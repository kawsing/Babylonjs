import {
  BoxBuilder,
  ClipboardEventTypes,
  ClipboardInfo,
  DynamicTexture,
  FadeInOutBehavior,
  Layer,
  LayerSceneComponent,
  PlaneBuilder,
  UtilityLayerRenderer
} from "./chunk-3NNWZ2WX.js";
import {
  Animatable,
  Animation,
  AnimationEvent,
  AnimationGroup,
  AnimationKeyInterpolation,
  AnimationRange,
  AssetContainer,
  BRDFTextureTools,
  Bone,
  CameraInputTypes,
  CameraInputsManager,
  CubeMapToSphericalPolynomialTools,
  CubeTexture,
  DataReader,
  Deferred,
  DirectionalLight,
  DracoCompression,
  EnvironmentTextureTools,
  FreeCamera,
  FreeCameraInputsManager,
  FreeCameraKeyboardMoveInput,
  FreeCameraMouseInput,
  FreeCameraMouseWheelInput,
  FreeCameraTouchInput,
  InstantiatedEntries,
  KeepAssets,
  MorphTarget,
  MorphTargetManager,
  PBRBaseMaterial,
  PBRClearCoatConfiguration,
  PBRMaterial,
  PBRMaterialDefines,
  PointLight,
  PostProcess,
  RGBDTextureTools,
  RawCubeTexture,
  RawTexture,
  RenderTargetTexture,
  RuntimeAnimation,
  SceneLoader,
  SceneLoaderAnimationGroupLoadingMode,
  ShaderMaterial,
  ShadowLight,
  Skeleton,
  Sound,
  SphericalHarmonics,
  SphericalPolynomial,
  SpotLight,
  TargetCamera,
  TargetedAnimation,
  WeightedSound,
  WorkerPool,
  _IAnimationState
} from "./chunk-KAF3XFTO.js";
import {
  AbstractActionManager,
  AbstractMesh,
  AbstractScene,
  ActionEvent,
  AlphaState,
  AndOrNotEvaluator,
  ArrayTools,
  AsyncLoop,
  Axis,
  BaseTexture,
  BoundingBox,
  BoundingInfo,
  BoundingSphere,
  Buffer,
  Camera,
  CanvasGenerator,
  Color3,
  Color4,
  ColorCurves,
  Constants,
  Coordinate,
  CopyTools,
  DataBuffer,
  DeepCopier,
  DepthCullingState,
  DomManagement,
  Effect,
  EffectFallbacks,
  Engine,
  EngineStore,
  Epsilon,
  EventState,
  FileTools,
  FilesInputStore,
  Frustum,
  GUID,
  Geometry,
  HemisphericLight,
  ImageProcessingConfiguration,
  ImageProcessingConfigurationDefines,
  InternalTexture,
  InternalTextureSource,
  IntersectionInfo,
  KeyboardEventTypes,
  KeyboardInfo,
  KeyboardInfoPre,
  Light,
  LoadFileError,
  Logger,
  Material,
  MaterialDefines,
  MaterialFlags,
  MaterialHelper,
  Matrix,
  Mesh,
  MeshLODLevel,
  MultiMaterial,
  MultiObserver,
  Node as Node2,
  Observable,
  Observer,
  PerfCounter,
  PerformanceConfigurator,
  PerformanceMonitor,
  PickingInfo,
  Plane,
  PointerEventTypes,
  PointerInfo,
  PointerInfoBase,
  PointerInfoPre,
  PostProcessManager,
  PrecisionDate,
  PromisePolyfill,
  PushMaterial,
  Quaternion,
  ReadFileError,
  RenderTargetCreationOptions,
  RenderingGroup,
  RenderingGroupInfo,
  RenderingManager,
  RequestFileError,
  RetryStrategy,
  RollingAverage,
  Scalar,
  Scene,
  SceneComponentConstants,
  SceneLoaderFlags,
  SerializationHelper,
  Size,
  SmartArray,
  SmartArrayNoDuplicate,
  Space,
  Stage,
  StandardMaterial,
  StandardMaterialDefines,
  StencilState,
  StringDictionary,
  StringTools,
  SubMesh,
  Tags,
  Texture,
  ThinEngine,
  ThinMaterialHelper,
  TimingTools,
  TmpColors,
  TmpVectors,
  ToGammaSpace,
  ToLinearSpace,
  Tools,
  TransformNode,
  UniformBuffer,
  UniqueIdGenerator,
  Vector2,
  Vector3,
  Vector4,
  VertexBuffer,
  VertexData,
  Viewport,
  WebGL2ShaderProcessor,
  WebGLDataBuffer,
  WebGLPipelineContext,
  WebRequest,
  _CreationDataStorage,
  _DevTools,
  _InstancesBatch,
  _MeshCollisionData,
  _TypeStore,
  __assign,
  __awaiter,
  __decorate,
  __extends,
  __generator,
  __spreadArrays,
  className,
  expandToProperty,
  extractMinAndMax,
  extractMinAndMaxIndexed,
  serialize,
  serializeAsCameraReference,
  serializeAsColor3,
  serializeAsColor4,
  serializeAsColorCurves,
  serializeAsFresnelParameters,
  serializeAsImageProcessingConfiguration,
  serializeAsMatrix,
  serializeAsMeshReference,
  serializeAsQuaternion,
  serializeAsTexture,
  serializeAsVector2,
  serializeAsVector3
} from "./chunk-FSGEGJV4.js";

// node_modules/@babylonjs/core/Actions/action.js
var Action = function() {
  function Action2(triggerOptions, condition) {
    this.triggerOptions = triggerOptions;
    this.onBeforeExecuteObservable = new Observable();
    if (triggerOptions.parameter) {
      this.trigger = triggerOptions.trigger;
      this._triggerParameter = triggerOptions.parameter;
    } else if (triggerOptions.trigger) {
      this.trigger = triggerOptions.trigger;
    } else {
      this.trigger = triggerOptions;
    }
    this._nextActiveAction = this;
    this._condition = condition;
  }
  Action2.prototype._prepare = function() {
  };
  Action2.prototype.getTriggerParameter = function() {
    return this._triggerParameter;
  };
  Action2.prototype._executeCurrent = function(evt) {
    if (this._nextActiveAction._condition) {
      var condition = this._nextActiveAction._condition;
      var currentRenderId = this._actionManager.getScene().getRenderId();
      if (condition._evaluationId === currentRenderId) {
        if (!condition._currentResult) {
          return;
        }
      } else {
        condition._evaluationId = currentRenderId;
        if (!condition.isValid()) {
          condition._currentResult = false;
          return;
        }
        condition._currentResult = true;
      }
    }
    this.onBeforeExecuteObservable.notifyObservers(this);
    this._nextActiveAction.execute(evt);
    this.skipToNextActiveAction();
  };
  Action2.prototype.execute = function(evt) {
  };
  Action2.prototype.skipToNextActiveAction = function() {
    if (this._nextActiveAction._child) {
      if (!this._nextActiveAction._child._actionManager) {
        this._nextActiveAction._child._actionManager = this._actionManager;
      }
      this._nextActiveAction = this._nextActiveAction._child;
    } else {
      this._nextActiveAction = this;
    }
  };
  Action2.prototype.then = function(action) {
    this._child = action;
    action._actionManager = this._actionManager;
    action._prepare();
    return action;
  };
  Action2.prototype._getProperty = function(propertyPath) {
    return this._actionManager._getProperty(propertyPath);
  };
  Action2.prototype._getEffectiveTarget = function(target, propertyPath) {
    return this._actionManager._getEffectiveTarget(target, propertyPath);
  };
  Action2.prototype.serialize = function(parent) {
  };
  Action2.prototype._serialize = function(serializedAction, parent) {
    var serializationObject = {
      type: 1,
      children: [],
      name: serializedAction.name,
      properties: serializedAction.properties || []
    };
    if (this._child) {
      this._child.serialize(serializationObject);
    }
    if (this._condition) {
      var serializedCondition = this._condition.serialize();
      serializedCondition.children.push(serializationObject);
      if (parent) {
        parent.children.push(serializedCondition);
      }
      return serializedCondition;
    }
    if (parent) {
      parent.children.push(serializationObject);
    }
    return serializationObject;
  };
  Action2._SerializeValueAsString = function(value) {
    if (typeof value === "number") {
      return value.toString();
    }
    if (typeof value === "boolean") {
      return value ? "true" : "false";
    }
    if (value instanceof Vector2) {
      return value.x + ", " + value.y;
    }
    if (value instanceof Vector3) {
      return value.x + ", " + value.y + ", " + value.z;
    }
    if (value instanceof Color3) {
      return value.r + ", " + value.g + ", " + value.b;
    }
    if (value instanceof Color4) {
      return value.r + ", " + value.g + ", " + value.b + ", " + value.a;
    }
    return value;
  };
  Action2._GetTargetProperty = function(target) {
    return {
      name: "target",
      targetType: target._isMesh ? "MeshProperties" : target._isLight ? "LightProperties" : target._isCamera ? "CameraProperties" : "SceneProperties",
      value: target._isScene ? "Scene" : target.name
    };
  };
  return Action2;
}();
_TypeStore.RegisteredTypes["BABYLON.Action"] = Action;

// node_modules/@babylonjs/core/Actions/condition.js
var Condition = function() {
  function Condition2(actionManager) {
    this._actionManager = actionManager;
  }
  Condition2.prototype.isValid = function() {
    return true;
  };
  Condition2.prototype._getProperty = function(propertyPath) {
    return this._actionManager._getProperty(propertyPath);
  };
  Condition2.prototype._getEffectiveTarget = function(target, propertyPath) {
    return this._actionManager._getEffectiveTarget(target, propertyPath);
  };
  Condition2.prototype.serialize = function() {
  };
  Condition2.prototype._serialize = function(serializedCondition) {
    return {
      type: 2,
      children: [],
      name: serializedCondition.name,
      properties: serializedCondition.properties
    };
  };
  return Condition2;
}();
var ValueCondition = function(_super) {
  __extends(ValueCondition2, _super);
  function ValueCondition2(actionManager, target, propertyPath, value, operator) {
    if (operator === void 0) {
      operator = ValueCondition2.IsEqual;
    }
    var _this = _super.call(this, actionManager) || this;
    _this.propertyPath = propertyPath;
    _this.value = value;
    _this.operator = operator;
    _this._target = target;
    _this._effectiveTarget = _this._getEffectiveTarget(target, _this.propertyPath);
    _this._property = _this._getProperty(_this.propertyPath);
    return _this;
  }
  Object.defineProperty(ValueCondition2, "IsEqual", {
    get: function() {
      return ValueCondition2._IsEqual;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ValueCondition2, "IsDifferent", {
    get: function() {
      return ValueCondition2._IsDifferent;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ValueCondition2, "IsGreater", {
    get: function() {
      return ValueCondition2._IsGreater;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ValueCondition2, "IsLesser", {
    get: function() {
      return ValueCondition2._IsLesser;
    },
    enumerable: false,
    configurable: true
  });
  ValueCondition2.prototype.isValid = function() {
    switch (this.operator) {
      case ValueCondition2.IsGreater:
        return this._effectiveTarget[this._property] > this.value;
      case ValueCondition2.IsLesser:
        return this._effectiveTarget[this._property] < this.value;
      case ValueCondition2.IsEqual:
      case ValueCondition2.IsDifferent:
        var check;
        if (this.value.equals) {
          check = this.value.equals(this._effectiveTarget[this._property]);
        } else {
          check = this.value === this._effectiveTarget[this._property];
        }
        return this.operator === ValueCondition2.IsEqual ? check : !check;
    }
    return false;
  };
  ValueCondition2.prototype.serialize = function() {
    return this._serialize({
      name: "ValueCondition",
      properties: [
        Action._GetTargetProperty(this._target),
        { name: "propertyPath", value: this.propertyPath },
        { name: "value", value: Action._SerializeValueAsString(this.value) },
        { name: "operator", value: ValueCondition2.GetOperatorName(this.operator) }
      ]
    });
  };
  ValueCondition2.GetOperatorName = function(operator) {
    switch (operator) {
      case ValueCondition2._IsEqual:
        return "IsEqual";
      case ValueCondition2._IsDifferent:
        return "IsDifferent";
      case ValueCondition2._IsGreater:
        return "IsGreater";
      case ValueCondition2._IsLesser:
        return "IsLesser";
      default:
        return "";
    }
  };
  ValueCondition2._IsEqual = 0;
  ValueCondition2._IsDifferent = 1;
  ValueCondition2._IsGreater = 2;
  ValueCondition2._IsLesser = 3;
  return ValueCondition2;
}(Condition);
var PredicateCondition = function(_super) {
  __extends(PredicateCondition2, _super);
  function PredicateCondition2(actionManager, predicate) {
    var _this = _super.call(this, actionManager) || this;
    _this.predicate = predicate;
    return _this;
  }
  PredicateCondition2.prototype.isValid = function() {
    return this.predicate();
  };
  return PredicateCondition2;
}(Condition);
var StateCondition = function(_super) {
  __extends(StateCondition2, _super);
  function StateCondition2(actionManager, target, value) {
    var _this = _super.call(this, actionManager) || this;
    _this.value = value;
    _this._target = target;
    return _this;
  }
  StateCondition2.prototype.isValid = function() {
    return this._target.state === this.value;
  };
  StateCondition2.prototype.serialize = function() {
    return this._serialize({
      name: "StateCondition",
      properties: [
        Action._GetTargetProperty(this._target),
        { name: "value", value: this.value }
      ]
    });
  };
  return StateCondition2;
}(Condition);
_TypeStore.RegisteredTypes["BABYLON.ValueCondition"] = ValueCondition;
_TypeStore.RegisteredTypes["BABYLON.PredicateCondition"] = PredicateCondition;
_TypeStore.RegisteredTypes["BABYLON.StateCondition"] = StateCondition;

// node_modules/@babylonjs/core/Actions/directActions.js
var SwitchBooleanAction = function(_super) {
  __extends(SwitchBooleanAction2, _super);
  function SwitchBooleanAction2(triggerOptions, target, propertyPath, condition) {
    var _this = _super.call(this, triggerOptions, condition) || this;
    _this.propertyPath = propertyPath;
    _this._target = _this._effectiveTarget = target;
    return _this;
  }
  SwitchBooleanAction2.prototype._prepare = function() {
    this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath);
    this._property = this._getProperty(this.propertyPath);
  };
  SwitchBooleanAction2.prototype.execute = function() {
    this._effectiveTarget[this._property] = !this._effectiveTarget[this._property];
  };
  SwitchBooleanAction2.prototype.serialize = function(parent) {
    return _super.prototype._serialize.call(this, {
      name: "SwitchBooleanAction",
      properties: [
        Action._GetTargetProperty(this._target),
        { name: "propertyPath", value: this.propertyPath }
      ]
    }, parent);
  };
  return SwitchBooleanAction2;
}(Action);
var SetStateAction = function(_super) {
  __extends(SetStateAction2, _super);
  function SetStateAction2(triggerOptions, target, value, condition) {
    var _this = _super.call(this, triggerOptions, condition) || this;
    _this.value = value;
    _this._target = target;
    return _this;
  }
  SetStateAction2.prototype.execute = function() {
    this._target.state = this.value;
  };
  SetStateAction2.prototype.serialize = function(parent) {
    return _super.prototype._serialize.call(this, {
      name: "SetStateAction",
      properties: [
        Action._GetTargetProperty(this._target),
        { name: "value", value: this.value }
      ]
    }, parent);
  };
  return SetStateAction2;
}(Action);
var SetValueAction = function(_super) {
  __extends(SetValueAction2, _super);
  function SetValueAction2(triggerOptions, target, propertyPath, value, condition) {
    var _this = _super.call(this, triggerOptions, condition) || this;
    _this.propertyPath = propertyPath;
    _this.value = value;
    _this._target = _this._effectiveTarget = target;
    return _this;
  }
  SetValueAction2.prototype._prepare = function() {
    this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath);
    this._property = this._getProperty(this.propertyPath);
  };
  SetValueAction2.prototype.execute = function() {
    this._effectiveTarget[this._property] = this.value;
    if (this._target.markAsDirty) {
      this._target.markAsDirty(this._property);
    }
  };
  SetValueAction2.prototype.serialize = function(parent) {
    return _super.prototype._serialize.call(this, {
      name: "SetValueAction",
      properties: [
        Action._GetTargetProperty(this._target),
        { name: "propertyPath", value: this.propertyPath },
        { name: "value", value: Action._SerializeValueAsString(this.value) }
      ]
    }, parent);
  };
  return SetValueAction2;
}(Action);
var IncrementValueAction = function(_super) {
  __extends(IncrementValueAction2, _super);
  function IncrementValueAction2(triggerOptions, target, propertyPath, value, condition) {
    var _this = _super.call(this, triggerOptions, condition) || this;
    _this.propertyPath = propertyPath;
    _this.value = value;
    _this._target = _this._effectiveTarget = target;
    return _this;
  }
  IncrementValueAction2.prototype._prepare = function() {
    this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath);
    this._property = this._getProperty(this.propertyPath);
    if (typeof this._effectiveTarget[this._property] !== "number") {
      Logger.Warn("Warning: IncrementValueAction can only be used with number values");
    }
  };
  IncrementValueAction2.prototype.execute = function() {
    this._effectiveTarget[this._property] += this.value;
    if (this._target.markAsDirty) {
      this._target.markAsDirty(this._property);
    }
  };
  IncrementValueAction2.prototype.serialize = function(parent) {
    return _super.prototype._serialize.call(this, {
      name: "IncrementValueAction",
      properties: [
        Action._GetTargetProperty(this._target),
        { name: "propertyPath", value: this.propertyPath },
        { name: "value", value: Action._SerializeValueAsString(this.value) }
      ]
    }, parent);
  };
  return IncrementValueAction2;
}(Action);
var PlayAnimationAction = function(_super) {
  __extends(PlayAnimationAction2, _super);
  function PlayAnimationAction2(triggerOptions, target, from, to, loop, condition) {
    var _this = _super.call(this, triggerOptions, condition) || this;
    _this.from = from;
    _this.to = to;
    _this.loop = loop;
    _this._target = target;
    return _this;
  }
  PlayAnimationAction2.prototype._prepare = function() {
  };
  PlayAnimationAction2.prototype.execute = function() {
    var scene = this._actionManager.getScene();
    scene.beginAnimation(this._target, this.from, this.to, this.loop);
  };
  PlayAnimationAction2.prototype.serialize = function(parent) {
    return _super.prototype._serialize.call(this, {
      name: "PlayAnimationAction",
      properties: [
        Action._GetTargetProperty(this._target),
        { name: "from", value: String(this.from) },
        { name: "to", value: String(this.to) },
        { name: "loop", value: Action._SerializeValueAsString(this.loop) || false }
      ]
    }, parent);
  };
  return PlayAnimationAction2;
}(Action);
var StopAnimationAction = function(_super) {
  __extends(StopAnimationAction2, _super);
  function StopAnimationAction2(triggerOptions, target, condition) {
    var _this = _super.call(this, triggerOptions, condition) || this;
    _this._target = target;
    return _this;
  }
  StopAnimationAction2.prototype._prepare = function() {
  };
  StopAnimationAction2.prototype.execute = function() {
    var scene = this._actionManager.getScene();
    scene.stopAnimation(this._target);
  };
  StopAnimationAction2.prototype.serialize = function(parent) {
    return _super.prototype._serialize.call(this, {
      name: "StopAnimationAction",
      properties: [Action._GetTargetProperty(this._target)]
    }, parent);
  };
  return StopAnimationAction2;
}(Action);
var DoNothingAction = function(_super) {
  __extends(DoNothingAction2, _super);
  function DoNothingAction2(triggerOptions, condition) {
    if (triggerOptions === void 0) {
      triggerOptions = 0;
    }
    return _super.call(this, triggerOptions, condition) || this;
  }
  DoNothingAction2.prototype.execute = function() {
  };
  DoNothingAction2.prototype.serialize = function(parent) {
    return _super.prototype._serialize.call(this, {
      name: "DoNothingAction",
      properties: []
    }, parent);
  };
  return DoNothingAction2;
}(Action);
var CombineAction = function(_super) {
  __extends(CombineAction2, _super);
  function CombineAction2(triggerOptions, children, condition) {
    var _this = _super.call(this, triggerOptions, condition) || this;
    _this.children = children;
    return _this;
  }
  CombineAction2.prototype._prepare = function() {
    for (var index = 0; index < this.children.length; index++) {
      this.children[index]._actionManager = this._actionManager;
      this.children[index]._prepare();
    }
  };
  CombineAction2.prototype.execute = function(evt) {
    for (var index = 0; index < this.children.length; index++) {
      this.children[index].execute(evt);
    }
  };
  CombineAction2.prototype.serialize = function(parent) {
    var serializationObject = _super.prototype._serialize.call(this, {
      name: "CombineAction",
      properties: [],
      combine: []
    }, parent);
    for (var i = 0; i < this.children.length; i++) {
      serializationObject.combine.push(this.children[i].serialize(null));
    }
    return serializationObject;
  };
  return CombineAction2;
}(Action);
var ExecuteCodeAction = function(_super) {
  __extends(ExecuteCodeAction2, _super);
  function ExecuteCodeAction2(triggerOptions, func, condition) {
    var _this = _super.call(this, triggerOptions, condition) || this;
    _this.func = func;
    return _this;
  }
  ExecuteCodeAction2.prototype.execute = function(evt) {
    this.func(evt);
  };
  return ExecuteCodeAction2;
}(Action);
var SetParentAction = function(_super) {
  __extends(SetParentAction2, _super);
  function SetParentAction2(triggerOptions, target, parent, condition) {
    var _this = _super.call(this, triggerOptions, condition) || this;
    _this._target = target;
    _this._parent = parent;
    return _this;
  }
  SetParentAction2.prototype._prepare = function() {
  };
  SetParentAction2.prototype.execute = function() {
    if (this._target.parent === this._parent) {
      return;
    }
    var invertParentWorldMatrix = this._parent.getWorldMatrix().clone();
    invertParentWorldMatrix.invert();
    this._target.position = Vector3.TransformCoordinates(this._target.position, invertParentWorldMatrix);
    this._target.parent = this._parent;
  };
  SetParentAction2.prototype.serialize = function(parent) {
    return _super.prototype._serialize.call(this, {
      name: "SetParentAction",
      properties: [
        Action._GetTargetProperty(this._target),
        Action._GetTargetProperty(this._parent)
      ]
    }, parent);
  };
  return SetParentAction2;
}(Action);
_TypeStore.RegisteredTypes["BABYLON.SetParentAction"] = SetParentAction;
_TypeStore.RegisteredTypes["BABYLON.ExecuteCodeAction"] = ExecuteCodeAction;
_TypeStore.RegisteredTypes["BABYLON.DoNothingAction"] = DoNothingAction;
_TypeStore.RegisteredTypes["BABYLON.StopAnimationAction"] = StopAnimationAction;
_TypeStore.RegisteredTypes["BABYLON.PlayAnimationAction"] = PlayAnimationAction;
_TypeStore.RegisteredTypes["BABYLON.IncrementValueAction"] = IncrementValueAction;
_TypeStore.RegisteredTypes["BABYLON.SetValueAction"] = SetValueAction;
_TypeStore.RegisteredTypes["BABYLON.SetStateAction"] = SetStateAction;
_TypeStore.RegisteredTypes["BABYLON.SetParentAction"] = SetParentAction;

// node_modules/@babylonjs/core/Actions/actionManager.js
var ActionManager = function(_super) {
  __extends(ActionManager2, _super);
  function ActionManager2(scene) {
    var _this = _super.call(this) || this;
    _this._scene = scene || EngineStore.LastCreatedScene;
    scene.actionManagers.push(_this);
    return _this;
  }
  ActionManager2.prototype.dispose = function() {
    var index = this._scene.actionManagers.indexOf(this);
    for (var i = 0; i < this.actions.length; i++) {
      var action = this.actions[i];
      ActionManager2.Triggers[action.trigger]--;
      if (ActionManager2.Triggers[action.trigger] === 0) {
        delete ActionManager2.Triggers[action.trigger];
      }
    }
    if (index > -1) {
      this._scene.actionManagers.splice(index, 1);
    }
  };
  ActionManager2.prototype.getScene = function() {
    return this._scene;
  };
  ActionManager2.prototype.hasSpecificTriggers = function(triggers) {
    for (var index = 0; index < this.actions.length; index++) {
      var action = this.actions[index];
      if (triggers.indexOf(action.trigger) > -1) {
        return true;
      }
    }
    return false;
  };
  ActionManager2.prototype.hasSpecificTriggers2 = function(triggerA, triggerB) {
    for (var index = 0; index < this.actions.length; index++) {
      var action = this.actions[index];
      if (triggerA == action.trigger || triggerB == action.trigger) {
        return true;
      }
    }
    return false;
  };
  ActionManager2.prototype.hasSpecificTrigger = function(trigger, parameterPredicate) {
    for (var index = 0; index < this.actions.length; index++) {
      var action = this.actions[index];
      if (action.trigger === trigger) {
        if (parameterPredicate) {
          if (parameterPredicate(action.getTriggerParameter())) {
            return true;
          }
        } else {
          return true;
        }
      }
    }
    return false;
  };
  Object.defineProperty(ActionManager2.prototype, "hasPointerTriggers", {
    get: function() {
      for (var index = 0; index < this.actions.length; index++) {
        var action = this.actions[index];
        if (action.trigger >= ActionManager2.OnPickTrigger && action.trigger <= ActionManager2.OnPointerOutTrigger) {
          return true;
        }
      }
      return false;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ActionManager2.prototype, "hasPickTriggers", {
    get: function() {
      for (var index = 0; index < this.actions.length; index++) {
        var action = this.actions[index];
        if (action.trigger >= ActionManager2.OnPickTrigger && action.trigger <= ActionManager2.OnPickUpTrigger) {
          return true;
        }
      }
      return false;
    },
    enumerable: false,
    configurable: true
  });
  ActionManager2.prototype.registerAction = function(action) {
    if (action.trigger === ActionManager2.OnEveryFrameTrigger) {
      if (this.getScene().actionManager !== this) {
        Logger.Warn("OnEveryFrameTrigger can only be used with scene.actionManager");
        return null;
      }
    }
    this.actions.push(action);
    if (ActionManager2.Triggers[action.trigger]) {
      ActionManager2.Triggers[action.trigger]++;
    } else {
      ActionManager2.Triggers[action.trigger] = 1;
    }
    action._actionManager = this;
    action._prepare();
    return action;
  };
  ActionManager2.prototype.unregisterAction = function(action) {
    var index = this.actions.indexOf(action);
    if (index !== -1) {
      this.actions.splice(index, 1);
      ActionManager2.Triggers[action.trigger] -= 1;
      if (ActionManager2.Triggers[action.trigger] === 0) {
        delete ActionManager2.Triggers[action.trigger];
      }
      action._actionManager = null;
      return true;
    }
    return false;
  };
  ActionManager2.prototype.processTrigger = function(trigger, evt) {
    for (var index = 0; index < this.actions.length; index++) {
      var action = this.actions[index];
      if (action.trigger === trigger) {
        if (evt) {
          if (trigger === ActionManager2.OnKeyUpTrigger || trigger === ActionManager2.OnKeyDownTrigger) {
            var parameter = action.getTriggerParameter();
            if (parameter && parameter !== evt.sourceEvent.keyCode) {
              if (!parameter.toLowerCase) {
                continue;
              }
              var lowerCase = parameter.toLowerCase();
              if (lowerCase !== evt.sourceEvent.key) {
                var unicode = evt.sourceEvent.charCode ? evt.sourceEvent.charCode : evt.sourceEvent.keyCode;
                var actualkey = String.fromCharCode(unicode).toLowerCase();
                if (actualkey !== lowerCase) {
                  continue;
                }
              }
            }
          }
        }
        action._executeCurrent(evt);
      }
    }
  };
  ActionManager2.prototype._getEffectiveTarget = function(target, propertyPath) {
    var properties = propertyPath.split(".");
    for (var index = 0; index < properties.length - 1; index++) {
      target = target[properties[index]];
    }
    return target;
  };
  ActionManager2.prototype._getProperty = function(propertyPath) {
    var properties = propertyPath.split(".");
    return properties[properties.length - 1];
  };
  ActionManager2.prototype.serialize = function(name98) {
    var root = {
      children: new Array(),
      name: name98,
      type: 3,
      properties: new Array()
    };
    for (var i = 0; i < this.actions.length; i++) {
      var triggerObject = {
        type: 0,
        children: new Array(),
        name: ActionManager2.GetTriggerName(this.actions[i].trigger),
        properties: new Array()
      };
      var triggerOptions = this.actions[i].triggerOptions;
      if (triggerOptions && typeof triggerOptions !== "number") {
        if (triggerOptions.parameter instanceof Node) {
          triggerObject.properties.push(Action._GetTargetProperty(triggerOptions.parameter));
        } else {
          var parameter = {};
          DeepCopier.DeepCopy(triggerOptions.parameter, parameter, ["mesh"]);
          if (triggerOptions.parameter && triggerOptions.parameter.mesh) {
            parameter._meshId = triggerOptions.parameter.mesh.id;
          }
          triggerObject.properties.push({ name: "parameter", targetType: null, value: parameter });
        }
      }
      this.actions[i].serialize(triggerObject);
      root.children.push(triggerObject);
    }
    return root;
  };
  ActionManager2.Parse = function(parsedActions, object, scene) {
    var actionManager = new ActionManager2(scene);
    if (object === null) {
      scene.actionManager = actionManager;
    } else {
      object.actionManager = actionManager;
    }
    var instanciate = function(name98, params) {
      var internalClassType = _TypeStore.GetClass("BABYLON." + name98);
      if (internalClassType) {
        var newInstance = Object.create(internalClassType.prototype);
        newInstance.constructor.apply(newInstance, params);
        return newInstance;
      }
    };
    var parseParameter = function(name98, value2, target, propertyPath) {
      if (propertyPath === null) {
        var floatValue = parseFloat(value2);
        if (value2 === "true" || value2 === "false") {
          return value2 === "true";
        } else {
          return isNaN(floatValue) ? value2 : floatValue;
        }
      }
      var effectiveTarget = propertyPath.split(".");
      var values = value2.split(",");
      for (var i2 = 0; i2 < effectiveTarget.length; i2++) {
        target = target[effectiveTarget[i2]];
      }
      if (typeof target === "boolean") {
        return values[0] === "true";
      }
      if (typeof target === "string") {
        return values[0];
      }
      var split = new Array();
      for (var i2 = 0; i2 < values.length; i2++) {
        split.push(parseFloat(values[i2]));
      }
      if (target instanceof Vector3) {
        return Vector3.FromArray(split);
      }
      if (target instanceof Vector4) {
        return Vector4.FromArray(split);
      }
      if (target instanceof Color3) {
        return Color3.FromArray(split);
      }
      if (target instanceof Color4) {
        return Color4.FromArray(split);
      }
      return parseFloat(values[0]);
    };
    var traverse = function(parsedAction, trigger2, condition, action, combineArray) {
      if (combineArray === void 0) {
        combineArray = null;
      }
      if (parsedAction.detached) {
        return;
      }
      var parameters = new Array();
      var target = null;
      var propertyPath = null;
      var combine = parsedAction.combine && parsedAction.combine.length > 0;
      if (parsedAction.type === 2) {
        parameters.push(actionManager);
      } else {
        parameters.push(trigger2);
      }
      if (combine) {
        var actions = new Array();
        for (var j2 = 0; j2 < parsedAction.combine.length; j2++) {
          traverse(parsedAction.combine[j2], ActionManager2.NothingTrigger, condition, action, actions);
        }
        parameters.push(actions);
      } else {
        for (var i2 = 0; i2 < parsedAction.properties.length; i2++) {
          var value2 = parsedAction.properties[i2].value;
          var name98 = parsedAction.properties[i2].name;
          var targetType = parsedAction.properties[i2].targetType;
          if (name98 === "target") {
            if (targetType !== null && targetType === "SceneProperties") {
              value2 = target = scene;
            } else {
              value2 = target = scene.getNodeByName(value2);
            }
          } else if (name98 === "parent") {
            value2 = scene.getNodeByName(value2);
          } else if (name98 === "sound") {
            if (scene.getSoundByName) {
              value2 = scene.getSoundByName(value2);
            }
          } else if (name98 !== "propertyPath") {
            if (parsedAction.type === 2 && name98 === "operator") {
              value2 = ValueCondition[value2];
            } else {
              value2 = parseParameter(name98, value2, target, name98 === "value" ? propertyPath : null);
            }
          } else {
            propertyPath = value2;
          }
          parameters.push(value2);
        }
      }
      if (combineArray === null) {
        parameters.push(condition);
      } else {
        parameters.push(null);
      }
      if (parsedAction.name === "InterpolateValueAction") {
        var param2 = parameters[parameters.length - 2];
        parameters[parameters.length - 1] = param2;
        parameters[parameters.length - 2] = condition;
      }
      var newAction = instanciate(parsedAction.name, parameters);
      if (newAction instanceof Condition && condition !== null) {
        var nothing = new DoNothingAction(trigger2, condition);
        if (action) {
          action.then(nothing);
        } else {
          actionManager.registerAction(nothing);
        }
        action = nothing;
      }
      if (combineArray === null) {
        if (newAction instanceof Condition) {
          condition = newAction;
          newAction = action;
        } else {
          condition = null;
          if (action) {
            action.then(newAction);
          } else {
            actionManager.registerAction(newAction);
          }
        }
      } else {
        combineArray.push(newAction);
      }
      for (var i2 = 0; i2 < parsedAction.children.length; i2++) {
        traverse(parsedAction.children[i2], trigger2, condition, newAction, null);
      }
    };
    for (var i = 0; i < parsedActions.children.length; i++) {
      var triggerParams;
      var trigger = parsedActions.children[i];
      if (trigger.properties.length > 0) {
        var param = trigger.properties[0].value;
        var value = trigger.properties[0].targetType === null ? param : scene.getMeshByName(param);
        if (value._meshId) {
          value.mesh = scene.getMeshByID(value._meshId);
        }
        triggerParams = { trigger: ActionManager2[trigger.name], parameter: value };
      } else {
        triggerParams = ActionManager2[trigger.name];
      }
      for (var j = 0; j < trigger.children.length; j++) {
        if (!trigger.detached) {
          traverse(trigger.children[j], triggerParams, null, null);
        }
      }
    }
  };
  ActionManager2.GetTriggerName = function(trigger) {
    switch (trigger) {
      case 0:
        return "NothingTrigger";
      case 1:
        return "OnPickTrigger";
      case 2:
        return "OnLeftPickTrigger";
      case 3:
        return "OnRightPickTrigger";
      case 4:
        return "OnCenterPickTrigger";
      case 5:
        return "OnPickDownTrigger";
      case 6:
        return "OnPickUpTrigger";
      case 7:
        return "OnLongPressTrigger";
      case 8:
        return "OnPointerOverTrigger";
      case 9:
        return "OnPointerOutTrigger";
      case 10:
        return "OnEveryFrameTrigger";
      case 11:
        return "OnIntersectionEnterTrigger";
      case 12:
        return "OnIntersectionExitTrigger";
      case 13:
        return "OnKeyDownTrigger";
      case 14:
        return "OnKeyUpTrigger";
      case 15:
        return "OnPickOutTrigger";
      default:
        return "";
    }
  };
  ActionManager2.NothingTrigger = 0;
  ActionManager2.OnPickTrigger = 1;
  ActionManager2.OnLeftPickTrigger = 2;
  ActionManager2.OnRightPickTrigger = 3;
  ActionManager2.OnCenterPickTrigger = 4;
  ActionManager2.OnPickDownTrigger = 5;
  ActionManager2.OnDoublePickTrigger = 6;
  ActionManager2.OnPickUpTrigger = 7;
  ActionManager2.OnPickOutTrigger = 16;
  ActionManager2.OnLongPressTrigger = 8;
  ActionManager2.OnPointerOverTrigger = 9;
  ActionManager2.OnPointerOutTrigger = 10;
  ActionManager2.OnEveryFrameTrigger = 11;
  ActionManager2.OnIntersectionEnterTrigger = 12;
  ActionManager2.OnIntersectionExitTrigger = 13;
  ActionManager2.OnKeyDownTrigger = 14;
  ActionManager2.OnKeyUpTrigger = 15;
  return ActionManager2;
}(AbstractActionManager);

// node_modules/@babylonjs/core/Actions/directAudioActions.js
var PlaySoundAction = function(_super) {
  __extends(PlaySoundAction2, _super);
  function PlaySoundAction2(triggerOptions, sound, condition) {
    var _this = _super.call(this, triggerOptions, condition) || this;
    _this._sound = sound;
    return _this;
  }
  PlaySoundAction2.prototype._prepare = function() {
  };
  PlaySoundAction2.prototype.execute = function() {
    if (this._sound !== void 0) {
      this._sound.play();
    }
  };
  PlaySoundAction2.prototype.serialize = function(parent) {
    return _super.prototype._serialize.call(this, {
      name: "PlaySoundAction",
      properties: [{ name: "sound", value: this._sound.name }]
    }, parent);
  };
  return PlaySoundAction2;
}(Action);
var StopSoundAction = function(_super) {
  __extends(StopSoundAction2, _super);
  function StopSoundAction2(triggerOptions, sound, condition) {
    var _this = _super.call(this, triggerOptions, condition) || this;
    _this._sound = sound;
    return _this;
  }
  StopSoundAction2.prototype._prepare = function() {
  };
  StopSoundAction2.prototype.execute = function() {
    if (this._sound !== void 0) {
      this._sound.stop();
    }
  };
  StopSoundAction2.prototype.serialize = function(parent) {
    return _super.prototype._serialize.call(this, {
      name: "StopSoundAction",
      properties: [{ name: "sound", value: this._sound.name }]
    }, parent);
  };
  return StopSoundAction2;
}(Action);
_TypeStore.RegisteredTypes["BABYLON.PlaySoundAction"] = StopSoundAction;
_TypeStore.RegisteredTypes["BABYLON.StopSoundAction"] = StopSoundAction;

// node_modules/@babylonjs/core/Actions/interpolateValueAction.js
var InterpolateValueAction = function(_super) {
  __extends(InterpolateValueAction2, _super);
  function InterpolateValueAction2(triggerOptions, target, propertyPath, value, duration, condition, stopOtherAnimations, onInterpolationDone) {
    if (duration === void 0) {
      duration = 1e3;
    }
    var _this = _super.call(this, triggerOptions, condition) || this;
    _this.duration = 1e3;
    _this.onInterpolationDoneObservable = new Observable();
    _this.propertyPath = propertyPath;
    _this.value = value;
    _this.duration = duration;
    _this.stopOtherAnimations = stopOtherAnimations;
    _this.onInterpolationDone = onInterpolationDone;
    _this._target = _this._effectiveTarget = target;
    return _this;
  }
  InterpolateValueAction2.prototype._prepare = function() {
    this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath);
    this._property = this._getProperty(this.propertyPath);
  };
  InterpolateValueAction2.prototype.execute = function() {
    var _this = this;
    var scene = this._actionManager.getScene();
    var keys = [
      {
        frame: 0,
        value: this._effectiveTarget[this._property]
      },
      {
        frame: 100,
        value: this.value
      }
    ];
    var dataType;
    if (typeof this.value === "number") {
      dataType = Animation.ANIMATIONTYPE_FLOAT;
    } else if (this.value instanceof Color3) {
      dataType = Animation.ANIMATIONTYPE_COLOR3;
    } else if (this.value instanceof Vector3) {
      dataType = Animation.ANIMATIONTYPE_VECTOR3;
    } else if (this.value instanceof Matrix) {
      dataType = Animation.ANIMATIONTYPE_MATRIX;
    } else if (this.value instanceof Quaternion) {
      dataType = Animation.ANIMATIONTYPE_QUATERNION;
    } else {
      Logger.Warn("InterpolateValueAction: Unsupported type (" + typeof this.value + ")");
      return;
    }
    var animation = new Animation("InterpolateValueAction", this._property, 100 * (1e3 / this.duration), dataType, Animation.ANIMATIONLOOPMODE_CONSTANT);
    animation.setKeys(keys);
    if (this.stopOtherAnimations) {
      scene.stopAnimation(this._effectiveTarget);
    }
    var wrapper = function() {
      _this.onInterpolationDoneObservable.notifyObservers(_this);
      if (_this.onInterpolationDone) {
        _this.onInterpolationDone();
      }
    };
    scene.beginDirectAnimation(this._effectiveTarget, [animation], 0, 100, false, 1, wrapper);
  };
  InterpolateValueAction2.prototype.serialize = function(parent) {
    return _super.prototype._serialize.call(this, {
      name: "InterpolateValueAction",
      properties: [
        Action._GetTargetProperty(this._target),
        { name: "propertyPath", value: this.propertyPath },
        { name: "value", value: Action._SerializeValueAsString(this.value) },
        { name: "duration", value: Action._SerializeValueAsString(this.duration) },
        { name: "stopOtherAnimations", value: Action._SerializeValueAsString(this.stopOtherAnimations) || false }
      ]
    }, parent);
  };
  return InterpolateValueAction2;
}(Action);
_TypeStore.RegisteredTypes["BABYLON.InterpolateValueAction"] = InterpolateValueAction;

// node_modules/@babylonjs/core/Animations/animationPropertiesOverride.js
var AnimationPropertiesOverride = function() {
  function AnimationPropertiesOverride2() {
    this.enableBlending = false;
    this.blendingSpeed = 0.01;
    this.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE;
  }
  return AnimationPropertiesOverride2;
}();

// node_modules/@babylonjs/core/Maths/math.path.js
var Orientation;
(function(Orientation2) {
  Orientation2[Orientation2["CW"] = 0] = "CW";
  Orientation2[Orientation2["CCW"] = 1] = "CCW";
})(Orientation || (Orientation = {}));
var BezierCurve = function() {
  function BezierCurve2() {
  }
  BezierCurve2.Interpolate = function(t, x1, y1, x2, y2) {
    var f0 = 1 - 3 * x2 + 3 * x1;
    var f1 = 3 * x2 - 6 * x1;
    var f2 = 3 * x1;
    var refinedT = t;
    for (var i = 0; i < 5; i++) {
      var refinedT2 = refinedT * refinedT;
      var refinedT3 = refinedT2 * refinedT;
      var x = f0 * refinedT3 + f1 * refinedT2 + f2 * refinedT;
      var slope = 1 / (3 * f0 * refinedT2 + 2 * f1 * refinedT + f2);
      refinedT -= (x - t) * slope;
      refinedT = Math.min(1, Math.max(0, refinedT));
    }
    return 3 * Math.pow(1 - refinedT, 2) * refinedT * y1 + 3 * (1 - refinedT) * Math.pow(refinedT, 2) * y2 + Math.pow(refinedT, 3);
  };
  return BezierCurve2;
}();
var Angle = function() {
  function Angle2(radians) {
    this._radians = radians;
    if (this._radians < 0) {
      this._radians += 2 * Math.PI;
    }
  }
  Angle2.prototype.degrees = function() {
    return this._radians * 180 / Math.PI;
  };
  Angle2.prototype.radians = function() {
    return this._radians;
  };
  Angle2.BetweenTwoPoints = function(a, b) {
    var delta = b.subtract(a);
    var theta = Math.atan2(delta.y, delta.x);
    return new Angle2(theta);
  };
  Angle2.FromRadians = function(radians) {
    return new Angle2(radians);
  };
  Angle2.FromDegrees = function(degrees) {
    return new Angle2(degrees * Math.PI / 180);
  };
  return Angle2;
}();
var Arc2 = function() {
  function Arc22(startPoint, midPoint, endPoint) {
    this.startPoint = startPoint;
    this.midPoint = midPoint;
    this.endPoint = endPoint;
    var temp = Math.pow(midPoint.x, 2) + Math.pow(midPoint.y, 2);
    var startToMid = (Math.pow(startPoint.x, 2) + Math.pow(startPoint.y, 2) - temp) / 2;
    var midToEnd = (temp - Math.pow(endPoint.x, 2) - Math.pow(endPoint.y, 2)) / 2;
    var det = (startPoint.x - midPoint.x) * (midPoint.y - endPoint.y) - (midPoint.x - endPoint.x) * (startPoint.y - midPoint.y);
    this.centerPoint = new Vector2((startToMid * (midPoint.y - endPoint.y) - midToEnd * (startPoint.y - midPoint.y)) / det, ((startPoint.x - midPoint.x) * midToEnd - (midPoint.x - endPoint.x) * startToMid) / det);
    this.radius = this.centerPoint.subtract(this.startPoint).length();
    this.startAngle = Angle.BetweenTwoPoints(this.centerPoint, this.startPoint);
    var a1 = this.startAngle.degrees();
    var a2 = Angle.BetweenTwoPoints(this.centerPoint, this.midPoint).degrees();
    var a3 = Angle.BetweenTwoPoints(this.centerPoint, this.endPoint).degrees();
    if (a2 - a1 > 180) {
      a2 -= 360;
    }
    if (a2 - a1 < -180) {
      a2 += 360;
    }
    if (a3 - a2 > 180) {
      a3 -= 360;
    }
    if (a3 - a2 < -180) {
      a3 += 360;
    }
    this.orientation = a2 - a1 < 0 ? Orientation.CW : Orientation.CCW;
    this.angle = Angle.FromDegrees(this.orientation === Orientation.CW ? a1 - a3 : a3 - a1);
  }
  return Arc22;
}();
var Path2 = function() {
  function Path22(x, y) {
    this._points = new Array();
    this._length = 0;
    this.closed = false;
    this._points.push(new Vector2(x, y));
  }
  Path22.prototype.addLineTo = function(x, y) {
    if (this.closed) {
      return this;
    }
    var newPoint = new Vector2(x, y);
    var previousPoint = this._points[this._points.length - 1];
    this._points.push(newPoint);
    this._length += newPoint.subtract(previousPoint).length();
    return this;
  };
  Path22.prototype.addArcTo = function(midX, midY, endX, endY, numberOfSegments) {
    if (numberOfSegments === void 0) {
      numberOfSegments = 36;
    }
    if (this.closed) {
      return this;
    }
    var startPoint = this._points[this._points.length - 1];
    var midPoint = new Vector2(midX, midY);
    var endPoint = new Vector2(endX, endY);
    var arc = new Arc2(startPoint, midPoint, endPoint);
    var increment = arc.angle.radians() / numberOfSegments;
    if (arc.orientation === Orientation.CW) {
      increment *= -1;
    }
    var currentAngle = arc.startAngle.radians() + increment;
    for (var i = 0; i < numberOfSegments; i++) {
      var x = Math.cos(currentAngle) * arc.radius + arc.centerPoint.x;
      var y = Math.sin(currentAngle) * arc.radius + arc.centerPoint.y;
      this.addLineTo(x, y);
      currentAngle += increment;
    }
    return this;
  };
  Path22.prototype.close = function() {
    this.closed = true;
    return this;
  };
  Path22.prototype.length = function() {
    var result = this._length;
    if (this.closed) {
      var lastPoint = this._points[this._points.length - 1];
      var firstPoint = this._points[0];
      result += firstPoint.subtract(lastPoint).length();
    }
    return result;
  };
  Path22.prototype.getPoints = function() {
    return this._points;
  };
  Path22.prototype.getPointAtLengthPosition = function(normalizedLengthPosition) {
    if (normalizedLengthPosition < 0 || normalizedLengthPosition > 1) {
      return Vector2.Zero();
    }
    var lengthPosition = normalizedLengthPosition * this.length();
    var previousOffset = 0;
    for (var i = 0; i < this._points.length; i++) {
      var j = (i + 1) % this._points.length;
      var a = this._points[i];
      var b = this._points[j];
      var bToA = b.subtract(a);
      var nextOffset = bToA.length() + previousOffset;
      if (lengthPosition >= previousOffset && lengthPosition <= nextOffset) {
        var dir = bToA.normalize();
        var localOffset = lengthPosition - previousOffset;
        return new Vector2(a.x + dir.x * localOffset, a.y + dir.y * localOffset);
      }
      previousOffset = nextOffset;
    }
    return Vector2.Zero();
  };
  Path22.StartingAt = function(x, y) {
    return new Path22(x, y);
  };
  return Path22;
}();
var Path3D = function() {
  function Path3D2(path, firstNormal, raw, alignTangentsWithPath) {
    if (firstNormal === void 0) {
      firstNormal = null;
    }
    if (alignTangentsWithPath === void 0) {
      alignTangentsWithPath = false;
    }
    this.path = path;
    this._curve = new Array();
    this._distances = new Array();
    this._tangents = new Array();
    this._normals = new Array();
    this._binormals = new Array();
    this._pointAtData = {
      id: 0,
      point: Vector3.Zero(),
      previousPointArrayIndex: 0,
      position: 0,
      subPosition: 0,
      interpolateReady: false,
      interpolationMatrix: Matrix.Identity()
    };
    for (var p = 0; p < path.length; p++) {
      this._curve[p] = path[p].clone();
    }
    this._raw = raw || false;
    this._alignTangentsWithPath = alignTangentsWithPath;
    this._compute(firstNormal, alignTangentsWithPath);
  }
  Path3D2.prototype.getCurve = function() {
    return this._curve;
  };
  Path3D2.prototype.getPoints = function() {
    return this._curve;
  };
  Path3D2.prototype.length = function() {
    return this._distances[this._distances.length - 1];
  };
  Path3D2.prototype.getTangents = function() {
    return this._tangents;
  };
  Path3D2.prototype.getNormals = function() {
    return this._normals;
  };
  Path3D2.prototype.getBinormals = function() {
    return this._binormals;
  };
  Path3D2.prototype.getDistances = function() {
    return this._distances;
  };
  Path3D2.prototype.getPointAt = function(position) {
    return this._updatePointAtData(position).point;
  };
  Path3D2.prototype.getTangentAt = function(position, interpolated) {
    if (interpolated === void 0) {
      interpolated = false;
    }
    this._updatePointAtData(position, interpolated);
    return interpolated ? Vector3.TransformCoordinates(Vector3.Forward(), this._pointAtData.interpolationMatrix) : this._tangents[this._pointAtData.previousPointArrayIndex];
  };
  Path3D2.prototype.getNormalAt = function(position, interpolated) {
    if (interpolated === void 0) {
      interpolated = false;
    }
    this._updatePointAtData(position, interpolated);
    return interpolated ? Vector3.TransformCoordinates(Vector3.Right(), this._pointAtData.interpolationMatrix) : this._normals[this._pointAtData.previousPointArrayIndex];
  };
  Path3D2.prototype.getBinormalAt = function(position, interpolated) {
    if (interpolated === void 0) {
      interpolated = false;
    }
    this._updatePointAtData(position, interpolated);
    return interpolated ? Vector3.TransformCoordinates(Vector3.UpReadOnly, this._pointAtData.interpolationMatrix) : this._binormals[this._pointAtData.previousPointArrayIndex];
  };
  Path3D2.prototype.getDistanceAt = function(position) {
    return this.length() * position;
  };
  Path3D2.prototype.getPreviousPointIndexAt = function(position) {
    this._updatePointAtData(position);
    return this._pointAtData.previousPointArrayIndex;
  };
  Path3D2.prototype.getSubPositionAt = function(position) {
    this._updatePointAtData(position);
    return this._pointAtData.subPosition;
  };
  Path3D2.prototype.getClosestPositionTo = function(target) {
    var smallestDistance = Number.MAX_VALUE;
    var closestPosition = 0;
    for (var i = 0; i < this._curve.length - 1; i++) {
      var point = this._curve[i + 0];
      var tangent = this._curve[i + 1].subtract(point).normalize();
      var subLength = this._distances[i + 1] - this._distances[i + 0];
      var subPosition = Math.min(Math.max(Vector3.Dot(tangent, target.subtract(point).normalize()), 0) * Vector3.Distance(point, target) / subLength, 1);
      var distance = Vector3.Distance(point.add(tangent.scale(subPosition * subLength)), target);
      if (distance < smallestDistance) {
        smallestDistance = distance;
        closestPosition = (this._distances[i + 0] + subLength * subPosition) / this.length();
      }
    }
    return closestPosition;
  };
  Path3D2.prototype.slice = function(start, end) {
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = 1;
    }
    if (start < 0) {
      start = 1 - start * -1 % 1;
    }
    if (end < 0) {
      end = 1 - end * -1 % 1;
    }
    if (start > end) {
      var _start = start;
      start = end;
      end = _start;
    }
    var curvePoints = this.getCurve();
    var startPoint = this.getPointAt(start);
    var startIndex = this.getPreviousPointIndexAt(start);
    var endPoint = this.getPointAt(end);
    var endIndex = this.getPreviousPointIndexAt(end) + 1;
    var slicePoints = [];
    if (start !== 0) {
      startIndex++;
      slicePoints.push(startPoint);
    }
    slicePoints.push.apply(slicePoints, curvePoints.slice(startIndex, endIndex));
    if (end !== 1 || start === 1) {
      slicePoints.push(endPoint);
    }
    return new Path3D2(slicePoints, this.getNormalAt(start), this._raw, this._alignTangentsWithPath);
  };
  Path3D2.prototype.update = function(path, firstNormal, alignTangentsWithPath) {
    if (firstNormal === void 0) {
      firstNormal = null;
    }
    if (alignTangentsWithPath === void 0) {
      alignTangentsWithPath = false;
    }
    for (var p = 0; p < path.length; p++) {
      this._curve[p].x = path[p].x;
      this._curve[p].y = path[p].y;
      this._curve[p].z = path[p].z;
    }
    this._compute(firstNormal, alignTangentsWithPath);
    return this;
  };
  Path3D2.prototype._compute = function(firstNormal, alignTangentsWithPath) {
    if (alignTangentsWithPath === void 0) {
      alignTangentsWithPath = false;
    }
    var l = this._curve.length;
    if (l < 2) {
      return;
    }
    this._tangents[0] = this._getFirstNonNullVector(0);
    if (!this._raw) {
      this._tangents[0].normalize();
    }
    this._tangents[l - 1] = this._curve[l - 1].subtract(this._curve[l - 2]);
    if (!this._raw) {
      this._tangents[l - 1].normalize();
    }
    var tg0 = this._tangents[0];
    var pp0 = this._normalVector(tg0, firstNormal);
    this._normals[0] = pp0;
    if (!this._raw) {
      this._normals[0].normalize();
    }
    this._binormals[0] = Vector3.Cross(tg0, this._normals[0]);
    if (!this._raw) {
      this._binormals[0].normalize();
    }
    this._distances[0] = 0;
    var prev;
    var cur;
    var curTang;
    var prevNor;
    var prevBinor;
    for (var i = 1; i < l; i++) {
      prev = this._getLastNonNullVector(i);
      if (i < l - 1) {
        cur = this._getFirstNonNullVector(i);
        this._tangents[i] = alignTangentsWithPath ? cur : prev.add(cur);
        this._tangents[i].normalize();
      }
      this._distances[i] = this._distances[i - 1] + this._curve[i].subtract(this._curve[i - 1]).length();
      curTang = this._tangents[i];
      prevBinor = this._binormals[i - 1];
      this._normals[i] = Vector3.Cross(prevBinor, curTang);
      if (!this._raw) {
        if (this._normals[i].length() === 0) {
          prevNor = this._normals[i - 1];
          this._normals[i] = prevNor.clone();
        } else {
          this._normals[i].normalize();
        }
      }
      this._binormals[i] = Vector3.Cross(curTang, this._normals[i]);
      if (!this._raw) {
        this._binormals[i].normalize();
      }
    }
    this._pointAtData.id = NaN;
  };
  Path3D2.prototype._getFirstNonNullVector = function(index) {
    var i = 1;
    var nNVector = this._curve[index + i].subtract(this._curve[index]);
    while (nNVector.length() === 0 && index + i + 1 < this._curve.length) {
      i++;
      nNVector = this._curve[index + i].subtract(this._curve[index]);
    }
    return nNVector;
  };
  Path3D2.prototype._getLastNonNullVector = function(index) {
    var i = 1;
    var nLVector = this._curve[index].subtract(this._curve[index - i]);
    while (nLVector.length() === 0 && index > i + 1) {
      i++;
      nLVector = this._curve[index].subtract(this._curve[index - i]);
    }
    return nLVector;
  };
  Path3D2.prototype._normalVector = function(vt, va) {
    var normal0;
    var tgl = vt.length();
    if (tgl === 0) {
      tgl = 1;
    }
    if (va === void 0 || va === null) {
      var point;
      if (!Scalar.WithinEpsilon(Math.abs(vt.y) / tgl, 1, Epsilon)) {
        point = new Vector3(0, -1, 0);
      } else if (!Scalar.WithinEpsilon(Math.abs(vt.x) / tgl, 1, Epsilon)) {
        point = new Vector3(1, 0, 0);
      } else if (!Scalar.WithinEpsilon(Math.abs(vt.z) / tgl, 1, Epsilon)) {
        point = new Vector3(0, 0, 1);
      } else {
        point = Vector3.Zero();
      }
      normal0 = Vector3.Cross(vt, point);
    } else {
      normal0 = Vector3.Cross(vt, va);
      Vector3.CrossToRef(normal0, vt, normal0);
    }
    normal0.normalize();
    return normal0;
  };
  Path3D2.prototype._updatePointAtData = function(position, interpolateTNB) {
    if (interpolateTNB === void 0) {
      interpolateTNB = false;
    }
    if (this._pointAtData.id === position) {
      if (!this._pointAtData.interpolateReady) {
        this._updateInterpolationMatrix();
      }
      return this._pointAtData;
    } else {
      this._pointAtData.id = position;
    }
    var curvePoints = this.getPoints();
    if (position <= 0) {
      return this._setPointAtData(0, 0, curvePoints[0], 0, interpolateTNB);
    } else if (position >= 1) {
      return this._setPointAtData(1, 1, curvePoints[curvePoints.length - 1], curvePoints.length - 1, interpolateTNB);
    }
    var previousPoint = curvePoints[0];
    var currentPoint;
    var currentLength = 0;
    var targetLength = position * this.length();
    for (var i = 1; i < curvePoints.length; i++) {
      currentPoint = curvePoints[i];
      var distance = Vector3.Distance(previousPoint, currentPoint);
      currentLength += distance;
      if (currentLength === targetLength) {
        return this._setPointAtData(position, 1, currentPoint, i, interpolateTNB);
      } else if (currentLength > targetLength) {
        var toLength = currentLength - targetLength;
        var diff = toLength / distance;
        var dir = previousPoint.subtract(currentPoint);
        var point = currentPoint.add(dir.scaleInPlace(diff));
        return this._setPointAtData(position, 1 - diff, point, i - 1, interpolateTNB);
      }
      previousPoint = currentPoint;
    }
    return this._pointAtData;
  };
  Path3D2.prototype._setPointAtData = function(position, subPosition, point, parentIndex, interpolateTNB) {
    this._pointAtData.point = point;
    this._pointAtData.position = position;
    this._pointAtData.subPosition = subPosition;
    this._pointAtData.previousPointArrayIndex = parentIndex;
    this._pointAtData.interpolateReady = interpolateTNB;
    if (interpolateTNB) {
      this._updateInterpolationMatrix();
    }
    return this._pointAtData;
  };
  Path3D2.prototype._updateInterpolationMatrix = function() {
    this._pointAtData.interpolationMatrix = Matrix.Identity();
    var parentIndex = this._pointAtData.previousPointArrayIndex;
    if (parentIndex !== this._tangents.length - 1) {
      var index = parentIndex + 1;
      var tangentFrom = this._tangents[parentIndex].clone();
      var normalFrom = this._normals[parentIndex].clone();
      var binormalFrom = this._binormals[parentIndex].clone();
      var tangentTo = this._tangents[index].clone();
      var normalTo = this._normals[index].clone();
      var binormalTo = this._binormals[index].clone();
      var quatFrom = Quaternion.RotationQuaternionFromAxis(normalFrom, binormalFrom, tangentFrom);
      var quatTo = Quaternion.RotationQuaternionFromAxis(normalTo, binormalTo, tangentTo);
      var quatAt = Quaternion.Slerp(quatFrom, quatTo, this._pointAtData.subPosition);
      quatAt.toRotationMatrix(this._pointAtData.interpolationMatrix);
    }
  };
  return Path3D2;
}();
var Curve3 = function() {
  function Curve32(points) {
    this._length = 0;
    this._points = points;
    this._length = this._computeLength(points);
  }
  Curve32.CreateQuadraticBezier = function(v0, v1, v2, nbPoints) {
    nbPoints = nbPoints > 2 ? nbPoints : 3;
    var bez = new Array();
    var equation = function(t, val0, val1, val2) {
      var res = (1 - t) * (1 - t) * val0 + 2 * t * (1 - t) * val1 + t * t * val2;
      return res;
    };
    for (var i = 0; i <= nbPoints; i++) {
      bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x), equation(i / nbPoints, v0.y, v1.y, v2.y), equation(i / nbPoints, v0.z, v1.z, v2.z)));
    }
    return new Curve32(bez);
  };
  Curve32.CreateCubicBezier = function(v0, v1, v2, v3, nbPoints) {
    nbPoints = nbPoints > 3 ? nbPoints : 4;
    var bez = new Array();
    var equation = function(t, val0, val1, val2, val3) {
      var res = (1 - t) * (1 - t) * (1 - t) * val0 + 3 * t * (1 - t) * (1 - t) * val1 + 3 * t * t * (1 - t) * val2 + t * t * t * val3;
      return res;
    };
    for (var i = 0; i <= nbPoints; i++) {
      bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x, v3.x), equation(i / nbPoints, v0.y, v1.y, v2.y, v3.y), equation(i / nbPoints, v0.z, v1.z, v2.z, v3.z)));
    }
    return new Curve32(bez);
  };
  Curve32.CreateHermiteSpline = function(p1, t1, p2, t2, nbPoints) {
    var hermite = new Array();
    var step = 1 / nbPoints;
    for (var i = 0; i <= nbPoints; i++) {
      hermite.push(Vector3.Hermite(p1, t1, p2, t2, i * step));
    }
    return new Curve32(hermite);
  };
  Curve32.CreateCatmullRomSpline = function(points, nbPoints, closed) {
    var catmullRom = new Array();
    var step = 1 / nbPoints;
    var amount = 0;
    if (closed) {
      var pointsCount = points.length;
      for (var i = 0; i < pointsCount; i++) {
        amount = 0;
        for (var c = 0; c < nbPoints; c++) {
          catmullRom.push(Vector3.CatmullRom(points[i % pointsCount], points[(i + 1) % pointsCount], points[(i + 2) % pointsCount], points[(i + 3) % pointsCount], amount));
          amount += step;
        }
      }
      catmullRom.push(catmullRom[0]);
    } else {
      var totalPoints = new Array();
      totalPoints.push(points[0].clone());
      Array.prototype.push.apply(totalPoints, points);
      totalPoints.push(points[points.length - 1].clone());
      for (var i = 0; i < totalPoints.length - 3; i++) {
        amount = 0;
        for (var c = 0; c < nbPoints; c++) {
          catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));
          amount += step;
        }
      }
      i--;
      catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));
    }
    return new Curve32(catmullRom);
  };
  Curve32.prototype.getPoints = function() {
    return this._points;
  };
  Curve32.prototype.length = function() {
    return this._length;
  };
  Curve32.prototype.continue = function(curve) {
    var lastPoint = this._points[this._points.length - 1];
    var continuedPoints = this._points.slice();
    var curvePoints = curve.getPoints();
    for (var i = 1; i < curvePoints.length; i++) {
      continuedPoints.push(curvePoints[i].subtract(curvePoints[0]).add(lastPoint));
    }
    var continuedCurve = new Curve32(continuedPoints);
    return continuedCurve;
  };
  Curve32.prototype._computeLength = function(path) {
    var l = 0;
    for (var i = 1; i < path.length; i++) {
      l += path[i].subtract(path[i - 1]).length();
    }
    return l;
  };
  return Curve32;
}();

// node_modules/@babylonjs/core/Animations/easing.js
var EasingFunction = function() {
  function EasingFunction2() {
    this._easingMode = EasingFunction2.EASINGMODE_EASEIN;
  }
  EasingFunction2.prototype.setEasingMode = function(easingMode) {
    var n = Math.min(Math.max(easingMode, 0), 2);
    this._easingMode = n;
  };
  EasingFunction2.prototype.getEasingMode = function() {
    return this._easingMode;
  };
  EasingFunction2.prototype.easeInCore = function(gradient) {
    throw new Error("You must implement this method");
  };
  EasingFunction2.prototype.ease = function(gradient) {
    switch (this._easingMode) {
      case EasingFunction2.EASINGMODE_EASEIN:
        return this.easeInCore(gradient);
      case EasingFunction2.EASINGMODE_EASEOUT:
        return 1 - this.easeInCore(1 - gradient);
    }
    if (gradient >= 0.5) {
      return (1 - this.easeInCore((1 - gradient) * 2)) * 0.5 + 0.5;
    }
    return this.easeInCore(gradient * 2) * 0.5;
  };
  EasingFunction2.EASINGMODE_EASEIN = 0;
  EasingFunction2.EASINGMODE_EASEOUT = 1;
  EasingFunction2.EASINGMODE_EASEINOUT = 2;
  return EasingFunction2;
}();
var CircleEase = function(_super) {
  __extends(CircleEase2, _super);
  function CircleEase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CircleEase2.prototype.easeInCore = function(gradient) {
    gradient = Math.max(0, Math.min(1, gradient));
    return 1 - Math.sqrt(1 - gradient * gradient);
  };
  return CircleEase2;
}(EasingFunction);
var BackEase = function(_super) {
  __extends(BackEase2, _super);
  function BackEase2(amplitude) {
    if (amplitude === void 0) {
      amplitude = 1;
    }
    var _this = _super.call(this) || this;
    _this.amplitude = amplitude;
    return _this;
  }
  BackEase2.prototype.easeInCore = function(gradient) {
    var num = Math.max(0, this.amplitude);
    return Math.pow(gradient, 3) - gradient * num * Math.sin(3.141592653589793 * gradient);
  };
  return BackEase2;
}(EasingFunction);
var BounceEase = function(_super) {
  __extends(BounceEase2, _super);
  function BounceEase2(bounces, bounciness) {
    if (bounces === void 0) {
      bounces = 3;
    }
    if (bounciness === void 0) {
      bounciness = 2;
    }
    var _this = _super.call(this) || this;
    _this.bounces = bounces;
    _this.bounciness = bounciness;
    return _this;
  }
  BounceEase2.prototype.easeInCore = function(gradient) {
    var y = Math.max(0, this.bounces);
    var bounciness = this.bounciness;
    if (bounciness <= 1) {
      bounciness = 1.001;
    }
    var num9 = Math.pow(bounciness, y);
    var num5 = 1 - bounciness;
    var num4 = (1 - num9) / num5 + num9 * 0.5;
    var num15 = gradient * num4;
    var num65 = Math.log(-num15 * (1 - bounciness) + 1) / Math.log(bounciness);
    var num3 = Math.floor(num65);
    var num13 = num3 + 1;
    var num8 = (1 - Math.pow(bounciness, num3)) / (num5 * num4);
    var num12 = (1 - Math.pow(bounciness, num13)) / (num5 * num4);
    var num7 = (num8 + num12) * 0.5;
    var num6 = gradient - num7;
    var num2 = num7 - num8;
    return -Math.pow(1 / bounciness, y - num3) / (num2 * num2) * (num6 - num2) * (num6 + num2);
  };
  return BounceEase2;
}(EasingFunction);
var CubicEase = function(_super) {
  __extends(CubicEase2, _super);
  function CubicEase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CubicEase2.prototype.easeInCore = function(gradient) {
    return gradient * gradient * gradient;
  };
  return CubicEase2;
}(EasingFunction);
var ElasticEase = function(_super) {
  __extends(ElasticEase2, _super);
  function ElasticEase2(oscillations, springiness) {
    if (oscillations === void 0) {
      oscillations = 3;
    }
    if (springiness === void 0) {
      springiness = 3;
    }
    var _this = _super.call(this) || this;
    _this.oscillations = oscillations;
    _this.springiness = springiness;
    return _this;
  }
  ElasticEase2.prototype.easeInCore = function(gradient) {
    var num2;
    var num3 = Math.max(0, this.oscillations);
    var num = Math.max(0, this.springiness);
    if (num == 0) {
      num2 = gradient;
    } else {
      num2 = (Math.exp(num * gradient) - 1) / (Math.exp(num) - 1);
    }
    return num2 * Math.sin((6.283185307179586 * num3 + 1.5707963267948966) * gradient);
  };
  return ElasticEase2;
}(EasingFunction);
var ExponentialEase = function(_super) {
  __extends(ExponentialEase2, _super);
  function ExponentialEase2(exponent) {
    if (exponent === void 0) {
      exponent = 2;
    }
    var _this = _super.call(this) || this;
    _this.exponent = exponent;
    return _this;
  }
  ExponentialEase2.prototype.easeInCore = function(gradient) {
    if (this.exponent <= 0) {
      return gradient;
    }
    return (Math.exp(this.exponent * gradient) - 1) / (Math.exp(this.exponent) - 1);
  };
  return ExponentialEase2;
}(EasingFunction);
var PowerEase = function(_super) {
  __extends(PowerEase2, _super);
  function PowerEase2(power) {
    if (power === void 0) {
      power = 2;
    }
    var _this = _super.call(this) || this;
    _this.power = power;
    return _this;
  }
  PowerEase2.prototype.easeInCore = function(gradient) {
    var y = Math.max(0, this.power);
    return Math.pow(gradient, y);
  };
  return PowerEase2;
}(EasingFunction);
var QuadraticEase = function(_super) {
  __extends(QuadraticEase2, _super);
  function QuadraticEase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  QuadraticEase2.prototype.easeInCore = function(gradient) {
    return gradient * gradient;
  };
  return QuadraticEase2;
}(EasingFunction);
var QuarticEase = function(_super) {
  __extends(QuarticEase2, _super);
  function QuarticEase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  QuarticEase2.prototype.easeInCore = function(gradient) {
    return gradient * gradient * gradient * gradient;
  };
  return QuarticEase2;
}(EasingFunction);
var QuinticEase = function(_super) {
  __extends(QuinticEase2, _super);
  function QuinticEase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  QuinticEase2.prototype.easeInCore = function(gradient) {
    return gradient * gradient * gradient * gradient * gradient;
  };
  return QuinticEase2;
}(EasingFunction);
var SineEase = function(_super) {
  __extends(SineEase2, _super);
  function SineEase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SineEase2.prototype.easeInCore = function(gradient) {
    return 1 - Math.sin(1.5707963267948966 * (1 - gradient));
  };
  return SineEase2;
}(EasingFunction);
var BezierCurveEase = function(_super) {
  __extends(BezierCurveEase2, _super);
  function BezierCurveEase2(x1, y1, x2, y2) {
    if (x1 === void 0) {
      x1 = 0;
    }
    if (y1 === void 0) {
      y1 = 0;
    }
    if (x2 === void 0) {
      x2 = 1;
    }
    if (y2 === void 0) {
      y2 = 1;
    }
    var _this = _super.call(this) || this;
    _this.x1 = x1;
    _this.y1 = y1;
    _this.x2 = x2;
    _this.y2 = y2;
    return _this;
  }
  BezierCurveEase2.prototype.easeInCore = function(gradient) {
    return BezierCurve.Interpolate(gradient, this.x1, this.y1, this.x2, this.y2);
  };
  return BezierCurveEase2;
}(EasingFunction);

// node_modules/@babylonjs/core/Audio/analyser.js
var Analyser = function() {
  function Analyser2(scene) {
    this.SMOOTHING = 0.75;
    this.FFT_SIZE = 512;
    this.BARGRAPHAMPLITUDE = 256;
    this.DEBUGCANVASPOS = { x: 20, y: 20 };
    this.DEBUGCANVASSIZE = { width: 320, height: 200 };
    this._scene = scene;
    this._audioEngine = Engine.audioEngine;
    if (this._audioEngine.canUseWebAudio && this._audioEngine.audioContext) {
      this._webAudioAnalyser = this._audioEngine.audioContext.createAnalyser();
      this._webAudioAnalyser.minDecibels = -140;
      this._webAudioAnalyser.maxDecibels = 0;
      this._byteFreqs = new Uint8Array(this._webAudioAnalyser.frequencyBinCount);
      this._byteTime = new Uint8Array(this._webAudioAnalyser.frequencyBinCount);
      this._floatFreqs = new Float32Array(this._webAudioAnalyser.frequencyBinCount);
    }
  }
  Analyser2.prototype.getFrequencyBinCount = function() {
    if (this._audioEngine.canUseWebAudio) {
      return this._webAudioAnalyser.frequencyBinCount;
    } else {
      return 0;
    }
  };
  Analyser2.prototype.getByteFrequencyData = function() {
    if (this._audioEngine.canUseWebAudio) {
      this._webAudioAnalyser.smoothingTimeConstant = this.SMOOTHING;
      this._webAudioAnalyser.fftSize = this.FFT_SIZE;
      this._webAudioAnalyser.getByteFrequencyData(this._byteFreqs);
    }
    return this._byteFreqs;
  };
  Analyser2.prototype.getByteTimeDomainData = function() {
    if (this._audioEngine.canUseWebAudio) {
      this._webAudioAnalyser.smoothingTimeConstant = this.SMOOTHING;
      this._webAudioAnalyser.fftSize = this.FFT_SIZE;
      this._webAudioAnalyser.getByteTimeDomainData(this._byteTime);
    }
    return this._byteTime;
  };
  Analyser2.prototype.getFloatFrequencyData = function() {
    if (this._audioEngine.canUseWebAudio) {
      this._webAudioAnalyser.smoothingTimeConstant = this.SMOOTHING;
      this._webAudioAnalyser.fftSize = this.FFT_SIZE;
      this._webAudioAnalyser.getFloatFrequencyData(this._floatFreqs);
    }
    return this._floatFreqs;
  };
  Analyser2.prototype.drawDebugCanvas = function() {
    var _this = this;
    if (this._audioEngine.canUseWebAudio) {
      if (!this._debugCanvas) {
        this._debugCanvas = document.createElement("canvas");
        this._debugCanvas.width = this.DEBUGCANVASSIZE.width;
        this._debugCanvas.height = this.DEBUGCANVASSIZE.height;
        this._debugCanvas.style.position = "absolute";
        this._debugCanvas.style.top = this.DEBUGCANVASPOS.y + "px";
        this._debugCanvas.style.left = this.DEBUGCANVASPOS.x + "px";
        this._debugCanvasContext = this._debugCanvas.getContext("2d");
        document.body.appendChild(this._debugCanvas);
        this._registerFunc = function() {
          _this.drawDebugCanvas();
        };
        this._scene.registerBeforeRender(this._registerFunc);
      }
      if (this._registerFunc && this._debugCanvasContext) {
        var workingArray = this.getByteFrequencyData();
        this._debugCanvasContext.fillStyle = "rgb(0, 0, 0)";
        this._debugCanvasContext.fillRect(0, 0, this.DEBUGCANVASSIZE.width, this.DEBUGCANVASSIZE.height);
        for (var i = 0; i < this.getFrequencyBinCount(); i++) {
          var value = workingArray[i];
          var percent = value / this.BARGRAPHAMPLITUDE;
          var height = this.DEBUGCANVASSIZE.height * percent;
          var offset = this.DEBUGCANVASSIZE.height - height - 1;
          var barWidth = this.DEBUGCANVASSIZE.width / this.getFrequencyBinCount();
          var hue = i / this.getFrequencyBinCount() * 360;
          this._debugCanvasContext.fillStyle = "hsl(" + hue + ", 100%, 50%)";
          this._debugCanvasContext.fillRect(i * barWidth, offset, barWidth, height);
        }
      }
    }
  };
  Analyser2.prototype.stopDebugCanvas = function() {
    if (this._debugCanvas) {
      if (this._registerFunc) {
        this._scene.unregisterBeforeRender(this._registerFunc);
        this._registerFunc = null;
      }
      document.body.removeChild(this._debugCanvas);
      this._debugCanvas = null;
      this._debugCanvasContext = null;
    }
  };
  Analyser2.prototype.connectAudioNodes = function(inputAudioNode, outputAudioNode) {
    if (this._audioEngine.canUseWebAudio) {
      inputAudioNode.connect(this._webAudioAnalyser);
      this._webAudioAnalyser.connect(outputAudioNode);
    }
  };
  Analyser2.prototype.dispose = function() {
    if (this._audioEngine.canUseWebAudio) {
      this._webAudioAnalyser.disconnect();
    }
  };
  return Analyser2;
}();

// node_modules/@babylonjs/core/Audio/audioEngine.js
Engine.AudioEngineFactory = function(hostElement) {
  return new AudioEngine(hostElement);
};
var AudioEngine = function() {
  function AudioEngine2(hostElement) {
    var _this = this;
    if (hostElement === void 0) {
      hostElement = null;
    }
    this._audioContext = null;
    this._audioContextInitialized = false;
    this._muteButton = null;
    this.canUseWebAudio = false;
    this.WarnedWebAudioUnsupported = false;
    this.isMP3supported = false;
    this.isOGGsupported = false;
    this.unlocked = true;
    this.useCustomUnlockedButton = false;
    this.onAudioUnlockedObservable = new Observable();
    this.onAudioLockedObservable = new Observable();
    this._tryToRun = false;
    this._onResize = function() {
      _this._moveButtonToTopLeft();
    };
    if (typeof window.AudioContext !== "undefined" || typeof window.webkitAudioContext !== "undefined") {
      window.AudioContext = window.AudioContext || window.webkitAudioContext;
      this.canUseWebAudio = true;
    }
    var audioElem = document.createElement("audio");
    this._hostElement = hostElement;
    try {
      if (audioElem && !!audioElem.canPlayType && (audioElem.canPlayType('audio/mpeg; codecs="mp3"').replace(/^no$/, "") || audioElem.canPlayType("audio/mp3").replace(/^no$/, ""))) {
        this.isMP3supported = true;
      }
    } catch (e) {
    }
    try {
      if (audioElem && !!audioElem.canPlayType && audioElem.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "")) {
        this.isOGGsupported = true;
      }
    } catch (e) {
    }
  }
  Object.defineProperty(AudioEngine2.prototype, "audioContext", {
    get: function() {
      if (!this._audioContextInitialized) {
        this._initializeAudioContext();
      } else {
        if (!this.unlocked && !this._muteButton) {
          this._displayMuteButton();
        }
      }
      return this._audioContext;
    },
    enumerable: false,
    configurable: true
  });
  AudioEngine2.prototype.lock = function() {
    this._triggerSuspendedState();
  };
  AudioEngine2.prototype.unlock = function() {
    this._triggerRunningState();
  };
  AudioEngine2.prototype._resumeAudioContext = function() {
    var result;
    if (this._audioContext.resume !== void 0) {
      result = this._audioContext.resume();
    }
    return result || Promise.resolve();
  };
  AudioEngine2.prototype._initializeAudioContext = function() {
    try {
      if (this.canUseWebAudio) {
        this._audioContext = new AudioContext();
        this.masterGain = this._audioContext.createGain();
        this.masterGain.gain.value = 1;
        this.masterGain.connect(this._audioContext.destination);
        this._audioContextInitialized = true;
        if (this._audioContext.state === "running") {
          this._triggerRunningState();
        }
      }
    } catch (e) {
      this.canUseWebAudio = false;
      Logger.Error("Web Audio: " + e.message);
    }
  };
  AudioEngine2.prototype._triggerRunningState = function() {
    var _this = this;
    if (this._tryToRun) {
      return;
    }
    this._tryToRun = true;
    this._resumeAudioContext().then(function() {
      _this._tryToRun = false;
      if (_this._muteButton) {
        _this._hideMuteButton();
      }
      _this.unlocked = true;
      _this.onAudioUnlockedObservable.notifyObservers(_this);
    }).catch(function() {
      _this._tryToRun = false;
      _this.unlocked = false;
    });
  };
  AudioEngine2.prototype._triggerSuspendedState = function() {
    this.unlocked = false;
    this.onAudioLockedObservable.notifyObservers(this);
    this._displayMuteButton();
  };
  AudioEngine2.prototype._displayMuteButton = function() {
    var _this = this;
    if (this.useCustomUnlockedButton || this._muteButton) {
      return;
    }
    this._muteButton = document.createElement("BUTTON");
    this._muteButton.className = "babylonUnmuteIcon";
    this._muteButton.id = "babylonUnmuteIconBtn";
    this._muteButton.title = "Unmute";
    var imageUrl = !window.SVGSVGElement ? "https://cdn.babylonjs.com/Assets/audio.png" : "data:image/svg+xml;charset=UTF-8,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2239%22%20height%3D%2232%22%20viewBox%3D%220%200%2039%2032%22%3E%3Cpath%20fill%3D%22white%22%20d%3D%22M9.625%2018.938l-0.031%200.016h-4.953q-0.016%200-0.031-0.016v-12.453q0-0.016%200.031-0.016h4.953q0.031%200%200.031%200.016v12.453zM12.125%207.688l8.719-8.703v27.453l-8.719-8.719-0.016-0.047v-9.938zM23.359%207.875l1.406-1.406%204.219%204.203%204.203-4.203%201.422%201.406-4.219%204.219%204.219%204.203-1.484%201.359-4.141-4.156-4.219%204.219-1.406-1.422%204.219-4.203z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E";
    var css = ".babylonUnmuteIcon { position: absolute; left: 20px; top: 20px; height: 40px; width: 60px; background-color: rgba(51,51,51,0.7); background-image: url(" + imageUrl + ");  background-size: 80%; background-repeat:no-repeat; background-position: center; background-position-y: 4px; border: none; outline: none; transition: transform 0.125s ease-out; cursor: pointer; z-index: 9999; } .babylonUnmuteIcon:hover { transform: scale(1.05) } .babylonUnmuteIcon:active { background-color: rgba(51,51,51,1) }";
    var style = document.createElement("style");
    style.appendChild(document.createTextNode(css));
    document.getElementsByTagName("head")[0].appendChild(style);
    document.body.appendChild(this._muteButton);
    this._moveButtonToTopLeft();
    this._muteButton.addEventListener("touchend", function() {
      _this._triggerRunningState();
    }, true);
    this._muteButton.addEventListener("click", function() {
      _this._triggerRunningState();
    }, true);
    window.addEventListener("resize", this._onResize);
  };
  AudioEngine2.prototype._moveButtonToTopLeft = function() {
    if (this._hostElement && this._muteButton) {
      this._muteButton.style.top = this._hostElement.offsetTop + 20 + "px";
      this._muteButton.style.left = this._hostElement.offsetLeft + 20 + "px";
    }
  };
  AudioEngine2.prototype._hideMuteButton = function() {
    if (this._muteButton) {
      document.body.removeChild(this._muteButton);
      this._muteButton = null;
    }
  };
  AudioEngine2.prototype.dispose = function() {
    if (this.canUseWebAudio && this._audioContextInitialized) {
      if (this._connectedAnalyser && this._audioContext) {
        this._connectedAnalyser.stopDebugCanvas();
        this._connectedAnalyser.dispose();
        this.masterGain.disconnect();
        this.masterGain.connect(this._audioContext.destination);
        this._connectedAnalyser = null;
      }
      this.masterGain.gain.value = 1;
    }
    this.WarnedWebAudioUnsupported = false;
    this._hideMuteButton();
    window.removeEventListener("resize", this._onResize);
    this.onAudioUnlockedObservable.clear();
    this.onAudioLockedObservable.clear();
  };
  AudioEngine2.prototype.getGlobalVolume = function() {
    if (this.canUseWebAudio && this._audioContextInitialized) {
      return this.masterGain.gain.value;
    } else {
      return -1;
    }
  };
  AudioEngine2.prototype.setGlobalVolume = function(newVolume) {
    if (this.canUseWebAudio && this._audioContextInitialized) {
      this.masterGain.gain.value = newVolume;
    }
  };
  AudioEngine2.prototype.connectToAnalyser = function(analyser) {
    if (this._connectedAnalyser) {
      this._connectedAnalyser.stopDebugCanvas();
    }
    if (this.canUseWebAudio && this._audioContextInitialized && this._audioContext) {
      this._connectedAnalyser = analyser;
      this.masterGain.disconnect();
      this._connectedAnalyser.connectAudioNodes(this.masterGain, this._audioContext.destination);
    }
  };
  return AudioEngine2;
}();

// node_modules/@babylonjs/core/Audio/soundTrack.js
var SoundTrack = function() {
  function SoundTrack2(scene, options) {
    if (options === void 0) {
      options = {};
    }
    this.id = -1;
    this._isInitialized = false;
    this._scene = scene;
    this.soundCollection = new Array();
    this._options = options;
    if (!this._options.mainTrack && this._scene.soundTracks) {
      this._scene.soundTracks.push(this);
      this.id = this._scene.soundTracks.length - 1;
    }
  }
  SoundTrack2.prototype._initializeSoundTrackAudioGraph = function() {
    if (Engine.audioEngine.canUseWebAudio && Engine.audioEngine.audioContext) {
      this._outputAudioNode = Engine.audioEngine.audioContext.createGain();
      this._outputAudioNode.connect(Engine.audioEngine.masterGain);
      if (this._options) {
        if (this._options.volume) {
          this._outputAudioNode.gain.value = this._options.volume;
        }
      }
      this._isInitialized = true;
    }
  };
  SoundTrack2.prototype.dispose = function() {
    if (Engine.audioEngine && Engine.audioEngine.canUseWebAudio) {
      if (this._connectedAnalyser) {
        this._connectedAnalyser.stopDebugCanvas();
      }
      while (this.soundCollection.length) {
        this.soundCollection[0].dispose();
      }
      if (this._outputAudioNode) {
        this._outputAudioNode.disconnect();
      }
      this._outputAudioNode = null;
    }
  };
  SoundTrack2.prototype.addSound = function(sound) {
    if (!this._isInitialized) {
      this._initializeSoundTrackAudioGraph();
    }
    if (Engine.audioEngine.canUseWebAudio && this._outputAudioNode) {
      sound.connectToSoundTrackAudioNode(this._outputAudioNode);
    }
    if (sound.soundTrackId) {
      if (sound.soundTrackId === -1) {
        this._scene.mainSoundTrack.removeSound(sound);
      } else if (this._scene.soundTracks) {
        this._scene.soundTracks[sound.soundTrackId].removeSound(sound);
      }
    }
    this.soundCollection.push(sound);
    sound.soundTrackId = this.id;
  };
  SoundTrack2.prototype.removeSound = function(sound) {
    var index = this.soundCollection.indexOf(sound);
    if (index !== -1) {
      this.soundCollection.splice(index, 1);
    }
  };
  SoundTrack2.prototype.setVolume = function(newVolume) {
    if (Engine.audioEngine.canUseWebAudio && this._outputAudioNode) {
      this._outputAudioNode.gain.value = newVolume;
    }
  };
  SoundTrack2.prototype.switchPanningModelToHRTF = function() {
    if (Engine.audioEngine.canUseWebAudio) {
      for (var i = 0; i < this.soundCollection.length; i++) {
        this.soundCollection[i].switchPanningModelToHRTF();
      }
    }
  };
  SoundTrack2.prototype.switchPanningModelToEqualPower = function() {
    if (Engine.audioEngine.canUseWebAudio) {
      for (var i = 0; i < this.soundCollection.length; i++) {
        this.soundCollection[i].switchPanningModelToEqualPower();
      }
    }
  };
  SoundTrack2.prototype.connectToAnalyser = function(analyser) {
    if (this._connectedAnalyser) {
      this._connectedAnalyser.stopDebugCanvas();
    }
    this._connectedAnalyser = analyser;
    if (Engine.audioEngine.canUseWebAudio && this._outputAudioNode) {
      this._outputAudioNode.disconnect();
      this._connectedAnalyser.connectAudioNodes(this._outputAudioNode, Engine.audioEngine.masterGain);
    }
  };
  return SoundTrack2;
}();

// node_modules/@babylonjs/core/Audio/audioSceneComponent.js
AbstractScene.AddParser(SceneComponentConstants.NAME_AUDIO, function(parsedData, scene, container, rootUrl) {
  var loadedSounds = [];
  var loadedSound;
  container.sounds = container.sounds || [];
  if (parsedData.sounds !== void 0 && parsedData.sounds !== null) {
    for (var index = 0, cache = parsedData.sounds.length; index < cache; index++) {
      var parsedSound = parsedData.sounds[index];
      if (Engine.audioEngine.canUseWebAudio) {
        if (!parsedSound.url) {
          parsedSound.url = parsedSound.name;
        }
        if (!loadedSounds[parsedSound.url]) {
          loadedSound = Sound.Parse(parsedSound, scene, rootUrl);
          loadedSounds[parsedSound.url] = loadedSound;
          container.sounds.push(loadedSound);
        } else {
          container.sounds.push(Sound.Parse(parsedSound, scene, rootUrl, loadedSounds[parsedSound.url]));
        }
      } else {
        container.sounds.push(new Sound(parsedSound.name, null, scene));
      }
    }
  }
  loadedSounds = [];
});
Object.defineProperty(Scene.prototype, "mainSoundTrack", {
  get: function() {
    var compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
    if (!compo) {
      compo = new AudioSceneComponent(this);
      this._addComponent(compo);
    }
    if (!this._mainSoundTrack) {
      this._mainSoundTrack = new SoundTrack(this, { mainTrack: true });
    }
    return this._mainSoundTrack;
  },
  enumerable: true,
  configurable: true
});
Scene.prototype.getSoundByName = function(name98) {
  var index;
  for (index = 0; index < this.mainSoundTrack.soundCollection.length; index++) {
    if (this.mainSoundTrack.soundCollection[index].name === name98) {
      return this.mainSoundTrack.soundCollection[index];
    }
  }
  if (this.soundTracks) {
    for (var sdIndex = 0; sdIndex < this.soundTracks.length; sdIndex++) {
      for (index = 0; index < this.soundTracks[sdIndex].soundCollection.length; index++) {
        if (this.soundTracks[sdIndex].soundCollection[index].name === name98) {
          return this.soundTracks[sdIndex].soundCollection[index];
        }
      }
    }
  }
  return null;
};
Object.defineProperty(Scene.prototype, "audioEnabled", {
  get: function() {
    var compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
    if (!compo) {
      compo = new AudioSceneComponent(this);
      this._addComponent(compo);
    }
    return compo.audioEnabled;
  },
  set: function(value) {
    var compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
    if (!compo) {
      compo = new AudioSceneComponent(this);
      this._addComponent(compo);
    }
    if (value) {
      compo.enableAudio();
    } else {
      compo.disableAudio();
    }
  },
  enumerable: true,
  configurable: true
});
Object.defineProperty(Scene.prototype, "headphone", {
  get: function() {
    var compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
    if (!compo) {
      compo = new AudioSceneComponent(this);
      this._addComponent(compo);
    }
    return compo.headphone;
  },
  set: function(value) {
    var compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
    if (!compo) {
      compo = new AudioSceneComponent(this);
      this._addComponent(compo);
    }
    if (value) {
      compo.switchAudioModeForHeadphones();
    } else {
      compo.switchAudioModeForNormalSpeakers();
    }
  },
  enumerable: true,
  configurable: true
});
Object.defineProperty(Scene.prototype, "audioListenerPositionProvider", {
  get: function() {
    var compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
    if (!compo) {
      compo = new AudioSceneComponent(this);
      this._addComponent(compo);
    }
    return compo.audioListenerPositionProvider;
  },
  set: function(value) {
    var compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
    if (!compo) {
      compo = new AudioSceneComponent(this);
      this._addComponent(compo);
    }
    if (typeof value !== "function") {
      throw new Error("The value passed to [Scene.audioListenerPositionProvider] must be a function that returns a Vector3");
    } else {
      compo.audioListenerPositionProvider = value;
    }
  },
  enumerable: true,
  configurable: true
});
Object.defineProperty(Scene.prototype, "audioPositioningRefreshRate", {
  get: function() {
    var compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
    if (!compo) {
      compo = new AudioSceneComponent(this);
      this._addComponent(compo);
    }
    return compo.audioPositioningRefreshRate;
  },
  set: function(value) {
    var compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
    if (!compo) {
      compo = new AudioSceneComponent(this);
      this._addComponent(compo);
    }
    compo.audioPositioningRefreshRate = value;
  },
  enumerable: true,
  configurable: true
});
var AudioSceneComponent = function() {
  function AudioSceneComponent2(scene) {
    this.name = SceneComponentConstants.NAME_AUDIO;
    this._audioEnabled = true;
    this._headphone = false;
    this.audioPositioningRefreshRate = 500;
    this._audioListenerPositionProvider = null;
    this._cachedCameraDirection = new Vector3();
    this._cachedCameraPosition = new Vector3();
    this._lastCheck = 0;
    this.scene = scene;
    scene.soundTracks = new Array();
    scene.sounds = new Array();
  }
  Object.defineProperty(AudioSceneComponent2.prototype, "audioEnabled", {
    get: function() {
      return this._audioEnabled;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AudioSceneComponent2.prototype, "headphone", {
    get: function() {
      return this._headphone;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AudioSceneComponent2.prototype, "audioListenerPositionProvider", {
    get: function() {
      return this._audioListenerPositionProvider;
    },
    set: function(value) {
      this._audioListenerPositionProvider = value;
    },
    enumerable: false,
    configurable: true
  });
  AudioSceneComponent2.prototype.register = function() {
    this.scene._afterRenderStage.registerStep(SceneComponentConstants.STEP_AFTERRENDER_AUDIO, this, this._afterRender);
  };
  AudioSceneComponent2.prototype.rebuild = function() {
  };
  AudioSceneComponent2.prototype.serialize = function(serializationObject) {
    serializationObject.sounds = [];
    if (this.scene.soundTracks) {
      for (var index = 0; index < this.scene.soundTracks.length; index++) {
        var soundtrack = this.scene.soundTracks[index];
        for (var soundId = 0; soundId < soundtrack.soundCollection.length; soundId++) {
          serializationObject.sounds.push(soundtrack.soundCollection[soundId].serialize());
        }
      }
    }
  };
  AudioSceneComponent2.prototype.addFromContainer = function(container) {
    var _this = this;
    if (!container.sounds) {
      return;
    }
    container.sounds.forEach(function(sound) {
      sound.play();
      sound.autoplay = true;
      _this.scene.mainSoundTrack.addSound(sound);
    });
  };
  AudioSceneComponent2.prototype.removeFromContainer = function(container, dispose) {
    var _this = this;
    if (dispose === void 0) {
      dispose = false;
    }
    if (!container.sounds) {
      return;
    }
    container.sounds.forEach(function(sound) {
      sound.stop();
      sound.autoplay = false;
      _this.scene.mainSoundTrack.removeSound(sound);
      if (dispose) {
        sound.dispose();
      }
    });
  };
  AudioSceneComponent2.prototype.dispose = function() {
    var scene = this.scene;
    if (scene._mainSoundTrack) {
      scene.mainSoundTrack.dispose();
    }
    if (scene.soundTracks) {
      for (var scIndex = 0; scIndex < scene.soundTracks.length; scIndex++) {
        scene.soundTracks[scIndex].dispose();
      }
    }
  };
  AudioSceneComponent2.prototype.disableAudio = function() {
    var scene = this.scene;
    this._audioEnabled = false;
    if (Engine.audioEngine && Engine.audioEngine.audioContext) {
      Engine.audioEngine.audioContext.suspend();
    }
    var i;
    for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {
      scene.mainSoundTrack.soundCollection[i].pause();
    }
    if (scene.soundTracks) {
      for (i = 0; i < scene.soundTracks.length; i++) {
        for (var j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {
          scene.soundTracks[i].soundCollection[j].pause();
        }
      }
    }
  };
  AudioSceneComponent2.prototype.enableAudio = function() {
    var scene = this.scene;
    this._audioEnabled = true;
    if (Engine.audioEngine && Engine.audioEngine.audioContext) {
      Engine.audioEngine.audioContext.resume();
    }
    var i;
    for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {
      if (scene.mainSoundTrack.soundCollection[i].isPaused) {
        scene.mainSoundTrack.soundCollection[i].play();
      }
    }
    if (scene.soundTracks) {
      for (i = 0; i < scene.soundTracks.length; i++) {
        for (var j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {
          if (scene.soundTracks[i].soundCollection[j].isPaused) {
            scene.soundTracks[i].soundCollection[j].play();
          }
        }
      }
    }
  };
  AudioSceneComponent2.prototype.switchAudioModeForHeadphones = function() {
    var scene = this.scene;
    this._headphone = true;
    scene.mainSoundTrack.switchPanningModelToHRTF();
    if (scene.soundTracks) {
      for (var i = 0; i < scene.soundTracks.length; i++) {
        scene.soundTracks[i].switchPanningModelToHRTF();
      }
    }
  };
  AudioSceneComponent2.prototype.switchAudioModeForNormalSpeakers = function() {
    var scene = this.scene;
    this._headphone = false;
    scene.mainSoundTrack.switchPanningModelToEqualPower();
    if (scene.soundTracks) {
      for (var i = 0; i < scene.soundTracks.length; i++) {
        scene.soundTracks[i].switchPanningModelToEqualPower();
      }
    }
  };
  AudioSceneComponent2.prototype._afterRender = function() {
    var now = PrecisionDate.Now;
    if (this._lastCheck && now - this._lastCheck < this.audioPositioningRefreshRate) {
      return;
    }
    this._lastCheck = now;
    var scene = this.scene;
    if (!this._audioEnabled || !scene._mainSoundTrack || !scene.soundTracks || scene._mainSoundTrack.soundCollection.length === 0 && scene.soundTracks.length === 1) {
      return;
    }
    var audioEngine = Engine.audioEngine;
    if (!audioEngine) {
      return;
    }
    if (audioEngine.audioContext) {
      if (this._audioListenerPositionProvider) {
        var position = this._audioListenerPositionProvider();
        position.x = position.x || 0;
        position.y = position.y || 0;
        position.z = position.z || 0;
        audioEngine.audioContext.listener.setPosition(position.x, position.y, position.z);
      } else {
        var listeningCamera;
        if (scene.activeCameras && scene.activeCameras.length > 0) {
          listeningCamera = scene.activeCameras[0];
        } else {
          listeningCamera = scene.activeCamera;
        }
        if (listeningCamera) {
          if (!this._cachedCameraPosition.equals(listeningCamera.globalPosition)) {
            this._cachedCameraPosition.copyFrom(listeningCamera.globalPosition);
            audioEngine.audioContext.listener.setPosition(listeningCamera.globalPosition.x, listeningCamera.globalPosition.y, listeningCamera.globalPosition.z);
          }
          if (listeningCamera.rigCameras && listeningCamera.rigCameras.length > 0) {
            listeningCamera = listeningCamera.rigCameras[0];
          }
          var mat = Matrix.Invert(listeningCamera.getViewMatrix());
          var cameraDirection = Vector3.TransformNormal(scene.useRightHandedSystem ? AudioSceneComponent2._CameraDirectionRH : AudioSceneComponent2._CameraDirectionLH, mat);
          cameraDirection.normalize();
          if (!isNaN(cameraDirection.x) && !isNaN(cameraDirection.y) && !isNaN(cameraDirection.z)) {
            if (!this._cachedCameraDirection.equals(cameraDirection)) {
              this._cachedCameraDirection.copyFrom(cameraDirection);
              audioEngine.audioContext.listener.setOrientation(cameraDirection.x, cameraDirection.y, cameraDirection.z, 0, 1, 0);
            }
          }
        } else {
          audioEngine.audioContext.listener.setPosition(0, 0, 0);
        }
      }
      var i;
      for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {
        var sound = scene.mainSoundTrack.soundCollection[i];
        if (sound.useCustomAttenuation) {
          sound.updateDistanceFromListener();
        }
      }
      if (scene.soundTracks) {
        for (i = 0; i < scene.soundTracks.length; i++) {
          for (var j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {
            sound = scene.soundTracks[i].soundCollection[j];
            if (sound.useCustomAttenuation) {
              sound.updateDistanceFromListener();
            }
          }
        }
      }
    }
  };
  AudioSceneComponent2._CameraDirectionLH = new Vector3(0, 0, -1);
  AudioSceneComponent2._CameraDirectionRH = new Vector3(0, 0, 1);
  return AudioSceneComponent2;
}();
Sound._SceneComponentInitialization = function(scene) {
  var compo = scene._getComponent(SceneComponentConstants.NAME_AUDIO);
  if (!compo) {
    compo = new AudioSceneComponent(scene);
    scene._addComponent(compo);
  }
};

// node_modules/@babylonjs/core/Behaviors/Cameras/autoRotationBehavior.js
var AutoRotationBehavior = function() {
  function AutoRotationBehavior2() {
    this._zoomStopsAnimation = false;
    this._idleRotationSpeed = 0.05;
    this._idleRotationWaitTime = 2e3;
    this._idleRotationSpinupTime = 2e3;
    this._isPointerDown = false;
    this._lastFrameTime = null;
    this._lastInteractionTime = -Infinity;
    this._cameraRotationSpeed = 0;
    this._lastFrameRadius = 0;
  }
  Object.defineProperty(AutoRotationBehavior2.prototype, "name", {
    get: function() {
      return "AutoRotation";
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AutoRotationBehavior2.prototype, "zoomStopsAnimation", {
    get: function() {
      return this._zoomStopsAnimation;
    },
    set: function(flag) {
      this._zoomStopsAnimation = flag;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AutoRotationBehavior2.prototype, "idleRotationSpeed", {
    get: function() {
      return this._idleRotationSpeed;
    },
    set: function(speed) {
      this._idleRotationSpeed = speed;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AutoRotationBehavior2.prototype, "idleRotationWaitTime", {
    get: function() {
      return this._idleRotationWaitTime;
    },
    set: function(time) {
      this._idleRotationWaitTime = time;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AutoRotationBehavior2.prototype, "idleRotationSpinupTime", {
    get: function() {
      return this._idleRotationSpinupTime;
    },
    set: function(time) {
      this._idleRotationSpinupTime = time;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AutoRotationBehavior2.prototype, "rotationInProgress", {
    get: function() {
      return Math.abs(this._cameraRotationSpeed) > 0;
    },
    enumerable: false,
    configurable: true
  });
  AutoRotationBehavior2.prototype.init = function() {
  };
  AutoRotationBehavior2.prototype.attach = function(camera) {
    var _this = this;
    this._attachedCamera = camera;
    var scene = this._attachedCamera.getScene();
    this._onPrePointerObservableObserver = scene.onPrePointerObservable.add(function(pointerInfoPre) {
      if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {
        _this._isPointerDown = true;
        return;
      }
      if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {
        _this._isPointerDown = false;
      }
    });
    this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(function() {
      var now = PrecisionDate.Now;
      var dt = 0;
      if (_this._lastFrameTime != null) {
        dt = now - _this._lastFrameTime;
      }
      _this._lastFrameTime = now;
      _this._applyUserInteraction();
      var timeToRotation = now - _this._lastInteractionTime - _this._idleRotationWaitTime;
      var scale = Math.max(Math.min(timeToRotation / _this._idleRotationSpinupTime, 1), 0);
      _this._cameraRotationSpeed = _this._idleRotationSpeed * scale;
      if (_this._attachedCamera) {
        _this._attachedCamera.alpha -= _this._cameraRotationSpeed * (dt / 1e3);
      }
    });
  };
  AutoRotationBehavior2.prototype.detach = function() {
    if (!this._attachedCamera) {
      return;
    }
    var scene = this._attachedCamera.getScene();
    if (this._onPrePointerObservableObserver) {
      scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);
    }
    this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);
    this._attachedCamera = null;
  };
  AutoRotationBehavior2.prototype._userIsZooming = function() {
    if (!this._attachedCamera) {
      return false;
    }
    return this._attachedCamera.inertialRadiusOffset !== 0;
  };
  AutoRotationBehavior2.prototype._shouldAnimationStopForInteraction = function() {
    if (!this._attachedCamera) {
      return false;
    }
    var zoomHasHitLimit = false;
    if (this._lastFrameRadius === this._attachedCamera.radius && this._attachedCamera.inertialRadiusOffset !== 0) {
      zoomHasHitLimit = true;
    }
    this._lastFrameRadius = this._attachedCamera.radius;
    return this._zoomStopsAnimation ? zoomHasHitLimit : this._userIsZooming();
  };
  AutoRotationBehavior2.prototype._applyUserInteraction = function() {
    if (this._userIsMoving() && !this._shouldAnimationStopForInteraction()) {
      this._lastInteractionTime = PrecisionDate.Now;
    }
  };
  AutoRotationBehavior2.prototype._userIsMoving = function() {
    if (!this._attachedCamera) {
      return false;
    }
    return this._attachedCamera.inertialAlphaOffset !== 0 || this._attachedCamera.inertialBetaOffset !== 0 || this._attachedCamera.inertialRadiusOffset !== 0 || this._attachedCamera.inertialPanningX !== 0 || this._attachedCamera.inertialPanningY !== 0 || this._isPointerDown;
  };
  return AutoRotationBehavior2;
}();

// node_modules/@babylonjs/core/Behaviors/Cameras/bouncingBehavior.js
var BouncingBehavior = function() {
  function BouncingBehavior2() {
    this.transitionDuration = 450;
    this.lowerRadiusTransitionRange = 2;
    this.upperRadiusTransitionRange = -2;
    this._autoTransitionRange = false;
    this._radiusIsAnimating = false;
    this._radiusBounceTransition = null;
    this._animatables = new Array();
  }
  Object.defineProperty(BouncingBehavior2.prototype, "name", {
    get: function() {
      return "Bouncing";
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BouncingBehavior2.prototype, "autoTransitionRange", {
    get: function() {
      return this._autoTransitionRange;
    },
    set: function(value) {
      var _this = this;
      if (this._autoTransitionRange === value) {
        return;
      }
      this._autoTransitionRange = value;
      var camera = this._attachedCamera;
      if (!camera) {
        return;
      }
      if (value) {
        this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add(function(mesh) {
          if (!mesh) {
            return;
          }
          mesh.computeWorldMatrix(true);
          var diagonal = mesh.getBoundingInfo().diagonalLength;
          _this.lowerRadiusTransitionRange = diagonal * 0.05;
          _this.upperRadiusTransitionRange = diagonal * 0.05;
        });
      } else if (this._onMeshTargetChangedObserver) {
        camera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);
      }
    },
    enumerable: false,
    configurable: true
  });
  BouncingBehavior2.prototype.init = function() {
  };
  BouncingBehavior2.prototype.attach = function(camera) {
    var _this = this;
    this._attachedCamera = camera;
    this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(function() {
      if (!_this._attachedCamera) {
        return;
      }
      if (_this._isRadiusAtLimit(_this._attachedCamera.lowerRadiusLimit)) {
        _this._applyBoundRadiusAnimation(_this.lowerRadiusTransitionRange);
      }
      if (_this._isRadiusAtLimit(_this._attachedCamera.upperRadiusLimit)) {
        _this._applyBoundRadiusAnimation(_this.upperRadiusTransitionRange);
      }
    });
  };
  BouncingBehavior2.prototype.detach = function() {
    if (!this._attachedCamera) {
      return;
    }
    if (this._onAfterCheckInputsObserver) {
      this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);
    }
    if (this._onMeshTargetChangedObserver) {
      this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);
    }
    this._attachedCamera = null;
  };
  BouncingBehavior2.prototype._isRadiusAtLimit = function(radiusLimit) {
    if (!this._attachedCamera) {
      return false;
    }
    if (this._attachedCamera.radius === radiusLimit && !this._radiusIsAnimating) {
      return true;
    }
    return false;
  };
  BouncingBehavior2.prototype._applyBoundRadiusAnimation = function(radiusDelta) {
    var _this = this;
    if (!this._attachedCamera) {
      return;
    }
    if (!this._radiusBounceTransition) {
      BouncingBehavior2.EasingFunction.setEasingMode(BouncingBehavior2.EasingMode);
      this._radiusBounceTransition = Animation.CreateAnimation("radius", Animation.ANIMATIONTYPE_FLOAT, 60, BouncingBehavior2.EasingFunction);
    }
    this._cachedWheelPrecision = this._attachedCamera.wheelPrecision;
    this._attachedCamera.wheelPrecision = Infinity;
    this._attachedCamera.inertialRadiusOffset = 0;
    this.stopAllAnimations();
    this._radiusIsAnimating = true;
    var animatable = Animation.TransitionTo("radius", this._attachedCamera.radius + radiusDelta, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusBounceTransition, this.transitionDuration, function() {
      return _this._clearAnimationLocks();
    });
    if (animatable) {
      this._animatables.push(animatable);
    }
  };
  BouncingBehavior2.prototype._clearAnimationLocks = function() {
    this._radiusIsAnimating = false;
    if (this._attachedCamera) {
      this._attachedCamera.wheelPrecision = this._cachedWheelPrecision;
    }
  };
  BouncingBehavior2.prototype.stopAllAnimations = function() {
    if (this._attachedCamera) {
      this._attachedCamera.animations = [];
    }
    while (this._animatables.length) {
      this._animatables[0].onAnimationEnd = null;
      this._animatables[0].stop();
      this._animatables.shift();
    }
  };
  BouncingBehavior2.EasingFunction = new BackEase(0.3);
  BouncingBehavior2.EasingMode = EasingFunction.EASINGMODE_EASEOUT;
  return BouncingBehavior2;
}();

// node_modules/@babylonjs/core/Behaviors/Cameras/framingBehavior.js
var FramingBehavior = function() {
  function FramingBehavior2() {
    this._mode = FramingBehavior2.FitFrustumSidesMode;
    this._radiusScale = 1;
    this._positionScale = 0.5;
    this._defaultElevation = 0.3;
    this._elevationReturnTime = 1500;
    this._elevationReturnWaitTime = 1e3;
    this._zoomStopsAnimation = false;
    this._framingTime = 1500;
    this.autoCorrectCameraLimitsAndSensibility = true;
    this._isPointerDown = false;
    this._lastInteractionTime = -Infinity;
    this._animatables = new Array();
    this._betaIsAnimating = false;
  }
  Object.defineProperty(FramingBehavior2.prototype, "name", {
    get: function() {
      return "Framing";
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FramingBehavior2.prototype, "mode", {
    get: function() {
      return this._mode;
    },
    set: function(mode) {
      this._mode = mode;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FramingBehavior2.prototype, "radiusScale", {
    get: function() {
      return this._radiusScale;
    },
    set: function(radius) {
      this._radiusScale = radius;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FramingBehavior2.prototype, "positionScale", {
    get: function() {
      return this._positionScale;
    },
    set: function(scale) {
      this._positionScale = scale;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FramingBehavior2.prototype, "defaultElevation", {
    get: function() {
      return this._defaultElevation;
    },
    set: function(elevation) {
      this._defaultElevation = elevation;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FramingBehavior2.prototype, "elevationReturnTime", {
    get: function() {
      return this._elevationReturnTime;
    },
    set: function(speed) {
      this._elevationReturnTime = speed;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FramingBehavior2.prototype, "elevationReturnWaitTime", {
    get: function() {
      return this._elevationReturnWaitTime;
    },
    set: function(time) {
      this._elevationReturnWaitTime = time;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FramingBehavior2.prototype, "zoomStopsAnimation", {
    get: function() {
      return this._zoomStopsAnimation;
    },
    set: function(flag) {
      this._zoomStopsAnimation = flag;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FramingBehavior2.prototype, "framingTime", {
    get: function() {
      return this._framingTime;
    },
    set: function(time) {
      this._framingTime = time;
    },
    enumerable: false,
    configurable: true
  });
  FramingBehavior2.prototype.init = function() {
  };
  FramingBehavior2.prototype.attach = function(camera) {
    var _this = this;
    this._attachedCamera = camera;
    var scene = this._attachedCamera.getScene();
    FramingBehavior2.EasingFunction.setEasingMode(FramingBehavior2.EasingMode);
    this._onPrePointerObservableObserver = scene.onPrePointerObservable.add(function(pointerInfoPre) {
      if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {
        _this._isPointerDown = true;
        return;
      }
      if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {
        _this._isPointerDown = false;
      }
    });
    this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add(function(mesh) {
      if (mesh) {
        _this.zoomOnMesh(mesh);
      }
    });
    this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(function() {
      _this._applyUserInteraction();
      _this._maintainCameraAboveGround();
    });
  };
  FramingBehavior2.prototype.detach = function() {
    if (!this._attachedCamera) {
      return;
    }
    var scene = this._attachedCamera.getScene();
    if (this._onPrePointerObservableObserver) {
      scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);
    }
    if (this._onAfterCheckInputsObserver) {
      this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);
    }
    if (this._onMeshTargetChangedObserver) {
      this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);
    }
    this._attachedCamera = null;
  };
  FramingBehavior2.prototype.zoomOnMesh = function(mesh, focusOnOriginXZ, onAnimationEnd) {
    if (focusOnOriginXZ === void 0) {
      focusOnOriginXZ = false;
    }
    if (onAnimationEnd === void 0) {
      onAnimationEnd = null;
    }
    mesh.computeWorldMatrix(true);
    var boundingBox = mesh.getBoundingInfo().boundingBox;
    this.zoomOnBoundingInfo(boundingBox.minimumWorld, boundingBox.maximumWorld, focusOnOriginXZ, onAnimationEnd);
  };
  FramingBehavior2.prototype.zoomOnMeshHierarchy = function(mesh, focusOnOriginXZ, onAnimationEnd) {
    if (focusOnOriginXZ === void 0) {
      focusOnOriginXZ = false;
    }
    if (onAnimationEnd === void 0) {
      onAnimationEnd = null;
    }
    mesh.computeWorldMatrix(true);
    var boundingBox = mesh.getHierarchyBoundingVectors(true);
    this.zoomOnBoundingInfo(boundingBox.min, boundingBox.max, focusOnOriginXZ, onAnimationEnd);
  };
  FramingBehavior2.prototype.zoomOnMeshesHierarchy = function(meshes, focusOnOriginXZ, onAnimationEnd) {
    if (focusOnOriginXZ === void 0) {
      focusOnOriginXZ = false;
    }
    if (onAnimationEnd === void 0) {
      onAnimationEnd = null;
    }
    var min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    var max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    for (var i = 0; i < meshes.length; i++) {
      var boundingInfo = meshes[i].getHierarchyBoundingVectors(true);
      Vector3.CheckExtends(boundingInfo.min, min, max);
      Vector3.CheckExtends(boundingInfo.max, min, max);
    }
    this.zoomOnBoundingInfo(min, max, focusOnOriginXZ, onAnimationEnd);
  };
  FramingBehavior2.prototype.zoomOnBoundingInfo = function(minimumWorld, maximumWorld, focusOnOriginXZ, onAnimationEnd) {
    var _this = this;
    if (focusOnOriginXZ === void 0) {
      focusOnOriginXZ = false;
    }
    if (onAnimationEnd === void 0) {
      onAnimationEnd = null;
    }
    var zoomTarget;
    if (!this._attachedCamera) {
      return;
    }
    var bottom = minimumWorld.y;
    var top = maximumWorld.y;
    var zoomTargetY = bottom + (top - bottom) * this._positionScale;
    var radiusWorld = maximumWorld.subtract(minimumWorld).scale(0.5);
    if (focusOnOriginXZ) {
      zoomTarget = new Vector3(0, zoomTargetY, 0);
    } else {
      var centerWorld = minimumWorld.add(radiusWorld);
      zoomTarget = new Vector3(centerWorld.x, zoomTargetY, centerWorld.z);
    }
    if (!this._vectorTransition) {
      this._vectorTransition = Animation.CreateAnimation("target", Animation.ANIMATIONTYPE_VECTOR3, 60, FramingBehavior2.EasingFunction);
    }
    this._betaIsAnimating = true;
    var animatable = Animation.TransitionTo("target", zoomTarget, this._attachedCamera, this._attachedCamera.getScene(), 60, this._vectorTransition, this._framingTime);
    if (animatable) {
      this._animatables.push(animatable);
    }
    var radius = 0;
    if (this._mode === FramingBehavior2.FitFrustumSidesMode) {
      var position = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);
      if (this.autoCorrectCameraLimitsAndSensibility) {
        this._attachedCamera.lowerRadiusLimit = radiusWorld.length() + this._attachedCamera.minZ;
      }
      radius = position;
    } else if (this._mode === FramingBehavior2.IgnoreBoundsSizeMode) {
      radius = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);
      if (this.autoCorrectCameraLimitsAndSensibility && this._attachedCamera.lowerRadiusLimit === null) {
        this._attachedCamera.lowerRadiusLimit = this._attachedCamera.minZ;
      }
    }
    if (this.autoCorrectCameraLimitsAndSensibility) {
      var extend = maximumWorld.subtract(minimumWorld).length();
      this._attachedCamera.panningSensibility = 5e3 / extend;
      this._attachedCamera.wheelPrecision = 100 / radius;
    }
    if (!this._radiusTransition) {
      this._radiusTransition = Animation.CreateAnimation("radius", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior2.EasingFunction);
    }
    animatable = Animation.TransitionTo("radius", radius, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusTransition, this._framingTime, function() {
      _this.stopAllAnimations();
      if (onAnimationEnd) {
        onAnimationEnd();
      }
      if (_this._attachedCamera && _this._attachedCamera.useInputToRestoreState) {
        _this._attachedCamera.storeState();
      }
    });
    if (animatable) {
      this._animatables.push(animatable);
    }
  };
  FramingBehavior2.prototype._calculateLowerRadiusFromModelBoundingSphere = function(minimumWorld, maximumWorld) {
    var size = maximumWorld.subtract(minimumWorld);
    var boxVectorGlobalDiagonal = size.length();
    var frustumSlope = this._getFrustumSlope();
    var radiusWithoutFraming = boxVectorGlobalDiagonal * 0.5;
    var radius = radiusWithoutFraming * this._radiusScale;
    var distanceForHorizontalFrustum = radius * Math.sqrt(1 + 1 / (frustumSlope.x * frustumSlope.x));
    var distanceForVerticalFrustum = radius * Math.sqrt(1 + 1 / (frustumSlope.y * frustumSlope.y));
    var distance = Math.max(distanceForHorizontalFrustum, distanceForVerticalFrustum);
    var camera = this._attachedCamera;
    if (!camera) {
      return 0;
    }
    if (camera.lowerRadiusLimit && this._mode === FramingBehavior2.IgnoreBoundsSizeMode) {
      distance = distance < camera.lowerRadiusLimit ? camera.lowerRadiusLimit : distance;
    }
    if (camera.upperRadiusLimit) {
      distance = distance > camera.upperRadiusLimit ? camera.upperRadiusLimit : distance;
    }
    return distance;
  };
  FramingBehavior2.prototype._maintainCameraAboveGround = function() {
    var _this = this;
    if (this._elevationReturnTime < 0) {
      return;
    }
    var timeSinceInteraction = PrecisionDate.Now - this._lastInteractionTime;
    var defaultBeta = Math.PI * 0.5 - this._defaultElevation;
    var limitBeta = Math.PI * 0.5;
    if (this._attachedCamera && !this._betaIsAnimating && this._attachedCamera.beta > limitBeta && timeSinceInteraction >= this._elevationReturnWaitTime) {
      this._betaIsAnimating = true;
      this.stopAllAnimations();
      if (!this._betaTransition) {
        this._betaTransition = Animation.CreateAnimation("beta", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior2.EasingFunction);
      }
      var animatabe = Animation.TransitionTo("beta", defaultBeta, this._attachedCamera, this._attachedCamera.getScene(), 60, this._betaTransition, this._elevationReturnTime, function() {
        _this._clearAnimationLocks();
        _this.stopAllAnimations();
      });
      if (animatabe) {
        this._animatables.push(animatabe);
      }
    }
  };
  FramingBehavior2.prototype._getFrustumSlope = function() {
    var camera = this._attachedCamera;
    if (!camera) {
      return Vector2.Zero();
    }
    var engine = camera.getScene().getEngine();
    var aspectRatio = engine.getAspectRatio(camera);
    var frustumSlopeY = Math.tan(camera.fov / 2);
    var frustumSlopeX = frustumSlopeY * aspectRatio;
    return new Vector2(frustumSlopeX, frustumSlopeY);
  };
  FramingBehavior2.prototype._clearAnimationLocks = function() {
    this._betaIsAnimating = false;
  };
  FramingBehavior2.prototype._applyUserInteraction = function() {
    if (this.isUserIsMoving) {
      this._lastInteractionTime = PrecisionDate.Now;
      this.stopAllAnimations();
      this._clearAnimationLocks();
    }
  };
  FramingBehavior2.prototype.stopAllAnimations = function() {
    if (this._attachedCamera) {
      this._attachedCamera.animations = [];
    }
    while (this._animatables.length) {
      if (this._animatables[0]) {
        this._animatables[0].onAnimationEnd = null;
        this._animatables[0].stop();
      }
      this._animatables.shift();
    }
  };
  Object.defineProperty(FramingBehavior2.prototype, "isUserIsMoving", {
    get: function() {
      if (!this._attachedCamera) {
        return false;
      }
      return this._attachedCamera.inertialAlphaOffset !== 0 || this._attachedCamera.inertialBetaOffset !== 0 || this._attachedCamera.inertialRadiusOffset !== 0 || this._attachedCamera.inertialPanningX !== 0 || this._attachedCamera.inertialPanningY !== 0 || this._isPointerDown;
    },
    enumerable: false,
    configurable: true
  });
  FramingBehavior2.EasingFunction = new ExponentialEase();
  FramingBehavior2.EasingMode = EasingFunction.EASINGMODE_EASEINOUT;
  FramingBehavior2.IgnoreBoundsSizeMode = 0;
  FramingBehavior2.FitFrustumSidesMode = 1;
  return FramingBehavior2;
}();

// node_modules/@babylonjs/core/Behaviors/Meshes/attachToBoxBehavior.js
var FaceDirectionInfo = function() {
  function FaceDirectionInfo2(direction, rotatedDirection, diff, ignore) {
    if (rotatedDirection === void 0) {
      rotatedDirection = new Vector3();
    }
    if (diff === void 0) {
      diff = 0;
    }
    if (ignore === void 0) {
      ignore = false;
    }
    this.direction = direction;
    this.rotatedDirection = rotatedDirection;
    this.diff = diff;
    this.ignore = ignore;
  }
  return FaceDirectionInfo2;
}();
var AttachToBoxBehavior = function() {
  function AttachToBoxBehavior2(ui) {
    this.ui = ui;
    this.name = "AttachToBoxBehavior";
    this.distanceAwayFromFace = 0.15;
    this.distanceAwayFromBottomOfFace = 0.15;
    this._faceVectors = [new FaceDirectionInfo(Vector3.Up()), new FaceDirectionInfo(Vector3.Down()), new FaceDirectionInfo(Vector3.Left()), new FaceDirectionInfo(Vector3.Right()), new FaceDirectionInfo(Vector3.Forward()), new FaceDirectionInfo(Vector3.Forward().scaleInPlace(-1))];
    this._tmpMatrix = new Matrix();
    this._tmpVector = new Vector3();
    this._zeroVector = Vector3.Zero();
    this._lookAtTmpMatrix = new Matrix();
  }
  AttachToBoxBehavior2.prototype.init = function() {
  };
  AttachToBoxBehavior2.prototype._closestFace = function(targetDirection) {
    var _this = this;
    this._faceVectors.forEach(function(v) {
      if (!_this._target.rotationQuaternion) {
        _this._target.rotationQuaternion = Quaternion.RotationYawPitchRoll(_this._target.rotation.y, _this._target.rotation.x, _this._target.rotation.z);
      }
      _this._target.rotationQuaternion.toRotationMatrix(_this._tmpMatrix);
      Vector3.TransformCoordinatesToRef(v.direction, _this._tmpMatrix, v.rotatedDirection);
      v.diff = Vector3.GetAngleBetweenVectors(v.rotatedDirection, targetDirection, Vector3.Cross(v.rotatedDirection, targetDirection));
    });
    return this._faceVectors.reduce(function(min, p) {
      if (min.ignore) {
        return p;
      } else if (p.ignore) {
        return min;
      } else {
        return min.diff < p.diff ? min : p;
      }
    }, this._faceVectors[0]);
  };
  AttachToBoxBehavior2.prototype._lookAtToRef = function(pos, up, ref) {
    if (up === void 0) {
      up = new Vector3(0, 1, 0);
    }
    Matrix.LookAtLHToRef(this._zeroVector, pos, up, this._lookAtTmpMatrix);
    this._lookAtTmpMatrix.invert();
    Quaternion.FromRotationMatrixToRef(this._lookAtTmpMatrix, ref);
  };
  AttachToBoxBehavior2.prototype.attach = function(target) {
    var _this = this;
    this._target = target;
    this._scene = this._target.getScene();
    this._onRenderObserver = this._scene.onBeforeRenderObservable.add(function() {
      if (!_this._scene.activeCamera) {
        return;
      }
      var cameraPos = _this._scene.activeCamera.position;
      if (_this._scene.activeCamera.devicePosition) {
        cameraPos = _this._scene.activeCamera.devicePosition;
      }
      var facing = _this._closestFace(cameraPos.subtract(target.position));
      if (_this._scene.activeCamera.leftCamera) {
        _this._scene.activeCamera.leftCamera.computeWorldMatrix().getRotationMatrixToRef(_this._tmpMatrix);
      } else {
        _this._scene.activeCamera.computeWorldMatrix().getRotationMatrixToRef(_this._tmpMatrix);
      }
      Vector3.TransformCoordinatesToRef(Vector3.Up(), _this._tmpMatrix, _this._tmpVector);
      _this._faceVectors.forEach(function(v) {
        if (facing.direction.x && v.direction.x) {
          v.ignore = true;
        }
        if (facing.direction.y && v.direction.y) {
          v.ignore = true;
        }
        if (facing.direction.z && v.direction.z) {
          v.ignore = true;
        }
      });
      var facingUp = _this._closestFace(_this._tmpVector);
      _this._faceVectors.forEach(function(v) {
        v.ignore = false;
      });
      _this.ui.position.copyFrom(target.position);
      if (facing.direction.x) {
        facing.rotatedDirection.scaleToRef(target.scaling.x / 2 + _this.distanceAwayFromFace, _this._tmpVector);
        _this.ui.position.addInPlace(_this._tmpVector);
      }
      if (facing.direction.y) {
        facing.rotatedDirection.scaleToRef(target.scaling.y / 2 + _this.distanceAwayFromFace, _this._tmpVector);
        _this.ui.position.addInPlace(_this._tmpVector);
      }
      if (facing.direction.z) {
        facing.rotatedDirection.scaleToRef(target.scaling.z / 2 + _this.distanceAwayFromFace, _this._tmpVector);
        _this.ui.position.addInPlace(_this._tmpVector);
      }
      if (!_this.ui.rotationQuaternion) {
        _this.ui.rotationQuaternion = Quaternion.RotationYawPitchRoll(_this.ui.rotation.y, _this.ui.rotation.x, _this.ui.rotation.z);
      }
      facing.rotatedDirection.scaleToRef(-1, _this._tmpVector);
      _this._lookAtToRef(_this._tmpVector, facingUp.rotatedDirection, _this.ui.rotationQuaternion);
      if (facingUp.direction.x) {
        _this.ui.up.scaleToRef(_this.distanceAwayFromBottomOfFace - target.scaling.x / 2, _this._tmpVector);
      }
      if (facingUp.direction.y) {
        _this.ui.up.scaleToRef(_this.distanceAwayFromBottomOfFace - target.scaling.y / 2, _this._tmpVector);
      }
      if (facingUp.direction.z) {
        _this.ui.up.scaleToRef(_this.distanceAwayFromBottomOfFace - target.scaling.z / 2, _this._tmpVector);
      }
      _this.ui.position.addInPlace(_this._tmpVector);
    });
  };
  AttachToBoxBehavior2.prototype.detach = function() {
    this._scene.onBeforeRenderObservable.remove(this._onRenderObserver);
  };
  return AttachToBoxBehavior2;
}();

// node_modules/@babylonjs/core/Culling/ray.js
var Ray = function() {
  function Ray2(origin, direction, length) {
    if (length === void 0) {
      length = Number.MAX_VALUE;
    }
    this.origin = origin;
    this.direction = direction;
    this.length = length;
  }
  Ray2.prototype.intersectsBoxMinMax = function(minimum, maximum, intersectionTreshold) {
    if (intersectionTreshold === void 0) {
      intersectionTreshold = 0;
    }
    var newMinimum = Ray2._TmpVector3[0].copyFromFloats(minimum.x - intersectionTreshold, minimum.y - intersectionTreshold, minimum.z - intersectionTreshold);
    var newMaximum = Ray2._TmpVector3[1].copyFromFloats(maximum.x + intersectionTreshold, maximum.y + intersectionTreshold, maximum.z + intersectionTreshold);
    var d = 0;
    var maxValue = Number.MAX_VALUE;
    var inv;
    var min;
    var max;
    var temp;
    if (Math.abs(this.direction.x) < 1e-7) {
      if (this.origin.x < newMinimum.x || this.origin.x > newMaximum.x) {
        return false;
      }
    } else {
      inv = 1 / this.direction.x;
      min = (newMinimum.x - this.origin.x) * inv;
      max = (newMaximum.x - this.origin.x) * inv;
      if (max === -Infinity) {
        max = Infinity;
      }
      if (min > max) {
        temp = min;
        min = max;
        max = temp;
      }
      d = Math.max(min, d);
      maxValue = Math.min(max, maxValue);
      if (d > maxValue) {
        return false;
      }
    }
    if (Math.abs(this.direction.y) < 1e-7) {
      if (this.origin.y < newMinimum.y || this.origin.y > newMaximum.y) {
        return false;
      }
    } else {
      inv = 1 / this.direction.y;
      min = (newMinimum.y - this.origin.y) * inv;
      max = (newMaximum.y - this.origin.y) * inv;
      if (max === -Infinity) {
        max = Infinity;
      }
      if (min > max) {
        temp = min;
        min = max;
        max = temp;
      }
      d = Math.max(min, d);
      maxValue = Math.min(max, maxValue);
      if (d > maxValue) {
        return false;
      }
    }
    if (Math.abs(this.direction.z) < 1e-7) {
      if (this.origin.z < newMinimum.z || this.origin.z > newMaximum.z) {
        return false;
      }
    } else {
      inv = 1 / this.direction.z;
      min = (newMinimum.z - this.origin.z) * inv;
      max = (newMaximum.z - this.origin.z) * inv;
      if (max === -Infinity) {
        max = Infinity;
      }
      if (min > max) {
        temp = min;
        min = max;
        max = temp;
      }
      d = Math.max(min, d);
      maxValue = Math.min(max, maxValue);
      if (d > maxValue) {
        return false;
      }
    }
    return true;
  };
  Ray2.prototype.intersectsBox = function(box, intersectionTreshold) {
    if (intersectionTreshold === void 0) {
      intersectionTreshold = 0;
    }
    return this.intersectsBoxMinMax(box.minimum, box.maximum, intersectionTreshold);
  };
  Ray2.prototype.intersectsSphere = function(sphere, intersectionTreshold) {
    if (intersectionTreshold === void 0) {
      intersectionTreshold = 0;
    }
    var x = sphere.center.x - this.origin.x;
    var y = sphere.center.y - this.origin.y;
    var z = sphere.center.z - this.origin.z;
    var pyth = x * x + y * y + z * z;
    var radius = sphere.radius + intersectionTreshold;
    var rr = radius * radius;
    if (pyth <= rr) {
      return true;
    }
    var dot = x * this.direction.x + y * this.direction.y + z * this.direction.z;
    if (dot < 0) {
      return false;
    }
    var temp = pyth - dot * dot;
    return temp <= rr;
  };
  Ray2.prototype.intersectsTriangle = function(vertex0, vertex1, vertex2) {
    var edge1 = Ray2._TmpVector3[0];
    var edge2 = Ray2._TmpVector3[1];
    var pvec = Ray2._TmpVector3[2];
    var tvec = Ray2._TmpVector3[3];
    var qvec = Ray2._TmpVector3[4];
    vertex1.subtractToRef(vertex0, edge1);
    vertex2.subtractToRef(vertex0, edge2);
    Vector3.CrossToRef(this.direction, edge2, pvec);
    var det = Vector3.Dot(edge1, pvec);
    if (det === 0) {
      return null;
    }
    var invdet = 1 / det;
    this.origin.subtractToRef(vertex0, tvec);
    var bv = Vector3.Dot(tvec, pvec) * invdet;
    if (bv < 0 || bv > 1) {
      return null;
    }
    Vector3.CrossToRef(tvec, edge1, qvec);
    var bw = Vector3.Dot(this.direction, qvec) * invdet;
    if (bw < 0 || bv + bw > 1) {
      return null;
    }
    var distance = Vector3.Dot(edge2, qvec) * invdet;
    if (distance > this.length) {
      return null;
    }
    return new IntersectionInfo(1 - bv - bw, bv, distance);
  };
  Ray2.prototype.intersectsPlane = function(plane) {
    var distance;
    var result1 = Vector3.Dot(plane.normal, this.direction);
    if (Math.abs(result1) < 999999997475243e-21) {
      return null;
    } else {
      var result2 = Vector3.Dot(plane.normal, this.origin);
      distance = (-plane.d - result2) / result1;
      if (distance < 0) {
        if (distance < -999999997475243e-21) {
          return null;
        } else {
          return 0;
        }
      }
      return distance;
    }
  };
  Ray2.prototype.intersectsAxis = function(axis, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    switch (axis) {
      case "y":
        var t = (this.origin.y - offset) / this.direction.y;
        if (t > 0) {
          return null;
        }
        return new Vector3(this.origin.x + this.direction.x * -t, offset, this.origin.z + this.direction.z * -t);
      case "x":
        var t = (this.origin.x - offset) / this.direction.x;
        if (t > 0) {
          return null;
        }
        return new Vector3(offset, this.origin.y + this.direction.y * -t, this.origin.z + this.direction.z * -t);
      case "z":
        var t = (this.origin.z - offset) / this.direction.z;
        if (t > 0) {
          return null;
        }
        return new Vector3(this.origin.x + this.direction.x * -t, this.origin.y + this.direction.y * -t, offset);
      default:
        return null;
    }
  };
  Ray2.prototype.intersectsMesh = function(mesh, fastCheck) {
    var tm = TmpVectors.Matrix[0];
    mesh.getWorldMatrix().invertToRef(tm);
    if (this._tmpRay) {
      Ray2.TransformToRef(this, tm, this._tmpRay);
    } else {
      this._tmpRay = Ray2.Transform(this, tm);
    }
    return mesh.intersects(this._tmpRay, fastCheck);
  };
  Ray2.prototype.intersectsMeshes = function(meshes, fastCheck, results) {
    if (results) {
      results.length = 0;
    } else {
      results = [];
    }
    for (var i = 0; i < meshes.length; i++) {
      var pickInfo = this.intersectsMesh(meshes[i], fastCheck);
      if (pickInfo.hit) {
        results.push(pickInfo);
      }
    }
    results.sort(this._comparePickingInfo);
    return results;
  };
  Ray2.prototype._comparePickingInfo = function(pickingInfoA, pickingInfoB) {
    if (pickingInfoA.distance < pickingInfoB.distance) {
      return -1;
    } else if (pickingInfoA.distance > pickingInfoB.distance) {
      return 1;
    } else {
      return 0;
    }
  };
  Ray2.prototype.intersectionSegment = function(sega, segb, threshold) {
    var o = this.origin;
    var u = TmpVectors.Vector3[0];
    var rsegb = TmpVectors.Vector3[1];
    var v = TmpVectors.Vector3[2];
    var w = TmpVectors.Vector3[3];
    segb.subtractToRef(sega, u);
    this.direction.scaleToRef(Ray2.rayl, v);
    o.addToRef(v, rsegb);
    sega.subtractToRef(o, w);
    var a = Vector3.Dot(u, u);
    var b = Vector3.Dot(u, v);
    var c = Vector3.Dot(v, v);
    var d = Vector3.Dot(u, w);
    var e = Vector3.Dot(v, w);
    var D = a * c - b * b;
    var sc, sN, sD = D;
    var tc, tN, tD = D;
    if (D < Ray2.smallnum) {
      sN = 0;
      sD = 1;
      tN = e;
      tD = c;
    } else {
      sN = b * e - c * d;
      tN = a * e - b * d;
      if (sN < 0) {
        sN = 0;
        tN = e;
        tD = c;
      } else if (sN > sD) {
        sN = sD;
        tN = e + b;
        tD = c;
      }
    }
    if (tN < 0) {
      tN = 0;
      if (-d < 0) {
        sN = 0;
      } else if (-d > a) {
        sN = sD;
      } else {
        sN = -d;
        sD = a;
      }
    } else if (tN > tD) {
      tN = tD;
      if (-d + b < 0) {
        sN = 0;
      } else if (-d + b > a) {
        sN = sD;
      } else {
        sN = -d + b;
        sD = a;
      }
    }
    sc = Math.abs(sN) < Ray2.smallnum ? 0 : sN / sD;
    tc = Math.abs(tN) < Ray2.smallnum ? 0 : tN / tD;
    var qtc = TmpVectors.Vector3[4];
    v.scaleToRef(tc, qtc);
    var qsc = TmpVectors.Vector3[5];
    u.scaleToRef(sc, qsc);
    qsc.addInPlace(w);
    var dP = TmpVectors.Vector3[6];
    qsc.subtractToRef(qtc, dP);
    var isIntersected = tc > 0 && tc <= this.length && dP.lengthSquared() < threshold * threshold;
    if (isIntersected) {
      return qsc.length();
    }
    return -1;
  };
  Ray2.prototype.update = function(x, y, viewportWidth, viewportHeight, world, view, projection) {
    this.unprojectRayToRef(x, y, viewportWidth, viewportHeight, world, view, projection);
    return this;
  };
  Ray2.Zero = function() {
    return new Ray2(Vector3.Zero(), Vector3.Zero());
  };
  Ray2.CreateNew = function(x, y, viewportWidth, viewportHeight, world, view, projection) {
    var result = Ray2.Zero();
    return result.update(x, y, viewportWidth, viewportHeight, world, view, projection);
  };
  Ray2.CreateNewFromTo = function(origin, end, world) {
    if (world === void 0) {
      world = Matrix.IdentityReadOnly;
    }
    var direction = end.subtract(origin);
    var length = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);
    direction.normalize();
    return Ray2.Transform(new Ray2(origin, direction, length), world);
  };
  Ray2.Transform = function(ray, matrix) {
    var result = new Ray2(new Vector3(0, 0, 0), new Vector3(0, 0, 0));
    Ray2.TransformToRef(ray, matrix, result);
    return result;
  };
  Ray2.TransformToRef = function(ray, matrix, result) {
    Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);
    Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);
    result.length = ray.length;
    var dir = result.direction;
    var len = dir.length();
    if (!(len === 0 || len === 1)) {
      var num = 1 / len;
      dir.x *= num;
      dir.y *= num;
      dir.z *= num;
      result.length *= len;
    }
  };
  Ray2.prototype.unprojectRayToRef = function(sourceX, sourceY, viewportWidth, viewportHeight, world, view, projection) {
    var matrix = TmpVectors.Matrix[0];
    world.multiplyToRef(view, matrix);
    matrix.multiplyToRef(projection, matrix);
    matrix.invert();
    var nearScreenSource = TmpVectors.Vector3[0];
    nearScreenSource.x = sourceX / viewportWidth * 2 - 1;
    nearScreenSource.y = -(sourceY / viewportHeight * 2 - 1);
    nearScreenSource.z = -1;
    var farScreenSource = TmpVectors.Vector3[1].copyFromFloats(nearScreenSource.x, nearScreenSource.y, 1);
    var nearVec3 = TmpVectors.Vector3[2];
    var farVec3 = TmpVectors.Vector3[3];
    Vector3._UnprojectFromInvertedMatrixToRef(nearScreenSource, matrix, nearVec3);
    Vector3._UnprojectFromInvertedMatrixToRef(farScreenSource, matrix, farVec3);
    this.origin.copyFrom(nearVec3);
    farVec3.subtractToRef(nearVec3, this.direction);
    this.direction.normalize();
  };
  Ray2._TmpVector3 = ArrayTools.BuildArray(6, Vector3.Zero);
  Ray2.smallnum = 1e-8;
  Ray2.rayl = 1e9;
  return Ray2;
}();
Scene.prototype.createPickingRay = function(x, y, world, camera, cameraViewSpace) {
  if (cameraViewSpace === void 0) {
    cameraViewSpace = false;
  }
  var result = Ray.Zero();
  this.createPickingRayToRef(x, y, world, result, camera, cameraViewSpace);
  return result;
};
Scene.prototype.createPickingRayToRef = function(x, y, world, result, camera, cameraViewSpace) {
  if (cameraViewSpace === void 0) {
    cameraViewSpace = false;
  }
  var engine = this.getEngine();
  if (!camera) {
    if (!this.activeCamera) {
      return this;
    }
    camera = this.activeCamera;
  }
  var cameraViewport = camera.viewport;
  var viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());
  x = x / engine.getHardwareScalingLevel() - viewport.x;
  y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);
  result.update(x, y, viewport.width, viewport.height, world ? world : Matrix.IdentityReadOnly, cameraViewSpace ? Matrix.IdentityReadOnly : camera.getViewMatrix(), camera.getProjectionMatrix());
  return this;
};
Scene.prototype.createPickingRayInCameraSpace = function(x, y, camera) {
  var result = Ray.Zero();
  this.createPickingRayInCameraSpaceToRef(x, y, result, camera);
  return result;
};
Scene.prototype.createPickingRayInCameraSpaceToRef = function(x, y, result, camera) {
  if (!PickingInfo) {
    return this;
  }
  var engine = this.getEngine();
  if (!camera) {
    if (!this.activeCamera) {
      throw new Error("Active camera not set");
    }
    camera = this.activeCamera;
  }
  var cameraViewport = camera.viewport;
  var viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());
  var identity = Matrix.Identity();
  x = x / engine.getHardwareScalingLevel() - viewport.x;
  y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);
  result.update(x, y, viewport.width, viewport.height, identity, identity, camera.getProjectionMatrix());
  return this;
};
Scene.prototype._internalPickForMesh = function(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate, skipBoundingInfo) {
  var ray = rayFunction(world);
  var result = mesh.intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo, world, skipBoundingInfo);
  if (!result || !result.hit) {
    return null;
  }
  if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {
    return null;
  }
  return result;
};
Scene.prototype._internalPick = function(rayFunction, predicate, fastCheck, onlyBoundingInfo, trianglePredicate) {
  if (!PickingInfo) {
    return null;
  }
  var pickingInfo = null;
  for (var meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {
    var mesh = this.meshes[meshIndex];
    if (predicate) {
      if (!predicate(mesh)) {
        continue;
      }
    } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {
      continue;
    }
    var world = mesh.skeleton && mesh.skeleton.overrideMesh ? mesh.skeleton.overrideMesh.getWorldMatrix() : mesh.getWorldMatrix();
    if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {
      var result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, true, true, trianglePredicate);
      if (result) {
        if (onlyBoundingInfo) {
          return pickingInfo;
        }
        var tmpMatrix4 = TmpVectors.Matrix[1];
        var thinMatrices = mesh.thinInstanceGetWorldMatrices();
        for (var index = 0; index < thinMatrices.length; index++) {
          var thinMatrix = thinMatrices[index];
          thinMatrix.multiplyToRef(world, tmpMatrix4);
          var result_1 = this._internalPickForMesh(pickingInfo, rayFunction, mesh, tmpMatrix4, fastCheck, onlyBoundingInfo, trianglePredicate, true);
          if (result_1) {
            pickingInfo = result_1;
            pickingInfo.thinInstanceIndex = index;
            if (fastCheck) {
              return pickingInfo;
            }
          }
        }
      }
    } else {
      var result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate);
      if (result) {
        pickingInfo = result;
        if (fastCheck) {
          return pickingInfo;
        }
      }
    }
  }
  return pickingInfo || new PickingInfo();
};
Scene.prototype._internalMultiPick = function(rayFunction, predicate, trianglePredicate) {
  if (!PickingInfo) {
    return null;
  }
  var pickingInfos = new Array();
  for (var meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {
    var mesh = this.meshes[meshIndex];
    if (predicate) {
      if (!predicate(mesh)) {
        continue;
      }
    } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {
      continue;
    }
    var world = mesh.skeleton && mesh.skeleton.overrideMesh ? mesh.skeleton.overrideMesh.getWorldMatrix() : mesh.getWorldMatrix();
    if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {
      var result = this._internalPickForMesh(null, rayFunction, mesh, world, true, true, trianglePredicate);
      if (result) {
        var tmpMatrix4 = TmpVectors.Matrix[1];
        var thinMatrices = mesh.thinInstanceGetWorldMatrices();
        for (var index = 0; index < thinMatrices.length; index++) {
          var thinMatrix = thinMatrices[index];
          thinMatrix.multiplyToRef(world, tmpMatrix4);
          var result_2 = this._internalPickForMesh(null, rayFunction, mesh, tmpMatrix4, false, false, trianglePredicate, true);
          if (result_2) {
            result_2.thinInstanceIndex = index;
            pickingInfos.push(result_2);
          }
        }
      }
    } else {
      var result = this._internalPickForMesh(null, rayFunction, mesh, world, false, false, trianglePredicate);
      if (result) {
        pickingInfos.push(result);
      }
    }
  }
  return pickingInfos;
};
Scene.prototype.pickWithBoundingInfo = function(x, y, predicate, fastCheck, camera) {
  var _this = this;
  if (!PickingInfo) {
    return null;
  }
  var result = this._internalPick(function(world) {
    if (!_this._tempPickingRay) {
      _this._tempPickingRay = Ray.Zero();
    }
    _this.createPickingRayToRef(x, y, world, _this._tempPickingRay, camera || null);
    return _this._tempPickingRay;
  }, predicate, fastCheck, true);
  if (result) {
    result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);
  }
  return result;
};
Scene.prototype.pick = function(x, y, predicate, fastCheck, camera, trianglePredicate) {
  var _this = this;
  if (!PickingInfo) {
    return null;
  }
  var result = this._internalPick(function(world) {
    if (!_this._tempPickingRay) {
      _this._tempPickingRay = Ray.Zero();
    }
    _this.createPickingRayToRef(x, y, world, _this._tempPickingRay, camera || null);
    return _this._tempPickingRay;
  }, predicate, fastCheck, false, trianglePredicate);
  if (result) {
    result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);
  }
  return result;
};
Scene.prototype.pickWithRay = function(ray, predicate, fastCheck, trianglePredicate) {
  var _this = this;
  var result = this._internalPick(function(world) {
    if (!_this._pickWithRayInverseMatrix) {
      _this._pickWithRayInverseMatrix = Matrix.Identity();
    }
    world.invertToRef(_this._pickWithRayInverseMatrix);
    if (!_this._cachedRayForTransform) {
      _this._cachedRayForTransform = Ray.Zero();
    }
    Ray.TransformToRef(ray, _this._pickWithRayInverseMatrix, _this._cachedRayForTransform);
    return _this._cachedRayForTransform;
  }, predicate, fastCheck, false, trianglePredicate);
  if (result) {
    result.ray = ray;
  }
  return result;
};
Scene.prototype.multiPick = function(x, y, predicate, camera, trianglePredicate) {
  var _this = this;
  return this._internalMultiPick(function(world) {
    return _this.createPickingRay(x, y, world, camera || null);
  }, predicate, trianglePredicate);
};
Scene.prototype.multiPickWithRay = function(ray, predicate, trianglePredicate) {
  var _this = this;
  return this._internalMultiPick(function(world) {
    if (!_this._pickWithRayInverseMatrix) {
      _this._pickWithRayInverseMatrix = Matrix.Identity();
    }
    world.invertToRef(_this._pickWithRayInverseMatrix);
    if (!_this._cachedRayForTransform) {
      _this._cachedRayForTransform = Ray.Zero();
    }
    Ray.TransformToRef(ray, _this._pickWithRayInverseMatrix, _this._cachedRayForTransform);
    return _this._cachedRayForTransform;
  }, predicate, trianglePredicate);
};
Camera.prototype.getForwardRay = function(length, transform, origin) {
  if (length === void 0) {
    length = 100;
  }
  return this.getForwardRayToRef(new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);
};
Camera.prototype.getForwardRayToRef = function(refRay, length, transform, origin) {
  if (length === void 0) {
    length = 100;
  }
  if (!transform) {
    transform = this.getWorldMatrix();
  }
  refRay.length = length;
  if (!origin) {
    refRay.origin.copyFrom(this.position);
  } else {
    refRay.origin.copyFrom(origin);
  }
  TmpVectors.Vector3[2].set(0, 0, this._scene.useRightHandedSystem ? -1 : 1);
  Vector3.TransformNormalToRef(TmpVectors.Vector3[2], transform, TmpVectors.Vector3[3]);
  Vector3.NormalizeToRef(TmpVectors.Vector3[3], refRay.direction);
  return refRay;
};

// node_modules/@babylonjs/core/Misc/pivotTools.js
var PivotTools = function() {
  function PivotTools2() {
  }
  PivotTools2._RemoveAndStorePivotPoint = function(mesh) {
    if (mesh && PivotTools2._PivotCached === 0) {
      mesh.getPivotPointToRef(PivotTools2._OldPivotPoint);
      PivotTools2._PivotPostMultiplyPivotMatrix = mesh._postMultiplyPivotMatrix;
      if (!PivotTools2._OldPivotPoint.equalsToFloats(0, 0, 0)) {
        mesh.setPivotMatrix(Matrix.IdentityReadOnly);
        PivotTools2._OldPivotPoint.subtractToRef(mesh.getPivotPoint(), PivotTools2._PivotTranslation);
        PivotTools2._PivotTmpVector.copyFromFloats(1, 1, 1);
        PivotTools2._PivotTmpVector.subtractInPlace(mesh.scaling);
        PivotTools2._PivotTmpVector.multiplyInPlace(PivotTools2._PivotTranslation);
        mesh.position.addInPlace(PivotTools2._PivotTmpVector);
      }
    }
    PivotTools2._PivotCached++;
  };
  PivotTools2._RestorePivotPoint = function(mesh) {
    if (mesh && !PivotTools2._OldPivotPoint.equalsToFloats(0, 0, 0) && PivotTools2._PivotCached === 1) {
      mesh.setPivotPoint(PivotTools2._OldPivotPoint);
      mesh._postMultiplyPivotMatrix = PivotTools2._PivotPostMultiplyPivotMatrix;
      PivotTools2._PivotTmpVector.copyFromFloats(1, 1, 1);
      PivotTools2._PivotTmpVector.subtractInPlace(mesh.scaling);
      PivotTools2._PivotTmpVector.multiplyInPlace(PivotTools2._PivotTranslation);
      mesh.position.subtractInPlace(PivotTools2._PivotTmpVector);
    }
    this._PivotCached--;
  };
  PivotTools2._PivotCached = 0;
  PivotTools2._OldPivotPoint = new Vector3();
  PivotTools2._PivotTranslation = new Vector3();
  PivotTools2._PivotTmpVector = new Vector3();
  PivotTools2._PivotPostMultiplyPivotMatrix = false;
  return PivotTools2;
}();

// node_modules/@babylonjs/core/Behaviors/Meshes/pointerDragBehavior.js
var PointerDragBehavior = function() {
  function PointerDragBehavior2(options) {
    this._useAlternatePickedPointAboveMaxDragAngleDragSpeed = -1.1;
    this.maxDragAngle = 0;
    this._useAlternatePickedPointAboveMaxDragAngle = false;
    this.currentDraggingPointerID = -1;
    this.dragging = false;
    this.dragDeltaRatio = 0.2;
    this.updateDragPlane = true;
    this._debugMode = false;
    this._moving = false;
    this.onDragObservable = new Observable();
    this.onDragStartObservable = new Observable();
    this.onDragEndObservable = new Observable();
    this.moveAttached = true;
    this.enabled = true;
    this.startAndReleaseDragOnPointerEvents = true;
    this.detachCameraControls = true;
    this.useObjectOrientationForDragging = true;
    this.validateDrag = function(targetPosition) {
      return true;
    };
    this._tmpVector = new Vector3(0, 0, 0);
    this._alternatePickedPoint = new Vector3(0, 0, 0);
    this._worldDragAxis = new Vector3(0, 0, 0);
    this._targetPosition = new Vector3(0, 0, 0);
    this._attachedToElement = false;
    this._startDragRay = new Ray(new Vector3(), new Vector3());
    this._lastPointerRay = {};
    this._dragDelta = new Vector3();
    this._pointA = new Vector3(0, 0, 0);
    this._pointC = new Vector3(0, 0, 0);
    this._localAxis = new Vector3(0, 0, 0);
    this._lookAt = new Vector3(0, 0, 0);
    this._options = options ? options : {};
    var optionCount = 0;
    if (this._options.dragAxis) {
      optionCount++;
    }
    if (this._options.dragPlaneNormal) {
      optionCount++;
    }
    if (optionCount > 1) {
      throw "Multiple drag modes specified in dragBehavior options. Only one expected";
    }
  }
  Object.defineProperty(PointerDragBehavior2.prototype, "options", {
    get: function() {
      return this._options;
    },
    set: function(options) {
      this._options = options;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PointerDragBehavior2.prototype, "name", {
    get: function() {
      return "PointerDrag";
    },
    enumerable: false,
    configurable: true
  });
  PointerDragBehavior2.prototype.init = function() {
  };
  PointerDragBehavior2.prototype.attach = function(ownerNode, predicate) {
    var _this = this;
    this._scene = ownerNode.getScene();
    this.attachedNode = ownerNode;
    if (!PointerDragBehavior2._planeScene) {
      if (this._debugMode) {
        PointerDragBehavior2._planeScene = this._scene;
      } else {
        PointerDragBehavior2._planeScene = new Scene(this._scene.getEngine(), { virtual: true });
        PointerDragBehavior2._planeScene.detachControl();
        this._scene.onDisposeObservable.addOnce(function() {
          PointerDragBehavior2._planeScene.dispose();
          PointerDragBehavior2._planeScene = null;
        });
      }
    }
    this._dragPlane = Mesh.CreatePlane("pointerDragPlane", this._debugMode ? 1 : 1e4, PointerDragBehavior2._planeScene, false, Mesh.DOUBLESIDE);
    this.lastDragPosition = new Vector3(0, 0, 0);
    var pickPredicate = !!predicate ? predicate : function(m) {
      return _this.attachedNode == m || m.isDescendantOf(_this.attachedNode);
    };
    this._pointerObserver = this._scene.onPointerObservable.add(function(pointerInfo, eventState) {
      if (!_this.enabled) {
        return;
      }
      if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {
        if (_this.startAndReleaseDragOnPointerEvents && !_this.dragging && pointerInfo.pickInfo && pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh && pointerInfo.pickInfo.pickedPoint && pointerInfo.pickInfo.ray && pickPredicate(pointerInfo.pickInfo.pickedMesh)) {
          _this._startDrag(pointerInfo.event.pointerId, pointerInfo.pickInfo.ray, pointerInfo.pickInfo.pickedPoint);
        }
      } else if (pointerInfo.type == PointerEventTypes.POINTERUP) {
        if (_this.startAndReleaseDragOnPointerEvents && _this.currentDraggingPointerID == pointerInfo.event.pointerId) {
          _this.releaseDrag();
        }
      } else if (pointerInfo.type == PointerEventTypes.POINTERMOVE) {
        var pointerId = pointerInfo.event.pointerId;
        if (_this.currentDraggingPointerID === PointerDragBehavior2._AnyMouseID && pointerId !== PointerDragBehavior2._AnyMouseID) {
          var evt = pointerInfo.event;
          var isMouseEvent = evt.pointerType === "mouse" || !_this._scene.getEngine().hostInformation.isMobile && evt instanceof MouseEvent;
          if (isMouseEvent) {
            if (_this._lastPointerRay[_this.currentDraggingPointerID]) {
              _this._lastPointerRay[pointerId] = _this._lastPointerRay[_this.currentDraggingPointerID];
              delete _this._lastPointerRay[_this.currentDraggingPointerID];
            }
            _this.currentDraggingPointerID = pointerId;
          }
        }
        if (!_this._lastPointerRay[pointerId]) {
          _this._lastPointerRay[pointerId] = new Ray(new Vector3(), new Vector3());
        }
        if (pointerInfo.pickInfo && pointerInfo.pickInfo.ray) {
          _this._lastPointerRay[pointerId].origin.copyFrom(pointerInfo.pickInfo.ray.origin);
          _this._lastPointerRay[pointerId].direction.copyFrom(pointerInfo.pickInfo.ray.direction);
          if (_this.currentDraggingPointerID == pointerId && _this.dragging) {
            _this._moveDrag(pointerInfo.pickInfo.ray);
          }
        }
      }
    });
    this._beforeRenderObserver = this._scene.onBeforeRenderObservable.add(function() {
      if (_this._moving && _this.moveAttached) {
        PivotTools._RemoveAndStorePivotPoint(_this.attachedNode);
        _this._targetPosition.subtractToRef(_this.attachedNode.absolutePosition, _this._tmpVector);
        _this._tmpVector.scaleInPlace(_this.dragDeltaRatio);
        _this.attachedNode.getAbsolutePosition().addToRef(_this._tmpVector, _this._tmpVector);
        if (_this.validateDrag(_this._tmpVector)) {
          _this.attachedNode.setAbsolutePosition(_this._tmpVector);
        }
        PivotTools._RestorePivotPoint(_this.attachedNode);
      }
    });
  };
  PointerDragBehavior2.prototype.releaseDrag = function() {
    if (this.dragging) {
      this.dragging = false;
      this.onDragEndObservable.notifyObservers({ dragPlanePoint: this.lastDragPosition, pointerId: this.currentDraggingPointerID });
    }
    this.currentDraggingPointerID = -1;
    this._moving = false;
    if (this.detachCameraControls && this._attachedToElement && this._scene.activeCamera && !this._scene.activeCamera.leftCamera) {
      if (this._scene.activeCamera.getClassName() === "ArcRotateCamera") {
        var arcRotateCamera = this._scene.activeCamera;
        arcRotateCamera.attachControl(arcRotateCamera.inputs ? arcRotateCamera.inputs.noPreventDefault : true, arcRotateCamera._useCtrlForPanning, arcRotateCamera._panningMouseButton);
      } else {
        this._scene.activeCamera.attachControl(this._scene.activeCamera.inputs ? this._scene.activeCamera.inputs.noPreventDefault : true);
      }
      this._attachedToElement = false;
    }
  };
  PointerDragBehavior2.prototype.startDrag = function(pointerId, fromRay, startPickedPoint) {
    if (pointerId === void 0) {
      pointerId = PointerDragBehavior2._AnyMouseID;
    }
    this._startDrag(pointerId, fromRay, startPickedPoint);
    var lastRay = this._lastPointerRay[pointerId];
    if (pointerId === PointerDragBehavior2._AnyMouseID) {
      lastRay = this._lastPointerRay[Object.keys(this._lastPointerRay)[0]];
    }
    if (lastRay) {
      this._moveDrag(lastRay);
    }
  };
  PointerDragBehavior2.prototype._startDrag = function(pointerId, fromRay, startPickedPoint) {
    if (!this._scene.activeCamera || this.dragging || !this.attachedNode) {
      return;
    }
    PivotTools._RemoveAndStorePivotPoint(this.attachedNode);
    if (fromRay) {
      this._startDragRay.direction.copyFrom(fromRay.direction);
      this._startDragRay.origin.copyFrom(fromRay.origin);
    } else {
      this._startDragRay.origin.copyFrom(this._scene.activeCamera.position);
      this.attachedNode.getWorldMatrix().getTranslationToRef(this._tmpVector);
      this._tmpVector.subtractToRef(this._scene.activeCamera.position, this._startDragRay.direction);
    }
    this._updateDragPlanePosition(this._startDragRay, startPickedPoint ? startPickedPoint : this._tmpVector);
    var pickedPoint = this._pickWithRayOnDragPlane(this._startDragRay);
    if (pickedPoint) {
      this.dragging = true;
      this.currentDraggingPointerID = pointerId;
      this.lastDragPosition.copyFrom(pickedPoint);
      this.onDragStartObservable.notifyObservers({ dragPlanePoint: pickedPoint, pointerId: this.currentDraggingPointerID });
      this._targetPosition.copyFrom(this.attachedNode.absolutePosition);
      if (this.detachCameraControls && this._scene.activeCamera && this._scene.activeCamera.inputs && !this._scene.activeCamera.leftCamera) {
        if (this._scene.activeCamera.inputs.attachedToElement) {
          this._scene.activeCamera.detachControl();
          this._attachedToElement = true;
        } else {
          this._attachedToElement = false;
        }
      }
    }
    PivotTools._RestorePivotPoint(this.attachedNode);
  };
  PointerDragBehavior2.prototype._moveDrag = function(ray) {
    this._moving = true;
    var pickedPoint = this._pickWithRayOnDragPlane(ray);
    if (pickedPoint) {
      if (this.updateDragPlane) {
        this._updateDragPlanePosition(ray, pickedPoint);
      }
      var dragLength = 0;
      if (this._options.dragAxis) {
        this.useObjectOrientationForDragging ? Vector3.TransformCoordinatesToRef(this._options.dragAxis, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._worldDragAxis) : this._worldDragAxis.copyFrom(this._options.dragAxis);
        pickedPoint.subtractToRef(this.lastDragPosition, this._tmpVector);
        dragLength = Vector3.Dot(this._tmpVector, this._worldDragAxis);
        this._worldDragAxis.scaleToRef(dragLength, this._dragDelta);
      } else {
        dragLength = this._dragDelta.length();
        pickedPoint.subtractToRef(this.lastDragPosition, this._dragDelta);
      }
      this._targetPosition.addInPlace(this._dragDelta);
      this.onDragObservable.notifyObservers({ dragDistance: dragLength, delta: this._dragDelta, dragPlanePoint: pickedPoint, dragPlaneNormal: this._dragPlane.forward, pointerId: this.currentDraggingPointerID });
      this.lastDragPosition.copyFrom(pickedPoint);
    }
  };
  PointerDragBehavior2.prototype._pickWithRayOnDragPlane = function(ray) {
    var _this = this;
    if (!ray) {
      return null;
    }
    var angle = Math.acos(Vector3.Dot(this._dragPlane.forward, ray.direction));
    if (angle > Math.PI / 2) {
      angle = Math.PI - angle;
    }
    if (this.maxDragAngle > 0 && angle > this.maxDragAngle) {
      if (this._useAlternatePickedPointAboveMaxDragAngle) {
        this._tmpVector.copyFrom(ray.direction);
        this.attachedNode.absolutePosition.subtractToRef(ray.origin, this._alternatePickedPoint);
        this._alternatePickedPoint.normalize();
        this._alternatePickedPoint.scaleInPlace(this._useAlternatePickedPointAboveMaxDragAngleDragSpeed * Vector3.Dot(this._alternatePickedPoint, this._tmpVector));
        this._tmpVector.addInPlace(this._alternatePickedPoint);
        var dot = Vector3.Dot(this._dragPlane.forward, this._tmpVector);
        this._dragPlane.forward.scaleToRef(-dot, this._alternatePickedPoint);
        this._alternatePickedPoint.addInPlace(this._tmpVector);
        this._alternatePickedPoint.addInPlace(this.attachedNode.absolutePosition);
        return this._alternatePickedPoint;
      } else {
        return null;
      }
    }
    var pickResult = PointerDragBehavior2._planeScene.pickWithRay(ray, function(m) {
      return m == _this._dragPlane;
    });
    if (pickResult && pickResult.hit && pickResult.pickedMesh && pickResult.pickedPoint) {
      return pickResult.pickedPoint;
    } else {
      return null;
    }
  };
  PointerDragBehavior2.prototype._updateDragPlanePosition = function(ray, dragPlanePosition) {
    this._pointA.copyFrom(dragPlanePosition);
    if (this._options.dragAxis) {
      this.useObjectOrientationForDragging ? Vector3.TransformCoordinatesToRef(this._options.dragAxis, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._localAxis) : this._localAxis.copyFrom(this._options.dragAxis);
      ray.origin.subtractToRef(this._pointA, this._pointC);
      this._pointC.normalize();
      if (Math.abs(Vector3.Dot(this._localAxis, this._pointC)) > 0.999) {
        if (Math.abs(Vector3.Dot(Vector3.UpReadOnly, this._pointC)) > 0.999) {
          this._lookAt.copyFrom(Vector3.Right());
        } else {
          this._lookAt.copyFrom(Vector3.UpReadOnly);
        }
      } else {
        Vector3.CrossToRef(this._localAxis, this._pointC, this._lookAt);
        Vector3.CrossToRef(this._localAxis, this._lookAt, this._lookAt);
        this._lookAt.normalize();
      }
      this._dragPlane.position.copyFrom(this._pointA);
      this._pointA.addToRef(this._lookAt, this._lookAt);
      this._dragPlane.lookAt(this._lookAt);
    } else if (this._options.dragPlaneNormal) {
      this.useObjectOrientationForDragging ? Vector3.TransformCoordinatesToRef(this._options.dragPlaneNormal, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._localAxis) : this._localAxis.copyFrom(this._options.dragPlaneNormal);
      this._dragPlane.position.copyFrom(this._pointA);
      this._pointA.addToRef(this._localAxis, this._lookAt);
      this._dragPlane.lookAt(this._lookAt);
    } else {
      this._dragPlane.position.copyFrom(this._pointA);
      this._dragPlane.lookAt(ray.origin);
    }
    this._dragPlane.position.copyFrom(this.attachedNode.absolutePosition);
    this._dragPlane.computeWorldMatrix(true);
  };
  PointerDragBehavior2.prototype.detach = function() {
    if (this._pointerObserver) {
      this._scene.onPointerObservable.remove(this._pointerObserver);
    }
    if (this._beforeRenderObserver) {
      this._scene.onBeforeRenderObservable.remove(this._beforeRenderObserver);
    }
    this.releaseDrag();
  };
  PointerDragBehavior2._AnyMouseID = -2;
  return PointerDragBehavior2;
}();

// node_modules/@babylonjs/core/Behaviors/Meshes/multiPointerScaleBehavior.js
var MultiPointerScaleBehavior = function() {
  function MultiPointerScaleBehavior2() {
    this._startDistance = 0;
    this._initialScale = new Vector3(0, 0, 0);
    this._targetScale = new Vector3(0, 0, 0);
    this._sceneRenderObserver = null;
    this._dragBehaviorA = new PointerDragBehavior({});
    this._dragBehaviorA.moveAttached = false;
    this._dragBehaviorB = new PointerDragBehavior({});
    this._dragBehaviorB.moveAttached = false;
  }
  Object.defineProperty(MultiPointerScaleBehavior2.prototype, "name", {
    get: function() {
      return "MultiPointerScale";
    },
    enumerable: false,
    configurable: true
  });
  MultiPointerScaleBehavior2.prototype.init = function() {
  };
  MultiPointerScaleBehavior2.prototype._getCurrentDistance = function() {
    return this._dragBehaviorA.lastDragPosition.subtract(this._dragBehaviorB.lastDragPosition).length();
  };
  MultiPointerScaleBehavior2.prototype.attach = function(ownerNode) {
    var _this = this;
    this._ownerNode = ownerNode;
    this._dragBehaviorA.onDragStartObservable.add(function(e) {
      if (_this._dragBehaviorA.dragging && _this._dragBehaviorB.dragging) {
        if (_this._dragBehaviorA.currentDraggingPointerID == _this._dragBehaviorB.currentDraggingPointerID) {
          _this._dragBehaviorA.releaseDrag();
        } else {
          _this._initialScale.copyFrom(ownerNode.scaling);
          _this._startDistance = _this._getCurrentDistance();
        }
      }
    });
    this._dragBehaviorB.onDragStartObservable.add(function(e) {
      if (_this._dragBehaviorA.dragging && _this._dragBehaviorB.dragging) {
        if (_this._dragBehaviorA.currentDraggingPointerID == _this._dragBehaviorB.currentDraggingPointerID) {
          _this._dragBehaviorB.releaseDrag();
        } else {
          _this._initialScale.copyFrom(ownerNode.scaling);
          _this._startDistance = _this._getCurrentDistance();
        }
      }
    });
    [this._dragBehaviorA, this._dragBehaviorB].forEach(function(behavior) {
      behavior.onDragObservable.add(function() {
        if (_this._dragBehaviorA.dragging && _this._dragBehaviorB.dragging) {
          var ratio = _this._getCurrentDistance() / _this._startDistance;
          _this._initialScale.scaleToRef(ratio, _this._targetScale);
        }
      });
    });
    ownerNode.addBehavior(this._dragBehaviorA);
    ownerNode.addBehavior(this._dragBehaviorB);
    this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(function() {
      if (_this._dragBehaviorA.dragging && _this._dragBehaviorB.dragging) {
        var change = _this._targetScale.subtract(ownerNode.scaling).scaleInPlace(0.1);
        if (change.length() > 0.01) {
          ownerNode.scaling.addInPlace(change);
        }
      }
    });
  };
  MultiPointerScaleBehavior2.prototype.detach = function() {
    var _this = this;
    this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);
    [this._dragBehaviorA, this._dragBehaviorB].forEach(function(behavior) {
      behavior.onDragStartObservable.clear();
      behavior.onDragObservable.clear();
      _this._ownerNode.removeBehavior(behavior);
    });
  };
  return MultiPointerScaleBehavior2;
}();

// node_modules/@babylonjs/core/Behaviors/Meshes/sixDofDragBehavior.js
var SixDofDragBehavior = function() {
  function SixDofDragBehavior2() {
    this._sceneRenderObserver = null;
    this._targetPosition = new Vector3(0, 0, 0);
    this._moving = false;
    this._startingOrientation = new Quaternion();
    this._attachedToElement = false;
    this.zDragFactor = 3;
    this.rotateDraggedObject = true;
    this.dragging = false;
    this.dragDeltaRatio = 0.2;
    this.currentDraggingPointerID = -1;
    this.detachCameraControls = true;
    this.onDragStartObservable = new Observable();
    this.onDragObservable = new Observable();
    this.onDragEndObservable = new Observable();
  }
  Object.defineProperty(SixDofDragBehavior2.prototype, "name", {
    get: function() {
      return "SixDofDrag";
    },
    enumerable: false,
    configurable: true
  });
  SixDofDragBehavior2.prototype.init = function() {
  };
  Object.defineProperty(SixDofDragBehavior2.prototype, "_pointerCamera", {
    get: function() {
      if (this._scene.cameraToUseForPointers) {
        return this._scene.cameraToUseForPointers;
      } else {
        return this._scene.activeCamera;
      }
    },
    enumerable: false,
    configurable: true
  });
  SixDofDragBehavior2.prototype.attach = function(ownerNode) {
    var _this = this;
    this._ownerNode = ownerNode;
    this._scene = this._ownerNode.getScene();
    if (!SixDofDragBehavior2._virtualScene) {
      SixDofDragBehavior2._virtualScene = new Scene(this._scene.getEngine(), { virtual: true });
      SixDofDragBehavior2._virtualScene.detachControl();
      this._scene.getEngine().scenes.pop();
    }
    var pickedMesh = null;
    var lastSixDofOriginPosition = new Vector3(0, 0, 0);
    this._virtualOriginMesh = new AbstractMesh("", SixDofDragBehavior2._virtualScene);
    this._virtualOriginMesh.rotationQuaternion = new Quaternion();
    this._virtualDragMesh = new AbstractMesh("", SixDofDragBehavior2._virtualScene);
    this._virtualDragMesh.rotationQuaternion = new Quaternion();
    var pickPredicate = function(m) {
      return _this._ownerNode == m || m.isDescendantOf(_this._ownerNode);
    };
    this._pointerObserver = this._scene.onPointerObservable.add(function(pointerInfo, eventState) {
      if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {
        if (!_this.dragging && pointerInfo.pickInfo && pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh && pointerInfo.pickInfo.ray && pickPredicate(pointerInfo.pickInfo.pickedMesh)) {
          if (_this._pointerCamera && _this._pointerCamera.cameraRigMode == Camera.RIG_MODE_NONE) {
            pointerInfo.pickInfo.ray.origin.copyFrom(_this._pointerCamera.globalPosition);
          }
          pickedMesh = _this._ownerNode;
          PivotTools._RemoveAndStorePivotPoint(pickedMesh);
          lastSixDofOriginPosition.copyFrom(pointerInfo.pickInfo.ray.origin);
          _this._virtualOriginMesh.position.copyFrom(pointerInfo.pickInfo.ray.origin);
          _this._virtualOriginMesh.lookAt(pointerInfo.pickInfo.ray.origin.add(pointerInfo.pickInfo.ray.direction));
          _this._virtualOriginMesh.removeChild(_this._virtualDragMesh);
          pickedMesh.computeWorldMatrix();
          _this._virtualDragMesh.position.copyFrom(pickedMesh.absolutePosition);
          if (!pickedMesh.rotationQuaternion) {
            pickedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(pickedMesh.rotation.y, pickedMesh.rotation.x, pickedMesh.rotation.z);
          }
          var oldParent = pickedMesh.parent;
          pickedMesh.setParent(null);
          _this._virtualDragMesh.rotationQuaternion.copyFrom(pickedMesh.rotationQuaternion);
          pickedMesh.setParent(oldParent);
          _this._virtualOriginMesh.addChild(_this._virtualDragMesh);
          _this._targetPosition.copyFrom(_this._virtualDragMesh.absolutePosition);
          _this.dragging = true;
          _this.currentDraggingPointerID = pointerInfo.event.pointerId;
          if (_this.detachCameraControls && _this._pointerCamera && !_this._pointerCamera.leftCamera) {
            if (_this._pointerCamera.inputs.attachedToElement) {
              _this._pointerCamera.detachControl();
              _this._attachedToElement = true;
            } else {
              _this._attachedToElement = false;
            }
          }
          PivotTools._RestorePivotPoint(pickedMesh);
          _this.onDragStartObservable.notifyObservers({});
        }
      } else if (pointerInfo.type == PointerEventTypes.POINTERUP || pointerInfo.type == PointerEventTypes.POINTERDOUBLETAP) {
        if (_this.currentDraggingPointerID == pointerInfo.event.pointerId) {
          _this.dragging = false;
          _this._moving = false;
          _this.currentDraggingPointerID = -1;
          pickedMesh = null;
          _this._virtualOriginMesh.removeChild(_this._virtualDragMesh);
          if (_this.detachCameraControls && _this._attachedToElement && _this._pointerCamera && !_this._pointerCamera.leftCamera) {
            _this._pointerCamera.attachControl(true);
            _this._attachedToElement = false;
          }
          _this.onDragEndObservable.notifyObservers({});
        }
      } else if (pointerInfo.type == PointerEventTypes.POINTERMOVE) {
        if (_this.currentDraggingPointerID == pointerInfo.event.pointerId && _this.dragging && pointerInfo.pickInfo && pointerInfo.pickInfo.ray && pickedMesh) {
          var zDragFactor = _this.zDragFactor;
          if (_this._pointerCamera && _this._pointerCamera.cameraRigMode == Camera.RIG_MODE_NONE) {
            pointerInfo.pickInfo.ray.origin.copyFrom(_this._pointerCamera.globalPosition);
            zDragFactor = 0;
          }
          var originDragDifference = pointerInfo.pickInfo.ray.origin.subtract(lastSixDofOriginPosition);
          lastSixDofOriginPosition.copyFrom(pointerInfo.pickInfo.ray.origin);
          var localOriginDragDifference = -Vector3.Dot(originDragDifference, pointerInfo.pickInfo.ray.direction);
          _this._virtualOriginMesh.addChild(_this._virtualDragMesh);
          _this._virtualDragMesh.position.z -= _this._virtualDragMesh.position.z < 1 ? localOriginDragDifference * _this.zDragFactor : localOriginDragDifference * zDragFactor * _this._virtualDragMesh.position.z;
          if (_this._virtualDragMesh.position.z < 0) {
            _this._virtualDragMesh.position.z = 0;
          }
          _this._virtualOriginMesh.position.copyFrom(pointerInfo.pickInfo.ray.origin);
          _this._virtualOriginMesh.lookAt(pointerInfo.pickInfo.ray.origin.add(pointerInfo.pickInfo.ray.direction));
          _this._virtualOriginMesh.removeChild(_this._virtualDragMesh);
          _this._targetPosition.copyFrom(_this._virtualDragMesh.absolutePosition);
          if (pickedMesh.parent) {
            Vector3.TransformCoordinatesToRef(_this._targetPosition, Matrix.Invert(pickedMesh.parent.getWorldMatrix()), _this._targetPosition);
          }
          if (!_this._moving) {
            _this._startingOrientation.copyFrom(_this._virtualDragMesh.rotationQuaternion);
          }
          _this._moving = true;
        }
      }
    });
    var tmpQuaternion = new Quaternion();
    this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(function() {
      if (_this.dragging && _this._moving && pickedMesh) {
        PivotTools._RemoveAndStorePivotPoint(pickedMesh);
        pickedMesh.position.addInPlace(_this._targetPosition.subtract(pickedMesh.position).scale(_this.dragDeltaRatio));
        if (_this.rotateDraggedObject) {
          tmpQuaternion.copyFrom(_this._startingOrientation);
          tmpQuaternion.x = -tmpQuaternion.x;
          tmpQuaternion.y = -tmpQuaternion.y;
          tmpQuaternion.z = -tmpQuaternion.z;
          _this._virtualDragMesh.rotationQuaternion.multiplyToRef(tmpQuaternion, tmpQuaternion);
          Quaternion.RotationYawPitchRollToRef(tmpQuaternion.toEulerAngles("xyz").y, 0, 0, tmpQuaternion);
          tmpQuaternion.multiplyToRef(_this._startingOrientation, tmpQuaternion);
          var oldParent = pickedMesh.parent;
          if (!oldParent || oldParent.scaling && !oldParent.scaling.isNonUniformWithinEpsilon(1e-3)) {
            pickedMesh.setParent(null);
            Quaternion.SlerpToRef(pickedMesh.rotationQuaternion, tmpQuaternion, _this.dragDeltaRatio, pickedMesh.rotationQuaternion);
            pickedMesh.setParent(oldParent);
          }
        }
        PivotTools._RestorePivotPoint(pickedMesh);
        _this.onDragObservable.notifyObservers();
      }
    });
  };
  SixDofDragBehavior2.prototype.detach = function() {
    if (this._scene) {
      if (this.detachCameraControls && this._attachedToElement && this._pointerCamera && !this._pointerCamera.leftCamera) {
        this._pointerCamera.attachControl(true);
        this._attachedToElement = false;
      }
      this._scene.onPointerObservable.remove(this._pointerObserver);
    }
    if (this._ownerNode) {
      this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);
    }
    if (this._virtualOriginMesh) {
      this._virtualOriginMesh.dispose();
    }
    if (this._virtualDragMesh) {
      this._virtualDragMesh.dispose();
    }
    this.onDragEndObservable.clear();
    this.onDragObservable.clear();
    this.onDragStartObservable.clear();
  };
  return SixDofDragBehavior2;
}();

// node_modules/@babylonjs/core/Bones/boneIKController.js
var BoneIKController = function() {
  function BoneIKController2(mesh, bone, options) {
    this.targetPosition = Vector3.Zero();
    this.poleTargetPosition = Vector3.Zero();
    this.poleTargetLocalOffset = Vector3.Zero();
    this.poleAngle = 0;
    this.slerpAmount = 1;
    this._bone1Quat = Quaternion.Identity();
    this._bone1Mat = Matrix.Identity();
    this._bone2Ang = Math.PI;
    this._maxAngle = Math.PI;
    this._rightHandedSystem = false;
    this._bendAxis = Vector3.Right();
    this._slerping = false;
    this._adjustRoll = 0;
    this._bone2 = bone;
    this._bone1 = bone.getParent();
    if (!this._bone1) {
      return;
    }
    this.mesh = mesh;
    var bonePos = bone.getPosition();
    if (bone.getAbsoluteTransform().determinant() > 0) {
      this._rightHandedSystem = true;
      this._bendAxis.x = 0;
      this._bendAxis.y = 0;
      this._bendAxis.z = -1;
      if (bonePos.x > bonePos.y && bonePos.x > bonePos.z) {
        this._adjustRoll = Math.PI * 0.5;
        this._bendAxis.z = 1;
      }
    }
    if (this._bone1.length) {
      var boneScale1 = this._bone1.getScale();
      var boneScale2 = this._bone2.getScale();
      this._bone1Length = this._bone1.length * boneScale1.y * this.mesh.scaling.y;
      this._bone2Length = this._bone2.length * boneScale2.y * this.mesh.scaling.y;
    } else if (this._bone1.children[0]) {
      mesh.computeWorldMatrix(true);
      var pos1 = this._bone2.children[0].getAbsolutePosition(mesh);
      var pos2 = this._bone2.getAbsolutePosition(mesh);
      var pos3 = this._bone1.getAbsolutePosition(mesh);
      this._bone1Length = Vector3.Distance(pos1, pos2);
      this._bone2Length = Vector3.Distance(pos2, pos3);
    }
    this._bone1.getRotationMatrixToRef(Space.WORLD, mesh, this._bone1Mat);
    this.maxAngle = Math.PI;
    if (options) {
      if (options.targetMesh) {
        this.targetMesh = options.targetMesh;
        this.targetMesh.computeWorldMatrix(true);
      }
      if (options.poleTargetMesh) {
        this.poleTargetMesh = options.poleTargetMesh;
        this.poleTargetMesh.computeWorldMatrix(true);
      } else if (options.poleTargetBone) {
        this.poleTargetBone = options.poleTargetBone;
      } else if (this._bone1.getParent()) {
        this.poleTargetBone = this._bone1.getParent();
      }
      if (options.poleTargetLocalOffset) {
        this.poleTargetLocalOffset.copyFrom(options.poleTargetLocalOffset);
      }
      if (options.poleAngle) {
        this.poleAngle = options.poleAngle;
      }
      if (options.bendAxis) {
        this._bendAxis.copyFrom(options.bendAxis);
      }
      if (options.maxAngle) {
        this.maxAngle = options.maxAngle;
      }
      if (options.slerpAmount) {
        this.slerpAmount = options.slerpAmount;
      }
    }
  }
  Object.defineProperty(BoneIKController2.prototype, "maxAngle", {
    get: function() {
      return this._maxAngle;
    },
    set: function(value) {
      this._setMaxAngle(value);
    },
    enumerable: false,
    configurable: true
  });
  BoneIKController2.prototype._setMaxAngle = function(ang) {
    if (ang < 0) {
      ang = 0;
    }
    if (ang > Math.PI || ang == void 0) {
      ang = Math.PI;
    }
    this._maxAngle = ang;
    var a = this._bone1Length;
    var b = this._bone2Length;
    this._maxReach = Math.sqrt(a * a + b * b - 2 * a * b * Math.cos(ang));
  };
  BoneIKController2.prototype.update = function() {
    var bone1 = this._bone1;
    if (!bone1) {
      return;
    }
    var target = this.targetPosition;
    var poleTarget = this.poleTargetPosition;
    var mat1 = BoneIKController2._tmpMats[0];
    var mat2 = BoneIKController2._tmpMats[1];
    if (this.targetMesh) {
      target.copyFrom(this.targetMesh.getAbsolutePosition());
    }
    if (this.poleTargetBone) {
      this.poleTargetBone.getAbsolutePositionFromLocalToRef(this.poleTargetLocalOffset, this.mesh, poleTarget);
    } else if (this.poleTargetMesh) {
      Vector3.TransformCoordinatesToRef(this.poleTargetLocalOffset, this.poleTargetMesh.getWorldMatrix(), poleTarget);
    }
    var bonePos = BoneIKController2._tmpVecs[0];
    var zaxis = BoneIKController2._tmpVecs[1];
    var xaxis = BoneIKController2._tmpVecs[2];
    var yaxis = BoneIKController2._tmpVecs[3];
    var upAxis = BoneIKController2._tmpVecs[4];
    var _tmpQuat = BoneIKController2._tmpQuat;
    bone1.getAbsolutePositionToRef(this.mesh, bonePos);
    poleTarget.subtractToRef(bonePos, upAxis);
    if (upAxis.x == 0 && upAxis.y == 0 && upAxis.z == 0) {
      upAxis.y = 1;
    } else {
      upAxis.normalize();
    }
    target.subtractToRef(bonePos, yaxis);
    yaxis.normalize();
    Vector3.CrossToRef(yaxis, upAxis, zaxis);
    zaxis.normalize();
    Vector3.CrossToRef(yaxis, zaxis, xaxis);
    xaxis.normalize();
    Matrix.FromXYZAxesToRef(xaxis, yaxis, zaxis, mat1);
    var a = this._bone1Length;
    var b = this._bone2Length;
    var c = Vector3.Distance(bonePos, target);
    if (this._maxReach > 0) {
      c = Math.min(this._maxReach, c);
    }
    var acosa = (b * b + c * c - a * a) / (2 * b * c);
    var acosb = (c * c + a * a - b * b) / (2 * c * a);
    if (acosa > 1) {
      acosa = 1;
    }
    if (acosb > 1) {
      acosb = 1;
    }
    if (acosa < -1) {
      acosa = -1;
    }
    if (acosb < -1) {
      acosb = -1;
    }
    var angA = Math.acos(acosa);
    var angB = Math.acos(acosb);
    var angC = -angA - angB;
    if (this._rightHandedSystem) {
      Matrix.RotationYawPitchRollToRef(0, 0, this._adjustRoll, mat2);
      mat2.multiplyToRef(mat1, mat1);
      Matrix.RotationAxisToRef(this._bendAxis, angB, mat2);
      mat2.multiplyToRef(mat1, mat1);
    } else {
      var _tmpVec = BoneIKController2._tmpVecs[5];
      _tmpVec.copyFrom(this._bendAxis);
      _tmpVec.x *= -1;
      Matrix.RotationAxisToRef(_tmpVec, -angB, mat2);
      mat2.multiplyToRef(mat1, mat1);
    }
    if (this.poleAngle) {
      Matrix.RotationAxisToRef(yaxis, this.poleAngle, mat2);
      mat1.multiplyToRef(mat2, mat1);
    }
    if (this._bone1) {
      if (this.slerpAmount < 1) {
        if (!this._slerping) {
          Quaternion.FromRotationMatrixToRef(this._bone1Mat, this._bone1Quat);
        }
        Quaternion.FromRotationMatrixToRef(mat1, _tmpQuat);
        Quaternion.SlerpToRef(this._bone1Quat, _tmpQuat, this.slerpAmount, this._bone1Quat);
        angC = this._bone2Ang * (1 - this.slerpAmount) + angC * this.slerpAmount;
        this._bone1.setRotationQuaternion(this._bone1Quat, Space.WORLD, this.mesh);
        this._slerping = true;
      } else {
        this._bone1.setRotationMatrix(mat1, Space.WORLD, this.mesh);
        this._bone1Mat.copyFrom(mat1);
        this._slerping = false;
      }
    }
    this._bone2.setAxisAngle(this._bendAxis, angC, Space.LOCAL);
    this._bone2Ang = angC;
  };
  BoneIKController2._tmpVecs = [Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero()];
  BoneIKController2._tmpQuat = Quaternion.Identity();
  BoneIKController2._tmpMats = [Matrix.Identity(), Matrix.Identity()];
  return BoneIKController2;
}();

// node_modules/@babylonjs/core/Bones/boneLookController.js
var BoneLookController = function() {
  function BoneLookController2(mesh, bone, target, options) {
    this.upAxis = Vector3.Up();
    this.upAxisSpace = Space.LOCAL;
    this.adjustYaw = 0;
    this.adjustPitch = 0;
    this.adjustRoll = 0;
    this.slerpAmount = 1;
    this._boneQuat = Quaternion.Identity();
    this._slerping = false;
    this._firstFrameSkipped = false;
    this._fowardAxis = Vector3.Forward();
    this.mesh = mesh;
    this.bone = bone;
    this.target = target;
    if (options) {
      if (options.adjustYaw) {
        this.adjustYaw = options.adjustYaw;
      }
      if (options.adjustPitch) {
        this.adjustPitch = options.adjustPitch;
      }
      if (options.adjustRoll) {
        this.adjustRoll = options.adjustRoll;
      }
      if (options.maxYaw != null) {
        this.maxYaw = options.maxYaw;
      } else {
        this.maxYaw = Math.PI;
      }
      if (options.minYaw != null) {
        this.minYaw = options.minYaw;
      } else {
        this.minYaw = -Math.PI;
      }
      if (options.maxPitch != null) {
        this.maxPitch = options.maxPitch;
      } else {
        this.maxPitch = Math.PI;
      }
      if (options.minPitch != null) {
        this.minPitch = options.minPitch;
      } else {
        this.minPitch = -Math.PI;
      }
      if (options.slerpAmount != null) {
        this.slerpAmount = options.slerpAmount;
      }
      if (options.upAxis != null) {
        this.upAxis = options.upAxis;
      }
      if (options.upAxisSpace != null) {
        this.upAxisSpace = options.upAxisSpace;
      }
      if (options.yawAxis != null || options.pitchAxis != null) {
        var newYawAxis = Axis.Y;
        var newPitchAxis = Axis.X;
        if (options.yawAxis != null) {
          newYawAxis = options.yawAxis.clone();
          newYawAxis.normalize();
        }
        if (options.pitchAxis != null) {
          newPitchAxis = options.pitchAxis.clone();
          newPitchAxis.normalize();
        }
        var newRollAxis = Vector3.Cross(newPitchAxis, newYawAxis);
        this._transformYawPitch = Matrix.Identity();
        Matrix.FromXYZAxesToRef(newPitchAxis, newYawAxis, newRollAxis, this._transformYawPitch);
        this._transformYawPitchInv = this._transformYawPitch.clone();
        this._transformYawPitch.invert();
      }
    }
    if (!bone.getParent() && this.upAxisSpace == Space.BONE) {
      this.upAxisSpace = Space.LOCAL;
    }
  }
  Object.defineProperty(BoneLookController2.prototype, "minYaw", {
    get: function() {
      return this._minYaw;
    },
    set: function(value) {
      this._minYaw = value;
      this._minYawSin = Math.sin(value);
      this._minYawCos = Math.cos(value);
      if (this._maxYaw != null) {
        this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * 0.5 + this._minYaw;
        this._yawRange = this._maxYaw - this._minYaw;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BoneLookController2.prototype, "maxYaw", {
    get: function() {
      return this._maxYaw;
    },
    set: function(value) {
      this._maxYaw = value;
      this._maxYawSin = Math.sin(value);
      this._maxYawCos = Math.cos(value);
      if (this._minYaw != null) {
        this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * 0.5 + this._minYaw;
        this._yawRange = this._maxYaw - this._minYaw;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BoneLookController2.prototype, "minPitch", {
    get: function() {
      return this._minPitch;
    },
    set: function(value) {
      this._minPitch = value;
      this._minPitchTan = Math.tan(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BoneLookController2.prototype, "maxPitch", {
    get: function() {
      return this._maxPitch;
    },
    set: function(value) {
      this._maxPitch = value;
      this._maxPitchTan = Math.tan(value);
    },
    enumerable: false,
    configurable: true
  });
  BoneLookController2.prototype.update = function() {
    if (this.slerpAmount < 1 && !this._firstFrameSkipped) {
      this._firstFrameSkipped = true;
      return;
    }
    var bone = this.bone;
    var bonePos = BoneLookController2._tmpVecs[0];
    bone.getAbsolutePositionToRef(this.mesh, bonePos);
    var target = this.target;
    var _tmpMat1 = BoneLookController2._tmpMats[0];
    var _tmpMat2 = BoneLookController2._tmpMats[1];
    var mesh = this.mesh;
    var parentBone = bone.getParent();
    var upAxis = BoneLookController2._tmpVecs[1];
    upAxis.copyFrom(this.upAxis);
    if (this.upAxisSpace == Space.BONE && parentBone) {
      if (this._transformYawPitch) {
        Vector3.TransformCoordinatesToRef(upAxis, this._transformYawPitchInv, upAxis);
      }
      parentBone.getDirectionToRef(upAxis, this.mesh, upAxis);
    } else if (this.upAxisSpace == Space.LOCAL) {
      mesh.getDirectionToRef(upAxis, upAxis);
      if (mesh.scaling.x != 1 || mesh.scaling.y != 1 || mesh.scaling.z != 1) {
        upAxis.normalize();
      }
    }
    var checkYaw = false;
    var checkPitch = false;
    if (this._maxYaw != Math.PI || this._minYaw != -Math.PI) {
      checkYaw = true;
    }
    if (this._maxPitch != Math.PI || this._minPitch != -Math.PI) {
      checkPitch = true;
    }
    if (checkYaw || checkPitch) {
      var spaceMat = BoneLookController2._tmpMats[2];
      var spaceMatInv = BoneLookController2._tmpMats[3];
      if (this.upAxisSpace == Space.BONE && upAxis.y == 1 && parentBone) {
        parentBone.getRotationMatrixToRef(Space.WORLD, this.mesh, spaceMat);
      } else if (this.upAxisSpace == Space.LOCAL && upAxis.y == 1 && !parentBone) {
        spaceMat.copyFrom(mesh.getWorldMatrix());
      } else {
        var forwardAxis = BoneLookController2._tmpVecs[2];
        forwardAxis.copyFrom(this._fowardAxis);
        if (this._transformYawPitch) {
          Vector3.TransformCoordinatesToRef(forwardAxis, this._transformYawPitchInv, forwardAxis);
        }
        if (parentBone) {
          parentBone.getDirectionToRef(forwardAxis, this.mesh, forwardAxis);
        } else {
          mesh.getDirectionToRef(forwardAxis, forwardAxis);
        }
        var rightAxis = Vector3.Cross(upAxis, forwardAxis);
        rightAxis.normalize();
        var forwardAxis = Vector3.Cross(rightAxis, upAxis);
        Matrix.FromXYZAxesToRef(rightAxis, upAxis, forwardAxis, spaceMat);
      }
      spaceMat.invertToRef(spaceMatInv);
      var xzlen = null;
      if (checkPitch) {
        var localTarget = BoneLookController2._tmpVecs[3];
        target.subtractToRef(bonePos, localTarget);
        Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);
        xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);
        var pitch = Math.atan2(localTarget.y, xzlen);
        var newPitch = pitch;
        if (pitch > this._maxPitch) {
          localTarget.y = this._maxPitchTan * xzlen;
          newPitch = this._maxPitch;
        } else if (pitch < this._minPitch) {
          localTarget.y = this._minPitchTan * xzlen;
          newPitch = this._minPitch;
        }
        if (pitch != newPitch) {
          Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);
          localTarget.addInPlace(bonePos);
          target = localTarget;
        }
      }
      if (checkYaw) {
        var localTarget = BoneLookController2._tmpVecs[4];
        target.subtractToRef(bonePos, localTarget);
        Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);
        var yaw = Math.atan2(localTarget.x, localTarget.z);
        var newYaw = yaw;
        if (yaw > this._maxYaw || yaw < this._minYaw) {
          if (xzlen == null) {
            xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);
          }
          if (this._yawRange > Math.PI) {
            if (this._isAngleBetween(yaw, this._maxYaw, this._midYawConstraint)) {
              localTarget.z = this._maxYawCos * xzlen;
              localTarget.x = this._maxYawSin * xzlen;
              newYaw = this._maxYaw;
            } else if (this._isAngleBetween(yaw, this._midYawConstraint, this._minYaw)) {
              localTarget.z = this._minYawCos * xzlen;
              localTarget.x = this._minYawSin * xzlen;
              newYaw = this._minYaw;
            }
          } else {
            if (yaw > this._maxYaw) {
              localTarget.z = this._maxYawCos * xzlen;
              localTarget.x = this._maxYawSin * xzlen;
              newYaw = this._maxYaw;
            } else if (yaw < this._minYaw) {
              localTarget.z = this._minYawCos * xzlen;
              localTarget.x = this._minYawSin * xzlen;
              newYaw = this._minYaw;
            }
          }
        }
        if (this._slerping && this._yawRange > Math.PI) {
          var boneFwd = BoneLookController2._tmpVecs[8];
          boneFwd.copyFrom(Axis.Z);
          if (this._transformYawPitch) {
            Vector3.TransformCoordinatesToRef(boneFwd, this._transformYawPitchInv, boneFwd);
          }
          var boneRotMat = BoneLookController2._tmpMats[4];
          this._boneQuat.toRotationMatrix(boneRotMat);
          this.mesh.getWorldMatrix().multiplyToRef(boneRotMat, boneRotMat);
          Vector3.TransformCoordinatesToRef(boneFwd, boneRotMat, boneFwd);
          Vector3.TransformCoordinatesToRef(boneFwd, spaceMatInv, boneFwd);
          var boneYaw = Math.atan2(boneFwd.x, boneFwd.z);
          var angBtwTar = this._getAngleBetween(boneYaw, yaw);
          var angBtwMidYaw = this._getAngleBetween(boneYaw, this._midYawConstraint);
          if (angBtwTar > angBtwMidYaw) {
            if (xzlen == null) {
              xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);
            }
            var angBtwMax = this._getAngleBetween(boneYaw, this._maxYaw);
            var angBtwMin = this._getAngleBetween(boneYaw, this._minYaw);
            if (angBtwMin < angBtwMax) {
              newYaw = boneYaw + Math.PI * 0.75;
              localTarget.z = Math.cos(newYaw) * xzlen;
              localTarget.x = Math.sin(newYaw) * xzlen;
            } else {
              newYaw = boneYaw - Math.PI * 0.75;
              localTarget.z = Math.cos(newYaw) * xzlen;
              localTarget.x = Math.sin(newYaw) * xzlen;
            }
          }
        }
        if (yaw != newYaw) {
          Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);
          localTarget.addInPlace(bonePos);
          target = localTarget;
        }
      }
    }
    var zaxis = BoneLookController2._tmpVecs[5];
    var xaxis = BoneLookController2._tmpVecs[6];
    var yaxis = BoneLookController2._tmpVecs[7];
    var _tmpQuat = BoneLookController2._tmpQuat;
    target.subtractToRef(bonePos, zaxis);
    zaxis.normalize();
    Vector3.CrossToRef(upAxis, zaxis, xaxis);
    xaxis.normalize();
    Vector3.CrossToRef(zaxis, xaxis, yaxis);
    yaxis.normalize();
    Matrix.FromXYZAxesToRef(xaxis, yaxis, zaxis, _tmpMat1);
    if (xaxis.x === 0 && xaxis.y === 0 && xaxis.z === 0) {
      return;
    }
    if (yaxis.x === 0 && yaxis.y === 0 && yaxis.z === 0) {
      return;
    }
    if (zaxis.x === 0 && zaxis.y === 0 && zaxis.z === 0) {
      return;
    }
    if (this.adjustYaw || this.adjustPitch || this.adjustRoll) {
      Matrix.RotationYawPitchRollToRef(this.adjustYaw, this.adjustPitch, this.adjustRoll, _tmpMat2);
      _tmpMat2.multiplyToRef(_tmpMat1, _tmpMat1);
    }
    if (this.slerpAmount < 1) {
      if (!this._slerping) {
        this.bone.getRotationQuaternionToRef(Space.WORLD, this.mesh, this._boneQuat);
      }
      if (this._transformYawPitch) {
        this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);
      }
      Quaternion.FromRotationMatrixToRef(_tmpMat1, _tmpQuat);
      Quaternion.SlerpToRef(this._boneQuat, _tmpQuat, this.slerpAmount, this._boneQuat);
      this.bone.setRotationQuaternion(this._boneQuat, Space.WORLD, this.mesh);
      this._slerping = true;
    } else {
      if (this._transformYawPitch) {
        this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);
      }
      this.bone.setRotationMatrix(_tmpMat1, Space.WORLD, this.mesh);
      this._slerping = false;
    }
  };
  BoneLookController2.prototype._getAngleDiff = function(ang1, ang2) {
    var angDiff = ang2 - ang1;
    angDiff %= Math.PI * 2;
    if (angDiff > Math.PI) {
      angDiff -= Math.PI * 2;
    } else if (angDiff < -Math.PI) {
      angDiff += Math.PI * 2;
    }
    return angDiff;
  };
  BoneLookController2.prototype._getAngleBetween = function(ang1, ang2) {
    ang1 %= 2 * Math.PI;
    ang1 = ang1 < 0 ? ang1 + 2 * Math.PI : ang1;
    ang2 %= 2 * Math.PI;
    ang2 = ang2 < 0 ? ang2 + 2 * Math.PI : ang2;
    var ab = 0;
    if (ang1 < ang2) {
      ab = ang2 - ang1;
    } else {
      ab = ang1 - ang2;
    }
    if (ab > Math.PI) {
      ab = Math.PI * 2 - ab;
    }
    return ab;
  };
  BoneLookController2.prototype._isAngleBetween = function(ang, ang1, ang2) {
    ang %= 2 * Math.PI;
    ang = ang < 0 ? ang + 2 * Math.PI : ang;
    ang1 %= 2 * Math.PI;
    ang1 = ang1 < 0 ? ang1 + 2 * Math.PI : ang1;
    ang2 %= 2 * Math.PI;
    ang2 = ang2 < 0 ? ang2 + 2 * Math.PI : ang2;
    if (ang1 < ang2) {
      if (ang > ang1 && ang < ang2) {
        return true;
      }
    } else {
      if (ang > ang2 && ang < ang1) {
        return true;
      }
    }
    return false;
  };
  BoneLookController2._tmpVecs = ArrayTools.BuildArray(10, Vector3.Zero);
  BoneLookController2._tmpQuat = Quaternion.Identity();
  BoneLookController2._tmpMats = ArrayTools.BuildArray(5, Matrix.Identity);
  return BoneLookController2;
}();

// node_modules/@babylonjs/core/Gamepads/gamepad.js
var StickValues = function() {
  function StickValues2(x, y) {
    this.x = x;
    this.y = y;
  }
  return StickValues2;
}();
var Gamepad = function() {
  function Gamepad2(id, index, browserGamepad, leftStickX, leftStickY, rightStickX, rightStickY) {
    if (leftStickX === void 0) {
      leftStickX = 0;
    }
    if (leftStickY === void 0) {
      leftStickY = 1;
    }
    if (rightStickX === void 0) {
      rightStickX = 2;
    }
    if (rightStickY === void 0) {
      rightStickY = 3;
    }
    this.id = id;
    this.index = index;
    this.browserGamepad = browserGamepad;
    this._leftStick = { x: 0, y: 0 };
    this._rightStick = { x: 0, y: 0 };
    this._isConnected = true;
    this._invertLeftStickY = false;
    this.type = Gamepad2.GAMEPAD;
    this._leftStickAxisX = leftStickX;
    this._leftStickAxisY = leftStickY;
    this._rightStickAxisX = rightStickX;
    this._rightStickAxisY = rightStickY;
    if (this.browserGamepad.axes.length >= 2) {
      this._leftStick = { x: this.browserGamepad.axes[this._leftStickAxisX], y: this.browserGamepad.axes[this._leftStickAxisY] };
    }
    if (this.browserGamepad.axes.length >= 4) {
      this._rightStick = { x: this.browserGamepad.axes[this._rightStickAxisX], y: this.browserGamepad.axes[this._rightStickAxisY] };
    }
  }
  Object.defineProperty(Gamepad2.prototype, "isConnected", {
    get: function() {
      return this._isConnected;
    },
    enumerable: false,
    configurable: true
  });
  Gamepad2.prototype.onleftstickchanged = function(callback) {
    this._onleftstickchanged = callback;
  };
  Gamepad2.prototype.onrightstickchanged = function(callback) {
    this._onrightstickchanged = callback;
  };
  Object.defineProperty(Gamepad2.prototype, "leftStick", {
    get: function() {
      return this._leftStick;
    },
    set: function(newValues) {
      if (this._onleftstickchanged && (this._leftStick.x !== newValues.x || this._leftStick.y !== newValues.y)) {
        this._onleftstickchanged(newValues);
      }
      this._leftStick = newValues;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Gamepad2.prototype, "rightStick", {
    get: function() {
      return this._rightStick;
    },
    set: function(newValues) {
      if (this._onrightstickchanged && (this._rightStick.x !== newValues.x || this._rightStick.y !== newValues.y)) {
        this._onrightstickchanged(newValues);
      }
      this._rightStick = newValues;
    },
    enumerable: false,
    configurable: true
  });
  Gamepad2.prototype.update = function() {
    if (this._leftStick) {
      this.leftStick = { x: this.browserGamepad.axes[this._leftStickAxisX], y: this.browserGamepad.axes[this._leftStickAxisY] };
      if (this._invertLeftStickY) {
        this.leftStick.y *= -1;
      }
    }
    if (this._rightStick) {
      this.rightStick = { x: this.browserGamepad.axes[this._rightStickAxisX], y: this.browserGamepad.axes[this._rightStickAxisY] };
    }
  };
  Gamepad2.prototype.dispose = function() {
  };
  Gamepad2.GAMEPAD = 0;
  Gamepad2.GENERIC = 1;
  Gamepad2.XBOX = 2;
  Gamepad2.POSE_ENABLED = 3;
  Gamepad2.DUALSHOCK = 4;
  return Gamepad2;
}();
var GenericPad = function(_super) {
  __extends(GenericPad2, _super);
  function GenericPad2(id, index, browserGamepad) {
    var _this = _super.call(this, id, index, browserGamepad) || this;
    _this.onButtonDownObservable = new Observable();
    _this.onButtonUpObservable = new Observable();
    _this.type = Gamepad.GENERIC;
    _this._buttons = new Array(browserGamepad.buttons.length);
    return _this;
  }
  GenericPad2.prototype.onbuttondown = function(callback) {
    this._onbuttondown = callback;
  };
  GenericPad2.prototype.onbuttonup = function(callback) {
    this._onbuttonup = callback;
  };
  GenericPad2.prototype._setButtonValue = function(newValue, currentValue, buttonIndex) {
    if (newValue !== currentValue) {
      if (newValue === 1) {
        if (this._onbuttondown) {
          this._onbuttondown(buttonIndex);
        }
        this.onButtonDownObservable.notifyObservers(buttonIndex);
      }
      if (newValue === 0) {
        if (this._onbuttonup) {
          this._onbuttonup(buttonIndex);
        }
        this.onButtonUpObservable.notifyObservers(buttonIndex);
      }
    }
    return newValue;
  };
  GenericPad2.prototype.update = function() {
    _super.prototype.update.call(this);
    for (var index = 0; index < this._buttons.length; index++) {
      this._buttons[index] = this._setButtonValue(this.browserGamepad.buttons[index].value, this._buttons[index], index);
    }
  };
  GenericPad2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this.onButtonDownObservable.clear();
    this.onButtonUpObservable.clear();
  };
  return GenericPad2;
}(Gamepad);

// node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraGamepadInput.js
var ArcRotateCameraGamepadInput = function() {
  function ArcRotateCameraGamepadInput2() {
    this.gamepadRotationSensibility = 80;
    this.gamepadMoveSensibility = 40;
    this._yAxisScale = 1;
  }
  Object.defineProperty(ArcRotateCameraGamepadInput2.prototype, "invertYAxis", {
    get: function() {
      return this._yAxisScale !== 1;
    },
    set: function(value) {
      this._yAxisScale = value ? -1 : 1;
    },
    enumerable: false,
    configurable: true
  });
  ArcRotateCameraGamepadInput2.prototype.attachControl = function() {
    var _this = this;
    var manager = this.camera.getScene().gamepadManager;
    this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add(function(gamepad) {
      if (gamepad.type !== Gamepad.POSE_ENABLED) {
        if (!_this.gamepad || gamepad.type === Gamepad.XBOX) {
          _this.gamepad = gamepad;
        }
      }
    });
    this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add(function(gamepad) {
      if (_this.gamepad === gamepad) {
        _this.gamepad = null;
      }
    });
    this.gamepad = manager.getGamepadByType(Gamepad.XBOX);
  };
  ArcRotateCameraGamepadInput2.prototype.detachControl = function(ignored) {
    this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);
    this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);
    this.gamepad = null;
  };
  ArcRotateCameraGamepadInput2.prototype.checkInputs = function() {
    if (this.gamepad) {
      var camera = this.camera;
      var RSValues = this.gamepad.rightStick;
      if (RSValues) {
        if (RSValues.x != 0) {
          var normalizedRX = RSValues.x / this.gamepadRotationSensibility;
          if (normalizedRX != 0 && Math.abs(normalizedRX) > 5e-3) {
            camera.inertialAlphaOffset += normalizedRX;
          }
        }
        if (RSValues.y != 0) {
          var normalizedRY = RSValues.y / this.gamepadRotationSensibility * this._yAxisScale;
          if (normalizedRY != 0 && Math.abs(normalizedRY) > 5e-3) {
            camera.inertialBetaOffset += normalizedRY;
          }
        }
      }
      var LSValues = this.gamepad.leftStick;
      if (LSValues && LSValues.y != 0) {
        var normalizedLY = LSValues.y / this.gamepadMoveSensibility;
        if (normalizedLY != 0 && Math.abs(normalizedLY) > 5e-3) {
          this.camera.inertialRadiusOffset -= normalizedLY;
        }
      }
    }
  };
  ArcRotateCameraGamepadInput2.prototype.getClassName = function() {
    return "ArcRotateCameraGamepadInput";
  };
  ArcRotateCameraGamepadInput2.prototype.getSimpleName = function() {
    return "gamepad";
  };
  __decorate([
    serialize()
  ], ArcRotateCameraGamepadInput2.prototype, "gamepadRotationSensibility", void 0);
  __decorate([
    serialize()
  ], ArcRotateCameraGamepadInput2.prototype, "gamepadMoveSensibility", void 0);
  return ArcRotateCameraGamepadInput2;
}();
CameraInputTypes["ArcRotateCameraGamepadInput"] = ArcRotateCameraGamepadInput;

// node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraKeyboardMoveInput.js
var ArcRotateCameraKeyboardMoveInput = function() {
  function ArcRotateCameraKeyboardMoveInput2() {
    this.keysUp = [38];
    this.keysDown = [40];
    this.keysLeft = [37];
    this.keysRight = [39];
    this.keysReset = [220];
    this.panningSensibility = 50;
    this.zoomingSensibility = 25;
    this.useAltToZoom = true;
    this.angularSpeed = 0.01;
    this._keys = new Array();
  }
  ArcRotateCameraKeyboardMoveInput2.prototype.attachControl = function(noPreventDefault) {
    var _this = this;
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    if (this._onCanvasBlurObserver) {
      return;
    }
    this._scene = this.camera.getScene();
    this._engine = this._scene.getEngine();
    this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(function() {
      _this._keys = [];
    });
    this._onKeyboardObserver = this._scene.onKeyboardObservable.add(function(info) {
      var evt = info.event;
      if (!evt.metaKey) {
        if (info.type === KeyboardEventTypes.KEYDOWN) {
          _this._ctrlPressed = evt.ctrlKey;
          _this._altPressed = evt.altKey;
          if (_this.keysUp.indexOf(evt.keyCode) !== -1 || _this.keysDown.indexOf(evt.keyCode) !== -1 || _this.keysLeft.indexOf(evt.keyCode) !== -1 || _this.keysRight.indexOf(evt.keyCode) !== -1 || _this.keysReset.indexOf(evt.keyCode) !== -1) {
            var index = _this._keys.indexOf(evt.keyCode);
            if (index === -1) {
              _this._keys.push(evt.keyCode);
            }
            if (evt.preventDefault) {
              if (!noPreventDefault) {
                evt.preventDefault();
              }
            }
          }
        } else {
          if (_this.keysUp.indexOf(evt.keyCode) !== -1 || _this.keysDown.indexOf(evt.keyCode) !== -1 || _this.keysLeft.indexOf(evt.keyCode) !== -1 || _this.keysRight.indexOf(evt.keyCode) !== -1 || _this.keysReset.indexOf(evt.keyCode) !== -1) {
            var index = _this._keys.indexOf(evt.keyCode);
            if (index >= 0) {
              _this._keys.splice(index, 1);
            }
            if (evt.preventDefault) {
              if (!noPreventDefault) {
                evt.preventDefault();
              }
            }
          }
        }
      }
    });
  };
  ArcRotateCameraKeyboardMoveInput2.prototype.detachControl = function(ignored) {
    if (this._scene) {
      if (this._onKeyboardObserver) {
        this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);
      }
      if (this._onCanvasBlurObserver) {
        this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);
      }
      this._onKeyboardObserver = null;
      this._onCanvasBlurObserver = null;
    }
    this._keys = [];
  };
  ArcRotateCameraKeyboardMoveInput2.prototype.checkInputs = function() {
    if (this._onKeyboardObserver) {
      var camera = this.camera;
      for (var index = 0; index < this._keys.length; index++) {
        var keyCode = this._keys[index];
        if (this.keysLeft.indexOf(keyCode) !== -1) {
          if (this._ctrlPressed && this.camera._useCtrlForPanning) {
            camera.inertialPanningX -= 1 / this.panningSensibility;
          } else {
            camera.inertialAlphaOffset -= this.angularSpeed;
          }
        } else if (this.keysUp.indexOf(keyCode) !== -1) {
          if (this._ctrlPressed && this.camera._useCtrlForPanning) {
            camera.inertialPanningY += 1 / this.panningSensibility;
          } else if (this._altPressed && this.useAltToZoom) {
            camera.inertialRadiusOffset += 1 / this.zoomingSensibility;
          } else {
            camera.inertialBetaOffset -= this.angularSpeed;
          }
        } else if (this.keysRight.indexOf(keyCode) !== -1) {
          if (this._ctrlPressed && this.camera._useCtrlForPanning) {
            camera.inertialPanningX += 1 / this.panningSensibility;
          } else {
            camera.inertialAlphaOffset += this.angularSpeed;
          }
        } else if (this.keysDown.indexOf(keyCode) !== -1) {
          if (this._ctrlPressed && this.camera._useCtrlForPanning) {
            camera.inertialPanningY -= 1 / this.panningSensibility;
          } else if (this._altPressed && this.useAltToZoom) {
            camera.inertialRadiusOffset -= 1 / this.zoomingSensibility;
          } else {
            camera.inertialBetaOffset += this.angularSpeed;
          }
        } else if (this.keysReset.indexOf(keyCode) !== -1) {
          if (camera.useInputToRestoreState) {
            camera.restoreState();
          }
        }
      }
    }
  };
  ArcRotateCameraKeyboardMoveInput2.prototype.getClassName = function() {
    return "ArcRotateCameraKeyboardMoveInput";
  };
  ArcRotateCameraKeyboardMoveInput2.prototype.getSimpleName = function() {
    return "keyboard";
  };
  __decorate([
    serialize()
  ], ArcRotateCameraKeyboardMoveInput2.prototype, "keysUp", void 0);
  __decorate([
    serialize()
  ], ArcRotateCameraKeyboardMoveInput2.prototype, "keysDown", void 0);
  __decorate([
    serialize()
  ], ArcRotateCameraKeyboardMoveInput2.prototype, "keysLeft", void 0);
  __decorate([
    serialize()
  ], ArcRotateCameraKeyboardMoveInput2.prototype, "keysRight", void 0);
  __decorate([
    serialize()
  ], ArcRotateCameraKeyboardMoveInput2.prototype, "keysReset", void 0);
  __decorate([
    serialize()
  ], ArcRotateCameraKeyboardMoveInput2.prototype, "panningSensibility", void 0);
  __decorate([
    serialize()
  ], ArcRotateCameraKeyboardMoveInput2.prototype, "zoomingSensibility", void 0);
  __decorate([
    serialize()
  ], ArcRotateCameraKeyboardMoveInput2.prototype, "useAltToZoom", void 0);
  __decorate([
    serialize()
  ], ArcRotateCameraKeyboardMoveInput2.prototype, "angularSpeed", void 0);
  return ArcRotateCameraKeyboardMoveInput2;
}();
CameraInputTypes["ArcRotateCameraKeyboardMoveInput"] = ArcRotateCameraKeyboardMoveInput;

// node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraMouseWheelInput.js
var ArcRotateCameraMouseWheelInput = function() {
  function ArcRotateCameraMouseWheelInput2() {
    this.wheelPrecision = 3;
    this.wheelDeltaPercentage = 0;
  }
  ArcRotateCameraMouseWheelInput2.prototype.computeDeltaFromMouseWheelLegacyEvent = function(mouseWheelDelta, radius) {
    var delta = 0;
    var wheelDelta = mouseWheelDelta * 0.01 * this.wheelDeltaPercentage * radius;
    if (mouseWheelDelta > 0) {
      delta = wheelDelta / (1 + this.wheelDeltaPercentage);
    } else {
      delta = wheelDelta * (1 + this.wheelDeltaPercentage);
    }
    return delta;
  };
  ArcRotateCameraMouseWheelInput2.prototype.attachControl = function(noPreventDefault) {
    var _this = this;
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    this._wheel = function(p, s) {
      if (p.type !== PointerEventTypes.POINTERWHEEL) {
        return;
      }
      var event = p.event;
      var delta = 0;
      var mouseWheelLegacyEvent = event;
      var wheelDelta = 0;
      if (mouseWheelLegacyEvent.wheelDelta) {
        wheelDelta = mouseWheelLegacyEvent.wheelDelta;
      } else {
        wheelDelta = -(event.deltaY || event.detail) * 60;
      }
      if (_this.wheelDeltaPercentage) {
        delta = _this.computeDeltaFromMouseWheelLegacyEvent(wheelDelta, _this.camera.radius);
        if (delta > 0) {
          var estimatedTargetRadius = _this.camera.radius;
          var targetInertia = _this.camera.inertialRadiusOffset + delta;
          for (var i = 0; i < 20 && Math.abs(targetInertia) > 1e-3; i++) {
            estimatedTargetRadius -= targetInertia;
            targetInertia *= _this.camera.inertia;
          }
          estimatedTargetRadius = Scalar.Clamp(estimatedTargetRadius, 0, Number.MAX_VALUE);
          delta = _this.computeDeltaFromMouseWheelLegacyEvent(wheelDelta, estimatedTargetRadius);
        }
      } else {
        delta = wheelDelta / (_this.wheelPrecision * 40);
      }
      if (delta) {
        _this.camera.inertialRadiusOffset += delta;
      }
      if (event.preventDefault) {
        if (!noPreventDefault) {
          event.preventDefault();
        }
      }
    };
    this._observer = this.camera.getScene().onPointerObservable.add(this._wheel, PointerEventTypes.POINTERWHEEL);
  };
  ArcRotateCameraMouseWheelInput2.prototype.detachControl = function(ignored) {
    if (this._observer) {
      this.camera.getScene().onPointerObservable.remove(this._observer);
      this._observer = null;
      this._wheel = null;
    }
  };
  ArcRotateCameraMouseWheelInput2.prototype.getClassName = function() {
    return "ArcRotateCameraMouseWheelInput";
  };
  ArcRotateCameraMouseWheelInput2.prototype.getSimpleName = function() {
    return "mousewheel";
  };
  __decorate([
    serialize()
  ], ArcRotateCameraMouseWheelInput2.prototype, "wheelPrecision", void 0);
  __decorate([
    serialize()
  ], ArcRotateCameraMouseWheelInput2.prototype, "wheelDeltaPercentage", void 0);
  return ArcRotateCameraMouseWheelInput2;
}();
CameraInputTypes["ArcRotateCameraMouseWheelInput"] = ArcRotateCameraMouseWheelInput;

// node_modules/@babylonjs/core/Cameras/Inputs/BaseCameraPointersInput.js
var BaseCameraPointersInput = function() {
  function BaseCameraPointersInput2() {
    this.buttons = [0, 1, 2];
  }
  BaseCameraPointersInput2.prototype.attachControl = function(noPreventDefault) {
    var _this = this;
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    var engine = this.camera.getEngine();
    var element = engine.getInputElement();
    var previousPinchSquaredDistance = 0;
    var previousMultiTouchPanPosition = null;
    this.pointA = null;
    this.pointB = null;
    this._altKey = false;
    this._ctrlKey = false;
    this._metaKey = false;
    this._shiftKey = false;
    this._buttonsPressed = 0;
    this._pointerInput = function(p, s) {
      var evt = p.event;
      var isTouch = evt.pointerType === "touch";
      if (engine.isInVRExclusivePointerMode) {
        return;
      }
      if (p.type !== PointerEventTypes.POINTERMOVE && _this.buttons.indexOf(evt.button) === -1) {
        return;
      }
      var srcElement = evt.srcElement || evt.target;
      _this._altKey = evt.altKey;
      _this._ctrlKey = evt.ctrlKey;
      _this._metaKey = evt.metaKey;
      _this._shiftKey = evt.shiftKey;
      _this._buttonsPressed = evt.buttons;
      if (engine.isPointerLock) {
        var offsetX = evt.movementX || evt.mozMovementX || evt.webkitMovementX || evt.msMovementX || 0;
        var offsetY = evt.movementY || evt.mozMovementY || evt.webkitMovementY || evt.msMovementY || 0;
        _this.onTouch(null, offsetX, offsetY);
        _this.pointA = null;
        _this.pointB = null;
      } else if (p.type === PointerEventTypes.POINTERDOWN && srcElement) {
        try {
          srcElement.setPointerCapture(evt.pointerId);
        } catch (e) {
        }
        if (_this.pointA === null) {
          _this.pointA = {
            x: evt.clientX,
            y: evt.clientY,
            pointerId: evt.pointerId,
            type: evt.pointerType
          };
        } else if (_this.pointB === null) {
          _this.pointB = {
            x: evt.clientX,
            y: evt.clientY,
            pointerId: evt.pointerId,
            type: evt.pointerType
          };
        }
        _this.onButtonDown(evt);
        if (!noPreventDefault) {
          evt.preventDefault();
          element && element.focus();
        }
      } else if (p.type === PointerEventTypes.POINTERDOUBLETAP) {
        _this.onDoubleTap(evt.pointerType);
      } else if (p.type === PointerEventTypes.POINTERUP && srcElement) {
        try {
          srcElement.releasePointerCapture(evt.pointerId);
        } catch (e) {
        }
        if (!isTouch) {
          _this.pointB = null;
        }
        if (engine._badOS) {
          _this.pointA = _this.pointB = null;
        } else {
          if (_this.pointB && _this.pointA && _this.pointA.pointerId == evt.pointerId) {
            _this.pointA = _this.pointB;
            _this.pointB = null;
          } else if (_this.pointA && _this.pointB && _this.pointB.pointerId == evt.pointerId) {
            _this.pointB = null;
          } else {
            _this.pointA = _this.pointB = null;
          }
        }
        if (previousPinchSquaredDistance !== 0 || previousMultiTouchPanPosition) {
          _this.onMultiTouch(_this.pointA, _this.pointB, previousPinchSquaredDistance, 0, previousMultiTouchPanPosition, null);
          previousPinchSquaredDistance = 0;
          previousMultiTouchPanPosition = null;
        }
        _this.onButtonUp(evt);
        if (!noPreventDefault) {
          evt.preventDefault();
        }
      } else if (p.type === PointerEventTypes.POINTERMOVE) {
        if (!noPreventDefault) {
          evt.preventDefault();
        }
        if (_this.pointA && _this.pointB === null) {
          var offsetX = evt.clientX - _this.pointA.x;
          var offsetY = evt.clientY - _this.pointA.y;
          _this.onTouch(_this.pointA, offsetX, offsetY);
          _this.pointA.x = evt.clientX;
          _this.pointA.y = evt.clientY;
        } else if (_this.pointA && _this.pointB) {
          var ed = _this.pointA.pointerId === evt.pointerId ? _this.pointA : _this.pointB;
          ed.x = evt.clientX;
          ed.y = evt.clientY;
          var distX = _this.pointA.x - _this.pointB.x;
          var distY = _this.pointA.y - _this.pointB.y;
          var pinchSquaredDistance = distX * distX + distY * distY;
          var multiTouchPanPosition = {
            x: (_this.pointA.x + _this.pointB.x) / 2,
            y: (_this.pointA.y + _this.pointB.y) / 2,
            pointerId: evt.pointerId,
            type: p.type
          };
          _this.onMultiTouch(_this.pointA, _this.pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);
          previousMultiTouchPanPosition = multiTouchPanPosition;
          previousPinchSquaredDistance = pinchSquaredDistance;
        }
      }
    };
    this._observer = this.camera.getScene().onPointerObservable.add(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);
    this._onLostFocus = function() {
      _this.pointA = _this.pointB = null;
      previousPinchSquaredDistance = 0;
      previousMultiTouchPanPosition = null;
      _this.onLostFocus();
    };
    element && element.addEventListener("contextmenu", this.onContextMenu.bind(this), false);
    var hostWindow = this.camera.getScene().getEngine().getHostWindow();
    if (hostWindow) {
      Tools.RegisterTopRootEvents(hostWindow, [
        { name: "blur", handler: this._onLostFocus }
      ]);
    }
  };
  BaseCameraPointersInput2.prototype.detachControl = function(ignored) {
    if (this._onLostFocus) {
      var hostWindow = this.camera.getScene().getEngine().getHostWindow();
      if (hostWindow) {
        Tools.UnregisterTopRootEvents(hostWindow, [
          { name: "blur", handler: this._onLostFocus }
        ]);
      }
    }
    if (this._observer) {
      this.camera.getScene().onPointerObservable.remove(this._observer);
      this._observer = null;
      if (this.onContextMenu) {
        var inputElement = this.camera.getScene().getEngine().getInputElement();
        inputElement && inputElement.removeEventListener("contextmenu", this.onContextMenu);
      }
      this._onLostFocus = null;
    }
    this._altKey = false;
    this._ctrlKey = false;
    this._metaKey = false;
    this._shiftKey = false;
    this._buttonsPressed = 0;
  };
  BaseCameraPointersInput2.prototype.getClassName = function() {
    return "BaseCameraPointersInput";
  };
  BaseCameraPointersInput2.prototype.getSimpleName = function() {
    return "pointers";
  };
  BaseCameraPointersInput2.prototype.onDoubleTap = function(type) {
  };
  BaseCameraPointersInput2.prototype.onTouch = function(point, offsetX, offsetY) {
  };
  BaseCameraPointersInput2.prototype.onMultiTouch = function(pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {
  };
  BaseCameraPointersInput2.prototype.onContextMenu = function(evt) {
    evt.preventDefault();
  };
  BaseCameraPointersInput2.prototype.onButtonDown = function(evt) {
  };
  BaseCameraPointersInput2.prototype.onButtonUp = function(evt) {
  };
  BaseCameraPointersInput2.prototype.onLostFocus = function() {
  };
  __decorate([
    serialize()
  ], BaseCameraPointersInput2.prototype, "buttons", void 0);
  return BaseCameraPointersInput2;
}();

// node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraPointersInput.js
var ArcRotateCameraPointersInput = function(_super) {
  __extends(ArcRotateCameraPointersInput2, _super);
  function ArcRotateCameraPointersInput2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.buttons = [0, 1, 2];
    _this.angularSensibilityX = 1e3;
    _this.angularSensibilityY = 1e3;
    _this.pinchPrecision = 12;
    _this.pinchDeltaPercentage = 0;
    _this.useNaturalPinchZoom = false;
    _this.panningSensibility = 1e3;
    _this.multiTouchPanning = true;
    _this.multiTouchPanAndZoom = true;
    _this.pinchInwards = true;
    _this._isPanClick = false;
    _this._twoFingerActivityCount = 0;
    _this._isPinching = false;
    return _this;
  }
  ArcRotateCameraPointersInput2.prototype.getClassName = function() {
    return "ArcRotateCameraPointersInput";
  };
  ArcRotateCameraPointersInput2.prototype.onTouch = function(point, offsetX, offsetY) {
    if (this.panningSensibility !== 0 && (this._ctrlKey && this.camera._useCtrlForPanning || this._isPanClick)) {
      this.camera.inertialPanningX += -offsetX / this.panningSensibility;
      this.camera.inertialPanningY += offsetY / this.panningSensibility;
    } else {
      this.camera.inertialAlphaOffset -= offsetX / this.angularSensibilityX;
      this.camera.inertialBetaOffset -= offsetY / this.angularSensibilityY;
    }
  };
  ArcRotateCameraPointersInput2.prototype.onDoubleTap = function(type) {
    if (this.camera.useInputToRestoreState) {
      this.camera.restoreState();
    }
  };
  ArcRotateCameraPointersInput2.prototype.onMultiTouch = function(pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {
    if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {
      return;
    }
    if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {
      return;
    }
    var direction = this.pinchInwards ? 1 : -1;
    if (this.multiTouchPanAndZoom) {
      if (this.useNaturalPinchZoom) {
        this.camera.radius = this.camera.radius * Math.sqrt(previousPinchSquaredDistance) / Math.sqrt(pinchSquaredDistance);
      } else if (this.pinchDeltaPercentage) {
        this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) * 1e-3 * this.camera.radius * this.pinchDeltaPercentage;
      } else {
        this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) / (this.pinchPrecision * direction * (this.angularSensibilityX + this.angularSensibilityY) / 2);
      }
      if (this.panningSensibility !== 0 && previousMultiTouchPanPosition && multiTouchPanPosition) {
        var moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;
        var moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;
        this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;
        this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;
      }
    } else {
      this._twoFingerActivityCount++;
      var previousPinchDistance = Math.sqrt(previousPinchSquaredDistance);
      var pinchDistance = Math.sqrt(pinchSquaredDistance);
      if (this._isPinching || this._twoFingerActivityCount < 20 && Math.abs(pinchDistance - previousPinchDistance) > this.camera.pinchToPanMaxDistance) {
        if (this.pinchDeltaPercentage) {
          this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) * 1e-3 * this.camera.radius * this.pinchDeltaPercentage;
        } else {
          this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) / (this.pinchPrecision * direction * (this.angularSensibilityX + this.angularSensibilityY) / 2);
        }
        this._isPinching = true;
      } else {
        if (this.panningSensibility !== 0 && this.multiTouchPanning && multiTouchPanPosition && previousMultiTouchPanPosition) {
          var moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;
          var moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;
          this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;
          this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;
        }
      }
    }
  };
  ArcRotateCameraPointersInput2.prototype.onButtonDown = function(evt) {
    this._isPanClick = evt.button === this.camera._panningMouseButton;
  };
  ArcRotateCameraPointersInput2.prototype.onButtonUp = function(evt) {
    this._twoFingerActivityCount = 0;
    this._isPinching = false;
  };
  ArcRotateCameraPointersInput2.prototype.onLostFocus = function() {
    this._isPanClick = false;
    this._twoFingerActivityCount = 0;
    this._isPinching = false;
  };
  __decorate([
    serialize()
  ], ArcRotateCameraPointersInput2.prototype, "buttons", void 0);
  __decorate([
    serialize()
  ], ArcRotateCameraPointersInput2.prototype, "angularSensibilityX", void 0);
  __decorate([
    serialize()
  ], ArcRotateCameraPointersInput2.prototype, "angularSensibilityY", void 0);
  __decorate([
    serialize()
  ], ArcRotateCameraPointersInput2.prototype, "pinchPrecision", void 0);
  __decorate([
    serialize()
  ], ArcRotateCameraPointersInput2.prototype, "pinchDeltaPercentage", void 0);
  __decorate([
    serialize()
  ], ArcRotateCameraPointersInput2.prototype, "useNaturalPinchZoom", void 0);
  __decorate([
    serialize()
  ], ArcRotateCameraPointersInput2.prototype, "panningSensibility", void 0);
  __decorate([
    serialize()
  ], ArcRotateCameraPointersInput2.prototype, "multiTouchPanning", void 0);
  __decorate([
    serialize()
  ], ArcRotateCameraPointersInput2.prototype, "multiTouchPanAndZoom", void 0);
  return ArcRotateCameraPointersInput2;
}(BaseCameraPointersInput);
CameraInputTypes["ArcRotateCameraPointersInput"] = ArcRotateCameraPointersInput;

// node_modules/@babylonjs/core/Cameras/arcRotateCameraInputsManager.js
var ArcRotateCameraInputsManager = function(_super) {
  __extends(ArcRotateCameraInputsManager2, _super);
  function ArcRotateCameraInputsManager2(camera) {
    return _super.call(this, camera) || this;
  }
  ArcRotateCameraInputsManager2.prototype.addMouseWheel = function() {
    this.add(new ArcRotateCameraMouseWheelInput());
    return this;
  };
  ArcRotateCameraInputsManager2.prototype.addPointers = function() {
    this.add(new ArcRotateCameraPointersInput());
    return this;
  };
  ArcRotateCameraInputsManager2.prototype.addKeyboard = function() {
    this.add(new ArcRotateCameraKeyboardMoveInput());
    return this;
  };
  return ArcRotateCameraInputsManager2;
}(CameraInputsManager);

// node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraVRDeviceOrientationInput.js
ArcRotateCameraInputsManager.prototype.addVRDeviceOrientation = function() {
  this.add(new ArcRotateCameraVRDeviceOrientationInput());
  return this;
};
var ArcRotateCameraVRDeviceOrientationInput = function() {
  function ArcRotateCameraVRDeviceOrientationInput2() {
    this.alphaCorrection = 1;
    this.gammaCorrection = 1;
    this._alpha = 0;
    this._gamma = 0;
    this._dirty = false;
    this._deviceOrientationHandler = this._onOrientationEvent.bind(this);
  }
  ArcRotateCameraVRDeviceOrientationInput2.prototype.attachControl = function(noPreventDefault) {
    var _this = this;
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    this.camera.attachControl(noPreventDefault);
    var hostWindow = this.camera.getScene().getEngine().getHostWindow();
    if (hostWindow) {
      if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
        DeviceOrientationEvent.requestPermission().then(function(response) {
          if (response === "granted") {
            hostWindow.addEventListener("deviceorientation", _this._deviceOrientationHandler);
          } else {
            Tools.Warn("Permission not granted.");
          }
        }).catch(function(error) {
          Tools.Error(error);
        });
      } else {
        hostWindow.addEventListener("deviceorientation", this._deviceOrientationHandler);
      }
    }
  };
  ArcRotateCameraVRDeviceOrientationInput2.prototype._onOrientationEvent = function(evt) {
    if (evt.alpha !== null) {
      this._alpha = (+evt.alpha | 0) * this.alphaCorrection;
    }
    if (evt.gamma !== null) {
      this._gamma = (+evt.gamma | 0) * this.gammaCorrection;
    }
    this._dirty = true;
  };
  ArcRotateCameraVRDeviceOrientationInput2.prototype.checkInputs = function() {
    if (this._dirty) {
      this._dirty = false;
      if (this._gamma < 0) {
        this._gamma = 180 + this._gamma;
      }
      this.camera.alpha = -this._alpha / 180 * Math.PI % Math.PI * 2;
      this.camera.beta = this._gamma / 180 * Math.PI;
    }
  };
  ArcRotateCameraVRDeviceOrientationInput2.prototype.detachControl = function(ignored) {
    window.removeEventListener("deviceorientation", this._deviceOrientationHandler);
  };
  ArcRotateCameraVRDeviceOrientationInput2.prototype.getClassName = function() {
    return "ArcRotateCameraVRDeviceOrientationInput";
  };
  ArcRotateCameraVRDeviceOrientationInput2.prototype.getSimpleName = function() {
    return "VRDeviceOrientation";
  };
  return ArcRotateCameraVRDeviceOrientationInput2;
}();
CameraInputTypes["ArcRotateCameraVRDeviceOrientationInput"] = ArcRotateCameraVRDeviceOrientationInput;

// node_modules/@babylonjs/core/Cameras/Inputs/flyCameraKeyboardInput.js
var FlyCameraKeyboardInput = function() {
  function FlyCameraKeyboardInput2() {
    this.keysForward = [87];
    this.keysBackward = [83];
    this.keysUp = [69];
    this.keysDown = [81];
    this.keysRight = [68];
    this.keysLeft = [65];
    this._keys = new Array();
  }
  FlyCameraKeyboardInput2.prototype.attachControl = function(noPreventDefault) {
    var _this = this;
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    if (this._onCanvasBlurObserver) {
      return;
    }
    this._scene = this.camera.getScene();
    this._engine = this._scene.getEngine();
    this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(function() {
      _this._keys = [];
    });
    this._onKeyboardObserver = this._scene.onKeyboardObservable.add(function(info) {
      var evt = info.event;
      if (info.type === KeyboardEventTypes.KEYDOWN) {
        if (_this.keysForward.indexOf(evt.keyCode) !== -1 || _this.keysBackward.indexOf(evt.keyCode) !== -1 || _this.keysUp.indexOf(evt.keyCode) !== -1 || _this.keysDown.indexOf(evt.keyCode) !== -1 || _this.keysLeft.indexOf(evt.keyCode) !== -1 || _this.keysRight.indexOf(evt.keyCode) !== -1) {
          var index = _this._keys.indexOf(evt.keyCode);
          if (index === -1) {
            _this._keys.push(evt.keyCode);
          }
          if (!noPreventDefault) {
            evt.preventDefault();
          }
        }
      } else {
        if (_this.keysForward.indexOf(evt.keyCode) !== -1 || _this.keysBackward.indexOf(evt.keyCode) !== -1 || _this.keysUp.indexOf(evt.keyCode) !== -1 || _this.keysDown.indexOf(evt.keyCode) !== -1 || _this.keysLeft.indexOf(evt.keyCode) !== -1 || _this.keysRight.indexOf(evt.keyCode) !== -1) {
          var index = _this._keys.indexOf(evt.keyCode);
          if (index >= 0) {
            _this._keys.splice(index, 1);
          }
          if (!noPreventDefault) {
            evt.preventDefault();
          }
        }
      }
    });
  };
  FlyCameraKeyboardInput2.prototype.detachControl = function(ignored) {
    if (this._scene) {
      if (this._onKeyboardObserver) {
        this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);
      }
      if (this._onCanvasBlurObserver) {
        this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);
      }
      this._onKeyboardObserver = null;
      this._onCanvasBlurObserver = null;
    }
    this._keys = [];
  };
  FlyCameraKeyboardInput2.prototype.getClassName = function() {
    return "FlyCameraKeyboardInput";
  };
  FlyCameraKeyboardInput2.prototype._onLostFocus = function(e) {
    this._keys = [];
  };
  FlyCameraKeyboardInput2.prototype.getSimpleName = function() {
    return "keyboard";
  };
  FlyCameraKeyboardInput2.prototype.checkInputs = function() {
    if (this._onKeyboardObserver) {
      var camera = this.camera;
      for (var index = 0; index < this._keys.length; index++) {
        var keyCode = this._keys[index];
        var speed = camera._computeLocalCameraSpeed();
        if (this.keysForward.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(0, 0, speed);
        } else if (this.keysBackward.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(0, 0, -speed);
        } else if (this.keysUp.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(0, speed, 0);
        } else if (this.keysDown.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(0, -speed, 0);
        } else if (this.keysRight.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(speed, 0, 0);
        } else if (this.keysLeft.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(-speed, 0, 0);
        }
        if (camera.getScene().useRightHandedSystem) {
          camera._localDirection.z *= -1;
        }
        camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);
        Vector3.TransformNormalToRef(camera._localDirection, camera._cameraTransformMatrix, camera._transformedDirection);
        camera.cameraDirection.addInPlace(camera._transformedDirection);
      }
    }
  };
  __decorate([
    serialize()
  ], FlyCameraKeyboardInput2.prototype, "keysForward", void 0);
  __decorate([
    serialize()
  ], FlyCameraKeyboardInput2.prototype, "keysBackward", void 0);
  __decorate([
    serialize()
  ], FlyCameraKeyboardInput2.prototype, "keysUp", void 0);
  __decorate([
    serialize()
  ], FlyCameraKeyboardInput2.prototype, "keysDown", void 0);
  __decorate([
    serialize()
  ], FlyCameraKeyboardInput2.prototype, "keysRight", void 0);
  __decorate([
    serialize()
  ], FlyCameraKeyboardInput2.prototype, "keysLeft", void 0);
  return FlyCameraKeyboardInput2;
}();
CameraInputTypes["FlyCameraKeyboardInput"] = FlyCameraKeyboardInput;

// node_modules/@babylonjs/core/Cameras/Inputs/flyCameraMouseInput.js
var FlyCameraMouseInput = function() {
  function FlyCameraMouseInput2(touchEnabled) {
    if (touchEnabled === void 0) {
      touchEnabled = true;
    }
    this.buttons = [0, 1, 2];
    this.buttonsYaw = [-1, 0, 1];
    this.buttonsPitch = [-1, 0, 1];
    this.buttonsRoll = [2];
    this.activeButton = -1;
    this.angularSensibility = 1e3;
    this.previousPosition = null;
  }
  FlyCameraMouseInput2.prototype.attachControl = function(noPreventDefault) {
    var _this = this;
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    this.noPreventDefault = noPreventDefault;
    this._observer = this.camera.getScene().onPointerObservable.add(function(p, s) {
      _this._pointerInput(p, s);
    }, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);
    this._rollObserver = this.camera.getScene().onBeforeRenderObservable.add(function() {
      if (_this.camera.rollCorrect) {
        _this.camera.restoreRoll(_this.camera.rollCorrect);
      }
    });
  };
  FlyCameraMouseInput2.prototype.detachControl = function(ignored) {
    if (this._observer) {
      this.camera.getScene().onPointerObservable.remove(this._observer);
      this.camera.getScene().onBeforeRenderObservable.remove(this._rollObserver);
      this._observer = null;
      this._rollObserver = null;
      this.previousPosition = null;
      this.noPreventDefault = void 0;
    }
  };
  FlyCameraMouseInput2.prototype.getClassName = function() {
    return "FlyCameraMouseInput";
  };
  FlyCameraMouseInput2.prototype.getSimpleName = function() {
    return "mouse";
  };
  FlyCameraMouseInput2.prototype._pointerInput = function(p, s) {
    var e = p.event;
    var camera = this.camera;
    var engine = camera.getEngine();
    if (engine.isInVRExclusivePointerMode) {
      return;
    }
    if (!this.touchEnabled && e.pointerType === "touch") {
      return;
    }
    if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(e.button) === -1) {
      return;
    }
    var srcElement = e.srcElement || e.target;
    if (p.type === PointerEventTypes.POINTERDOWN && srcElement) {
      try {
        srcElement.setPointerCapture(e.pointerId);
      } catch (e2) {
      }
      this.previousPosition = {
        x: e.clientX,
        y: e.clientY
      };
      this.activeButton = e.button;
      if (!this.noPreventDefault) {
        e.preventDefault();
        this.element.focus();
      }
      if (engine.isPointerLock) {
        this._onMouseMove(p.event);
      }
    } else if (p.type === PointerEventTypes.POINTERUP && srcElement) {
      try {
        srcElement.releasePointerCapture(e.pointerId);
      } catch (e2) {
      }
      this.activeButton = -1;
      this.previousPosition = null;
      if (!this.noPreventDefault) {
        e.preventDefault();
      }
    } else if (p.type === PointerEventTypes.POINTERMOVE) {
      if (!this.previousPosition) {
        if (engine.isPointerLock) {
          this._onMouseMove(p.event);
        }
        return;
      }
      var offsetX = e.clientX - this.previousPosition.x;
      var offsetY = e.clientY - this.previousPosition.y;
      this.rotateCamera(offsetX, offsetY);
      this.previousPosition = {
        x: e.clientX,
        y: e.clientY
      };
      if (!this.noPreventDefault) {
        e.preventDefault();
      }
    }
  };
  FlyCameraMouseInput2.prototype._onMouseMove = function(e) {
    var camera = this.camera;
    var engine = camera.getEngine();
    if (!engine.isPointerLock || engine.isInVRExclusivePointerMode) {
      return;
    }
    var offsetX = e.movementX || e.mozMovementX || e.webkitMovementX || e.msMovementX || 0;
    var offsetY = e.movementY || e.mozMovementY || e.webkitMovementY || e.msMovementY || 0;
    this.rotateCamera(offsetX, offsetY);
    this.previousPosition = null;
    if (!this.noPreventDefault) {
      e.preventDefault();
    }
  };
  FlyCameraMouseInput2.prototype.rotateCamera = function(offsetX, offsetY) {
    var _this = this;
    var camera = this.camera;
    var scene = this.camera.getScene();
    if (scene.useRightHandedSystem) {
      offsetX *= -1;
    }
    if (camera.parent && camera.parent._getWorldMatrixDeterminant() < 0) {
      offsetX *= -1;
    }
    var x = offsetX / this.angularSensibility;
    var y = offsetY / this.angularSensibility;
    var currentRotation = Quaternion.RotationYawPitchRoll(camera.rotation.y, camera.rotation.x, camera.rotation.z);
    var rotationChange;
    if (this.buttonsPitch.some(function(v) {
      return v === _this.activeButton;
    })) {
      rotationChange = Quaternion.RotationAxis(Axis.X, y);
      currentRotation.multiplyInPlace(rotationChange);
    }
    if (this.buttonsYaw.some(function(v) {
      return v === _this.activeButton;
    })) {
      rotationChange = Quaternion.RotationAxis(Axis.Y, x);
      currentRotation.multiplyInPlace(rotationChange);
      var limit = camera.bankedTurnLimit + camera._trackRoll;
      if (camera.bankedTurn && -limit < camera.rotation.z && camera.rotation.z < limit) {
        var bankingDelta = camera.bankedTurnMultiplier * -x;
        rotationChange = Quaternion.RotationAxis(Axis.Z, bankingDelta);
        currentRotation.multiplyInPlace(rotationChange);
      }
    }
    if (this.buttonsRoll.some(function(v) {
      return v === _this.activeButton;
    })) {
      rotationChange = Quaternion.RotationAxis(Axis.Z, -x);
      camera._trackRoll -= x;
      currentRotation.multiplyInPlace(rotationChange);
    }
    currentRotation.toEulerAnglesToRef(camera.rotation);
  };
  __decorate([
    serialize()
  ], FlyCameraMouseInput2.prototype, "buttons", void 0);
  __decorate([
    serialize()
  ], FlyCameraMouseInput2.prototype, "angularSensibility", void 0);
  return FlyCameraMouseInput2;
}();
CameraInputTypes["FlyCameraMouseInput"] = FlyCameraMouseInput;

// node_modules/@babylonjs/core/Cameras/Inputs/followCameraKeyboardMoveInput.js
var FollowCameraKeyboardMoveInput = function() {
  function FollowCameraKeyboardMoveInput2() {
    this.keysHeightOffsetIncr = [38];
    this.keysHeightOffsetDecr = [40];
    this.keysHeightOffsetModifierAlt = false;
    this.keysHeightOffsetModifierCtrl = false;
    this.keysHeightOffsetModifierShift = false;
    this.keysRotationOffsetIncr = [37];
    this.keysRotationOffsetDecr = [39];
    this.keysRotationOffsetModifierAlt = false;
    this.keysRotationOffsetModifierCtrl = false;
    this.keysRotationOffsetModifierShift = false;
    this.keysRadiusIncr = [40];
    this.keysRadiusDecr = [38];
    this.keysRadiusModifierAlt = true;
    this.keysRadiusModifierCtrl = false;
    this.keysRadiusModifierShift = false;
    this.heightSensibility = 1;
    this.rotationSensibility = 1;
    this.radiusSensibility = 1;
    this._keys = new Array();
  }
  FollowCameraKeyboardMoveInput2.prototype.attachControl = function(noPreventDefault) {
    var _this = this;
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    if (this._onCanvasBlurObserver) {
      return;
    }
    this._scene = this.camera.getScene();
    this._engine = this._scene.getEngine();
    this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(function() {
      _this._keys = [];
    });
    this._onKeyboardObserver = this._scene.onKeyboardObservable.add(function(info) {
      var evt = info.event;
      if (!evt.metaKey) {
        if (info.type === KeyboardEventTypes.KEYDOWN) {
          _this._ctrlPressed = evt.ctrlKey;
          _this._altPressed = evt.altKey;
          _this._shiftPressed = evt.shiftKey;
          if (_this.keysHeightOffsetIncr.indexOf(evt.keyCode) !== -1 || _this.keysHeightOffsetDecr.indexOf(evt.keyCode) !== -1 || _this.keysRotationOffsetIncr.indexOf(evt.keyCode) !== -1 || _this.keysRotationOffsetDecr.indexOf(evt.keyCode) !== -1 || _this.keysRadiusIncr.indexOf(evt.keyCode) !== -1 || _this.keysRadiusDecr.indexOf(evt.keyCode) !== -1) {
            var index = _this._keys.indexOf(evt.keyCode);
            if (index === -1) {
              _this._keys.push(evt.keyCode);
            }
            if (evt.preventDefault) {
              if (!noPreventDefault) {
                evt.preventDefault();
              }
            }
          }
        } else {
          if (_this.keysHeightOffsetIncr.indexOf(evt.keyCode) !== -1 || _this.keysHeightOffsetDecr.indexOf(evt.keyCode) !== -1 || _this.keysRotationOffsetIncr.indexOf(evt.keyCode) !== -1 || _this.keysRotationOffsetDecr.indexOf(evt.keyCode) !== -1 || _this.keysRadiusIncr.indexOf(evt.keyCode) !== -1 || _this.keysRadiusDecr.indexOf(evt.keyCode) !== -1) {
            var index = _this._keys.indexOf(evt.keyCode);
            if (index >= 0) {
              _this._keys.splice(index, 1);
            }
            if (evt.preventDefault) {
              if (!noPreventDefault) {
                evt.preventDefault();
              }
            }
          }
        }
      }
    });
  };
  FollowCameraKeyboardMoveInput2.prototype.detachControl = function(ignored) {
    if (this._scene) {
      if (this._onKeyboardObserver) {
        this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);
      }
      if (this._onCanvasBlurObserver) {
        this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);
      }
      this._onKeyboardObserver = null;
      this._onCanvasBlurObserver = null;
    }
    this._keys = [];
  };
  FollowCameraKeyboardMoveInput2.prototype.checkInputs = function() {
    var _this = this;
    if (this._onKeyboardObserver) {
      this._keys.forEach(function(keyCode) {
        if (_this.keysHeightOffsetIncr.indexOf(keyCode) !== -1 && _this._modifierHeightOffset()) {
          _this.camera.heightOffset += _this.heightSensibility;
        } else if (_this.keysHeightOffsetDecr.indexOf(keyCode) !== -1 && _this._modifierHeightOffset()) {
          _this.camera.heightOffset -= _this.heightSensibility;
        } else if (_this.keysRotationOffsetIncr.indexOf(keyCode) !== -1 && _this._modifierRotationOffset()) {
          _this.camera.rotationOffset += _this.rotationSensibility;
          _this.camera.rotationOffset %= 360;
        } else if (_this.keysRotationOffsetDecr.indexOf(keyCode) !== -1 && _this._modifierRotationOffset()) {
          _this.camera.rotationOffset -= _this.rotationSensibility;
          _this.camera.rotationOffset %= 360;
        } else if (_this.keysRadiusIncr.indexOf(keyCode) !== -1 && _this._modifierRadius()) {
          _this.camera.radius += _this.radiusSensibility;
        } else if (_this.keysRadiusDecr.indexOf(keyCode) !== -1 && _this._modifierRadius()) {
          _this.camera.radius -= _this.radiusSensibility;
        }
      });
    }
  };
  FollowCameraKeyboardMoveInput2.prototype.getClassName = function() {
    return "FollowCameraKeyboardMoveInput";
  };
  FollowCameraKeyboardMoveInput2.prototype.getSimpleName = function() {
    return "keyboard";
  };
  FollowCameraKeyboardMoveInput2.prototype._modifierHeightOffset = function() {
    return this.keysHeightOffsetModifierAlt === this._altPressed && this.keysHeightOffsetModifierCtrl === this._ctrlPressed && this.keysHeightOffsetModifierShift === this._shiftPressed;
  };
  FollowCameraKeyboardMoveInput2.prototype._modifierRotationOffset = function() {
    return this.keysRotationOffsetModifierAlt === this._altPressed && this.keysRotationOffsetModifierCtrl === this._ctrlPressed && this.keysRotationOffsetModifierShift === this._shiftPressed;
  };
  FollowCameraKeyboardMoveInput2.prototype._modifierRadius = function() {
    return this.keysRadiusModifierAlt === this._altPressed && this.keysRadiusModifierCtrl === this._ctrlPressed && this.keysRadiusModifierShift === this._shiftPressed;
  };
  __decorate([
    serialize()
  ], FollowCameraKeyboardMoveInput2.prototype, "keysHeightOffsetIncr", void 0);
  __decorate([
    serialize()
  ], FollowCameraKeyboardMoveInput2.prototype, "keysHeightOffsetDecr", void 0);
  __decorate([
    serialize()
  ], FollowCameraKeyboardMoveInput2.prototype, "keysHeightOffsetModifierAlt", void 0);
  __decorate([
    serialize()
  ], FollowCameraKeyboardMoveInput2.prototype, "keysHeightOffsetModifierCtrl", void 0);
  __decorate([
    serialize()
  ], FollowCameraKeyboardMoveInput2.prototype, "keysHeightOffsetModifierShift", void 0);
  __decorate([
    serialize()
  ], FollowCameraKeyboardMoveInput2.prototype, "keysRotationOffsetIncr", void 0);
  __decorate([
    serialize()
  ], FollowCameraKeyboardMoveInput2.prototype, "keysRotationOffsetDecr", void 0);
  __decorate([
    serialize()
  ], FollowCameraKeyboardMoveInput2.prototype, "keysRotationOffsetModifierAlt", void 0);
  __decorate([
    serialize()
  ], FollowCameraKeyboardMoveInput2.prototype, "keysRotationOffsetModifierCtrl", void 0);
  __decorate([
    serialize()
  ], FollowCameraKeyboardMoveInput2.prototype, "keysRotationOffsetModifierShift", void 0);
  __decorate([
    serialize()
  ], FollowCameraKeyboardMoveInput2.prototype, "keysRadiusIncr", void 0);
  __decorate([
    serialize()
  ], FollowCameraKeyboardMoveInput2.prototype, "keysRadiusDecr", void 0);
  __decorate([
    serialize()
  ], FollowCameraKeyboardMoveInput2.prototype, "keysRadiusModifierAlt", void 0);
  __decorate([
    serialize()
  ], FollowCameraKeyboardMoveInput2.prototype, "keysRadiusModifierCtrl", void 0);
  __decorate([
    serialize()
  ], FollowCameraKeyboardMoveInput2.prototype, "keysRadiusModifierShift", void 0);
  __decorate([
    serialize()
  ], FollowCameraKeyboardMoveInput2.prototype, "heightSensibility", void 0);
  __decorate([
    serialize()
  ], FollowCameraKeyboardMoveInput2.prototype, "rotationSensibility", void 0);
  __decorate([
    serialize()
  ], FollowCameraKeyboardMoveInput2.prototype, "radiusSensibility", void 0);
  return FollowCameraKeyboardMoveInput2;
}();
CameraInputTypes["FollowCameraKeyboardMoveInput"] = FollowCameraKeyboardMoveInput;

// node_modules/@babylonjs/core/Cameras/Inputs/followCameraMouseWheelInput.js
var FollowCameraMouseWheelInput = function() {
  function FollowCameraMouseWheelInput2() {
    this.axisControlRadius = true;
    this.axisControlHeight = false;
    this.axisControlRotation = false;
    this.wheelPrecision = 3;
    this.wheelDeltaPercentage = 0;
  }
  FollowCameraMouseWheelInput2.prototype.attachControl = function(noPreventDefault) {
    var _this = this;
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    this._wheel = function(p, s) {
      if (p.type !== PointerEventTypes.POINTERWHEEL) {
        return;
      }
      var event = p.event;
      var delta = 0;
      var wheelDelta = Math.max(-1, Math.min(1, event.deltaY || event.wheelDelta || -event.detail));
      if (_this.wheelDeltaPercentage) {
        console.assert(_this.axisControlRadius + _this.axisControlHeight + _this.axisControlRotation <= 1, "wheelDeltaPercentage only usable when mouse wheel controlls ONE axis. Currently enabled: axisControlRadius: " + _this.axisControlRadius + ", axisControlHeightOffset: " + _this.axisControlHeight + ", axisControlRotationOffset: " + _this.axisControlRotation);
        if (_this.axisControlRadius) {
          delta = wheelDelta * 0.01 * _this.wheelDeltaPercentage * _this.camera.radius;
        } else if (_this.axisControlHeight) {
          delta = wheelDelta * 0.01 * _this.wheelDeltaPercentage * _this.camera.heightOffset;
        } else if (_this.axisControlRotation) {
          delta = wheelDelta * 0.01 * _this.wheelDeltaPercentage * _this.camera.rotationOffset;
        }
      } else {
        delta = wheelDelta * _this.wheelPrecision;
      }
      if (delta) {
        if (_this.axisControlRadius) {
          _this.camera.radius += delta;
        } else if (_this.axisControlHeight) {
          _this.camera.heightOffset -= delta;
        } else if (_this.axisControlRotation) {
          _this.camera.rotationOffset -= delta;
        }
      }
      if (event.preventDefault) {
        if (!noPreventDefault) {
          event.preventDefault();
        }
      }
    };
    this._observer = this.camera.getScene().onPointerObservable.add(this._wheel, PointerEventTypes.POINTERWHEEL);
  };
  FollowCameraMouseWheelInput2.prototype.detachControl = function(ignored) {
    if (this._observer) {
      this.camera.getScene().onPointerObservable.remove(this._observer);
      this._observer = null;
      this._wheel = null;
    }
  };
  FollowCameraMouseWheelInput2.prototype.getClassName = function() {
    return "ArcRotateCameraMouseWheelInput";
  };
  FollowCameraMouseWheelInput2.prototype.getSimpleName = function() {
    return "mousewheel";
  };
  __decorate([
    serialize()
  ], FollowCameraMouseWheelInput2.prototype, "axisControlRadius", void 0);
  __decorate([
    serialize()
  ], FollowCameraMouseWheelInput2.prototype, "axisControlHeight", void 0);
  __decorate([
    serialize()
  ], FollowCameraMouseWheelInput2.prototype, "axisControlRotation", void 0);
  __decorate([
    serialize()
  ], FollowCameraMouseWheelInput2.prototype, "wheelPrecision", void 0);
  __decorate([
    serialize()
  ], FollowCameraMouseWheelInput2.prototype, "wheelDeltaPercentage", void 0);
  return FollowCameraMouseWheelInput2;
}();
CameraInputTypes["FollowCameraMouseWheelInput"] = FollowCameraMouseWheelInput;

// node_modules/@babylonjs/core/Cameras/Inputs/followCameraPointersInput.js
var FollowCameraPointersInput = function(_super) {
  __extends(FollowCameraPointersInput2, _super);
  function FollowCameraPointersInput2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.angularSensibilityX = 1;
    _this.angularSensibilityY = 1;
    _this.pinchPrecision = 1e4;
    _this.pinchDeltaPercentage = 0;
    _this.axisXControlRadius = false;
    _this.axisXControlHeight = false;
    _this.axisXControlRotation = true;
    _this.axisYControlRadius = false;
    _this.axisYControlHeight = true;
    _this.axisYControlRotation = false;
    _this.axisPinchControlRadius = true;
    _this.axisPinchControlHeight = false;
    _this.axisPinchControlRotation = false;
    _this.warningEnable = true;
    _this._warningCounter = 0;
    return _this;
  }
  FollowCameraPointersInput2.prototype.getClassName = function() {
    return "FollowCameraPointersInput";
  };
  FollowCameraPointersInput2.prototype.onTouch = function(pointA, offsetX, offsetY) {
    this._warning();
    if (this.axisXControlRotation) {
      this.camera.rotationOffset += offsetX / this.angularSensibilityX;
    } else if (this.axisYControlRotation) {
      this.camera.rotationOffset += offsetY / this.angularSensibilityX;
    }
    if (this.axisXControlHeight) {
      this.camera.heightOffset += offsetX / this.angularSensibilityY;
    } else if (this.axisYControlHeight) {
      this.camera.heightOffset += offsetY / this.angularSensibilityY;
    }
    if (this.axisXControlRadius) {
      this.camera.radius -= offsetX / this.angularSensibilityY;
    } else if (this.axisYControlRadius) {
      this.camera.radius -= offsetY / this.angularSensibilityY;
    }
  };
  FollowCameraPointersInput2.prototype.onMultiTouch = function(pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {
    if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {
      return;
    }
    if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {
      return;
    }
    var pinchDelta = (pinchSquaredDistance - previousPinchSquaredDistance) / (this.pinchPrecision * (this.angularSensibilityX + this.angularSensibilityY) / 2);
    if (this.pinchDeltaPercentage) {
      pinchDelta *= 0.01 * this.pinchDeltaPercentage;
      if (this.axisPinchControlRotation) {
        this.camera.rotationOffset += pinchDelta * this.camera.rotationOffset;
      }
      if (this.axisPinchControlHeight) {
        this.camera.heightOffset += pinchDelta * this.camera.heightOffset;
      }
      if (this.axisPinchControlRadius) {
        this.camera.radius -= pinchDelta * this.camera.radius;
      }
    } else {
      if (this.axisPinchControlRotation) {
        this.camera.rotationOffset += pinchDelta;
      }
      if (this.axisPinchControlHeight) {
        this.camera.heightOffset += pinchDelta;
      }
      if (this.axisPinchControlRadius) {
        this.camera.radius -= pinchDelta;
      }
    }
  };
  FollowCameraPointersInput2.prototype._warning = function() {
    if (!this.warningEnable || this._warningCounter++ % 100 !== 0) {
      return;
    }
    var warn = "It probably only makes sense to control ONE camera property with each pointer axis. Set 'warningEnable = false' if you are sure. Currently enabled: ";
    console.assert(this.axisXControlRotation + this.axisXControlHeight + this.axisXControlRadius <= 1, warn + "axisXControlRotation: " + this.axisXControlRotation + ", axisXControlHeight: " + this.axisXControlHeight + ", axisXControlRadius: " + this.axisXControlRadius);
    console.assert(this.axisYControlRotation + this.axisYControlHeight + this.axisYControlRadius <= 1, warn + "axisYControlRotation: " + this.axisYControlRotation + ", axisYControlHeight: " + this.axisYControlHeight + ", axisYControlRadius: " + this.axisYControlRadius);
    console.assert(this.axisPinchControlRotation + this.axisPinchControlHeight + this.axisPinchControlRadius <= 1, warn + "axisPinchControlRotation: " + this.axisPinchControlRotation + ", axisPinchControlHeight: " + this.axisPinchControlHeight + ", axisPinchControlRadius: " + this.axisPinchControlRadius);
  };
  __decorate([
    serialize()
  ], FollowCameraPointersInput2.prototype, "angularSensibilityX", void 0);
  __decorate([
    serialize()
  ], FollowCameraPointersInput2.prototype, "angularSensibilityY", void 0);
  __decorate([
    serialize()
  ], FollowCameraPointersInput2.prototype, "pinchPrecision", void 0);
  __decorate([
    serialize()
  ], FollowCameraPointersInput2.prototype, "pinchDeltaPercentage", void 0);
  __decorate([
    serialize()
  ], FollowCameraPointersInput2.prototype, "axisXControlRadius", void 0);
  __decorate([
    serialize()
  ], FollowCameraPointersInput2.prototype, "axisXControlHeight", void 0);
  __decorate([
    serialize()
  ], FollowCameraPointersInput2.prototype, "axisXControlRotation", void 0);
  __decorate([
    serialize()
  ], FollowCameraPointersInput2.prototype, "axisYControlRadius", void 0);
  __decorate([
    serialize()
  ], FollowCameraPointersInput2.prototype, "axisYControlHeight", void 0);
  __decorate([
    serialize()
  ], FollowCameraPointersInput2.prototype, "axisYControlRotation", void 0);
  __decorate([
    serialize()
  ], FollowCameraPointersInput2.prototype, "axisPinchControlRadius", void 0);
  __decorate([
    serialize()
  ], FollowCameraPointersInput2.prototype, "axisPinchControlHeight", void 0);
  __decorate([
    serialize()
  ], FollowCameraPointersInput2.prototype, "axisPinchControlRotation", void 0);
  return FollowCameraPointersInput2;
}(BaseCameraPointersInput);
CameraInputTypes["FollowCameraPointersInput"] = FollowCameraPointersInput;

// node_modules/@babylonjs/core/Cameras/Inputs/freeCameraDeviceOrientationInput.js
FreeCameraInputsManager.prototype.addDeviceOrientation = function() {
  if (!this._deviceOrientationInput) {
    this._deviceOrientationInput = new FreeCameraDeviceOrientationInput();
    this.add(this._deviceOrientationInput);
  }
  return this;
};
var FreeCameraDeviceOrientationInput = function() {
  function FreeCameraDeviceOrientationInput2() {
    var _this = this;
    this._screenOrientationAngle = 0;
    this._screenQuaternion = new Quaternion();
    this._alpha = 0;
    this._beta = 0;
    this._gamma = 0;
    this._onDeviceOrientationChangedObservable = new Observable();
    this._orientationChanged = function() {
      _this._screenOrientationAngle = window.orientation !== void 0 ? +window.orientation : window.screen.orientation && window.screen.orientation["angle"] ? window.screen.orientation.angle : 0;
      _this._screenOrientationAngle = -Tools.ToRadians(_this._screenOrientationAngle / 2);
      _this._screenQuaternion.copyFromFloats(0, Math.sin(_this._screenOrientationAngle), 0, Math.cos(_this._screenOrientationAngle));
    };
    this._deviceOrientation = function(evt) {
      _this._alpha = evt.alpha !== null ? evt.alpha : 0;
      _this._beta = evt.beta !== null ? evt.beta : 0;
      _this._gamma = evt.gamma !== null ? evt.gamma : 0;
      if (evt.alpha !== null) {
        _this._onDeviceOrientationChangedObservable.notifyObservers();
      }
    };
    this._constantTranform = new Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));
    this._orientationChanged();
  }
  FreeCameraDeviceOrientationInput2.WaitForOrientationChangeAsync = function(timeout) {
    return new Promise(function(res, rej) {
      var gotValue = false;
      var eventHandler = function() {
        window.removeEventListener("deviceorientation", eventHandler);
        gotValue = true;
        res();
      };
      if (timeout) {
        setTimeout(function() {
          if (!gotValue) {
            window.removeEventListener("deviceorientation", eventHandler);
            rej("WaitForOrientationChangeAsync timed out");
          }
        }, timeout);
      }
      if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
        DeviceOrientationEvent.requestPermission().then(function(response) {
          if (response == "granted") {
            window.addEventListener("deviceorientation", eventHandler);
          } else {
            Tools.Warn("Permission not granted.");
          }
        }).catch(function(error) {
          Tools.Error(error);
        });
      } else {
        window.addEventListener("deviceorientation", eventHandler);
      }
    });
  };
  Object.defineProperty(FreeCameraDeviceOrientationInput2.prototype, "camera", {
    get: function() {
      return this._camera;
    },
    set: function(camera) {
      var _this = this;
      this._camera = camera;
      if (this._camera != null && !this._camera.rotationQuaternion) {
        this._camera.rotationQuaternion = new Quaternion();
      }
      if (this._camera) {
        this._camera.onDisposeObservable.add(function() {
          _this._onDeviceOrientationChangedObservable.clear();
        });
      }
    },
    enumerable: false,
    configurable: true
  });
  FreeCameraDeviceOrientationInput2.prototype.attachControl = function() {
    var _this = this;
    var hostWindow = this.camera.getScene().getEngine().getHostWindow();
    if (hostWindow) {
      var eventHandler_1 = function() {
        hostWindow.addEventListener("orientationchange", _this._orientationChanged);
        hostWindow.addEventListener("deviceorientation", _this._deviceOrientation);
        _this._orientationChanged();
      };
      if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
        DeviceOrientationEvent.requestPermission().then(function(response) {
          if (response === "granted") {
            eventHandler_1();
          } else {
            Tools.Warn("Permission not granted.");
          }
        }).catch(function(error) {
          Tools.Error(error);
        });
      } else {
        eventHandler_1();
      }
    }
  };
  FreeCameraDeviceOrientationInput2.prototype.detachControl = function(ignored) {
    window.removeEventListener("orientationchange", this._orientationChanged);
    window.removeEventListener("deviceorientation", this._deviceOrientation);
    this._alpha = 0;
  };
  FreeCameraDeviceOrientationInput2.prototype.checkInputs = function() {
    if (!this._alpha) {
      return;
    }
    Quaternion.RotationYawPitchRollToRef(Tools.ToRadians(this._alpha), Tools.ToRadians(this._beta), -Tools.ToRadians(this._gamma), this.camera.rotationQuaternion);
    this._camera.rotationQuaternion.multiplyInPlace(this._screenQuaternion);
    this._camera.rotationQuaternion.multiplyInPlace(this._constantTranform);
    this._camera.rotationQuaternion.z *= -1;
    this._camera.rotationQuaternion.w *= -1;
  };
  FreeCameraDeviceOrientationInput2.prototype.getClassName = function() {
    return "FreeCameraDeviceOrientationInput";
  };
  FreeCameraDeviceOrientationInput2.prototype.getSimpleName = function() {
    return "deviceOrientation";
  };
  return FreeCameraDeviceOrientationInput2;
}();
CameraInputTypes["FreeCameraDeviceOrientationInput"] = FreeCameraDeviceOrientationInput;

// node_modules/@babylonjs/core/Cameras/Inputs/freeCameraGamepadInput.js
var FreeCameraGamepadInput = function() {
  function FreeCameraGamepadInput2() {
    this.gamepadAngularSensibility = 200;
    this.gamepadMoveSensibility = 40;
    this._yAxisScale = 1;
    this._cameraTransform = Matrix.Identity();
    this._deltaTransform = Vector3.Zero();
    this._vector3 = Vector3.Zero();
    this._vector2 = Vector2.Zero();
  }
  Object.defineProperty(FreeCameraGamepadInput2.prototype, "invertYAxis", {
    get: function() {
      return this._yAxisScale !== 1;
    },
    set: function(value) {
      this._yAxisScale = value ? -1 : 1;
    },
    enumerable: false,
    configurable: true
  });
  FreeCameraGamepadInput2.prototype.attachControl = function() {
    var _this = this;
    var manager = this.camera.getScene().gamepadManager;
    this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add(function(gamepad) {
      if (gamepad.type !== Gamepad.POSE_ENABLED) {
        if (!_this.gamepad || gamepad.type === Gamepad.XBOX) {
          _this.gamepad = gamepad;
        }
      }
    });
    this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add(function(gamepad) {
      if (_this.gamepad === gamepad) {
        _this.gamepad = null;
      }
    });
    this.gamepad = manager.getGamepadByType(Gamepad.XBOX);
    if (!this.gamepad && manager.gamepads.length) {
      this.gamepad = manager.gamepads[0];
    }
  };
  FreeCameraGamepadInput2.prototype.detachControl = function(ignored) {
    this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);
    this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);
    this.gamepad = null;
  };
  FreeCameraGamepadInput2.prototype.checkInputs = function() {
    if (this.gamepad && this.gamepad.leftStick) {
      var camera = this.camera;
      var LSValues = this.gamepad.leftStick;
      var normalizedLX = LSValues.x / this.gamepadMoveSensibility;
      var normalizedLY = LSValues.y / this.gamepadMoveSensibility;
      LSValues.x = Math.abs(normalizedLX) > 5e-3 ? 0 + normalizedLX : 0;
      LSValues.y = Math.abs(normalizedLY) > 5e-3 ? 0 + normalizedLY : 0;
      var RSValues = this.gamepad.rightStick;
      if (RSValues) {
        var normalizedRX = RSValues.x / this.gamepadAngularSensibility;
        var normalizedRY = RSValues.y / this.gamepadAngularSensibility * this._yAxisScale;
        RSValues.x = Math.abs(normalizedRX) > 1e-3 ? 0 + normalizedRX : 0;
        RSValues.y = Math.abs(normalizedRY) > 1e-3 ? 0 + normalizedRY : 0;
      } else {
        RSValues = { x: 0, y: 0 };
      }
      if (!camera.rotationQuaternion) {
        Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, this._cameraTransform);
      } else {
        camera.rotationQuaternion.toRotationMatrix(this._cameraTransform);
      }
      var speed = camera._computeLocalCameraSpeed() * 50;
      this._vector3.copyFromFloats(LSValues.x * speed, 0, -LSValues.y * speed);
      Vector3.TransformCoordinatesToRef(this._vector3, this._cameraTransform, this._deltaTransform);
      camera.cameraDirection.addInPlace(this._deltaTransform);
      this._vector2.copyFromFloats(RSValues.y, RSValues.x);
      camera.cameraRotation.addInPlace(this._vector2);
    }
  };
  FreeCameraGamepadInput2.prototype.getClassName = function() {
    return "FreeCameraGamepadInput";
  };
  FreeCameraGamepadInput2.prototype.getSimpleName = function() {
    return "gamepad";
  };
  __decorate([
    serialize()
  ], FreeCameraGamepadInput2.prototype, "gamepadAngularSensibility", void 0);
  __decorate([
    serialize()
  ], FreeCameraGamepadInput2.prototype, "gamepadMoveSensibility", void 0);
  return FreeCameraGamepadInput2;
}();
CameraInputTypes["FreeCameraGamepadInput"] = FreeCameraGamepadInput;

// node_modules/@babylonjs/core/Misc/virtualJoystick.js
var JoystickAxis;
(function(JoystickAxis2) {
  JoystickAxis2[JoystickAxis2["X"] = 0] = "X";
  JoystickAxis2[JoystickAxis2["Y"] = 1] = "Y";
  JoystickAxis2[JoystickAxis2["Z"] = 2] = "Z";
})(JoystickAxis || (JoystickAxis = {}));
var VirtualJoystick = function() {
  function VirtualJoystick2(leftJoystick, customizations) {
    var _this = this;
    var options = __assign(__assign({}, VirtualJoystick2._GetDefaultOptions()), customizations);
    if (leftJoystick) {
      this._leftJoystick = true;
    } else {
      this._leftJoystick = false;
    }
    VirtualJoystick2._globalJoystickIndex++;
    this._axisTargetedByLeftAndRight = JoystickAxis.X;
    this._axisTargetedByUpAndDown = JoystickAxis.Y;
    this.reverseLeftRight = false;
    this.reverseUpDown = false;
    this._touches = new StringDictionary();
    this.deltaPosition = Vector3.Zero();
    this._joystickSensibility = 25;
    this._inversedSensibility = 1 / (this._joystickSensibility / 1e3);
    this._onResize = function(evt) {
      VirtualJoystick2.vjCanvasWidth = window.innerWidth;
      VirtualJoystick2.vjCanvasHeight = window.innerHeight;
      if (VirtualJoystick2.Canvas) {
        VirtualJoystick2.Canvas.width = VirtualJoystick2.vjCanvasWidth;
        VirtualJoystick2.Canvas.height = VirtualJoystick2.vjCanvasHeight;
      }
      VirtualJoystick2.halfWidth = VirtualJoystick2.vjCanvasWidth / 2;
    };
    if (!VirtualJoystick2.Canvas) {
      window.addEventListener("resize", this._onResize, false);
      VirtualJoystick2.Canvas = document.createElement("canvas");
      VirtualJoystick2.vjCanvasWidth = window.innerWidth;
      VirtualJoystick2.vjCanvasHeight = window.innerHeight;
      VirtualJoystick2.Canvas.width = window.innerWidth;
      VirtualJoystick2.Canvas.height = window.innerHeight;
      VirtualJoystick2.Canvas.style.width = "100%";
      VirtualJoystick2.Canvas.style.height = "100%";
      VirtualJoystick2.Canvas.style.position = "absolute";
      VirtualJoystick2.Canvas.style.backgroundColor = "transparent";
      VirtualJoystick2.Canvas.style.top = "0px";
      VirtualJoystick2.Canvas.style.left = "0px";
      VirtualJoystick2.Canvas.style.zIndex = "5";
      VirtualJoystick2.Canvas.style.msTouchAction = "none";
      VirtualJoystick2.Canvas.style.touchAction = "none";
      VirtualJoystick2.Canvas.setAttribute("touch-action", "none");
      var context = VirtualJoystick2.Canvas.getContext("2d");
      if (!context) {
        throw new Error("Unable to create canvas for virtual joystick");
      }
      VirtualJoystick2.vjCanvasContext = context;
      VirtualJoystick2.vjCanvasContext.strokeStyle = "#ffffff";
      VirtualJoystick2.vjCanvasContext.lineWidth = 2;
      document.body.appendChild(VirtualJoystick2.Canvas);
    }
    VirtualJoystick2.halfWidth = VirtualJoystick2.Canvas.width / 2;
    this.pressed = false;
    this.limitToContainer = options.limitToContainer;
    this._joystickColor = options.color;
    this.containerSize = options.containerSize;
    this.puckSize = options.puckSize;
    if (options.position) {
      this.setPosition(options.position.x, options.position.y);
    }
    if (options.puckImage) {
      this.setPuckImage(options.puckImage);
    }
    if (options.containerImage) {
      this.setContainerImage(options.containerImage);
    }
    if (options.alwaysVisible) {
      VirtualJoystick2._alwaysVisibleSticks++;
    }
    this.alwaysVisible = options.alwaysVisible;
    this._joystickPointerID = -1;
    this._joystickPointerPos = new Vector2(0, 0);
    this._joystickPreviousPointerPos = new Vector2(0, 0);
    this._joystickPointerStartPos = new Vector2(0, 0);
    this._deltaJoystickVector = new Vector2(0, 0);
    this._onPointerDownHandlerRef = function(evt) {
      _this._onPointerDown(evt);
    };
    this._onPointerMoveHandlerRef = function(evt) {
      _this._onPointerMove(evt);
    };
    this._onPointerUpHandlerRef = function(evt) {
      _this._onPointerUp(evt);
    };
    VirtualJoystick2.Canvas.addEventListener("pointerdown", this._onPointerDownHandlerRef, false);
    VirtualJoystick2.Canvas.addEventListener("pointermove", this._onPointerMoveHandlerRef, false);
    VirtualJoystick2.Canvas.addEventListener("pointerup", this._onPointerUpHandlerRef, false);
    VirtualJoystick2.Canvas.addEventListener("pointerout", this._onPointerUpHandlerRef, false);
    VirtualJoystick2.Canvas.addEventListener("contextmenu", function(evt) {
      evt.preventDefault();
    }, false);
    requestAnimationFrame(function() {
      _this._drawVirtualJoystick();
    });
  }
  VirtualJoystick2._GetDefaultOptions = function() {
    return {
      puckSize: 40,
      containerSize: 60,
      color: "cyan",
      puckImage: void 0,
      containerImage: void 0,
      position: void 0,
      alwaysVisible: false,
      limitToContainer: false
    };
  };
  VirtualJoystick2.prototype.setJoystickSensibility = function(newJoystickSensibility) {
    this._joystickSensibility = newJoystickSensibility;
    this._inversedSensibility = 1 / (this._joystickSensibility / 1e3);
  };
  VirtualJoystick2.prototype._onPointerDown = function(e) {
    var positionOnScreenCondition;
    e.preventDefault();
    if (this._leftJoystick === true) {
      positionOnScreenCondition = e.clientX < VirtualJoystick2.halfWidth;
    } else {
      positionOnScreenCondition = e.clientX > VirtualJoystick2.halfWidth;
    }
    if (positionOnScreenCondition && this._joystickPointerID < 0) {
      this._joystickPointerID = e.pointerId;
      if (this._joystickPosition) {
        this._joystickPointerStartPos = this._joystickPosition.clone();
        this._joystickPointerPos = this._joystickPosition.clone();
        this._joystickPreviousPointerPos = this._joystickPosition.clone();
        this._onPointerMove(e);
      } else {
        this._joystickPointerStartPos.x = e.clientX;
        this._joystickPointerStartPos.y = e.clientY;
        this._joystickPointerPos = this._joystickPointerStartPos.clone();
        this._joystickPreviousPointerPos = this._joystickPointerStartPos.clone();
      }
      this._deltaJoystickVector.x = 0;
      this._deltaJoystickVector.y = 0;
      this.pressed = true;
      this._touches.add(e.pointerId.toString(), e);
    } else {
      if (VirtualJoystick2._globalJoystickIndex < 2 && this._action) {
        this._action();
        this._touches.add(e.pointerId.toString(), { x: e.clientX, y: e.clientY, prevX: e.clientX, prevY: e.clientY });
      }
    }
  };
  VirtualJoystick2.prototype._onPointerMove = function(e) {
    if (this._joystickPointerID == e.pointerId) {
      if (this.limitToContainer) {
        var vector = new Vector2(e.clientX - this._joystickPointerStartPos.x, e.clientY - this._joystickPointerStartPos.y);
        var distance = vector.length();
        if (distance > this.containerSize) {
          vector.scaleInPlace(this.containerSize / distance);
        }
        this._joystickPointerPos.x = this._joystickPointerStartPos.x + vector.x;
        this._joystickPointerPos.y = this._joystickPointerStartPos.y + vector.y;
      } else {
        this._joystickPointerPos.x = e.clientX;
        this._joystickPointerPos.y = e.clientY;
      }
      this._deltaJoystickVector = this._joystickPointerPos.clone();
      this._deltaJoystickVector = this._deltaJoystickVector.subtract(this._joystickPointerStartPos);
      if (0 < VirtualJoystick2._alwaysVisibleSticks) {
        if (this._leftJoystick) {
          this._joystickPointerPos.x = Math.min(VirtualJoystick2.halfWidth, this._joystickPointerPos.x);
        } else {
          this._joystickPointerPos.x = Math.max(VirtualJoystick2.halfWidth, this._joystickPointerPos.x);
        }
      }
      var directionLeftRight = this.reverseLeftRight ? -1 : 1;
      var deltaJoystickX = directionLeftRight * this._deltaJoystickVector.x / this._inversedSensibility;
      switch (this._axisTargetedByLeftAndRight) {
        case JoystickAxis.X:
          this.deltaPosition.x = Math.min(1, Math.max(-1, deltaJoystickX));
          break;
        case JoystickAxis.Y:
          this.deltaPosition.y = Math.min(1, Math.max(-1, deltaJoystickX));
          break;
        case JoystickAxis.Z:
          this.deltaPosition.z = Math.min(1, Math.max(-1, deltaJoystickX));
          break;
      }
      var directionUpDown = this.reverseUpDown ? 1 : -1;
      var deltaJoystickY = directionUpDown * this._deltaJoystickVector.y / this._inversedSensibility;
      switch (this._axisTargetedByUpAndDown) {
        case JoystickAxis.X:
          this.deltaPosition.x = Math.min(1, Math.max(-1, deltaJoystickY));
          break;
        case JoystickAxis.Y:
          this.deltaPosition.y = Math.min(1, Math.max(-1, deltaJoystickY));
          break;
        case JoystickAxis.Z:
          this.deltaPosition.z = Math.min(1, Math.max(-1, deltaJoystickY));
          break;
      }
    } else {
      var data = this._touches.get(e.pointerId.toString());
      if (data) {
        data.x = e.clientX;
        data.y = e.clientY;
      }
    }
  };
  VirtualJoystick2.prototype._onPointerUp = function(e) {
    if (this._joystickPointerID == e.pointerId) {
      this._clearPreviousDraw();
      this._joystickPointerID = -1;
      this.pressed = false;
    } else {
      var touch = this._touches.get(e.pointerId.toString());
      if (touch) {
        VirtualJoystick2.vjCanvasContext.clearRect(touch.prevX - 44, touch.prevY - 44, 88, 88);
      }
    }
    this._deltaJoystickVector.x = 0;
    this._deltaJoystickVector.y = 0;
    this._touches.remove(e.pointerId.toString());
  };
  VirtualJoystick2.prototype.setJoystickColor = function(newColor) {
    this._joystickColor = newColor;
  };
  Object.defineProperty(VirtualJoystick2.prototype, "containerSize", {
    get: function() {
      return this._joystickContainerSize;
    },
    set: function(newSize) {
      this._joystickContainerSize = newSize;
      this._clearContainerSize = ~~(this._joystickContainerSize * 2.1);
      this._clearContainerSizeOffset = ~~(this._clearContainerSize / 2);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VirtualJoystick2.prototype, "puckSize", {
    get: function() {
      return this._joystickPuckSize;
    },
    set: function(newSize) {
      this._joystickPuckSize = newSize;
      this._clearPuckSize = ~~(this._joystickPuckSize * 2.1);
      this._clearPuckSizeOffset = ~~(this._clearPuckSize / 2);
    },
    enumerable: false,
    configurable: true
  });
  VirtualJoystick2.prototype.clearPosition = function() {
    this.alwaysVisible = false;
    this._joystickPosition = null;
  };
  Object.defineProperty(VirtualJoystick2.prototype, "alwaysVisible", {
    get: function() {
      return this._alwaysVisible;
    },
    set: function(value) {
      if (this._alwaysVisible === value) {
        return;
      }
      if (value && this._joystickPosition) {
        VirtualJoystick2._alwaysVisibleSticks++;
        this._alwaysVisible = true;
      } else {
        VirtualJoystick2._alwaysVisibleSticks--;
        this._alwaysVisible = false;
      }
    },
    enumerable: false,
    configurable: true
  });
  VirtualJoystick2.prototype.setPosition = function(x, y) {
    if (this._joystickPointerStartPos) {
      this._clearPreviousDraw();
    }
    this._joystickPosition = new Vector2(x, y);
  };
  VirtualJoystick2.prototype.setActionOnTouch = function(action) {
    this._action = action;
  };
  VirtualJoystick2.prototype.setAxisForLeftRight = function(axis) {
    switch (axis) {
      case JoystickAxis.X:
      case JoystickAxis.Y:
      case JoystickAxis.Z:
        this._axisTargetedByLeftAndRight = axis;
        break;
      default:
        this._axisTargetedByLeftAndRight = JoystickAxis.X;
        break;
    }
  };
  VirtualJoystick2.prototype.setAxisForUpDown = function(axis) {
    switch (axis) {
      case JoystickAxis.X:
      case JoystickAxis.Y:
      case JoystickAxis.Z:
        this._axisTargetedByUpAndDown = axis;
        break;
      default:
        this._axisTargetedByUpAndDown = JoystickAxis.Y;
        break;
    }
  };
  VirtualJoystick2.prototype._clearPreviousDraw = function() {
    var jp = this._joystickPosition || this._joystickPointerStartPos;
    VirtualJoystick2.vjCanvasContext.clearRect(jp.x - this._clearContainerSizeOffset, jp.y - this._clearContainerSizeOffset, this._clearContainerSize, this._clearContainerSize);
    VirtualJoystick2.vjCanvasContext.clearRect(this._joystickPreviousPointerPos.x - this._clearPuckSizeOffset, this._joystickPreviousPointerPos.y - this._clearPuckSizeOffset, this._clearPuckSize, this._clearPuckSize);
  };
  VirtualJoystick2.prototype.setContainerImage = function(urlPath) {
    var _this = this;
    var image = new Image();
    image.src = urlPath;
    image.onload = function() {
      return _this._containerImage = image;
    };
  };
  VirtualJoystick2.prototype.setPuckImage = function(urlPath) {
    var _this = this;
    var image = new Image();
    image.src = urlPath;
    image.onload = function() {
      return _this._puckImage = image;
    };
  };
  VirtualJoystick2.prototype._drawContainer = function() {
    var jp = this._joystickPosition || this._joystickPointerStartPos;
    this._clearPreviousDraw();
    if (this._containerImage) {
      VirtualJoystick2.vjCanvasContext.drawImage(this._containerImage, jp.x - this.containerSize, jp.y - this.containerSize, this.containerSize * 2, this.containerSize * 2);
    } else {
      VirtualJoystick2.vjCanvasContext.beginPath();
      VirtualJoystick2.vjCanvasContext.strokeStyle = this._joystickColor;
      VirtualJoystick2.vjCanvasContext.lineWidth = 2;
      VirtualJoystick2.vjCanvasContext.arc(jp.x, jp.y, this.containerSize, 0, Math.PI * 2, true);
      VirtualJoystick2.vjCanvasContext.stroke();
      VirtualJoystick2.vjCanvasContext.closePath();
      VirtualJoystick2.vjCanvasContext.beginPath();
      VirtualJoystick2.vjCanvasContext.lineWidth = 6;
      VirtualJoystick2.vjCanvasContext.strokeStyle = this._joystickColor;
      VirtualJoystick2.vjCanvasContext.arc(jp.x, jp.y, this.puckSize, 0, Math.PI * 2, true);
      VirtualJoystick2.vjCanvasContext.stroke();
      VirtualJoystick2.vjCanvasContext.closePath();
    }
  };
  VirtualJoystick2.prototype._drawPuck = function() {
    if (this._puckImage) {
      VirtualJoystick2.vjCanvasContext.drawImage(this._puckImage, this._joystickPointerPos.x - this.puckSize, this._joystickPointerPos.y - this.puckSize, this.puckSize * 2, this.puckSize * 2);
    } else {
      VirtualJoystick2.vjCanvasContext.beginPath();
      VirtualJoystick2.vjCanvasContext.strokeStyle = this._joystickColor;
      VirtualJoystick2.vjCanvasContext.lineWidth = 2;
      VirtualJoystick2.vjCanvasContext.arc(this._joystickPointerPos.x, this._joystickPointerPos.y, this.puckSize, 0, Math.PI * 2, true);
      VirtualJoystick2.vjCanvasContext.stroke();
      VirtualJoystick2.vjCanvasContext.closePath();
    }
  };
  VirtualJoystick2.prototype._drawVirtualJoystick = function() {
    var _this = this;
    if (this.alwaysVisible) {
      this._drawContainer();
    }
    if (this.pressed) {
      this._touches.forEach(function(key, touch) {
        if (touch.pointerId === _this._joystickPointerID) {
          if (!_this.alwaysVisible) {
            _this._drawContainer();
          }
          _this._drawPuck();
          _this._joystickPreviousPointerPos = _this._joystickPointerPos.clone();
        } else {
          VirtualJoystick2.vjCanvasContext.clearRect(touch.prevX - 44, touch.prevY - 44, 88, 88);
          VirtualJoystick2.vjCanvasContext.beginPath();
          VirtualJoystick2.vjCanvasContext.fillStyle = "white";
          VirtualJoystick2.vjCanvasContext.beginPath();
          VirtualJoystick2.vjCanvasContext.strokeStyle = "red";
          VirtualJoystick2.vjCanvasContext.lineWidth = 6;
          VirtualJoystick2.vjCanvasContext.arc(touch.x, touch.y, 40, 0, Math.PI * 2, true);
          VirtualJoystick2.vjCanvasContext.stroke();
          VirtualJoystick2.vjCanvasContext.closePath();
          touch.prevX = touch.x;
          touch.prevY = touch.y;
        }
      });
    }
    requestAnimationFrame(function() {
      _this._drawVirtualJoystick();
    });
  };
  VirtualJoystick2.prototype.releaseCanvas = function() {
    if (VirtualJoystick2.Canvas) {
      VirtualJoystick2.Canvas.removeEventListener("pointerdown", this._onPointerDownHandlerRef);
      VirtualJoystick2.Canvas.removeEventListener("pointermove", this._onPointerMoveHandlerRef);
      VirtualJoystick2.Canvas.removeEventListener("pointerup", this._onPointerUpHandlerRef);
      VirtualJoystick2.Canvas.removeEventListener("pointerout", this._onPointerUpHandlerRef);
      window.removeEventListener("resize", this._onResize);
      document.body.removeChild(VirtualJoystick2.Canvas);
      VirtualJoystick2.Canvas = null;
    }
  };
  VirtualJoystick2._globalJoystickIndex = 0;
  VirtualJoystick2._alwaysVisibleSticks = 0;
  return VirtualJoystick2;
}();

// node_modules/@babylonjs/core/Cameras/Inputs/freeCameraVirtualJoystickInput.js
FreeCameraInputsManager.prototype.addVirtualJoystick = function() {
  this.add(new FreeCameraVirtualJoystickInput());
  return this;
};
var FreeCameraVirtualJoystickInput = function() {
  function FreeCameraVirtualJoystickInput2() {
  }
  FreeCameraVirtualJoystickInput2.prototype.getLeftJoystick = function() {
    return this._leftjoystick;
  };
  FreeCameraVirtualJoystickInput2.prototype.getRightJoystick = function() {
    return this._rightjoystick;
  };
  FreeCameraVirtualJoystickInput2.prototype.checkInputs = function() {
    if (this._leftjoystick) {
      var camera = this.camera;
      var speed = camera._computeLocalCameraSpeed() * 50;
      var cameraTransform = Matrix.RotationYawPitchRoll(camera.rotation.y, camera.rotation.x, 0);
      var deltaTransform = Vector3.TransformCoordinates(new Vector3(this._leftjoystick.deltaPosition.x * speed, this._leftjoystick.deltaPosition.y * speed, this._leftjoystick.deltaPosition.z * speed), cameraTransform);
      camera.cameraDirection = camera.cameraDirection.add(deltaTransform);
      camera.cameraRotation = camera.cameraRotation.addVector3(this._rightjoystick.deltaPosition);
      if (!this._leftjoystick.pressed) {
        this._leftjoystick.deltaPosition = this._leftjoystick.deltaPosition.scale(0.9);
      }
      if (!this._rightjoystick.pressed) {
        this._rightjoystick.deltaPosition = this._rightjoystick.deltaPosition.scale(0.9);
      }
    }
  };
  FreeCameraVirtualJoystickInput2.prototype.attachControl = function() {
    this._leftjoystick = new VirtualJoystick(true);
    this._leftjoystick.setAxisForUpDown(JoystickAxis.Z);
    this._leftjoystick.setAxisForLeftRight(JoystickAxis.X);
    this._leftjoystick.setJoystickSensibility(0.15);
    this._rightjoystick = new VirtualJoystick(false);
    this._rightjoystick.setAxisForUpDown(JoystickAxis.X);
    this._rightjoystick.setAxisForLeftRight(JoystickAxis.Y);
    this._rightjoystick.reverseUpDown = true;
    this._rightjoystick.setJoystickSensibility(0.05);
    this._rightjoystick.setJoystickColor("yellow");
  };
  FreeCameraVirtualJoystickInput2.prototype.detachControl = function(ignored) {
    this._leftjoystick.releaseCanvas();
    this._rightjoystick.releaseCanvas();
  };
  FreeCameraVirtualJoystickInput2.prototype.getClassName = function() {
    return "FreeCameraVirtualJoystickInput";
  };
  FreeCameraVirtualJoystickInput2.prototype.getSimpleName = function() {
    return "virtualJoystick";
  };
  return FreeCameraVirtualJoystickInput2;
}();
CameraInputTypes["FreeCameraVirtualJoystickInput"] = FreeCameraVirtualJoystickInput;

// node_modules/@babylonjs/core/Cameras/touchCamera.js
Node2.AddNodeConstructor("TouchCamera", function(name98, scene) {
  return function() {
    return new TouchCamera(name98, Vector3.Zero(), scene);
  };
});
var TouchCamera = function(_super) {
  __extends(TouchCamera2, _super);
  function TouchCamera2(name98, position, scene) {
    var _this = _super.call(this, name98, position, scene) || this;
    _this.inputs.addTouch();
    _this._setupInputs();
    return _this;
  }
  Object.defineProperty(TouchCamera2.prototype, "touchAngularSensibility", {
    get: function() {
      var touch = this.inputs.attached["touch"];
      if (touch) {
        return touch.touchAngularSensibility;
      }
      return 0;
    },
    set: function(value) {
      var touch = this.inputs.attached["touch"];
      if (touch) {
        touch.touchAngularSensibility = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TouchCamera2.prototype, "touchMoveSensibility", {
    get: function() {
      var touch = this.inputs.attached["touch"];
      if (touch) {
        return touch.touchMoveSensibility;
      }
      return 0;
    },
    set: function(value) {
      var touch = this.inputs.attached["touch"];
      if (touch) {
        touch.touchMoveSensibility = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  TouchCamera2.prototype.getClassName = function() {
    return "TouchCamera";
  };
  TouchCamera2.prototype._setupInputs = function() {
    var touch = this.inputs.attached["touch"];
    var mouse = this.inputs.attached["mouse"];
    if (mouse) {
      mouse.touchEnabled = false;
    } else {
      touch.allowMouse = true;
    }
  };
  return TouchCamera2;
}(FreeCamera);

// node_modules/@babylonjs/core/Cameras/arcRotateCamera.js
Node2.AddNodeConstructor("ArcRotateCamera", function(name98, scene) {
  return function() {
    return new ArcRotateCamera(name98, 0, 0, 1, Vector3.Zero(), scene);
  };
});
var ArcRotateCamera = function(_super) {
  __extends(ArcRotateCamera2, _super);
  function ArcRotateCamera2(name98, alpha, beta, radius, target, scene, setActiveOnSceneIfNoneActive) {
    if (setActiveOnSceneIfNoneActive === void 0) {
      setActiveOnSceneIfNoneActive = true;
    }
    var _this = _super.call(this, name98, Vector3.Zero(), scene, setActiveOnSceneIfNoneActive) || this;
    _this.inertialAlphaOffset = 0;
    _this.inertialBetaOffset = 0;
    _this.inertialRadiusOffset = 0;
    _this.lowerAlphaLimit = null;
    _this.upperAlphaLimit = null;
    _this.lowerBetaLimit = 0.01;
    _this.upperBetaLimit = Math.PI - 0.01;
    _this.lowerRadiusLimit = null;
    _this.upperRadiusLimit = null;
    _this.inertialPanningX = 0;
    _this.inertialPanningY = 0;
    _this.pinchToPanMaxDistance = 20;
    _this.panningDistanceLimit = null;
    _this.panningOriginTarget = Vector3.Zero();
    _this.panningInertia = 0.9;
    _this.zoomOnFactor = 1;
    _this.targetScreenOffset = Vector2.Zero();
    _this.allowUpsideDown = true;
    _this.useInputToRestoreState = true;
    _this._viewMatrix = new Matrix();
    _this.panningAxis = new Vector3(1, 1, 0);
    _this.onMeshTargetChangedObservable = new Observable();
    _this.checkCollisions = false;
    _this.collisionRadius = new Vector3(0.5, 0.5, 0.5);
    _this._previousPosition = Vector3.Zero();
    _this._collisionVelocity = Vector3.Zero();
    _this._newPosition = Vector3.Zero();
    _this._computationVector = Vector3.Zero();
    _this._onCollisionPositionChange = function(collisionId, newPosition, collidedMesh) {
      if (collidedMesh === void 0) {
        collidedMesh = null;
      }
      if (!collidedMesh) {
        _this._previousPosition.copyFrom(_this._position);
      } else {
        _this.setPosition(newPosition);
        if (_this.onCollide) {
          _this.onCollide(collidedMesh);
        }
      }
      var cosa = Math.cos(_this.alpha);
      var sina = Math.sin(_this.alpha);
      var cosb = Math.cos(_this.beta);
      var sinb = Math.sin(_this.beta);
      if (sinb === 0) {
        sinb = 1e-4;
      }
      var target2 = _this._getTargetPosition();
      _this._computationVector.copyFromFloats(_this.radius * cosa * sinb, _this.radius * cosb, _this.radius * sina * sinb);
      target2.addToRef(_this._computationVector, _this._newPosition);
      _this._position.copyFrom(_this._newPosition);
      var up = _this.upVector;
      if (_this.allowUpsideDown && _this.beta < 0) {
        up = up.clone();
        up = up.negate();
      }
      _this._computeViewMatrix(_this._position, target2, up);
      _this._viewMatrix.addAtIndex(12, _this.targetScreenOffset.x);
      _this._viewMatrix.addAtIndex(13, _this.targetScreenOffset.y);
      _this._collisionTriggered = false;
    };
    _this._target = Vector3.Zero();
    if (target) {
      _this.setTarget(target);
    }
    _this.alpha = alpha;
    _this.beta = beta;
    _this.radius = radius;
    _this.getViewMatrix();
    _this.inputs = new ArcRotateCameraInputsManager(_this);
    _this.inputs.addKeyboard().addMouseWheel().addPointers();
    return _this;
  }
  Object.defineProperty(ArcRotateCamera2.prototype, "target", {
    get: function() {
      return this._target;
    },
    set: function(value) {
      this.setTarget(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ArcRotateCamera2.prototype, "position", {
    get: function() {
      return this._position;
    },
    set: function(newPosition) {
      this.setPosition(newPosition);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ArcRotateCamera2.prototype, "upVector", {
    get: function() {
      return this._upVector;
    },
    set: function(vec) {
      if (!this._upToYMatrix) {
        this._YToUpMatrix = new Matrix();
        this._upToYMatrix = new Matrix();
        this._upVector = Vector3.Zero();
      }
      vec.normalize();
      this._upVector.copyFrom(vec);
      this.setMatUp();
    },
    enumerable: false,
    configurable: true
  });
  ArcRotateCamera2.prototype.setMatUp = function() {
    Matrix.RotationAlignToRef(Vector3.UpReadOnly, this._upVector, this._YToUpMatrix);
    Matrix.RotationAlignToRef(this._upVector, Vector3.UpReadOnly, this._upToYMatrix);
  };
  Object.defineProperty(ArcRotateCamera2.prototype, "angularSensibilityX", {
    get: function() {
      var pointers = this.inputs.attached["pointers"];
      if (pointers) {
        return pointers.angularSensibilityX;
      }
      return 0;
    },
    set: function(value) {
      var pointers = this.inputs.attached["pointers"];
      if (pointers) {
        pointers.angularSensibilityX = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ArcRotateCamera2.prototype, "angularSensibilityY", {
    get: function() {
      var pointers = this.inputs.attached["pointers"];
      if (pointers) {
        return pointers.angularSensibilityY;
      }
      return 0;
    },
    set: function(value) {
      var pointers = this.inputs.attached["pointers"];
      if (pointers) {
        pointers.angularSensibilityY = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ArcRotateCamera2.prototype, "pinchPrecision", {
    get: function() {
      var pointers = this.inputs.attached["pointers"];
      if (pointers) {
        return pointers.pinchPrecision;
      }
      return 0;
    },
    set: function(value) {
      var pointers = this.inputs.attached["pointers"];
      if (pointers) {
        pointers.pinchPrecision = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ArcRotateCamera2.prototype, "pinchDeltaPercentage", {
    get: function() {
      var pointers = this.inputs.attached["pointers"];
      if (pointers) {
        return pointers.pinchDeltaPercentage;
      }
      return 0;
    },
    set: function(value) {
      var pointers = this.inputs.attached["pointers"];
      if (pointers) {
        pointers.pinchDeltaPercentage = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ArcRotateCamera2.prototype, "useNaturalPinchZoom", {
    get: function() {
      var pointers = this.inputs.attached["pointers"];
      if (pointers) {
        return pointers.useNaturalPinchZoom;
      }
      return false;
    },
    set: function(value) {
      var pointers = this.inputs.attached["pointers"];
      if (pointers) {
        pointers.useNaturalPinchZoom = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ArcRotateCamera2.prototype, "panningSensibility", {
    get: function() {
      var pointers = this.inputs.attached["pointers"];
      if (pointers) {
        return pointers.panningSensibility;
      }
      return 0;
    },
    set: function(value) {
      var pointers = this.inputs.attached["pointers"];
      if (pointers) {
        pointers.panningSensibility = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ArcRotateCamera2.prototype, "keysUp", {
    get: function() {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        return keyboard.keysUp;
      }
      return [];
    },
    set: function(value) {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        keyboard.keysUp = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ArcRotateCamera2.prototype, "keysDown", {
    get: function() {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        return keyboard.keysDown;
      }
      return [];
    },
    set: function(value) {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        keyboard.keysDown = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ArcRotateCamera2.prototype, "keysLeft", {
    get: function() {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        return keyboard.keysLeft;
      }
      return [];
    },
    set: function(value) {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        keyboard.keysLeft = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ArcRotateCamera2.prototype, "keysRight", {
    get: function() {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        return keyboard.keysRight;
      }
      return [];
    },
    set: function(value) {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        keyboard.keysRight = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ArcRotateCamera2.prototype, "wheelPrecision", {
    get: function() {
      var mousewheel = this.inputs.attached["mousewheel"];
      if (mousewheel) {
        return mousewheel.wheelPrecision;
      }
      return 0;
    },
    set: function(value) {
      var mousewheel = this.inputs.attached["mousewheel"];
      if (mousewheel) {
        mousewheel.wheelPrecision = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ArcRotateCamera2.prototype, "wheelDeltaPercentage", {
    get: function() {
      var mousewheel = this.inputs.attached["mousewheel"];
      if (mousewheel) {
        return mousewheel.wheelDeltaPercentage;
      }
      return 0;
    },
    set: function(value) {
      var mousewheel = this.inputs.attached["mousewheel"];
      if (mousewheel) {
        mousewheel.wheelDeltaPercentage = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ArcRotateCamera2.prototype, "bouncingBehavior", {
    get: function() {
      return this._bouncingBehavior;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ArcRotateCamera2.prototype, "useBouncingBehavior", {
    get: function() {
      return this._bouncingBehavior != null;
    },
    set: function(value) {
      if (value === this.useBouncingBehavior) {
        return;
      }
      if (value) {
        this._bouncingBehavior = new BouncingBehavior();
        this.addBehavior(this._bouncingBehavior);
      } else if (this._bouncingBehavior) {
        this.removeBehavior(this._bouncingBehavior);
        this._bouncingBehavior = null;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ArcRotateCamera2.prototype, "framingBehavior", {
    get: function() {
      return this._framingBehavior;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ArcRotateCamera2.prototype, "useFramingBehavior", {
    get: function() {
      return this._framingBehavior != null;
    },
    set: function(value) {
      if (value === this.useFramingBehavior) {
        return;
      }
      if (value) {
        this._framingBehavior = new FramingBehavior();
        this.addBehavior(this._framingBehavior);
      } else if (this._framingBehavior) {
        this.removeBehavior(this._framingBehavior);
        this._framingBehavior = null;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ArcRotateCamera2.prototype, "autoRotationBehavior", {
    get: function() {
      return this._autoRotationBehavior;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ArcRotateCamera2.prototype, "useAutoRotationBehavior", {
    get: function() {
      return this._autoRotationBehavior != null;
    },
    set: function(value) {
      if (value === this.useAutoRotationBehavior) {
        return;
      }
      if (value) {
        this._autoRotationBehavior = new AutoRotationBehavior();
        this.addBehavior(this._autoRotationBehavior);
      } else if (this._autoRotationBehavior) {
        this.removeBehavior(this._autoRotationBehavior);
        this._autoRotationBehavior = null;
      }
    },
    enumerable: false,
    configurable: true
  });
  ArcRotateCamera2.prototype._initCache = function() {
    _super.prototype._initCache.call(this);
    this._cache._target = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.alpha = void 0;
    this._cache.beta = void 0;
    this._cache.radius = void 0;
    this._cache.targetScreenOffset = Vector2.Zero();
  };
  ArcRotateCamera2.prototype._updateCache = function(ignoreParentClass) {
    if (!ignoreParentClass) {
      _super.prototype._updateCache.call(this);
    }
    this._cache._target.copyFrom(this._getTargetPosition());
    this._cache.alpha = this.alpha;
    this._cache.beta = this.beta;
    this._cache.radius = this.radius;
    this._cache.targetScreenOffset.copyFrom(this.targetScreenOffset);
  };
  ArcRotateCamera2.prototype._getTargetPosition = function() {
    if (this._targetHost && this._targetHost.getAbsolutePosition) {
      var pos = this._targetHost.absolutePosition;
      if (this._targetBoundingCenter) {
        pos.addToRef(this._targetBoundingCenter, this._target);
      } else {
        this._target.copyFrom(pos);
      }
    }
    var lockedTargetPosition = this._getLockedTargetPosition();
    if (lockedTargetPosition) {
      return lockedTargetPosition;
    }
    return this._target;
  };
  ArcRotateCamera2.prototype.storeState = function() {
    this._storedAlpha = this.alpha;
    this._storedBeta = this.beta;
    this._storedRadius = this.radius;
    this._storedTarget = this._getTargetPosition().clone();
    this._storedTargetScreenOffset = this.targetScreenOffset.clone();
    return _super.prototype.storeState.call(this);
  };
  ArcRotateCamera2.prototype._restoreStateValues = function() {
    if (!_super.prototype._restoreStateValues.call(this)) {
      return false;
    }
    this.setTarget(this._storedTarget.clone());
    this.alpha = this._storedAlpha;
    this.beta = this._storedBeta;
    this.radius = this._storedRadius;
    this.targetScreenOffset = this._storedTargetScreenOffset.clone();
    this.inertialAlphaOffset = 0;
    this.inertialBetaOffset = 0;
    this.inertialRadiusOffset = 0;
    this.inertialPanningX = 0;
    this.inertialPanningY = 0;
    return true;
  };
  ArcRotateCamera2.prototype._isSynchronizedViewMatrix = function() {
    if (!_super.prototype._isSynchronizedViewMatrix.call(this)) {
      return false;
    }
    return this._cache._target.equals(this._getTargetPosition()) && this._cache.alpha === this.alpha && this._cache.beta === this.beta && this._cache.radius === this.radius && this._cache.targetScreenOffset.equals(this.targetScreenOffset);
  };
  ArcRotateCamera2.prototype.attachControl = function(ignored, noPreventDefault, useCtrlForPanning, panningMouseButton) {
    var _this = this;
    if (useCtrlForPanning === void 0) {
      useCtrlForPanning = true;
    }
    if (panningMouseButton === void 0) {
      panningMouseButton = 2;
    }
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    this._useCtrlForPanning = useCtrlForPanning;
    this._panningMouseButton = panningMouseButton;
    if (typeof arguments[0] === "boolean") {
      if (arguments.length > 1) {
        this._useCtrlForPanning = arguments[1];
      }
      if (arguments.length > 2) {
        this._panningMouseButton = arguments[2];
      }
    }
    this.inputs.attachElement(noPreventDefault);
    this._reset = function() {
      _this.inertialAlphaOffset = 0;
      _this.inertialBetaOffset = 0;
      _this.inertialRadiusOffset = 0;
      _this.inertialPanningX = 0;
      _this.inertialPanningY = 0;
    };
  };
  ArcRotateCamera2.prototype.detachControl = function(ignored) {
    this.inputs.detachElement();
    if (this._reset) {
      this._reset();
    }
  };
  ArcRotateCamera2.prototype._checkInputs = function() {
    if (this._collisionTriggered) {
      return;
    }
    this.inputs.checkInputs();
    if (this.inertialAlphaOffset !== 0 || this.inertialBetaOffset !== 0 || this.inertialRadiusOffset !== 0) {
      var inertialAlphaOffset = this.inertialAlphaOffset;
      if (this.beta <= 0) {
        inertialAlphaOffset *= -1;
      }
      if (this.getScene().useRightHandedSystem) {
        inertialAlphaOffset *= -1;
      }
      if (this.parent && this.parent._getWorldMatrixDeterminant() < 0) {
        inertialAlphaOffset *= -1;
      }
      this.alpha += inertialAlphaOffset;
      this.beta += this.inertialBetaOffset;
      this.radius -= this.inertialRadiusOffset;
      this.inertialAlphaOffset *= this.inertia;
      this.inertialBetaOffset *= this.inertia;
      this.inertialRadiusOffset *= this.inertia;
      if (Math.abs(this.inertialAlphaOffset) < Epsilon) {
        this.inertialAlphaOffset = 0;
      }
      if (Math.abs(this.inertialBetaOffset) < Epsilon) {
        this.inertialBetaOffset = 0;
      }
      if (Math.abs(this.inertialRadiusOffset) < this.speed * Epsilon) {
        this.inertialRadiusOffset = 0;
      }
    }
    if (this.inertialPanningX !== 0 || this.inertialPanningY !== 0) {
      if (!this._localDirection) {
        this._localDirection = Vector3.Zero();
        this._transformedDirection = Vector3.Zero();
      }
      this._localDirection.copyFromFloats(this.inertialPanningX, this.inertialPanningY, this.inertialPanningY);
      this._localDirection.multiplyInPlace(this.panningAxis);
      this._viewMatrix.invertToRef(this._cameraTransformMatrix);
      Vector3.TransformNormalToRef(this._localDirection, this._cameraTransformMatrix, this._transformedDirection);
      if (!this.panningAxis.y) {
        this._transformedDirection.y = 0;
      }
      if (!this._targetHost) {
        if (this.panningDistanceLimit) {
          this._transformedDirection.addInPlace(this._target);
          var distanceSquared = Vector3.DistanceSquared(this._transformedDirection, this.panningOriginTarget);
          if (distanceSquared <= this.panningDistanceLimit * this.panningDistanceLimit) {
            this._target.copyFrom(this._transformedDirection);
          }
        } else {
          this._target.addInPlace(this._transformedDirection);
        }
      }
      this.inertialPanningX *= this.panningInertia;
      this.inertialPanningY *= this.panningInertia;
      if (Math.abs(this.inertialPanningX) < this.speed * Epsilon) {
        this.inertialPanningX = 0;
      }
      if (Math.abs(this.inertialPanningY) < this.speed * Epsilon) {
        this.inertialPanningY = 0;
      }
    }
    this._checkLimits();
    _super.prototype._checkInputs.call(this);
  };
  ArcRotateCamera2.prototype._checkLimits = function() {
    if (this.lowerBetaLimit === null || this.lowerBetaLimit === void 0) {
      if (this.allowUpsideDown && this.beta > Math.PI) {
        this.beta = this.beta - 2 * Math.PI;
      }
    } else {
      if (this.beta < this.lowerBetaLimit) {
        this.beta = this.lowerBetaLimit;
      }
    }
    if (this.upperBetaLimit === null || this.upperBetaLimit === void 0) {
      if (this.allowUpsideDown && this.beta < -Math.PI) {
        this.beta = this.beta + 2 * Math.PI;
      }
    } else {
      if (this.beta > this.upperBetaLimit) {
        this.beta = this.upperBetaLimit;
      }
    }
    if (this.lowerAlphaLimit !== null && this.alpha < this.lowerAlphaLimit) {
      this.alpha = this.lowerAlphaLimit;
    }
    if (this.upperAlphaLimit !== null && this.alpha > this.upperAlphaLimit) {
      this.alpha = this.upperAlphaLimit;
    }
    if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {
      this.radius = this.lowerRadiusLimit;
      this.inertialRadiusOffset = 0;
    }
    if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {
      this.radius = this.upperRadiusLimit;
      this.inertialRadiusOffset = 0;
    }
  };
  ArcRotateCamera2.prototype.rebuildAnglesAndRadius = function() {
    this._position.subtractToRef(this._getTargetPosition(), this._computationVector);
    if (this._upVector.x !== 0 || this._upVector.y !== 1 || this._upVector.z !== 0) {
      Vector3.TransformCoordinatesToRef(this._computationVector, this._upToYMatrix, this._computationVector);
    }
    this.radius = this._computationVector.length();
    if (this.radius === 0) {
      this.radius = 1e-4;
    }
    var previousAlpha = this.alpha;
    if (this._computationVector.x === 0 && this._computationVector.z === 0) {
      this.alpha = Math.PI / 2;
    } else {
      this.alpha = Math.acos(this._computationVector.x / Math.sqrt(Math.pow(this._computationVector.x, 2) + Math.pow(this._computationVector.z, 2)));
    }
    if (this._computationVector.z < 0) {
      this.alpha = 2 * Math.PI - this.alpha;
    }
    var alphaCorrectionTurns = Math.round((previousAlpha - this.alpha) / (2 * Math.PI));
    this.alpha += alphaCorrectionTurns * 2 * Math.PI;
    this.beta = Math.acos(this._computationVector.y / this.radius);
    this._checkLimits();
  };
  ArcRotateCamera2.prototype.setPosition = function(position) {
    if (this._position.equals(position)) {
      return;
    }
    this._position.copyFrom(position);
    this.rebuildAnglesAndRadius();
  };
  ArcRotateCamera2.prototype.setTarget = function(target, toBoundingCenter, allowSamePosition) {
    if (toBoundingCenter === void 0) {
      toBoundingCenter = false;
    }
    if (allowSamePosition === void 0) {
      allowSamePosition = false;
    }
    if (target.getBoundingInfo) {
      if (toBoundingCenter) {
        this._targetBoundingCenter = target.getBoundingInfo().boundingBox.centerWorld.clone();
      } else {
        this._targetBoundingCenter = null;
      }
      target.computeWorldMatrix();
      this._targetHost = target;
      this._target = this._getTargetPosition();
      this.onMeshTargetChangedObservable.notifyObservers(this._targetHost);
    } else {
      var newTarget = target;
      var currentTarget = this._getTargetPosition();
      if (currentTarget && !allowSamePosition && currentTarget.equals(newTarget)) {
        return;
      }
      this._targetHost = null;
      this._target = newTarget;
      this._targetBoundingCenter = null;
      this.onMeshTargetChangedObservable.notifyObservers(null);
    }
    this.rebuildAnglesAndRadius();
  };
  ArcRotateCamera2.prototype._getViewMatrix = function() {
    var cosa = Math.cos(this.alpha);
    var sina = Math.sin(this.alpha);
    var cosb = Math.cos(this.beta);
    var sinb = Math.sin(this.beta);
    if (sinb === 0) {
      sinb = 1e-4;
    }
    if (this.radius === 0) {
      this.radius = 1e-4;
    }
    var target = this._getTargetPosition();
    this._computationVector.copyFromFloats(this.radius * cosa * sinb, this.radius * cosb, this.radius * sina * sinb);
    if (this._upVector.x !== 0 || this._upVector.y !== 1 || this._upVector.z !== 0) {
      Vector3.TransformCoordinatesToRef(this._computationVector, this._YToUpMatrix, this._computationVector);
    }
    target.addToRef(this._computationVector, this._newPosition);
    if (this.getScene().collisionsEnabled && this.checkCollisions) {
      var coordinator = this.getScene().collisionCoordinator;
      if (!this._collider) {
        this._collider = coordinator.createCollider();
      }
      this._collider._radius = this.collisionRadius;
      this._newPosition.subtractToRef(this._position, this._collisionVelocity);
      this._collisionTriggered = true;
      coordinator.getNewPosition(this._position, this._collisionVelocity, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);
    } else {
      this._position.copyFrom(this._newPosition);
      var up = this.upVector;
      if (this.allowUpsideDown && sinb < 0) {
        up = up.negate();
      }
      this._computeViewMatrix(this._position, target, up);
      this._viewMatrix.addAtIndex(12, this.targetScreenOffset.x);
      this._viewMatrix.addAtIndex(13, this.targetScreenOffset.y);
    }
    this._currentTarget = target;
    return this._viewMatrix;
  };
  ArcRotateCamera2.prototype.zoomOn = function(meshes, doNotUpdateMaxZ) {
    if (doNotUpdateMaxZ === void 0) {
      doNotUpdateMaxZ = false;
    }
    meshes = meshes || this.getScene().meshes;
    var minMaxVector = Mesh.MinMax(meshes);
    var distance = Vector3.Distance(minMaxVector.min, minMaxVector.max);
    this.radius = distance * this.zoomOnFactor;
    this.focusOn({ min: minMaxVector.min, max: minMaxVector.max, distance }, doNotUpdateMaxZ);
  };
  ArcRotateCamera2.prototype.focusOn = function(meshesOrMinMaxVectorAndDistance, doNotUpdateMaxZ) {
    if (doNotUpdateMaxZ === void 0) {
      doNotUpdateMaxZ = false;
    }
    var meshesOrMinMaxVector;
    var distance;
    if (meshesOrMinMaxVectorAndDistance.min === void 0) {
      var meshes = meshesOrMinMaxVectorAndDistance || this.getScene().meshes;
      meshesOrMinMaxVector = Mesh.MinMax(meshes);
      distance = Vector3.Distance(meshesOrMinMaxVector.min, meshesOrMinMaxVector.max);
    } else {
      var minMaxVectorAndDistance = meshesOrMinMaxVectorAndDistance;
      meshesOrMinMaxVector = minMaxVectorAndDistance;
      distance = minMaxVectorAndDistance.distance;
    }
    this._target = Mesh.Center(meshesOrMinMaxVector);
    if (!doNotUpdateMaxZ) {
      this.maxZ = distance * 2;
    }
  };
  ArcRotateCamera2.prototype.createRigCamera = function(name98, cameraIndex) {
    var alphaShift = 0;
    switch (this.cameraRigMode) {
      case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
      case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:
      case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:
      case Camera.RIG_MODE_VR:
        alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? 1 : -1);
        break;
      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
        alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? -1 : 1);
        break;
    }
    var rigCam = new ArcRotateCamera2(name98, this.alpha + alphaShift, this.beta, this.radius, this._target, this.getScene());
    rigCam._cameraRigParams = {};
    rigCam.isRigCamera = true;
    rigCam.rigParent = this;
    rigCam.upVector = this.upVector;
    return rigCam;
  };
  ArcRotateCamera2.prototype._updateRigCameras = function() {
    var camLeft = this._rigCameras[0];
    var camRight = this._rigCameras[1];
    camLeft.beta = camRight.beta = this.beta;
    switch (this.cameraRigMode) {
      case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
      case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:
      case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:
      case Camera.RIG_MODE_VR:
        camLeft.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;
        camRight.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;
        break;
      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
        camLeft.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;
        camRight.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;
        break;
    }
    _super.prototype._updateRigCameras.call(this);
  };
  ArcRotateCamera2.prototype.dispose = function() {
    this.inputs.clear();
    _super.prototype.dispose.call(this);
  };
  ArcRotateCamera2.prototype.getClassName = function() {
    return "ArcRotateCamera";
  };
  __decorate([
    serialize()
  ], ArcRotateCamera2.prototype, "alpha", void 0);
  __decorate([
    serialize()
  ], ArcRotateCamera2.prototype, "beta", void 0);
  __decorate([
    serialize()
  ], ArcRotateCamera2.prototype, "radius", void 0);
  __decorate([
    serializeAsVector3("target")
  ], ArcRotateCamera2.prototype, "_target", void 0);
  __decorate([
    serialize()
  ], ArcRotateCamera2.prototype, "inertialAlphaOffset", void 0);
  __decorate([
    serialize()
  ], ArcRotateCamera2.prototype, "inertialBetaOffset", void 0);
  __decorate([
    serialize()
  ], ArcRotateCamera2.prototype, "inertialRadiusOffset", void 0);
  __decorate([
    serialize()
  ], ArcRotateCamera2.prototype, "lowerAlphaLimit", void 0);
  __decorate([
    serialize()
  ], ArcRotateCamera2.prototype, "upperAlphaLimit", void 0);
  __decorate([
    serialize()
  ], ArcRotateCamera2.prototype, "lowerBetaLimit", void 0);
  __decorate([
    serialize()
  ], ArcRotateCamera2.prototype, "upperBetaLimit", void 0);
  __decorate([
    serialize()
  ], ArcRotateCamera2.prototype, "lowerRadiusLimit", void 0);
  __decorate([
    serialize()
  ], ArcRotateCamera2.prototype, "upperRadiusLimit", void 0);
  __decorate([
    serialize()
  ], ArcRotateCamera2.prototype, "inertialPanningX", void 0);
  __decorate([
    serialize()
  ], ArcRotateCamera2.prototype, "inertialPanningY", void 0);
  __decorate([
    serialize()
  ], ArcRotateCamera2.prototype, "pinchToPanMaxDistance", void 0);
  __decorate([
    serialize()
  ], ArcRotateCamera2.prototype, "panningDistanceLimit", void 0);
  __decorate([
    serializeAsVector3()
  ], ArcRotateCamera2.prototype, "panningOriginTarget", void 0);
  __decorate([
    serialize()
  ], ArcRotateCamera2.prototype, "panningInertia", void 0);
  __decorate([
    serialize()
  ], ArcRotateCamera2.prototype, "zoomOnFactor", void 0);
  __decorate([
    serialize()
  ], ArcRotateCamera2.prototype, "targetScreenOffset", void 0);
  __decorate([
    serialize()
  ], ArcRotateCamera2.prototype, "allowUpsideDown", void 0);
  __decorate([
    serialize()
  ], ArcRotateCamera2.prototype, "useInputToRestoreState", void 0);
  return ArcRotateCamera2;
}(TargetCamera);

// node_modules/@babylonjs/core/Cameras/deviceOrientationCamera.js
Node2.AddNodeConstructor("DeviceOrientationCamera", function(name98, scene) {
  return function() {
    return new DeviceOrientationCamera(name98, Vector3.Zero(), scene);
  };
});
var DeviceOrientationCamera = function(_super) {
  __extends(DeviceOrientationCamera2, _super);
  function DeviceOrientationCamera2(name98, position, scene) {
    var _this = _super.call(this, name98, position, scene) || this;
    _this._tmpDragQuaternion = new Quaternion();
    _this._disablePointerInputWhenUsingDeviceOrientation = true;
    _this._dragFactor = 0;
    _this._quaternionCache = new Quaternion();
    _this.inputs.addDeviceOrientation();
    if (_this.inputs._deviceOrientationInput) {
      _this.inputs._deviceOrientationInput._onDeviceOrientationChangedObservable.addOnce(function() {
        if (_this._disablePointerInputWhenUsingDeviceOrientation) {
          if (_this.inputs._mouseInput) {
            _this.inputs._mouseInput._allowCameraRotation = false;
            _this.inputs._mouseInput.onPointerMovedObservable.add(function(e) {
              if (_this._dragFactor != 0) {
                if (!_this._initialQuaternion) {
                  _this._initialQuaternion = new Quaternion();
                }
                Quaternion.FromEulerAnglesToRef(0, e.offsetX * _this._dragFactor, 0, _this._tmpDragQuaternion);
                _this._initialQuaternion.multiplyToRef(_this._tmpDragQuaternion, _this._initialQuaternion);
              }
            });
          }
        }
      });
    }
    return _this;
  }
  Object.defineProperty(DeviceOrientationCamera2.prototype, "disablePointerInputWhenUsingDeviceOrientation", {
    get: function() {
      return this._disablePointerInputWhenUsingDeviceOrientation;
    },
    set: function(value) {
      this._disablePointerInputWhenUsingDeviceOrientation = value;
    },
    enumerable: false,
    configurable: true
  });
  DeviceOrientationCamera2.prototype.enableHorizontalDragging = function(dragFactor) {
    if (dragFactor === void 0) {
      dragFactor = 1 / 300;
    }
    this._dragFactor = dragFactor;
  };
  DeviceOrientationCamera2.prototype.getClassName = function() {
    return "DeviceOrientationCamera";
  };
  DeviceOrientationCamera2.prototype._checkInputs = function() {
    _super.prototype._checkInputs.call(this);
    this._quaternionCache.copyFrom(this.rotationQuaternion);
    if (this._initialQuaternion) {
      this._initialQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);
    }
  };
  DeviceOrientationCamera2.prototype.resetToCurrentRotation = function(axis) {
    var _this = this;
    if (axis === void 0) {
      axis = Axis.Y;
    }
    if (!this.rotationQuaternion) {
      return;
    }
    if (!this._initialQuaternion) {
      this._initialQuaternion = new Quaternion();
    }
    this._initialQuaternion.copyFrom(this._quaternionCache || this.rotationQuaternion);
    ["x", "y", "z"].forEach(function(axisName) {
      if (!axis[axisName]) {
        _this._initialQuaternion[axisName] = 0;
      } else {
        _this._initialQuaternion[axisName] *= -1;
      }
    });
    this._initialQuaternion.normalize();
    this._initialQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);
  };
  return DeviceOrientationCamera2;
}(FreeCamera);

// node_modules/@babylonjs/core/Cameras/flyCameraInputsManager.js
var FlyCameraInputsManager = function(_super) {
  __extends(FlyCameraInputsManager2, _super);
  function FlyCameraInputsManager2(camera) {
    return _super.call(this, camera) || this;
  }
  FlyCameraInputsManager2.prototype.addKeyboard = function() {
    this.add(new FlyCameraKeyboardInput());
    return this;
  };
  FlyCameraInputsManager2.prototype.addMouse = function(touchEnabled) {
    if (touchEnabled === void 0) {
      touchEnabled = true;
    }
    this.add(new FlyCameraMouseInput(touchEnabled));
    return this;
  };
  return FlyCameraInputsManager2;
}(CameraInputsManager);

// node_modules/@babylonjs/core/Cameras/flyCamera.js
var FlyCamera = function(_super) {
  __extends(FlyCamera2, _super);
  function FlyCamera2(name98, position, scene, setActiveOnSceneIfNoneActive) {
    if (setActiveOnSceneIfNoneActive === void 0) {
      setActiveOnSceneIfNoneActive = true;
    }
    var _this = _super.call(this, name98, position, scene, setActiveOnSceneIfNoneActive) || this;
    _this.ellipsoid = new Vector3(1, 1, 1);
    _this.ellipsoidOffset = new Vector3(0, 0, 0);
    _this.checkCollisions = false;
    _this.applyGravity = false;
    _this.cameraDirection = Vector3.Zero();
    _this._trackRoll = 0;
    _this.rollCorrect = 100;
    _this.bankedTurn = false;
    _this.bankedTurnLimit = Math.PI / 2;
    _this.bankedTurnMultiplier = 1;
    _this._needMoveForGravity = false;
    _this._oldPosition = Vector3.Zero();
    _this._diffPosition = Vector3.Zero();
    _this._newPosition = Vector3.Zero();
    _this._collisionMask = -1;
    _this._onCollisionPositionChange = function(collisionId, newPosition, collidedMesh) {
      if (collidedMesh === void 0) {
        collidedMesh = null;
      }
      var updatePosition = function(newPos) {
        _this._newPosition.copyFrom(newPos);
        _this._newPosition.subtractToRef(_this._oldPosition, _this._diffPosition);
        if (_this._diffPosition.length() > Engine.CollisionsEpsilon) {
          _this.position.addInPlace(_this._diffPosition);
          if (_this.onCollide && collidedMesh) {
            _this.onCollide(collidedMesh);
          }
        }
      };
      updatePosition(newPosition);
    };
    _this.inputs = new FlyCameraInputsManager(_this);
    _this.inputs.addKeyboard().addMouse();
    return _this;
  }
  Object.defineProperty(FlyCamera2.prototype, "angularSensibility", {
    get: function() {
      var mouse = this.inputs.attached["mouse"];
      if (mouse) {
        return mouse.angularSensibility;
      }
      return 0;
    },
    set: function(value) {
      var mouse = this.inputs.attached["mouse"];
      if (mouse) {
        mouse.angularSensibility = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FlyCamera2.prototype, "keysForward", {
    get: function() {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        return keyboard.keysForward;
      }
      return [];
    },
    set: function(value) {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        keyboard.keysForward = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FlyCamera2.prototype, "keysBackward", {
    get: function() {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        return keyboard.keysBackward;
      }
      return [];
    },
    set: function(value) {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        keyboard.keysBackward = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FlyCamera2.prototype, "keysUp", {
    get: function() {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        return keyboard.keysUp;
      }
      return [];
    },
    set: function(value) {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        keyboard.keysUp = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FlyCamera2.prototype, "keysDown", {
    get: function() {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        return keyboard.keysDown;
      }
      return [];
    },
    set: function(value) {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        keyboard.keysDown = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FlyCamera2.prototype, "keysLeft", {
    get: function() {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        return keyboard.keysLeft;
      }
      return [];
    },
    set: function(value) {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        keyboard.keysLeft = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FlyCamera2.prototype, "keysRight", {
    get: function() {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        return keyboard.keysRight;
      }
      return [];
    },
    set: function(value) {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        keyboard.keysRight = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  FlyCamera2.prototype.attachControl = function(ignored, noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    this.inputs.attachElement(noPreventDefault);
  };
  FlyCamera2.prototype.detachControl = function() {
    this.inputs.detachElement();
    this.cameraDirection = new Vector3(0, 0, 0);
  };
  Object.defineProperty(FlyCamera2.prototype, "collisionMask", {
    get: function() {
      return this._collisionMask;
    },
    set: function(mask) {
      this._collisionMask = !isNaN(mask) ? mask : -1;
    },
    enumerable: false,
    configurable: true
  });
  FlyCamera2.prototype._collideWithWorld = function(displacement) {
    var globalPosition;
    if (this.parent) {
      globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());
    } else {
      globalPosition = this.position;
    }
    globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);
    this._oldPosition.addInPlace(this.ellipsoidOffset);
    var coordinator = this.getScene().collisionCoordinator;
    if (!this._collider) {
      this._collider = coordinator.createCollider();
    }
    this._collider._radius = this.ellipsoid;
    this._collider.collisionMask = this._collisionMask;
    var actualDisplacement = displacement;
    if (this.applyGravity) {
      actualDisplacement = displacement.add(this.getScene().gravity);
    }
    coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);
  };
  FlyCamera2.prototype._checkInputs = function() {
    if (!this._localDirection) {
      this._localDirection = Vector3.Zero();
      this._transformedDirection = Vector3.Zero();
    }
    this.inputs.checkInputs();
    _super.prototype._checkInputs.call(this);
  };
  FlyCamera2.prototype._decideIfNeedsToMove = function() {
    return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;
  };
  FlyCamera2.prototype._updatePosition = function() {
    if (this.checkCollisions && this.getScene().collisionsEnabled) {
      this._collideWithWorld(this.cameraDirection);
    } else {
      _super.prototype._updatePosition.call(this);
    }
  };
  FlyCamera2.prototype.restoreRoll = function(rate) {
    var limit = this._trackRoll;
    var z = this.rotation.z;
    var delta = limit - z;
    var minRad = 1e-3;
    if (Math.abs(delta) >= minRad) {
      this.rotation.z += delta / rate;
      if (Math.abs(limit - this.rotation.z) <= minRad) {
        this.rotation.z = limit;
      }
    }
  };
  FlyCamera2.prototype.dispose = function() {
    this.inputs.clear();
    _super.prototype.dispose.call(this);
  };
  FlyCamera2.prototype.getClassName = function() {
    return "FlyCamera";
  };
  __decorate([
    serializeAsVector3()
  ], FlyCamera2.prototype, "ellipsoid", void 0);
  __decorate([
    serializeAsVector3()
  ], FlyCamera2.prototype, "ellipsoidOffset", void 0);
  __decorate([
    serialize()
  ], FlyCamera2.prototype, "checkCollisions", void 0);
  __decorate([
    serialize()
  ], FlyCamera2.prototype, "applyGravity", void 0);
  return FlyCamera2;
}(TargetCamera);

// node_modules/@babylonjs/core/Cameras/followCameraInputsManager.js
var FollowCameraInputsManager = function(_super) {
  __extends(FollowCameraInputsManager2, _super);
  function FollowCameraInputsManager2(camera) {
    return _super.call(this, camera) || this;
  }
  FollowCameraInputsManager2.prototype.addKeyboard = function() {
    this.add(new FollowCameraKeyboardMoveInput());
    return this;
  };
  FollowCameraInputsManager2.prototype.addMouseWheel = function() {
    this.add(new FollowCameraMouseWheelInput());
    return this;
  };
  FollowCameraInputsManager2.prototype.addPointers = function() {
    this.add(new FollowCameraPointersInput());
    return this;
  };
  FollowCameraInputsManager2.prototype.addVRDeviceOrientation = function() {
    console.warn("DeviceOrientation support not yet implemented for FollowCamera.");
    return this;
  };
  return FollowCameraInputsManager2;
}(CameraInputsManager);

// node_modules/@babylonjs/core/Cameras/followCamera.js
Node2.AddNodeConstructor("FollowCamera", function(name98, scene) {
  return function() {
    return new FollowCamera(name98, Vector3.Zero(), scene);
  };
});
Node2.AddNodeConstructor("ArcFollowCamera", function(name98, scene) {
  return function() {
    return new ArcFollowCamera(name98, 0, 0, 1, null, scene);
  };
});
var FollowCamera = function(_super) {
  __extends(FollowCamera2, _super);
  function FollowCamera2(name98, position, scene, lockedTarget) {
    if (lockedTarget === void 0) {
      lockedTarget = null;
    }
    var _this = _super.call(this, name98, position, scene) || this;
    _this.radius = 12;
    _this.lowerRadiusLimit = null;
    _this.upperRadiusLimit = null;
    _this.rotationOffset = 0;
    _this.lowerRotationOffsetLimit = null;
    _this.upperRotationOffsetLimit = null;
    _this.heightOffset = 4;
    _this.lowerHeightOffsetLimit = null;
    _this.upperHeightOffsetLimit = null;
    _this.cameraAcceleration = 0.05;
    _this.maxCameraSpeed = 20;
    _this.lockedTarget = lockedTarget;
    _this.inputs = new FollowCameraInputsManager(_this);
    _this.inputs.addKeyboard().addMouseWheel().addPointers();
    return _this;
  }
  FollowCamera2.prototype._follow = function(cameraTarget) {
    if (!cameraTarget) {
      return;
    }
    var yRotation;
    if (cameraTarget.rotationQuaternion) {
      var rotMatrix = new Matrix();
      cameraTarget.rotationQuaternion.toRotationMatrix(rotMatrix);
      yRotation = Math.atan2(rotMatrix.m[8], rotMatrix.m[10]);
    } else {
      yRotation = cameraTarget.rotation.y;
    }
    var radians = Tools.ToRadians(this.rotationOffset) + yRotation;
    var targetPosition = cameraTarget.getAbsolutePosition();
    var targetX = targetPosition.x + Math.sin(radians) * this.radius;
    var targetZ = targetPosition.z + Math.cos(radians) * this.radius;
    var dx = targetX - this.position.x;
    var dy = targetPosition.y + this.heightOffset - this.position.y;
    var dz = targetZ - this.position.z;
    var vx = dx * this.cameraAcceleration * 2;
    var vy = dy * this.cameraAcceleration;
    var vz = dz * this.cameraAcceleration * 2;
    if (vx > this.maxCameraSpeed || vx < -this.maxCameraSpeed) {
      vx = vx < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;
    }
    if (vy > this.maxCameraSpeed || vy < -this.maxCameraSpeed) {
      vy = vy < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;
    }
    if (vz > this.maxCameraSpeed || vz < -this.maxCameraSpeed) {
      vz = vz < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;
    }
    this.position = new Vector3(this.position.x + vx, this.position.y + vy, this.position.z + vz);
    this.setTarget(targetPosition);
  };
  FollowCamera2.prototype.attachControl = function(ignored, noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    this.inputs.attachElement(noPreventDefault);
    this._reset = function() {
    };
  };
  FollowCamera2.prototype.detachControl = function(ignored) {
    this.inputs.detachElement();
    if (this._reset) {
      this._reset();
    }
  };
  FollowCamera2.prototype._checkInputs = function() {
    this.inputs.checkInputs();
    this._checkLimits();
    _super.prototype._checkInputs.call(this);
    if (this.lockedTarget) {
      this._follow(this.lockedTarget);
    }
  };
  FollowCamera2.prototype._checkLimits = function() {
    if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {
      this.radius = this.lowerRadiusLimit;
    }
    if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {
      this.radius = this.upperRadiusLimit;
    }
    if (this.lowerHeightOffsetLimit !== null && this.heightOffset < this.lowerHeightOffsetLimit) {
      this.heightOffset = this.lowerHeightOffsetLimit;
    }
    if (this.upperHeightOffsetLimit !== null && this.heightOffset > this.upperHeightOffsetLimit) {
      this.heightOffset = this.upperHeightOffsetLimit;
    }
    if (this.lowerRotationOffsetLimit !== null && this.rotationOffset < this.lowerRotationOffsetLimit) {
      this.rotationOffset = this.lowerRotationOffsetLimit;
    }
    if (this.upperRotationOffsetLimit !== null && this.rotationOffset > this.upperRotationOffsetLimit) {
      this.rotationOffset = this.upperRotationOffsetLimit;
    }
  };
  FollowCamera2.prototype.getClassName = function() {
    return "FollowCamera";
  };
  __decorate([
    serialize()
  ], FollowCamera2.prototype, "radius", void 0);
  __decorate([
    serialize()
  ], FollowCamera2.prototype, "lowerRadiusLimit", void 0);
  __decorate([
    serialize()
  ], FollowCamera2.prototype, "upperRadiusLimit", void 0);
  __decorate([
    serialize()
  ], FollowCamera2.prototype, "rotationOffset", void 0);
  __decorate([
    serialize()
  ], FollowCamera2.prototype, "lowerRotationOffsetLimit", void 0);
  __decorate([
    serialize()
  ], FollowCamera2.prototype, "upperRotationOffsetLimit", void 0);
  __decorate([
    serialize()
  ], FollowCamera2.prototype, "heightOffset", void 0);
  __decorate([
    serialize()
  ], FollowCamera2.prototype, "lowerHeightOffsetLimit", void 0);
  __decorate([
    serialize()
  ], FollowCamera2.prototype, "upperHeightOffsetLimit", void 0);
  __decorate([
    serialize()
  ], FollowCamera2.prototype, "cameraAcceleration", void 0);
  __decorate([
    serialize()
  ], FollowCamera2.prototype, "maxCameraSpeed", void 0);
  __decorate([
    serializeAsMeshReference("lockedTargetId")
  ], FollowCamera2.prototype, "lockedTarget", void 0);
  return FollowCamera2;
}(TargetCamera);
var ArcFollowCamera = function(_super) {
  __extends(ArcFollowCamera2, _super);
  function ArcFollowCamera2(name98, alpha, beta, radius, target, scene) {
    var _this = _super.call(this, name98, Vector3.Zero(), scene) || this;
    _this.alpha = alpha;
    _this.beta = beta;
    _this.radius = radius;
    _this._cartesianCoordinates = Vector3.Zero();
    _this._meshTarget = target;
    _this._follow();
    return _this;
  }
  ArcFollowCamera2.prototype._follow = function() {
    if (!this._meshTarget) {
      return;
    }
    this._cartesianCoordinates.x = this.radius * Math.cos(this.alpha) * Math.cos(this.beta);
    this._cartesianCoordinates.y = this.radius * Math.sin(this.beta);
    this._cartesianCoordinates.z = this.radius * Math.sin(this.alpha) * Math.cos(this.beta);
    var targetPosition = this._meshTarget.getAbsolutePosition();
    this.position = targetPosition.add(this._cartesianCoordinates);
    this.setTarget(targetPosition);
  };
  ArcFollowCamera2.prototype._checkInputs = function() {
    _super.prototype._checkInputs.call(this);
    this._follow();
  };
  ArcFollowCamera2.prototype.getClassName = function() {
    return "ArcFollowCamera";
  };
  return ArcFollowCamera2;
}(TargetCamera);

// node_modules/@babylonjs/core/Gamepads/Controllers/poseEnabledController.js
var PoseEnabledControllerType;
(function(PoseEnabledControllerType2) {
  PoseEnabledControllerType2[PoseEnabledControllerType2["VIVE"] = 0] = "VIVE";
  PoseEnabledControllerType2[PoseEnabledControllerType2["OCULUS"] = 1] = "OCULUS";
  PoseEnabledControllerType2[PoseEnabledControllerType2["WINDOWS"] = 2] = "WINDOWS";
  PoseEnabledControllerType2[PoseEnabledControllerType2["GEAR_VR"] = 3] = "GEAR_VR";
  PoseEnabledControllerType2[PoseEnabledControllerType2["DAYDREAM"] = 4] = "DAYDREAM";
  PoseEnabledControllerType2[PoseEnabledControllerType2["GENERIC"] = 5] = "GENERIC";
})(PoseEnabledControllerType || (PoseEnabledControllerType = {}));
var PoseEnabledControllerHelper = function() {
  function PoseEnabledControllerHelper2() {
  }
  PoseEnabledControllerHelper2.InitiateController = function(vrGamepad) {
    for (var _i = 0, _a = this._ControllerFactories; _i < _a.length; _i++) {
      var factory = _a[_i];
      if (factory.canCreate(vrGamepad)) {
        return factory.create(vrGamepad);
      }
    }
    if (this._DefaultControllerFactory) {
      return this._DefaultControllerFactory(vrGamepad);
    }
    throw "The type of gamepad you are trying to load needs to be imported first or is not supported.";
  };
  PoseEnabledControllerHelper2._ControllerFactories = [];
  PoseEnabledControllerHelper2._DefaultControllerFactory = null;
  return PoseEnabledControllerHelper2;
}();
var PoseEnabledController = function(_super) {
  __extends(PoseEnabledController2, _super);
  function PoseEnabledController2(browserGamepad) {
    var _this = _super.call(this, browserGamepad.id, browserGamepad.index, browserGamepad) || this;
    _this.isXR = false;
    _this._deviceRoomPosition = Vector3.Zero();
    _this._deviceRoomRotationQuaternion = new Quaternion();
    _this.devicePosition = Vector3.Zero();
    _this.deviceRotationQuaternion = new Quaternion();
    _this.deviceScaleFactor = 1;
    _this._trackPosition = true;
    _this._maxRotationDistFromHeadset = Math.PI / 5;
    _this._draggedRoomRotation = 0;
    _this._leftHandSystemQuaternion = new Quaternion();
    _this._deviceToWorld = Matrix.Identity();
    _this._pointingPoseNode = null;
    _this._workingMatrix = Matrix.Identity();
    _this._meshAttachedObservable = new Observable();
    _this.type = Gamepad.POSE_ENABLED;
    _this.controllerType = PoseEnabledControllerType.GENERIC;
    _this.position = Vector3.Zero();
    _this.rotationQuaternion = new Quaternion();
    _this._calculatedPosition = Vector3.Zero();
    _this._calculatedRotation = new Quaternion();
    Quaternion.RotationYawPitchRollToRef(Math.PI, 0, 0, _this._leftHandSystemQuaternion);
    return _this;
  }
  PoseEnabledController2.prototype._disableTrackPosition = function(fixedPosition) {
    if (this._trackPosition) {
      this._calculatedPosition.copyFrom(fixedPosition);
      this._trackPosition = false;
    }
  };
  PoseEnabledController2.prototype.update = function() {
    _super.prototype.update.call(this);
    this._updatePoseAndMesh();
  };
  PoseEnabledController2.prototype._updatePoseAndMesh = function() {
    if (this.isXR) {
      return;
    }
    var pose = this.browserGamepad.pose;
    this.updateFromDevice(pose);
    if (!this._trackPosition && EngineStore.LastCreatedScene && EngineStore.LastCreatedScene.activeCamera && EngineStore.LastCreatedScene.activeCamera.devicePosition) {
      var camera = EngineStore.LastCreatedScene.activeCamera;
      camera._computeDevicePosition();
      this._deviceToWorld.setTranslation(camera.devicePosition);
      if (camera.deviceRotationQuaternion) {
        var camera = camera;
        camera._deviceRoomRotationQuaternion.toEulerAnglesToRef(TmpVectors.Vector3[0]);
        var distanceAway = Math.atan2(Math.sin(TmpVectors.Vector3[0].y - this._draggedRoomRotation), Math.cos(TmpVectors.Vector3[0].y - this._draggedRoomRotation));
        if (Math.abs(distanceAway) > this._maxRotationDistFromHeadset) {
          var rotationAmount = distanceAway - (distanceAway < 0 ? -this._maxRotationDistFromHeadset : this._maxRotationDistFromHeadset);
          this._draggedRoomRotation += rotationAmount;
          var sin = Math.sin(-rotationAmount);
          var cos = Math.cos(-rotationAmount);
          this._calculatedPosition.x = this._calculatedPosition.x * cos - this._calculatedPosition.z * sin;
          this._calculatedPosition.z = this._calculatedPosition.x * sin + this._calculatedPosition.z * cos;
        }
      }
    }
    Vector3.TransformCoordinatesToRef(this._calculatedPosition, this._deviceToWorld, this.devicePosition);
    this._deviceToWorld.getRotationMatrixToRef(this._workingMatrix);
    Quaternion.FromRotationMatrixToRef(this._workingMatrix, this.deviceRotationQuaternion);
    this.deviceRotationQuaternion.multiplyInPlace(this._calculatedRotation);
    if (this._mesh) {
      this._mesh.position.copyFrom(this.devicePosition);
      if (this._mesh.rotationQuaternion) {
        this._mesh.rotationQuaternion.copyFrom(this.deviceRotationQuaternion);
      }
    }
  };
  PoseEnabledController2.prototype.updateFromDevice = function(poseData) {
    if (this.isXR) {
      return;
    }
    if (poseData) {
      this.rawPose = poseData;
      if (poseData.position) {
        this._deviceRoomPosition.copyFromFloats(poseData.position[0], poseData.position[1], -poseData.position[2]);
        if (this._mesh && this._mesh.getScene().useRightHandedSystem) {
          this._deviceRoomPosition.z *= -1;
        }
        if (this._trackPosition) {
          this._deviceRoomPosition.scaleToRef(this.deviceScaleFactor, this._calculatedPosition);
        }
        this._calculatedPosition.addInPlace(this.position);
      }
      var pose = this.rawPose;
      if (poseData.orientation && pose.orientation && pose.orientation.length === 4) {
        this._deviceRoomRotationQuaternion.copyFromFloats(pose.orientation[0], pose.orientation[1], -pose.orientation[2], -pose.orientation[3]);
        if (this._mesh) {
          if (this._mesh.getScene().useRightHandedSystem) {
            this._deviceRoomRotationQuaternion.z *= -1;
            this._deviceRoomRotationQuaternion.w *= -1;
          } else {
            this._deviceRoomRotationQuaternion.multiplyToRef(this._leftHandSystemQuaternion, this._deviceRoomRotationQuaternion);
          }
        }
        this._deviceRoomRotationQuaternion.multiplyToRef(this.rotationQuaternion, this._calculatedRotation);
      }
    }
  };
  PoseEnabledController2.prototype.attachToMesh = function(mesh) {
    if (this._mesh) {
      this._mesh.parent = null;
    }
    this._mesh = mesh;
    if (this._poseControlledCamera) {
      this._mesh.parent = this._poseControlledCamera;
    }
    if (!this._mesh.rotationQuaternion) {
      this._mesh.rotationQuaternion = new Quaternion();
    }
    if (!this.isXR) {
      this._updatePoseAndMesh();
      if (this._pointingPoseNode) {
        var parents = [];
        var obj = this._pointingPoseNode;
        while (obj.parent) {
          parents.push(obj.parent);
          obj = obj.parent;
        }
        parents.reverse().forEach(function(p) {
          p.computeWorldMatrix(true);
        });
      }
    }
    this._meshAttachedObservable.notifyObservers(mesh);
  };
  PoseEnabledController2.prototype.attachToPoseControlledCamera = function(camera) {
    this._poseControlledCamera = camera;
    if (this._mesh) {
      this._mesh.parent = this._poseControlledCamera;
    }
  };
  PoseEnabledController2.prototype.dispose = function() {
    if (this._mesh) {
      this._mesh.dispose();
    }
    this._mesh = null;
    _super.prototype.dispose.call(this);
  };
  Object.defineProperty(PoseEnabledController2.prototype, "mesh", {
    get: function() {
      return this._mesh;
    },
    enumerable: false,
    configurable: true
  });
  PoseEnabledController2.prototype.getForwardRay = function(length) {
    if (length === void 0) {
      length = 100;
    }
    if (!this.mesh) {
      return new Ray(Vector3.Zero(), new Vector3(0, 0, 1), length);
    }
    var m = this._pointingPoseNode ? this._pointingPoseNode.getWorldMatrix() : this.mesh.getWorldMatrix();
    var origin = m.getTranslation();
    var forward = new Vector3(0, 0, -1);
    var forwardWorld = Vector3.TransformNormal(forward, m);
    var direction = Vector3.Normalize(forwardWorld);
    return new Ray(origin, direction, length);
  };
  PoseEnabledController2.POINTING_POSE = "POINTING_POSE";
  return PoseEnabledController2;
}(Gamepad);

// node_modules/@babylonjs/core/Gamepads/xboxGamepad.js
var Xbox360Button;
(function(Xbox360Button2) {
  Xbox360Button2[Xbox360Button2["A"] = 0] = "A";
  Xbox360Button2[Xbox360Button2["B"] = 1] = "B";
  Xbox360Button2[Xbox360Button2["X"] = 2] = "X";
  Xbox360Button2[Xbox360Button2["Y"] = 3] = "Y";
  Xbox360Button2[Xbox360Button2["LB"] = 4] = "LB";
  Xbox360Button2[Xbox360Button2["RB"] = 5] = "RB";
  Xbox360Button2[Xbox360Button2["Back"] = 8] = "Back";
  Xbox360Button2[Xbox360Button2["Start"] = 9] = "Start";
  Xbox360Button2[Xbox360Button2["LeftStick"] = 10] = "LeftStick";
  Xbox360Button2[Xbox360Button2["RightStick"] = 11] = "RightStick";
})(Xbox360Button || (Xbox360Button = {}));
var Xbox360Dpad;
(function(Xbox360Dpad2) {
  Xbox360Dpad2[Xbox360Dpad2["Up"] = 12] = "Up";
  Xbox360Dpad2[Xbox360Dpad2["Down"] = 13] = "Down";
  Xbox360Dpad2[Xbox360Dpad2["Left"] = 14] = "Left";
  Xbox360Dpad2[Xbox360Dpad2["Right"] = 15] = "Right";
})(Xbox360Dpad || (Xbox360Dpad = {}));
var Xbox360Pad = function(_super) {
  __extends(Xbox360Pad2, _super);
  function Xbox360Pad2(id, index, gamepad, xboxOne) {
    if (xboxOne === void 0) {
      xboxOne = false;
    }
    var _this = _super.call(this, id, index, gamepad, 0, 1, 2, 3) || this;
    _this._leftTrigger = 0;
    _this._rightTrigger = 0;
    _this.onButtonDownObservable = new Observable();
    _this.onButtonUpObservable = new Observable();
    _this.onPadDownObservable = new Observable();
    _this.onPadUpObservable = new Observable();
    _this._buttonA = 0;
    _this._buttonB = 0;
    _this._buttonX = 0;
    _this._buttonY = 0;
    _this._buttonBack = 0;
    _this._buttonStart = 0;
    _this._buttonLB = 0;
    _this._buttonRB = 0;
    _this._buttonLeftStick = 0;
    _this._buttonRightStick = 0;
    _this._dPadUp = 0;
    _this._dPadDown = 0;
    _this._dPadLeft = 0;
    _this._dPadRight = 0;
    _this._isXboxOnePad = false;
    _this.type = Gamepad.XBOX;
    _this._isXboxOnePad = xboxOne;
    return _this;
  }
  Xbox360Pad2.prototype.onlefttriggerchanged = function(callback) {
    this._onlefttriggerchanged = callback;
  };
  Xbox360Pad2.prototype.onrighttriggerchanged = function(callback) {
    this._onrighttriggerchanged = callback;
  };
  Object.defineProperty(Xbox360Pad2.prototype, "leftTrigger", {
    get: function() {
      return this._leftTrigger;
    },
    set: function(newValue) {
      if (this._onlefttriggerchanged && this._leftTrigger !== newValue) {
        this._onlefttriggerchanged(newValue);
      }
      this._leftTrigger = newValue;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Xbox360Pad2.prototype, "rightTrigger", {
    get: function() {
      return this._rightTrigger;
    },
    set: function(newValue) {
      if (this._onrighttriggerchanged && this._rightTrigger !== newValue) {
        this._onrighttriggerchanged(newValue);
      }
      this._rightTrigger = newValue;
    },
    enumerable: false,
    configurable: true
  });
  Xbox360Pad2.prototype.onbuttondown = function(callback) {
    this._onbuttondown = callback;
  };
  Xbox360Pad2.prototype.onbuttonup = function(callback) {
    this._onbuttonup = callback;
  };
  Xbox360Pad2.prototype.ondpaddown = function(callback) {
    this._ondpaddown = callback;
  };
  Xbox360Pad2.prototype.ondpadup = function(callback) {
    this._ondpadup = callback;
  };
  Xbox360Pad2.prototype._setButtonValue = function(newValue, currentValue, buttonType) {
    if (newValue !== currentValue) {
      if (newValue === 1) {
        if (this._onbuttondown) {
          this._onbuttondown(buttonType);
        }
        this.onButtonDownObservable.notifyObservers(buttonType);
      }
      if (newValue === 0) {
        if (this._onbuttonup) {
          this._onbuttonup(buttonType);
        }
        this.onButtonUpObservable.notifyObservers(buttonType);
      }
    }
    return newValue;
  };
  Xbox360Pad2.prototype._setDPadValue = function(newValue, currentValue, buttonType) {
    if (newValue !== currentValue) {
      if (newValue === 1) {
        if (this._ondpaddown) {
          this._ondpaddown(buttonType);
        }
        this.onPadDownObservable.notifyObservers(buttonType);
      }
      if (newValue === 0) {
        if (this._ondpadup) {
          this._ondpadup(buttonType);
        }
        this.onPadUpObservable.notifyObservers(buttonType);
      }
    }
    return newValue;
  };
  Object.defineProperty(Xbox360Pad2.prototype, "buttonA", {
    get: function() {
      return this._buttonA;
    },
    set: function(value) {
      this._buttonA = this._setButtonValue(value, this._buttonA, Xbox360Button.A);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Xbox360Pad2.prototype, "buttonB", {
    get: function() {
      return this._buttonB;
    },
    set: function(value) {
      this._buttonB = this._setButtonValue(value, this._buttonB, Xbox360Button.B);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Xbox360Pad2.prototype, "buttonX", {
    get: function() {
      return this._buttonX;
    },
    set: function(value) {
      this._buttonX = this._setButtonValue(value, this._buttonX, Xbox360Button.X);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Xbox360Pad2.prototype, "buttonY", {
    get: function() {
      return this._buttonY;
    },
    set: function(value) {
      this._buttonY = this._setButtonValue(value, this._buttonY, Xbox360Button.Y);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Xbox360Pad2.prototype, "buttonStart", {
    get: function() {
      return this._buttonStart;
    },
    set: function(value) {
      this._buttonStart = this._setButtonValue(value, this._buttonStart, Xbox360Button.Start);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Xbox360Pad2.prototype, "buttonBack", {
    get: function() {
      return this._buttonBack;
    },
    set: function(value) {
      this._buttonBack = this._setButtonValue(value, this._buttonBack, Xbox360Button.Back);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Xbox360Pad2.prototype, "buttonLB", {
    get: function() {
      return this._buttonLB;
    },
    set: function(value) {
      this._buttonLB = this._setButtonValue(value, this._buttonLB, Xbox360Button.LB);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Xbox360Pad2.prototype, "buttonRB", {
    get: function() {
      return this._buttonRB;
    },
    set: function(value) {
      this._buttonRB = this._setButtonValue(value, this._buttonRB, Xbox360Button.RB);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Xbox360Pad2.prototype, "buttonLeftStick", {
    get: function() {
      return this._buttonLeftStick;
    },
    set: function(value) {
      this._buttonLeftStick = this._setButtonValue(value, this._buttonLeftStick, Xbox360Button.LeftStick);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Xbox360Pad2.prototype, "buttonRightStick", {
    get: function() {
      return this._buttonRightStick;
    },
    set: function(value) {
      this._buttonRightStick = this._setButtonValue(value, this._buttonRightStick, Xbox360Button.RightStick);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Xbox360Pad2.prototype, "dPadUp", {
    get: function() {
      return this._dPadUp;
    },
    set: function(value) {
      this._dPadUp = this._setDPadValue(value, this._dPadUp, Xbox360Dpad.Up);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Xbox360Pad2.prototype, "dPadDown", {
    get: function() {
      return this._dPadDown;
    },
    set: function(value) {
      this._dPadDown = this._setDPadValue(value, this._dPadDown, Xbox360Dpad.Down);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Xbox360Pad2.prototype, "dPadLeft", {
    get: function() {
      return this._dPadLeft;
    },
    set: function(value) {
      this._dPadLeft = this._setDPadValue(value, this._dPadLeft, Xbox360Dpad.Left);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Xbox360Pad2.prototype, "dPadRight", {
    get: function() {
      return this._dPadRight;
    },
    set: function(value) {
      this._dPadRight = this._setDPadValue(value, this._dPadRight, Xbox360Dpad.Right);
    },
    enumerable: false,
    configurable: true
  });
  Xbox360Pad2.prototype.update = function() {
    _super.prototype.update.call(this);
    if (this._isXboxOnePad) {
      this.buttonA = this.browserGamepad.buttons[0].value;
      this.buttonB = this.browserGamepad.buttons[1].value;
      this.buttonX = this.browserGamepad.buttons[2].value;
      this.buttonY = this.browserGamepad.buttons[3].value;
      this.buttonLB = this.browserGamepad.buttons[4].value;
      this.buttonRB = this.browserGamepad.buttons[5].value;
      this.leftTrigger = this.browserGamepad.buttons[6].value;
      this.rightTrigger = this.browserGamepad.buttons[7].value;
      this.buttonBack = this.browserGamepad.buttons[8].value;
      this.buttonStart = this.browserGamepad.buttons[9].value;
      this.buttonLeftStick = this.browserGamepad.buttons[10].value;
      this.buttonRightStick = this.browserGamepad.buttons[11].value;
      this.dPadUp = this.browserGamepad.buttons[12].value;
      this.dPadDown = this.browserGamepad.buttons[13].value;
      this.dPadLeft = this.browserGamepad.buttons[14].value;
      this.dPadRight = this.browserGamepad.buttons[15].value;
    } else {
      this.buttonA = this.browserGamepad.buttons[0].value;
      this.buttonB = this.browserGamepad.buttons[1].value;
      this.buttonX = this.browserGamepad.buttons[2].value;
      this.buttonY = this.browserGamepad.buttons[3].value;
      this.buttonLB = this.browserGamepad.buttons[4].value;
      this.buttonRB = this.browserGamepad.buttons[5].value;
      this.leftTrigger = this.browserGamepad.buttons[6].value;
      this.rightTrigger = this.browserGamepad.buttons[7].value;
      this.buttonBack = this.browserGamepad.buttons[8].value;
      this.buttonStart = this.browserGamepad.buttons[9].value;
      this.buttonLeftStick = this.browserGamepad.buttons[10].value;
      this.buttonRightStick = this.browserGamepad.buttons[11].value;
      this.dPadUp = this.browserGamepad.buttons[12].value;
      this.dPadDown = this.browserGamepad.buttons[13].value;
      this.dPadLeft = this.browserGamepad.buttons[14].value;
      this.dPadRight = this.browserGamepad.buttons[15].value;
    }
  };
  Xbox360Pad2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this.onButtonDownObservable.clear();
    this.onButtonUpObservable.clear();
    this.onPadDownObservable.clear();
    this.onPadUpObservable.clear();
  };
  return Xbox360Pad2;
}(Gamepad);

// node_modules/@babylonjs/core/Gamepads/dualShockGamepad.js
var DualShockButton;
(function(DualShockButton2) {
  DualShockButton2[DualShockButton2["Cross"] = 0] = "Cross";
  DualShockButton2[DualShockButton2["Circle"] = 1] = "Circle";
  DualShockButton2[DualShockButton2["Square"] = 2] = "Square";
  DualShockButton2[DualShockButton2["Triangle"] = 3] = "Triangle";
  DualShockButton2[DualShockButton2["L1"] = 4] = "L1";
  DualShockButton2[DualShockButton2["R1"] = 5] = "R1";
  DualShockButton2[DualShockButton2["Share"] = 8] = "Share";
  DualShockButton2[DualShockButton2["Options"] = 9] = "Options";
  DualShockButton2[DualShockButton2["LeftStick"] = 10] = "LeftStick";
  DualShockButton2[DualShockButton2["RightStick"] = 11] = "RightStick";
})(DualShockButton || (DualShockButton = {}));
var DualShockDpad;
(function(DualShockDpad2) {
  DualShockDpad2[DualShockDpad2["Up"] = 12] = "Up";
  DualShockDpad2[DualShockDpad2["Down"] = 13] = "Down";
  DualShockDpad2[DualShockDpad2["Left"] = 14] = "Left";
  DualShockDpad2[DualShockDpad2["Right"] = 15] = "Right";
})(DualShockDpad || (DualShockDpad = {}));
var DualShockPad = function(_super) {
  __extends(DualShockPad2, _super);
  function DualShockPad2(id, index, gamepad) {
    var _this = _super.call(this, id.replace("STANDARD GAMEPAD", "SONY PLAYSTATION DUALSHOCK"), index, gamepad, 0, 1, 2, 3) || this;
    _this._leftTrigger = 0;
    _this._rightTrigger = 0;
    _this.onButtonDownObservable = new Observable();
    _this.onButtonUpObservable = new Observable();
    _this.onPadDownObservable = new Observable();
    _this.onPadUpObservable = new Observable();
    _this._buttonCross = 0;
    _this._buttonCircle = 0;
    _this._buttonSquare = 0;
    _this._buttonTriangle = 0;
    _this._buttonShare = 0;
    _this._buttonOptions = 0;
    _this._buttonL1 = 0;
    _this._buttonR1 = 0;
    _this._buttonLeftStick = 0;
    _this._buttonRightStick = 0;
    _this._dPadUp = 0;
    _this._dPadDown = 0;
    _this._dPadLeft = 0;
    _this._dPadRight = 0;
    _this.type = Gamepad.DUALSHOCK;
    return _this;
  }
  DualShockPad2.prototype.onlefttriggerchanged = function(callback) {
    this._onlefttriggerchanged = callback;
  };
  DualShockPad2.prototype.onrighttriggerchanged = function(callback) {
    this._onrighttriggerchanged = callback;
  };
  Object.defineProperty(DualShockPad2.prototype, "leftTrigger", {
    get: function() {
      return this._leftTrigger;
    },
    set: function(newValue) {
      if (this._onlefttriggerchanged && this._leftTrigger !== newValue) {
        this._onlefttriggerchanged(newValue);
      }
      this._leftTrigger = newValue;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DualShockPad2.prototype, "rightTrigger", {
    get: function() {
      return this._rightTrigger;
    },
    set: function(newValue) {
      if (this._onrighttriggerchanged && this._rightTrigger !== newValue) {
        this._onrighttriggerchanged(newValue);
      }
      this._rightTrigger = newValue;
    },
    enumerable: false,
    configurable: true
  });
  DualShockPad2.prototype.onbuttondown = function(callback) {
    this._onbuttondown = callback;
  };
  DualShockPad2.prototype.onbuttonup = function(callback) {
    this._onbuttonup = callback;
  };
  DualShockPad2.prototype.ondpaddown = function(callback) {
    this._ondpaddown = callback;
  };
  DualShockPad2.prototype.ondpadup = function(callback) {
    this._ondpadup = callback;
  };
  DualShockPad2.prototype._setButtonValue = function(newValue, currentValue, buttonType) {
    if (newValue !== currentValue) {
      if (newValue === 1) {
        if (this._onbuttondown) {
          this._onbuttondown(buttonType);
        }
        this.onButtonDownObservable.notifyObservers(buttonType);
      }
      if (newValue === 0) {
        if (this._onbuttonup) {
          this._onbuttonup(buttonType);
        }
        this.onButtonUpObservable.notifyObservers(buttonType);
      }
    }
    return newValue;
  };
  DualShockPad2.prototype._setDPadValue = function(newValue, currentValue, buttonType) {
    if (newValue !== currentValue) {
      if (newValue === 1) {
        if (this._ondpaddown) {
          this._ondpaddown(buttonType);
        }
        this.onPadDownObservable.notifyObservers(buttonType);
      }
      if (newValue === 0) {
        if (this._ondpadup) {
          this._ondpadup(buttonType);
        }
        this.onPadUpObservable.notifyObservers(buttonType);
      }
    }
    return newValue;
  };
  Object.defineProperty(DualShockPad2.prototype, "buttonCross", {
    get: function() {
      return this._buttonCross;
    },
    set: function(value) {
      this._buttonCross = this._setButtonValue(value, this._buttonCross, DualShockButton.Cross);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DualShockPad2.prototype, "buttonCircle", {
    get: function() {
      return this._buttonCircle;
    },
    set: function(value) {
      this._buttonCircle = this._setButtonValue(value, this._buttonCircle, DualShockButton.Circle);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DualShockPad2.prototype, "buttonSquare", {
    get: function() {
      return this._buttonSquare;
    },
    set: function(value) {
      this._buttonSquare = this._setButtonValue(value, this._buttonSquare, DualShockButton.Square);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DualShockPad2.prototype, "buttonTriangle", {
    get: function() {
      return this._buttonTriangle;
    },
    set: function(value) {
      this._buttonTriangle = this._setButtonValue(value, this._buttonTriangle, DualShockButton.Triangle);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DualShockPad2.prototype, "buttonOptions", {
    get: function() {
      return this._buttonOptions;
    },
    set: function(value) {
      this._buttonOptions = this._setButtonValue(value, this._buttonOptions, DualShockButton.Options);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DualShockPad2.prototype, "buttonShare", {
    get: function() {
      return this._buttonShare;
    },
    set: function(value) {
      this._buttonShare = this._setButtonValue(value, this._buttonShare, DualShockButton.Share);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DualShockPad2.prototype, "buttonL1", {
    get: function() {
      return this._buttonL1;
    },
    set: function(value) {
      this._buttonL1 = this._setButtonValue(value, this._buttonL1, DualShockButton.L1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DualShockPad2.prototype, "buttonR1", {
    get: function() {
      return this._buttonR1;
    },
    set: function(value) {
      this._buttonR1 = this._setButtonValue(value, this._buttonR1, DualShockButton.R1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DualShockPad2.prototype, "buttonLeftStick", {
    get: function() {
      return this._buttonLeftStick;
    },
    set: function(value) {
      this._buttonLeftStick = this._setButtonValue(value, this._buttonLeftStick, DualShockButton.LeftStick);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DualShockPad2.prototype, "buttonRightStick", {
    get: function() {
      return this._buttonRightStick;
    },
    set: function(value) {
      this._buttonRightStick = this._setButtonValue(value, this._buttonRightStick, DualShockButton.RightStick);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DualShockPad2.prototype, "dPadUp", {
    get: function() {
      return this._dPadUp;
    },
    set: function(value) {
      this._dPadUp = this._setDPadValue(value, this._dPadUp, DualShockDpad.Up);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DualShockPad2.prototype, "dPadDown", {
    get: function() {
      return this._dPadDown;
    },
    set: function(value) {
      this._dPadDown = this._setDPadValue(value, this._dPadDown, DualShockDpad.Down);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DualShockPad2.prototype, "dPadLeft", {
    get: function() {
      return this._dPadLeft;
    },
    set: function(value) {
      this._dPadLeft = this._setDPadValue(value, this._dPadLeft, DualShockDpad.Left);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DualShockPad2.prototype, "dPadRight", {
    get: function() {
      return this._dPadRight;
    },
    set: function(value) {
      this._dPadRight = this._setDPadValue(value, this._dPadRight, DualShockDpad.Right);
    },
    enumerable: false,
    configurable: true
  });
  DualShockPad2.prototype.update = function() {
    _super.prototype.update.call(this);
    this.buttonCross = this.browserGamepad.buttons[0].value;
    this.buttonCircle = this.browserGamepad.buttons[1].value;
    this.buttonSquare = this.browserGamepad.buttons[2].value;
    this.buttonTriangle = this.browserGamepad.buttons[3].value;
    this.buttonL1 = this.browserGamepad.buttons[4].value;
    this.buttonR1 = this.browserGamepad.buttons[5].value;
    this.leftTrigger = this.browserGamepad.buttons[6].value;
    this.rightTrigger = this.browserGamepad.buttons[7].value;
    this.buttonShare = this.browserGamepad.buttons[8].value;
    this.buttonOptions = this.browserGamepad.buttons[9].value;
    this.buttonLeftStick = this.browserGamepad.buttons[10].value;
    this.buttonRightStick = this.browserGamepad.buttons[11].value;
    this.dPadUp = this.browserGamepad.buttons[12].value;
    this.dPadDown = this.browserGamepad.buttons[13].value;
    this.dPadLeft = this.browserGamepad.buttons[14].value;
    this.dPadRight = this.browserGamepad.buttons[15].value;
  };
  DualShockPad2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this.onButtonDownObservable.clear();
    this.onButtonUpObservable.clear();
    this.onPadDownObservable.clear();
    this.onPadUpObservable.clear();
  };
  return DualShockPad2;
}(Gamepad);

// node_modules/@babylonjs/core/Gamepads/gamepadManager.js
var GamepadManager = function() {
  function GamepadManager2(_scene) {
    var _this = this;
    this._scene = _scene;
    this._babylonGamepads = [];
    this._oneGamepadConnected = false;
    this._isMonitoring = false;
    this.onGamepadDisconnectedObservable = new Observable();
    if (!DomManagement.IsWindowObjectExist()) {
      this._gamepadEventSupported = false;
    } else {
      this._gamepadEventSupported = "GamepadEvent" in window;
      this._gamepadSupport = navigator.getGamepads || navigator.webkitGetGamepads || navigator.msGetGamepads || navigator.webkitGamepads;
    }
    this.onGamepadConnectedObservable = new Observable(function(observer) {
      for (var i in _this._babylonGamepads) {
        var gamepad = _this._babylonGamepads[i];
        if (gamepad && gamepad._isConnected) {
          _this.onGamepadConnectedObservable.notifyObserver(observer, gamepad);
        }
      }
    });
    this._onGamepadConnectedEvent = function(evt) {
      var gamepad = evt.gamepad;
      if (gamepad.index in _this._babylonGamepads) {
        if (_this._babylonGamepads[gamepad.index].isConnected) {
          return;
        }
      }
      var newGamepad;
      if (_this._babylonGamepads[gamepad.index]) {
        newGamepad = _this._babylonGamepads[gamepad.index];
        newGamepad.browserGamepad = gamepad;
        newGamepad._isConnected = true;
      } else {
        newGamepad = _this._addNewGamepad(gamepad);
      }
      _this.onGamepadConnectedObservable.notifyObservers(newGamepad);
      _this._startMonitoringGamepads();
    };
    this._onGamepadDisconnectedEvent = function(evt) {
      var gamepad = evt.gamepad;
      for (var i in _this._babylonGamepads) {
        if (_this._babylonGamepads[i].index === gamepad.index) {
          var disconnectedGamepad = _this._babylonGamepads[i];
          disconnectedGamepad._isConnected = false;
          _this.onGamepadDisconnectedObservable.notifyObservers(disconnectedGamepad);
          disconnectedGamepad.dispose && disconnectedGamepad.dispose();
          break;
        }
      }
    };
    if (this._gamepadSupport) {
      this._updateGamepadObjects();
      if (this._babylonGamepads.length) {
        this._startMonitoringGamepads();
      }
      if (this._gamepadEventSupported) {
        var hostWindow = this._scene ? this._scene.getEngine().getHostWindow() : window;
        if (hostWindow) {
          hostWindow.addEventListener("gamepadconnected", this._onGamepadConnectedEvent, false);
          hostWindow.addEventListener("gamepaddisconnected", this._onGamepadDisconnectedEvent, false);
        }
      } else {
        this._startMonitoringGamepads();
      }
    }
  }
  Object.defineProperty(GamepadManager2.prototype, "gamepads", {
    get: function() {
      return this._babylonGamepads;
    },
    enumerable: false,
    configurable: true
  });
  GamepadManager2.prototype.getGamepadByType = function(type) {
    if (type === void 0) {
      type = Gamepad.XBOX;
    }
    for (var _i = 0, _a = this._babylonGamepads; _i < _a.length; _i++) {
      var gamepad = _a[_i];
      if (gamepad && gamepad.type === type) {
        return gamepad;
      }
    }
    return null;
  };
  GamepadManager2.prototype.dispose = function() {
    if (this._gamepadEventSupported) {
      if (this._onGamepadConnectedEvent) {
        window.removeEventListener("gamepadconnected", this._onGamepadConnectedEvent);
      }
      if (this._onGamepadDisconnectedEvent) {
        window.removeEventListener("gamepaddisconnected", this._onGamepadDisconnectedEvent);
      }
      this._onGamepadConnectedEvent = null;
      this._onGamepadDisconnectedEvent = null;
    }
    this._babylonGamepads.forEach(function(gamepad) {
      gamepad.dispose();
    });
    this.onGamepadConnectedObservable.clear();
    this.onGamepadDisconnectedObservable.clear();
    this._oneGamepadConnected = false;
    this._stopMonitoringGamepads();
    this._babylonGamepads = [];
  };
  GamepadManager2.prototype._addNewGamepad = function(gamepad) {
    if (!this._oneGamepadConnected) {
      this._oneGamepadConnected = true;
    }
    var newGamepad;
    var dualShock = gamepad.id.search("054c") !== -1;
    var xboxOne = gamepad.id.search("Xbox One") !== -1;
    if (xboxOne || gamepad.id.search("Xbox 360") !== -1 || gamepad.id.search("xinput") !== -1) {
      newGamepad = new Xbox360Pad(gamepad.id, gamepad.index, gamepad, xboxOne);
    } else if (dualShock) {
      newGamepad = new DualShockPad(gamepad.id, gamepad.index, gamepad);
    } else if (gamepad.pose) {
      newGamepad = PoseEnabledControllerHelper.InitiateController(gamepad);
    } else {
      newGamepad = new GenericPad(gamepad.id, gamepad.index, gamepad);
    }
    this._babylonGamepads[newGamepad.index] = newGamepad;
    return newGamepad;
  };
  GamepadManager2.prototype._startMonitoringGamepads = function() {
    if (!this._isMonitoring) {
      this._isMonitoring = true;
      if (!this._scene) {
        this._checkGamepadsStatus();
      }
    }
  };
  GamepadManager2.prototype._stopMonitoringGamepads = function() {
    this._isMonitoring = false;
  };
  GamepadManager2.prototype._checkGamepadsStatus = function() {
    var _this = this;
    this._updateGamepadObjects();
    for (var i in this._babylonGamepads) {
      var gamepad = this._babylonGamepads[i];
      if (!gamepad || !gamepad.isConnected) {
        continue;
      }
      gamepad.update();
    }
    if (this._isMonitoring && !this._scene) {
      Engine.QueueNewFrame(function() {
        _this._checkGamepadsStatus();
      });
    }
  };
  GamepadManager2.prototype._updateGamepadObjects = function() {
    var gamepads = navigator.getGamepads ? navigator.getGamepads() : navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : [];
    for (var i = 0; i < gamepads.length; i++) {
      var gamepad = gamepads[i];
      if (gamepad) {
        if (!this._babylonGamepads[gamepad.index]) {
          var newGamepad = this._addNewGamepad(gamepad);
          this.onGamepadConnectedObservable.notifyObservers(newGamepad);
        } else {
          this._babylonGamepads[i].browserGamepad = gamepad;
          if (!this._babylonGamepads[i].isConnected) {
            this._babylonGamepads[i]._isConnected = true;
            this.onGamepadConnectedObservable.notifyObservers(this._babylonGamepads[i]);
          }
        }
      }
    }
  };
  return GamepadManager2;
}();

// node_modules/@babylonjs/core/Gamepads/gamepadSceneComponent.js
Object.defineProperty(Scene.prototype, "gamepadManager", {
  get: function() {
    if (!this._gamepadManager) {
      this._gamepadManager = new GamepadManager(this);
      var component = this._getComponent(SceneComponentConstants.NAME_GAMEPAD);
      if (!component) {
        component = new GamepadSystemSceneComponent(this);
        this._addComponent(component);
      }
    }
    return this._gamepadManager;
  },
  enumerable: true,
  configurable: true
});
FreeCameraInputsManager.prototype.addGamepad = function() {
  this.add(new FreeCameraGamepadInput());
  return this;
};
ArcRotateCameraInputsManager.prototype.addGamepad = function() {
  this.add(new ArcRotateCameraGamepadInput());
  return this;
};
var GamepadSystemSceneComponent = function() {
  function GamepadSystemSceneComponent2(scene) {
    this.name = SceneComponentConstants.NAME_GAMEPAD;
    this.scene = scene;
  }
  GamepadSystemSceneComponent2.prototype.register = function() {
    this.scene._beforeCameraUpdateStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERAUPDATE_GAMEPAD, this, this._beforeCameraUpdate);
  };
  GamepadSystemSceneComponent2.prototype.rebuild = function() {
  };
  GamepadSystemSceneComponent2.prototype.dispose = function() {
    var gamepadManager = this.scene._gamepadManager;
    if (gamepadManager) {
      gamepadManager.dispose();
      this.scene._gamepadManager = null;
    }
  };
  GamepadSystemSceneComponent2.prototype._beforeCameraUpdate = function() {
    var gamepadManager = this.scene._gamepadManager;
    if (gamepadManager && gamepadManager._isMonitoring) {
      gamepadManager._checkGamepadsStatus();
    }
  };
  return GamepadSystemSceneComponent2;
}();

// node_modules/@babylonjs/core/Cameras/universalCamera.js
Node2.AddNodeConstructor("FreeCamera", function(name98, scene) {
  return function() {
    return new UniversalCamera(name98, Vector3.Zero(), scene);
  };
});
var UniversalCamera = function(_super) {
  __extends(UniversalCamera2, _super);
  function UniversalCamera2(name98, position, scene) {
    var _this = _super.call(this, name98, position, scene) || this;
    _this.inputs.addGamepad();
    return _this;
  }
  Object.defineProperty(UniversalCamera2.prototype, "gamepadAngularSensibility", {
    get: function() {
      var gamepad = this.inputs.attached["gamepad"];
      if (gamepad) {
        return gamepad.gamepadAngularSensibility;
      }
      return 0;
    },
    set: function(value) {
      var gamepad = this.inputs.attached["gamepad"];
      if (gamepad) {
        gamepad.gamepadAngularSensibility = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(UniversalCamera2.prototype, "gamepadMoveSensibility", {
    get: function() {
      var gamepad = this.inputs.attached["gamepad"];
      if (gamepad) {
        return gamepad.gamepadMoveSensibility;
      }
      return 0;
    },
    set: function(value) {
      var gamepad = this.inputs.attached["gamepad"];
      if (gamepad) {
        gamepad.gamepadMoveSensibility = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  UniversalCamera2.prototype.getClassName = function() {
    return "UniversalCamera";
  };
  return UniversalCamera2;
}(TouchCamera);
Camera._createDefaultParsedCamera = function(name98, scene) {
  return new UniversalCamera(name98, Vector3.Zero(), scene);
};

// node_modules/@babylonjs/core/Cameras/gamepadCamera.js
Node2.AddNodeConstructor("GamepadCamera", function(name98, scene) {
  return function() {
    return new GamepadCamera(name98, Vector3.Zero(), scene);
  };
});
var GamepadCamera = function(_super) {
  __extends(GamepadCamera2, _super);
  function GamepadCamera2(name98, position, scene) {
    return _super.call(this, name98, position, scene) || this;
  }
  GamepadCamera2.prototype.getClassName = function() {
    return "GamepadCamera";
  };
  return GamepadCamera2;
}(UniversalCamera);

// node_modules/@babylonjs/core/Shaders/pass.fragment.js
var name = "passPixelShader";
var shader = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nvoid main(void)\n{\ngl_FragColor=texture2D(textureSampler,vUV);\n}";
Effect.ShadersStore[name] = shader;

// node_modules/@babylonjs/core/Shaders/passCube.fragment.js
var name2 = "passCubePixelShader";
var shader2 = "\nvarying vec2 vUV;\nuniform samplerCube textureSampler;\nvoid main(void)\n{\nvec2 uv=vUV*2.0-1.0;\n#ifdef POSITIVEX\ngl_FragColor=textureCube(textureSampler,vec3(1.001,uv.y,uv.x));\n#endif\n#ifdef NEGATIVEX\ngl_FragColor=textureCube(textureSampler,vec3(-1.001,uv.y,uv.x));\n#endif\n#ifdef POSITIVEY\ngl_FragColor=textureCube(textureSampler,vec3(uv.y,1.001,uv.x));\n#endif\n#ifdef NEGATIVEY\ngl_FragColor=textureCube(textureSampler,vec3(uv.y,-1.001,uv.x));\n#endif\n#ifdef POSITIVEZ\ngl_FragColor=textureCube(textureSampler,vec3(uv,1.001));\n#endif\n#ifdef NEGATIVEZ\ngl_FragColor=textureCube(textureSampler,vec3(uv,-1.001));\n#endif\n}";
Effect.ShadersStore[name2] = shader2;

// node_modules/@babylonjs/core/PostProcesses/passPostProcess.js
var PassPostProcess = function(_super) {
  __extends(PassPostProcess2, _super);
  function PassPostProcess2(name98, options, camera, samplingMode, engine, reusable, textureType, blockCompilation) {
    if (camera === void 0) {
      camera = null;
    }
    if (textureType === void 0) {
      textureType = 0;
    }
    if (blockCompilation === void 0) {
      blockCompilation = false;
    }
    return _super.call(this, name98, "pass", null, null, options, camera, samplingMode, engine, reusable, void 0, textureType, void 0, null, blockCompilation) || this;
  }
  PassPostProcess2.prototype.getClassName = function() {
    return "PassPostProcess";
  };
  PassPostProcess2._Parse = function(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(function() {
      return new PassPostProcess2(parsedPostProcess.name, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable);
    }, parsedPostProcess, scene, rootUrl);
  };
  return PassPostProcess2;
}(PostProcess);
_TypeStore.RegisteredTypes["BABYLON.PassPostProcess"] = PassPostProcess;
var PassCubePostProcess = function(_super) {
  __extends(PassCubePostProcess2, _super);
  function PassCubePostProcess2(name98, options, camera, samplingMode, engine, reusable, textureType, blockCompilation) {
    if (camera === void 0) {
      camera = null;
    }
    if (textureType === void 0) {
      textureType = 0;
    }
    if (blockCompilation === void 0) {
      blockCompilation = false;
    }
    var _this = _super.call(this, name98, "passCube", null, null, options, camera, samplingMode, engine, reusable, "#define POSITIVEX", textureType, void 0, null, blockCompilation) || this;
    _this._face = 0;
    return _this;
  }
  Object.defineProperty(PassCubePostProcess2.prototype, "face", {
    get: function() {
      return this._face;
    },
    set: function(value) {
      if (value < 0 || value > 5) {
        return;
      }
      this._face = value;
      switch (this._face) {
        case 0:
          this.updateEffect("#define POSITIVEX");
          break;
        case 1:
          this.updateEffect("#define NEGATIVEX");
          break;
        case 2:
          this.updateEffect("#define POSITIVEY");
          break;
        case 3:
          this.updateEffect("#define NEGATIVEY");
          break;
        case 4:
          this.updateEffect("#define POSITIVEZ");
          break;
        case 5:
          this.updateEffect("#define NEGATIVEZ");
          break;
      }
    },
    enumerable: false,
    configurable: true
  });
  PassCubePostProcess2.prototype.getClassName = function() {
    return "PassCubePostProcess";
  };
  PassCubePostProcess2._Parse = function(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(function() {
      return new PassCubePostProcess2(parsedPostProcess.name, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable);
    }, parsedPostProcess, scene, rootUrl);
  };
  return PassCubePostProcess2;
}(PostProcess);
Engine._RescalePostProcessFactory = function(engine) {
  return new PassPostProcess("rescale", 1, null, 2, engine, false, 0);
};

// node_modules/@babylonjs/core/Shaders/anaglyph.fragment.js
var name3 = "anaglyphPixelShader";
var shader3 = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform sampler2D leftSampler;\nvoid main(void)\n{\nvec4 leftFrag=texture2D(leftSampler,vUV);\nleftFrag=vec4(1.0,leftFrag.g,leftFrag.b,1.0);\nvec4 rightFrag=texture2D(textureSampler,vUV);\nrightFrag=vec4(rightFrag.r,1.0,1.0,1.0);\ngl_FragColor=vec4(rightFrag.rgb*leftFrag.rgb,1.0);\n}";
Effect.ShadersStore[name3] = shader3;

// node_modules/@babylonjs/core/PostProcesses/anaglyphPostProcess.js
var AnaglyphPostProcess = function(_super) {
  __extends(AnaglyphPostProcess2, _super);
  function AnaglyphPostProcess2(name98, options, rigCameras, samplingMode, engine, reusable) {
    var _this = _super.call(this, name98, "anaglyph", null, ["leftSampler"], options, rigCameras[1], samplingMode, engine, reusable) || this;
    _this._passedProcess = rigCameras[0]._rigPostProcess;
    _this.onApplyObservable.add(function(effect) {
      effect.setTextureFromPostProcess("leftSampler", _this._passedProcess);
    });
    return _this;
  }
  AnaglyphPostProcess2.prototype.getClassName = function() {
    return "AnaglyphPostProcess";
  };
  return AnaglyphPostProcess2;
}(PostProcess);
_TypeStore.RegisteredTypes["BABYLON.AnaglyphPostProcess"] = AnaglyphPostProcess;

// node_modules/@babylonjs/core/Cameras/RigModes/stereoscopicAnaglyphRigMode.js
Camera._setStereoscopicAnaglyphRigMode = function(camera) {
  camera._rigCameras[0]._rigPostProcess = new PassPostProcess(camera.name + "_passthru", 1, camera._rigCameras[0]);
  camera._rigCameras[1]._rigPostProcess = new AnaglyphPostProcess(camera.name + "_anaglyph", 1, camera._rigCameras);
};

// node_modules/@babylonjs/core/Cameras/Stereoscopic/anaglyphArcRotateCamera.js
Node2.AddNodeConstructor("AnaglyphArcRotateCamera", function(name98, scene, options) {
  return function() {
    return new AnaglyphArcRotateCamera(name98, 0, 0, 1, Vector3.Zero(), options.interaxial_distance, scene);
  };
});
var AnaglyphArcRotateCamera = function(_super) {
  __extends(AnaglyphArcRotateCamera2, _super);
  function AnaglyphArcRotateCamera2(name98, alpha, beta, radius, target, interaxialDistance, scene) {
    var _this = _super.call(this, name98, alpha, beta, radius, target, scene) || this;
    _this.interaxialDistance = interaxialDistance;
    _this.setCameraRigMode(Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, { interaxialDistance });
    return _this;
  }
  AnaglyphArcRotateCamera2.prototype.getClassName = function() {
    return "AnaglyphArcRotateCamera";
  };
  return AnaglyphArcRotateCamera2;
}(ArcRotateCamera);

// node_modules/@babylonjs/core/Cameras/Stereoscopic/anaglyphFreeCamera.js
Node2.AddNodeConstructor("AnaglyphFreeCamera", function(name98, scene, options) {
  return function() {
    return new AnaglyphFreeCamera(name98, Vector3.Zero(), options.interaxial_distance, scene);
  };
});
var AnaglyphFreeCamera = function(_super) {
  __extends(AnaglyphFreeCamera2, _super);
  function AnaglyphFreeCamera2(name98, position, interaxialDistance, scene) {
    var _this = _super.call(this, name98, position, scene) || this;
    _this.interaxialDistance = interaxialDistance;
    _this.setCameraRigMode(Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, { interaxialDistance });
    return _this;
  }
  AnaglyphFreeCamera2.prototype.getClassName = function() {
    return "AnaglyphFreeCamera";
  };
  return AnaglyphFreeCamera2;
}(FreeCamera);

// node_modules/@babylonjs/core/Cameras/Stereoscopic/anaglyphGamepadCamera.js
Node2.AddNodeConstructor("AnaglyphGamepadCamera", function(name98, scene, options) {
  return function() {
    return new AnaglyphGamepadCamera(name98, Vector3.Zero(), options.interaxial_distance, scene);
  };
});
var AnaglyphGamepadCamera = function(_super) {
  __extends(AnaglyphGamepadCamera2, _super);
  function AnaglyphGamepadCamera2(name98, position, interaxialDistance, scene) {
    var _this = _super.call(this, name98, position, scene) || this;
    _this.interaxialDistance = interaxialDistance;
    _this.setCameraRigMode(Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, { interaxialDistance });
    return _this;
  }
  AnaglyphGamepadCamera2.prototype.getClassName = function() {
    return "AnaglyphGamepadCamera";
  };
  return AnaglyphGamepadCamera2;
}(GamepadCamera);

// node_modules/@babylonjs/core/Cameras/Stereoscopic/anaglyphUniversalCamera.js
Node2.AddNodeConstructor("AnaglyphUniversalCamera", function(name98, scene, options) {
  return function() {
    return new AnaglyphUniversalCamera(name98, Vector3.Zero(), options.interaxial_distance, scene);
  };
});
var AnaglyphUniversalCamera = function(_super) {
  __extends(AnaglyphUniversalCamera2, _super);
  function AnaglyphUniversalCamera2(name98, position, interaxialDistance, scene) {
    var _this = _super.call(this, name98, position, scene) || this;
    _this.interaxialDistance = interaxialDistance;
    _this.setCameraRigMode(Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, { interaxialDistance });
    return _this;
  }
  AnaglyphUniversalCamera2.prototype.getClassName = function() {
    return "AnaglyphUniversalCamera";
  };
  return AnaglyphUniversalCamera2;
}(UniversalCamera);

// node_modules/@babylonjs/core/Cameras/RigModes/stereoscopicRigMode.js
Camera._setStereoscopicRigMode = function(camera) {
  var isStereoscopicHoriz = camera.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL || camera.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED;
  var isCrossEye = camera.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED;
  camera._rigCameras[isCrossEye ? 1 : 0].viewport = new Viewport(0, 0, isStereoscopicHoriz ? 0.5 : 1, isStereoscopicHoriz ? 1 : 0.5);
  camera._rigCameras[isCrossEye ? 0 : 1].viewport = new Viewport(isStereoscopicHoriz ? 0.5 : 0, isStereoscopicHoriz ? 0 : 0.5, isStereoscopicHoriz ? 0.5 : 1, isStereoscopicHoriz ? 1 : 0.5);
};

// node_modules/@babylonjs/core/Cameras/Stereoscopic/stereoscopicArcRotateCamera.js
Node2.AddNodeConstructor("StereoscopicArcRotateCamera", function(name98, scene, options) {
  return function() {
    return new StereoscopicArcRotateCamera(name98, 0, 0, 1, Vector3.Zero(), options.interaxial_distance, options.isStereoscopicSideBySide, scene);
  };
});
var StereoscopicArcRotateCamera = function(_super) {
  __extends(StereoscopicArcRotateCamera2, _super);
  function StereoscopicArcRotateCamera2(name98, alpha, beta, radius, target, interaxialDistance, isStereoscopicSideBySide, scene) {
    var _this = _super.call(this, name98, alpha, beta, radius, target, scene) || this;
    _this.interaxialDistance = interaxialDistance;
    _this.isStereoscopicSideBySide = isStereoscopicSideBySide;
    _this.setCameraRigMode(isStereoscopicSideBySide ? Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, { interaxialDistance });
    return _this;
  }
  StereoscopicArcRotateCamera2.prototype.getClassName = function() {
    return "StereoscopicArcRotateCamera";
  };
  return StereoscopicArcRotateCamera2;
}(ArcRotateCamera);

// node_modules/@babylonjs/core/Cameras/Stereoscopic/stereoscopicFreeCamera.js
Node2.AddNodeConstructor("StereoscopicFreeCamera", function(name98, scene, options) {
  return function() {
    return new StereoscopicFreeCamera(name98, Vector3.Zero(), options.interaxial_distance, options.isStereoscopicSideBySide, scene);
  };
});
var StereoscopicFreeCamera = function(_super) {
  __extends(StereoscopicFreeCamera2, _super);
  function StereoscopicFreeCamera2(name98, position, interaxialDistance, isStereoscopicSideBySide, scene) {
    var _this = _super.call(this, name98, position, scene) || this;
    _this.interaxialDistance = interaxialDistance;
    _this.isStereoscopicSideBySide = isStereoscopicSideBySide;
    _this.setCameraRigMode(isStereoscopicSideBySide ? Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, { interaxialDistance });
    return _this;
  }
  StereoscopicFreeCamera2.prototype.getClassName = function() {
    return "StereoscopicFreeCamera";
  };
  return StereoscopicFreeCamera2;
}(FreeCamera);

// node_modules/@babylonjs/core/Cameras/Stereoscopic/stereoscopicGamepadCamera.js
Node2.AddNodeConstructor("StereoscopicGamepadCamera", function(name98, scene, options) {
  return function() {
    return new StereoscopicGamepadCamera(name98, Vector3.Zero(), options.interaxial_distance, options.isStereoscopicSideBySide, scene);
  };
});
var StereoscopicGamepadCamera = function(_super) {
  __extends(StereoscopicGamepadCamera2, _super);
  function StereoscopicGamepadCamera2(name98, position, interaxialDistance, isStereoscopicSideBySide, scene) {
    var _this = _super.call(this, name98, position, scene) || this;
    _this.interaxialDistance = interaxialDistance;
    _this.isStereoscopicSideBySide = isStereoscopicSideBySide;
    _this.setCameraRigMode(isStereoscopicSideBySide ? Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, { interaxialDistance });
    return _this;
  }
  StereoscopicGamepadCamera2.prototype.getClassName = function() {
    return "StereoscopicGamepadCamera";
  };
  return StereoscopicGamepadCamera2;
}(GamepadCamera);

// node_modules/@babylonjs/core/Cameras/Stereoscopic/stereoscopicUniversalCamera.js
Node2.AddNodeConstructor("StereoscopicFreeCamera", function(name98, scene, options) {
  return function() {
    return new StereoscopicUniversalCamera(name98, Vector3.Zero(), options.interaxial_distance, options.isStereoscopicSideBySide, scene);
  };
});
var StereoscopicUniversalCamera = function(_super) {
  __extends(StereoscopicUniversalCamera2, _super);
  function StereoscopicUniversalCamera2(name98, position, interaxialDistance, isStereoscopicSideBySide, scene) {
    var _this = _super.call(this, name98, position, scene) || this;
    _this.interaxialDistance = interaxialDistance;
    _this.isStereoscopicSideBySide = isStereoscopicSideBySide;
    _this.setCameraRigMode(isStereoscopicSideBySide ? Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, { interaxialDistance });
    return _this;
  }
  StereoscopicUniversalCamera2.prototype.getClassName = function() {
    return "StereoscopicUniversalCamera";
  };
  return StereoscopicUniversalCamera2;
}(UniversalCamera);

// node_modules/@babylonjs/core/Cameras/virtualJoysticksCamera.js
Node2.AddNodeConstructor("VirtualJoysticksCamera", function(name98, scene) {
  return function() {
    return new VirtualJoysticksCamera(name98, Vector3.Zero(), scene);
  };
});
var VirtualJoysticksCamera = function(_super) {
  __extends(VirtualJoysticksCamera2, _super);
  function VirtualJoysticksCamera2(name98, position, scene) {
    var _this = _super.call(this, name98, position, scene) || this;
    _this.inputs.addVirtualJoystick();
    return _this;
  }
  VirtualJoysticksCamera2.prototype.getClassName = function() {
    return "VirtualJoysticksCamera";
  };
  return VirtualJoysticksCamera2;
}(FreeCamera);

// node_modules/@babylonjs/core/Cameras/VR/vrCameraMetrics.js
var VRCameraMetrics = function() {
  function VRCameraMetrics2() {
    this.compensateDistortion = true;
    this.multiviewEnabled = false;
  }
  Object.defineProperty(VRCameraMetrics2.prototype, "aspectRatio", {
    get: function() {
      return this.hResolution / (2 * this.vResolution);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VRCameraMetrics2.prototype, "aspectRatioFov", {
    get: function() {
      return 2 * Math.atan(this.postProcessScaleFactor * this.vScreenSize / (2 * this.eyeToScreenDistance));
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VRCameraMetrics2.prototype, "leftHMatrix", {
    get: function() {
      var meters = this.hScreenSize / 4 - this.lensSeparationDistance / 2;
      var h = 4 * meters / this.hScreenSize;
      return Matrix.Translation(h, 0, 0);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VRCameraMetrics2.prototype, "rightHMatrix", {
    get: function() {
      var meters = this.hScreenSize / 4 - this.lensSeparationDistance / 2;
      var h = 4 * meters / this.hScreenSize;
      return Matrix.Translation(-h, 0, 0);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VRCameraMetrics2.prototype, "leftPreViewMatrix", {
    get: function() {
      return Matrix.Translation(0.5 * this.interpupillaryDistance, 0, 0);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VRCameraMetrics2.prototype, "rightPreViewMatrix", {
    get: function() {
      return Matrix.Translation(-0.5 * this.interpupillaryDistance, 0, 0);
    },
    enumerable: false,
    configurable: true
  });
  VRCameraMetrics2.GetDefault = function() {
    var result = new VRCameraMetrics2();
    result.hResolution = 1280;
    result.vResolution = 800;
    result.hScreenSize = 0.149759993;
    result.vScreenSize = 0.0935999975;
    result.vScreenCenter = 0.0467999987;
    result.eyeToScreenDistance = 0.0410000011;
    result.lensSeparationDistance = 0.063500002;
    result.interpupillaryDistance = 0.064000003;
    result.distortionK = [1, 0.219999999, 0.239999995, 0];
    result.chromaAbCorrection = [0.995999992, -0.00400000019, 1.01400006, 0];
    result.postProcessScaleFactor = 1.714605507808412;
    result.lensCenterOffset = 0.151976421;
    return result;
  };
  return VRCameraMetrics2;
}();

// node_modules/@babylonjs/core/Shaders/vrDistortionCorrection.fragment.js
var name4 = "vrDistortionCorrectionPixelShader";
var shader4 = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform vec2 LensCenter;\nuniform vec2 Scale;\nuniform vec2 ScaleIn;\nuniform vec4 HmdWarpParam;\nvec2 HmdWarp(vec2 in01) {\nvec2 theta=(in01-LensCenter)*ScaleIn;\nfloat rSq=theta.x*theta.x+theta.y*theta.y;\nvec2 rvector=theta*(HmdWarpParam.x+HmdWarpParam.y*rSq+HmdWarpParam.z*rSq*rSq+HmdWarpParam.w*rSq*rSq*rSq);\nreturn LensCenter+Scale*rvector;\n}\nvoid main(void)\n{\nvec2 tc=HmdWarp(vUV);\nif (tc.x <0.0 || tc.x>1.0 || tc.y<0.0 || tc.y>1.0)\ngl_FragColor=vec4(0.0,0.0,0.0,0.0);\nelse{\ngl_FragColor=texture2D(textureSampler,tc);\n}\n}";
Effect.ShadersStore[name4] = shader4;

// node_modules/@babylonjs/core/PostProcesses/vrDistortionCorrectionPostProcess.js
var VRDistortionCorrectionPostProcess = function(_super) {
  __extends(VRDistortionCorrectionPostProcess2, _super);
  function VRDistortionCorrectionPostProcess2(name98, camera, isRightEye, vrMetrics) {
    var _this = _super.call(this, name98, "vrDistortionCorrection", [
      "LensCenter",
      "Scale",
      "ScaleIn",
      "HmdWarpParam"
    ], null, vrMetrics.postProcessScaleFactor, camera, Texture.BILINEAR_SAMPLINGMODE) || this;
    _this._isRightEye = isRightEye;
    _this._distortionFactors = vrMetrics.distortionK;
    _this._postProcessScaleFactor = vrMetrics.postProcessScaleFactor;
    _this._lensCenterOffset = vrMetrics.lensCenterOffset;
    _this.adaptScaleToCurrentViewport = true;
    _this.onSizeChangedObservable.add(function() {
      _this._scaleIn = new Vector2(2, 2 / _this.aspectRatio);
      _this._scaleFactor = new Vector2(0.5 * (1 / _this._postProcessScaleFactor), 0.5 * (1 / _this._postProcessScaleFactor) * _this.aspectRatio);
      _this._lensCenter = new Vector2(_this._isRightEye ? 0.5 - _this._lensCenterOffset * 0.5 : 0.5 + _this._lensCenterOffset * 0.5, 0.5);
    });
    _this.onApplyObservable.add(function(effect) {
      effect.setFloat2("LensCenter", _this._lensCenter.x, _this._lensCenter.y);
      effect.setFloat2("Scale", _this._scaleFactor.x, _this._scaleFactor.y);
      effect.setFloat2("ScaleIn", _this._scaleIn.x, _this._scaleIn.y);
      effect.setFloat4("HmdWarpParam", _this._distortionFactors[0], _this._distortionFactors[1], _this._distortionFactors[2], _this._distortionFactors[3]);
    });
    return _this;
  }
  VRDistortionCorrectionPostProcess2.prototype.getClassName = function() {
    return "VRDistortionCorrectionPostProcess";
  };
  return VRDistortionCorrectionPostProcess2;
}(PostProcess);

// node_modules/@babylonjs/core/Shaders/vrMultiviewToSingleview.fragment.js
var name5 = "vrMultiviewToSingleviewPixelShader";
var shader5 = "precision mediump sampler2DArray;\nvarying vec2 vUV;\nuniform sampler2DArray multiviewSampler;\nuniform int imageIndex;\nvoid main(void)\n{\ngl_FragColor=texture(multiviewSampler,vec3(vUV,imageIndex));\n}";
Effect.ShadersStore[name5] = shader5;

// node_modules/@babylonjs/core/Materials/Textures/MultiviewRenderTarget.js
var MultiviewRenderTarget = function(_super) {
  __extends(MultiviewRenderTarget2, _super);
  function MultiviewRenderTarget2(scene, size) {
    if (size === void 0) {
      size = 512;
    }
    var _this = _super.call(this, "multiview rtt", size, scene, false, true, InternalTextureSource.Unknown, false, void 0, false, false, true, void 0, true) || this;
    var internalTexture = scene.getEngine().createMultiviewRenderTargetTexture(_this.getRenderWidth(), _this.getRenderHeight());
    internalTexture.isMultiview = true;
    internalTexture.format = 5;
    _this._texture = internalTexture;
    _this.samples = _this._getEngine().getCaps().maxSamples || _this.samples;
    return _this;
  }
  MultiviewRenderTarget2.prototype._bindFrameBuffer = function(faceIndex) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (!this._texture) {
      return;
    }
    this.getScene().getEngine().bindMultiviewFramebuffer(this._texture);
  };
  MultiviewRenderTarget2.prototype.getViewCount = function() {
    return 2;
  };
  return MultiviewRenderTarget2;
}(RenderTargetTexture);

// node_modules/@babylonjs/core/Engines/Extensions/engine.multiview.js
Engine.prototype.createMultiviewRenderTargetTexture = function(width, height) {
  var gl = this._gl;
  if (!this.getCaps().multiview) {
    throw "Multiview is not supported";
  }
  var internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);
  internalTexture.width = width;
  internalTexture.height = height;
  internalTexture._framebuffer = gl.createFramebuffer();
  internalTexture._colorTextureArray = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D_ARRAY, internalTexture._colorTextureArray);
  gl.texStorage3D(gl.TEXTURE_2D_ARRAY, 1, gl.RGBA8, width, height, 2);
  internalTexture._depthStencilTextureArray = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D_ARRAY, internalTexture._depthStencilTextureArray);
  gl.texStorage3D(gl.TEXTURE_2D_ARRAY, 1, gl.DEPTH32F_STENCIL8, width, height, 2);
  internalTexture.isReady = true;
  return internalTexture;
};
Engine.prototype.bindMultiviewFramebuffer = function(multiviewTexture) {
  var gl = this._gl;
  var ext = this.getCaps().oculusMultiview || this.getCaps().multiview;
  this.bindFramebuffer(multiviewTexture, void 0, void 0, void 0, true);
  gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, multiviewTexture._framebuffer);
  if (multiviewTexture._colorTextureArray && multiviewTexture._depthStencilTextureArray) {
    if (this.getCaps().oculusMultiview) {
      ext.framebufferTextureMultisampleMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, multiviewTexture._colorTextureArray, 0, multiviewTexture.samples, 0, 2);
      ext.framebufferTextureMultisampleMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, multiviewTexture._depthStencilTextureArray, 0, multiviewTexture.samples, 0, 2);
    } else {
      ext.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, multiviewTexture._colorTextureArray, 0, 0, 2);
      ext.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, multiviewTexture._depthStencilTextureArray, 0, 0, 2);
    }
  } else {
    throw "Invalid multiview frame buffer";
  }
};
Camera.prototype._useMultiviewToSingleView = false;
Camera.prototype._multiviewTexture = null;
Camera.prototype._resizeOrCreateMultiviewTexture = function(width, height) {
  if (!this._multiviewTexture) {
    this._multiviewTexture = new MultiviewRenderTarget(this.getScene(), { width, height });
  } else if (this._multiviewTexture.getRenderWidth() != width || this._multiviewTexture.getRenderHeight() != height) {
    this._multiviewTexture.dispose();
    this._multiviewTexture = new MultiviewRenderTarget(this.getScene(), { width, height });
  }
};
Scene.prototype._transformMatrixR = Matrix.Zero();
Scene.prototype._multiviewSceneUbo = null;
Scene.prototype._createMultiviewUbo = function() {
  this._multiviewSceneUbo = new UniformBuffer(this.getEngine(), void 0, true);
  this._multiviewSceneUbo.addUniform("viewProjection", 16);
  this._multiviewSceneUbo.addUniform("viewProjectionR", 16);
  this._multiviewSceneUbo.addUniform("view", 16);
};
Scene.prototype._updateMultiviewUbo = function(viewR, projectionR) {
  if (viewR && projectionR) {
    viewR.multiplyToRef(projectionR, this._transformMatrixR);
  }
  if (viewR && projectionR) {
    viewR.multiplyToRef(projectionR, TmpVectors.Matrix[0]);
    Frustum.GetRightPlaneToRef(TmpVectors.Matrix[0], this._frustumPlanes[3]);
  }
  if (this._multiviewSceneUbo) {
    this._multiviewSceneUbo.updateMatrix("viewProjection", this.getTransformMatrix());
    this._multiviewSceneUbo.updateMatrix("viewProjectionR", this._transformMatrixR);
    this._multiviewSceneUbo.updateMatrix("view", this._viewMatrix);
    this._multiviewSceneUbo.update();
  }
};
Scene.prototype._renderMultiviewToSingleView = function(camera) {
  camera._resizeOrCreateMultiviewTexture(camera._rigPostProcess && camera._rigPostProcess && camera._rigPostProcess.width > 0 ? camera._rigPostProcess.width : this.getEngine().getRenderWidth(true), camera._rigPostProcess && camera._rigPostProcess && camera._rigPostProcess.height > 0 ? camera._rigPostProcess.height : this.getEngine().getRenderHeight(true));
  if (!this._multiviewSceneUbo) {
    this._createMultiviewUbo();
  }
  camera.outputRenderTarget = camera._multiviewTexture;
  this._renderForCamera(camera);
  camera.outputRenderTarget = null;
  for (var index = 0; index < camera._rigCameras.length; index++) {
    var engine = this.getEngine();
    this._activeCamera = camera._rigCameras[index];
    engine.setViewport(this._activeCamera.viewport);
    if (this.postProcessManager) {
      this.postProcessManager._prepareFrame();
      this.postProcessManager._finalizeFrame(this._activeCamera.isIntermediate);
    }
  }
};

// node_modules/@babylonjs/core/PostProcesses/vrMultiviewToSingleviewPostProcess.js
var VRMultiviewToSingleviewPostProcess = function(_super) {
  __extends(VRMultiviewToSingleviewPostProcess2, _super);
  function VRMultiviewToSingleviewPostProcess2(name98, camera, scaleFactor) {
    var _this = _super.call(this, name98, "vrMultiviewToSingleview", ["imageIndex"], ["multiviewSampler"], scaleFactor, camera, Texture.BILINEAR_SAMPLINGMODE) || this;
    _this.onSizeChangedObservable.add(function() {
    });
    _this.onApplyObservable.add(function(effect) {
      if (camera._scene.activeCamera && camera._scene.activeCamera.isLeftCamera) {
        effect.setInt("imageIndex", 0);
      } else {
        effect.setInt("imageIndex", 1);
      }
      effect.setTexture("multiviewSampler", camera._multiviewTexture);
    });
    return _this;
  }
  VRMultiviewToSingleviewPostProcess2.prototype.getClassName = function() {
    return "VRMultiviewToSingleviewPostProcess";
  };
  return VRMultiviewToSingleviewPostProcess2;
}(PostProcess);

// node_modules/@babylonjs/core/Cameras/RigModes/vrRigMode.js
Camera._setVRRigMode = function(camera, rigParams) {
  var metrics = rigParams.vrCameraMetrics || VRCameraMetrics.GetDefault();
  camera._rigCameras[0]._cameraRigParams.vrMetrics = metrics;
  camera._rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1);
  camera._rigCameras[0]._cameraRigParams.vrWorkMatrix = new Matrix();
  camera._rigCameras[0]._cameraRigParams.vrHMatrix = metrics.leftHMatrix;
  camera._rigCameras[0]._cameraRigParams.vrPreViewMatrix = metrics.leftPreViewMatrix;
  camera._rigCameras[0].getProjectionMatrix = camera._rigCameras[0]._getVRProjectionMatrix;
  camera._rigCameras[1]._cameraRigParams.vrMetrics = metrics;
  camera._rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1);
  camera._rigCameras[1]._cameraRigParams.vrWorkMatrix = new Matrix();
  camera._rigCameras[1]._cameraRigParams.vrHMatrix = metrics.rightHMatrix;
  camera._rigCameras[1]._cameraRigParams.vrPreViewMatrix = metrics.rightPreViewMatrix;
  camera._rigCameras[1].getProjectionMatrix = camera._rigCameras[1]._getVRProjectionMatrix;
  if (metrics.multiviewEnabled) {
    if (!camera.getScene().getEngine().getCaps().multiview) {
      Logger.Warn("Multiview is not supported, falling back to standard rendering");
      metrics.multiviewEnabled = false;
    } else {
      camera._useMultiviewToSingleView = true;
      camera._rigPostProcess = new VRMultiviewToSingleviewPostProcess("VRMultiviewToSingleview", camera, metrics.postProcessScaleFactor);
    }
  }
  if (metrics.compensateDistortion) {
    camera._rigCameras[0]._rigPostProcess = new VRDistortionCorrectionPostProcess("VR_Distort_Compensation_Left", camera._rigCameras[0], false, metrics);
    camera._rigCameras[1]._rigPostProcess = new VRDistortionCorrectionPostProcess("VR_Distort_Compensation_Right", camera._rigCameras[1], true, metrics);
  }
};

// node_modules/@babylonjs/core/Cameras/VR/vrDeviceOrientationArcRotateCamera.js
Node2.AddNodeConstructor("VRDeviceOrientationFreeCamera", function(name98, scene) {
  return function() {
    return new VRDeviceOrientationArcRotateCamera(name98, 0, 0, 1, Vector3.Zero(), scene);
  };
});
var VRDeviceOrientationArcRotateCamera = function(_super) {
  __extends(VRDeviceOrientationArcRotateCamera2, _super);
  function VRDeviceOrientationArcRotateCamera2(name98, alpha, beta, radius, target, scene, compensateDistortion, vrCameraMetrics) {
    if (compensateDistortion === void 0) {
      compensateDistortion = true;
    }
    if (vrCameraMetrics === void 0) {
      vrCameraMetrics = VRCameraMetrics.GetDefault();
    }
    var _this = _super.call(this, name98, alpha, beta, radius, target, scene) || this;
    vrCameraMetrics.compensateDistortion = compensateDistortion;
    _this.setCameraRigMode(Camera.RIG_MODE_VR, { vrCameraMetrics });
    _this.inputs.addVRDeviceOrientation();
    return _this;
  }
  VRDeviceOrientationArcRotateCamera2.prototype.getClassName = function() {
    return "VRDeviceOrientationArcRotateCamera";
  };
  return VRDeviceOrientationArcRotateCamera2;
}(ArcRotateCamera);

// node_modules/@babylonjs/core/Cameras/VR/vrDeviceOrientationFreeCamera.js
Node2.AddNodeConstructor("VRDeviceOrientationFreeCamera", function(name98, scene) {
  return function() {
    return new VRDeviceOrientationFreeCamera(name98, Vector3.Zero(), scene);
  };
});
var VRDeviceOrientationFreeCamera = function(_super) {
  __extends(VRDeviceOrientationFreeCamera2, _super);
  function VRDeviceOrientationFreeCamera2(name98, position, scene, compensateDistortion, vrCameraMetrics) {
    if (compensateDistortion === void 0) {
      compensateDistortion = true;
    }
    if (vrCameraMetrics === void 0) {
      vrCameraMetrics = VRCameraMetrics.GetDefault();
    }
    var _this = _super.call(this, name98, position, scene) || this;
    vrCameraMetrics.compensateDistortion = compensateDistortion;
    _this.setCameraRigMode(Camera.RIG_MODE_VR, { vrCameraMetrics });
    return _this;
  }
  VRDeviceOrientationFreeCamera2.prototype.getClassName = function() {
    return "VRDeviceOrientationFreeCamera";
  };
  return VRDeviceOrientationFreeCamera2;
}(DeviceOrientationCamera);

// node_modules/@babylonjs/core/Cameras/VR/vrDeviceOrientationGamepadCamera.js
Node2.AddNodeConstructor("VRDeviceOrientationGamepadCamera", function(name98, scene) {
  return function() {
    return new VRDeviceOrientationGamepadCamera(name98, Vector3.Zero(), scene);
  };
});
var VRDeviceOrientationGamepadCamera = function(_super) {
  __extends(VRDeviceOrientationGamepadCamera2, _super);
  function VRDeviceOrientationGamepadCamera2(name98, position, scene, compensateDistortion, vrCameraMetrics) {
    if (compensateDistortion === void 0) {
      compensateDistortion = true;
    }
    if (vrCameraMetrics === void 0) {
      vrCameraMetrics = VRCameraMetrics.GetDefault();
    }
    var _this = _super.call(this, name98, position, scene, compensateDistortion, vrCameraMetrics) || this;
    _this.inputs.addGamepad();
    return _this;
  }
  VRDeviceOrientationGamepadCamera2.prototype.getClassName = function() {
    return "VRDeviceOrientationGamepadCamera";
  };
  return VRDeviceOrientationGamepadCamera2;
}(VRDeviceOrientationFreeCamera);

// node_modules/@babylonjs/core/Cameras/RigModes/webVRRigMode.js
Camera._setWebVRRigMode = function(camera, rigParams) {
  if (rigParams.vrDisplay) {
    var leftEye = rigParams.vrDisplay.getEyeParameters("left");
    var rightEye = rigParams.vrDisplay.getEyeParameters("right");
    camera._rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1);
    camera._rigCameras[0].setCameraRigParameter("left", true);
    camera._rigCameras[0].setCameraRigParameter("specs", rigParams.specs);
    camera._rigCameras[0].setCameraRigParameter("eyeParameters", leftEye);
    camera._rigCameras[0].setCameraRigParameter("frameData", rigParams.frameData);
    camera._rigCameras[0].setCameraRigParameter("parentCamera", rigParams.parentCamera);
    camera._rigCameras[0]._cameraRigParams.vrWorkMatrix = new Matrix();
    camera._rigCameras[0].getProjectionMatrix = camera._getWebVRProjectionMatrix;
    camera._rigCameras[0].parent = camera;
    camera._rigCameras[0]._getViewMatrix = camera._getWebVRViewMatrix;
    camera._rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1);
    camera._rigCameras[1].setCameraRigParameter("eyeParameters", rightEye);
    camera._rigCameras[1].setCameraRigParameter("specs", rigParams.specs);
    camera._rigCameras[1].setCameraRigParameter("frameData", rigParams.frameData);
    camera._rigCameras[1].setCameraRigParameter("parentCamera", rigParams.parentCamera);
    camera._rigCameras[1]._cameraRigParams.vrWorkMatrix = new Matrix();
    camera._rigCameras[1].getProjectionMatrix = camera._getWebVRProjectionMatrix;
    camera._rigCameras[1].parent = camera;
    camera._rigCameras[1]._getViewMatrix = camera._getWebVRViewMatrix;
  }
};

// node_modules/@babylonjs/core/Engines/Extensions/engine.webVR.js
Object.defineProperty(Engine.prototype, "isInVRExclusivePointerMode", {
  get: function() {
    return this._vrExclusivePointerMode;
  },
  enumerable: true,
  configurable: true
});
Engine.prototype._prepareVRComponent = function() {
  this._vrSupported = false;
  this._vrExclusivePointerMode = false;
  this.onVRDisplayChangedObservable = new Observable();
  this.onVRRequestPresentComplete = new Observable();
  this.onVRRequestPresentStart = new Observable();
};
Engine.prototype.isVRDevicePresent = function() {
  return !!this._vrDisplay;
};
Engine.prototype.getVRDevice = function() {
  return this._vrDisplay;
};
Engine.prototype.initWebVR = function() {
  this.initWebVRAsync();
  return this.onVRDisplayChangedObservable;
};
Engine.prototype.initWebVRAsync = function() {
  var _this = this;
  var notifyObservers = function() {
    var eventArgs = {
      vrDisplay: _this._vrDisplay,
      vrSupported: _this._vrSupported
    };
    _this.onVRDisplayChangedObservable.notifyObservers(eventArgs);
    _this._webVRInitPromise = new Promise(function(res) {
      res(eventArgs);
    });
  };
  if (!this._onVrDisplayConnect) {
    this._onVrDisplayConnect = function(event) {
      _this._vrDisplay = event.display;
      notifyObservers();
    };
    this._onVrDisplayDisconnect = function() {
      _this._vrDisplay.cancelAnimationFrame(_this._frameHandler);
      _this._vrDisplay = void 0;
      _this._frameHandler = Engine.QueueNewFrame(_this._boundRenderFunction);
      notifyObservers();
    };
    this._onVrDisplayPresentChange = function() {
      _this._vrExclusivePointerMode = _this._vrDisplay && _this._vrDisplay.isPresenting;
    };
    var hostWindow = this.getHostWindow();
    if (hostWindow) {
      hostWindow.addEventListener("vrdisplayconnect", this._onVrDisplayConnect);
      hostWindow.addEventListener("vrdisplaydisconnect", this._onVrDisplayDisconnect);
      hostWindow.addEventListener("vrdisplaypresentchange", this._onVrDisplayPresentChange);
    }
  }
  this._webVRInitPromise = this._webVRInitPromise || this._getVRDisplaysAsync();
  this._webVRInitPromise.then(notifyObservers);
  return this._webVRInitPromise;
};
Engine.prototype._getVRDisplaysAsync = function() {
  var _this = this;
  return new Promise(function(res) {
    if (navigator.getVRDisplays) {
      navigator.getVRDisplays().then(function(devices) {
        _this._vrSupported = true;
        _this._vrDisplay = devices[0];
        res({
          vrDisplay: _this._vrDisplay,
          vrSupported: _this._vrSupported
        });
      });
    } else {
      _this._vrDisplay = void 0;
      _this._vrSupported = false;
      res({
        vrDisplay: _this._vrDisplay,
        vrSupported: _this._vrSupported
      });
    }
  });
};
Engine.prototype.enableVR = function(options) {
  var _this = this;
  if (this._vrDisplay && !this._vrDisplay.isPresenting) {
    var onResolved = function() {
      _this.onVRRequestPresentComplete.notifyObservers(true);
      _this._onVRFullScreenTriggered();
    };
    var onRejected = function() {
      _this.onVRRequestPresentComplete.notifyObservers(false);
    };
    this.onVRRequestPresentStart.notifyObservers(this);
    var presentationAttributes = {
      highRefreshRate: this.vrPresentationAttributes ? this.vrPresentationAttributes.highRefreshRate : false,
      foveationLevel: this.vrPresentationAttributes ? this.vrPresentationAttributes.foveationLevel : 1,
      multiview: (this.getCaps().multiview || this.getCaps().oculusMultiview) && options.useMultiview
    };
    this._vrDisplay.requestPresent([__assign({ source: this.getRenderingCanvas(), attributes: presentationAttributes }, presentationAttributes)]).then(onResolved).catch(onRejected);
  }
};
Engine.prototype._onVRFullScreenTriggered = function() {
  if (this._vrDisplay && this._vrDisplay.isPresenting) {
    this._oldSize = new Size(this.getRenderWidth(), this.getRenderHeight());
    this._oldHardwareScaleFactor = this.getHardwareScalingLevel();
    var leftEye = this._vrDisplay.getEyeParameters("left");
    this.setHardwareScalingLevel(1);
    this.setSize(leftEye.renderWidth * 2, leftEye.renderHeight);
  } else {
    this.setHardwareScalingLevel(this._oldHardwareScaleFactor);
    this.setSize(this._oldSize.width, this._oldSize.height);
  }
};
Engine.prototype.disableVR = function() {
  var _this = this;
  if (this._vrDisplay && this._vrDisplay.isPresenting) {
    this._vrDisplay.exitPresent().then(function() {
      return _this._onVRFullScreenTriggered();
    }).catch(function() {
      return _this._onVRFullScreenTriggered();
    });
  }
  if (DomManagement.IsWindowObjectExist()) {
    window.removeEventListener("vrdisplaypointerrestricted", this._onVRDisplayPointerRestricted);
    window.removeEventListener("vrdisplaypointerunrestricted", this._onVRDisplayPointerUnrestricted);
    if (this._onVrDisplayConnect) {
      window.removeEventListener("vrdisplayconnect", this._onVrDisplayConnect);
      if (this._onVrDisplayDisconnect) {
        window.removeEventListener("vrdisplaydisconnect", this._onVrDisplayDisconnect);
      }
      if (this._onVrDisplayPresentChange) {
        window.removeEventListener("vrdisplaypresentchange", this._onVrDisplayPresentChange);
      }
      this._onVrDisplayConnect = null;
      this._onVrDisplayDisconnect = null;
    }
  }
};
Engine.prototype._connectVREvents = function(canvas, document2) {
  var _this = this;
  this._onVRDisplayPointerRestricted = function() {
    if (canvas) {
      canvas.requestPointerLock();
    }
  };
  this._onVRDisplayPointerUnrestricted = function() {
    if (!document2) {
      var hostWindow2 = _this.getHostWindow();
      if (hostWindow2.document && hostWindow2.document.exitPointerLock) {
        hostWindow2.document.exitPointerLock();
      }
      return;
    }
    if (!document2.exitPointerLock) {
      return;
    }
    document2.exitPointerLock();
  };
  if (DomManagement.IsWindowObjectExist()) {
    var hostWindow = this.getHostWindow();
    hostWindow.addEventListener("vrdisplaypointerrestricted", this._onVRDisplayPointerRestricted, false);
    hostWindow.addEventListener("vrdisplaypointerunrestricted", this._onVRDisplayPointerUnrestricted, false);
  }
};
Engine.prototype._submitVRFrame = function() {
  if (this._vrDisplay && this._vrDisplay.isPresenting) {
    try {
      this._vrDisplay.submitFrame();
    } catch (e) {
      Tools.Warn("webVR submitFrame has had an unexpected failure: " + e);
    }
  }
};
Engine.prototype.isVRPresenting = function() {
  return this._vrDisplay && this._vrDisplay.isPresenting;
};
Engine.prototype._requestVRFrame = function() {
  this._frameHandler = Engine.QueueNewFrame(this._boundRenderFunction, this._vrDisplay);
};

// node_modules/@babylonjs/core/Cameras/VR/webVRCamera.js
Node2.AddNodeConstructor("WebVRFreeCamera", function(name98, scene) {
  return function() {
    return new WebVRFreeCamera(name98, Vector3.Zero(), scene);
  };
});
Node2.AddNodeConstructor("WebVRGamepadCamera", function(name98, scene) {
  return function() {
    return new WebVRFreeCamera(name98, Vector3.Zero(), scene);
  };
});
var WebVRFreeCamera = function(_super) {
  __extends(WebVRFreeCamera2, _super);
  function WebVRFreeCamera2(name98, position, scene, webVROptions) {
    if (webVROptions === void 0) {
      webVROptions = {};
    }
    var _this = _super.call(this, name98, position, scene) || this;
    _this.webVROptions = webVROptions;
    _this._vrDevice = null;
    _this.rawPose = null;
    _this._specsVersion = "1.1";
    _this._attached = false;
    _this._descendants = [];
    _this._deviceRoomPosition = Vector3.Zero();
    _this._deviceRoomRotationQuaternion = Quaternion.Identity();
    _this._standingMatrix = null;
    _this.devicePosition = Vector3.Zero();
    _this.deviceRotationQuaternion = Quaternion.Identity();
    _this.deviceScaleFactor = 1;
    _this._deviceToWorld = Matrix.Identity();
    _this._worldToDevice = Matrix.Identity();
    _this.controllers = [];
    _this.onControllersAttachedObservable = new Observable();
    _this.onControllerMeshLoadedObservable = new Observable();
    _this.onPoseUpdatedFromDeviceObservable = new Observable();
    _this._poseSet = false;
    _this.rigParenting = true;
    _this._defaultHeight = void 0;
    _this._detachIfAttached = function() {
      var vrDisplay = _this.getEngine().getVRDevice();
      if (vrDisplay && !vrDisplay.isPresenting) {
        _this.detachControl();
      }
    };
    _this._workingVector = Vector3.Zero();
    _this._oneVector = Vector3.One();
    _this._workingMatrix = Matrix.Identity();
    _this._tmpMatrix = new Matrix();
    _this._cache.position = Vector3.Zero();
    if (webVROptions.defaultHeight) {
      _this._defaultHeight = webVROptions.defaultHeight;
      _this.position.y = _this._defaultHeight;
    }
    _this.minZ = 0.1;
    if (arguments.length === 5) {
      _this.webVROptions = arguments[4];
    }
    if (_this.webVROptions.trackPosition == void 0) {
      _this.webVROptions.trackPosition = true;
    }
    if (_this.webVROptions.controllerMeshes == void 0) {
      _this.webVROptions.controllerMeshes = true;
    }
    if (_this.webVROptions.defaultLightingOnControllers == void 0) {
      _this.webVROptions.defaultLightingOnControllers = true;
    }
    _this.rotationQuaternion = new Quaternion();
    if (_this.webVROptions && _this.webVROptions.positionScale) {
      _this.deviceScaleFactor = _this.webVROptions.positionScale;
    }
    var engine = _this.getEngine();
    _this._onVREnabled = function(success) {
      if (success) {
        _this.initControllers();
      }
    };
    engine.onVRRequestPresentComplete.add(_this._onVREnabled);
    engine.initWebVR().add(function(event) {
      if (!event.vrDisplay || _this._vrDevice === event.vrDisplay) {
        return;
      }
      _this._vrDevice = event.vrDisplay;
      _this.setCameraRigMode(Camera.RIG_MODE_WEBVR, { parentCamera: _this, vrDisplay: _this._vrDevice, frameData: _this._frameData, specs: _this._specsVersion });
      if (_this._attached) {
        _this.getEngine().enableVR(_this.webVROptions);
      }
    });
    if (typeof VRFrameData !== "undefined") {
      _this._frameData = new VRFrameData();
    }
    if (webVROptions.useMultiview) {
      if (!_this.getScene().getEngine().getCaps().multiview) {
        Logger.Warn("Multiview is not supported, falling back to standard rendering");
        _this._useMultiviewToSingleView = false;
      } else {
        _this._useMultiviewToSingleView = true;
        _this._rigPostProcess = new VRMultiviewToSingleviewPostProcess("VRMultiviewToSingleview", _this, 1);
      }
    }
    scene.onBeforeCameraRenderObservable.add(function(camera) {
      if (camera.parent === _this && _this.rigParenting) {
        _this._descendants = _this.getDescendants(true, function(n) {
          var isController = _this.controllers.some(function(controller) {
            return controller._mesh === n;
          });
          var isRigCamera = _this._rigCameras.indexOf(n) !== -1;
          return !isController && !isRigCamera;
        });
        _this._descendants.forEach(function(node) {
          node.parent = camera;
        });
      }
    });
    scene.onAfterCameraRenderObservable.add(function(camera) {
      if (camera.parent === _this && _this.rigParenting) {
        _this._descendants.forEach(function(node) {
          node.parent = _this;
        });
      }
    });
    return _this;
  }
  WebVRFreeCamera2.prototype.deviceDistanceToRoomGround = function() {
    if (this._standingMatrix) {
      this._standingMatrix.getTranslationToRef(this._workingVector);
      return this._deviceRoomPosition.y + this._workingVector.y;
    }
    return this._defaultHeight || 0;
  };
  WebVRFreeCamera2.prototype.useStandingMatrix = function(callback) {
    var _this = this;
    if (callback === void 0) {
      callback = function(bool) {
      };
    }
    this.getEngine().initWebVRAsync().then(function(result) {
      if (!result.vrDisplay || !result.vrDisplay.stageParameters || !result.vrDisplay.stageParameters.sittingToStandingTransform || !_this.webVROptions.trackPosition) {
        callback(false);
      } else {
        _this._standingMatrix = new Matrix();
        Matrix.FromFloat32ArrayToRefScaled(result.vrDisplay.stageParameters.sittingToStandingTransform, 0, 1, _this._standingMatrix);
        if (!_this.getScene().useRightHandedSystem) {
          if (_this._standingMatrix) {
            _this._standingMatrix.toggleModelMatrixHandInPlace();
          }
        }
        callback(true);
      }
    });
  };
  WebVRFreeCamera2.prototype.useStandingMatrixAsync = function() {
    var _this = this;
    return new Promise(function(res) {
      _this.useStandingMatrix(function(supported) {
        res(supported);
      });
    });
  };
  WebVRFreeCamera2.prototype.dispose = function() {
    this._detachIfAttached();
    this.getEngine().onVRRequestPresentComplete.removeCallback(this._onVREnabled);
    if (this._updateCacheWhenTrackingDisabledObserver) {
      this._scene.onBeforeRenderObservable.remove(this._updateCacheWhenTrackingDisabledObserver);
    }
    _super.prototype.dispose.call(this);
  };
  WebVRFreeCamera2.prototype.getControllerByName = function(name98) {
    for (var _i = 0, _a = this.controllers; _i < _a.length; _i++) {
      var gp = _a[_i];
      if (gp.hand === name98) {
        return gp;
      }
    }
    return null;
  };
  Object.defineProperty(WebVRFreeCamera2.prototype, "leftController", {
    get: function() {
      if (!this._leftController) {
        this._leftController = this.getControllerByName("left");
      }
      return this._leftController;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebVRFreeCamera2.prototype, "rightController", {
    get: function() {
      if (!this._rightController) {
        this._rightController = this.getControllerByName("right");
      }
      return this._rightController;
    },
    enumerable: false,
    configurable: true
  });
  WebVRFreeCamera2.prototype.getForwardRay = function(length) {
    if (length === void 0) {
      length = 100;
    }
    if (this.leftCamera) {
      return _super.prototype.getForwardRay.call(this, length, this.leftCamera.getWorldMatrix(), this.leftCamera.globalPosition);
    } else {
      return _super.prototype.getForwardRay.call(this, length);
    }
  };
  WebVRFreeCamera2.prototype._checkInputs = function() {
    if (this._vrDevice && this._vrDevice.isPresenting) {
      this._vrDevice.getFrameData(this._frameData);
      this.updateFromDevice(this._frameData.pose);
    }
    _super.prototype._checkInputs.call(this);
  };
  WebVRFreeCamera2.prototype.updateFromDevice = function(poseData) {
    if (poseData && poseData.orientation && poseData.orientation.length === 4) {
      this.rawPose = poseData;
      this._deviceRoomRotationQuaternion.copyFromFloats(poseData.orientation[0], poseData.orientation[1], -poseData.orientation[2], -poseData.orientation[3]);
      if (this.getScene().useRightHandedSystem) {
        this._deviceRoomRotationQuaternion.z *= -1;
        this._deviceRoomRotationQuaternion.w *= -1;
      }
      if (this.webVROptions.trackPosition && this.rawPose.position) {
        this._deviceRoomPosition.copyFromFloats(this.rawPose.position[0], this.rawPose.position[1], -this.rawPose.position[2]);
        if (this.getScene().useRightHandedSystem) {
          this._deviceRoomPosition.z *= -1;
        }
      }
      this._poseSet = true;
    }
  };
  WebVRFreeCamera2.prototype.attachControl = function(noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    _super.prototype.attachControl.call(this, noPreventDefault);
    this._attached = true;
    noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;
    if (this._vrDevice) {
      this.getEngine().enableVR(this.webVROptions);
    }
    var hostWindow = this._scene.getEngine().getHostWindow();
    if (hostWindow) {
      hostWindow.addEventListener("vrdisplaypresentchange", this._detachIfAttached);
    }
  };
  WebVRFreeCamera2.prototype.detachControl = function(ignored) {
    this.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);
    this.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);
    _super.prototype.detachControl.call(this);
    this._attached = false;
    this.getEngine().disableVR();
    window.removeEventListener("vrdisplaypresentchange", this._detachIfAttached);
  };
  WebVRFreeCamera2.prototype.getClassName = function() {
    return "WebVRFreeCamera";
  };
  WebVRFreeCamera2.prototype.resetToCurrentRotation = function() {
    this._vrDevice.resetPose();
  };
  WebVRFreeCamera2.prototype._updateRigCameras = function() {
    var camLeft = this._rigCameras[0];
    var camRight = this._rigCameras[1];
    camLeft.rotationQuaternion.copyFrom(this._deviceRoomRotationQuaternion);
    camRight.rotationQuaternion.copyFrom(this._deviceRoomRotationQuaternion);
    camLeft.position.copyFrom(this._deviceRoomPosition);
    camRight.position.copyFrom(this._deviceRoomPosition);
  };
  WebVRFreeCamera2.prototype._correctPositionIfNotTrackPosition = function(matrix, isViewMatrix) {
    if (isViewMatrix === void 0) {
      isViewMatrix = false;
    }
    if (this.rawPose && this.rawPose.position && !this.webVROptions.trackPosition) {
      Matrix.TranslationToRef(this.rawPose.position[0], this.rawPose.position[1], -this.rawPose.position[2], this._tmpMatrix);
      if (!isViewMatrix) {
        this._tmpMatrix.invert();
      }
      this._tmpMatrix.multiplyToRef(matrix, matrix);
    }
  };
  WebVRFreeCamera2.prototype._updateCache = function(ignoreParentClass) {
    var _this = this;
    if (!this.rotationQuaternion.equals(this._cache.rotationQuaternion) || !this.position.equals(this._cache.position)) {
      if (!this.updateCacheCalled) {
        this.updateCacheCalled = true;
        this.update();
      }
      this.rotationQuaternion.toRotationMatrix(this._workingMatrix);
      Vector3.TransformCoordinatesToRef(this._deviceRoomPosition, this._workingMatrix, this._workingVector);
      this.devicePosition.subtractToRef(this._workingVector, this._workingVector);
      Matrix.ComposeToRef(this._oneVector, this.rotationQuaternion, this._workingVector, this._deviceToWorld);
      this._deviceToWorld.getTranslationToRef(this._workingVector);
      this._workingVector.addInPlace(this.position);
      this._workingVector.subtractInPlace(this._cache.position);
      this._deviceToWorld.setTranslation(this._workingVector);
      this._deviceToWorld.invertToRef(this._worldToDevice);
      this.controllers.forEach(function(controller) {
        controller._deviceToWorld.copyFrom(_this._deviceToWorld);
        _this._correctPositionIfNotTrackPosition(controller._deviceToWorld);
        controller.update();
      });
    }
    if (!ignoreParentClass) {
      _super.prototype._updateCache.call(this);
    }
    this.updateCacheCalled = false;
  };
  WebVRFreeCamera2.prototype._computeDevicePosition = function() {
    Vector3.TransformCoordinatesToRef(this._deviceRoomPosition, this._deviceToWorld, this.devicePosition);
  };
  WebVRFreeCamera2.prototype.update = function() {
    this._computeDevicePosition();
    Matrix.FromQuaternionToRef(this._deviceRoomRotationQuaternion, this._workingMatrix);
    this._workingMatrix.multiplyToRef(this._deviceToWorld, this._workingMatrix);
    Quaternion.FromRotationMatrixToRef(this._workingMatrix, this.deviceRotationQuaternion);
    if (this._poseSet) {
      this.onPoseUpdatedFromDeviceObservable.notifyObservers(null);
    }
    _super.prototype.update.call(this);
  };
  WebVRFreeCamera2.prototype._getViewMatrix = function() {
    return Matrix.Identity();
  };
  WebVRFreeCamera2.prototype._getWebVRViewMatrix = function() {
    var parentCamera = this._cameraRigParams["parentCamera"];
    parentCamera._updateCache();
    var viewArray = this._cameraRigParams["left"] ? this._cameraRigParams["frameData"].leftViewMatrix : this._cameraRigParams["frameData"].rightViewMatrix;
    Matrix.FromArrayToRef(viewArray, 0, this._webvrViewMatrix);
    if (!this.getScene().useRightHandedSystem) {
      this._webvrViewMatrix.toggleModelMatrixHandInPlace();
    }
    this._webvrViewMatrix.getRotationMatrixToRef(this._cameraRotationMatrix);
    Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);
    this.position.addToRef(this._transformedReferencePoint, this._currentTarget);
    if (parentCamera.deviceScaleFactor !== 1) {
      this._webvrViewMatrix.invert();
      if (parentCamera.deviceScaleFactor) {
        this._webvrViewMatrix.multiplyAtIndex(12, parentCamera.deviceScaleFactor);
        this._webvrViewMatrix.multiplyAtIndex(13, parentCamera.deviceScaleFactor);
        this._webvrViewMatrix.multiplyAtIndex(14, parentCamera.deviceScaleFactor);
      }
      this._webvrViewMatrix.invert();
    }
    parentCamera._correctPositionIfNotTrackPosition(this._webvrViewMatrix, true);
    parentCamera._worldToDevice.multiplyToRef(this._webvrViewMatrix, this._webvrViewMatrix);
    this._workingMatrix = this._workingMatrix || Matrix.Identity();
    this._webvrViewMatrix.invertToRef(this._workingMatrix);
    this._workingMatrix.multiplyToRef(parentCamera.getWorldMatrix(), this._workingMatrix);
    this._workingMatrix.getTranslationToRef(this._globalPosition);
    this._markSyncedWithParent();
    return this._webvrViewMatrix;
  };
  WebVRFreeCamera2.prototype._getWebVRProjectionMatrix = function() {
    var parentCamera = this.parent;
    parentCamera._vrDevice.depthNear = parentCamera.minZ;
    parentCamera._vrDevice.depthFar = parentCamera.maxZ;
    var projectionArray = this._cameraRigParams["left"] ? this._cameraRigParams["frameData"].leftProjectionMatrix : this._cameraRigParams["frameData"].rightProjectionMatrix;
    Matrix.FromArrayToRef(projectionArray, 0, this._projectionMatrix);
    if (!this.getScene().useRightHandedSystem) {
      this._projectionMatrix.toggleProjectionMatrixHandInPlace();
    }
    return this._projectionMatrix;
  };
  WebVRFreeCamera2.prototype.initControllers = function() {
    var _this = this;
    this.controllers = [];
    var manager = this.getScene().gamepadManager;
    this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add(function(gamepad) {
      if (gamepad.type === Gamepad.POSE_ENABLED) {
        var webVrController = gamepad;
        if (webVrController.defaultModel) {
          webVrController.defaultModel.setEnabled(false);
        }
        if (webVrController.hand === "right") {
          _this._rightController = null;
        }
        if (webVrController.hand === "left") {
          _this._leftController = null;
        }
        var controllerIndex = _this.controllers.indexOf(webVrController);
        if (controllerIndex !== -1) {
          _this.controllers.splice(controllerIndex, 1);
        }
      }
    });
    this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add(function(gamepad) {
      if (gamepad.type === Gamepad.POSE_ENABLED) {
        var webVrController_1 = gamepad;
        if (!_this.webVROptions.trackPosition) {
          webVrController_1._disableTrackPosition(new Vector3(webVrController_1.hand == "left" ? -0.15 : 0.15, -0.5, 0.25));
          if (!_this._updateCacheWhenTrackingDisabledObserver) {
            _this._updateCacheWhenTrackingDisabledObserver = _this._scene.onBeforeRenderObservable.add(function() {
              _this._updateCache();
            });
          }
        }
        webVrController_1.deviceScaleFactor = _this.deviceScaleFactor;
        webVrController_1._deviceToWorld.copyFrom(_this._deviceToWorld);
        _this._correctPositionIfNotTrackPosition(webVrController_1._deviceToWorld);
        if (_this.webVROptions.controllerMeshes) {
          if (webVrController_1.defaultModel) {
            webVrController_1.defaultModel.setEnabled(true);
          } else {
            webVrController_1.initControllerMesh(_this.getScene(), function(loadedMesh) {
              loadedMesh.scaling.scaleInPlace(_this.deviceScaleFactor);
              _this.onControllerMeshLoadedObservable.notifyObservers(webVrController_1);
              if (_this.webVROptions.defaultLightingOnControllers) {
                if (!_this._lightOnControllers) {
                  _this._lightOnControllers = new HemisphericLight("vrControllersLight", new Vector3(0, 1, 0), _this.getScene());
                }
                var activateLightOnSubMeshes_1 = function(mesh, light) {
                  var children = mesh.getChildren();
                  if (children && children.length !== 0) {
                    children.forEach(function(mesh2) {
                      light.includedOnlyMeshes.push(mesh2);
                      activateLightOnSubMeshes_1(mesh2, light);
                    });
                  }
                };
                _this._lightOnControllers.includedOnlyMeshes.push(loadedMesh);
                activateLightOnSubMeshes_1(loadedMesh, _this._lightOnControllers);
              }
            });
          }
        }
        webVrController_1.attachToPoseControlledCamera(_this);
        if (_this.controllers.indexOf(webVrController_1) === -1) {
          _this.controllers.push(webVrController_1);
          var firstViveWandDetected = false;
          for (var i = 0; i < _this.controllers.length; i++) {
            if (_this.controllers[i].controllerType === PoseEnabledControllerType.VIVE) {
              if (!firstViveWandDetected) {
                firstViveWandDetected = true;
                _this.controllers[i].hand = "left";
              } else {
                _this.controllers[i].hand = "right";
              }
            }
          }
          if (_this.controllers.length >= 2) {
            _this.onControllersAttachedObservable.notifyObservers(_this.controllers);
          }
        }
      }
    });
  };
  return WebVRFreeCamera2;
}(FreeCamera);

// node_modules/@babylonjs/core/Gamepads/Controllers/webVRController.js
var WebVRController = function(_super) {
  __extends(WebVRController2, _super);
  function WebVRController2(vrGamepad) {
    var _this = _super.call(this, vrGamepad) || this;
    _this.onTriggerStateChangedObservable = new Observable();
    _this.onMainButtonStateChangedObservable = new Observable();
    _this.onSecondaryButtonStateChangedObservable = new Observable();
    _this.onPadStateChangedObservable = new Observable();
    _this.onPadValuesChangedObservable = new Observable();
    _this.pad = { x: 0, y: 0 };
    _this._changes = {
      pressChanged: false,
      touchChanged: false,
      valueChanged: false,
      changed: false
    };
    _this._buttons = new Array(vrGamepad.buttons.length);
    _this.hand = vrGamepad.hand;
    return _this;
  }
  WebVRController2.prototype.onButtonStateChange = function(callback) {
    this._onButtonStateChange = callback;
  };
  Object.defineProperty(WebVRController2.prototype, "defaultModel", {
    get: function() {
      return this._defaultModel;
    },
    enumerable: false,
    configurable: true
  });
  WebVRController2.prototype.update = function() {
    _super.prototype.update.call(this);
    for (var index = 0; index < this._buttons.length; index++) {
      this._setButtonValue(this.browserGamepad.buttons[index], this._buttons[index], index);
    }
    if (this.leftStick.x !== this.pad.x || this.leftStick.y !== this.pad.y) {
      this.pad.x = this.leftStick.x;
      this.pad.y = this.leftStick.y;
      this.onPadValuesChangedObservable.notifyObservers(this.pad);
    }
  };
  WebVRController2.prototype._setButtonValue = function(newState, currentState, buttonIndex) {
    if (!newState) {
      newState = {
        pressed: false,
        touched: false,
        value: 0
      };
    }
    if (!currentState) {
      this._buttons[buttonIndex] = {
        pressed: newState.pressed,
        touched: newState.touched,
        value: newState.value
      };
      return;
    }
    this._checkChanges(newState, currentState);
    if (this._changes.changed) {
      this._onButtonStateChange && this._onButtonStateChange(this.index, buttonIndex, newState);
      this._handleButtonChange(buttonIndex, newState, this._changes);
    }
    this._buttons[buttonIndex].pressed = newState.pressed;
    this._buttons[buttonIndex].touched = newState.touched;
    this._buttons[buttonIndex].value = newState.value < 1e-8 ? 0 : newState.value;
  };
  WebVRController2.prototype._checkChanges = function(newState, currentState) {
    this._changes.pressChanged = newState.pressed !== currentState.pressed;
    this._changes.touchChanged = newState.touched !== currentState.touched;
    this._changes.valueChanged = newState.value !== currentState.value;
    this._changes.changed = this._changes.pressChanged || this._changes.touchChanged || this._changes.valueChanged;
    return this._changes;
  };
  WebVRController2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this._defaultModel = null;
    this.onTriggerStateChangedObservable.clear();
    this.onMainButtonStateChangedObservable.clear();
    this.onSecondaryButtonStateChangedObservable.clear();
    this.onPadStateChangedObservable.clear();
    this.onPadValuesChangedObservable.clear();
  };
  return WebVRController2;
}(PoseEnabledController);

// node_modules/@babylonjs/core/Shaders/imageProcessing.fragment.js
var name6 = "imageProcessingPixelShader";
var shader6 = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n#include<imageProcessingDeclaration>\n#include<helperFunctions>\n#include<imageProcessingFunctions>\nvoid main(void)\n{\nvec4 result=texture2D(textureSampler,vUV);\n#ifdef IMAGEPROCESSING\n#ifndef FROMLINEARSPACE\n\nresult.rgb=toLinearSpace(result.rgb);\n#endif\nresult=applyImageProcessing(result);\n#else\n\n#ifdef FROMLINEARSPACE\nresult=applyImageProcessing(result);\n#endif\n#endif\ngl_FragColor=result;\n}";
Effect.ShadersStore[name6] = shader6;

// node_modules/@babylonjs/core/PostProcesses/imageProcessingPostProcess.js
var ImageProcessingPostProcess = function(_super) {
  __extends(ImageProcessingPostProcess2, _super);
  function ImageProcessingPostProcess2(name98, options, camera, samplingMode, engine, reusable, textureType, imageProcessingConfiguration) {
    if (camera === void 0) {
      camera = null;
    }
    if (textureType === void 0) {
      textureType = 0;
    }
    var _this = _super.call(this, name98, "imageProcessing", [], [], options, camera, samplingMode, engine, reusable, null, textureType, "postprocess", null, true) || this;
    _this._fromLinearSpace = true;
    _this._defines = {
      IMAGEPROCESSING: false,
      VIGNETTE: false,
      VIGNETTEBLENDMODEMULTIPLY: false,
      VIGNETTEBLENDMODEOPAQUE: false,
      TONEMAPPING: false,
      TONEMAPPING_ACES: false,
      CONTRAST: false,
      COLORCURVES: false,
      COLORGRADING: false,
      COLORGRADING3D: false,
      FROMLINEARSPACE: false,
      SAMPLER3DGREENDEPTH: false,
      SAMPLER3DBGRMAP: false,
      IMAGEPROCESSINGPOSTPROCESS: false,
      EXPOSURE: false
    };
    if (imageProcessingConfiguration) {
      imageProcessingConfiguration.applyByPostProcess = true;
      _this._attachImageProcessingConfiguration(imageProcessingConfiguration, true);
      _this.fromLinearSpace = false;
    } else {
      _this._attachImageProcessingConfiguration(null, true);
      _this.imageProcessingConfiguration.applyByPostProcess = true;
    }
    _this.onApply = function(effect) {
      _this.imageProcessingConfiguration.bind(effect, _this.aspectRatio);
    };
    return _this;
  }
  Object.defineProperty(ImageProcessingPostProcess2.prototype, "imageProcessingConfiguration", {
    get: function() {
      return this._imageProcessingConfiguration;
    },
    set: function(value) {
      value.applyByPostProcess = true;
      this._attachImageProcessingConfiguration(value);
    },
    enumerable: false,
    configurable: true
  });
  ImageProcessingPostProcess2.prototype._attachImageProcessingConfiguration = function(configuration, doNotBuild) {
    var _this = this;
    if (doNotBuild === void 0) {
      doNotBuild = false;
    }
    if (configuration === this._imageProcessingConfiguration) {
      return;
    }
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    if (!configuration) {
      var scene = null;
      var engine = this.getEngine();
      var camera = this.getCamera();
      if (camera) {
        scene = camera.getScene();
      } else if (engine && engine.scenes) {
        var scenes = engine.scenes;
        scene = scenes[scenes.length - 1];
      } else {
        scene = EngineStore.LastCreatedScene;
      }
      if (scene) {
        this._imageProcessingConfiguration = scene.imageProcessingConfiguration;
      } else {
        this._imageProcessingConfiguration = new ImageProcessingConfiguration();
      }
    } else {
      this._imageProcessingConfiguration = configuration;
    }
    if (this._imageProcessingConfiguration) {
      this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(function() {
        _this._updateParameters();
      });
    }
    if (!doNotBuild) {
      this._updateParameters();
    }
  };
  Object.defineProperty(ImageProcessingPostProcess2.prototype, "isSupported", {
    get: function() {
      var effect = this.getEffect();
      return !effect || effect.isSupported;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingPostProcess2.prototype, "colorCurves", {
    get: function() {
      return this.imageProcessingConfiguration.colorCurves;
    },
    set: function(value) {
      this.imageProcessingConfiguration.colorCurves = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingPostProcess2.prototype, "colorCurvesEnabled", {
    get: function() {
      return this.imageProcessingConfiguration.colorCurvesEnabled;
    },
    set: function(value) {
      this.imageProcessingConfiguration.colorCurvesEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingPostProcess2.prototype, "colorGradingTexture", {
    get: function() {
      return this.imageProcessingConfiguration.colorGradingTexture;
    },
    set: function(value) {
      this.imageProcessingConfiguration.colorGradingTexture = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingPostProcess2.prototype, "colorGradingEnabled", {
    get: function() {
      return this.imageProcessingConfiguration.colorGradingEnabled;
    },
    set: function(value) {
      this.imageProcessingConfiguration.colorGradingEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingPostProcess2.prototype, "exposure", {
    get: function() {
      return this.imageProcessingConfiguration.exposure;
    },
    set: function(value) {
      this.imageProcessingConfiguration.exposure = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingPostProcess2.prototype, "toneMappingEnabled", {
    get: function() {
      return this._imageProcessingConfiguration.toneMappingEnabled;
    },
    set: function(value) {
      this._imageProcessingConfiguration.toneMappingEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingPostProcess2.prototype, "toneMappingType", {
    get: function() {
      return this._imageProcessingConfiguration.toneMappingType;
    },
    set: function(value) {
      this._imageProcessingConfiguration.toneMappingType = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingPostProcess2.prototype, "contrast", {
    get: function() {
      return this.imageProcessingConfiguration.contrast;
    },
    set: function(value) {
      this.imageProcessingConfiguration.contrast = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingPostProcess2.prototype, "vignetteStretch", {
    get: function() {
      return this.imageProcessingConfiguration.vignetteStretch;
    },
    set: function(value) {
      this.imageProcessingConfiguration.vignetteStretch = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingPostProcess2.prototype, "vignetteCentreX", {
    get: function() {
      return this.imageProcessingConfiguration.vignetteCentreX;
    },
    set: function(value) {
      this.imageProcessingConfiguration.vignetteCentreX = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingPostProcess2.prototype, "vignetteCentreY", {
    get: function() {
      return this.imageProcessingConfiguration.vignetteCentreY;
    },
    set: function(value) {
      this.imageProcessingConfiguration.vignetteCentreY = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingPostProcess2.prototype, "vignetteWeight", {
    get: function() {
      return this.imageProcessingConfiguration.vignetteWeight;
    },
    set: function(value) {
      this.imageProcessingConfiguration.vignetteWeight = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingPostProcess2.prototype, "vignetteColor", {
    get: function() {
      return this.imageProcessingConfiguration.vignetteColor;
    },
    set: function(value) {
      this.imageProcessingConfiguration.vignetteColor = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingPostProcess2.prototype, "vignetteCameraFov", {
    get: function() {
      return this.imageProcessingConfiguration.vignetteCameraFov;
    },
    set: function(value) {
      this.imageProcessingConfiguration.vignetteCameraFov = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingPostProcess2.prototype, "vignetteBlendMode", {
    get: function() {
      return this.imageProcessingConfiguration.vignetteBlendMode;
    },
    set: function(value) {
      this.imageProcessingConfiguration.vignetteBlendMode = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingPostProcess2.prototype, "vignetteEnabled", {
    get: function() {
      return this.imageProcessingConfiguration.vignetteEnabled;
    },
    set: function(value) {
      this.imageProcessingConfiguration.vignetteEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingPostProcess2.prototype, "fromLinearSpace", {
    get: function() {
      return this._fromLinearSpace;
    },
    set: function(value) {
      if (this._fromLinearSpace === value) {
        return;
      }
      this._fromLinearSpace = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  ImageProcessingPostProcess2.prototype.getClassName = function() {
    return "ImageProcessingPostProcess";
  };
  ImageProcessingPostProcess2.prototype._updateParameters = function() {
    this._defines.FROMLINEARSPACE = this._fromLinearSpace;
    this.imageProcessingConfiguration.prepareDefines(this._defines, true);
    var defines = "";
    for (var define in this._defines) {
      if (this._defines[define]) {
        defines += "#define " + define + ";\r\n";
      }
    }
    var samplers = ["textureSampler"];
    var uniforms = ["scale"];
    if (ImageProcessingConfiguration) {
      ImageProcessingConfiguration.PrepareSamplers(samplers, this._defines);
      ImageProcessingConfiguration.PrepareUniforms(uniforms, this._defines);
    }
    this.updateEffect(defines, uniforms, samplers);
  };
  ImageProcessingPostProcess2.prototype.dispose = function(camera) {
    _super.prototype.dispose.call(this, camera);
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    if (this._imageProcessingConfiguration) {
      this.imageProcessingConfiguration.applyByPostProcess = false;
    }
  };
  __decorate([
    serialize()
  ], ImageProcessingPostProcess2.prototype, "_fromLinearSpace", void 0);
  return ImageProcessingPostProcess2;
}(PostProcess);

// node_modules/@babylonjs/core/Meshes/groundMesh.js
Mesh._GroundMeshParser = function(parsedMesh, scene) {
  return GroundMesh.Parse(parsedMesh, scene);
};
var GroundMesh = function(_super) {
  __extends(GroundMesh2, _super);
  function GroundMesh2(name98, scene) {
    var _this = _super.call(this, name98, scene) || this;
    _this.generateOctree = false;
    return _this;
  }
  GroundMesh2.prototype.getClassName = function() {
    return "GroundMesh";
  };
  Object.defineProperty(GroundMesh2.prototype, "subdivisions", {
    get: function() {
      return Math.min(this._subdivisionsX, this._subdivisionsY);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GroundMesh2.prototype, "subdivisionsX", {
    get: function() {
      return this._subdivisionsX;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GroundMesh2.prototype, "subdivisionsY", {
    get: function() {
      return this._subdivisionsY;
    },
    enumerable: false,
    configurable: true
  });
  GroundMesh2.prototype.optimize = function(chunksCount, octreeBlocksSize) {
    if (octreeBlocksSize === void 0) {
      octreeBlocksSize = 32;
    }
    this._subdivisionsX = chunksCount;
    this._subdivisionsY = chunksCount;
    this.subdivide(chunksCount);
    var thisAsAny = this;
    if (thisAsAny.createOrUpdateSubmeshesOctree) {
      thisAsAny.createOrUpdateSubmeshesOctree(octreeBlocksSize);
    }
  };
  GroundMesh2.prototype.getHeightAtCoordinates = function(x, z) {
    var world = this.getWorldMatrix();
    var invMat = TmpVectors.Matrix[5];
    world.invertToRef(invMat);
    var tmpVect = TmpVectors.Vector3[8];
    Vector3.TransformCoordinatesFromFloatsToRef(x, 0, z, invMat, tmpVect);
    x = tmpVect.x;
    z = tmpVect.z;
    if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {
      return this.position.y;
    }
    if (!this._heightQuads || this._heightQuads.length == 0) {
      this._initHeightQuads();
      this._computeHeightQuads();
    }
    var facet = this._getFacetAt(x, z);
    var y = -(facet.x * x + facet.z * z + facet.w) / facet.y;
    Vector3.TransformCoordinatesFromFloatsToRef(0, y, 0, world, tmpVect);
    return tmpVect.y;
  };
  GroundMesh2.prototype.getNormalAtCoordinates = function(x, z) {
    var normal = new Vector3(0, 1, 0);
    this.getNormalAtCoordinatesToRef(x, z, normal);
    return normal;
  };
  GroundMesh2.prototype.getNormalAtCoordinatesToRef = function(x, z, ref) {
    var world = this.getWorldMatrix();
    var tmpMat = TmpVectors.Matrix[5];
    world.invertToRef(tmpMat);
    var tmpVect = TmpVectors.Vector3[8];
    Vector3.TransformCoordinatesFromFloatsToRef(x, 0, z, tmpMat, tmpVect);
    x = tmpVect.x;
    z = tmpVect.z;
    if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {
      return this;
    }
    if (!this._heightQuads || this._heightQuads.length == 0) {
      this._initHeightQuads();
      this._computeHeightQuads();
    }
    var facet = this._getFacetAt(x, z);
    Vector3.TransformNormalFromFloatsToRef(facet.x, facet.y, facet.z, world, ref);
    return this;
  };
  GroundMesh2.prototype.updateCoordinateHeights = function() {
    if (!this._heightQuads || this._heightQuads.length == 0) {
      this._initHeightQuads();
    }
    this._computeHeightQuads();
    return this;
  };
  GroundMesh2.prototype._getFacetAt = function(x, z) {
    var col = Math.floor((x + this._maxX) * this._subdivisionsX / this._width);
    var row = Math.floor(-(z + this._maxZ) * this._subdivisionsY / this._height + this._subdivisionsY);
    var quad = this._heightQuads[row * this._subdivisionsX + col];
    var facet;
    if (z < quad.slope.x * x + quad.slope.y) {
      facet = quad.facet1;
    } else {
      facet = quad.facet2;
    }
    return facet;
  };
  GroundMesh2.prototype._initHeightQuads = function() {
    var subdivisionsX = this._subdivisionsX;
    var subdivisionsY = this._subdivisionsY;
    this._heightQuads = new Array();
    for (var row = 0; row < subdivisionsY; row++) {
      for (var col = 0; col < subdivisionsX; col++) {
        var quad = { slope: Vector2.Zero(), facet1: new Vector4(0, 0, 0, 0), facet2: new Vector4(0, 0, 0, 0) };
        this._heightQuads[row * subdivisionsX + col] = quad;
      }
    }
    return this;
  };
  GroundMesh2.prototype._computeHeightQuads = function() {
    var positions = this.getVerticesData(VertexBuffer.PositionKind);
    if (!positions) {
      return this;
    }
    var v1 = TmpVectors.Vector3[3];
    var v2 = TmpVectors.Vector3[2];
    var v3 = TmpVectors.Vector3[1];
    var v4 = TmpVectors.Vector3[0];
    var v1v2 = TmpVectors.Vector3[4];
    var v1v3 = TmpVectors.Vector3[5];
    var v1v4 = TmpVectors.Vector3[6];
    var norm1 = TmpVectors.Vector3[7];
    var norm2 = TmpVectors.Vector3[8];
    var i = 0;
    var j = 0;
    var k = 0;
    var cd = 0;
    var h = 0;
    var d1 = 0;
    var d2 = 0;
    var subdivisionsX = this._subdivisionsX;
    var subdivisionsY = this._subdivisionsY;
    for (var row = 0; row < subdivisionsY; row++) {
      for (var col = 0; col < subdivisionsX; col++) {
        i = col * 3;
        j = row * (subdivisionsX + 1) * 3;
        k = (row + 1) * (subdivisionsX + 1) * 3;
        v1.x = positions[j + i];
        v1.y = positions[j + i + 1];
        v1.z = positions[j + i + 2];
        v2.x = positions[j + i + 3];
        v2.y = positions[j + i + 4];
        v2.z = positions[j + i + 5];
        v3.x = positions[k + i];
        v3.y = positions[k + i + 1];
        v3.z = positions[k + i + 2];
        v4.x = positions[k + i + 3];
        v4.y = positions[k + i + 4];
        v4.z = positions[k + i + 5];
        cd = (v4.z - v1.z) / (v4.x - v1.x);
        h = v1.z - cd * v1.x;
        v2.subtractToRef(v1, v1v2);
        v3.subtractToRef(v1, v1v3);
        v4.subtractToRef(v1, v1v4);
        Vector3.CrossToRef(v1v4, v1v3, norm1);
        Vector3.CrossToRef(v1v2, v1v4, norm2);
        norm1.normalize();
        norm2.normalize();
        d1 = -(norm1.x * v1.x + norm1.y * v1.y + norm1.z * v1.z);
        d2 = -(norm2.x * v2.x + norm2.y * v2.y + norm2.z * v2.z);
        var quad = this._heightQuads[row * subdivisionsX + col];
        quad.slope.copyFromFloats(cd, h);
        quad.facet1.copyFromFloats(norm1.x, norm1.y, norm1.z, d1);
        quad.facet2.copyFromFloats(norm2.x, norm2.y, norm2.z, d2);
      }
    }
    return this;
  };
  GroundMesh2.prototype.serialize = function(serializationObject) {
    _super.prototype.serialize.call(this, serializationObject);
    serializationObject.subdivisionsX = this._subdivisionsX;
    serializationObject.subdivisionsY = this._subdivisionsY;
    serializationObject.minX = this._minX;
    serializationObject.maxX = this._maxX;
    serializationObject.minZ = this._minZ;
    serializationObject.maxZ = this._maxZ;
    serializationObject.width = this._width;
    serializationObject.height = this._height;
  };
  GroundMesh2.Parse = function(parsedMesh, scene) {
    var result = new GroundMesh2(parsedMesh.name, scene);
    result._subdivisionsX = parsedMesh.subdivisionsX || 1;
    result._subdivisionsY = parsedMesh.subdivisionsY || 1;
    result._minX = parsedMesh.minX;
    result._maxX = parsedMesh.maxX;
    result._minZ = parsedMesh.minZ;
    result._maxZ = parsedMesh.maxZ;
    result._width = parsedMesh.width;
    result._height = parsedMesh.height;
    return result;
  };
  return GroundMesh2;
}(Mesh);

// node_modules/@babylonjs/core/Meshes/Builders/groundBuilder.js
VertexData.CreateGround = function(options) {
  var indices = [];
  var positions = [];
  var normals = [];
  var uvs = [];
  var row, col;
  var width = options.width || 1;
  var height = options.height || 1;
  var subdivisionsX = options.subdivisionsX || options.subdivisions || 1;
  var subdivisionsY = options.subdivisionsY || options.subdivisions || 1;
  for (row = 0; row <= subdivisionsY; row++) {
    for (col = 0; col <= subdivisionsX; col++) {
      var position = new Vector3(col * width / subdivisionsX - width / 2, 0, (subdivisionsY - row) * height / subdivisionsY - height / 2);
      var normal = new Vector3(0, 1, 0);
      positions.push(position.x, position.y, position.z);
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(col / subdivisionsX, 1 - row / subdivisionsY);
    }
  }
  for (row = 0; row < subdivisionsY; row++) {
    for (col = 0; col < subdivisionsX; col++) {
      indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));
      indices.push(col + 1 + row * (subdivisionsX + 1));
      indices.push(col + row * (subdivisionsX + 1));
      indices.push(col + (row + 1) * (subdivisionsX + 1));
      indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));
      indices.push(col + row * (subdivisionsX + 1));
    }
  }
  var vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
};
VertexData.CreateTiledGround = function(options) {
  var xmin = options.xmin !== void 0 && options.xmin !== null ? options.xmin : -1;
  var zmin = options.zmin !== void 0 && options.zmin !== null ? options.zmin : -1;
  var xmax = options.xmax !== void 0 && options.xmax !== null ? options.xmax : 1;
  var zmax = options.zmax !== void 0 && options.zmax !== null ? options.zmax : 1;
  var subdivisions = options.subdivisions || { w: 1, h: 1 };
  var precision = options.precision || { w: 1, h: 1 };
  var indices = new Array();
  var positions = new Array();
  var normals = new Array();
  var uvs = new Array();
  var row, col, tileRow, tileCol;
  subdivisions.h = subdivisions.h < 1 ? 1 : subdivisions.h;
  subdivisions.w = subdivisions.w < 1 ? 1 : subdivisions.w;
  precision.w = precision.w < 1 ? 1 : precision.w;
  precision.h = precision.h < 1 ? 1 : precision.h;
  var tileSize = {
    "w": (xmax - xmin) / subdivisions.w,
    "h": (zmax - zmin) / subdivisions.h
  };
  function applyTile(xTileMin, zTileMin, xTileMax, zTileMax) {
    var base = positions.length / 3;
    var rowLength = precision.w + 1;
    for (row = 0; row < precision.h; row++) {
      for (col = 0; col < precision.w; col++) {
        var square = [
          base + col + row * rowLength,
          base + (col + 1) + row * rowLength,
          base + (col + 1) + (row + 1) * rowLength,
          base + col + (row + 1) * rowLength
        ];
        indices.push(square[1]);
        indices.push(square[2]);
        indices.push(square[3]);
        indices.push(square[0]);
        indices.push(square[1]);
        indices.push(square[3]);
      }
    }
    var position = Vector3.Zero();
    var normal = new Vector3(0, 1, 0);
    for (row = 0; row <= precision.h; row++) {
      position.z = row * (zTileMax - zTileMin) / precision.h + zTileMin;
      for (col = 0; col <= precision.w; col++) {
        position.x = col * (xTileMax - xTileMin) / precision.w + xTileMin;
        position.y = 0;
        positions.push(position.x, position.y, position.z);
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(col / precision.w, row / precision.h);
      }
    }
  }
  for (tileRow = 0; tileRow < subdivisions.h; tileRow++) {
    for (tileCol = 0; tileCol < subdivisions.w; tileCol++) {
      applyTile(xmin + tileCol * tileSize.w, zmin + tileRow * tileSize.h, xmin + (tileCol + 1) * tileSize.w, zmin + (tileRow + 1) * tileSize.h);
    }
  }
  var vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
};
VertexData.CreateGroundFromHeightMap = function(options) {
  var indices = [];
  var positions = [];
  var normals = [];
  var uvs = [];
  var row, col;
  var filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);
  var alphaFilter = options.alphaFilter || 0;
  var invert = false;
  if (options.minHeight > options.maxHeight) {
    invert = true;
    var temp = options.maxHeight;
    options.maxHeight = options.minHeight;
    options.minHeight = temp;
  }
  for (row = 0; row <= options.subdivisions; row++) {
    for (col = 0; col <= options.subdivisions; col++) {
      var position = new Vector3(col * options.width / options.subdivisions - options.width / 2, 0, (options.subdivisions - row) * options.height / options.subdivisions - options.height / 2);
      var heightMapX = (position.x + options.width / 2) / options.width * (options.bufferWidth - 1) | 0;
      var heightMapY = (1 - (position.z + options.height / 2) / options.height) * (options.bufferHeight - 1) | 0;
      var pos = (heightMapX + heightMapY * options.bufferWidth) * 4;
      var r = options.buffer[pos] / 255;
      var g = options.buffer[pos + 1] / 255;
      var b = options.buffer[pos + 2] / 255;
      var a = options.buffer[pos + 3] / 255;
      if (invert) {
        r = 1 - r;
        g = 1 - g;
        b = 1 - b;
      }
      var gradient = r * filter.r + g * filter.g + b * filter.b;
      if (a >= alphaFilter) {
        position.y = options.minHeight + (options.maxHeight - options.minHeight) * gradient;
      } else {
        position.y = options.minHeight - Epsilon;
      }
      positions.push(position.x, position.y, position.z);
      normals.push(0, 0, 0);
      uvs.push(col / options.subdivisions, 1 - row / options.subdivisions);
    }
  }
  for (row = 0; row < options.subdivisions; row++) {
    for (col = 0; col < options.subdivisions; col++) {
      var idx1 = col + 1 + (row + 1) * (options.subdivisions + 1);
      var idx2 = col + 1 + row * (options.subdivisions + 1);
      var idx3 = col + row * (options.subdivisions + 1);
      var idx4 = col + (row + 1) * (options.subdivisions + 1);
      var isVisibleIdx1 = positions[idx1 * 3 + 1] >= options.minHeight;
      var isVisibleIdx2 = positions[idx2 * 3 + 1] >= options.minHeight;
      var isVisibleIdx3 = positions[idx3 * 3 + 1] >= options.minHeight;
      if (isVisibleIdx1 && isVisibleIdx2 && isVisibleIdx3) {
        indices.push(idx1);
        indices.push(idx2);
        indices.push(idx3);
      }
      var isVisibleIdx4 = positions[idx4 * 3 + 1] >= options.minHeight;
      if (isVisibleIdx4 && isVisibleIdx1 && isVisibleIdx3) {
        indices.push(idx4);
        indices.push(idx1);
        indices.push(idx3);
      }
    }
  }
  VertexData.ComputeNormals(positions, indices, normals);
  var vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
};
Mesh.CreateGround = function(name98, width, height, subdivisions, scene, updatable) {
  var options = {
    width,
    height,
    subdivisions,
    updatable
  };
  return GroundBuilder.CreateGround(name98, options, scene);
};
Mesh.CreateTiledGround = function(name98, xmin, zmin, xmax, zmax, subdivisions, precision, scene, updatable) {
  var options = {
    xmin,
    zmin,
    xmax,
    zmax,
    subdivisions,
    precision,
    updatable
  };
  return GroundBuilder.CreateTiledGround(name98, options, scene);
};
Mesh.CreateGroundFromHeightMap = function(name98, url, width, height, subdivisions, minHeight, maxHeight, scene, updatable, onReady, alphaFilter) {
  var options = {
    width,
    height,
    subdivisions,
    minHeight,
    maxHeight,
    updatable,
    onReady,
    alphaFilter
  };
  return GroundBuilder.CreateGroundFromHeightMap(name98, url, options, scene);
};
var GroundBuilder = function() {
  function GroundBuilder2() {
  }
  GroundBuilder2.CreateGround = function(name98, options, scene) {
    var ground = new GroundMesh(name98, scene);
    ground._setReady(false);
    ground._subdivisionsX = options.subdivisionsX || options.subdivisions || 1;
    ground._subdivisionsY = options.subdivisionsY || options.subdivisions || 1;
    ground._width = options.width || 1;
    ground._height = options.height || 1;
    ground._maxX = ground._width / 2;
    ground._maxZ = ground._height / 2;
    ground._minX = -ground._maxX;
    ground._minZ = -ground._maxZ;
    var vertexData = VertexData.CreateGround(options);
    vertexData.applyToMesh(ground, options.updatable);
    ground._setReady(true);
    return ground;
  };
  GroundBuilder2.CreateTiledGround = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    var tiledGround = new Mesh(name98, scene);
    var vertexData = VertexData.CreateTiledGround(options);
    vertexData.applyToMesh(tiledGround, options.updatable);
    return tiledGround;
  };
  GroundBuilder2.CreateGroundFromHeightMap = function(name98, url, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    var width = options.width || 10;
    var height = options.height || 10;
    var subdivisions = options.subdivisions || 1 | 0;
    var minHeight = options.minHeight || 0;
    var maxHeight = options.maxHeight || 1;
    var filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);
    var alphaFilter = options.alphaFilter || 0;
    var updatable = options.updatable;
    var onReady = options.onReady;
    scene = scene || EngineStore.LastCreatedScene;
    var ground = new GroundMesh(name98, scene);
    ground._subdivisionsX = subdivisions;
    ground._subdivisionsY = subdivisions;
    ground._width = width;
    ground._height = height;
    ground._maxX = ground._width / 2;
    ground._maxZ = ground._height / 2;
    ground._minX = -ground._maxX;
    ground._minZ = -ground._maxZ;
    ground._setReady(false);
    var onload = function(img) {
      var bufferWidth = img.width;
      var bufferHeight = img.height;
      var canvas = CanvasGenerator.CreateCanvas(bufferWidth, bufferHeight);
      var context = canvas.getContext("2d");
      if (!context) {
        throw new Error("Unable to get 2d context for CreateGroundFromHeightMap");
      }
      if (scene.isDisposed) {
        return;
      }
      context.drawImage(img, 0, 0);
      var buffer = context.getImageData(0, 0, bufferWidth, bufferHeight).data;
      var vertexData = VertexData.CreateGroundFromHeightMap({
        width,
        height,
        subdivisions,
        minHeight,
        maxHeight,
        colorFilter: filter,
        buffer,
        bufferWidth,
        bufferHeight,
        alphaFilter
      });
      vertexData.applyToMesh(ground, updatable);
      if (onReady) {
        onReady(ground);
      }
      ground._setReady(true);
    };
    Tools.LoadImage(url, onload, function() {
    }, scene.offlineProvider);
    return ground;
  };
  return GroundBuilder2;
}();

// node_modules/@babylonjs/core/Meshes/Builders/torusBuilder.js
VertexData.CreateTorus = function(options) {
  var indices = [];
  var positions = [];
  var normals = [];
  var uvs = [];
  var diameter = options.diameter || 1;
  var thickness = options.thickness || 0.5;
  var tessellation = options.tessellation || 16;
  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  var stride = tessellation + 1;
  for (var i = 0; i <= tessellation; i++) {
    var u = i / tessellation;
    var outerAngle = i * Math.PI * 2 / tessellation - Math.PI / 2;
    var transform = Matrix.Translation(diameter / 2, 0, 0).multiply(Matrix.RotationY(outerAngle));
    for (var j = 0; j <= tessellation; j++) {
      var v = 1 - j / tessellation;
      var innerAngle = j * Math.PI * 2 / tessellation + Math.PI;
      var dx = Math.cos(innerAngle);
      var dy = Math.sin(innerAngle);
      var normal = new Vector3(dx, dy, 0);
      var position = normal.scale(thickness / 2);
      var textureCoordinate = new Vector2(u, v);
      position = Vector3.TransformCoordinates(position, transform);
      normal = Vector3.TransformNormal(normal, transform);
      positions.push(position.x, position.y, position.z);
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(textureCoordinate.x, textureCoordinate.y);
      var nextI = (i + 1) % stride;
      var nextJ = (j + 1) % stride;
      indices.push(i * stride + j);
      indices.push(i * stride + nextJ);
      indices.push(nextI * stride + j);
      indices.push(i * stride + nextJ);
      indices.push(nextI * stride + nextJ);
      indices.push(nextI * stride + j);
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  var vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
};
Mesh.CreateTorus = function(name98, diameter, thickness, tessellation, scene, updatable, sideOrientation) {
  var options = {
    diameter,
    thickness,
    tessellation,
    sideOrientation,
    updatable
  };
  return TorusBuilder.CreateTorus(name98, options, scene);
};
var TorusBuilder = function() {
  function TorusBuilder2() {
  }
  TorusBuilder2.CreateTorus = function(name98, options, scene) {
    var torus = new Mesh(name98, scene);
    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
    torus._originalBuilderSideOrientation = options.sideOrientation;
    var vertexData = VertexData.CreateTorus(options);
    vertexData.applyToMesh(torus, options.updatable);
    return torus;
  };
  return TorusBuilder2;
}();

// node_modules/@babylonjs/core/Meshes/Builders/cylinderBuilder.js
VertexData.CreateCylinder = function(options) {
  var height = options.height || 2;
  var diameterTop = options.diameterTop === 0 ? 0 : options.diameterTop || options.diameter || 1;
  var diameterBottom = options.diameterBottom === 0 ? 0 : options.diameterBottom || options.diameter || 1;
  diameterTop = diameterTop || 1e-5;
  diameterBottom = diameterBottom || 1e-5;
  var tessellation = options.tessellation || 24;
  var subdivisions = options.subdivisions || 1;
  var hasRings = options.hasRings ? true : false;
  var enclose = options.enclose ? true : false;
  var cap = options.cap === 0 ? 0 : options.cap || Mesh.CAP_ALL;
  var arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1 : options.arc || 1;
  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  var faceUV = options.faceUV || new Array(3);
  var faceColors = options.faceColors;
  var quadNb = arc !== 1 && enclose ? 2 : 0;
  var ringNb = hasRings ? subdivisions : 1;
  var surfaceNb = 2 + (1 + quadNb) * ringNb;
  var f;
  for (f = 0; f < surfaceNb; f++) {
    if (faceColors && faceColors[f] === void 0) {
      faceColors[f] = new Color4(1, 1, 1, 1);
    }
  }
  for (f = 0; f < surfaceNb; f++) {
    if (faceUV && faceUV[f] === void 0) {
      faceUV[f] = new Vector4(0, 0, 1, 1);
    }
  }
  var indices = new Array();
  var positions = new Array();
  var normals = new Array();
  var uvs = new Array();
  var colors = new Array();
  var angle_step = Math.PI * 2 * arc / tessellation;
  var angle;
  var h;
  var radius;
  var tan = (diameterBottom - diameterTop) / 2 / height;
  var ringVertex = Vector3.Zero();
  var ringNormal = Vector3.Zero();
  var ringFirstVertex = Vector3.Zero();
  var ringFirstNormal = Vector3.Zero();
  var quadNormal = Vector3.Zero();
  var Y = Axis.Y;
  var i;
  var j;
  var r;
  var ringIdx = 1;
  var s = 1;
  var cs = 0;
  var v = 0;
  for (i = 0; i <= subdivisions; i++) {
    h = i / subdivisions;
    radius = (h * (diameterTop - diameterBottom) + diameterBottom) / 2;
    ringIdx = hasRings && i !== 0 && i !== subdivisions ? 2 : 1;
    for (r = 0; r < ringIdx; r++) {
      if (hasRings) {
        s += r;
      }
      if (enclose) {
        s += 2 * r;
      }
      for (j = 0; j <= tessellation; j++) {
        angle = j * angle_step;
        ringVertex.x = Math.cos(-angle) * radius;
        ringVertex.y = -height / 2 + h * height;
        ringVertex.z = Math.sin(-angle) * radius;
        if (diameterTop === 0 && i === subdivisions) {
          ringNormal.x = normals[normals.length - (tessellation + 1) * 3];
          ringNormal.y = normals[normals.length - (tessellation + 1) * 3 + 1];
          ringNormal.z = normals[normals.length - (tessellation + 1) * 3 + 2];
        } else {
          ringNormal.x = ringVertex.x;
          ringNormal.z = ringVertex.z;
          ringNormal.y = Math.sqrt(ringNormal.x * ringNormal.x + ringNormal.z * ringNormal.z) * tan;
          ringNormal.normalize();
        }
        if (j === 0) {
          ringFirstVertex.copyFrom(ringVertex);
          ringFirstNormal.copyFrom(ringNormal);
        }
        positions.push(ringVertex.x, ringVertex.y, ringVertex.z);
        normals.push(ringNormal.x, ringNormal.y, ringNormal.z);
        if (hasRings) {
          v = cs !== s ? faceUV[s].y : faceUV[s].w;
        } else {
          v = faceUV[s].y + (faceUV[s].w - faceUV[s].y) * h;
        }
        uvs.push(faceUV[s].x + (faceUV[s].z - faceUV[s].x) * j / tessellation, v);
        if (faceColors) {
          colors.push(faceColors[s].r, faceColors[s].g, faceColors[s].b, faceColors[s].a);
        }
      }
      if (arc !== 1 && enclose) {
        positions.push(ringVertex.x, ringVertex.y, ringVertex.z);
        positions.push(0, ringVertex.y, 0);
        positions.push(0, ringVertex.y, 0);
        positions.push(ringFirstVertex.x, ringFirstVertex.y, ringFirstVertex.z);
        Vector3.CrossToRef(Y, ringNormal, quadNormal);
        quadNormal.normalize();
        normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);
        Vector3.CrossToRef(ringFirstNormal, Y, quadNormal);
        quadNormal.normalize();
        normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);
        if (hasRings) {
          v = cs !== s ? faceUV[s + 1].y : faceUV[s + 1].w;
        } else {
          v = faceUV[s + 1].y + (faceUV[s + 1].w - faceUV[s + 1].y) * h;
        }
        uvs.push(faceUV[s + 1].x, v);
        uvs.push(faceUV[s + 1].z, v);
        if (hasRings) {
          v = cs !== s ? faceUV[s + 2].y : faceUV[s + 2].w;
        } else {
          v = faceUV[s + 2].y + (faceUV[s + 2].w - faceUV[s + 2].y) * h;
        }
        uvs.push(faceUV[s + 2].x, v);
        uvs.push(faceUV[s + 2].z, v);
        if (faceColors) {
          colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);
          colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);
          colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);
          colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);
        }
      }
      if (cs !== s) {
        cs = s;
      }
    }
  }
  var e = arc !== 1 && enclose ? tessellation + 4 : tessellation;
  var s;
  i = 0;
  for (s = 0; s < subdivisions; s++) {
    var i0 = 0;
    var i1 = 0;
    var i2 = 0;
    var i3 = 0;
    for (j = 0; j < tessellation; j++) {
      i0 = i * (e + 1) + j;
      i1 = (i + 1) * (e + 1) + j;
      i2 = i * (e + 1) + (j + 1);
      i3 = (i + 1) * (e + 1) + (j + 1);
      indices.push(i0, i1, i2);
      indices.push(i3, i2, i1);
    }
    if (arc !== 1 && enclose) {
      indices.push(i0 + 2, i1 + 2, i2 + 2);
      indices.push(i3 + 2, i2 + 2, i1 + 2);
      indices.push(i0 + 4, i1 + 4, i2 + 4);
      indices.push(i3 + 4, i2 + 4, i1 + 4);
    }
    i = hasRings ? i + 2 : i + 1;
  }
  var createCylinderCap = function(isTop) {
    var radius2 = isTop ? diameterTop / 2 : diameterBottom / 2;
    if (radius2 === 0) {
      return;
    }
    var angle2;
    var circleVector;
    var i4;
    var u = isTop ? faceUV[surfaceNb - 1] : faceUV[0];
    var c = null;
    if (faceColors) {
      c = isTop ? faceColors[surfaceNb - 1] : faceColors[0];
    }
    var vbase = positions.length / 3;
    var offset = isTop ? height / 2 : -height / 2;
    var center = new Vector3(0, offset, 0);
    positions.push(center.x, center.y, center.z);
    normals.push(0, isTop ? 1 : -1, 0);
    uvs.push(u.x + (u.z - u.x) * 0.5, u.y + (u.w - u.y) * 0.5);
    if (c) {
      colors.push(c.r, c.g, c.b, c.a);
    }
    var textureScale = new Vector2(0.5, 0.5);
    for (i4 = 0; i4 <= tessellation; i4++) {
      angle2 = Math.PI * 2 * i4 * arc / tessellation;
      var cos = Math.cos(-angle2);
      var sin = Math.sin(-angle2);
      circleVector = new Vector3(cos * radius2, offset, sin * radius2);
      var textureCoordinate = new Vector2(cos * textureScale.x + 0.5, sin * textureScale.y + 0.5);
      positions.push(circleVector.x, circleVector.y, circleVector.z);
      normals.push(0, isTop ? 1 : -1, 0);
      uvs.push(u.x + (u.z - u.x) * textureCoordinate.x, u.y + (u.w - u.y) * textureCoordinate.y);
      if (c) {
        colors.push(c.r, c.g, c.b, c.a);
      }
    }
    for (i4 = 0; i4 < tessellation; i4++) {
      if (!isTop) {
        indices.push(vbase);
        indices.push(vbase + (i4 + 1));
        indices.push(vbase + (i4 + 2));
      } else {
        indices.push(vbase);
        indices.push(vbase + (i4 + 2));
        indices.push(vbase + (i4 + 1));
      }
    }
  };
  if (cap === Mesh.CAP_START || cap === Mesh.CAP_ALL) {
    createCylinderCap(false);
  }
  if (cap === Mesh.CAP_END || cap === Mesh.CAP_ALL) {
    createCylinderCap(true);
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  var vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  if (faceColors) {
    vertexData.colors = colors;
  }
  return vertexData;
};
Mesh.CreateCylinder = function(name98, height, diameterTop, diameterBottom, tessellation, subdivisions, scene, updatable, sideOrientation) {
  if (scene === void 0 || !(scene instanceof Scene)) {
    if (scene !== void 0) {
      sideOrientation = updatable || Mesh.DEFAULTSIDE;
      updatable = scene;
    }
    scene = subdivisions;
    subdivisions = 1;
  }
  var options = {
    height,
    diameterTop,
    diameterBottom,
    tessellation,
    subdivisions,
    sideOrientation,
    updatable
  };
  return CylinderBuilder.CreateCylinder(name98, options, scene);
};
var CylinderBuilder = function() {
  function CylinderBuilder2() {
  }
  CylinderBuilder2.CreateCylinder = function(name98, options, scene) {
    var cylinder = new Mesh(name98, scene);
    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
    cylinder._originalBuilderSideOrientation = options.sideOrientation;
    var vertexData = VertexData.CreateCylinder(options);
    vertexData.applyToMesh(cylinder, options.updatable);
    return cylinder;
  };
  return CylinderBuilder2;
}();

// node_modules/@babylonjs/core/XR/webXRManagedOutputCanvas.js
var WebXRManagedOutputCanvasOptions = function() {
  function WebXRManagedOutputCanvasOptions2() {
  }
  WebXRManagedOutputCanvasOptions2.GetDefaults = function(engine) {
    var defaults = new WebXRManagedOutputCanvasOptions2();
    defaults.canvasOptions = {
      antialias: true,
      depth: true,
      stencil: engine ? engine.isStencilEnable : true,
      alpha: true,
      multiview: false,
      framebufferScaleFactor: 1
    };
    defaults.newCanvasCssStyle = "position:absolute; bottom:0px;right:0px;z-index:10;width:90%;height:100%;background-color: #000000;";
    return defaults;
  };
  return WebXRManagedOutputCanvasOptions2;
}();
var WebXRManagedOutputCanvas = function() {
  function WebXRManagedOutputCanvas2(_xrSessionManager, _options) {
    var _this = this;
    if (_options === void 0) {
      _options = WebXRManagedOutputCanvasOptions.GetDefaults();
    }
    this._options = _options;
    this._canvas = null;
    this.xrLayer = null;
    this.onXRLayerInitObservable = new Observable();
    this._engine = _xrSessionManager.scene.getEngine();
    if (!_options.canvasElement) {
      var canvas = document.createElement("canvas");
      canvas.style.cssText = this._options.newCanvasCssStyle || "position:absolute; bottom:0px;right:0px;";
      this._setManagedOutputCanvas(canvas);
    } else {
      this._setManagedOutputCanvas(_options.canvasElement);
    }
    _xrSessionManager.onXRSessionInit.add(function() {
      _this._addCanvas();
    });
    _xrSessionManager.onXRSessionEnded.add(function() {
      _this._removeCanvas();
    });
  }
  WebXRManagedOutputCanvas2.prototype.dispose = function() {
    this._removeCanvas();
    this._setManagedOutputCanvas(null);
  };
  WebXRManagedOutputCanvas2.prototype.initializeXRLayerAsync = function(xrSession) {
    var _this = this;
    var createLayer = function() {
      var layer = new XRWebGLLayer(xrSession, _this.canvasContext, _this._options.canvasOptions);
      _this.onXRLayerInitObservable.notifyObservers(layer);
      return layer;
    };
    if (!this.canvasContext.makeXRCompatible) {
      this.xrLayer = createLayer();
      return Promise.resolve(this.xrLayer);
    }
    return this.canvasContext.makeXRCompatible().then(function() {
      _this.xrLayer = createLayer();
      return _this.xrLayer;
    });
  };
  WebXRManagedOutputCanvas2.prototype._addCanvas = function() {
    var _this = this;
    if (this._canvas && this._canvas !== this._engine.getRenderingCanvas()) {
      document.body.appendChild(this._canvas);
    }
    if (this.xrLayer) {
      this._setCanvasSize(true);
    } else {
      this.onXRLayerInitObservable.addOnce(function(layer) {
        _this._setCanvasSize(true, layer);
      });
    }
  };
  WebXRManagedOutputCanvas2.prototype._removeCanvas = function() {
    if (this._canvas && document.body.contains(this._canvas) && this._canvas !== this._engine.getRenderingCanvas()) {
      document.body.removeChild(this._canvas);
    }
    this._setCanvasSize(false);
  };
  WebXRManagedOutputCanvas2.prototype._setCanvasSize = function(init, xrLayer) {
    if (init === void 0) {
      init = true;
    }
    if (xrLayer === void 0) {
      xrLayer = this.xrLayer;
    }
    if (!this._canvas) {
      return;
    }
    if (init) {
      if (xrLayer) {
        if (this._canvas !== this._engine.getRenderingCanvas()) {
          this._canvas.style.width = xrLayer.framebufferWidth + "px";
          this._canvas.style.height = xrLayer.framebufferHeight + "px";
        } else {
          this._engine.setSize(xrLayer.framebufferWidth, xrLayer.framebufferHeight);
        }
      }
    } else {
      if (this._originalCanvasSize) {
        if (this._canvas !== this._engine.getRenderingCanvas()) {
          this._canvas.style.width = this._originalCanvasSize.width + "px";
          this._canvas.style.height = this._originalCanvasSize.height + "px";
        } else {
          this._engine.setSize(this._originalCanvasSize.width, this._originalCanvasSize.height);
        }
      }
    }
  };
  WebXRManagedOutputCanvas2.prototype._setManagedOutputCanvas = function(canvas) {
    this._removeCanvas();
    if (!canvas) {
      this._canvas = null;
      this.canvasContext = null;
    } else {
      this._originalCanvasSize = {
        width: canvas.offsetWidth,
        height: canvas.offsetHeight
      };
      this._canvas = canvas;
      this.canvasContext = this._canvas.getContext("webgl2");
      if (!this.canvasContext) {
        this.canvasContext = this._canvas.getContext("webgl");
      }
    }
  };
  return WebXRManagedOutputCanvas2;
}();

// node_modules/@babylonjs/core/XR/webXRSessionManager.js
var WebXRSessionManager = function() {
  function WebXRSessionManager2(scene) {
    this.scene = scene;
    this._sessionEnded = false;
    this.baseLayer = null;
    this.currentTimestamp = -1;
    this.defaultHeightCompensation = 1.7;
    this.onXRFrameObservable = new Observable();
    this.onXRReferenceSpaceChanged = new Observable();
    this.onXRSessionEnded = new Observable();
    this.onXRSessionInit = new Observable();
  }
  Object.defineProperty(WebXRSessionManager2.prototype, "referenceSpace", {
    get: function() {
      return this._referenceSpace;
    },
    set: function(newReferenceSpace) {
      this._referenceSpace = newReferenceSpace;
      this.onXRReferenceSpaceChanged.notifyObservers(this._referenceSpace);
    },
    enumerable: false,
    configurable: true
  });
  WebXRSessionManager2.prototype.dispose = function() {
    if (!this._sessionEnded) {
      this.exitXRAsync();
    }
    this.onXRFrameObservable.clear();
    this.onXRSessionEnded.clear();
    this.onXRReferenceSpaceChanged.clear();
    this.onXRSessionInit.clear();
  };
  WebXRSessionManager2.prototype.exitXRAsync = function() {
    if (this.session && !this._sessionEnded) {
      this._sessionEnded = true;
      return this.session.end().catch(function(e) {
        Logger.Warn("Could not end XR session.");
      });
    }
    return Promise.resolve();
  };
  WebXRSessionManager2.prototype.getRenderTargetTextureForEye = function(eye) {
    return this._rttProvider.getRenderTargetForEye(eye);
  };
  WebXRSessionManager2.prototype.getWebXRRenderTarget = function(options) {
    var engine = this.scene.getEngine();
    if (this._xrNavigator.xr.native) {
      return this._xrNavigator.xr.getWebXRRenderTarget(engine);
    } else {
      options = options || WebXRManagedOutputCanvasOptions.GetDefaults(engine);
      options.canvasElement = engine.getRenderingCanvas() || void 0;
      return new WebXRManagedOutputCanvas(this, options);
    }
  };
  WebXRSessionManager2.prototype.initializeAsync = function() {
    this._xrNavigator = navigator;
    if (!this._xrNavigator.xr) {
      return Promise.reject("WebXR not available");
    }
    return Promise.resolve();
  };
  WebXRSessionManager2.prototype.initializeSessionAsync = function(xrSessionMode, xrSessionInit) {
    var _this = this;
    if (xrSessionMode === void 0) {
      xrSessionMode = "immersive-vr";
    }
    if (xrSessionInit === void 0) {
      xrSessionInit = {};
    }
    return this._xrNavigator.xr.requestSession(xrSessionMode, xrSessionInit).then(function(session) {
      _this.session = session;
      _this.onXRSessionInit.notifyObservers(session);
      _this._sessionEnded = false;
      _this.session.addEventListener("end", function() {
        var engine = _this.scene.getEngine();
        _this._sessionEnded = true;
        _this._rttProvider = null;
        engine.framebufferDimensionsObject = null;
        engine.restoreDefaultFramebuffer();
        engine.customAnimationFrameRequester = null;
        _this.onXRSessionEnded.notifyObservers(null);
        engine._renderLoop();
      }, { once: true });
      return _this.session;
    });
  };
  WebXRSessionManager2.prototype.isSessionSupportedAsync = function(sessionMode) {
    return WebXRSessionManager2.IsSessionSupportedAsync(sessionMode);
  };
  WebXRSessionManager2.prototype.resetReferenceSpace = function() {
    this.referenceSpace = this.baseReferenceSpace;
  };
  WebXRSessionManager2.prototype.runXRRenderLoop = function() {
    var _this = this;
    var engine = this.scene.getEngine();
    engine.customAnimationFrameRequester = {
      requestAnimationFrame: this.session.requestAnimationFrame.bind(this.session),
      renderFunction: function(timestamp, xrFrame) {
        if (_this._sessionEnded) {
          return;
        }
        _this.currentFrame = xrFrame;
        _this.currentTimestamp = timestamp;
        if (xrFrame) {
          engine.framebufferDimensionsObject = _this.baseLayer;
          _this.onXRFrameObservable.notifyObservers(xrFrame);
          engine._renderLoop();
          engine.framebufferDimensionsObject = null;
        }
      }
    };
    if (this._xrNavigator.xr.native) {
      this._rttProvider = this._xrNavigator.xr.getNativeRenderTargetProvider(this.session, this._createRenderTargetTexture.bind(this));
    } else {
      var rtt_1 = this._createRenderTargetTexture(this.baseLayer.framebufferWidth, this.baseLayer.framebufferHeight, this.baseLayer.framebuffer);
      this._rttProvider = { getRenderTargetForEye: function() {
        return rtt_1;
      } };
      engine.framebufferDimensionsObject = this.baseLayer;
    }
    if (typeof window !== "undefined" && window.cancelAnimationFrame) {
      window.cancelAnimationFrame(engine._frameHandler);
    }
    engine._renderLoop();
  };
  WebXRSessionManager2.prototype.setReferenceSpaceTypeAsync = function(referenceSpaceType) {
    var _this = this;
    if (referenceSpaceType === void 0) {
      referenceSpaceType = "local-floor";
    }
    return this.session.requestReferenceSpace(referenceSpaceType).then(function(referenceSpace) {
      return referenceSpace;
    }, function(rejectionReason) {
      Logger.Error("XR.requestReferenceSpace failed for the following reason: ");
      Logger.Error(rejectionReason);
      Logger.Log('Defaulting to universally-supported "viewer" reference space type.');
      return _this.session.requestReferenceSpace("viewer").then(function(referenceSpace) {
        var heightCompensation = new XRRigidTransform({ x: 0, y: -_this.defaultHeightCompensation, z: 0 });
        return referenceSpace.getOffsetReferenceSpace(heightCompensation);
      }, function(rejectionReason2) {
        Logger.Error(rejectionReason2);
        throw 'XR initialization failed: required "viewer" reference space type not supported.';
      });
    }).then(function(referenceSpace) {
      return _this.session.requestReferenceSpace("viewer").then(function(viewerReferenceSpace) {
        _this.viewerReferenceSpace = viewerReferenceSpace;
        return referenceSpace;
      });
    }).then(function(referenceSpace) {
      _this.referenceSpace = _this.baseReferenceSpace = referenceSpace;
      return _this.referenceSpace;
    });
  };
  WebXRSessionManager2.prototype.updateRenderStateAsync = function(state) {
    if (state.baseLayer) {
      this.baseLayer = state.baseLayer;
    }
    return this.session.updateRenderState(state);
  };
  WebXRSessionManager2.IsSessionSupportedAsync = function(sessionMode) {
    if (!navigator.xr) {
      return Promise.resolve(false);
    }
    var functionToUse = navigator.xr.isSessionSupported || navigator.xr.supportsSession;
    if (!functionToUse) {
      return Promise.resolve(false);
    } else {
      return functionToUse.call(navigator.xr, sessionMode).then(function(result) {
        var returnValue = typeof result === "undefined" ? true : result;
        return Promise.resolve(returnValue);
      }).catch(function(e) {
        Logger.Warn(e);
        return Promise.resolve(false);
      });
    }
  };
  WebXRSessionManager2.prototype._createRenderTargetTexture = function(width, height, framebuffer) {
    if (framebuffer === void 0) {
      framebuffer = null;
    }
    var internalTexture = new InternalTexture(this.scene.getEngine(), InternalTextureSource.Unknown, true);
    internalTexture.width = width;
    internalTexture.height = height;
    internalTexture._framebuffer = framebuffer;
    var renderTargetTexture = new RenderTargetTexture("XR renderTargetTexture", { width, height }, this.scene, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, true);
    renderTargetTexture._texture = internalTexture;
    return renderTargetTexture;
  };
  return WebXRSessionManager2;
}();

// node_modules/@babylonjs/core/XR/webXRTypes.js
var WebXRState;
(function(WebXRState2) {
  WebXRState2[WebXRState2["ENTERING_XR"] = 0] = "ENTERING_XR";
  WebXRState2[WebXRState2["EXITING_XR"] = 1] = "EXITING_XR";
  WebXRState2[WebXRState2["IN_XR"] = 2] = "IN_XR";
  WebXRState2[WebXRState2["NOT_IN_XR"] = 3] = "NOT_IN_XR";
})(WebXRState || (WebXRState = {}));
var WebXRTrackingState;
(function(WebXRTrackingState2) {
  WebXRTrackingState2[WebXRTrackingState2["NOT_TRACKING"] = 0] = "NOT_TRACKING";
  WebXRTrackingState2[WebXRTrackingState2["TRACKING_LOST"] = 1] = "TRACKING_LOST";
  WebXRTrackingState2[WebXRTrackingState2["TRACKING"] = 2] = "TRACKING";
})(WebXRTrackingState || (WebXRTrackingState = {}));

// node_modules/@babylonjs/core/Cameras/VR/vrExperienceHelper.js
var VRExperienceHelperGazer = function() {
  function VRExperienceHelperGazer2(scene, gazeTrackerToClone) {
    if (gazeTrackerToClone === void 0) {
      gazeTrackerToClone = null;
    }
    this.scene = scene;
    this._pointerDownOnMeshAsked = false;
    this._isActionableMesh = false;
    this._teleportationRequestInitiated = false;
    this._teleportationBackRequestInitiated = false;
    this._rotationRightAsked = false;
    this._rotationLeftAsked = false;
    this._dpadPressed = true;
    this._activePointer = false;
    this._id = VRExperienceHelperGazer2._idCounter++;
    if (!gazeTrackerToClone) {
      this._gazeTracker = Mesh.CreateTorus("gazeTracker", 35e-4, 25e-4, 20, scene, false);
      this._gazeTracker.bakeCurrentTransformIntoVertices();
      this._gazeTracker.isPickable = false;
      this._gazeTracker.isVisible = false;
      var targetMat = new StandardMaterial("targetMat", scene);
      targetMat.specularColor = Color3.Black();
      targetMat.emissiveColor = new Color3(0.7, 0.7, 0.7);
      targetMat.backFaceCulling = false;
      this._gazeTracker.material = targetMat;
    } else {
      this._gazeTracker = gazeTrackerToClone.clone("gazeTracker");
    }
  }
  VRExperienceHelperGazer2.prototype._getForwardRay = function(length) {
    return new Ray(Vector3.Zero(), new Vector3(0, 0, length));
  };
  VRExperienceHelperGazer2.prototype._selectionPointerDown = function() {
    this._pointerDownOnMeshAsked = true;
    if (this._currentHit) {
      this.scene.simulatePointerDown(this._currentHit, { pointerId: this._id });
    }
  };
  VRExperienceHelperGazer2.prototype._selectionPointerUp = function() {
    if (this._currentHit) {
      this.scene.simulatePointerUp(this._currentHit, { pointerId: this._id });
    }
    this._pointerDownOnMeshAsked = false;
  };
  VRExperienceHelperGazer2.prototype._activatePointer = function() {
    this._activePointer = true;
  };
  VRExperienceHelperGazer2.prototype._deactivatePointer = function() {
    this._activePointer = false;
  };
  VRExperienceHelperGazer2.prototype._updatePointerDistance = function(distance) {
    if (distance === void 0) {
      distance = 100;
    }
  };
  VRExperienceHelperGazer2.prototype.dispose = function() {
    this._interactionsEnabled = false;
    this._teleportationEnabled = false;
    if (this._gazeTracker) {
      this._gazeTracker.dispose();
    }
  };
  VRExperienceHelperGazer2._idCounter = 0;
  return VRExperienceHelperGazer2;
}();
var VRExperienceHelperControllerGazer = function(_super) {
  __extends(VRExperienceHelperControllerGazer2, _super);
  function VRExperienceHelperControllerGazer2(webVRController, scene, gazeTrackerToClone) {
    var _this = _super.call(this, scene, gazeTrackerToClone) || this;
    _this.webVRController = webVRController;
    _this._laserPointer = Mesh.CreateCylinder("laserPointer", 1, 4e-3, 2e-4, 20, 1, scene, false);
    var laserPointerMaterial = new StandardMaterial("laserPointerMat", scene);
    laserPointerMaterial.emissiveColor = new Color3(0.7, 0.7, 0.7);
    laserPointerMaterial.alpha = 0.6;
    _this._laserPointer.material = laserPointerMaterial;
    _this._laserPointer.rotation.x = Math.PI / 2;
    _this._laserPointer.position.z = -0.5;
    _this._laserPointer.isVisible = false;
    _this._laserPointer.isPickable = false;
    if (!webVRController.mesh) {
      var preloadMesh = new Mesh("preloadControllerMesh", scene);
      var preloadPointerPose = new Mesh(PoseEnabledController.POINTING_POSE, scene);
      preloadPointerPose.rotation.x = -0.7;
      preloadMesh.addChild(preloadPointerPose);
      webVRController.attachToMesh(preloadMesh);
    }
    _this._setLaserPointerParent(webVRController.mesh);
    _this._meshAttachedObserver = webVRController._meshAttachedObservable.add(function(mesh) {
      _this._setLaserPointerParent(mesh);
    });
    return _this;
  }
  VRExperienceHelperControllerGazer2.prototype._getForwardRay = function(length) {
    return this.webVRController.getForwardRay(length);
  };
  VRExperienceHelperControllerGazer2.prototype._activatePointer = function() {
    _super.prototype._activatePointer.call(this);
    this._laserPointer.isVisible = true;
  };
  VRExperienceHelperControllerGazer2.prototype._deactivatePointer = function() {
    _super.prototype._deactivatePointer.call(this);
    this._laserPointer.isVisible = false;
  };
  VRExperienceHelperControllerGazer2.prototype._setLaserPointerColor = function(color) {
    this._laserPointer.material.emissiveColor = color;
  };
  VRExperienceHelperControllerGazer2.prototype._setLaserPointerLightingDisabled = function(disabled) {
    this._laserPointer.material.disableLighting = disabled;
  };
  VRExperienceHelperControllerGazer2.prototype._setLaserPointerParent = function(mesh) {
    var makeNotPick = function(root) {
      root.isPickable = false;
      root.getChildMeshes().forEach(function(c) {
        makeNotPick(c);
      });
    };
    makeNotPick(mesh);
    var meshChildren = mesh.getChildren(void 0, false);
    var laserParent = mesh;
    this.webVRController._pointingPoseNode = null;
    for (var i = 0; i < meshChildren.length; i++) {
      if (meshChildren[i].name && meshChildren[i].name.indexOf(PoseEnabledController.POINTING_POSE) >= 0) {
        laserParent = meshChildren[i];
        this.webVRController._pointingPoseNode = laserParent;
        break;
      }
    }
    this._laserPointer.parent = laserParent;
  };
  VRExperienceHelperControllerGazer2.prototype._updatePointerDistance = function(distance) {
    if (distance === void 0) {
      distance = 100;
    }
    this._laserPointer.scaling.y = distance;
    this._laserPointer.position.z = -distance / 2;
  };
  VRExperienceHelperControllerGazer2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this._laserPointer.dispose();
    if (this._meshAttachedObserver) {
      this.webVRController._meshAttachedObservable.remove(this._meshAttachedObserver);
    }
  };
  return VRExperienceHelperControllerGazer2;
}(VRExperienceHelperGazer);
var VRExperienceHelperCameraGazer = function(_super) {
  __extends(VRExperienceHelperCameraGazer2, _super);
  function VRExperienceHelperCameraGazer2(getCamera, scene) {
    var _this = _super.call(this, scene) || this;
    _this.getCamera = getCamera;
    return _this;
  }
  VRExperienceHelperCameraGazer2.prototype._getForwardRay = function(length) {
    var camera = this.getCamera();
    if (camera) {
      return camera.getForwardRay(length);
    } else {
      return new Ray(Vector3.Zero(), Vector3.Forward());
    }
  };
  return VRExperienceHelperCameraGazer2;
}(VRExperienceHelperGazer);
var OnAfterEnteringVRObservableEvent = function() {
  function OnAfterEnteringVRObservableEvent2() {
  }
  return OnAfterEnteringVRObservableEvent2;
}();
var VRExperienceHelper = function() {
  function VRExperienceHelper2(scene, webVROptions) {
    var _this = this;
    if (webVROptions === void 0) {
      webVROptions = {};
    }
    this.webVROptions = webVROptions;
    this._webVRsupported = false;
    this._webVRready = false;
    this._webVRrequesting = false;
    this._webVRpresenting = false;
    this._fullscreenVRpresenting = false;
    this.enableGazeEvenWhenNoPointerLock = false;
    this.exitVROnDoubleTap = true;
    this.onEnteringVRObservable = new Observable();
    this.onAfterEnteringVRObservable = new Observable();
    this.onExitingVRObservable = new Observable();
    this.onControllerMeshLoadedObservable = new Observable();
    this._useCustomVRButton = false;
    this._teleportationRequested = false;
    this._teleportActive = false;
    this._floorMeshesCollection = [];
    this._teleportationMode = VRExperienceHelper2.TELEPORTATIONMODE_CONSTANTTIME;
    this._teleportationTime = 122;
    this._teleportationSpeed = 20;
    this._rotationAllowed = true;
    this._teleportBackwardsVector = new Vector3(0, -1, -1);
    this._isDefaultTeleportationTarget = true;
    this._teleportationFillColor = "#444444";
    this._teleportationBorderColor = "#FFFFFF";
    this._rotationAngle = 0;
    this._haloCenter = new Vector3(0, 0, 0);
    this._padSensibilityUp = 0.65;
    this._padSensibilityDown = 0.35;
    this._leftController = null;
    this._rightController = null;
    this._gazeColor = new Color3(0.7, 0.7, 0.7);
    this._laserColor = new Color3(0.7, 0.7, 0.7);
    this._pickedLaserColor = new Color3(0.2, 0.2, 1);
    this._pickedGazeColor = new Color3(0, 0, 1);
    this.onNewMeshSelected = new Observable();
    this.onMeshSelectedWithController = new Observable();
    this.onNewMeshPicked = new Observable();
    this.onBeforeCameraTeleport = new Observable();
    this.onAfterCameraTeleport = new Observable();
    this.onSelectedMeshUnselected = new Observable();
    this.teleportationEnabled = true;
    this._teleportationInitialized = false;
    this._interactionsEnabled = false;
    this._interactionsRequested = false;
    this._displayGaze = true;
    this._displayLaserPointer = true;
    this.updateGazeTrackerScale = true;
    this.updateGazeTrackerColor = true;
    this.updateControllerLaserColor = true;
    this.requestPointerLockOnFullScreen = true;
    this.xrTestDone = false;
    this._onResize = function() {
      _this.moveButtonToBottomRight();
      if (_this._fullscreenVRpresenting && _this._webVRready) {
        _this.exitVR();
      }
    };
    this._onFullscreenChange = function() {
      var anyDoc = document;
      if (anyDoc.fullscreen !== void 0) {
        _this._fullscreenVRpresenting = document.fullscreen;
      } else if (anyDoc.mozFullScreen !== void 0) {
        _this._fullscreenVRpresenting = anyDoc.mozFullScreen;
      } else if (anyDoc.webkitIsFullScreen !== void 0) {
        _this._fullscreenVRpresenting = anyDoc.webkitIsFullScreen;
      } else if (anyDoc.msIsFullScreen !== void 0) {
        _this._fullscreenVRpresenting = anyDoc.msIsFullScreen;
      } else if (document.msFullscreenElement !== void 0) {
        _this._fullscreenVRpresenting = document.msFullscreenElement;
      }
      if (!_this._fullscreenVRpresenting && _this._inputElement) {
        _this.exitVR();
        if (!_this._useCustomVRButton && _this._btnVR) {
          _this._btnVR.style.top = _this._inputElement.offsetTop + _this._inputElement.offsetHeight - 70 + "px";
          _this._btnVR.style.left = _this._inputElement.offsetLeft + _this._inputElement.offsetWidth - 100 + "px";
          _this.updateButtonVisibility();
        }
      }
    };
    this._cachedAngularSensibility = { angularSensibilityX: null, angularSensibilityY: null, angularSensibility: null };
    this.beforeRender = function() {
      if (_this._leftController && _this._leftController._activePointer) {
        _this._castRayAndSelectObject(_this._leftController);
      }
      if (_this._rightController && _this._rightController._activePointer) {
        _this._castRayAndSelectObject(_this._rightController);
      }
      if (_this._noControllerIsActive && (_this._scene.getEngine().isPointerLock || _this.enableGazeEvenWhenNoPointerLock)) {
        _this._castRayAndSelectObject(_this._cameraGazer);
      } else {
        _this._cameraGazer._gazeTracker.isVisible = false;
      }
    };
    this._onNewGamepadConnected = function(gamepad) {
      if (gamepad.type !== Gamepad.POSE_ENABLED) {
        if (gamepad.leftStick) {
          gamepad.onleftstickchanged(function(stickValues) {
            if (_this._teleportationInitialized && _this.teleportationEnabled) {
              if (!_this._leftController && !_this._rightController || _this._leftController && !_this._leftController._activePointer && (_this._rightController && !_this._rightController._activePointer)) {
                _this._checkTeleportWithRay(stickValues, _this._cameraGazer);
                _this._checkTeleportBackwards(stickValues, _this._cameraGazer);
              }
            }
          });
        }
        if (gamepad.rightStick) {
          gamepad.onrightstickchanged(function(stickValues) {
            if (_this._teleportationInitialized) {
              _this._checkRotate(stickValues, _this._cameraGazer);
            }
          });
        }
        if (gamepad.type === Gamepad.XBOX) {
          gamepad.onbuttondown(function(buttonPressed) {
            if (_this._interactionsEnabled && buttonPressed === Xbox360Button.A) {
              _this._cameraGazer._selectionPointerDown();
            }
          });
          gamepad.onbuttonup(function(buttonPressed) {
            if (_this._interactionsEnabled && buttonPressed === Xbox360Button.A) {
              _this._cameraGazer._selectionPointerUp();
            }
          });
        }
      } else {
        var webVRController = gamepad;
        var controller = new VRExperienceHelperControllerGazer(webVRController, _this._scene, _this._cameraGazer._gazeTracker);
        if (webVRController.hand === "right" || _this._leftController && _this._leftController.webVRController != webVRController) {
          _this._rightController = controller;
        } else {
          _this._leftController = controller;
        }
        _this._tryEnableInteractionOnController(controller);
      }
    };
    this._tryEnableInteractionOnController = function(controller) {
      if (_this._interactionsRequested && !controller._interactionsEnabled) {
        _this._enableInteractionOnController(controller);
      }
      if (_this._teleportationRequested && !controller._teleportationEnabled) {
        _this._enableTeleportationOnController(controller);
      }
    };
    this._onNewGamepadDisconnected = function(gamepad) {
      if (gamepad instanceof WebVRController) {
        if (gamepad.hand === "left" && _this._leftController != null) {
          _this._leftController.dispose();
          _this._leftController = null;
        }
        if (gamepad.hand === "right" && _this._rightController != null) {
          _this._rightController.dispose();
          _this._rightController = null;
        }
      }
    };
    this._workingVector = Vector3.Zero();
    this._workingQuaternion = Quaternion.Identity();
    this._workingMatrix = Matrix.Identity();
    this._scene = scene;
    this._inputElement = scene.getEngine().getInputElement();
    var vrSupported = "getVRDisplays" in navigator;
    if (!vrSupported) {
      webVROptions.useXR = true;
    }
    if (webVROptions.createFallbackVRDeviceOrientationFreeCamera === void 0) {
      webVROptions.createFallbackVRDeviceOrientationFreeCamera = true;
    }
    if (webVROptions.createDeviceOrientationCamera === void 0) {
      webVROptions.createDeviceOrientationCamera = true;
    }
    if (webVROptions.laserToggle === void 0) {
      webVROptions.laserToggle = true;
    }
    if (webVROptions.defaultHeight === void 0) {
      webVROptions.defaultHeight = 1.7;
    }
    if (webVROptions.useCustomVRButton) {
      this._useCustomVRButton = true;
      if (webVROptions.customVRButton) {
        this._btnVR = webVROptions.customVRButton;
      }
    }
    if (webVROptions.rayLength) {
      this._rayLength = webVROptions.rayLength;
    }
    this._defaultHeight = webVROptions.defaultHeight;
    if (webVROptions.positionScale) {
      this._rayLength *= webVROptions.positionScale;
      this._defaultHeight *= webVROptions.positionScale;
    }
    this._hasEnteredVR = false;
    if (this._scene.activeCamera) {
      this._position = this._scene.activeCamera.position.clone();
    } else {
      this._position = new Vector3(0, this._defaultHeight, 0);
    }
    if (webVROptions.createDeviceOrientationCamera || !this._scene.activeCamera) {
      this._deviceOrientationCamera = new DeviceOrientationCamera("deviceOrientationVRHelper", this._position.clone(), scene);
      if (this._scene.activeCamera) {
        this._deviceOrientationCamera.minZ = this._scene.activeCamera.minZ;
        this._deviceOrientationCamera.maxZ = this._scene.activeCamera.maxZ;
        if (this._scene.activeCamera instanceof TargetCamera && this._scene.activeCamera.rotation) {
          var targetCamera = this._scene.activeCamera;
          if (targetCamera.rotationQuaternion) {
            this._deviceOrientationCamera.rotationQuaternion.copyFrom(targetCamera.rotationQuaternion);
          } else {
            this._deviceOrientationCamera.rotationQuaternion.copyFrom(Quaternion.RotationYawPitchRoll(targetCamera.rotation.y, targetCamera.rotation.x, targetCamera.rotation.z));
          }
          this._deviceOrientationCamera.rotation = targetCamera.rotation.clone();
        }
      }
      this._scene.activeCamera = this._deviceOrientationCamera;
      if (this._inputElement) {
        this._scene.activeCamera.attachControl();
      }
    } else {
      this._existingCamera = this._scene.activeCamera;
    }
    if (this.webVROptions.useXR && navigator.xr) {
      WebXRSessionManager.IsSessionSupportedAsync("immersive-vr").then(function(supported) {
        if (supported) {
          Logger.Log("Using WebXR. It is recommended to use the WebXRDefaultExperience directly");
          scene.createDefaultXRExperienceAsync({
            floorMeshes: webVROptions.floorMeshes || []
          }).then(function(xr) {
            _this.xr = xr;
            _this.xrTestDone = true;
            _this._cameraGazer = new VRExperienceHelperCameraGazer(function() {
              return _this.xr.baseExperience.camera;
            }, scene);
            _this.xr.baseExperience.onStateChangedObservable.add(function(state) {
              switch (state) {
                case WebXRState.ENTERING_XR:
                  _this.onEnteringVRObservable.notifyObservers(_this);
                  if (!_this._interactionsEnabled) {
                    _this.xr.pointerSelection.detach();
                  }
                  _this.xr.pointerSelection.displayLaserPointer = _this._displayLaserPointer;
                  break;
                case WebXRState.EXITING_XR:
                  _this.onExitingVRObservable.notifyObservers(_this);
                  _this._scene.getEngine().resize();
                  break;
                case WebXRState.IN_XR:
                  _this._hasEnteredVR = true;
                  break;
                case WebXRState.NOT_IN_XR:
                  _this._hasEnteredVR = false;
                  break;
              }
            });
          });
        } else {
          _this.completeVRInit(scene, webVROptions);
        }
      });
    } else {
      this.completeVRInit(scene, webVROptions);
    }
  }
  Object.defineProperty(VRExperienceHelper2.prototype, "onEnteringVR", {
    get: function() {
      return this.onEnteringVRObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VRExperienceHelper2.prototype, "onExitingVR", {
    get: function() {
      return this.onExitingVRObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VRExperienceHelper2.prototype, "onControllerMeshLoaded", {
    get: function() {
      return this.onControllerMeshLoadedObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VRExperienceHelper2.prototype, "teleportationTarget", {
    get: function() {
      return this._teleportationTarget;
    },
    set: function(value) {
      if (value) {
        value.name = "teleportationTarget";
        this._isDefaultTeleportationTarget = false;
        this._teleportationTarget = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VRExperienceHelper2.prototype, "gazeTrackerMesh", {
    get: function() {
      return this._cameraGazer._gazeTracker;
    },
    set: function(value) {
      if (value) {
        if (this._cameraGazer._gazeTracker) {
          this._cameraGazer._gazeTracker.dispose();
        }
        if (this._leftController && this._leftController._gazeTracker) {
          this._leftController._gazeTracker.dispose();
        }
        if (this._rightController && this._rightController._gazeTracker) {
          this._rightController._gazeTracker.dispose();
        }
        this._cameraGazer._gazeTracker = value;
        this._cameraGazer._gazeTracker.bakeCurrentTransformIntoVertices();
        this._cameraGazer._gazeTracker.isPickable = false;
        this._cameraGazer._gazeTracker.isVisible = false;
        this._cameraGazer._gazeTracker.name = "gazeTracker";
        if (this._leftController) {
          this._leftController._gazeTracker = this._cameraGazer._gazeTracker.clone("gazeTracker");
        }
        if (this._rightController) {
          this._rightController._gazeTracker = this._cameraGazer._gazeTracker.clone("gazeTracker");
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VRExperienceHelper2.prototype, "leftControllerGazeTrackerMesh", {
    get: function() {
      if (this._leftController) {
        return this._leftController._gazeTracker;
      }
      return null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VRExperienceHelper2.prototype, "rightControllerGazeTrackerMesh", {
    get: function() {
      if (this._rightController) {
        return this._rightController._gazeTracker;
      }
      return null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VRExperienceHelper2.prototype, "displayGaze", {
    get: function() {
      return this._displayGaze;
    },
    set: function(value) {
      this._displayGaze = value;
      if (!value) {
        this._cameraGazer._gazeTracker.isVisible = false;
        if (this._leftController) {
          this._leftController._gazeTracker.isVisible = false;
        }
        if (this._rightController) {
          this._rightController._gazeTracker.isVisible = false;
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VRExperienceHelper2.prototype, "displayLaserPointer", {
    get: function() {
      return this._displayLaserPointer;
    },
    set: function(value) {
      this._displayLaserPointer = value;
      if (!value) {
        if (this._rightController) {
          this._rightController._deactivatePointer();
          this._rightController._gazeTracker.isVisible = false;
        }
        if (this._leftController) {
          this._leftController._deactivatePointer();
          this._leftController._gazeTracker.isVisible = false;
        }
      } else {
        if (this._rightController) {
          this._rightController._activatePointer();
        }
        if (this._leftController) {
          this._leftController._activatePointer();
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VRExperienceHelper2.prototype, "deviceOrientationCamera", {
    get: function() {
      return this._deviceOrientationCamera;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VRExperienceHelper2.prototype, "currentVRCamera", {
    get: function() {
      if (this._webVRready) {
        return this._webVRCamera;
      } else {
        return this._scene.activeCamera;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VRExperienceHelper2.prototype, "webVRCamera", {
    get: function() {
      return this._webVRCamera;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VRExperienceHelper2.prototype, "vrDeviceOrientationCamera", {
    get: function() {
      return this._vrDeviceOrientationCamera;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VRExperienceHelper2.prototype, "vrButton", {
    get: function() {
      return this._btnVR;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VRExperienceHelper2.prototype, "_teleportationRequestInitiated", {
    get: function() {
      var result = this._cameraGazer._teleportationRequestInitiated || this._leftController !== null && this._leftController._teleportationRequestInitiated || this._rightController !== null && this._rightController._teleportationRequestInitiated;
      return result;
    },
    enumerable: false,
    configurable: true
  });
  VRExperienceHelper2.prototype.completeVRInit = function(scene, webVROptions) {
    var _this = this;
    this.xrTestDone = true;
    if (webVROptions.createFallbackVRDeviceOrientationFreeCamera) {
      if (webVROptions.useMultiview) {
        if (!webVROptions.vrDeviceOrientationCameraMetrics) {
          webVROptions.vrDeviceOrientationCameraMetrics = VRCameraMetrics.GetDefault();
        }
        webVROptions.vrDeviceOrientationCameraMetrics.multiviewEnabled = true;
      }
      this._vrDeviceOrientationCamera = new VRDeviceOrientationFreeCamera("VRDeviceOrientationVRHelper", this._position, this._scene, true, webVROptions.vrDeviceOrientationCameraMetrics);
      this._vrDeviceOrientationCamera.angularSensibility = Number.MAX_VALUE;
    }
    this._webVRCamera = new WebVRFreeCamera("WebVRHelper", this._position, this._scene, webVROptions);
    this._webVRCamera.useStandingMatrix();
    this._cameraGazer = new VRExperienceHelperCameraGazer(function() {
      return _this.currentVRCamera;
    }, scene);
    if (!this._useCustomVRButton) {
      this._btnVR = document.createElement("BUTTON");
      this._btnVR.className = "babylonVRicon";
      this._btnVR.id = "babylonVRiconbtn";
      this._btnVR.title = "Click to switch to VR";
      var url = !window.SVGSVGElement ? "https://cdn.babylonjs.com/Assets/vrButton.png" : "data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%222048%22%20height%3D%221152%22%20viewBox%3D%220%200%202048%201152%22%20version%3D%221.1%22%3E%3Cpath%20transform%3D%22rotate%28180%201024%2C576.0000000000001%29%22%20d%3D%22m1109%2C896q17%2C0%2030%2C-12t13%2C-30t-12.5%2C-30.5t-30.5%2C-12.5l-170%2C0q-18%2C0%20-30.5%2C12.5t-12.5%2C30.5t13%2C30t30%2C12l170%2C0zm-85%2C256q59%2C0%20132.5%2C-1.5t154.5%2C-5.5t164.5%2C-11.5t163%2C-20t150%2C-30t124.5%2C-41.5q23%2C-11%2042%2C-24t38%2C-30q27%2C-25%2041%2C-61.5t14%2C-72.5l0%2C-257q0%2C-123%20-47%2C-232t-128%2C-190t-190%2C-128t-232%2C-47l-81%2C0q-37%2C0%20-68.5%2C14t-60.5%2C34.5t-55.5%2C45t-53%2C45t-53%2C34.5t-55.5%2C14t-55.5%2C-14t-53%2C-34.5t-53%2C-45t-55.5%2C-45t-60.5%2C-34.5t-68.5%2C-14l-81%2C0q-123%2C0%20-232%2C47t-190%2C128t-128%2C190t-47%2C232l0%2C257q0%2C68%2038%2C115t97%2C73q54%2C24%20124.5%2C41.5t150%2C30t163%2C20t164.5%2C11.5t154.5%2C5.5t132.5%2C1.5zm939%2C-298q0%2C39%20-24.5%2C67t-58.5%2C42q-54%2C23%20-122%2C39.5t-143.5%2C28t-155.5%2C19t-157%2C11t-148.5%2C5t-129.5%2C1.5q-59%2C0%20-130%2C-1.5t-148%2C-5t-157%2C-11t-155.5%2C-19t-143.5%2C-28t-122%2C-39.5q-34%2C-14%20-58.5%2C-42t-24.5%2C-67l0%2C-257q0%2C-106%2040.5%2C-199t110%2C-162.5t162.5%2C-109.5t199%2C-40l81%2C0q27%2C0%2052%2C14t50%2C34.5t51%2C44.5t55.5%2C44.5t63.5%2C34.5t74%2C14t74%2C-14t63.5%2C-34.5t55.5%2C-44.5t51%2C-44.5t50%2C-34.5t52%2C-14l14%2C0q37%2C0%2070%2C0.5t64.5%2C4.5t63.5%2C12t68%2C23q71%2C30%20128.5%2C78.5t98.5%2C110t63.5%2C133.5t22.5%2C149l0%2C257z%22%20fill%3D%22white%22%20/%3E%3C/svg%3E%0A";
      var css = ".babylonVRicon { position: absolute; right: 20px; height: 50px; width: 80px; background-color: rgba(51,51,51,0.7); background-image: url(" + url + "); background-size: 80%; background-repeat:no-repeat; background-position: center; border: none; outline: none; transition: transform 0.125s ease-out } .babylonVRicon:hover { transform: scale(1.05) } .babylonVRicon:active {background-color: rgba(51,51,51,1) } .babylonVRicon:focus {background-color: rgba(51,51,51,1) }";
      css += ".babylonVRicon.vrdisplaypresenting { display: none; }";
      var style = document.createElement("style");
      style.appendChild(document.createTextNode(css));
      document.getElementsByTagName("head")[0].appendChild(style);
      this.moveButtonToBottomRight();
    }
    if (this._btnVR) {
      this._btnVR.addEventListener("click", function() {
        if (!_this.isInVRMode) {
          _this.enterVR();
        } else {
          _this._scene.getEngine().disableVR();
        }
      });
    }
    var hostWindow = this._scene.getEngine().getHostWindow();
    if (!hostWindow) {
      return;
    }
    hostWindow.addEventListener("resize", this._onResize);
    document.addEventListener("fullscreenchange", this._onFullscreenChange, false);
    document.addEventListener("mozfullscreenchange", this._onFullscreenChange, false);
    document.addEventListener("webkitfullscreenchange", this._onFullscreenChange, false);
    document.addEventListener("msfullscreenchange", this._onFullscreenChange, false);
    document.onmsfullscreenchange = this._onFullscreenChange;
    if (webVROptions.createFallbackVRDeviceOrientationFreeCamera) {
      this.displayVRButton();
    } else {
      this._scene.getEngine().onVRDisplayChangedObservable.add(function(e) {
        if (e.vrDisplay) {
          _this.displayVRButton();
        }
      });
    }
    this._onKeyDown = function(event) {
      if (event.keyCode === 27 && _this.isInVRMode) {
        _this.exitVR();
      }
    };
    document.addEventListener("keydown", this._onKeyDown);
    this._scene.onPrePointerObservable.add(function() {
      if (_this._hasEnteredVR && _this.exitVROnDoubleTap) {
        _this.exitVR();
        if (_this._fullscreenVRpresenting) {
          _this._scene.getEngine().exitFullscreen();
        }
      }
    }, PointerEventTypes.POINTERDOUBLETAP, false);
    this._onVRDisplayChanged = function(eventArgs) {
      return _this.onVRDisplayChanged(eventArgs);
    };
    this._onVrDisplayPresentChange = function() {
      return _this.onVrDisplayPresentChange();
    };
    this._onVRRequestPresentStart = function() {
      _this._webVRrequesting = true;
      _this.updateButtonVisibility();
    };
    this._onVRRequestPresentComplete = function() {
      _this._webVRrequesting = false;
      _this.updateButtonVisibility();
    };
    scene.getEngine().onVRDisplayChangedObservable.add(this._onVRDisplayChanged);
    scene.getEngine().onVRRequestPresentStart.add(this._onVRRequestPresentStart);
    scene.getEngine().onVRRequestPresentComplete.add(this._onVRRequestPresentComplete);
    hostWindow.addEventListener("vrdisplaypresentchange", this._onVrDisplayPresentChange);
    scene.onDisposeObservable.add(function() {
      _this.dispose();
    });
    this._webVRCamera.onControllerMeshLoadedObservable.add(function(webVRController) {
      return _this._onDefaultMeshLoaded(webVRController);
    });
    this._scene.gamepadManager.onGamepadConnectedObservable.add(this._onNewGamepadConnected);
    this._scene.gamepadManager.onGamepadDisconnectedObservable.add(this._onNewGamepadDisconnected);
    this.updateButtonVisibility();
    this._circleEase = new CircleEase();
    this._circleEase.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);
    this._teleportationEasing = this._circleEase;
    scene.onPointerObservable.add(function(e) {
      if (_this._interactionsEnabled) {
        if (scene.activeCamera === _this.vrDeviceOrientationCamera && e.event.pointerType === "mouse") {
          if (e.type === PointerEventTypes.POINTERDOWN) {
            _this._cameraGazer._selectionPointerDown();
          } else if (e.type === PointerEventTypes.POINTERUP) {
            _this._cameraGazer._selectionPointerUp();
          }
        }
      }
    });
    if (this.webVROptions.floorMeshes) {
      this.enableTeleportation({ floorMeshes: this.webVROptions.floorMeshes });
    }
  };
  VRExperienceHelper2.prototype._onDefaultMeshLoaded = function(webVRController) {
    if (this._leftController && this._leftController.webVRController == webVRController) {
      if (webVRController.mesh) {
        this._leftController._setLaserPointerParent(webVRController.mesh);
      }
    }
    if (this._rightController && this._rightController.webVRController == webVRController) {
      if (webVRController.mesh) {
        this._rightController._setLaserPointerParent(webVRController.mesh);
      }
    }
    try {
      this.onControllerMeshLoadedObservable.notifyObservers(webVRController);
    } catch (err) {
      Logger.Warn("Error in your custom logic onControllerMeshLoaded: " + err);
    }
  };
  Object.defineProperty(VRExperienceHelper2.prototype, "isInVRMode", {
    get: function() {
      return this.xr && this.webVROptions.useXR && this.xr.baseExperience.state === WebXRState.IN_XR || (this._webVRpresenting || this._fullscreenVRpresenting);
    },
    enumerable: false,
    configurable: true
  });
  VRExperienceHelper2.prototype.onVrDisplayPresentChange = function() {
    var vrDisplay = this._scene.getEngine().getVRDevice();
    if (vrDisplay) {
      var wasPresenting = this._webVRpresenting;
      this._webVRpresenting = vrDisplay.isPresenting;
      if (wasPresenting && !this._webVRpresenting) {
        this.exitVR();
      }
    } else {
      Logger.Warn("Detected VRDisplayPresentChange on an unknown VRDisplay. Did you can enterVR on the vrExperienceHelper?");
    }
    this.updateButtonVisibility();
  };
  VRExperienceHelper2.prototype.onVRDisplayChanged = function(eventArgs) {
    this._webVRsupported = eventArgs.vrSupported;
    this._webVRready = !!eventArgs.vrDisplay;
    this._webVRpresenting = eventArgs.vrDisplay && eventArgs.vrDisplay.isPresenting;
    this.updateButtonVisibility();
  };
  VRExperienceHelper2.prototype.moveButtonToBottomRight = function() {
    if (this._inputElement && !this._useCustomVRButton && this._btnVR) {
      var rect = this._inputElement.getBoundingClientRect();
      this._btnVR.style.top = rect.top + rect.height - 70 + "px";
      this._btnVR.style.left = rect.left + rect.width - 100 + "px";
    }
  };
  VRExperienceHelper2.prototype.displayVRButton = function() {
    if (!this._useCustomVRButton && !this._btnVRDisplayed && this._btnVR) {
      document.body.appendChild(this._btnVR);
      this._btnVRDisplayed = true;
    }
  };
  VRExperienceHelper2.prototype.updateButtonVisibility = function() {
    if (!this._btnVR || this._useCustomVRButton) {
      return;
    }
    this._btnVR.className = "babylonVRicon";
    if (this.isInVRMode) {
      this._btnVR.className += " vrdisplaypresenting";
    } else {
      if (this._webVRready) {
        this._btnVR.className += " vrdisplayready";
      }
      if (this._webVRsupported) {
        this._btnVR.className += " vrdisplaysupported";
      }
      if (this._webVRrequesting) {
        this._btnVR.className += " vrdisplayrequesting";
      }
    }
  };
  VRExperienceHelper2.prototype.enterVR = function() {
    var _this = this;
    if (this.xr) {
      this.xr.baseExperience.enterXRAsync("immersive-vr", "local-floor", this.xr.renderTarget);
      return;
    }
    if (this.onEnteringVRObservable) {
      try {
        this.onEnteringVRObservable.notifyObservers(this);
      } catch (err) {
        Logger.Warn("Error in your custom logic onEnteringVR: " + err);
      }
    }
    if (this._scene.activeCamera) {
      this._position = this._scene.activeCamera.position.clone();
      if (this.vrDeviceOrientationCamera) {
        this.vrDeviceOrientationCamera.rotation = Quaternion.FromRotationMatrix(this._scene.activeCamera.getWorldMatrix().getRotationMatrix()).toEulerAngles();
        this.vrDeviceOrientationCamera.angularSensibility = 2e3;
      }
      if (this.webVRCamera) {
        var currentYRotation = this.webVRCamera.deviceRotationQuaternion.toEulerAngles().y;
        var desiredYRotation = Quaternion.FromRotationMatrix(this._scene.activeCamera.getWorldMatrix().getRotationMatrix()).toEulerAngles().y;
        var delta = desiredYRotation - currentYRotation;
        var currentGlobalRotation = this.webVRCamera.rotationQuaternion.toEulerAngles().y;
        this.webVRCamera.rotationQuaternion = Quaternion.FromEulerAngles(0, currentGlobalRotation + delta, 0);
      }
      this._existingCamera = this._scene.activeCamera;
      if (this._existingCamera.angularSensibilityX) {
        this._cachedAngularSensibility.angularSensibilityX = this._existingCamera.angularSensibilityX;
        this._existingCamera.angularSensibilityX = Number.MAX_VALUE;
      }
      if (this._existingCamera.angularSensibilityY) {
        this._cachedAngularSensibility.angularSensibilityY = this._existingCamera.angularSensibilityY;
        this._existingCamera.angularSensibilityY = Number.MAX_VALUE;
      }
      if (this._existingCamera.angularSensibility) {
        this._cachedAngularSensibility.angularSensibility = this._existingCamera.angularSensibility;
        this._existingCamera.angularSensibility = Number.MAX_VALUE;
      }
    }
    if (this._webVRrequesting) {
      return;
    }
    if (this._webVRready) {
      if (!this._webVRpresenting) {
        this._scene.getEngine().onVRRequestPresentComplete.addOnce(function(result) {
          _this.onAfterEnteringVRObservable.notifyObservers({ success: result });
        });
        this._webVRCamera.position = this._position;
        this._scene.activeCamera = this._webVRCamera;
      }
    } else if (this._vrDeviceOrientationCamera) {
      this._vrDeviceOrientationCamera.position = this._position;
      if (this._scene.activeCamera) {
        this._vrDeviceOrientationCamera.minZ = this._scene.activeCamera.minZ;
      }
      this._scene.activeCamera = this._vrDeviceOrientationCamera;
      this._scene.getEngine().enterFullscreen(this.requestPointerLockOnFullScreen);
      this.updateButtonVisibility();
      this._vrDeviceOrientationCamera.onViewMatrixChangedObservable.addOnce(function() {
        _this.onAfterEnteringVRObservable.notifyObservers({ success: true });
      });
    }
    if (this._scene.activeCamera && this._inputElement) {
      this._scene.activeCamera.attachControl();
    }
    if (this._interactionsEnabled) {
      this._scene.registerBeforeRender(this.beforeRender);
    }
    if (this._displayLaserPointer) {
      [this._leftController, this._rightController].forEach(function(controller) {
        if (controller) {
          controller._activatePointer();
        }
      });
    }
    this._hasEnteredVR = true;
  };
  VRExperienceHelper2.prototype.exitVR = function() {
    if (this.xr) {
      this.xr.baseExperience.exitXRAsync();
      return;
    }
    if (this._hasEnteredVR) {
      if (this.onExitingVRObservable) {
        try {
          this.onExitingVRObservable.notifyObservers(this);
        } catch (err) {
          Logger.Warn("Error in your custom logic onExitingVR: " + err);
        }
      }
      if (this._webVRpresenting) {
        this._scene.getEngine().disableVR();
      }
      if (this._scene.activeCamera) {
        this._position = this._scene.activeCamera.position.clone();
      }
      if (this.vrDeviceOrientationCamera) {
        this.vrDeviceOrientationCamera.angularSensibility = Number.MAX_VALUE;
      }
      if (this._deviceOrientationCamera) {
        this._deviceOrientationCamera.position = this._position;
        this._scene.activeCamera = this._deviceOrientationCamera;
        if (this._cachedAngularSensibility.angularSensibilityX) {
          this._deviceOrientationCamera.angularSensibilityX = this._cachedAngularSensibility.angularSensibilityX;
          this._cachedAngularSensibility.angularSensibilityX = null;
        }
        if (this._cachedAngularSensibility.angularSensibilityY) {
          this._deviceOrientationCamera.angularSensibilityY = this._cachedAngularSensibility.angularSensibilityY;
          this._cachedAngularSensibility.angularSensibilityY = null;
        }
        if (this._cachedAngularSensibility.angularSensibility) {
          this._deviceOrientationCamera.angularSensibility = this._cachedAngularSensibility.angularSensibility;
          this._cachedAngularSensibility.angularSensibility = null;
        }
      } else if (this._existingCamera) {
        this._existingCamera.position = this._position;
        this._scene.activeCamera = this._existingCamera;
        if (this._inputElement) {
          this._scene.activeCamera.attachControl();
        }
        if (this._cachedAngularSensibility.angularSensibilityX) {
          this._existingCamera.angularSensibilityX = this._cachedAngularSensibility.angularSensibilityX;
          this._cachedAngularSensibility.angularSensibilityX = null;
        }
        if (this._cachedAngularSensibility.angularSensibilityY) {
          this._existingCamera.angularSensibilityY = this._cachedAngularSensibility.angularSensibilityY;
          this._cachedAngularSensibility.angularSensibilityY = null;
        }
        if (this._cachedAngularSensibility.angularSensibility) {
          this._existingCamera.angularSensibility = this._cachedAngularSensibility.angularSensibility;
          this._cachedAngularSensibility.angularSensibility = null;
        }
      }
      this.updateButtonVisibility();
      if (this._interactionsEnabled) {
        this._scene.unregisterBeforeRender(this.beforeRender);
        this._cameraGazer._gazeTracker.isVisible = false;
        if (this._leftController) {
          this._leftController._gazeTracker.isVisible = false;
        }
        if (this._rightController) {
          this._rightController._gazeTracker.isVisible = false;
        }
      }
      this._scene.getEngine().resize();
      [this._leftController, this._rightController].forEach(function(controller) {
        if (controller) {
          controller._deactivatePointer();
        }
      });
      this._hasEnteredVR = false;
      var engine = this._scene.getEngine();
      if (engine._onVrDisplayPresentChange) {
        engine._onVrDisplayPresentChange();
      }
    }
  };
  Object.defineProperty(VRExperienceHelper2.prototype, "position", {
    get: function() {
      return this._position;
    },
    set: function(value) {
      this._position = value;
      if (this._scene.activeCamera) {
        this._scene.activeCamera.position = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  VRExperienceHelper2.prototype.enableInteractions = function() {
    var _this = this;
    if (!this._interactionsEnabled) {
      this._interactionsRequested = true;
      if (this.xr) {
        if (this.xr.baseExperience.state === WebXRState.IN_XR) {
          this.xr.pointerSelection.attach();
        }
        return;
      }
      if (this._leftController) {
        this._enableInteractionOnController(this._leftController);
      }
      if (this._rightController) {
        this._enableInteractionOnController(this._rightController);
      }
      this.raySelectionPredicate = function(mesh) {
        return mesh.isVisible && (mesh.isPickable || mesh.name === _this._floorMeshName);
      };
      this.meshSelectionPredicate = function() {
        return true;
      };
      this._raySelectionPredicate = function(mesh) {
        if (_this._isTeleportationFloor(mesh) || mesh.name.indexOf("gazeTracker") === -1 && mesh.name.indexOf("teleportationTarget") === -1 && mesh.name.indexOf("torusTeleportation") === -1) {
          return _this.raySelectionPredicate(mesh);
        }
        return false;
      };
      this._interactionsEnabled = true;
    }
  };
  Object.defineProperty(VRExperienceHelper2.prototype, "_noControllerIsActive", {
    get: function() {
      return !(this._leftController && this._leftController._activePointer) && !(this._rightController && this._rightController._activePointer);
    },
    enumerable: false,
    configurable: true
  });
  VRExperienceHelper2.prototype._isTeleportationFloor = function(mesh) {
    for (var i = 0; i < this._floorMeshesCollection.length; i++) {
      if (this._floorMeshesCollection[i].id === mesh.id) {
        return true;
      }
    }
    if (this._floorMeshName && mesh.name === this._floorMeshName) {
      return true;
    }
    return false;
  };
  VRExperienceHelper2.prototype.addFloorMesh = function(floorMesh) {
    if (!this._floorMeshesCollection) {
      return;
    }
    if (this._floorMeshesCollection.indexOf(floorMesh) > -1) {
      return;
    }
    this._floorMeshesCollection.push(floorMesh);
  };
  VRExperienceHelper2.prototype.removeFloorMesh = function(floorMesh) {
    if (!this._floorMeshesCollection) {
      return;
    }
    var meshIndex = this._floorMeshesCollection.indexOf(floorMesh);
    if (meshIndex !== -1) {
      this._floorMeshesCollection.splice(meshIndex, 1);
    }
  };
  VRExperienceHelper2.prototype.enableTeleportation = function(vrTeleportationOptions) {
    var _this = this;
    if (vrTeleportationOptions === void 0) {
      vrTeleportationOptions = {};
    }
    if (!this._teleportationInitialized) {
      this._teleportationRequested = true;
      this.enableInteractions();
      if (this.webVROptions.useXR && (vrTeleportationOptions.floorMeshes || vrTeleportationOptions.floorMeshName)) {
        var floorMeshes = vrTeleportationOptions.floorMeshes || [];
        if (!floorMeshes.length) {
          var floorMesh = this._scene.getMeshByName(vrTeleportationOptions.floorMeshName);
          if (floorMesh) {
            floorMeshes.push(floorMesh);
          }
        }
        if (this.xr) {
          floorMeshes.forEach(function(mesh) {
            _this.xr.teleportation.addFloorMesh(mesh);
          });
          if (!this.xr.teleportation.attached) {
            this.xr.teleportation.attach();
          }
          return;
        } else if (!this.xrTestDone) {
          var waitForXr_1 = function() {
            if (_this.xrTestDone) {
              _this._scene.unregisterBeforeRender(waitForXr_1);
              if (_this.xr) {
                if (!_this.xr.teleportation.attached) {
                  _this.xr.teleportation.attach();
                }
              } else {
                _this.enableTeleportation(vrTeleportationOptions);
              }
            }
          };
          this._scene.registerBeforeRender(waitForXr_1);
          return;
        }
      }
      if (vrTeleportationOptions.floorMeshName) {
        this._floorMeshName = vrTeleportationOptions.floorMeshName;
      }
      if (vrTeleportationOptions.floorMeshes) {
        this._floorMeshesCollection = vrTeleportationOptions.floorMeshes;
      }
      if (vrTeleportationOptions.teleportationMode) {
        this._teleportationMode = vrTeleportationOptions.teleportationMode;
      }
      if (vrTeleportationOptions.teleportationTime && vrTeleportationOptions.teleportationTime > 0) {
        this._teleportationTime = vrTeleportationOptions.teleportationTime;
      }
      if (vrTeleportationOptions.teleportationSpeed && vrTeleportationOptions.teleportationSpeed > 0) {
        this._teleportationSpeed = vrTeleportationOptions.teleportationSpeed;
      }
      if (vrTeleportationOptions.easingFunction !== void 0) {
        this._teleportationEasing = vrTeleportationOptions.easingFunction;
      }
      if (this._leftController != null) {
        this._enableTeleportationOnController(this._leftController);
      }
      if (this._rightController != null) {
        this._enableTeleportationOnController(this._rightController);
      }
      var imageProcessingConfiguration = new ImageProcessingConfiguration();
      imageProcessingConfiguration.vignetteColor = new Color4(0, 0, 0, 0);
      imageProcessingConfiguration.vignetteEnabled = true;
      this._postProcessMove = new ImageProcessingPostProcess("postProcessMove", 1, this._webVRCamera, void 0, void 0, void 0, void 0, imageProcessingConfiguration);
      this._webVRCamera.detachPostProcess(this._postProcessMove);
      this._teleportationInitialized = true;
      if (this._isDefaultTeleportationTarget) {
        this._createTeleportationCircles();
        this._teleportationTarget.scaling.scaleInPlace(this._webVRCamera.deviceScaleFactor);
      }
    }
  };
  VRExperienceHelper2.prototype._enableInteractionOnController = function(controller) {
    var _this = this;
    var controllerMesh = controller.webVRController.mesh;
    if (controllerMesh) {
      controller._interactionsEnabled = true;
      if (this.isInVRMode && this._displayLaserPointer) {
        controller._activatePointer();
      }
      if (this.webVROptions.laserToggle) {
        controller.webVRController.onMainButtonStateChangedObservable.add(function(stateObject) {
          if (_this._displayLaserPointer && stateObject.value === 1) {
            if (controller._activePointer) {
              controller._deactivatePointer();
            } else {
              controller._activatePointer();
            }
            if (_this.displayGaze) {
              controller._gazeTracker.isVisible = controller._activePointer;
            }
          }
        });
      }
      controller.webVRController.onTriggerStateChangedObservable.add(function(stateObject) {
        var gazer = controller;
        if (_this._noControllerIsActive) {
          gazer = _this._cameraGazer;
        }
        if (!gazer._pointerDownOnMeshAsked) {
          if (stateObject.value > _this._padSensibilityUp) {
            gazer._selectionPointerDown();
          }
        } else if (stateObject.value < _this._padSensibilityDown) {
          gazer._selectionPointerUp();
        }
      });
    }
  };
  VRExperienceHelper2.prototype._checkTeleportWithRay = function(stateObject, gazer) {
    if (this._teleportationRequestInitiated && !gazer._teleportationRequestInitiated) {
      return;
    }
    if (!gazer._teleportationRequestInitiated) {
      if (stateObject.y < -this._padSensibilityUp && gazer._dpadPressed) {
        gazer._activatePointer();
        gazer._teleportationRequestInitiated = true;
      }
    } else {
      if (Math.sqrt(stateObject.y * stateObject.y + stateObject.x * stateObject.x) < this._padSensibilityDown) {
        if (this._teleportActive) {
          this.teleportCamera(this._haloCenter);
        }
        gazer._teleportationRequestInitiated = false;
      }
    }
  };
  VRExperienceHelper2.prototype._checkRotate = function(stateObject, gazer) {
    if (gazer._teleportationRequestInitiated) {
      return;
    }
    if (!gazer._rotationLeftAsked) {
      if (stateObject.x < -this._padSensibilityUp && gazer._dpadPressed) {
        gazer._rotationLeftAsked = true;
        if (this._rotationAllowed) {
          this._rotateCamera(false);
        }
      }
    } else {
      if (stateObject.x > -this._padSensibilityDown) {
        gazer._rotationLeftAsked = false;
      }
    }
    if (!gazer._rotationRightAsked) {
      if (stateObject.x > this._padSensibilityUp && gazer._dpadPressed) {
        gazer._rotationRightAsked = true;
        if (this._rotationAllowed) {
          this._rotateCamera(true);
        }
      }
    } else {
      if (stateObject.x < this._padSensibilityDown) {
        gazer._rotationRightAsked = false;
      }
    }
  };
  VRExperienceHelper2.prototype._checkTeleportBackwards = function(stateObject, gazer) {
    if (gazer._teleportationRequestInitiated) {
      return;
    }
    if (stateObject.y > this._padSensibilityUp && gazer._dpadPressed) {
      if (!gazer._teleportationBackRequestInitiated) {
        if (!this.currentVRCamera) {
          return;
        }
        var rotation = Quaternion.FromRotationMatrix(this.currentVRCamera.getWorldMatrix().getRotationMatrix());
        var position = this.currentVRCamera.position;
        if (this.currentVRCamera.devicePosition && this.currentVRCamera.deviceRotationQuaternion) {
          rotation = this.currentVRCamera.deviceRotationQuaternion;
          position = this.currentVRCamera.devicePosition;
        }
        rotation.toEulerAnglesToRef(this._workingVector);
        this._workingVector.z = 0;
        this._workingVector.x = 0;
        Quaternion.RotationYawPitchRollToRef(this._workingVector.y, this._workingVector.x, this._workingVector.z, this._workingQuaternion);
        this._workingQuaternion.toRotationMatrix(this._workingMatrix);
        Vector3.TransformCoordinatesToRef(this._teleportBackwardsVector, this._workingMatrix, this._workingVector);
        var ray = new Ray(position, this._workingVector);
        var hit = this._scene.pickWithRay(ray, this._raySelectionPredicate);
        if (hit && hit.pickedPoint && hit.pickedMesh && this._isTeleportationFloor(hit.pickedMesh) && hit.distance < 5) {
          this.teleportCamera(hit.pickedPoint);
        }
        gazer._teleportationBackRequestInitiated = true;
      }
    } else {
      gazer._teleportationBackRequestInitiated = false;
    }
  };
  VRExperienceHelper2.prototype._enableTeleportationOnController = function(controller) {
    var _this = this;
    var controllerMesh = controller.webVRController.mesh;
    if (controllerMesh) {
      if (!controller._interactionsEnabled) {
        this._enableInteractionOnController(controller);
      }
      controller._interactionsEnabled = true;
      controller._teleportationEnabled = true;
      if (controller.webVRController.controllerType === PoseEnabledControllerType.VIVE) {
        controller._dpadPressed = false;
        controller.webVRController.onPadStateChangedObservable.add(function(stateObject) {
          controller._dpadPressed = stateObject.pressed;
          if (!controller._dpadPressed) {
            controller._rotationLeftAsked = false;
            controller._rotationRightAsked = false;
            controller._teleportationBackRequestInitiated = false;
          }
        });
      }
      controller.webVRController.onPadValuesChangedObservable.add(function(stateObject) {
        if (_this.teleportationEnabled) {
          _this._checkTeleportBackwards(stateObject, controller);
          _this._checkTeleportWithRay(stateObject, controller);
        }
        _this._checkRotate(stateObject, controller);
      });
    }
  };
  VRExperienceHelper2.prototype._createTeleportationCircles = function() {
    this._teleportationTarget = Mesh.CreateGround("teleportationTarget", 2, 2, 2, this._scene);
    this._teleportationTarget.isPickable = false;
    var length = 512;
    var dynamicTexture = new DynamicTexture("DynamicTexture", length, this._scene, true);
    dynamicTexture.hasAlpha = true;
    var context = dynamicTexture.getContext();
    var centerX = length / 2;
    var centerY = length / 2;
    var radius = 200;
    context.beginPath();
    context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
    context.fillStyle = this._teleportationFillColor;
    context.fill();
    context.lineWidth = 10;
    context.strokeStyle = this._teleportationBorderColor;
    context.stroke();
    context.closePath();
    dynamicTexture.update();
    var teleportationCircleMaterial = new StandardMaterial("TextPlaneMaterial", this._scene);
    teleportationCircleMaterial.diffuseTexture = dynamicTexture;
    this._teleportationTarget.material = teleportationCircleMaterial;
    var torus = Mesh.CreateTorus("torusTeleportation", 0.75, 0.1, 25, this._scene, false);
    torus.isPickable = false;
    torus.parent = this._teleportationTarget;
    var animationInnerCircle = new Animation("animationInnerCircle", "position.y", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);
    var keys = [];
    keys.push({
      frame: 0,
      value: 0
    });
    keys.push({
      frame: 30,
      value: 0.4
    });
    keys.push({
      frame: 60,
      value: 0
    });
    animationInnerCircle.setKeys(keys);
    var easingFunction = new SineEase();
    easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);
    animationInnerCircle.setEasingFunction(easingFunction);
    torus.animations = [];
    torus.animations.push(animationInnerCircle);
    this._scene.beginAnimation(torus, 0, 60, true);
    this._hideTeleportationTarget();
  };
  VRExperienceHelper2.prototype._displayTeleportationTarget = function() {
    this._teleportActive = true;
    if (this._teleportationInitialized) {
      this._teleportationTarget.isVisible = true;
      if (this._isDefaultTeleportationTarget) {
        this._teleportationTarget.getChildren()[0].isVisible = true;
      }
    }
  };
  VRExperienceHelper2.prototype._hideTeleportationTarget = function() {
    this._teleportActive = false;
    if (this._teleportationInitialized) {
      this._teleportationTarget.isVisible = false;
      if (this._isDefaultTeleportationTarget) {
        this._teleportationTarget.getChildren()[0].isVisible = false;
      }
    }
  };
  VRExperienceHelper2.prototype._rotateCamera = function(right) {
    var _this = this;
    if (!(this.currentVRCamera instanceof FreeCamera)) {
      return;
    }
    if (right) {
      this._rotationAngle++;
    } else {
      this._rotationAngle--;
    }
    this.currentVRCamera.animations = [];
    var target = Quaternion.FromRotationMatrix(Matrix.RotationY(Math.PI / 4 * this._rotationAngle));
    var animationRotation = new Animation("animationRotation", "rotationQuaternion", 90, Animation.ANIMATIONTYPE_QUATERNION, Animation.ANIMATIONLOOPMODE_CONSTANT);
    var animationRotationKeys = [];
    animationRotationKeys.push({
      frame: 0,
      value: this.currentVRCamera.rotationQuaternion
    });
    animationRotationKeys.push({
      frame: 6,
      value: target
    });
    animationRotation.setKeys(animationRotationKeys);
    animationRotation.setEasingFunction(this._circleEase);
    this.currentVRCamera.animations.push(animationRotation);
    this._postProcessMove.animations = [];
    var animationPP = new Animation("animationPP", "vignetteWeight", 90, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);
    var vignetteWeightKeys = [];
    vignetteWeightKeys.push({
      frame: 0,
      value: 0
    });
    vignetteWeightKeys.push({
      frame: 3,
      value: 4
    });
    vignetteWeightKeys.push({
      frame: 6,
      value: 0
    });
    animationPP.setKeys(vignetteWeightKeys);
    animationPP.setEasingFunction(this._circleEase);
    this._postProcessMove.animations.push(animationPP);
    var animationPP2 = new Animation("animationPP2", "vignetteStretch", 90, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);
    var vignetteStretchKeys = [];
    vignetteStretchKeys.push({
      frame: 0,
      value: 0
    });
    vignetteStretchKeys.push({
      frame: 3,
      value: 10
    });
    vignetteStretchKeys.push({
      frame: 6,
      value: 0
    });
    animationPP2.setKeys(vignetteStretchKeys);
    animationPP2.setEasingFunction(this._circleEase);
    this._postProcessMove.animations.push(animationPP2);
    this._postProcessMove.imageProcessingConfiguration.vignetteWeight = 0;
    this._postProcessMove.imageProcessingConfiguration.vignetteStretch = 0;
    this._postProcessMove.samples = 4;
    this._webVRCamera.attachPostProcess(this._postProcessMove);
    this._scene.beginAnimation(this._postProcessMove, 0, 6, false, 1, function() {
      _this._webVRCamera.detachPostProcess(_this._postProcessMove);
    });
    this._scene.beginAnimation(this.currentVRCamera, 0, 6, false, 1);
  };
  VRExperienceHelper2.prototype._moveTeleportationSelectorTo = function(hit, gazer, ray) {
    if (hit.pickedPoint) {
      if (gazer._teleportationRequestInitiated) {
        this._displayTeleportationTarget();
        this._haloCenter.copyFrom(hit.pickedPoint);
        this._teleportationTarget.position.copyFrom(hit.pickedPoint);
      }
      var pickNormal = this._convertNormalToDirectionOfRay(hit.getNormal(true, false), ray);
      if (pickNormal) {
        var axis1 = Vector3.Cross(Axis.Y, pickNormal);
        var axis2 = Vector3.Cross(pickNormal, axis1);
        Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, this._teleportationTarget.rotation);
      }
      this._teleportationTarget.position.y += 0.1;
    }
  };
  VRExperienceHelper2.prototype.teleportCamera = function(location) {
    var _this = this;
    if (!(this.currentVRCamera instanceof FreeCamera)) {
      return;
    }
    if (this.webVRCamera.leftCamera) {
      this._workingVector.copyFrom(this.webVRCamera.leftCamera.globalPosition);
      this._workingVector.subtractInPlace(this.webVRCamera.position);
      location.subtractToRef(this._workingVector, this._workingVector);
    } else {
      this._workingVector.copyFrom(location);
    }
    if (this.isInVRMode) {
      this._workingVector.y += this.webVRCamera.deviceDistanceToRoomGround() * this._webVRCamera.deviceScaleFactor;
    } else {
      this._workingVector.y += this._defaultHeight;
    }
    this.onBeforeCameraTeleport.notifyObservers(this._workingVector);
    var FPS = 90;
    var speedRatio, lastFrame;
    if (this._teleportationMode == VRExperienceHelper2.TELEPORTATIONMODE_CONSTANTSPEED) {
      lastFrame = FPS;
      var dist = Vector3.Distance(this.currentVRCamera.position, this._workingVector);
      speedRatio = this._teleportationSpeed / dist;
    } else {
      lastFrame = Math.round(this._teleportationTime * FPS / 1e3);
      speedRatio = 1;
    }
    this.currentVRCamera.animations = [];
    var animationCameraTeleportation = new Animation("animationCameraTeleportation", "position", FPS, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);
    var animationCameraTeleportationKeys = [
      {
        frame: 0,
        value: this.currentVRCamera.position
      },
      {
        frame: lastFrame,
        value: this._workingVector
      }
    ];
    animationCameraTeleportation.setKeys(animationCameraTeleportationKeys);
    animationCameraTeleportation.setEasingFunction(this._teleportationEasing);
    this.currentVRCamera.animations.push(animationCameraTeleportation);
    this._postProcessMove.animations = [];
    var midFrame = Math.round(lastFrame / 2);
    var animationPP = new Animation("animationPP", "vignetteWeight", FPS, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);
    var vignetteWeightKeys = [];
    vignetteWeightKeys.push({
      frame: 0,
      value: 0
    });
    vignetteWeightKeys.push({
      frame: midFrame,
      value: 8
    });
    vignetteWeightKeys.push({
      frame: lastFrame,
      value: 0
    });
    animationPP.setKeys(vignetteWeightKeys);
    this._postProcessMove.animations.push(animationPP);
    var animationPP2 = new Animation("animationPP2", "vignetteStretch", FPS, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);
    var vignetteStretchKeys = [];
    vignetteStretchKeys.push({
      frame: 0,
      value: 0
    });
    vignetteStretchKeys.push({
      frame: midFrame,
      value: 10
    });
    vignetteStretchKeys.push({
      frame: lastFrame,
      value: 0
    });
    animationPP2.setKeys(vignetteStretchKeys);
    this._postProcessMove.animations.push(animationPP2);
    this._postProcessMove.imageProcessingConfiguration.vignetteWeight = 0;
    this._postProcessMove.imageProcessingConfiguration.vignetteStretch = 0;
    this._webVRCamera.attachPostProcess(this._postProcessMove);
    this._scene.beginAnimation(this._postProcessMove, 0, lastFrame, false, speedRatio, function() {
      _this._webVRCamera.detachPostProcess(_this._postProcessMove);
    });
    this._scene.beginAnimation(this.currentVRCamera, 0, lastFrame, false, speedRatio, function() {
      _this.onAfterCameraTeleport.notifyObservers(_this._workingVector);
    });
    this._hideTeleportationTarget();
  };
  VRExperienceHelper2.prototype._convertNormalToDirectionOfRay = function(normal, ray) {
    if (normal) {
      var angle = Math.acos(Vector3.Dot(normal, ray.direction));
      if (angle < Math.PI / 2) {
        normal.scaleInPlace(-1);
      }
    }
    return normal;
  };
  VRExperienceHelper2.prototype._castRayAndSelectObject = function(gazer) {
    if (!(this.currentVRCamera instanceof FreeCamera)) {
      return;
    }
    var ray = gazer._getForwardRay(this._rayLength);
    var hit = this._scene.pickWithRay(ray, this._raySelectionPredicate);
    if (hit) {
      if (gazer._laserPointer) {
        hit.originMesh = gazer._laserPointer.parent;
      }
      this._scene.simulatePointerMove(hit, { pointerId: gazer._id });
    }
    gazer._currentHit = hit;
    if (hit && hit.pickedPoint) {
      if (this._displayGaze) {
        var multiplier = 1;
        gazer._gazeTracker.isVisible = true;
        if (gazer._isActionableMesh) {
          multiplier = 3;
        }
        if (this.updateGazeTrackerScale) {
          gazer._gazeTracker.scaling.x = hit.distance * multiplier;
          gazer._gazeTracker.scaling.y = hit.distance * multiplier;
          gazer._gazeTracker.scaling.z = hit.distance * multiplier;
        }
        var pickNormal = this._convertNormalToDirectionOfRay(hit.getNormal(), ray);
        var deltaFighting = 2e-3;
        if (pickNormal) {
          var axis1 = Vector3.Cross(Axis.Y, pickNormal);
          var axis2 = Vector3.Cross(pickNormal, axis1);
          Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, gazer._gazeTracker.rotation);
        }
        gazer._gazeTracker.position.copyFrom(hit.pickedPoint);
        if (gazer._gazeTracker.position.x < 0) {
          gazer._gazeTracker.position.x += deltaFighting;
        } else {
          gazer._gazeTracker.position.x -= deltaFighting;
        }
        if (gazer._gazeTracker.position.y < 0) {
          gazer._gazeTracker.position.y += deltaFighting;
        } else {
          gazer._gazeTracker.position.y -= deltaFighting;
        }
        if (gazer._gazeTracker.position.z < 0) {
          gazer._gazeTracker.position.z += deltaFighting;
        } else {
          gazer._gazeTracker.position.z -= deltaFighting;
        }
      }
      gazer._updatePointerDistance(hit.distance);
    } else {
      gazer._updatePointerDistance();
      gazer._gazeTracker.isVisible = false;
    }
    if (hit && hit.pickedMesh) {
      if (this._teleportationInitialized && this._isTeleportationFloor(hit.pickedMesh) && hit.pickedPoint) {
        if (gazer._currentMeshSelected && !this._isTeleportationFloor(gazer._currentMeshSelected)) {
          this._notifySelectedMeshUnselected(gazer._currentMeshSelected);
        }
        gazer._currentMeshSelected = null;
        if (gazer._teleportationRequestInitiated) {
          this._moveTeleportationSelectorTo(hit, gazer, ray);
        }
        return;
      }
      if (hit.pickedMesh !== gazer._currentMeshSelected) {
        if (this.meshSelectionPredicate(hit.pickedMesh)) {
          this.onNewMeshPicked.notifyObservers(hit);
          gazer._currentMeshSelected = hit.pickedMesh;
          if (hit.pickedMesh.isPickable && hit.pickedMesh.actionManager) {
            this.changeGazeColor(this._pickedGazeColor);
            this.changeLaserColor(this._pickedLaserColor);
            gazer._isActionableMesh = true;
          } else {
            this.changeGazeColor(this._gazeColor);
            this.changeLaserColor(this._laserColor);
            gazer._isActionableMesh = false;
          }
          try {
            this.onNewMeshSelected.notifyObservers(hit.pickedMesh);
            var gazerAsControllerGazer = gazer;
            if (gazerAsControllerGazer.webVRController) {
              this.onMeshSelectedWithController.notifyObservers({ mesh: hit.pickedMesh, controller: gazerAsControllerGazer.webVRController });
            }
          } catch (err) {
            Logger.Warn("Error while raising onNewMeshSelected or onMeshSelectedWithController: " + err);
          }
        } else {
          this._notifySelectedMeshUnselected(gazer._currentMeshSelected);
          gazer._currentMeshSelected = null;
          this.changeGazeColor(this._gazeColor);
          this.changeLaserColor(this._laserColor);
        }
      }
    } else {
      this._notifySelectedMeshUnselected(gazer._currentMeshSelected);
      gazer._currentMeshSelected = null;
      this.changeGazeColor(this._gazeColor);
      this.changeLaserColor(this._laserColor);
    }
  };
  VRExperienceHelper2.prototype._notifySelectedMeshUnselected = function(mesh) {
    if (mesh) {
      this.onSelectedMeshUnselected.notifyObservers(mesh);
    }
  };
  VRExperienceHelper2.prototype.setLaserColor = function(color, pickedColor) {
    if (pickedColor === void 0) {
      pickedColor = this._pickedLaserColor;
    }
    this._laserColor = color;
    this._pickedLaserColor = pickedColor;
  };
  VRExperienceHelper2.prototype.setLaserLightingState = function(enabled) {
    if (enabled === void 0) {
      enabled = true;
    }
    if (this._leftController) {
      this._leftController._setLaserPointerLightingDisabled(!enabled);
    }
    if (this._rightController) {
      this._rightController._setLaserPointerLightingDisabled(!enabled);
    }
  };
  VRExperienceHelper2.prototype.setGazeColor = function(color, pickedColor) {
    if (pickedColor === void 0) {
      pickedColor = this._pickedGazeColor;
    }
    this._gazeColor = color;
    this._pickedGazeColor = pickedColor;
  };
  VRExperienceHelper2.prototype.changeLaserColor = function(color) {
    if (!this.updateControllerLaserColor) {
      return;
    }
    if (this._leftController) {
      this._leftController._setLaserPointerColor(color);
    }
    if (this._rightController) {
      this._rightController._setLaserPointerColor(color);
    }
  };
  VRExperienceHelper2.prototype.changeGazeColor = function(color) {
    if (!this.updateGazeTrackerColor) {
      return;
    }
    if (!this._cameraGazer._gazeTracker.material) {
      return;
    }
    this._cameraGazer._gazeTracker.material.emissiveColor = color;
    if (this._leftController) {
      this._leftController._gazeTracker.material.emissiveColor = color;
    }
    if (this._rightController) {
      this._rightController._gazeTracker.material.emissiveColor = color;
    }
  };
  VRExperienceHelper2.prototype.dispose = function() {
    if (this.isInVRMode) {
      this.exitVR();
    }
    if (this._postProcessMove) {
      this._postProcessMove.dispose();
    }
    if (this._webVRCamera) {
      this._webVRCamera.dispose();
    }
    if (this._vrDeviceOrientationCamera) {
      this._vrDeviceOrientationCamera.dispose();
    }
    if (!this._useCustomVRButton && this._btnVR && this._btnVR.parentNode) {
      document.body.removeChild(this._btnVR);
    }
    if (this._deviceOrientationCamera && this._scene.activeCamera != this._deviceOrientationCamera) {
      this._deviceOrientationCamera.dispose();
    }
    if (this._cameraGazer) {
      this._cameraGazer.dispose();
    }
    if (this._leftController) {
      this._leftController.dispose();
    }
    if (this._rightController) {
      this._rightController.dispose();
    }
    if (this._teleportationTarget) {
      this._teleportationTarget.dispose();
    }
    if (this.xr) {
      this.xr.dispose();
    }
    this._floorMeshesCollection = [];
    document.removeEventListener("keydown", this._onKeyDown);
    window.removeEventListener("vrdisplaypresentchange", this._onVrDisplayPresentChange);
    window.removeEventListener("resize", this._onResize);
    document.removeEventListener("fullscreenchange", this._onFullscreenChange);
    document.removeEventListener("mozfullscreenchange", this._onFullscreenChange);
    document.removeEventListener("webkitfullscreenchange", this._onFullscreenChange);
    document.removeEventListener("msfullscreenchange", this._onFullscreenChange);
    document.onmsfullscreenchange = null;
    this._scene.getEngine().onVRDisplayChangedObservable.removeCallback(this._onVRDisplayChanged);
    this._scene.getEngine().onVRRequestPresentStart.removeCallback(this._onVRRequestPresentStart);
    this._scene.getEngine().onVRRequestPresentComplete.removeCallback(this._onVRRequestPresentComplete);
    window.removeEventListener("vrdisplaypresentchange", this._onVrDisplayPresentChange);
    this._scene.gamepadManager.onGamepadConnectedObservable.removeCallback(this._onNewGamepadConnected);
    this._scene.gamepadManager.onGamepadDisconnectedObservable.removeCallback(this._onNewGamepadDisconnected);
    this._scene.unregisterBeforeRender(this.beforeRender);
  };
  VRExperienceHelper2.prototype.getClassName = function() {
    return "VRExperienceHelper";
  };
  VRExperienceHelper2.TELEPORTATIONMODE_CONSTANTTIME = 0;
  VRExperienceHelper2.TELEPORTATIONMODE_CONSTANTSPEED = 1;
  return VRExperienceHelper2;
}();

// node_modules/@babylonjs/core/Collisions/collider.js
var intersectBoxAASphere = function(boxMin, boxMax, sphereCenter, sphereRadius) {
  if (boxMin.x > sphereCenter.x + sphereRadius) {
    return false;
  }
  if (sphereCenter.x - sphereRadius > boxMax.x) {
    return false;
  }
  if (boxMin.y > sphereCenter.y + sphereRadius) {
    return false;
  }
  if (sphereCenter.y - sphereRadius > boxMax.y) {
    return false;
  }
  if (boxMin.z > sphereCenter.z + sphereRadius) {
    return false;
  }
  if (sphereCenter.z - sphereRadius > boxMax.z) {
    return false;
  }
  return true;
};
var getLowestRoot = function() {
  var result = { root: 0, found: false };
  return function(a, b, c, maxR) {
    result.root = 0;
    result.found = false;
    var determinant = b * b - 4 * a * c;
    if (determinant < 0) {
      return result;
    }
    var sqrtD = Math.sqrt(determinant);
    var r1 = (-b - sqrtD) / (2 * a);
    var r2 = (-b + sqrtD) / (2 * a);
    if (r1 > r2) {
      var temp = r2;
      r2 = r1;
      r1 = temp;
    }
    if (r1 > 0 && r1 < maxR) {
      result.root = r1;
      result.found = true;
      return result;
    }
    if (r2 > 0 && r2 < maxR) {
      result.root = r2;
      result.found = true;
      return result;
    }
    return result;
  };
}();
var Collider = function() {
  function Collider2() {
    this._collisionPoint = Vector3.Zero();
    this._planeIntersectionPoint = Vector3.Zero();
    this._tempVector = Vector3.Zero();
    this._tempVector2 = Vector3.Zero();
    this._tempVector3 = Vector3.Zero();
    this._tempVector4 = Vector3.Zero();
    this._edge = Vector3.Zero();
    this._baseToVertex = Vector3.Zero();
    this._destinationPoint = Vector3.Zero();
    this._slidePlaneNormal = Vector3.Zero();
    this._displacementVector = Vector3.Zero();
    this._radius = Vector3.One();
    this._retry = 0;
    this._basePointWorld = Vector3.Zero();
    this._velocityWorld = Vector3.Zero();
    this._normalizedVelocity = Vector3.Zero();
    this._collisionMask = -1;
  }
  Object.defineProperty(Collider2.prototype, "collisionMask", {
    get: function() {
      return this._collisionMask;
    },
    set: function(mask) {
      this._collisionMask = !isNaN(mask) ? mask : -1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Collider2.prototype, "slidePlaneNormal", {
    get: function() {
      return this._slidePlaneNormal;
    },
    enumerable: false,
    configurable: true
  });
  Collider2.prototype._initialize = function(source, dir, e) {
    this._velocity = dir;
    Vector3.NormalizeToRef(dir, this._normalizedVelocity);
    this._basePoint = source;
    source.multiplyToRef(this._radius, this._basePointWorld);
    dir.multiplyToRef(this._radius, this._velocityWorld);
    this._velocityWorldLength = this._velocityWorld.length();
    this._epsilon = e;
    this.collisionFound = false;
  };
  Collider2.prototype._checkPointInTriangle = function(point, pa, pb, pc, n) {
    pa.subtractToRef(point, this._tempVector);
    pb.subtractToRef(point, this._tempVector2);
    Vector3.CrossToRef(this._tempVector, this._tempVector2, this._tempVector4);
    var d = Vector3.Dot(this._tempVector4, n);
    if (d < 0) {
      return false;
    }
    pc.subtractToRef(point, this._tempVector3);
    Vector3.CrossToRef(this._tempVector2, this._tempVector3, this._tempVector4);
    d = Vector3.Dot(this._tempVector4, n);
    if (d < 0) {
      return false;
    }
    Vector3.CrossToRef(this._tempVector3, this._tempVector, this._tempVector4);
    d = Vector3.Dot(this._tempVector4, n);
    return d >= 0;
  };
  Collider2.prototype._canDoCollision = function(sphereCenter, sphereRadius, vecMin, vecMax) {
    var distance = Vector3.Distance(this._basePointWorld, sphereCenter);
    var max = Math.max(this._radius.x, this._radius.y, this._radius.z);
    if (distance > this._velocityWorldLength + max + sphereRadius) {
      return false;
    }
    if (!intersectBoxAASphere(vecMin, vecMax, this._basePointWorld, this._velocityWorldLength + max)) {
      return false;
    }
    return true;
  };
  Collider2.prototype._testTriangle = function(faceIndex, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh) {
    var t0;
    var embeddedInPlane = false;
    if (!trianglePlaneArray) {
      trianglePlaneArray = [];
    }
    if (!trianglePlaneArray[faceIndex]) {
      trianglePlaneArray[faceIndex] = new Plane(0, 0, 0, 0);
      trianglePlaneArray[faceIndex].copyFromPoints(p1, p2, p3);
    }
    var trianglePlane = trianglePlaneArray[faceIndex];
    if (!hasMaterial && !trianglePlane.isFrontFacingTo(this._normalizedVelocity, 0)) {
      return;
    }
    var signedDistToTrianglePlane = trianglePlane.signedDistanceTo(this._basePoint);
    var normalDotVelocity = Vector3.Dot(trianglePlane.normal, this._velocity);
    if (normalDotVelocity == 0) {
      if (Math.abs(signedDistToTrianglePlane) >= 1) {
        return;
      }
      embeddedInPlane = true;
      t0 = 0;
    } else {
      t0 = (-1 - signedDistToTrianglePlane) / normalDotVelocity;
      var t1 = (1 - signedDistToTrianglePlane) / normalDotVelocity;
      if (t0 > t1) {
        var temp = t1;
        t1 = t0;
        t0 = temp;
      }
      if (t0 > 1 || t1 < 0) {
        return;
      }
      if (t0 < 0) {
        t0 = 0;
      }
      if (t0 > 1) {
        t0 = 1;
      }
    }
    this._collisionPoint.copyFromFloats(0, 0, 0);
    var found = false;
    var t = 1;
    if (!embeddedInPlane) {
      this._basePoint.subtractToRef(trianglePlane.normal, this._planeIntersectionPoint);
      this._velocity.scaleToRef(t0, this._tempVector);
      this._planeIntersectionPoint.addInPlace(this._tempVector);
      if (this._checkPointInTriangle(this._planeIntersectionPoint, p1, p2, p3, trianglePlane.normal)) {
        found = true;
        t = t0;
        this._collisionPoint.copyFrom(this._planeIntersectionPoint);
      }
    }
    if (!found) {
      var velocitySquaredLength = this._velocity.lengthSquared();
      var a = velocitySquaredLength;
      this._basePoint.subtractToRef(p1, this._tempVector);
      var b = 2 * Vector3.Dot(this._velocity, this._tempVector);
      var c = this._tempVector.lengthSquared() - 1;
      var lowestRoot = getLowestRoot(a, b, c, t);
      if (lowestRoot.found) {
        t = lowestRoot.root;
        found = true;
        this._collisionPoint.copyFrom(p1);
      }
      this._basePoint.subtractToRef(p2, this._tempVector);
      b = 2 * Vector3.Dot(this._velocity, this._tempVector);
      c = this._tempVector.lengthSquared() - 1;
      lowestRoot = getLowestRoot(a, b, c, t);
      if (lowestRoot.found) {
        t = lowestRoot.root;
        found = true;
        this._collisionPoint.copyFrom(p2);
      }
      this._basePoint.subtractToRef(p3, this._tempVector);
      b = 2 * Vector3.Dot(this._velocity, this._tempVector);
      c = this._tempVector.lengthSquared() - 1;
      lowestRoot = getLowestRoot(a, b, c, t);
      if (lowestRoot.found) {
        t = lowestRoot.root;
        found = true;
        this._collisionPoint.copyFrom(p3);
      }
      p2.subtractToRef(p1, this._edge);
      p1.subtractToRef(this._basePoint, this._baseToVertex);
      var edgeSquaredLength = this._edge.lengthSquared();
      var edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);
      var edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);
      a = edgeSquaredLength * -velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;
      b = edgeSquaredLength * (2 * Vector3.Dot(this._velocity, this._baseToVertex)) - 2 * edgeDotVelocity * edgeDotBaseToVertex;
      c = edgeSquaredLength * (1 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;
      lowestRoot = getLowestRoot(a, b, c, t);
      if (lowestRoot.found) {
        var f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;
        if (f >= 0 && f <= 1) {
          t = lowestRoot.root;
          found = true;
          this._edge.scaleInPlace(f);
          p1.addToRef(this._edge, this._collisionPoint);
        }
      }
      p3.subtractToRef(p2, this._edge);
      p2.subtractToRef(this._basePoint, this._baseToVertex);
      edgeSquaredLength = this._edge.lengthSquared();
      edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);
      edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);
      a = edgeSquaredLength * -velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;
      b = edgeSquaredLength * (2 * Vector3.Dot(this._velocity, this._baseToVertex)) - 2 * edgeDotVelocity * edgeDotBaseToVertex;
      c = edgeSquaredLength * (1 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;
      lowestRoot = getLowestRoot(a, b, c, t);
      if (lowestRoot.found) {
        f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;
        if (f >= 0 && f <= 1) {
          t = lowestRoot.root;
          found = true;
          this._edge.scaleInPlace(f);
          p2.addToRef(this._edge, this._collisionPoint);
        }
      }
      p1.subtractToRef(p3, this._edge);
      p3.subtractToRef(this._basePoint, this._baseToVertex);
      edgeSquaredLength = this._edge.lengthSquared();
      edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);
      edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);
      a = edgeSquaredLength * -velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;
      b = edgeSquaredLength * (2 * Vector3.Dot(this._velocity, this._baseToVertex)) - 2 * edgeDotVelocity * edgeDotBaseToVertex;
      c = edgeSquaredLength * (1 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;
      lowestRoot = getLowestRoot(a, b, c, t);
      if (lowestRoot.found) {
        f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;
        if (f >= 0 && f <= 1) {
          t = lowestRoot.root;
          found = true;
          this._edge.scaleInPlace(f);
          p3.addToRef(this._edge, this._collisionPoint);
        }
      }
    }
    if (found) {
      var distToCollision = t * this._velocity.length();
      if (!this.collisionFound || distToCollision < this._nearestDistance) {
        if (hostMesh.collisionResponse) {
          if (!this.intersectionPoint) {
            this.intersectionPoint = this._collisionPoint.clone();
          } else {
            this.intersectionPoint.copyFrom(this._collisionPoint);
          }
          this._nearestDistance = distToCollision;
          this.collisionFound = true;
        }
        this.collidedMesh = hostMesh;
      }
    }
  };
  Collider2.prototype._collide = function(trianglePlaneArray, pts, indices, indexStart, indexEnd, decal, hasMaterial, hostMesh) {
    if (!indices || indices.length === 0) {
      for (var i = 0; i < pts.length; i += 3) {
        var p1 = pts[i];
        var p2 = pts[i + 1];
        var p3 = pts[i + 2];
        this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial, hostMesh);
      }
    } else {
      for (var i = indexStart; i < indexEnd; i += 3) {
        var p1 = pts[indices[i] - decal];
        var p2 = pts[indices[i + 1] - decal];
        var p3 = pts[indices[i + 2] - decal];
        this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial, hostMesh);
      }
    }
  };
  Collider2.prototype._getResponse = function(pos, vel) {
    pos.addToRef(vel, this._destinationPoint);
    vel.scaleInPlace(this._nearestDistance / vel.length());
    this._basePoint.addToRef(vel, pos);
    pos.subtractToRef(this.intersectionPoint, this._slidePlaneNormal);
    this._slidePlaneNormal.normalize();
    this._slidePlaneNormal.scaleToRef(this._epsilon, this._displacementVector);
    pos.addInPlace(this._displacementVector);
    this.intersectionPoint.addInPlace(this._displacementVector);
    this._slidePlaneNormal.scaleInPlace(Plane.SignedDistanceToPlaneFromPositionAndNormal(this.intersectionPoint, this._slidePlaneNormal, this._destinationPoint));
    this._destinationPoint.subtractInPlace(this._slidePlaneNormal);
    this._destinationPoint.subtractToRef(this.intersectionPoint, vel);
  };
  return Collider2;
}();

// node_modules/@babylonjs/core/Collisions/collisionCoordinator.js
var DefaultCollisionCoordinator = function() {
  function DefaultCollisionCoordinator2() {
    this._scaledPosition = Vector3.Zero();
    this._scaledVelocity = Vector3.Zero();
    this._finalPosition = Vector3.Zero();
  }
  DefaultCollisionCoordinator2.prototype.getNewPosition = function(position, displacement, collider, maximumRetry, excludedMesh, onNewPosition, collisionIndex) {
    position.divideToRef(collider._radius, this._scaledPosition);
    displacement.divideToRef(collider._radius, this._scaledVelocity);
    collider.collidedMesh = null;
    collider._retry = 0;
    collider._initialVelocity = this._scaledVelocity;
    collider._initialPosition = this._scaledPosition;
    this._collideWithWorld(this._scaledPosition, this._scaledVelocity, collider, maximumRetry, this._finalPosition, excludedMesh);
    this._finalPosition.multiplyInPlace(collider._radius);
    onNewPosition(collisionIndex, this._finalPosition, collider.collidedMesh);
  };
  DefaultCollisionCoordinator2.prototype.createCollider = function() {
    return new Collider();
  };
  DefaultCollisionCoordinator2.prototype.init = function(scene) {
    this._scene = scene;
  };
  DefaultCollisionCoordinator2.prototype._collideWithWorld = function(position, velocity, collider, maximumRetry, finalPosition, excludedMesh) {
    if (excludedMesh === void 0) {
      excludedMesh = null;
    }
    var closeDistance = Engine.CollisionsEpsilon * 10;
    if (collider._retry >= maximumRetry) {
      finalPosition.copyFrom(position);
      return;
    }
    var collisionMask = excludedMesh ? excludedMesh.collisionMask : collider.collisionMask;
    collider._initialize(position, velocity, closeDistance);
    var meshes = excludedMesh && excludedMesh.surroundingMeshes || this._scene.meshes;
    for (var index = 0; index < meshes.length; index++) {
      var mesh = meshes[index];
      if (mesh.isEnabled() && mesh.checkCollisions && mesh.subMeshes && mesh !== excludedMesh && (collisionMask & mesh.collisionGroup) !== 0) {
        mesh._checkCollision(collider);
      }
    }
    if (!collider.collisionFound) {
      position.addToRef(velocity, finalPosition);
      return;
    }
    if (velocity.x !== 0 || velocity.y !== 0 || velocity.z !== 0) {
      collider._getResponse(position, velocity);
    }
    if (velocity.length() <= closeDistance) {
      finalPosition.copyFrom(position);
      return;
    }
    collider._retry++;
    this._collideWithWorld(position, velocity, collider, maximumRetry, finalPosition, excludedMesh);
  };
  return DefaultCollisionCoordinator2;
}();
Scene.CollisionCoordinatorFactory = function() {
  return new DefaultCollisionCoordinator();
};

// node_modules/@babylonjs/core/Culling/Octrees/octreeBlock.js
var OctreeBlock = function() {
  function OctreeBlock2(minPoint, maxPoint, capacity, depth, maxDepth, creationFunc) {
    this.entries = new Array();
    this._boundingVectors = new Array();
    this._capacity = capacity;
    this._depth = depth;
    this._maxDepth = maxDepth;
    this._creationFunc = creationFunc;
    this._minPoint = minPoint;
    this._maxPoint = maxPoint;
    this._boundingVectors.push(minPoint.clone());
    this._boundingVectors.push(maxPoint.clone());
    this._boundingVectors.push(minPoint.clone());
    this._boundingVectors[2].x = maxPoint.x;
    this._boundingVectors.push(minPoint.clone());
    this._boundingVectors[3].y = maxPoint.y;
    this._boundingVectors.push(minPoint.clone());
    this._boundingVectors[4].z = maxPoint.z;
    this._boundingVectors.push(maxPoint.clone());
    this._boundingVectors[5].z = minPoint.z;
    this._boundingVectors.push(maxPoint.clone());
    this._boundingVectors[6].x = minPoint.x;
    this._boundingVectors.push(maxPoint.clone());
    this._boundingVectors[7].y = minPoint.y;
  }
  Object.defineProperty(OctreeBlock2.prototype, "capacity", {
    get: function() {
      return this._capacity;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(OctreeBlock2.prototype, "minPoint", {
    get: function() {
      return this._minPoint;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(OctreeBlock2.prototype, "maxPoint", {
    get: function() {
      return this._maxPoint;
    },
    enumerable: false,
    configurable: true
  });
  OctreeBlock2.prototype.addEntry = function(entry) {
    if (this.blocks) {
      for (var index = 0; index < this.blocks.length; index++) {
        var block = this.blocks[index];
        block.addEntry(entry);
      }
      return;
    }
    this._creationFunc(entry, this);
    if (this.entries.length > this.capacity && this._depth < this._maxDepth) {
      this.createInnerBlocks();
    }
  };
  OctreeBlock2.prototype.removeEntry = function(entry) {
    if (this.blocks) {
      for (var index = 0; index < this.blocks.length; index++) {
        var block = this.blocks[index];
        block.removeEntry(entry);
      }
      return;
    }
    var entryIndex = this.entries.indexOf(entry);
    if (entryIndex > -1) {
      this.entries.splice(entryIndex, 1);
    }
  };
  OctreeBlock2.prototype.addEntries = function(entries) {
    for (var index = 0; index < entries.length; index++) {
      var mesh = entries[index];
      this.addEntry(mesh);
    }
  };
  OctreeBlock2.prototype.select = function(frustumPlanes, selection, allowDuplicate) {
    if (BoundingBox.IsInFrustum(this._boundingVectors, frustumPlanes)) {
      if (this.blocks) {
        for (var index = 0; index < this.blocks.length; index++) {
          var block = this.blocks[index];
          block.select(frustumPlanes, selection, allowDuplicate);
        }
        return;
      }
      if (allowDuplicate) {
        selection.concat(this.entries);
      } else {
        selection.concatWithNoDuplicate(this.entries);
      }
    }
  };
  OctreeBlock2.prototype.intersects = function(sphereCenter, sphereRadius, selection, allowDuplicate) {
    if (BoundingBox.IntersectsSphere(this._minPoint, this._maxPoint, sphereCenter, sphereRadius)) {
      if (this.blocks) {
        for (var index = 0; index < this.blocks.length; index++) {
          var block = this.blocks[index];
          block.intersects(sphereCenter, sphereRadius, selection, allowDuplicate);
        }
        return;
      }
      if (allowDuplicate) {
        selection.concat(this.entries);
      } else {
        selection.concatWithNoDuplicate(this.entries);
      }
    }
  };
  OctreeBlock2.prototype.intersectsRay = function(ray, selection) {
    if (ray.intersectsBoxMinMax(this._minPoint, this._maxPoint)) {
      if (this.blocks) {
        for (var index = 0; index < this.blocks.length; index++) {
          var block = this.blocks[index];
          block.intersectsRay(ray, selection);
        }
        return;
      }
      selection.concatWithNoDuplicate(this.entries);
    }
  };
  OctreeBlock2.prototype.createInnerBlocks = function() {
    OctreeBlock2._CreateBlocks(this._minPoint, this._maxPoint, this.entries, this._capacity, this._depth, this._maxDepth, this, this._creationFunc);
  };
  OctreeBlock2._CreateBlocks = function(worldMin, worldMax, entries, maxBlockCapacity, currentDepth, maxDepth, target, creationFunc) {
    target.blocks = new Array();
    var blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);
    for (var x = 0; x < 2; x++) {
      for (var y = 0; y < 2; y++) {
        for (var z = 0; z < 2; z++) {
          var localMin = worldMin.add(blockSize.multiplyByFloats(x, y, z));
          var localMax = worldMin.add(blockSize.multiplyByFloats(x + 1, y + 1, z + 1));
          var block = new OctreeBlock2(localMin, localMax, maxBlockCapacity, currentDepth + 1, maxDepth, creationFunc);
          block.addEntries(entries);
          target.blocks.push(block);
        }
      }
    }
  };
  return OctreeBlock2;
}();

// node_modules/@babylonjs/core/Culling/Octrees/octree.js
var Octree = function() {
  function Octree2(creationFunc, maxBlockCapacity, maxDepth) {
    if (maxDepth === void 0) {
      maxDepth = 2;
    }
    this.maxDepth = maxDepth;
    this.dynamicContent = new Array();
    this._maxBlockCapacity = maxBlockCapacity || 64;
    this._selectionContent = new SmartArrayNoDuplicate(1024);
    this._creationFunc = creationFunc;
  }
  Octree2.prototype.update = function(worldMin, worldMax, entries) {
    OctreeBlock._CreateBlocks(worldMin, worldMax, entries, this._maxBlockCapacity, 0, this.maxDepth, this, this._creationFunc);
  };
  Octree2.prototype.addMesh = function(entry) {
    for (var index = 0; index < this.blocks.length; index++) {
      var block = this.blocks[index];
      block.addEntry(entry);
    }
  };
  Octree2.prototype.removeMesh = function(entry) {
    for (var index = 0; index < this.blocks.length; index++) {
      var block = this.blocks[index];
      block.removeEntry(entry);
    }
  };
  Octree2.prototype.select = function(frustumPlanes, allowDuplicate) {
    this._selectionContent.reset();
    for (var index = 0; index < this.blocks.length; index++) {
      var block = this.blocks[index];
      block.select(frustumPlanes, this._selectionContent, allowDuplicate);
    }
    if (allowDuplicate) {
      this._selectionContent.concat(this.dynamicContent);
    } else {
      this._selectionContent.concatWithNoDuplicate(this.dynamicContent);
    }
    return this._selectionContent;
  };
  Octree2.prototype.intersects = function(sphereCenter, sphereRadius, allowDuplicate) {
    this._selectionContent.reset();
    for (var index = 0; index < this.blocks.length; index++) {
      var block = this.blocks[index];
      block.intersects(sphereCenter, sphereRadius, this._selectionContent, allowDuplicate);
    }
    if (allowDuplicate) {
      this._selectionContent.concat(this.dynamicContent);
    } else {
      this._selectionContent.concatWithNoDuplicate(this.dynamicContent);
    }
    return this._selectionContent;
  };
  Octree2.prototype.intersectsRay = function(ray) {
    this._selectionContent.reset();
    for (var index = 0; index < this.blocks.length; index++) {
      var block = this.blocks[index];
      block.intersectsRay(ray, this._selectionContent);
    }
    this._selectionContent.concatWithNoDuplicate(this.dynamicContent);
    return this._selectionContent;
  };
  Octree2.CreationFuncForMeshes = function(entry, block) {
    var boundingInfo = entry.getBoundingInfo();
    if (!entry.isBlocked && boundingInfo.boundingBox.intersectsMinMax(block.minPoint, block.maxPoint)) {
      block.entries.push(entry);
    }
  };
  Octree2.CreationFuncForSubMeshes = function(entry, block) {
    var boundingInfo = entry.getBoundingInfo();
    if (boundingInfo.boundingBox.intersectsMinMax(block.minPoint, block.maxPoint)) {
      block.entries.push(entry);
    }
  };
  return Octree2;
}();

// node_modules/@babylonjs/core/Culling/Octrees/octreeSceneComponent.js
Scene.prototype.createOrUpdateSelectionOctree = function(maxCapacity, maxDepth) {
  if (maxCapacity === void 0) {
    maxCapacity = 64;
  }
  if (maxDepth === void 0) {
    maxDepth = 2;
  }
  var component = this._getComponent(SceneComponentConstants.NAME_OCTREE);
  if (!component) {
    component = new OctreeSceneComponent(this);
    this._addComponent(component);
  }
  if (!this._selectionOctree) {
    this._selectionOctree = new Octree(Octree.CreationFuncForMeshes, maxCapacity, maxDepth);
  }
  var worldExtends = this.getWorldExtends();
  this._selectionOctree.update(worldExtends.min, worldExtends.max, this.meshes);
  return this._selectionOctree;
};
Object.defineProperty(Scene.prototype, "selectionOctree", {
  get: function() {
    return this._selectionOctree;
  },
  enumerable: true,
  configurable: true
});
AbstractMesh.prototype.createOrUpdateSubmeshesOctree = function(maxCapacity, maxDepth) {
  if (maxCapacity === void 0) {
    maxCapacity = 64;
  }
  if (maxDepth === void 0) {
    maxDepth = 2;
  }
  var scene = this.getScene();
  var component = scene._getComponent(SceneComponentConstants.NAME_OCTREE);
  if (!component) {
    component = new OctreeSceneComponent(scene);
    scene._addComponent(component);
  }
  if (!this._submeshesOctree) {
    this._submeshesOctree = new Octree(Octree.CreationFuncForSubMeshes, maxCapacity, maxDepth);
  }
  this.computeWorldMatrix(true);
  var boundingInfo = this.getBoundingInfo();
  var bbox = boundingInfo.boundingBox;
  this._submeshesOctree.update(bbox.minimumWorld, bbox.maximumWorld, this.subMeshes);
  return this._submeshesOctree;
};
var OctreeSceneComponent = function() {
  function OctreeSceneComponent2(scene) {
    this.name = SceneComponentConstants.NAME_OCTREE;
    this.checksIsEnabled = true;
    this._tempRay = new Ray(Vector3.Zero(), new Vector3(1, 1, 1));
    this.scene = scene;
    this.scene.getActiveMeshCandidates = this.getActiveMeshCandidates.bind(this);
    this.scene.getActiveSubMeshCandidates = this.getActiveSubMeshCandidates.bind(this);
    this.scene.getCollidingSubMeshCandidates = this.getCollidingSubMeshCandidates.bind(this);
    this.scene.getIntersectingSubMeshCandidates = this.getIntersectingSubMeshCandidates.bind(this);
  }
  OctreeSceneComponent2.prototype.register = function() {
    var _this = this;
    this.scene.onMeshRemovedObservable.add(function(mesh) {
      var sceneOctree = _this.scene.selectionOctree;
      if (sceneOctree !== void 0 && sceneOctree !== null) {
        var index = sceneOctree.dynamicContent.indexOf(mesh);
        if (index !== -1) {
          sceneOctree.dynamicContent.splice(index, 1);
        }
      }
    });
    this.scene.onMeshImportedObservable.add(function(mesh) {
      var sceneOctree = _this.scene.selectionOctree;
      if (sceneOctree !== void 0 && sceneOctree !== null) {
        sceneOctree.addMesh(mesh);
      }
    });
  };
  OctreeSceneComponent2.prototype.getActiveMeshCandidates = function() {
    if (this.scene._selectionOctree) {
      var selection = this.scene._selectionOctree.select(this.scene.frustumPlanes);
      return selection;
    }
    return this.scene._getDefaultMeshCandidates();
  };
  OctreeSceneComponent2.prototype.getActiveSubMeshCandidates = function(mesh) {
    if (mesh._submeshesOctree && mesh.useOctreeForRenderingSelection) {
      var intersections = mesh._submeshesOctree.select(this.scene.frustumPlanes);
      return intersections;
    }
    return this.scene._getDefaultSubMeshCandidates(mesh);
  };
  OctreeSceneComponent2.prototype.getIntersectingSubMeshCandidates = function(mesh, localRay) {
    if (mesh._submeshesOctree && mesh.useOctreeForPicking) {
      Ray.TransformToRef(localRay, mesh.getWorldMatrix(), this._tempRay);
      var intersections = mesh._submeshesOctree.intersectsRay(this._tempRay);
      return intersections;
    }
    return this.scene._getDefaultSubMeshCandidates(mesh);
  };
  OctreeSceneComponent2.prototype.getCollidingSubMeshCandidates = function(mesh, collider) {
    if (mesh._submeshesOctree && mesh.useOctreeForCollisions) {
      var radius = collider._velocityWorldLength + Math.max(collider._radius.x, collider._radius.y, collider._radius.z);
      var intersections = mesh._submeshesOctree.intersects(collider._basePointWorld, radius);
      return intersections;
    }
    return this.scene._getDefaultSubMeshCandidates(mesh);
  };
  OctreeSceneComponent2.prototype.rebuild = function() {
  };
  OctreeSceneComponent2.prototype.dispose = function() {
  };
  return OctreeSceneComponent2;
}();

// node_modules/@babylonjs/core/Gizmos/gizmo.js
var Gizmo = function() {
  function Gizmo2(gizmoLayer) {
    var _this = this;
    if (gizmoLayer === void 0) {
      gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer;
    }
    this.gizmoLayer = gizmoLayer;
    this._attachedMesh = null;
    this._attachedNode = null;
    this._scaleRatio = 1;
    this._isHovered = false;
    this._customMeshSet = false;
    this._updateGizmoRotationToMatchAttachedMesh = true;
    this.updateGizmoPositionToMatchAttachedMesh = true;
    this.updateScale = true;
    this._interactionsEnabled = true;
    this._tempQuaternion = new Quaternion(0, 0, 0, 1);
    this._tempVector = new Vector3();
    this._tempVector2 = new Vector3();
    this._tempMatrix1 = new Matrix();
    this._tempMatrix2 = new Matrix();
    this._rightHandtoLeftHandMatrix = Matrix.RotationY(Math.PI);
    this._rootMesh = new Mesh("gizmoRootNode", gizmoLayer.utilityLayerScene);
    this._rootMesh.rotationQuaternion = Quaternion.Identity();
    this._beforeRenderObserver = this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.add(function() {
      _this._update();
    });
  }
  Object.defineProperty(Gizmo2.prototype, "scaleRatio", {
    get: function() {
      return this._scaleRatio;
    },
    set: function(value) {
      this._scaleRatio = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Gizmo2.prototype, "isHovered", {
    get: function() {
      return this._isHovered;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Gizmo2.prototype, "attachedMesh", {
    get: function() {
      return this._attachedMesh;
    },
    set: function(value) {
      this._attachedMesh = value;
      if (value) {
        this._attachedNode = value;
      }
      this._rootMesh.setEnabled(value ? true : false);
      this._attachedNodeChanged(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Gizmo2.prototype, "attachedNode", {
    get: function() {
      return this._attachedNode;
    },
    set: function(value) {
      this._attachedNode = value;
      this._attachedMesh = null;
      this._rootMesh.setEnabled(value ? true : false);
      this._attachedNodeChanged(value);
    },
    enumerable: false,
    configurable: true
  });
  Gizmo2.prototype.setCustomMesh = function(mesh) {
    if (mesh.getScene() != this.gizmoLayer.utilityLayerScene) {
      throw "When setting a custom mesh on a gizmo, the custom meshes scene must be the same as the gizmos (eg. gizmo.gizmoLayer.utilityLayerScene)";
    }
    this._rootMesh.getChildMeshes().forEach(function(c) {
      c.dispose();
    });
    mesh.parent = this._rootMesh;
    this._customMeshSet = true;
  };
  Object.defineProperty(Gizmo2.prototype, "updateGizmoRotationToMatchAttachedMesh", {
    get: function() {
      return this._updateGizmoRotationToMatchAttachedMesh;
    },
    set: function(value) {
      this._updateGizmoRotationToMatchAttachedMesh = value;
    },
    enumerable: false,
    configurable: true
  });
  Gizmo2.prototype._attachedNodeChanged = function(value) {
  };
  Gizmo2.prototype._update = function() {
    if (this.attachedNode) {
      var effectiveNode = this.attachedNode;
      if (this.attachedMesh) {
        effectiveNode = this.attachedMesh._effectiveMesh || this.attachedNode;
      }
      if (this.updateGizmoPositionToMatchAttachedMesh) {
        var row = effectiveNode.getWorldMatrix().getRow(3);
        var position = row ? row.toVector3() : new Vector3(0, 0, 0);
        this._rootMesh.position.copyFrom(position);
      }
      if (this.updateGizmoRotationToMatchAttachedMesh) {
        effectiveNode.getWorldMatrix().decompose(void 0, this._rootMesh.rotationQuaternion);
      } else {
        this._rootMesh.rotationQuaternion.set(0, 0, 0, 1);
      }
      if (this.updateScale) {
        var activeCamera = this.gizmoLayer.utilityLayerScene.activeCamera;
        var cameraPosition = activeCamera.globalPosition;
        if (activeCamera.devicePosition) {
          cameraPosition = activeCamera.devicePosition;
        }
        this._rootMesh.position.subtractToRef(cameraPosition, this._tempVector);
        var dist = this._tempVector.length() * this.scaleRatio;
        this._rootMesh.scaling.set(dist, dist, dist);
        if (effectiveNode._getWorldMatrixDeterminant() < 0) {
          this._rootMesh.scaling.y *= -1;
        }
      } else {
        this._rootMesh.scaling.setAll(this.scaleRatio);
      }
    }
  };
  Gizmo2.prototype._matrixChanged = function() {
    if (!this._attachedNode) {
      return;
    }
    if (this._attachedNode._isCamera) {
      var camera = this._attachedNode;
      var worldMatrix;
      var worldMatrixUC;
      if (camera.parent) {
        var parentInv = this._tempMatrix2;
        camera.parent._worldMatrix.invertToRef(parentInv);
        this._attachedNode._worldMatrix.multiplyToRef(parentInv, this._tempMatrix1);
        worldMatrix = this._tempMatrix1;
      } else {
        worldMatrix = this._attachedNode._worldMatrix;
      }
      if (camera.getScene().useRightHandedSystem) {
        this._rightHandtoLeftHandMatrix.multiplyToRef(worldMatrix, this._tempMatrix2);
        worldMatrixUC = this._tempMatrix2;
      } else {
        worldMatrixUC = worldMatrix;
      }
      worldMatrixUC.decompose(this._tempVector2, this._tempQuaternion, this._tempVector);
      var inheritsTargetCamera = this._attachedNode.getClassName() === "FreeCamera" || this._attachedNode.getClassName() === "FlyCamera" || this._attachedNode.getClassName() === "ArcFollowCamera" || this._attachedNode.getClassName() === "TargetCamera" || this._attachedNode.getClassName() === "TouchCamera" || this._attachedNode.getClassName() === "UniversalCamera";
      if (inheritsTargetCamera) {
        var targetCamera = this._attachedNode;
        targetCamera.rotation = this._tempQuaternion.toEulerAngles();
        if (targetCamera.rotationQuaternion) {
          targetCamera.rotationQuaternion.copyFrom(this._tempQuaternion);
        }
      }
      camera.position.copyFrom(this._tempVector);
    } else if (this._attachedNode._isMesh || this._attachedNode.getClassName() === "AbstractMesh" || this._attachedNode.getClassName() === "TransformNode" || this._attachedNode.getClassName() === "InstancedMesh") {
      var transform = this._attachedNode;
      if (transform.parent) {
        var parentInv = this._tempMatrix1;
        var localMat = this._tempMatrix2;
        transform.parent.getWorldMatrix().invertToRef(parentInv);
        this._attachedNode.getWorldMatrix().multiplyToRef(parentInv, localMat);
        localMat.decompose(transform.scaling, this._tempQuaternion, transform.position);
      } else {
        this._attachedNode._worldMatrix.decompose(transform.scaling, this._tempQuaternion, transform.position);
      }
      if (!transform.billboardMode) {
        if (transform.rotationQuaternion) {
          transform.rotationQuaternion.copyFrom(this._tempQuaternion);
        } else {
          transform.rotation = this._tempQuaternion.toEulerAngles();
        }
      }
    } else if (this._attachedNode.getClassName() === "Bone") {
      var bone = this._attachedNode;
      var parent_1 = bone.getParent();
      if (parent_1) {
        var invParent = this._tempMatrix1;
        var boneLocalMatrix = this._tempMatrix2;
        parent_1.getWorldMatrix().invertToRef(invParent);
        bone.getWorldMatrix().multiplyToRef(invParent, boneLocalMatrix);
        var lmat = bone.getLocalMatrix();
        lmat.copyFrom(boneLocalMatrix);
      } else {
        var lmat = bone.getLocalMatrix();
        lmat.copyFrom(bone.getWorldMatrix());
      }
      bone.markAsDirty();
    }
  };
  Gizmo2.GizmoAxisPointerObserver = function(gizmoLayer, gizmoAxisCache) {
    var dragging = false;
    var pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function(pointerInfo) {
      var _a, _b;
      if (pointerInfo.pickInfo) {
        if (pointerInfo.type === PointerEventTypes.POINTERMOVE) {
          if (dragging) {
            return;
          }
          gizmoAxisCache.forEach(function(cache) {
            var _a2, _b2;
            if (cache.colliderMeshes && cache.gizmoMeshes) {
              var isHovered = ((_a2 = cache.colliderMeshes) === null || _a2 === void 0 ? void 0 : _a2.indexOf((_b2 = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _b2 === void 0 ? void 0 : _b2.pickedMesh)) != -1;
              var material_1 = isHovered || cache.active ? cache.hoverMaterial : cache.material;
              cache.gizmoMeshes.forEach(function(m) {
                m.material = material_1;
                if (m.color) {
                  m.color = material_1.diffuseColor;
                }
              });
            }
          });
        }
        if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {
          if (gizmoAxisCache.has((_a = pointerInfo.pickInfo.pickedMesh) === null || _a === void 0 ? void 0 : _a.parent)) {
            dragging = true;
            var statusMap = gizmoAxisCache.get((_b = pointerInfo.pickInfo.pickedMesh) === null || _b === void 0 ? void 0 : _b.parent);
            statusMap.active = true;
            gizmoAxisCache.forEach(function(cache) {
              var _a2, _b2;
              var isHovered = ((_a2 = cache.colliderMeshes) === null || _a2 === void 0 ? void 0 : _a2.indexOf((_b2 = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _b2 === void 0 ? void 0 : _b2.pickedMesh)) != -1;
              var material = isHovered || cache.active ? cache.hoverMaterial : cache.disableMaterial;
              cache.gizmoMeshes.forEach(function(m) {
                m.material = material;
                if (m.color) {
                  m.color = material.diffuseColor;
                }
              });
            });
          }
        }
        if (pointerInfo.type === PointerEventTypes.POINTERUP) {
          gizmoAxisCache.forEach(function(cache) {
            cache.active = false;
            dragging = false;
            cache.gizmoMeshes.forEach(function(m) {
              m.material = cache.material;
              if (m.color) {
                m.color = cache.material.diffuseColor;
              }
            });
          });
        }
      }
    });
    return pointerObserver;
  };
  Gizmo2.prototype.dispose = function() {
    this._rootMesh.dispose();
    if (this._beforeRenderObserver) {
      this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.remove(this._beforeRenderObserver);
    }
  };
  return Gizmo2;
}();

// node_modules/@babylonjs/core/Gizmos/axisDragGizmo.js
var AxisDragGizmo = function(_super) {
  __extends(AxisDragGizmo2, _super);
  function AxisDragGizmo2(dragAxis, color, gizmoLayer, parent, thickness) {
    if (color === void 0) {
      color = Color3.Gray();
    }
    if (gizmoLayer === void 0) {
      gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer;
    }
    if (parent === void 0) {
      parent = null;
    }
    if (thickness === void 0) {
      thickness = 1;
    }
    var _a;
    var _this = _super.call(this, gizmoLayer) || this;
    _this._pointerObserver = null;
    _this.snapDistance = 0;
    _this.onSnapObservable = new Observable();
    _this._isEnabled = true;
    _this._parent = null;
    _this._dragging = false;
    _this._parent = parent;
    _this._coloredMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
    _this._coloredMaterial.diffuseColor = color;
    _this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));
    _this._hoverMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
    _this._hoverMaterial.diffuseColor = Color3.Yellow();
    _this._disableMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
    _this._disableMaterial.diffuseColor = Color3.Gray();
    _this._disableMaterial.alpha = 0.4;
    var arrow = AxisDragGizmo2._CreateArrow(gizmoLayer.utilityLayerScene, _this._coloredMaterial, thickness);
    var collider = AxisDragGizmo2._CreateArrow(gizmoLayer.utilityLayerScene, _this._coloredMaterial, thickness + 4, true);
    _this._gizmoMesh = new Mesh("", gizmoLayer.utilityLayerScene);
    _this._gizmoMesh.addChild(arrow);
    _this._gizmoMesh.addChild(collider);
    _this._gizmoMesh.lookAt(_this._rootMesh.position.add(dragAxis));
    _this._gizmoMesh.scaling.scaleInPlace(1 / 3);
    _this._gizmoMesh.parent = _this._rootMesh;
    var currentSnapDragDistance = 0;
    var tmpVector = new Vector3();
    var tmpSnapEvent = { snapDistance: 0 };
    _this.dragBehavior = new PointerDragBehavior({ dragAxis });
    _this.dragBehavior.moveAttached = false;
    _this._rootMesh.addBehavior(_this.dragBehavior);
    _this.dragBehavior.onDragObservable.add(function(event) {
      if (_this.attachedNode) {
        if (_this.snapDistance == 0) {
          if (_this.attachedNode.position) {
            _this.attachedNode.position.addInPlaceFromFloats(event.delta.x, event.delta.y, event.delta.z);
          }
          _this.attachedNode.getWorldMatrix().addTranslationFromFloats(event.delta.x, event.delta.y, event.delta.z);
          _this.attachedNode.updateCache();
        } else {
          currentSnapDragDistance += event.dragDistance;
          if (Math.abs(currentSnapDragDistance) > _this.snapDistance) {
            var dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / _this.snapDistance);
            currentSnapDragDistance = currentSnapDragDistance % _this.snapDistance;
            event.delta.normalizeToRef(tmpVector);
            tmpVector.scaleInPlace(_this.snapDistance * dragSteps);
            _this.attachedNode.getWorldMatrix().addTranslationFromFloats(tmpVector.x, tmpVector.y, tmpVector.z);
            _this.attachedNode.updateCache();
            tmpSnapEvent.snapDistance = _this.snapDistance * dragSteps;
            _this.onSnapObservable.notifyObservers(tmpSnapEvent);
          }
        }
        _this._matrixChanged();
      }
    });
    _this.dragBehavior.onDragStartObservable.add(function() {
      _this._dragging = true;
    });
    _this.dragBehavior.onDragEndObservable.add(function() {
      _this._dragging = false;
    });
    var light = gizmoLayer._getSharedGizmoLight();
    light.includedOnlyMeshes = light.includedOnlyMeshes.concat(_this._rootMesh.getChildMeshes(false));
    var cache = {
      gizmoMeshes: arrow.getChildMeshes(),
      colliderMeshes: collider.getChildMeshes(),
      material: _this._coloredMaterial,
      hoverMaterial: _this._hoverMaterial,
      disableMaterial: _this._disableMaterial,
      active: false
    };
    (_a = _this._parent) === null || _a === void 0 ? void 0 : _a.addToAxisCache(collider, cache);
    _this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function(pointerInfo) {
      var _a2;
      if (_this._customMeshSet) {
        return;
      }
      _this._isHovered = !!(cache.colliderMeshes.indexOf((_a2 = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _a2 === void 0 ? void 0 : _a2.pickedMesh) != -1);
      if (!_this._parent) {
        var material = _this._isHovered || _this._dragging ? _this._hoverMaterial : _this._coloredMaterial;
        cache.gizmoMeshes.forEach(function(m) {
          m.material = material;
          if (m.color) {
            m.color = material.diffuseColor;
          }
        });
      }
    });
    return _this;
  }
  AxisDragGizmo2._CreateArrow = function(scene, material, thickness, isCollider) {
    if (thickness === void 0) {
      thickness = 1;
    }
    if (isCollider === void 0) {
      isCollider = false;
    }
    var arrow = new TransformNode("arrow", scene);
    var cylinder = CylinderBuilder.CreateCylinder("cylinder", { diameterTop: 0, height: 0.075, diameterBottom: 0.0375 * (1 + (thickness - 1) / 4), tessellation: 96 }, scene);
    var line = CylinderBuilder.CreateCylinder("cylinder", { diameterTop: 5e-3 * thickness, height: 0.275, diameterBottom: 5e-3 * thickness, tessellation: 96 }, scene);
    cylinder.parent = arrow;
    cylinder.material = material;
    cylinder.rotation.x = Math.PI / 2;
    cylinder.position.z += 0.3;
    line.parent = arrow;
    line.material = material;
    line.position.z += 0.275 / 2;
    line.rotation.x = Math.PI / 2;
    if (isCollider) {
      line.visibility = 0;
      cylinder.visibility = 0;
    }
    return arrow;
  };
  AxisDragGizmo2._CreateArrowInstance = function(scene, arrow) {
    var instance = new TransformNode("arrow", scene);
    for (var _i = 0, _a = arrow.getChildMeshes(); _i < _a.length; _i++) {
      var mesh = _a[_i];
      var childInstance = mesh.createInstance(mesh.name);
      childInstance.parent = instance;
    }
    return instance;
  };
  AxisDragGizmo2.prototype._attachedNodeChanged = function(value) {
    if (this.dragBehavior) {
      this.dragBehavior.enabled = value ? true : false;
    }
  };
  Object.defineProperty(AxisDragGizmo2.prototype, "isEnabled", {
    get: function() {
      return this._isEnabled;
    },
    set: function(value) {
      this._isEnabled = value;
      if (!value) {
        this.attachedMesh = null;
        this.attachedNode = null;
      } else {
        if (this._parent) {
          this.attachedMesh = this._parent.attachedMesh;
          this.attachedNode = this._parent.attachedNode;
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  AxisDragGizmo2.prototype.dispose = function() {
    this.onSnapObservable.clear();
    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
    this.dragBehavior.detach();
    if (this._gizmoMesh) {
      this._gizmoMesh.dispose();
    }
    [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach(function(matl) {
      if (matl) {
        matl.dispose();
      }
    });
    _super.prototype.dispose.call(this);
  };
  return AxisDragGizmo2;
}(Gizmo);

// node_modules/@babylonjs/core/Debug/axesViewer.js
var AxesViewer = function() {
  function AxesViewer2(scene, scaleLines, renderingGroupId, xAxis, yAxis, zAxis) {
    if (scaleLines === void 0) {
      scaleLines = 1;
    }
    if (renderingGroupId === void 0) {
      renderingGroupId = 2;
    }
    this._scaleLinesFactor = 4;
    this._instanced = false;
    this.scene = null;
    this.scaleLines = 1;
    this.scaleLines = scaleLines;
    if (!xAxis) {
      var redColoredMaterial = new StandardMaterial("", scene);
      redColoredMaterial.disableLighting = true;
      redColoredMaterial.emissiveColor = Color3.Red().scale(0.5);
      xAxis = AxisDragGizmo._CreateArrow(scene, redColoredMaterial);
    }
    if (!yAxis) {
      var greenColoredMaterial = new StandardMaterial("", scene);
      greenColoredMaterial.disableLighting = true;
      greenColoredMaterial.emissiveColor = Color3.Green().scale(0.5);
      yAxis = AxisDragGizmo._CreateArrow(scene, greenColoredMaterial);
    }
    if (!zAxis) {
      var blueColoredMaterial = new StandardMaterial("", scene);
      blueColoredMaterial.disableLighting = true;
      blueColoredMaterial.emissiveColor = Color3.Blue().scale(0.5);
      zAxis = AxisDragGizmo._CreateArrow(scene, blueColoredMaterial);
    }
    this._xAxis = xAxis;
    this._xAxis.scaling.setAll(this.scaleLines * this._scaleLinesFactor);
    this._yAxis = yAxis;
    this._yAxis.scaling.setAll(this.scaleLines * this._scaleLinesFactor);
    this._zAxis = zAxis;
    this._zAxis.scaling.setAll(this.scaleLines * this._scaleLinesFactor);
    if (renderingGroupId != null) {
      AxesViewer2._SetRenderingGroupId(this._xAxis, renderingGroupId);
      AxesViewer2._SetRenderingGroupId(this._yAxis, renderingGroupId);
      AxesViewer2._SetRenderingGroupId(this._zAxis, renderingGroupId);
    }
    this.scene = scene;
    this.update(new Vector3(), Vector3.Right(), Vector3.Up(), Vector3.Forward());
  }
  Object.defineProperty(AxesViewer2.prototype, "xAxis", {
    get: function() {
      return this._xAxis;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AxesViewer2.prototype, "yAxis", {
    get: function() {
      return this._yAxis;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AxesViewer2.prototype, "zAxis", {
    get: function() {
      return this._zAxis;
    },
    enumerable: false,
    configurable: true
  });
  AxesViewer2.prototype.update = function(position, xaxis, yaxis, zaxis) {
    this._xAxis.position.copyFrom(position);
    this._xAxis.setDirection(xaxis);
    this._xAxis.scaling.setAll(this.scaleLines * this._scaleLinesFactor);
    this._yAxis.position.copyFrom(position);
    this._yAxis.setDirection(yaxis);
    this._yAxis.scaling.setAll(this.scaleLines * this._scaleLinesFactor);
    this._zAxis.position.copyFrom(position);
    this._zAxis.setDirection(zaxis);
    this._zAxis.scaling.setAll(this.scaleLines * this._scaleLinesFactor);
  };
  AxesViewer2.prototype.createInstance = function() {
    var xAxis = AxisDragGizmo._CreateArrowInstance(this.scene, this._xAxis);
    var yAxis = AxisDragGizmo._CreateArrowInstance(this.scene, this._yAxis);
    var zAxis = AxisDragGizmo._CreateArrowInstance(this.scene, this._zAxis);
    var axesViewer = new AxesViewer2(this.scene, this.scaleLines, null, xAxis, yAxis, zAxis);
    axesViewer._instanced = true;
    return axesViewer;
  };
  AxesViewer2.prototype.dispose = function() {
    if (this._xAxis) {
      this._xAxis.dispose(false, !this._instanced);
    }
    if (this._yAxis) {
      this._yAxis.dispose(false, !this._instanced);
    }
    if (this._zAxis) {
      this._zAxis.dispose(false, !this._instanced);
    }
    this.scene = null;
  };
  AxesViewer2._SetRenderingGroupId = function(node, id) {
    node.getChildMeshes().forEach(function(mesh) {
      mesh.renderingGroupId = id;
    });
  };
  return AxesViewer2;
}();

// node_modules/@babylonjs/core/Debug/boneAxesViewer.js
var BoneAxesViewer = function(_super) {
  __extends(BoneAxesViewer2, _super);
  function BoneAxesViewer2(scene, bone, mesh, scaleLines) {
    if (scaleLines === void 0) {
      scaleLines = 1;
    }
    var _this = _super.call(this, scene, scaleLines) || this;
    _this.pos = Vector3.Zero();
    _this.xaxis = Vector3.Zero();
    _this.yaxis = Vector3.Zero();
    _this.zaxis = Vector3.Zero();
    _this.mesh = mesh;
    _this.bone = bone;
    return _this;
  }
  BoneAxesViewer2.prototype.update = function() {
    if (!this.mesh || !this.bone) {
      return;
    }
    var bone = this.bone;
    bone._markAsDirtyAndCompose();
    bone.getAbsolutePositionToRef(this.mesh, this.pos);
    bone.getDirectionToRef(Axis.X, this.mesh, this.xaxis);
    bone.getDirectionToRef(Axis.Y, this.mesh, this.yaxis);
    bone.getDirectionToRef(Axis.Z, this.mesh, this.zaxis);
    _super.prototype.update.call(this, this.pos, this.xaxis, this.yaxis, this.zaxis);
  };
  BoneAxesViewer2.prototype.dispose = function() {
    if (this.mesh) {
      this.mesh = null;
      this.bone = null;
      _super.prototype.dispose.call(this);
    }
  };
  return BoneAxesViewer2;
}(AxesViewer);

// node_modules/@babylonjs/core/Debug/debugLayer.js
Object.defineProperty(Scene.prototype, "debugLayer", {
  get: function() {
    if (!this._debugLayer) {
      this._debugLayer = new DebugLayer(this);
    }
    return this._debugLayer;
  },
  enumerable: true,
  configurable: true
});
var DebugLayerTab;
(function(DebugLayerTab2) {
  DebugLayerTab2[DebugLayerTab2["Properties"] = 0] = "Properties";
  DebugLayerTab2[DebugLayerTab2["Debug"] = 1] = "Debug";
  DebugLayerTab2[DebugLayerTab2["Statistics"] = 2] = "Statistics";
  DebugLayerTab2[DebugLayerTab2["Tools"] = 3] = "Tools";
  DebugLayerTab2[DebugLayerTab2["Settings"] = 4] = "Settings";
})(DebugLayerTab || (DebugLayerTab = {}));
var DebugLayer = function() {
  function DebugLayer2(scene) {
    var _this = this;
    this.BJSINSPECTOR = this._getGlobalInspector();
    this._scene = scene;
    this._scene.onDisposeObservable.add(function() {
      if (_this._scene._debugLayer) {
        _this._scene._debugLayer.hide();
      }
    });
  }
  Object.defineProperty(DebugLayer2.prototype, "onPropertyChangedObservable", {
    get: function() {
      if (this.BJSINSPECTOR && this.BJSINSPECTOR.Inspector) {
        return this.BJSINSPECTOR.Inspector.OnPropertyChangedObservable;
      }
      if (!this._onPropertyChangedObservable) {
        this._onPropertyChangedObservable = new Observable();
      }
      return this._onPropertyChangedObservable;
    },
    enumerable: false,
    configurable: true
  });
  DebugLayer2.prototype._createInspector = function(config) {
    if (this.isVisible()) {
      return;
    }
    if (this._onPropertyChangedObservable) {
      for (var _i = 0, _a = this._onPropertyChangedObservable.observers; _i < _a.length; _i++) {
        var observer = _a[_i];
        this.BJSINSPECTOR.Inspector.OnPropertyChangedObservable.add(observer);
      }
      this._onPropertyChangedObservable.clear();
      this._onPropertyChangedObservable = void 0;
    }
    var userOptions = __assign({ overlay: false, showExplorer: true, showInspector: true, embedMode: false, handleResize: true, enablePopup: true }, config);
    this.BJSINSPECTOR = this.BJSINSPECTOR || this._getGlobalInspector();
    this.BJSINSPECTOR.Inspector.Show(this._scene, userOptions);
  };
  DebugLayer2.prototype.select = function(entity, lineContainerTitles) {
    if (this.BJSINSPECTOR) {
      if (lineContainerTitles) {
        if (Object.prototype.toString.call(lineContainerTitles) == "[object String]") {
          this.BJSINSPECTOR.Inspector.MarkLineContainerTitleForHighlighting(lineContainerTitles);
        } else {
          this.BJSINSPECTOR.Inspector.MarkMultipleLineContainerTitlesForHighlighting(lineContainerTitles);
        }
      }
      this.BJSINSPECTOR.Inspector.OnSelectionChangeObservable.notifyObservers(entity);
    }
  };
  DebugLayer2.prototype._getGlobalInspector = function() {
    if (typeof INSPECTOR !== "undefined") {
      return INSPECTOR;
    }
    if (typeof BABYLON !== "undefined" && typeof BABYLON.Inspector !== "undefined") {
      return BABYLON;
    }
    return void 0;
  };
  DebugLayer2.prototype.isVisible = function() {
    return this.BJSINSPECTOR && this.BJSINSPECTOR.Inspector.IsVisible;
  };
  DebugLayer2.prototype.hide = function() {
    if (this.BJSINSPECTOR) {
      this.BJSINSPECTOR.Inspector.Hide();
    }
  };
  DebugLayer2.prototype.setAsActiveScene = function() {
    if (this.BJSINSPECTOR) {
      this.BJSINSPECTOR.Inspector._SetNewScene(this._scene);
    }
  };
  DebugLayer2.prototype.show = function(config) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      if (typeof _this.BJSINSPECTOR == "undefined") {
        var inspectorUrl = config && config.inspectorURL ? config.inspectorURL : DebugLayer2.InspectorURL;
        Tools.LoadScript(inspectorUrl, function() {
          _this._createInspector(config);
          resolve(_this);
        });
      } else {
        _this._createInspector(config);
        resolve(_this);
      }
    });
  };
  DebugLayer2.InspectorURL = "https://unpkg.com/babylonjs-inspector@" + Engine.Version + "/babylon.inspector.bundle.js";
  return DebugLayer2;
}();

// node_modules/@babylonjs/core/Meshes/Builders/sphereBuilder.js
VertexData.CreateSphere = function(options) {
  var segments = options.segments || 32;
  var diameterX = options.diameterX || options.diameter || 1;
  var diameterY = options.diameterY || options.diameter || 1;
  var diameterZ = options.diameterZ || options.diameter || 1;
  var arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1 : options.arc || 1;
  var slice = options.slice && options.slice <= 0 ? 1 : options.slice || 1;
  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  var dedupTopBottomIndices = !!options.dedupTopBottomIndices;
  var radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);
  var totalZRotationSteps = 2 + segments;
  var totalYRotationSteps = 2 * totalZRotationSteps;
  var indices = [];
  var positions = [];
  var normals = [];
  var uvs = [];
  for (var zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {
    var normalizedZ = zRotationStep / totalZRotationSteps;
    var angleZ = normalizedZ * Math.PI * slice;
    for (var yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {
      var normalizedY = yRotationStep / totalYRotationSteps;
      var angleY = normalizedY * Math.PI * 2 * arc;
      var rotationZ = Matrix.RotationZ(-angleZ);
      var rotationY = Matrix.RotationY(angleY);
      var afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);
      var complete = Vector3.TransformCoordinates(afterRotZ, rotationY);
      var vertex = complete.multiply(radius);
      var normal = complete.divide(radius).normalize();
      positions.push(vertex.x, vertex.y, vertex.z);
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(normalizedY, normalizedZ);
    }
    if (zRotationStep > 0) {
      var verticesCount = positions.length / 3;
      for (var firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {
        if (dedupTopBottomIndices) {
          if (zRotationStep > 1) {
            indices.push(firstIndex);
            indices.push(firstIndex + 1);
            indices.push(firstIndex + totalYRotationSteps + 1);
          }
          if (zRotationStep < totalZRotationSteps || slice < 1) {
            indices.push(firstIndex + totalYRotationSteps + 1);
            indices.push(firstIndex + 1);
            indices.push(firstIndex + totalYRotationSteps + 2);
          }
        } else {
          indices.push(firstIndex);
          indices.push(firstIndex + 1);
          indices.push(firstIndex + totalYRotationSteps + 1);
          indices.push(firstIndex + totalYRotationSteps + 1);
          indices.push(firstIndex + 1);
          indices.push(firstIndex + totalYRotationSteps + 2);
        }
      }
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  var vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
};
Mesh.CreateSphere = function(name98, segments, diameter, scene, updatable, sideOrientation) {
  var options = {
    segments,
    diameterX: diameter,
    diameterY: diameter,
    diameterZ: diameter,
    sideOrientation,
    updatable
  };
  return SphereBuilder.CreateSphere(name98, options, scene);
};
var SphereBuilder = function() {
  function SphereBuilder2() {
  }
  SphereBuilder2.CreateSphere = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    var sphere = new Mesh(name98, scene);
    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
    sphere._originalBuilderSideOrientation = options.sideOrientation;
    var vertexData = VertexData.CreateSphere(options);
    vertexData.applyToMesh(sphere, options.updatable);
    return sphere;
  };
  return SphereBuilder2;
}();

// node_modules/@babylonjs/core/Physics/physicsJoint.js
var PhysicsJoint = function() {
  function PhysicsJoint2(type, jointData) {
    this.type = type;
    this.jointData = jointData;
    jointData.nativeParams = jointData.nativeParams || {};
  }
  Object.defineProperty(PhysicsJoint2.prototype, "physicsJoint", {
    get: function() {
      return this._physicsJoint;
    },
    set: function(newJoint) {
      if (this._physicsJoint) {
      }
      this._physicsJoint = newJoint;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PhysicsJoint2.prototype, "physicsPlugin", {
    set: function(physicsPlugin) {
      this._physicsPlugin = physicsPlugin;
    },
    enumerable: false,
    configurable: true
  });
  PhysicsJoint2.prototype.executeNativeFunction = function(func) {
    func(this._physicsPlugin.world, this._physicsJoint);
  };
  PhysicsJoint2.DistanceJoint = 0;
  PhysicsJoint2.HingeJoint = 1;
  PhysicsJoint2.BallAndSocketJoint = 2;
  PhysicsJoint2.WheelJoint = 3;
  PhysicsJoint2.SliderJoint = 4;
  PhysicsJoint2.PrismaticJoint = 5;
  PhysicsJoint2.UniversalJoint = 6;
  PhysicsJoint2.Hinge2Joint = PhysicsJoint2.WheelJoint;
  PhysicsJoint2.PointToPointJoint = 8;
  PhysicsJoint2.SpringJoint = 9;
  PhysicsJoint2.LockJoint = 10;
  return PhysicsJoint2;
}();
var DistanceJoint = function(_super) {
  __extends(DistanceJoint2, _super);
  function DistanceJoint2(jointData) {
    return _super.call(this, PhysicsJoint.DistanceJoint, jointData) || this;
  }
  DistanceJoint2.prototype.updateDistance = function(maxDistance, minDistance) {
    this._physicsPlugin.updateDistanceJoint(this, maxDistance, minDistance);
  };
  return DistanceJoint2;
}(PhysicsJoint);
var MotorEnabledJoint = function(_super) {
  __extends(MotorEnabledJoint2, _super);
  function MotorEnabledJoint2(type, jointData) {
    return _super.call(this, type, jointData) || this;
  }
  MotorEnabledJoint2.prototype.setMotor = function(force, maxForce) {
    this._physicsPlugin.setMotor(this, force || 0, maxForce);
  };
  MotorEnabledJoint2.prototype.setLimit = function(upperLimit, lowerLimit) {
    this._physicsPlugin.setLimit(this, upperLimit, lowerLimit);
  };
  return MotorEnabledJoint2;
}(PhysicsJoint);
var HingeJoint = function(_super) {
  __extends(HingeJoint2, _super);
  function HingeJoint2(jointData) {
    return _super.call(this, PhysicsJoint.HingeJoint, jointData) || this;
  }
  HingeJoint2.prototype.setMotor = function(force, maxForce) {
    this._physicsPlugin.setMotor(this, force || 0, maxForce);
  };
  HingeJoint2.prototype.setLimit = function(upperLimit, lowerLimit) {
    this._physicsPlugin.setLimit(this, upperLimit, lowerLimit);
  };
  return HingeJoint2;
}(MotorEnabledJoint);
var Hinge2Joint = function(_super) {
  __extends(Hinge2Joint2, _super);
  function Hinge2Joint2(jointData) {
    return _super.call(this, PhysicsJoint.Hinge2Joint, jointData) || this;
  }
  Hinge2Joint2.prototype.setMotor = function(targetSpeed, maxForce, motorIndex) {
    if (motorIndex === void 0) {
      motorIndex = 0;
    }
    this._physicsPlugin.setMotor(this, targetSpeed || 0, maxForce, motorIndex);
  };
  Hinge2Joint2.prototype.setLimit = function(upperLimit, lowerLimit, motorIndex) {
    if (motorIndex === void 0) {
      motorIndex = 0;
    }
    this._physicsPlugin.setLimit(this, upperLimit, lowerLimit, motorIndex);
  };
  return Hinge2Joint2;
}(MotorEnabledJoint);

// node_modules/@babylonjs/core/Physics/physicsImpostor.js
Mesh._PhysicsImpostorParser = function(scene, physicObject, jsonObject) {
  return new PhysicsImpostor(physicObject, jsonObject.physicsImpostor, {
    mass: jsonObject.physicsMass,
    friction: jsonObject.physicsFriction,
    restitution: jsonObject.physicsRestitution
  }, scene);
};
var PhysicsImpostor = function() {
  function PhysicsImpostor2(object, type, _options, _scene) {
    var _this = this;
    if (_options === void 0) {
      _options = { mass: 0 };
    }
    this.object = object;
    this.type = type;
    this._options = _options;
    this._scene = _scene;
    this._pluginData = {};
    this._bodyUpdateRequired = false;
    this._onBeforePhysicsStepCallbacks = new Array();
    this._onAfterPhysicsStepCallbacks = new Array();
    this._onPhysicsCollideCallbacks = [];
    this._deltaPosition = Vector3.Zero();
    this._isDisposed = false;
    this.soft = false;
    this.segments = 0;
    this._tmpQuat = new Quaternion();
    this._tmpQuat2 = new Quaternion();
    this.beforeStep = function() {
      if (!_this._physicsEngine) {
        return;
      }
      _this.object.translate(_this._deltaPosition, -1);
      _this._deltaRotationConjugated && _this.object.rotationQuaternion && _this.object.rotationQuaternion.multiplyToRef(_this._deltaRotationConjugated, _this.object.rotationQuaternion);
      _this.object.computeWorldMatrix(false);
      if (_this.object.parent && _this.object.rotationQuaternion) {
        _this.getParentsRotation();
        _this._tmpQuat.multiplyToRef(_this.object.rotationQuaternion, _this._tmpQuat);
      } else {
        _this._tmpQuat.copyFrom(_this.object.rotationQuaternion || new Quaternion());
      }
      if (!_this._options.disableBidirectionalTransformation) {
        _this.object.rotationQuaternion && _this._physicsEngine.getPhysicsPlugin().setPhysicsBodyTransformation(_this, _this.object.getAbsolutePosition(), _this._tmpQuat);
      }
      _this._onBeforePhysicsStepCallbacks.forEach(function(func) {
        func(_this);
      });
    };
    this.afterStep = function() {
      if (!_this._physicsEngine) {
        return;
      }
      _this._onAfterPhysicsStepCallbacks.forEach(function(func) {
        func(_this);
      });
      _this._physicsEngine.getPhysicsPlugin().setTransformationFromPhysicsBody(_this);
      if (_this.object.parent && _this.object.rotationQuaternion) {
        _this.getParentsRotation();
        _this._tmpQuat.conjugateInPlace();
        _this._tmpQuat.multiplyToRef(_this.object.rotationQuaternion, _this.object.rotationQuaternion);
      }
      _this.object.setAbsolutePosition(_this.object.position);
      _this._deltaRotation && _this.object.rotationQuaternion && _this.object.rotationQuaternion.multiplyToRef(_this._deltaRotation, _this.object.rotationQuaternion);
      _this.object.translate(_this._deltaPosition, 1);
    };
    this.onCollideEvent = null;
    this.onCollide = function(e) {
      if (!_this._onPhysicsCollideCallbacks.length && !_this.onCollideEvent) {
        return;
      }
      if (!_this._physicsEngine) {
        return;
      }
      var otherImpostor = _this._physicsEngine.getImpostorWithPhysicsBody(e.body);
      if (otherImpostor) {
        if (_this.onCollideEvent) {
          _this.onCollideEvent(_this, otherImpostor);
        }
        _this._onPhysicsCollideCallbacks.filter(function(obj) {
          return obj.otherImpostors.indexOf(otherImpostor) !== -1;
        }).forEach(function(obj) {
          obj.callback(_this, otherImpostor, e.point);
        });
      }
    };
    if (!this.object) {
      Logger.Error("No object was provided. A physics object is obligatory");
      return;
    }
    if (this.object.parent && _options.mass !== 0) {
      Logger.Warn("A physics impostor has been created for an object which has a parent. Babylon physics currently works in local space so unexpected issues may occur.");
    }
    if (!this._scene && object.getScene) {
      this._scene = object.getScene();
    }
    if (!this._scene) {
      return;
    }
    if (this.type > 100) {
      this.soft = true;
    }
    this._physicsEngine = this._scene.getPhysicsEngine();
    if (!this._physicsEngine) {
      Logger.Error("Physics not enabled. Please use scene.enablePhysics(...) before creating impostors.");
    } else {
      if (!this.object.rotationQuaternion) {
        if (this.object.rotation) {
          this.object.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.object.rotation.y, this.object.rotation.x, this.object.rotation.z);
        } else {
          this.object.rotationQuaternion = new Quaternion();
        }
      }
      this._options.mass = _options.mass === void 0 ? 0 : _options.mass;
      this._options.friction = _options.friction === void 0 ? 0.2 : _options.friction;
      this._options.restitution = _options.restitution === void 0 ? 0.2 : _options.restitution;
      if (this.soft) {
        this._options.mass = this._options.mass > 0 ? this._options.mass : 1;
        this._options.pressure = _options.pressure === void 0 ? 200 : _options.pressure;
        this._options.stiffness = _options.stiffness === void 0 ? 1 : _options.stiffness;
        this._options.velocityIterations = _options.velocityIterations === void 0 ? 20 : _options.velocityIterations;
        this._options.positionIterations = _options.positionIterations === void 0 ? 20 : _options.positionIterations;
        this._options.fixedPoints = _options.fixedPoints === void 0 ? 0 : _options.fixedPoints;
        this._options.margin = _options.margin === void 0 ? 0 : _options.margin;
        this._options.damping = _options.damping === void 0 ? 0 : _options.damping;
        this._options.path = _options.path === void 0 ? null : _options.path;
        this._options.shape = _options.shape === void 0 ? null : _options.shape;
      }
      this._joints = [];
      if (!this.object.parent || this._options.ignoreParent) {
        this._init();
      } else if (this.object.parent.physicsImpostor) {
        Logger.Warn("You must affect impostors to children before affecting impostor to parent.");
      }
    }
  }
  Object.defineProperty(PhysicsImpostor2.prototype, "isDisposed", {
    get: function() {
      return this._isDisposed;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PhysicsImpostor2.prototype, "mass", {
    get: function() {
      return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyMass(this) : 0;
    },
    set: function(value) {
      this.setMass(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PhysicsImpostor2.prototype, "friction", {
    get: function() {
      return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyFriction(this) : 0;
    },
    set: function(value) {
      if (!this._physicsEngine) {
        return;
      }
      this._physicsEngine.getPhysicsPlugin().setBodyFriction(this, value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PhysicsImpostor2.prototype, "restitution", {
    get: function() {
      return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyRestitution(this) : 0;
    },
    set: function(value) {
      if (!this._physicsEngine) {
        return;
      }
      this._physicsEngine.getPhysicsPlugin().setBodyRestitution(this, value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PhysicsImpostor2.prototype, "pressure", {
    get: function() {
      if (!this._physicsEngine) {
        return 0;
      }
      var plugin = this._physicsEngine.getPhysicsPlugin();
      if (!plugin.setBodyPressure) {
        return 0;
      }
      return plugin.getBodyPressure(this);
    },
    set: function(value) {
      if (!this._physicsEngine) {
        return;
      }
      var plugin = this._physicsEngine.getPhysicsPlugin();
      if (!plugin.setBodyPressure) {
        return;
      }
      plugin.setBodyPressure(this, value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PhysicsImpostor2.prototype, "stiffness", {
    get: function() {
      if (!this._physicsEngine) {
        return 0;
      }
      var plugin = this._physicsEngine.getPhysicsPlugin();
      if (!plugin.getBodyStiffness) {
        return 0;
      }
      return plugin.getBodyStiffness(this);
    },
    set: function(value) {
      if (!this._physicsEngine) {
        return;
      }
      var plugin = this._physicsEngine.getPhysicsPlugin();
      if (!plugin.setBodyStiffness) {
        return;
      }
      plugin.setBodyStiffness(this, value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PhysicsImpostor2.prototype, "velocityIterations", {
    get: function() {
      if (!this._physicsEngine) {
        return 0;
      }
      var plugin = this._physicsEngine.getPhysicsPlugin();
      if (!plugin.getBodyVelocityIterations) {
        return 0;
      }
      return plugin.getBodyVelocityIterations(this);
    },
    set: function(value) {
      if (!this._physicsEngine) {
        return;
      }
      var plugin = this._physicsEngine.getPhysicsPlugin();
      if (!plugin.setBodyVelocityIterations) {
        return;
      }
      plugin.setBodyVelocityIterations(this, value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PhysicsImpostor2.prototype, "positionIterations", {
    get: function() {
      if (!this._physicsEngine) {
        return 0;
      }
      var plugin = this._physicsEngine.getPhysicsPlugin();
      if (!plugin.getBodyPositionIterations) {
        return 0;
      }
      return plugin.getBodyPositionIterations(this);
    },
    set: function(value) {
      if (!this._physicsEngine) {
        return;
      }
      var plugin = this._physicsEngine.getPhysicsPlugin();
      if (!plugin.setBodyPositionIterations) {
        return;
      }
      plugin.setBodyPositionIterations(this, value);
    },
    enumerable: false,
    configurable: true
  });
  PhysicsImpostor2.prototype._init = function() {
    if (!this._physicsEngine) {
      return;
    }
    this._physicsEngine.removeImpostor(this);
    this.physicsBody = null;
    this._parent = this._parent || this._getPhysicsParent();
    if (!this._isDisposed && (!this.parent || this._options.ignoreParent)) {
      this._physicsEngine.addImpostor(this);
    }
  };
  PhysicsImpostor2.prototype._getPhysicsParent = function() {
    if (this.object.parent instanceof AbstractMesh) {
      var parentMesh = this.object.parent;
      return parentMesh.physicsImpostor;
    }
    return null;
  };
  PhysicsImpostor2.prototype.isBodyInitRequired = function() {
    return this._bodyUpdateRequired || !this._physicsBody && !this._parent;
  };
  PhysicsImpostor2.prototype.setScalingUpdated = function() {
    this.forceUpdate();
  };
  PhysicsImpostor2.prototype.forceUpdate = function() {
    this._init();
    if (this.parent && !this._options.ignoreParent) {
      this.parent.forceUpdate();
    }
  };
  Object.defineProperty(PhysicsImpostor2.prototype, "physicsBody", {
    get: function() {
      return this._parent && !this._options.ignoreParent ? this._parent.physicsBody : this._physicsBody;
    },
    set: function(physicsBody) {
      if (this._physicsBody && this._physicsEngine) {
        this._physicsEngine.getPhysicsPlugin().removePhysicsBody(this);
      }
      this._physicsBody = physicsBody;
      this.resetUpdateFlags();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PhysicsImpostor2.prototype, "parent", {
    get: function() {
      return !this._options.ignoreParent && this._parent ? this._parent : null;
    },
    set: function(value) {
      this._parent = value;
    },
    enumerable: false,
    configurable: true
  });
  PhysicsImpostor2.prototype.resetUpdateFlags = function() {
    this._bodyUpdateRequired = false;
  };
  PhysicsImpostor2.prototype.getObjectExtendSize = function() {
    if (this.object.getBoundingInfo) {
      var q = this.object.rotationQuaternion;
      var scaling = this.object.scaling.clone();
      this.object.rotationQuaternion = PhysicsImpostor2.IDENTITY_QUATERNION;
      var worldMatrix = this.object.computeWorldMatrix && this.object.computeWorldMatrix(true);
      if (worldMatrix) {
        worldMatrix.decompose(scaling, void 0, void 0);
      }
      var boundingInfo = this.object.getBoundingInfo();
      var size = boundingInfo.boundingBox.extendSize.scale(2).multiplyInPlace(scaling);
      this.object.rotationQuaternion = q;
      this.object.computeWorldMatrix && this.object.computeWorldMatrix(true);
      return size;
    } else {
      return PhysicsImpostor2.DEFAULT_OBJECT_SIZE;
    }
  };
  PhysicsImpostor2.prototype.getObjectCenter = function() {
    if (this.object.getBoundingInfo) {
      var boundingInfo = this.object.getBoundingInfo();
      return boundingInfo.boundingBox.centerWorld;
    } else {
      return this.object.position;
    }
  };
  PhysicsImpostor2.prototype.getParam = function(paramName) {
    return this._options[paramName];
  };
  PhysicsImpostor2.prototype.setParam = function(paramName, value) {
    this._options[paramName] = value;
    this._bodyUpdateRequired = true;
  };
  PhysicsImpostor2.prototype.setMass = function(mass) {
    if (this.getParam("mass") !== mass) {
      this.setParam("mass", mass);
    }
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().setBodyMass(this, mass);
    }
  };
  PhysicsImpostor2.prototype.getLinearVelocity = function() {
    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getLinearVelocity(this) : Vector3.Zero();
  };
  PhysicsImpostor2.prototype.setLinearVelocity = function(velocity) {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().setLinearVelocity(this, velocity);
    }
  };
  PhysicsImpostor2.prototype.getAngularVelocity = function() {
    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getAngularVelocity(this) : Vector3.Zero();
  };
  PhysicsImpostor2.prototype.setAngularVelocity = function(velocity) {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().setAngularVelocity(this, velocity);
    }
  };
  PhysicsImpostor2.prototype.executeNativeFunction = function(func) {
    if (this._physicsEngine) {
      func(this._physicsEngine.getPhysicsPlugin().world, this.physicsBody);
    }
  };
  PhysicsImpostor2.prototype.registerBeforePhysicsStep = function(func) {
    this._onBeforePhysicsStepCallbacks.push(func);
  };
  PhysicsImpostor2.prototype.unregisterBeforePhysicsStep = function(func) {
    var index = this._onBeforePhysicsStepCallbacks.indexOf(func);
    if (index > -1) {
      this._onBeforePhysicsStepCallbacks.splice(index, 1);
    } else {
      Logger.Warn("Function to remove was not found");
    }
  };
  PhysicsImpostor2.prototype.registerAfterPhysicsStep = function(func) {
    this._onAfterPhysicsStepCallbacks.push(func);
  };
  PhysicsImpostor2.prototype.unregisterAfterPhysicsStep = function(func) {
    var index = this._onAfterPhysicsStepCallbacks.indexOf(func);
    if (index > -1) {
      this._onAfterPhysicsStepCallbacks.splice(index, 1);
    } else {
      Logger.Warn("Function to remove was not found");
    }
  };
  PhysicsImpostor2.prototype.registerOnPhysicsCollide = function(collideAgainst, func) {
    var collidedAgainstList = collideAgainst instanceof Array ? collideAgainst : [collideAgainst];
    this._onPhysicsCollideCallbacks.push({ callback: func, otherImpostors: collidedAgainstList });
  };
  PhysicsImpostor2.prototype.unregisterOnPhysicsCollide = function(collideAgainst, func) {
    var collidedAgainstList = collideAgainst instanceof Array ? collideAgainst : [collideAgainst];
    var index = -1;
    var found = this._onPhysicsCollideCallbacks.some(function(cbDef, idx) {
      if (cbDef.callback === func && cbDef.otherImpostors.length === collidedAgainstList.length) {
        var sameList = cbDef.otherImpostors.every(function(impostor) {
          return collidedAgainstList.indexOf(impostor) > -1;
        });
        if (sameList) {
          index = idx;
        }
        return sameList;
      }
      return false;
    });
    if (found) {
      this._onPhysicsCollideCallbacks.splice(index, 1);
    } else {
      Logger.Warn("Function to remove was not found");
    }
  };
  PhysicsImpostor2.prototype.getParentsRotation = function() {
    var parent = this.object.parent;
    this._tmpQuat.copyFromFloats(0, 0, 0, 1);
    while (parent) {
      if (parent.rotationQuaternion) {
        this._tmpQuat2.copyFrom(parent.rotationQuaternion);
      } else {
        Quaternion.RotationYawPitchRollToRef(parent.rotation.y, parent.rotation.x, parent.rotation.z, this._tmpQuat2);
      }
      this._tmpQuat.multiplyToRef(this._tmpQuat2, this._tmpQuat);
      parent = parent.parent;
    }
    return this._tmpQuat;
  };
  PhysicsImpostor2.prototype.applyForce = function(force, contactPoint) {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().applyForce(this, force, contactPoint);
    }
    return this;
  };
  PhysicsImpostor2.prototype.applyImpulse = function(force, contactPoint) {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().applyImpulse(this, force, contactPoint);
    }
    return this;
  };
  PhysicsImpostor2.prototype.createJoint = function(otherImpostor, jointType, jointData) {
    var joint = new PhysicsJoint(jointType, jointData);
    this.addJoint(otherImpostor, joint);
    return this;
  };
  PhysicsImpostor2.prototype.addJoint = function(otherImpostor, joint) {
    this._joints.push({
      otherImpostor,
      joint
    });
    if (this._physicsEngine) {
      this._physicsEngine.addJoint(this, otherImpostor, joint);
    }
    return this;
  };
  PhysicsImpostor2.prototype.addAnchor = function(otherImpostor, width, height, influence, noCollisionBetweenLinkedBodies) {
    if (!this._physicsEngine) {
      return this;
    }
    var plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.appendAnchor) {
      return this;
    }
    if (this._physicsEngine) {
      plugin.appendAnchor(this, otherImpostor, width, height, influence, noCollisionBetweenLinkedBodies);
    }
    return this;
  };
  PhysicsImpostor2.prototype.addHook = function(otherImpostor, length, influence, noCollisionBetweenLinkedBodies) {
    if (!this._physicsEngine) {
      return this;
    }
    var plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.appendAnchor) {
      return this;
    }
    if (this._physicsEngine) {
      plugin.appendHook(this, otherImpostor, length, influence, noCollisionBetweenLinkedBodies);
    }
    return this;
  };
  PhysicsImpostor2.prototype.sleep = function() {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().sleepBody(this);
    }
    return this;
  };
  PhysicsImpostor2.prototype.wakeUp = function() {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().wakeUpBody(this);
    }
    return this;
  };
  PhysicsImpostor2.prototype.clone = function(newObject) {
    if (!newObject) {
      return null;
    }
    return new PhysicsImpostor2(newObject, this.type, this._options, this._scene);
  };
  PhysicsImpostor2.prototype.dispose = function() {
    var _this = this;
    if (!this._physicsEngine) {
      return;
    }
    this._joints.forEach(function(j) {
      if (_this._physicsEngine) {
        _this._physicsEngine.removeJoint(_this, j.otherImpostor, j.joint);
      }
    });
    this._physicsEngine.removeImpostor(this);
    if (this.parent) {
      this.parent.forceUpdate();
    } else {
    }
    this._isDisposed = true;
  };
  PhysicsImpostor2.prototype.setDeltaPosition = function(position) {
    this._deltaPosition.copyFrom(position);
  };
  PhysicsImpostor2.prototype.setDeltaRotation = function(rotation) {
    if (!this._deltaRotation) {
      this._deltaRotation = new Quaternion();
    }
    this._deltaRotation.copyFrom(rotation);
    this._deltaRotationConjugated = this._deltaRotation.conjugate();
  };
  PhysicsImpostor2.prototype.getBoxSizeToRef = function(result) {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().getBoxSizeToRef(this, result);
    }
    return this;
  };
  PhysicsImpostor2.prototype.getRadius = function() {
    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getRadius(this) : 0;
  };
  PhysicsImpostor2.prototype.syncBoneWithImpostor = function(bone, boneMesh, jointPivot, distToJoint, adjustRotation) {
    var tempVec = PhysicsImpostor2._tmpVecs[0];
    var mesh = this.object;
    if (mesh.rotationQuaternion) {
      if (adjustRotation) {
        var tempQuat = PhysicsImpostor2._tmpQuat;
        mesh.rotationQuaternion.multiplyToRef(adjustRotation, tempQuat);
        bone.setRotationQuaternion(tempQuat, Space.WORLD, boneMesh);
      } else {
        bone.setRotationQuaternion(mesh.rotationQuaternion, Space.WORLD, boneMesh);
      }
    }
    tempVec.x = 0;
    tempVec.y = 0;
    tempVec.z = 0;
    if (jointPivot) {
      tempVec.x = jointPivot.x;
      tempVec.y = jointPivot.y;
      tempVec.z = jointPivot.z;
      bone.getDirectionToRef(tempVec, boneMesh, tempVec);
      if (distToJoint === void 0 || distToJoint === null) {
        distToJoint = jointPivot.length();
      }
      tempVec.x *= distToJoint;
      tempVec.y *= distToJoint;
      tempVec.z *= distToJoint;
    }
    if (bone.getParent()) {
      tempVec.addInPlace(mesh.getAbsolutePosition());
      bone.setAbsolutePosition(tempVec, boneMesh);
    } else {
      boneMesh.setAbsolutePosition(mesh.getAbsolutePosition());
      boneMesh.position.x -= tempVec.x;
      boneMesh.position.y -= tempVec.y;
      boneMesh.position.z -= tempVec.z;
    }
  };
  PhysicsImpostor2.prototype.syncImpostorWithBone = function(bone, boneMesh, jointPivot, distToJoint, adjustRotation, boneAxis) {
    var mesh = this.object;
    if (mesh.rotationQuaternion) {
      if (adjustRotation) {
        var tempQuat = PhysicsImpostor2._tmpQuat;
        bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, tempQuat);
        tempQuat.multiplyToRef(adjustRotation, mesh.rotationQuaternion);
      } else {
        bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, mesh.rotationQuaternion);
      }
    }
    var pos = PhysicsImpostor2._tmpVecs[0];
    var boneDir = PhysicsImpostor2._tmpVecs[1];
    if (!boneAxis) {
      boneAxis = PhysicsImpostor2._tmpVecs[2];
      boneAxis.x = 0;
      boneAxis.y = 1;
      boneAxis.z = 0;
    }
    bone.getDirectionToRef(boneAxis, boneMesh, boneDir);
    bone.getAbsolutePositionToRef(boneMesh, pos);
    if ((distToJoint === void 0 || distToJoint === null) && jointPivot) {
      distToJoint = jointPivot.length();
    }
    if (distToJoint !== void 0 && distToJoint !== null) {
      pos.x += boneDir.x * distToJoint;
      pos.y += boneDir.y * distToJoint;
      pos.z += boneDir.z * distToJoint;
    }
    mesh.setAbsolutePosition(pos);
  };
  PhysicsImpostor2.DEFAULT_OBJECT_SIZE = new Vector3(1, 1, 1);
  PhysicsImpostor2.IDENTITY_QUATERNION = Quaternion.Identity();
  PhysicsImpostor2._tmpVecs = ArrayTools.BuildArray(3, Vector3.Zero);
  PhysicsImpostor2._tmpQuat = Quaternion.Identity();
  PhysicsImpostor2.NoImpostor = 0;
  PhysicsImpostor2.SphereImpostor = 1;
  PhysicsImpostor2.BoxImpostor = 2;
  PhysicsImpostor2.PlaneImpostor = 3;
  PhysicsImpostor2.MeshImpostor = 4;
  PhysicsImpostor2.CapsuleImpostor = 6;
  PhysicsImpostor2.CylinderImpostor = 7;
  PhysicsImpostor2.ParticleImpostor = 8;
  PhysicsImpostor2.HeightmapImpostor = 9;
  PhysicsImpostor2.ConvexHullImpostor = 10;
  PhysicsImpostor2.CustomImpostor = 100;
  PhysicsImpostor2.RopeImpostor = 101;
  PhysicsImpostor2.ClothImpostor = 102;
  PhysicsImpostor2.SoftbodyImpostor = 103;
  return PhysicsImpostor2;
}();

// node_modules/@babylonjs/core/Debug/physicsViewer.js
var PhysicsViewer = function() {
  function PhysicsViewer2(scene) {
    this._impostors = [];
    this._meshes = [];
    this._numMeshes = 0;
    this._debugMeshMeshes = new Array();
    this._scene = scene || EngineStore.LastCreatedScene;
    var physicEngine = this._scene.getPhysicsEngine();
    if (physicEngine) {
      this._physicsEnginePlugin = physicEngine.getPhysicsPlugin();
    }
    this._utilityLayer = new UtilityLayerRenderer(this._scene, false);
    this._utilityLayer.pickUtilitySceneFirst = false;
    this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = true;
  }
  PhysicsViewer2.prototype._updateDebugMeshes = function() {
    var plugin = this._physicsEnginePlugin;
    for (var i = 0; i < this._numMeshes; i++) {
      var impostor = this._impostors[i];
      if (!impostor) {
        continue;
      }
      if (impostor.isDisposed) {
        this.hideImpostor(this._impostors[i--]);
      } else {
        if (impostor.type === PhysicsImpostor.MeshImpostor) {
          continue;
        }
        var mesh = this._meshes[i];
        if (mesh && plugin) {
          plugin.syncMeshWithImpostor(mesh, impostor);
        }
      }
    }
  };
  PhysicsViewer2.prototype.showImpostor = function(impostor, targetMesh) {
    if (!this._scene) {
      return null;
    }
    for (var i = 0; i < this._numMeshes; i++) {
      if (this._impostors[i] == impostor) {
        return null;
      }
    }
    var debugMesh = this._getDebugMesh(impostor, targetMesh);
    if (debugMesh) {
      this._impostors[this._numMeshes] = impostor;
      this._meshes[this._numMeshes] = debugMesh;
      if (this._numMeshes === 0) {
        this._renderFunction = this._updateDebugMeshes.bind(this);
        this._scene.registerBeforeRender(this._renderFunction);
      }
      this._numMeshes++;
    }
    return debugMesh;
  };
  PhysicsViewer2.prototype.hideImpostor = function(impostor) {
    if (!impostor || !this._scene || !this._utilityLayer) {
      return;
    }
    var removed = false;
    var utilityLayerScene = this._utilityLayer.utilityLayerScene;
    for (var i = 0; i < this._numMeshes; i++) {
      if (this._impostors[i] == impostor) {
        var mesh = this._meshes[i];
        if (!mesh) {
          continue;
        }
        utilityLayerScene.removeMesh(mesh);
        mesh.dispose();
        var index = this._debugMeshMeshes.indexOf(mesh);
        if (index > -1) {
          this._debugMeshMeshes.splice(index, 1);
        }
        this._numMeshes--;
        if (this._numMeshes > 0) {
          this._meshes[i] = this._meshes[this._numMeshes];
          this._impostors[i] = this._impostors[this._numMeshes];
          this._meshes[this._numMeshes] = null;
          this._impostors[this._numMeshes] = null;
        } else {
          this._meshes[0] = null;
          this._impostors[0] = null;
        }
        removed = true;
        break;
      }
    }
    if (removed && this._numMeshes === 0) {
      this._scene.unregisterBeforeRender(this._renderFunction);
    }
  };
  PhysicsViewer2.prototype._getDebugMaterial = function(scene) {
    if (!this._debugMaterial) {
      this._debugMaterial = new StandardMaterial("", scene);
      this._debugMaterial.wireframe = true;
      this._debugMaterial.emissiveColor = Color3.White();
      this._debugMaterial.disableLighting = true;
    }
    return this._debugMaterial;
  };
  PhysicsViewer2.prototype._getDebugBoxMesh = function(scene) {
    if (!this._debugBoxMesh) {
      this._debugBoxMesh = BoxBuilder.CreateBox("physicsBodyBoxViewMesh", { size: 1 }, scene);
      this._debugBoxMesh.rotationQuaternion = Quaternion.Identity();
      this._debugBoxMesh.material = this._getDebugMaterial(scene);
      this._debugBoxMesh.setEnabled(false);
    }
    return this._debugBoxMesh.createInstance("physicsBodyBoxViewInstance");
  };
  PhysicsViewer2.prototype._getDebugSphereMesh = function(scene) {
    if (!this._debugSphereMesh) {
      this._debugSphereMesh = SphereBuilder.CreateSphere("physicsBodySphereViewMesh", { diameter: 1 }, scene);
      this._debugSphereMesh.rotationQuaternion = Quaternion.Identity();
      this._debugSphereMesh.material = this._getDebugMaterial(scene);
      this._debugSphereMesh.setEnabled(false);
    }
    return this._debugSphereMesh.createInstance("physicsBodyBoxViewInstance");
  };
  PhysicsViewer2.prototype._getDebugCylinderMesh = function(scene) {
    if (!this._debugCylinderMesh) {
      this._debugCylinderMesh = CylinderBuilder.CreateCylinder("physicsBodyCylinderViewMesh", { diameterTop: 1, diameterBottom: 1, height: 1 }, scene);
      this._debugCylinderMesh.rotationQuaternion = Quaternion.Identity();
      this._debugCylinderMesh.material = this._getDebugMaterial(scene);
      this._debugCylinderMesh.setEnabled(false);
    }
    return this._debugCylinderMesh.createInstance("physicsBodyBoxViewInstance");
  };
  PhysicsViewer2.prototype._getDebugMeshMesh = function(mesh, scene) {
    var wireframeOver = new Mesh(mesh.name, scene, null, mesh);
    wireframeOver.position = Vector3.Zero();
    wireframeOver.setParent(mesh);
    wireframeOver.material = this._getDebugMaterial(scene);
    this._debugMeshMeshes.push(wireframeOver);
    return wireframeOver;
  };
  PhysicsViewer2.prototype._getDebugMesh = function(impostor, targetMesh) {
    var _this = this;
    if (!this._utilityLayer) {
      return null;
    }
    if (targetMesh && targetMesh.parent && targetMesh.parent.physicsImpostor) {
      return null;
    }
    var mesh = null;
    var utilityLayerScene = this._utilityLayer.utilityLayerScene;
    switch (impostor.type) {
      case PhysicsImpostor.BoxImpostor:
        mesh = this._getDebugBoxMesh(utilityLayerScene);
        impostor.getBoxSizeToRef(mesh.scaling);
        break;
      case PhysicsImpostor.SphereImpostor:
        mesh = this._getDebugSphereMesh(utilityLayerScene);
        var radius = impostor.getRadius();
        mesh.scaling.x = radius * 2;
        mesh.scaling.y = radius * 2;
        mesh.scaling.z = radius * 2;
        break;
      case PhysicsImpostor.MeshImpostor:
        if (targetMesh) {
          mesh = this._getDebugMeshMesh(targetMesh, utilityLayerScene);
        }
        break;
      case PhysicsImpostor.NoImpostor:
        if (targetMesh) {
          var childMeshes = targetMesh.getChildMeshes().filter(function(c) {
            return c.physicsImpostor ? 1 : 0;
          });
          childMeshes.forEach(function(m) {
            var a = _this._getDebugBoxMesh(utilityLayerScene);
            a.parent = m;
          });
        }
        break;
      case PhysicsImpostor.CylinderImpostor:
        mesh = this._getDebugCylinderMesh(utilityLayerScene);
        var bi = impostor.object.getBoundingInfo();
        mesh.scaling.x = bi.boundingBox.maximum.x - bi.boundingBox.minimum.x;
        mesh.scaling.y = bi.boundingBox.maximum.y - bi.boundingBox.minimum.y;
        mesh.scaling.z = bi.boundingBox.maximum.z - bi.boundingBox.minimum.z;
        break;
    }
    return mesh;
  };
  PhysicsViewer2.prototype.dispose = function() {
    var count = this._numMeshes;
    for (var index = 0; index < count; index++) {
      this.hideImpostor(this._impostors[0]);
    }
    if (this._debugBoxMesh) {
      this._debugBoxMesh.dispose();
    }
    if (this._debugSphereMesh) {
      this._debugSphereMesh.dispose();
    }
    if (this._debugCylinderMesh) {
      this._debugCylinderMesh.dispose();
    }
    if (this._debugMaterial) {
      this._debugMaterial.dispose();
    }
    this._impostors.length = 0;
    this._scene = null;
    this._physicsEnginePlugin = null;
    if (this._utilityLayer) {
      this._utilityLayer.dispose();
      this._utilityLayer = null;
    }
  };
  return PhysicsViewer2;
}();

// node_modules/@babylonjs/core/Meshes/instancedMesh.js
Mesh._instancedMeshFactory = function(name98, mesh) {
  var instance = new InstancedMesh(name98, mesh);
  if (mesh.instancedBuffers) {
    instance.instancedBuffers = {};
    for (var key in mesh.instancedBuffers) {
      instance.instancedBuffers[key] = mesh.instancedBuffers[key];
    }
  }
  return instance;
};
var InstancedMesh = function(_super) {
  __extends(InstancedMesh2, _super);
  function InstancedMesh2(name98, source) {
    var _this = _super.call(this, name98, source.getScene()) || this;
    _this._indexInSourceMeshInstanceArray = -1;
    source.addInstance(_this);
    _this._sourceMesh = source;
    _this._unIndexed = source._unIndexed;
    _this.position.copyFrom(source.position);
    _this.rotation.copyFrom(source.rotation);
    _this.scaling.copyFrom(source.scaling);
    if (source.rotationQuaternion) {
      _this.rotationQuaternion = source.rotationQuaternion.clone();
    }
    _this.animations = Tools.Slice(source.animations);
    for (var _i = 0, _a = source.getAnimationRanges(); _i < _a.length; _i++) {
      var range = _a[_i];
      if (range != null) {
        _this.createAnimationRange(range.name, range.from, range.to);
      }
    }
    _this.infiniteDistance = source.infiniteDistance;
    _this.setPivotMatrix(source.getPivotMatrix());
    _this.refreshBoundingInfo();
    _this._syncSubMeshes();
    return _this;
  }
  InstancedMesh2.prototype.getClassName = function() {
    return "InstancedMesh";
  };
  Object.defineProperty(InstancedMesh2.prototype, "lightSources", {
    get: function() {
      return this._sourceMesh._lightSources;
    },
    enumerable: false,
    configurable: true
  });
  InstancedMesh2.prototype._resyncLightSources = function() {
  };
  InstancedMesh2.prototype._resyncLightSource = function(light) {
  };
  InstancedMesh2.prototype._removeLightSource = function(light, dispose) {
  };
  Object.defineProperty(InstancedMesh2.prototype, "receiveShadows", {
    get: function() {
      return this._sourceMesh.receiveShadows;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InstancedMesh2.prototype, "material", {
    get: function() {
      return this._sourceMesh.material;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InstancedMesh2.prototype, "visibility", {
    get: function() {
      return this._sourceMesh.visibility;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InstancedMesh2.prototype, "skeleton", {
    get: function() {
      return this._sourceMesh.skeleton;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InstancedMesh2.prototype, "renderingGroupId", {
    get: function() {
      return this._sourceMesh.renderingGroupId;
    },
    set: function(value) {
      if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {
        return;
      }
      Logger.Warn("Note - setting renderingGroupId of an instanced mesh has no effect on the scene");
    },
    enumerable: false,
    configurable: true
  });
  InstancedMesh2.prototype.getTotalVertices = function() {
    return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;
  };
  InstancedMesh2.prototype.getTotalIndices = function() {
    return this._sourceMesh.getTotalIndices();
  };
  Object.defineProperty(InstancedMesh2.prototype, "sourceMesh", {
    get: function() {
      return this._sourceMesh;
    },
    enumerable: false,
    configurable: true
  });
  InstancedMesh2.prototype.createInstance = function(name98) {
    return this._sourceMesh.createInstance(name98);
  };
  InstancedMesh2.prototype.isReady = function(completeCheck) {
    if (completeCheck === void 0) {
      completeCheck = false;
    }
    return this._sourceMesh.isReady(completeCheck, true);
  };
  InstancedMesh2.prototype.getVerticesData = function(kind, copyWhenShared) {
    return this._sourceMesh.getVerticesData(kind, copyWhenShared);
  };
  InstancedMesh2.prototype.setVerticesData = function(kind, data, updatable, stride) {
    if (this.sourceMesh) {
      this.sourceMesh.setVerticesData(kind, data, updatable, stride);
    }
    return this.sourceMesh;
  };
  InstancedMesh2.prototype.updateVerticesData = function(kind, data, updateExtends, makeItUnique) {
    if (this.sourceMesh) {
      this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);
    }
    return this.sourceMesh;
  };
  InstancedMesh2.prototype.setIndices = function(indices, totalVertices) {
    if (totalVertices === void 0) {
      totalVertices = null;
    }
    if (this.sourceMesh) {
      this.sourceMesh.setIndices(indices, totalVertices);
    }
    return this.sourceMesh;
  };
  InstancedMesh2.prototype.isVerticesDataPresent = function(kind) {
    return this._sourceMesh.isVerticesDataPresent(kind);
  };
  InstancedMesh2.prototype.getIndices = function() {
    return this._sourceMesh.getIndices();
  };
  Object.defineProperty(InstancedMesh2.prototype, "_positions", {
    get: function() {
      return this._sourceMesh._positions;
    },
    enumerable: false,
    configurable: true
  });
  InstancedMesh2.prototype.refreshBoundingInfo = function(applySkeleton) {
    if (applySkeleton === void 0) {
      applySkeleton = false;
    }
    if (this._boundingInfo && this._boundingInfo.isLocked) {
      return this;
    }
    var bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;
    this._refreshBoundingInfo(this._sourceMesh._getPositionData(applySkeleton), bias);
    return this;
  };
  InstancedMesh2.prototype._preActivate = function() {
    if (this._currentLOD) {
      this._currentLOD._preActivate();
    }
    return this;
  };
  InstancedMesh2.prototype._activate = function(renderId, intermediateRendering) {
    if (!this._sourceMesh.subMeshes) {
      Logger.Warn("Instances should only be created for meshes with geometry.");
    }
    if (this._currentLOD) {
      var differentSign = this._currentLOD._getWorldMatrixDeterminant() > 0 !== this._getWorldMatrixDeterminant() > 0;
      if (differentSign) {
        this._internalAbstractMeshDataInfo._actAsRegularMesh = true;
        return true;
      }
      this._internalAbstractMeshDataInfo._actAsRegularMesh = false;
      this._currentLOD._registerInstanceForRenderId(this, renderId);
      if (intermediateRendering) {
        if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {
          this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;
          return true;
        }
      } else {
        if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {
          this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;
          return true;
        }
      }
    }
    return false;
  };
  InstancedMesh2.prototype._postActivate = function() {
    if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {
      this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);
      this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());
    } else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {
      this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);
    }
  };
  InstancedMesh2.prototype.getWorldMatrix = function() {
    if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {
      var tempMaster = this._currentLOD._masterMesh;
      this._currentLOD._masterMesh = this;
      TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);
      this._currentLOD.position.set(0, 0, 0);
      TmpVectors.Matrix[0].copyFrom(this._currentLOD.computeWorldMatrix(true));
      this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);
      this._currentLOD._masterMesh = tempMaster;
      return TmpVectors.Matrix[0];
    }
    return _super.prototype.getWorldMatrix.call(this);
  };
  Object.defineProperty(InstancedMesh2.prototype, "isAnInstance", {
    get: function() {
      return true;
    },
    enumerable: false,
    configurable: true
  });
  InstancedMesh2.prototype.getLOD = function(camera) {
    if (!camera) {
      return this;
    }
    var boundingInfo = this.getBoundingInfo();
    this._currentLOD = this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);
    if (this._currentLOD === this.sourceMesh) {
      return this.sourceMesh;
    }
    return this._currentLOD;
  };
  InstancedMesh2.prototype._preActivateForIntermediateRendering = function(renderId) {
    return this.sourceMesh._preActivateForIntermediateRendering(renderId);
  };
  InstancedMesh2.prototype._syncSubMeshes = function() {
    this.releaseSubMeshes();
    if (this._sourceMesh.subMeshes) {
      for (var index = 0; index < this._sourceMesh.subMeshes.length; index++) {
        this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);
      }
    }
    return this;
  };
  InstancedMesh2.prototype._generatePointsArray = function() {
    return this._sourceMesh._generatePointsArray();
  };
  InstancedMesh2.prototype._updateBoundingInfo = function() {
    var effectiveMesh = this;
    if (this._boundingInfo) {
      this._boundingInfo.update(effectiveMesh.worldMatrixFromCache);
    } else {
      this._boundingInfo = new BoundingInfo(this.absolutePosition, this.absolutePosition, effectiveMesh.worldMatrixFromCache);
    }
    this._updateSubMeshesBoundingInfo(effectiveMesh.worldMatrixFromCache);
    return this;
  };
  InstancedMesh2.prototype.clone = function(name98, newParent, doNotCloneChildren) {
    if (newParent === void 0) {
      newParent = null;
    }
    var result = this._sourceMesh.createInstance(name98);
    DeepCopier.DeepCopy(this, result, [
      "name",
      "subMeshes",
      "uniqueId",
      "parent",
      "lightSources",
      "receiveShadows",
      "material",
      "visibility",
      "skeleton",
      "sourceMesh",
      "isAnInstance",
      "facetNb",
      "isFacetDataEnabled",
      "isBlocked",
      "useBones",
      "hasInstances",
      "collider",
      "edgesRenderer",
      "forward",
      "up",
      "right",
      "absolutePosition",
      "absoluteScaling",
      "absoluteRotationQuaternion",
      "isWorldMatrixFrozen",
      "nonUniformScaling",
      "behaviors",
      "worldMatrixFromCache",
      "hasThinInstances"
    ], []);
    this.refreshBoundingInfo();
    if (newParent) {
      result.parent = newParent;
    }
    if (!doNotCloneChildren) {
      for (var index = 0; index < this.getScene().meshes.length; index++) {
        var mesh = this.getScene().meshes[index];
        if (mesh.parent === this) {
          mesh.clone(mesh.name, result);
        }
      }
    }
    result.computeWorldMatrix(true);
    return result;
  };
  InstancedMesh2.prototype.dispose = function(doNotRecurse, disposeMaterialAndTextures) {
    if (disposeMaterialAndTextures === void 0) {
      disposeMaterialAndTextures = false;
    }
    this._sourceMesh.removeInstance(this);
    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);
  };
  return InstancedMesh2;
}(AbstractMesh);
Mesh.prototype.edgesShareWithInstances = false;
Mesh.prototype.registerInstancedBuffer = function(kind, stride) {
  this.removeVerticesData(kind);
  if (!this.instancedBuffers) {
    this.instancedBuffers = {};
    for (var _i = 0, _a = this.instances; _i < _a.length; _i++) {
      var instance = _a[_i];
      instance.instancedBuffers = {};
    }
    this._userInstancedBuffersStorage = {
      data: {},
      vertexBuffers: {},
      strides: {},
      sizes: {}
    };
  }
  this.instancedBuffers[kind] = null;
  this._userInstancedBuffersStorage.strides[kind] = stride;
  this._userInstancedBuffersStorage.sizes[kind] = stride * 32;
  this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);
  this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);
  this.setVerticesBuffer(this._userInstancedBuffersStorage.vertexBuffers[kind]);
  for (var _b = 0, _c = this.instances; _b < _c.length; _b++) {
    var instance = _c[_b];
    instance.instancedBuffers[kind] = null;
  }
};
Mesh.prototype._processInstancedBuffers = function(visibleInstances, renderSelf) {
  var instanceCount = visibleInstances.length;
  for (var kind in this.instancedBuffers) {
    var size = this._userInstancedBuffersStorage.sizes[kind];
    var stride = this._userInstancedBuffersStorage.strides[kind];
    var expectedSize = (instanceCount + 1) * stride;
    while (size < expectedSize) {
      size *= 2;
    }
    if (this._userInstancedBuffersStorage.data[kind].length != size) {
      this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);
      this._userInstancedBuffersStorage.sizes[kind] = size;
      if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {
        this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();
        this._userInstancedBuffersStorage.vertexBuffers[kind] = null;
      }
    }
    var data = this._userInstancedBuffersStorage.data[kind];
    var offset = 0;
    if (renderSelf) {
      var value = this.instancedBuffers[kind];
      if (value.toArray) {
        value.toArray(data, offset);
      } else {
        value.copyToArray(data, offset);
      }
      offset += stride;
    }
    for (var instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {
      var instance = visibleInstances[instanceIndex];
      var value = instance.instancedBuffers[kind];
      if (value.toArray) {
        value.toArray(data, offset);
      } else {
        value.copyToArray(data, offset);
      }
      offset += stride;
    }
    if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {
      this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);
      this.setVerticesBuffer(this._userInstancedBuffersStorage.vertexBuffers[kind]);
    } else {
      this._userInstancedBuffersStorage.vertexBuffers[kind].updateDirectly(data, 0);
    }
  }
};
Mesh.prototype._disposeInstanceSpecificData = function() {
  if (this._instanceDataStorage.instancesBuffer) {
    this._instanceDataStorage.instancesBuffer.dispose();
    this._instanceDataStorage.instancesBuffer = null;
  }
  while (this.instances.length) {
    this.instances[0].dispose();
  }
  for (var kind in this.instancedBuffers) {
    if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {
      this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();
    }
  }
  this.instancedBuffers = {};
};

// node_modules/@babylonjs/core/Shaders/color.fragment.js
var name7 = "colorPixelShader";
var shader7 = "#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#else\nuniform vec4 color;\n#endif\n#include<clipPlaneFragmentDeclaration>\nvoid main(void) {\n#include<clipPlaneFragment>\n#ifdef VERTEXCOLOR\ngl_FragColor=vColor;\n#else\ngl_FragColor=color;\n#endif\n}";
Effect.ShadersStore[name7] = shader7;

// node_modules/@babylonjs/core/Shaders/color.vertex.js
var name8 = "colorVertexShader";
var shader8 = "\nattribute vec3 position;\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<clipPlaneVertexDeclaration>\n\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\n#ifdef MULTIVIEW\nuniform mat4 viewProjectionR;\n#endif\n\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\nvoid main(void) {\n#include<instancesVertex>\n#include<bonesVertex>\nvec4 worldPos=finalWorld*vec4(position,1.0);\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR == 0u) {\ngl_Position=viewProjection*worldPos;\n} else {\ngl_Position=viewProjectionR*worldPos;\n}\n#else\ngl_Position=viewProjection*worldPos;\n#endif\n#include<clipPlaneVertex>\n#ifdef VERTEXCOLOR\n\nvColor=color;\n#endif\n}";
Effect.ShadersStore[name8] = shader8;

// node_modules/@babylonjs/core/Meshes/linesMesh.js
var LinesMesh = function(_super) {
  __extends(LinesMesh2, _super);
  function LinesMesh2(name98, scene, parent, source, doNotCloneChildren, useVertexColor, useVertexAlpha) {
    if (scene === void 0) {
      scene = null;
    }
    if (parent === void 0) {
      parent = null;
    }
    if (source === void 0) {
      source = null;
    }
    var _this = _super.call(this, name98, scene, parent, source, doNotCloneChildren) || this;
    _this.useVertexColor = useVertexColor;
    _this.useVertexAlpha = useVertexAlpha;
    _this.color = new Color3(1, 1, 1);
    _this.alpha = 1;
    if (source) {
      _this.color = source.color.clone();
      _this.alpha = source.alpha;
      _this.useVertexColor = source.useVertexColor;
      _this.useVertexAlpha = source.useVertexAlpha;
    }
    _this.intersectionThreshold = 0.1;
    var defines = [];
    var options = {
      attributes: [VertexBuffer.PositionKind, "world0", "world1", "world2", "world3"],
      uniforms: ["vClipPlane", "vClipPlane2", "vClipPlane3", "vClipPlane4", "vClipPlane5", "vClipPlane6", "world", "viewProjection"],
      needAlphaBlending: true,
      defines
    };
    if (useVertexAlpha === false) {
      options.needAlphaBlending = false;
    }
    if (!useVertexColor) {
      options.uniforms.push("color");
      _this.color4 = new Color4();
    } else {
      options.defines.push("#define VERTEXCOLOR");
      options.attributes.push(VertexBuffer.ColorKind);
    }
    _this._colorShader = new ShaderMaterial("colorShader", _this.getScene(), "color", options);
    return _this;
  }
  LinesMesh2.prototype._addClipPlaneDefine = function(label) {
    var define = "#define " + label;
    var index = this._colorShader.options.defines.indexOf(define);
    if (index !== -1) {
      return;
    }
    this._colorShader.options.defines.push(define);
  };
  LinesMesh2.prototype._removeClipPlaneDefine = function(label) {
    var define = "#define " + label;
    var index = this._colorShader.options.defines.indexOf(define);
    if (index === -1) {
      return;
    }
    this._colorShader.options.defines.splice(index, 1);
  };
  LinesMesh2.prototype.isReady = function() {
    var scene = this.getScene();
    scene.clipPlane ? this._addClipPlaneDefine("CLIPPLANE") : this._removeClipPlaneDefine("CLIPPLANE");
    scene.clipPlane2 ? this._addClipPlaneDefine("CLIPPLANE2") : this._removeClipPlaneDefine("CLIPPLANE2");
    scene.clipPlane3 ? this._addClipPlaneDefine("CLIPPLANE3") : this._removeClipPlaneDefine("CLIPPLANE3");
    scene.clipPlane4 ? this._addClipPlaneDefine("CLIPPLANE4") : this._removeClipPlaneDefine("CLIPPLANE4");
    scene.clipPlane5 ? this._addClipPlaneDefine("CLIPPLANE5") : this._removeClipPlaneDefine("CLIPPLANE5");
    scene.clipPlane6 ? this._addClipPlaneDefine("CLIPPLANE6") : this._removeClipPlaneDefine("CLIPPLANE6");
    if (!this._colorShader.isReady(this)) {
      return false;
    }
    return _super.prototype.isReady.call(this);
  };
  LinesMesh2.prototype.getClassName = function() {
    return "LinesMesh";
  };
  Object.defineProperty(LinesMesh2.prototype, "material", {
    get: function() {
      return this._colorShader;
    },
    set: function(value) {
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LinesMesh2.prototype, "checkCollisions", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  LinesMesh2.prototype._bind = function(subMesh, effect, fillMode) {
    if (!this._geometry) {
      return this;
    }
    var colorEffect = this._colorShader.getEffect();
    var indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();
    this._geometry._bind(colorEffect, indexToBind);
    if (!this.useVertexColor) {
      var _a = this.color, r = _a.r, g = _a.g, b = _a.b;
      this.color4.set(r, g, b, this.alpha);
      this._colorShader.setColor4("color", this.color4);
    }
    MaterialHelper.BindClipPlane(colorEffect, this.getScene());
    return this;
  };
  LinesMesh2.prototype._draw = function(subMesh, fillMode, instancesCount) {
    if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {
      return this;
    }
    var engine = this.getScene().getEngine();
    if (this._unIndexed) {
      engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);
    } else {
      engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);
    }
    return this;
  };
  LinesMesh2.prototype.dispose = function(doNotRecurse) {
    this._colorShader.dispose(false, false, true);
    _super.prototype.dispose.call(this, doNotRecurse);
  };
  LinesMesh2.prototype.clone = function(name98, newParent, doNotCloneChildren) {
    if (newParent === void 0) {
      newParent = null;
    }
    return new LinesMesh2(name98, this.getScene(), newParent, this, doNotCloneChildren);
  };
  LinesMesh2.prototype.createInstance = function(name98) {
    return new InstancedLinesMesh(name98, this);
  };
  return LinesMesh2;
}(Mesh);
var InstancedLinesMesh = function(_super) {
  __extends(InstancedLinesMesh2, _super);
  function InstancedLinesMesh2(name98, source) {
    var _this = _super.call(this, name98, source) || this;
    _this.intersectionThreshold = source.intersectionThreshold;
    return _this;
  }
  InstancedLinesMesh2.prototype.getClassName = function() {
    return "InstancedLinesMesh";
  };
  return InstancedLinesMesh2;
}(InstancedMesh);

// node_modules/@babylonjs/core/Meshes/Builders/linesBuilder.js
VertexData.CreateLineSystem = function(options) {
  var indices = [];
  var positions = [];
  var lines = options.lines;
  var colors = options.colors;
  var vertexColors = [];
  var idx = 0;
  for (var l = 0; l < lines.length; l++) {
    var points = lines[l];
    for (var index = 0; index < points.length; index++) {
      positions.push(points[index].x, points[index].y, points[index].z);
      if (colors) {
        var color = colors[l];
        vertexColors.push(color[index].r, color[index].g, color[index].b, color[index].a);
      }
      if (index > 0) {
        indices.push(idx - 1);
        indices.push(idx);
      }
      idx++;
    }
  }
  var vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  if (colors) {
    vertexData.colors = vertexColors;
  }
  return vertexData;
};
VertexData.CreateDashedLines = function(options) {
  var dashSize = options.dashSize || 3;
  var gapSize = options.gapSize || 1;
  var dashNb = options.dashNb || 200;
  var points = options.points;
  var positions = new Array();
  var indices = new Array();
  var curvect = Vector3.Zero();
  var lg = 0;
  var nb = 0;
  var shft = 0;
  var dashshft = 0;
  var curshft = 0;
  var idx = 0;
  var i = 0;
  for (i = 0; i < points.length - 1; i++) {
    points[i + 1].subtractToRef(points[i], curvect);
    lg += curvect.length();
  }
  shft = lg / dashNb;
  dashshft = dashSize * shft / (dashSize + gapSize);
  for (i = 0; i < points.length - 1; i++) {
    points[i + 1].subtractToRef(points[i], curvect);
    nb = Math.floor(curvect.length() / shft);
    curvect.normalize();
    for (var j = 0; j < nb; j++) {
      curshft = shft * j;
      positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);
      positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);
      indices.push(idx, idx + 1);
      idx += 2;
    }
  }
  var vertexData = new VertexData();
  vertexData.positions = positions;
  vertexData.indices = indices;
  return vertexData;
};
Mesh.CreateLines = function(name98, points, scene, updatable, instance) {
  if (scene === void 0) {
    scene = null;
  }
  if (updatable === void 0) {
    updatable = false;
  }
  if (instance === void 0) {
    instance = null;
  }
  var options = {
    points,
    updatable,
    instance
  };
  return LinesBuilder.CreateLines(name98, options, scene);
};
Mesh.CreateDashedLines = function(name98, points, dashSize, gapSize, dashNb, scene, updatable, instance) {
  if (scene === void 0) {
    scene = null;
  }
  var options = {
    points,
    dashSize,
    gapSize,
    dashNb,
    updatable,
    instance
  };
  return LinesBuilder.CreateDashedLines(name98, options, scene);
};
var LinesBuilder = function() {
  function LinesBuilder2() {
  }
  LinesBuilder2.CreateLineSystem = function(name98, options, scene) {
    var instance = options.instance;
    var lines = options.lines;
    var colors = options.colors;
    if (instance) {
      var positions = instance.getVerticesData(VertexBuffer.PositionKind);
      var vertexColor;
      var lineColors;
      if (colors) {
        vertexColor = instance.getVerticesData(VertexBuffer.ColorKind);
      }
      var i = 0;
      var c = 0;
      for (var l = 0; l < lines.length; l++) {
        var points = lines[l];
        for (var p = 0; p < points.length; p++) {
          positions[i] = points[p].x;
          positions[i + 1] = points[p].y;
          positions[i + 2] = points[p].z;
          if (colors && vertexColor) {
            lineColors = colors[l];
            vertexColor[c] = lineColors[p].r;
            vertexColor[c + 1] = lineColors[p].g;
            vertexColor[c + 2] = lineColors[p].b;
            vertexColor[c + 3] = lineColors[p].a;
            c += 4;
          }
          i += 3;
        }
      }
      instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);
      if (colors && vertexColor) {
        instance.updateVerticesData(VertexBuffer.ColorKind, vertexColor, false, false);
      }
      return instance;
    }
    var useVertexColor = colors ? true : false;
    var lineSystem = new LinesMesh(name98, scene, null, void 0, void 0, useVertexColor, options.useVertexAlpha);
    var vertexData = VertexData.CreateLineSystem(options);
    vertexData.applyToMesh(lineSystem, options.updatable);
    return lineSystem;
  };
  LinesBuilder2.CreateLines = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    var colors = options.colors ? [options.colors] : null;
    var lines = LinesBuilder2.CreateLineSystem(name98, { lines: [options.points], updatable: options.updatable, instance: options.instance, colors, useVertexAlpha: options.useVertexAlpha }, scene);
    return lines;
  };
  LinesBuilder2.CreateDashedLines = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    var points = options.points;
    var instance = options.instance;
    var gapSize = options.gapSize || 1;
    var dashSize = options.dashSize || 3;
    if (instance) {
      var positionFunction = function(positions) {
        var curvect = Vector3.Zero();
        var nbSeg = positions.length / 6;
        var lg = 0;
        var nb = 0;
        var shft = 0;
        var dashshft = 0;
        var curshft = 0;
        var p = 0;
        var i = 0;
        var j = 0;
        for (i = 0; i < points.length - 1; i++) {
          points[i + 1].subtractToRef(points[i], curvect);
          lg += curvect.length();
        }
        shft = lg / nbSeg;
        var dashSize2 = instance._creationDataStorage.dashSize;
        var gapSize2 = instance._creationDataStorage.gapSize;
        dashshft = dashSize2 * shft / (dashSize2 + gapSize2);
        for (i = 0; i < points.length - 1; i++) {
          points[i + 1].subtractToRef(points[i], curvect);
          nb = Math.floor(curvect.length() / shft);
          curvect.normalize();
          j = 0;
          while (j < nb && p < positions.length) {
            curshft = shft * j;
            positions[p] = points[i].x + curshft * curvect.x;
            positions[p + 1] = points[i].y + curshft * curvect.y;
            positions[p + 2] = points[i].z + curshft * curvect.z;
            positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;
            positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;
            positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;
            p += 6;
            j++;
          }
        }
        while (p < positions.length) {
          positions[p] = points[i].x;
          positions[p + 1] = points[i].y;
          positions[p + 2] = points[i].z;
          p += 3;
        }
      };
      instance.updateMeshPositions(positionFunction, false);
      return instance;
    }
    var dashedLines = new LinesMesh(name98, scene, null, void 0, void 0, void 0, options.useVertexAlpha);
    var vertexData = VertexData.CreateDashedLines(options);
    vertexData.applyToMesh(dashedLines, options.updatable);
    dashedLines._creationDataStorage = new _CreationDataStorage();
    dashedLines._creationDataStorage.dashSize = dashSize;
    dashedLines._creationDataStorage.gapSize = gapSize;
    return dashedLines;
  };
  return LinesBuilder2;
}();

// node_modules/@babylonjs/core/Debug/rayHelper.js
var RayHelper = function() {
  function RayHelper2(ray) {
    this.ray = ray;
  }
  RayHelper2.CreateAndShow = function(ray, scene, color) {
    var helper = new RayHelper2(ray);
    helper.show(scene, color);
    return helper;
  };
  RayHelper2.prototype.show = function(scene, color) {
    if (!this._renderFunction && this.ray) {
      var ray = this.ray;
      this._renderFunction = this._render.bind(this);
      this._scene = scene;
      this._renderPoints = [ray.origin, ray.origin.add(ray.direction.scale(ray.length))];
      this._renderLine = Mesh.CreateLines("ray", this._renderPoints, scene, true);
      this._renderLine.isPickable = false;
      if (this._renderFunction) {
        this._scene.registerBeforeRender(this._renderFunction);
      }
    }
    if (color && this._renderLine) {
      this._renderLine.color.copyFrom(color);
    }
  };
  RayHelper2.prototype.hide = function() {
    if (this._renderFunction && this._scene) {
      this._scene.unregisterBeforeRender(this._renderFunction);
      this._scene = null;
      this._renderFunction = null;
      if (this._renderLine) {
        this._renderLine.dispose();
        this._renderLine = null;
      }
      this._renderPoints = [];
    }
  };
  RayHelper2.prototype._render = function() {
    var ray = this.ray;
    if (!ray) {
      return;
    }
    var point = this._renderPoints[1];
    var len = Math.min(ray.length, 1e6);
    point.copyFrom(ray.direction);
    point.scaleInPlace(len);
    point.addInPlace(ray.origin);
    this._renderPoints[0].copyFrom(ray.origin);
    Mesh.CreateLines("ray", this._renderPoints, this._scene, true, this._renderLine);
  };
  RayHelper2.prototype.attachToMesh = function(mesh, meshSpaceDirection, meshSpaceOrigin, length) {
    var _this = this;
    this._attachedToMesh = mesh;
    var ray = this.ray;
    if (!ray) {
      return;
    }
    if (!ray.direction) {
      ray.direction = Vector3.Zero();
    }
    if (!ray.origin) {
      ray.origin = Vector3.Zero();
    }
    if (length) {
      ray.length = length;
    }
    if (!meshSpaceOrigin) {
      meshSpaceOrigin = Vector3.Zero();
    }
    if (!meshSpaceDirection) {
      meshSpaceDirection = new Vector3(0, 0, -1);
    }
    if (!this._scene) {
      this._scene = mesh.getScene();
    }
    if (!this._meshSpaceDirection) {
      this._meshSpaceDirection = meshSpaceDirection.clone();
      this._meshSpaceOrigin = meshSpaceOrigin.clone();
    } else {
      this._meshSpaceDirection.copyFrom(meshSpaceDirection);
      this._meshSpaceOrigin.copyFrom(meshSpaceOrigin);
    }
    if (!this._onAfterRenderObserver) {
      this._onAfterRenderObserver = this._scene.onBeforeRenderObservable.add(function() {
        return _this._updateToMesh();
      });
      this._onAfterStepObserver = this._scene.onAfterStepObservable.add(function() {
        return _this._updateToMesh();
      });
    }
    this._attachedToMesh.computeWorldMatrix(true);
    this._updateToMesh();
  };
  RayHelper2.prototype.detachFromMesh = function() {
    if (this._attachedToMesh && this._scene) {
      if (this._onAfterRenderObserver) {
        this._scene.onBeforeRenderObservable.remove(this._onAfterRenderObserver);
        this._scene.onAfterStepObservable.remove(this._onAfterStepObserver);
      }
      this._attachedToMesh = null;
      this._onAfterRenderObserver = null;
      this._onAfterStepObserver = null;
      this._scene = null;
    }
  };
  RayHelper2.prototype._updateToMesh = function() {
    var ray = this.ray;
    if (!this._attachedToMesh || !ray) {
      return;
    }
    if (this._attachedToMesh._isDisposed) {
      this.detachFromMesh();
      return;
    }
    this._attachedToMesh.getDirectionToRef(this._meshSpaceDirection, ray.direction);
    Vector3.TransformCoordinatesToRef(this._meshSpaceOrigin, this._attachedToMesh.getWorldMatrix(), ray.origin);
  };
  RayHelper2.prototype.dispose = function() {
    this.hide();
    this.detachFromMesh();
    this.ray = null;
  };
  return RayHelper2;
}();

// node_modules/@babylonjs/core/Meshes/Builders/ribbonBuilder.js
VertexData.CreateRibbon = function(options) {
  var pathArray = options.pathArray;
  var closeArray = options.closeArray || false;
  var closePath = options.closePath || false;
  var invertUV = options.invertUV || false;
  var defaultOffset = Math.floor(pathArray[0].length / 2);
  var offset = options.offset || defaultOffset;
  offset = offset > defaultOffset ? defaultOffset : Math.floor(offset);
  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  var customUV = options.uvs;
  var customColors = options.colors;
  var positions = [];
  var indices = [];
  var normals = [];
  var uvs = [];
  var us = [];
  var vs = [];
  var uTotalDistance = [];
  var vTotalDistance = [];
  var minlg;
  var lg = [];
  var idx = [];
  var p;
  var i;
  var j;
  if (pathArray.length < 2) {
    var ar1 = [];
    var ar2 = [];
    for (i = 0; i < pathArray[0].length - offset; i++) {
      ar1.push(pathArray[0][i]);
      ar2.push(pathArray[0][i + offset]);
    }
    pathArray = [ar1, ar2];
  }
  var idc = 0;
  var closePathCorr = closePath ? 1 : 0;
  var path;
  var l;
  minlg = pathArray[0].length;
  var vectlg;
  var dist;
  for (p = 0; p < pathArray.length; p++) {
    uTotalDistance[p] = 0;
    us[p] = [0];
    path = pathArray[p];
    l = path.length;
    minlg = minlg < l ? minlg : l;
    j = 0;
    while (j < l) {
      positions.push(path[j].x, path[j].y, path[j].z);
      if (j > 0) {
        vectlg = path[j].subtract(path[j - 1]).length();
        dist = vectlg + uTotalDistance[p];
        us[p].push(dist);
        uTotalDistance[p] = dist;
      }
      j++;
    }
    if (closePath) {
      j--;
      positions.push(path[0].x, path[0].y, path[0].z);
      vectlg = path[j].subtract(path[0]).length();
      dist = vectlg + uTotalDistance[p];
      us[p].push(dist);
      uTotalDistance[p] = dist;
    }
    lg[p] = l + closePathCorr;
    idx[p] = idc;
    idc += l + closePathCorr;
  }
  var path1;
  var path2;
  var vertex1 = null;
  var vertex2 = null;
  for (i = 0; i < minlg + closePathCorr; i++) {
    vTotalDistance[i] = 0;
    vs[i] = [0];
    for (p = 0; p < pathArray.length - 1; p++) {
      path1 = pathArray[p];
      path2 = pathArray[p + 1];
      if (i === minlg) {
        vertex1 = path1[0];
        vertex2 = path2[0];
      } else {
        vertex1 = path1[i];
        vertex2 = path2[i];
      }
      vectlg = vertex2.subtract(vertex1).length();
      dist = vectlg + vTotalDistance[i];
      vs[i].push(dist);
      vTotalDistance[i] = dist;
    }
    if (closeArray && vertex2 && vertex1) {
      path1 = pathArray[p];
      path2 = pathArray[0];
      if (i === minlg) {
        vertex2 = path2[0];
      }
      vectlg = vertex2.subtract(vertex1).length();
      dist = vectlg + vTotalDistance[i];
      vTotalDistance[i] = dist;
    }
  }
  var u;
  var v;
  if (customUV) {
    for (p = 0; p < customUV.length; p++) {
      uvs.push(customUV[p].x, customUV[p].y);
    }
  } else {
    for (p = 0; p < pathArray.length; p++) {
      for (i = 0; i < minlg + closePathCorr; i++) {
        u = uTotalDistance[p] != 0 ? us[p][i] / uTotalDistance[p] : 0;
        v = vTotalDistance[i] != 0 ? vs[i][p] / vTotalDistance[i] : 0;
        if (invertUV) {
          uvs.push(v, u);
        } else {
          uvs.push(u, v);
        }
      }
    }
  }
  p = 0;
  var pi = 0;
  var l1 = lg[p] - 1;
  var l2 = lg[p + 1] - 1;
  var min = l1 < l2 ? l1 : l2;
  var shft = idx[1] - idx[0];
  var path1nb = closeArray ? lg.length : lg.length - 1;
  while (pi <= min && p < path1nb) {
    indices.push(pi, pi + shft, pi + 1);
    indices.push(pi + shft + 1, pi + 1, pi + shft);
    pi += 1;
    if (pi === min) {
      p++;
      if (p === lg.length - 1) {
        shft = idx[0] - idx[p];
        l1 = lg[p] - 1;
        l2 = lg[0] - 1;
      } else {
        shft = idx[p + 1] - idx[p];
        l1 = lg[p] - 1;
        l2 = lg[p + 1] - 1;
      }
      pi = idx[p];
      min = l1 < l2 ? l1 + pi : l2 + pi;
    }
  }
  VertexData.ComputeNormals(positions, indices, normals);
  if (closePath) {
    var indexFirst = 0;
    var indexLast = 0;
    for (p = 0; p < pathArray.length; p++) {
      indexFirst = idx[p] * 3;
      if (p + 1 < pathArray.length) {
        indexLast = (idx[p + 1] - 1) * 3;
      } else {
        indexLast = normals.length - 3;
      }
      normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;
      normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;
      normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;
      normals[indexLast] = normals[indexFirst];
      normals[indexLast + 1] = normals[indexFirst + 1];
      normals[indexLast + 2] = normals[indexFirst + 2];
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  var colors = null;
  if (customColors) {
    colors = new Float32Array(customColors.length * 4);
    for (var c = 0; c < customColors.length; c++) {
      colors[c * 4] = customColors[c].r;
      colors[c * 4 + 1] = customColors[c].g;
      colors[c * 4 + 2] = customColors[c].b;
      colors[c * 4 + 3] = customColors[c].a;
    }
  }
  var vertexData = new VertexData();
  var positions32 = new Float32Array(positions);
  var normals32 = new Float32Array(normals);
  var uvs32 = new Float32Array(uvs);
  vertexData.indices = indices;
  vertexData.positions = positions32;
  vertexData.normals = normals32;
  vertexData.uvs = uvs32;
  if (colors) {
    vertexData.set(colors, VertexBuffer.ColorKind);
  }
  if (closePath) {
    vertexData._idx = idx;
  }
  return vertexData;
};
Mesh.CreateRibbon = function(name98, pathArray, closeArray, closePath, offset, scene, updatable, sideOrientation, instance) {
  if (closeArray === void 0) {
    closeArray = false;
  }
  if (updatable === void 0) {
    updatable = false;
  }
  return RibbonBuilder.CreateRibbon(name98, {
    pathArray,
    closeArray,
    closePath,
    offset,
    updatable,
    sideOrientation,
    instance
  }, scene);
};
var RibbonBuilder = function() {
  function RibbonBuilder2() {
  }
  RibbonBuilder2.CreateRibbon = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    var pathArray = options.pathArray;
    var closeArray = options.closeArray;
    var closePath = options.closePath;
    var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
    var instance = options.instance;
    var updatable = options.updatable;
    if (instance) {
      var minimum_1 = TmpVectors.Vector3[0].setAll(Number.MAX_VALUE);
      var maximum_1 = TmpVectors.Vector3[1].setAll(-Number.MAX_VALUE);
      var positionFunction = function(positions2) {
        var minlg = pathArray[0].length;
        var mesh = instance;
        var i2 = 0;
        var ns = mesh._originalBuilderSideOrientation === Mesh.DOUBLESIDE ? 2 : 1;
        for (var si = 1; si <= ns; ++si) {
          for (var p2 = 0; p2 < pathArray.length; ++p2) {
            var path = pathArray[p2];
            var l = path.length;
            minlg = minlg < l ? minlg : l;
            for (var j = 0; j < minlg; ++j) {
              var pathPoint = path[j];
              positions2[i2] = pathPoint.x;
              positions2[i2 + 1] = pathPoint.y;
              positions2[i2 + 2] = pathPoint.z;
              minimum_1.minimizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);
              maximum_1.maximizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);
              i2 += 3;
            }
            if (mesh._creationDataStorage && mesh._creationDataStorage.closePath) {
              var pathPoint = path[0];
              positions2[i2] = pathPoint.x;
              positions2[i2 + 1] = pathPoint.y;
              positions2[i2 + 2] = pathPoint.z;
              i2 += 3;
            }
          }
        }
      };
      var positions = instance.getVerticesData(VertexBuffer.PositionKind);
      positionFunction(positions);
      if (instance._boundingInfo) {
        instance._boundingInfo.reConstruct(minimum_1, maximum_1, instance._worldMatrix);
      } else {
        instance._boundingInfo = new BoundingInfo(minimum_1, maximum_1, instance._worldMatrix);
      }
      instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);
      if (options.colors) {
        var colors = instance.getVerticesData(VertexBuffer.ColorKind);
        for (var c = 0, colorIndex = 0; c < options.colors.length; c++, colorIndex += 4) {
          var color = options.colors[c];
          colors[colorIndex] = color.r;
          colors[colorIndex + 1] = color.g;
          colors[colorIndex + 2] = color.b;
          colors[colorIndex + 3] = color.a;
        }
        instance.updateVerticesData(VertexBuffer.ColorKind, colors, false, false);
      }
      if (options.uvs) {
        var uvs = instance.getVerticesData(VertexBuffer.UVKind);
        for (var i = 0; i < options.uvs.length; i++) {
          uvs[i * 2] = options.uvs[i].x;
          uvs[i * 2 + 1] = options.uvs[i].y;
        }
        instance.updateVerticesData(VertexBuffer.UVKind, uvs, false, false);
      }
      if (!instance.areNormalsFrozen || instance.isFacetDataEnabled) {
        var indices = instance.getIndices();
        var normals = instance.getVerticesData(VertexBuffer.NormalKind);
        var params = instance.isFacetDataEnabled ? instance.getFacetDataParameters() : null;
        VertexData.ComputeNormals(positions, indices, normals, params);
        if (instance._creationDataStorage && instance._creationDataStorage.closePath) {
          var indexFirst = 0;
          var indexLast = 0;
          for (var p = 0; p < pathArray.length; p++) {
            indexFirst = instance._creationDataStorage.idx[p] * 3;
            if (p + 1 < pathArray.length) {
              indexLast = (instance._creationDataStorage.idx[p + 1] - 1) * 3;
            } else {
              indexLast = normals.length - 3;
            }
            normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;
            normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;
            normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;
            normals[indexLast] = normals[indexFirst];
            normals[indexLast + 1] = normals[indexFirst + 1];
            normals[indexLast + 2] = normals[indexFirst + 2];
          }
        }
        if (!instance.areNormalsFrozen) {
          instance.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);
        }
      }
      return instance;
    } else {
      var ribbon = new Mesh(name98, scene);
      ribbon._originalBuilderSideOrientation = sideOrientation;
      ribbon._creationDataStorage = new _CreationDataStorage();
      var vertexData = VertexData.CreateRibbon(options);
      if (closePath) {
        ribbon._creationDataStorage.idx = vertexData._idx;
      }
      ribbon._creationDataStorage.closePath = closePath;
      ribbon._creationDataStorage.closeArray = closeArray;
      vertexData.applyToMesh(ribbon, updatable);
      return ribbon;
    }
  };
  return RibbonBuilder2;
}();

// node_modules/@babylonjs/core/Meshes/Builders/shapeBuilder.js
Mesh.ExtrudeShape = function(name98, shape, path, scale, rotation, cap, scene, updatable, sideOrientation, instance) {
  if (scene === void 0) {
    scene = null;
  }
  var options = {
    shape,
    path,
    scale,
    rotation,
    cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,
    sideOrientation,
    instance,
    updatable
  };
  return ShapeBuilder.ExtrudeShape(name98, options, scene);
};
Mesh.ExtrudeShapeCustom = function(name98, shape, path, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, scene, updatable, sideOrientation, instance) {
  var options = {
    shape,
    path,
    scaleFunction,
    rotationFunction,
    ribbonCloseArray,
    ribbonClosePath,
    cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,
    sideOrientation,
    instance,
    updatable
  };
  return ShapeBuilder.ExtrudeShapeCustom(name98, options, scene);
};
var ShapeBuilder = function() {
  function ShapeBuilder2() {
  }
  ShapeBuilder2.ExtrudeShape = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    var path = options.path;
    var shape = options.shape;
    var scale = options.scale || 1;
    var rotation = options.rotation || 0;
    var cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;
    var updatable = options.updatable;
    var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
    var instance = options.instance || null;
    var invertUV = options.invertUV || false;
    return ShapeBuilder2._ExtrudeShapeGeneric(name98, shape, path, scale, rotation, null, null, false, false, cap, false, scene, updatable ? true : false, sideOrientation, instance, invertUV, options.frontUVs || null, options.backUVs || null);
  };
  ShapeBuilder2.ExtrudeShapeCustom = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    var path = options.path;
    var shape = options.shape;
    var scaleFunction = options.scaleFunction || function() {
      return 1;
    };
    var rotationFunction = options.rotationFunction || function() {
      return 0;
    };
    var ribbonCloseArray = options.ribbonCloseArray || false;
    var ribbonClosePath = options.ribbonClosePath || false;
    var cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;
    var updatable = options.updatable;
    var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
    var instance = options.instance;
    var invertUV = options.invertUV || false;
    return ShapeBuilder2._ExtrudeShapeGeneric(name98, shape, path, null, null, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, true, scene, updatable ? true : false, sideOrientation, instance || null, invertUV, options.frontUVs || null, options.backUVs || null);
  };
  ShapeBuilder2._ExtrudeShapeGeneric = function(name98, shape, curve, scale, rotation, scaleFunction, rotateFunction, rbCA, rbCP, cap, custom, scene, updtbl, side, instance, invertUV, frontUVs, backUVs) {
    var extrusionPathArray = function(shape2, curve2, path3D2, shapePaths, scale2, rotation2, scaleFunction2, rotateFunction2, cap2, custom2) {
      var tangents = path3D2.getTangents();
      var normals = path3D2.getNormals();
      var binormals = path3D2.getBinormals();
      var distances = path3D2.getDistances();
      var angle = 0;
      var returnScale = function() {
        return scale2 !== null ? scale2 : 1;
      };
      var returnRotation = function() {
        return rotation2 !== null ? rotation2 : 0;
      };
      var rotate = custom2 && rotateFunction2 ? rotateFunction2 : returnRotation;
      var scl = custom2 && scaleFunction2 ? scaleFunction2 : returnScale;
      var index = cap2 === Mesh.NO_CAP || cap2 === Mesh.CAP_END ? 0 : 2;
      var rotationMatrix = TmpVectors.Matrix[0];
      for (var i = 0; i < curve2.length; i++) {
        var shapePath = new Array();
        var angleStep = rotate(i, distances[i]);
        var scaleRatio = scl(i, distances[i]);
        for (var p = 0; p < shape2.length; p++) {
          Matrix.RotationAxisToRef(tangents[i], angle, rotationMatrix);
          var planed = tangents[i].scale(shape2[p].z).add(normals[i].scale(shape2[p].x)).add(binormals[i].scale(shape2[p].y));
          var rotated = shapePath[p] ? shapePath[p] : Vector3.Zero();
          Vector3.TransformCoordinatesToRef(planed, rotationMatrix, rotated);
          rotated.scaleInPlace(scaleRatio).addInPlace(curve2[i]);
          shapePath[p] = rotated;
        }
        shapePaths[index] = shapePath;
        angle += angleStep;
        index++;
      }
      var capPath = function(shapePath2) {
        var pointCap = Array();
        var barycenter = Vector3.Zero();
        var i2;
        for (i2 = 0; i2 < shapePath2.length; i2++) {
          barycenter.addInPlace(shapePath2[i2]);
        }
        barycenter.scaleInPlace(1 / shapePath2.length);
        for (i2 = 0; i2 < shapePath2.length; i2++) {
          pointCap.push(barycenter);
        }
        return pointCap;
      };
      switch (cap2) {
        case Mesh.NO_CAP:
          break;
        case Mesh.CAP_START:
          shapePaths[0] = capPath(shapePaths[2]);
          shapePaths[1] = shapePaths[2];
          break;
        case Mesh.CAP_END:
          shapePaths[index] = shapePaths[index - 1];
          shapePaths[index + 1] = capPath(shapePaths[index - 1]);
          break;
        case Mesh.CAP_ALL:
          shapePaths[0] = capPath(shapePaths[2]);
          shapePaths[1] = shapePaths[2];
          shapePaths[index] = shapePaths[index - 1];
          shapePaths[index + 1] = capPath(shapePaths[index - 1]);
          break;
        default:
          break;
      }
      return shapePaths;
    };
    var path3D;
    var pathArray;
    if (instance) {
      var storage = instance._creationDataStorage;
      path3D = storage.path3D.update(curve);
      pathArray = extrusionPathArray(shape, curve, storage.path3D, storage.pathArray, scale, rotation, scaleFunction, rotateFunction, storage.cap, custom);
      instance = Mesh.CreateRibbon("", pathArray, false, false, 0, scene || void 0, false, 0, instance);
      return instance;
    }
    path3D = new Path3D(curve);
    var newShapePaths = new Array();
    cap = cap < 0 || cap > 3 ? 0 : cap;
    pathArray = extrusionPathArray(shape, curve, path3D, newShapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom);
    var extrudedGeneric = RibbonBuilder.CreateRibbon(name98, { pathArray, closeArray: rbCA, closePath: rbCP, updatable: updtbl, sideOrientation: side, invertUV, frontUVs: frontUVs || void 0, backUVs: backUVs || void 0 }, scene);
    extrudedGeneric._creationDataStorage.pathArray = pathArray;
    extrudedGeneric._creationDataStorage.path3D = path3D;
    extrudedGeneric._creationDataStorage.cap = cap;
    return extrudedGeneric;
  };
  return ShapeBuilder2;
}();

// node_modules/@babylonjs/core/Debug/skeletonViewer.js
var SkeletonViewer = function() {
  function SkeletonViewer2(skeleton, mesh, scene, autoUpdateBonesMatrices, renderingGroupId, options) {
    if (autoUpdateBonesMatrices === void 0) {
      autoUpdateBonesMatrices = true;
    }
    if (renderingGroupId === void 0) {
      renderingGroupId = 3;
    }
    if (options === void 0) {
      options = {};
    }
    var _a, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
    this.skeleton = skeleton;
    this.mesh = mesh;
    this.autoUpdateBonesMatrices = autoUpdateBonesMatrices;
    this.renderingGroupId = renderingGroupId;
    this.options = options;
    this.color = Color3.White();
    this._debugLines = new Array();
    this._localAxes = null;
    this._isEnabled = false;
    this._obs = null;
    this._scene = scene;
    this._ready = false;
    options.pauseAnimations = (_a = options.pauseAnimations) !== null && _a !== void 0 ? _a : true;
    options.returnToRest = (_c = options.returnToRest) !== null && _c !== void 0 ? _c : false;
    options.displayMode = (_d = options.displayMode) !== null && _d !== void 0 ? _d : SkeletonViewer2.DISPLAY_LINES;
    options.displayOptions = (_e = options.displayOptions) !== null && _e !== void 0 ? _e : {};
    options.displayOptions.midStep = (_f = options.displayOptions.midStep) !== null && _f !== void 0 ? _f : 0.235;
    options.displayOptions.midStepFactor = (_g = options.displayOptions.midStepFactor) !== null && _g !== void 0 ? _g : 0.155;
    options.displayOptions.sphereBaseSize = (_h = options.displayOptions.sphereBaseSize) !== null && _h !== void 0 ? _h : 0.15;
    options.displayOptions.sphereScaleUnit = (_j = options.displayOptions.sphereScaleUnit) !== null && _j !== void 0 ? _j : 2;
    options.displayOptions.sphereFactor = (_k = options.displayOptions.sphereFactor) !== null && _k !== void 0 ? _k : 0.865;
    options.displayOptions.spurFollowsChild = (_l = options.displayOptions.spurFollowsChild) !== null && _l !== void 0 ? _l : false;
    options.displayOptions.showLocalAxes = (_m = options.displayOptions.showLocalAxes) !== null && _m !== void 0 ? _m : false;
    options.displayOptions.localAxesSize = (_o = options.displayOptions.localAxesSize) !== null && _o !== void 0 ? _o : 0.075;
    options.computeBonesUsingShaders = (_p = options.computeBonesUsingShaders) !== null && _p !== void 0 ? _p : true;
    options.useAllBones = (_q = options.useAllBones) !== null && _q !== void 0 ? _q : true;
    var initialMeshBoneIndices = mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);
    var initialMeshBoneWeights = mesh.getVerticesData(VertexBuffer.MatricesWeightsKind);
    this._boneIndices = /* @__PURE__ */ new Set();
    if (!options.useAllBones) {
      if (initialMeshBoneIndices && initialMeshBoneWeights) {
        for (var i = 0; i < initialMeshBoneIndices.length; ++i) {
          var index = initialMeshBoneIndices[i], weight = initialMeshBoneWeights[i];
          if (weight !== 0) {
            this._boneIndices.add(index);
          }
        }
      }
    }
    this._utilityLayer = new UtilityLayerRenderer(this._scene, false);
    this._utilityLayer.pickUtilitySceneFirst = false;
    this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = true;
    var displayMode = this.options.displayMode || 0;
    if (displayMode > SkeletonViewer2.DISPLAY_SPHERE_AND_SPURS) {
      displayMode = SkeletonViewer2.DISPLAY_LINES;
    }
    this.displayMode = displayMode;
    this.update();
    this._bindObs();
  }
  SkeletonViewer2.CreateBoneWeightShader = function(options, scene) {
    var _a, _c, _d, _e, _f, _g;
    var skeleton = options.skeleton;
    var colorBase = (_a = options.colorBase) !== null && _a !== void 0 ? _a : Color3.Black();
    var colorZero = (_c = options.colorZero) !== null && _c !== void 0 ? _c : Color3.Blue();
    var colorQuarter = (_d = options.colorQuarter) !== null && _d !== void 0 ? _d : Color3.Green();
    var colorHalf = (_e = options.colorHalf) !== null && _e !== void 0 ? _e : Color3.Yellow();
    var colorFull = (_f = options.colorFull) !== null && _f !== void 0 ? _f : Color3.Red();
    var targetBoneIndex = (_g = options.targetBoneIndex) !== null && _g !== void 0 ? _g : 0;
    Effect.ShadersStore["boneWeights:" + skeleton.name + "VertexShader"] = "precision highp float;\n\n        attribute vec3 position;\n        attribute vec2 uv;\n\n        uniform mat4 view;\n        uniform mat4 projection;\n        uniform mat4 worldViewProjection;\n\n        #include<bonesDeclaration>\n        #if NUM_BONE_INFLUENCERS == 0\n            attribute vec4 matricesIndices;\n            attribute vec4 matricesWeights;\n        #endif\n\n        #include<instancesDeclaration>\n\n        varying vec3 vColor;\n\n        uniform vec3 colorBase;\n        uniform vec3 colorZero;\n        uniform vec3 colorQuarter;\n        uniform vec3 colorHalf;\n        uniform vec3 colorFull;\n\n        uniform float targetBoneIndex;\n\n        void main() {\n            vec3 positionUpdated = position;\n\n            #include<instancesVertex>\n            #include<bonesVertex>\n\n            vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\n\n            vec3 color = colorBase;\n            float totalWeight = 0.;\n            if(matricesIndices[0] == targetBoneIndex && matricesWeights[0] > 0.){\n                totalWeight += matricesWeights[0];\n            }\n            if(matricesIndices[1] == targetBoneIndex && matricesWeights[1] > 0.){\n                totalWeight += matricesWeights[1];\n            }\n            if(matricesIndices[2] == targetBoneIndex && matricesWeights[2] > 0.){\n                totalWeight += matricesWeights[2];\n            }\n            if(matricesIndices[3] == targetBoneIndex && matricesWeights[3] > 0.){\n                totalWeight += matricesWeights[3];\n            }\n\n            color = mix(color, colorZero, smoothstep(0., 0.25, totalWeight));\n            color = mix(color, colorQuarter, smoothstep(0.25, 0.5, totalWeight));\n            color = mix(color, colorHalf, smoothstep(0.5, 0.75, totalWeight));\n            color = mix(color, colorFull, smoothstep(0.75, 1.0, totalWeight));\n            vColor = color;\n\n        gl_Position = projection * view * worldPos;\n        }";
    Effect.ShadersStore["boneWeights:" + skeleton.name + "FragmentShader"] = "\n            precision highp float;\n            varying vec3 vPosition;\n\n            varying vec3 vColor;\n\n            void main() {\n                vec4 color = vec4(vColor, 1.0);\n                gl_FragColor = color;\n            }\n        ";
    var shader98 = new ShaderMaterial("boneWeight:" + skeleton.name, scene, {
      vertex: "boneWeights:" + skeleton.name,
      fragment: "boneWeights:" + skeleton.name
    }, {
      attributes: ["position", "normal", "matricesIndices", "matricesWeights"],
      uniforms: [
        "world",
        "worldView",
        "worldViewProjection",
        "view",
        "projection",
        "viewProjection",
        "colorBase",
        "colorZero",
        "colorQuarter",
        "colorHalf",
        "colorFull",
        "targetBoneIndex"
      ]
    });
    shader98.setColor3("colorBase", colorBase);
    shader98.setColor3("colorZero", colorZero);
    shader98.setColor3("colorQuarter", colorQuarter);
    shader98.setColor3("colorHalf", colorHalf);
    shader98.setColor3("colorFull", colorFull);
    shader98.setFloat("targetBoneIndex", targetBoneIndex);
    shader98.getClassName = function() {
      return "BoneWeightShader";
    };
    shader98.transparencyMode = Material.MATERIAL_OPAQUE;
    return shader98;
  };
  SkeletonViewer2.CreateSkeletonMapShader = function(options, scene) {
    var _a;
    var skeleton = options.skeleton;
    var colorMap = (_a = options.colorMap) !== null && _a !== void 0 ? _a : [
      {
        color: new Color3(1, 0.38, 0.18),
        location: 0
      },
      {
        color: new Color3(0.59, 0.18, 1),
        location: 0.2
      },
      {
        color: new Color3(0.59, 1, 0.18),
        location: 0.4
      },
      {
        color: new Color3(1, 0.87, 0.17),
        location: 0.6
      },
      {
        color: new Color3(1, 0.17, 0.42),
        location: 0.8
      },
      {
        color: new Color3(0.17, 0.68, 1),
        location: 1
      }
    ];
    var bufferWidth = skeleton.bones.length + 1;
    var colorMapBuffer = SkeletonViewer2._CreateBoneMapColorBuffer(bufferWidth, colorMap, scene);
    var shader98 = new ShaderMaterial("boneWeights:" + skeleton.name, scene, {
      vertexSource: "precision highp float;\n\n            attribute vec3 position;\n            attribute vec2 uv;\n\n            uniform mat4 view;\n            uniform mat4 projection;\n            uniform mat4 worldViewProjection;\n            uniform float colorMap[" + skeleton.bones.length * 4 + "];\n\n            #include<bonesDeclaration>\n            #if NUM_BONE_INFLUENCERS == 0\n                attribute vec4 matricesIndices;\n                attribute vec4 matricesWeights;\n            #endif\n            #include<instancesDeclaration>\n\n            varying vec3 vColor;\n\n            void main() {\n                vec3 positionUpdated = position;\n\n                #include<instancesVertex>\n                #include<bonesVertex>\n\n                vec3 color = vec3(0.);\n                bool first = true;\n\n                for (int i = 0; i < 4; i++) {\n                    int boneIdx = int(matricesIndices[i]);\n                    float boneWgt = matricesWeights[i];\n\n                    vec3 c = vec3(colorMap[boneIdx * 4 + 0], colorMap[boneIdx * 4 + 1], colorMap[boneIdx * 4 + 2]);\n\n                    if (boneWgt > 0.) {\n                        if (first) {\n                            first = false;\n                            color = c;\n                        } else {\n                            color = mix(color, c, boneWgt);\n                        }\n                    }\n                }\n\n                vColor = color;\n\n                vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\n\n                gl_Position = projection * view * worldPos;\n            }",
      fragmentSource: "\n            precision highp float;\n            varying vec3 vColor;\n\n            void main() {\n                vec4 color = vec4( vColor, 1.0 );\n                gl_FragColor = color;\n            }\n            "
    }, {
      attributes: ["position", "normal", "matricesIndices", "matricesWeights"],
      uniforms: [
        "world",
        "worldView",
        "worldViewProjection",
        "view",
        "projection",
        "viewProjection",
        "colorMap"
      ]
    });
    shader98.setFloats("colorMap", colorMapBuffer);
    shader98.getClassName = function() {
      return "SkeletonMapShader";
    };
    shader98.transparencyMode = Material.MATERIAL_OPAQUE;
    return shader98;
  };
  SkeletonViewer2._CreateBoneMapColorBuffer = function(size, colorMap, scene) {
    var tempGrad = new DynamicTexture("temp", { width: size, height: 1 }, scene, false);
    var ctx = tempGrad.getContext();
    var grad = ctx.createLinearGradient(0, 0, size, 0);
    colorMap.forEach(function(stop) {
      grad.addColorStop(stop.location, stop.color.toHexString());
    });
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, size, 1);
    tempGrad.update();
    var buffer = [];
    var data = ctx.getImageData(0, 0, size, 1).data;
    var rUnit = 1 / 255;
    for (var i = 0; i < data.length; i++) {
      buffer.push(data[i] * rUnit);
    }
    tempGrad.dispose();
    return buffer;
  };
  Object.defineProperty(SkeletonViewer2.prototype, "scene", {
    get: function() {
      return this._scene;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SkeletonViewer2.prototype, "utilityLayer", {
    get: function() {
      return this._utilityLayer;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SkeletonViewer2.prototype, "isReady", {
    get: function() {
      return this._ready;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SkeletonViewer2.prototype, "ready", {
    set: function(value) {
      this._ready = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SkeletonViewer2.prototype, "debugMesh", {
    get: function() {
      return this._debugMesh;
    },
    set: function(value) {
      this._debugMesh = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SkeletonViewer2.prototype, "displayMode", {
    get: function() {
      return this.options.displayMode || SkeletonViewer2.DISPLAY_LINES;
    },
    set: function(value) {
      if (value > SkeletonViewer2.DISPLAY_SPHERE_AND_SPURS) {
        value = SkeletonViewer2.DISPLAY_LINES;
      }
      this.options.displayMode = value;
    },
    enumerable: false,
    configurable: true
  });
  SkeletonViewer2.prototype._bindObs = function() {
    var _this = this;
    switch (this.displayMode) {
      case SkeletonViewer2.DISPLAY_LINES: {
        this._obs = this.scene.onBeforeRenderObservable.add(function() {
          _this._displayLinesUpdate();
        });
        break;
      }
    }
  };
  SkeletonViewer2.prototype.update = function() {
    switch (this.displayMode) {
      case SkeletonViewer2.DISPLAY_LINES: {
        this._displayLinesUpdate();
        break;
      }
      case SkeletonViewer2.DISPLAY_SPHERES: {
        this._buildSpheresAndSpurs(true);
        break;
      }
      case SkeletonViewer2.DISPLAY_SPHERE_AND_SPURS: {
        this._buildSpheresAndSpurs(false);
        break;
      }
    }
    this._buildLocalAxes();
  };
  Object.defineProperty(SkeletonViewer2.prototype, "isEnabled", {
    get: function() {
      return this._isEnabled;
    },
    set: function(value) {
      if (this.isEnabled === value) {
        return;
      }
      this._isEnabled = value;
      if (this.debugMesh) {
        this.debugMesh.setEnabled(value);
      }
      if (value && !this._obs) {
        this._bindObs();
      } else if (!value && this._obs) {
        this.scene.onBeforeRenderObservable.remove(this._obs);
        this._obs = null;
      }
    },
    enumerable: false,
    configurable: true
  });
  SkeletonViewer2.prototype._getBonePosition = function(position, bone, meshMat, x, y, z) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    var tmat = TmpVectors.Matrix[0];
    var parentBone = bone.getParent();
    tmat.copyFrom(bone.getLocalMatrix());
    if (x !== 0 || y !== 0 || z !== 0) {
      var tmat2 = TmpVectors.Matrix[1];
      Matrix.IdentityToRef(tmat2);
      tmat2.setTranslationFromFloats(x, y, z);
      tmat2.multiplyToRef(tmat, tmat);
    }
    if (parentBone) {
      tmat.multiplyToRef(parentBone.getAbsoluteTransform(), tmat);
    }
    tmat.multiplyToRef(meshMat, tmat);
    position.x = tmat.m[12];
    position.y = tmat.m[13];
    position.z = tmat.m[14];
  };
  SkeletonViewer2.prototype._getLinesForBonesWithLength = function(bones, meshMat) {
    var len = bones.length;
    var mesh = this.mesh._effectiveMesh;
    var meshPos = mesh.position;
    var idx = 0;
    for (var i = 0; i < len; i++) {
      var bone = bones[i];
      var points = this._debugLines[idx];
      if (bone._index === -1 || !this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones) {
        continue;
      }
      if (!points) {
        points = [Vector3.Zero(), Vector3.Zero()];
        this._debugLines[idx] = points;
      }
      this._getBonePosition(points[0], bone, meshMat);
      this._getBonePosition(points[1], bone, meshMat, 0, bone.length, 0);
      points[0].subtractInPlace(meshPos);
      points[1].subtractInPlace(meshPos);
      idx++;
    }
  };
  SkeletonViewer2.prototype._getLinesForBonesNoLength = function(bones) {
    var len = bones.length;
    var boneNum = 0;
    var mesh = this.mesh._effectiveMesh;
    var meshPos = mesh.position;
    for (var i = len - 1; i >= 0; i--) {
      var childBone = bones[i];
      var parentBone = childBone.getParent();
      if (!parentBone || !this._boneIndices.has(childBone.getIndex()) && !this.options.useAllBones) {
        continue;
      }
      var points = this._debugLines[boneNum];
      if (!points) {
        points = [Vector3.Zero(), Vector3.Zero()];
        this._debugLines[boneNum] = points;
      }
      childBone.getAbsolutePositionToRef(mesh, points[0]);
      parentBone.getAbsolutePositionToRef(mesh, points[1]);
      points[0].subtractInPlace(meshPos);
      points[1].subtractInPlace(meshPos);
      boneNum++;
    }
  };
  SkeletonViewer2.prototype._revert = function(animationState) {
    if (this.options.pauseAnimations) {
      this.scene.animationsEnabled = animationState;
      this.utilityLayer.utilityLayerScene.animationsEnabled = animationState;
    }
  };
  SkeletonViewer2.prototype._getAbsoluteBindPoseToRef = function(bone, matrix) {
    if (bone === null || bone._index === -1) {
      matrix.copyFrom(Matrix.Identity());
      return;
    }
    this._getAbsoluteBindPoseToRef(bone.getParent(), matrix);
    bone.getBindPose().multiplyToRef(matrix, matrix);
    return;
  };
  SkeletonViewer2.prototype._buildSpheresAndSpurs = function(spheresOnly) {
    var _a, _c;
    if (spheresOnly === void 0) {
      spheresOnly = true;
    }
    if (this._debugMesh) {
      this._debugMesh.dispose();
      this._debugMesh = null;
      this.ready = false;
    }
    this._ready = false;
    var utilityLayerScene = (_a = this.utilityLayer) === null || _a === void 0 ? void 0 : _a.utilityLayerScene;
    var bones = this.skeleton.bones;
    var spheres = [];
    var spurs = [];
    var animationState = this.scene.animationsEnabled;
    try {
      if (this.options.pauseAnimations) {
        this.scene.animationsEnabled = false;
        utilityLayerScene.animationsEnabled = false;
      }
      if (this.options.returnToRest) {
        this.skeleton.returnToRest();
      }
      if (this.autoUpdateBonesMatrices) {
        this.skeleton.computeAbsoluteTransforms();
      }
      var longestBoneLength_1 = Number.NEGATIVE_INFINITY;
      var displayOptions_1 = this.options.displayOptions || {};
      var _loop_1 = function(i2) {
        var bone2 = bones[i2];
        if (bone2._index === -1 || !this_1._boneIndices.has(bone2.getIndex()) && !this_1.options.useAllBones) {
          return "continue";
        }
        var boneAbsoluteBindPoseTransform = new Matrix();
        this_1._getAbsoluteBindPoseToRef(bone2, boneAbsoluteBindPoseTransform);
        var anchorPoint = new Vector3();
        boneAbsoluteBindPoseTransform.decompose(void 0, void 0, anchorPoint);
        bone2.children.forEach(function(bc, i3) {
          var childAbsoluteBindPoseTransform = new Matrix();
          bc.getBindPose().multiplyToRef(boneAbsoluteBindPoseTransform, childAbsoluteBindPoseTransform);
          var childPoint = new Vector3();
          childAbsoluteBindPoseTransform.decompose(void 0, void 0, childPoint);
          var distanceFromParent = Vector3.Distance(anchorPoint, childPoint);
          if (distanceFromParent > longestBoneLength_1) {
            longestBoneLength_1 = distanceFromParent;
          }
          if (spheresOnly) {
            return;
          }
          var dir = childPoint.clone().subtract(anchorPoint.clone());
          var h = dir.length();
          var up = dir.normalize().scale(h);
          var midStep = displayOptions_1.midStep || 0.165;
          var midStepFactor = displayOptions_1.midStepFactor || 0.215;
          var up0 = up.scale(midStep);
          var spur = ShapeBuilder.ExtrudeShapeCustom("skeletonViewer", {
            shape: [
              new Vector3(1, -1, 0),
              new Vector3(1, 1, 0),
              new Vector3(-1, 1, 0),
              new Vector3(-1, -1, 0),
              new Vector3(1, -1, 0)
            ],
            path: [Vector3.Zero(), up0, up],
            scaleFunction: function(i4) {
              switch (i4) {
                case 0:
                case 2:
                  return 0;
                case 1:
                  return h * midStepFactor;
              }
              return 0;
            },
            sideOrientation: Mesh.DEFAULTSIDE,
            updatable: false
          }, utilityLayerScene);
          var numVertices2 = spur.getTotalVertices();
          var mwk2 = [], mik2 = [];
          for (var i_1 = 0; i_1 < numVertices2; i_1++) {
            mwk2.push(1, 0, 0, 0);
            if (displayOptions_1.spurFollowsChild && i_1 > 9) {
              mik2.push(bc.getIndex(), 0, 0, 0);
            } else {
              mik2.push(bone2.getIndex(), 0, 0, 0);
            }
          }
          spur.position = anchorPoint.clone();
          spur.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk2, false);
          spur.setVerticesData(VertexBuffer.MatricesIndicesKind, mik2, false);
          spur.convertToFlatShadedMesh();
          spurs.push(spur);
        });
        var sphereBaseSize = displayOptions_1.sphereBaseSize || 0.2;
        var sphere2 = SphereBuilder.CreateSphere("skeletonViewer", {
          segments: 6,
          diameter: sphereBaseSize,
          updatable: true
        }, utilityLayerScene);
        var numVertices = sphere2.getTotalVertices();
        var mwk = [], mik = [];
        for (var i_2 = 0; i_2 < numVertices; i_2++) {
          mwk.push(1, 0, 0, 0);
          mik.push(bone2.getIndex(), 0, 0, 0);
        }
        sphere2.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);
        sphere2.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);
        sphere2.position = anchorPoint.clone();
        spheres.push([sphere2, bone2]);
      };
      var this_1 = this;
      for (var i = 0; i < bones.length; i++) {
        _loop_1(i);
      }
      var sphereScaleUnit = displayOptions_1.sphereScaleUnit || 2;
      var sphereFactor = displayOptions_1.sphereFactor || 0.85;
      var meshes = [];
      for (var i = 0; i < spheres.length; i++) {
        var _d = spheres[i], sphere = _d[0], bone = _d[1];
        var scale = 1 / (sphereScaleUnit / longestBoneLength_1);
        var _stepsOut = 0;
        var _b = bone;
        while (_b.getParent() && _b.getParent().getIndex() !== -1) {
          _stepsOut++;
          _b = _b.getParent();
        }
        sphere.scaling.scaleInPlace(scale * Math.pow(sphereFactor, _stepsOut));
        meshes.push(sphere);
      }
      this.debugMesh = Mesh.MergeMeshes(meshes.concat(spurs), true, true);
      if (this.debugMesh) {
        this.debugMesh.renderingGroupId = this.renderingGroupId;
        this.debugMesh.skeleton = this.skeleton;
        this.debugMesh.parent = this.mesh;
        this.debugMesh.computeBonesUsingShaders = (_c = this.options.computeBonesUsingShaders) !== null && _c !== void 0 ? _c : true;
        this.debugMesh.alwaysSelectAsActiveMesh = true;
      }
      var light = this.utilityLayer._getSharedGizmoLight();
      light.intensity = 0.7;
      this._revert(animationState);
      this.ready = true;
    } catch (err) {
      console.error(err);
      this._revert(animationState);
      this.dispose();
    }
  };
  SkeletonViewer2.prototype._buildLocalAxes = function() {
    var _a;
    if (this._localAxes) {
      this._localAxes.dispose();
    }
    this._localAxes = null;
    var displayOptions = this.options.displayOptions || {};
    if (!displayOptions.showLocalAxes) {
      return;
    }
    var targetScene = this._utilityLayer.utilityLayerScene;
    var size = displayOptions.localAxesSize || 0.075;
    var lines = [];
    var colors = [];
    var red = new Color4(1, 0, 0, 1);
    var green = new Color4(0, 1, 0, 1);
    var blue = new Color4(0, 0, 1, 1);
    var mwk = [];
    var mik = [];
    var vertsPerBone = 6;
    for (var i in this.skeleton.bones) {
      var bone = this.skeleton.bones[i];
      if (bone._index === -1 || !this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones) {
        continue;
      }
      var boneAbsoluteBindPoseTransform = new Matrix();
      var boneOrigin = new Vector3();
      this._getAbsoluteBindPoseToRef(bone, boneAbsoluteBindPoseTransform);
      boneAbsoluteBindPoseTransform.decompose(void 0, void 0, boneOrigin);
      var m = bone.getBindPose().getRotationMatrix();
      var boneAxisX = Vector3.TransformCoordinates(new Vector3(0 + size, 0, 0), m);
      var boneAxisY = Vector3.TransformCoordinates(new Vector3(0, 0 + size, 0), m);
      var boneAxisZ = Vector3.TransformCoordinates(new Vector3(0, 0, 0 + size), m);
      var axisX = [boneOrigin, boneOrigin.add(boneAxisX)];
      var axisY = [boneOrigin, boneOrigin.add(boneAxisY)];
      var axisZ = [boneOrigin, boneOrigin.add(boneAxisZ)];
      var linePoints = [axisX, axisY, axisZ];
      var lineColors = [[red, red], [green, green], [blue, blue]];
      lines.push.apply(lines, linePoints);
      colors.push.apply(colors, lineColors);
      for (var j = 0; j < vertsPerBone; j++) {
        mwk.push(1, 0, 0, 0);
        mik.push(bone.getIndex(), 0, 0, 0);
      }
    }
    this._localAxes = LinesBuilder.CreateLineSystem("localAxes", { lines, colors, updatable: true }, targetScene);
    this._localAxes.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);
    this._localAxes.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);
    this._localAxes.skeleton = this.skeleton;
    this._localAxes.renderingGroupId = this.renderingGroupId;
    this._localAxes.parent = this.mesh;
    this._localAxes.computeBonesUsingShaders = (_a = this.options.computeBonesUsingShaders) !== null && _a !== void 0 ? _a : true;
  };
  SkeletonViewer2.prototype._displayLinesUpdate = function() {
    if (!this._utilityLayer) {
      return;
    }
    if (this.autoUpdateBonesMatrices) {
      this.skeleton.computeAbsoluteTransforms();
    }
    var mesh = this.mesh._effectiveMesh;
    if (this.skeleton.bones[0].length === void 0) {
      this._getLinesForBonesNoLength(this.skeleton.bones);
    } else {
      this._getLinesForBonesWithLength(this.skeleton.bones, mesh.getWorldMatrix());
    }
    var targetScene = this._utilityLayer.utilityLayerScene;
    if (targetScene) {
      if (!this._debugMesh) {
        this._debugMesh = LinesBuilder.CreateLineSystem("", { lines: this._debugLines, updatable: true, instance: null }, targetScene);
        this._debugMesh.renderingGroupId = this.renderingGroupId;
      } else {
        LinesBuilder.CreateLineSystem("", { lines: this._debugLines, updatable: true, instance: this._debugMesh }, targetScene);
      }
      this._debugMesh.position.copyFrom(this.mesh.position);
      this._debugMesh.color = this.color;
    }
  };
  SkeletonViewer2.prototype.changeDisplayMode = function(mode) {
    var wasEnabled = this.isEnabled ? true : false;
    if (this.displayMode !== mode) {
      this.isEnabled = false;
      if (this._debugMesh) {
        this._debugMesh.dispose();
        this._debugMesh = null;
        this.ready = false;
      }
      this.displayMode = mode;
      this.update();
      this._bindObs();
      this.isEnabled = wasEnabled;
    }
  };
  SkeletonViewer2.prototype.changeDisplayOptions = function(option, value) {
    var wasEnabled = this.isEnabled ? true : false;
    this.options.displayOptions[option] = value;
    this.isEnabled = false;
    if (this._debugMesh) {
      this._debugMesh.dispose();
      this._debugMesh = null;
      this.ready = false;
    }
    this.update();
    this._bindObs();
    this.isEnabled = wasEnabled;
  };
  SkeletonViewer2.prototype.dispose = function() {
    this.isEnabled = false;
    if (this._debugMesh) {
      this._debugMesh.dispose();
      this._debugMesh = null;
    }
    if (this._utilityLayer) {
      this._utilityLayer.dispose();
      this._utilityLayer = null;
    }
    this.ready = false;
  };
  SkeletonViewer2.DISPLAY_LINES = 0;
  SkeletonViewer2.DISPLAY_SPHERES = 1;
  SkeletonViewer2.DISPLAY_SPHERE_AND_SPURS = 2;
  return SkeletonViewer2;
}();

// node_modules/@babylonjs/core/DeviceInput/InputDevices/deviceEnums.js
var DeviceType;
(function(DeviceType2) {
  DeviceType2[DeviceType2["Generic"] = 0] = "Generic";
  DeviceType2[DeviceType2["Keyboard"] = 1] = "Keyboard";
  DeviceType2[DeviceType2["Mouse"] = 2] = "Mouse";
  DeviceType2[DeviceType2["Touch"] = 3] = "Touch";
  DeviceType2[DeviceType2["DualShock"] = 4] = "DualShock";
  DeviceType2[DeviceType2["Xbox"] = 5] = "Xbox";
  DeviceType2[DeviceType2["Switch"] = 6] = "Switch";
})(DeviceType || (DeviceType = {}));
var PointerInput;
(function(PointerInput2) {
  PointerInput2[PointerInput2["Horizontal"] = 0] = "Horizontal";
  PointerInput2[PointerInput2["Vertical"] = 1] = "Vertical";
  PointerInput2[PointerInput2["LeftClick"] = 2] = "LeftClick";
  PointerInput2[PointerInput2["MiddleClick"] = 3] = "MiddleClick";
  PointerInput2[PointerInput2["RightClick"] = 4] = "RightClick";
  PointerInput2[PointerInput2["BrowserBack"] = 5] = "BrowserBack";
  PointerInput2[PointerInput2["BrowserForward"] = 6] = "BrowserForward";
})(PointerInput || (PointerInput = {}));
var DualShockInput;
(function(DualShockInput2) {
  DualShockInput2[DualShockInput2["Cross"] = 0] = "Cross";
  DualShockInput2[DualShockInput2["Circle"] = 1] = "Circle";
  DualShockInput2[DualShockInput2["Square"] = 2] = "Square";
  DualShockInput2[DualShockInput2["Triangle"] = 3] = "Triangle";
  DualShockInput2[DualShockInput2["L1"] = 4] = "L1";
  DualShockInput2[DualShockInput2["R1"] = 5] = "R1";
  DualShockInput2[DualShockInput2["L2"] = 6] = "L2";
  DualShockInput2[DualShockInput2["R2"] = 7] = "R2";
  DualShockInput2[DualShockInput2["Share"] = 8] = "Share";
  DualShockInput2[DualShockInput2["Options"] = 9] = "Options";
  DualShockInput2[DualShockInput2["L3"] = 10] = "L3";
  DualShockInput2[DualShockInput2["R3"] = 11] = "R3";
  DualShockInput2[DualShockInput2["DPadUp"] = 12] = "DPadUp";
  DualShockInput2[DualShockInput2["DPadDown"] = 13] = "DPadDown";
  DualShockInput2[DualShockInput2["DPadLeft"] = 14] = "DPadLeft";
  DualShockInput2[DualShockInput2["DPadRight"] = 15] = "DPadRight";
  DualShockInput2[DualShockInput2["Home"] = 16] = "Home";
  DualShockInput2[DualShockInput2["TouchPad"] = 17] = "TouchPad";
  DualShockInput2[DualShockInput2["LStickXAxis"] = 18] = "LStickXAxis";
  DualShockInput2[DualShockInput2["LStickYAxis"] = 19] = "LStickYAxis";
  DualShockInput2[DualShockInput2["RStickXAxis"] = 20] = "RStickXAxis";
  DualShockInput2[DualShockInput2["RStickYAxis"] = 21] = "RStickYAxis";
})(DualShockInput || (DualShockInput = {}));
var XboxInput;
(function(XboxInput2) {
  XboxInput2[XboxInput2["A"] = 0] = "A";
  XboxInput2[XboxInput2["B"] = 1] = "B";
  XboxInput2[XboxInput2["X"] = 2] = "X";
  XboxInput2[XboxInput2["Y"] = 3] = "Y";
  XboxInput2[XboxInput2["LB"] = 4] = "LB";
  XboxInput2[XboxInput2["RB"] = 5] = "RB";
  XboxInput2[XboxInput2["LT"] = 6] = "LT";
  XboxInput2[XboxInput2["RT"] = 7] = "RT";
  XboxInput2[XboxInput2["Back"] = 8] = "Back";
  XboxInput2[XboxInput2["Start"] = 9] = "Start";
  XboxInput2[XboxInput2["LS"] = 10] = "LS";
  XboxInput2[XboxInput2["RS"] = 11] = "RS";
  XboxInput2[XboxInput2["DPadUp"] = 12] = "DPadUp";
  XboxInput2[XboxInput2["DPadDown"] = 13] = "DPadDown";
  XboxInput2[XboxInput2["DPadLeft"] = 14] = "DPadLeft";
  XboxInput2[XboxInput2["DPadRight"] = 15] = "DPadRight";
  XboxInput2[XboxInput2["Home"] = 16] = "Home";
  XboxInput2[XboxInput2["LStickXAxis"] = 17] = "LStickXAxis";
  XboxInput2[XboxInput2["LStickYAxis"] = 18] = "LStickYAxis";
  XboxInput2[XboxInput2["RStickXAxis"] = 19] = "RStickXAxis";
  XboxInput2[XboxInput2["RStickYAxis"] = 20] = "RStickYAxis";
})(XboxInput || (XboxInput = {}));
var SwitchInput;
(function(SwitchInput2) {
  SwitchInput2[SwitchInput2["B"] = 0] = "B";
  SwitchInput2[SwitchInput2["A"] = 1] = "A";
  SwitchInput2[SwitchInput2["Y"] = 2] = "Y";
  SwitchInput2[SwitchInput2["X"] = 3] = "X";
  SwitchInput2[SwitchInput2["L"] = 4] = "L";
  SwitchInput2[SwitchInput2["R"] = 5] = "R";
  SwitchInput2[SwitchInput2["ZL"] = 6] = "ZL";
  SwitchInput2[SwitchInput2["ZR"] = 7] = "ZR";
  SwitchInput2[SwitchInput2["Minus"] = 8] = "Minus";
  SwitchInput2[SwitchInput2["Plus"] = 9] = "Plus";
  SwitchInput2[SwitchInput2["LS"] = 10] = "LS";
  SwitchInput2[SwitchInput2["RS"] = 11] = "RS";
  SwitchInput2[SwitchInput2["DPadUp"] = 12] = "DPadUp";
  SwitchInput2[SwitchInput2["DPadDown"] = 13] = "DPadDown";
  SwitchInput2[SwitchInput2["DPadLeft"] = 14] = "DPadLeft";
  SwitchInput2[SwitchInput2["DPadRight"] = 15] = "DPadRight";
  SwitchInput2[SwitchInput2["Home"] = 16] = "Home";
  SwitchInput2[SwitchInput2["Capture"] = 17] = "Capture";
  SwitchInput2[SwitchInput2["LStickXAxis"] = 18] = "LStickXAxis";
  SwitchInput2[SwitchInput2["LStickYAxis"] = 19] = "LStickYAxis";
  SwitchInput2[SwitchInput2["RStickXAxis"] = 20] = "RStickXAxis";
  SwitchInput2[SwitchInput2["RStickYAxis"] = 21] = "RStickYAxis";
})(SwitchInput || (SwitchInput = {}));

// node_modules/@babylonjs/core/DeviceInput/deviceInputSystem.js
var DeviceInputSystem = function() {
  function DeviceInputSystem2(engine) {
    this.onDeviceDisconnected = function() {
    };
    this._inputs = [];
    this._keyboardActive = false;
    this._pointerActive = false;
    this._keyboardDownEvent = function(evt) {
    };
    this._keyboardUpEvent = function(evt) {
    };
    this._pointerMoveEvent = function(evt) {
    };
    this._pointerDownEvent = function(evt) {
    };
    this._pointerUpEvent = function(evt) {
    };
    this._gamepadConnectedEvent = function(evt) {
    };
    this._gamepadDisconnectedEvent = function(evt) {
    };
    this._onDeviceConnected = function() {
    };
    var inputElement = engine.getInputElement();
    if (inputElement) {
      this._elementToAttachTo = inputElement;
      this._handleKeyActions();
      this._handlePointerActions();
      this._handleGamepadActions();
      this._checkForConnectedDevices();
    }
  }
  Object.defineProperty(DeviceInputSystem2.prototype, "onDeviceConnected", {
    get: function() {
      return this._onDeviceConnected;
    },
    set: function(callback) {
      this._onDeviceConnected = callback;
      for (var deviceType = 0; deviceType < this._inputs.length; deviceType++) {
        if (this._inputs[deviceType]) {
          for (var deviceSlot = 0; deviceSlot < this._inputs[deviceType].length; deviceSlot++) {
            if (this._inputs[deviceType][deviceSlot]) {
              this._onDeviceConnected(deviceType, deviceSlot);
            }
          }
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  DeviceInputSystem2.Create = function(engine) {
    if (typeof _native !== "undefined" && _native.DeviceInputSystem) {
      return new _native.DeviceInputSystem(engine);
    }
    return new DeviceInputSystem2(engine);
  };
  DeviceInputSystem2.prototype.pollInput = function(deviceType, deviceSlot, inputIndex) {
    var device = this._inputs[deviceType][deviceSlot];
    if (!device) {
      throw "Unable to find device " + DeviceType[deviceType];
    }
    this._updateDevice(deviceType, deviceSlot, inputIndex);
    if (device[inputIndex] === void 0) {
      throw "Unable to find input " + inputIndex + " for device " + DeviceType[deviceType] + " in slot " + deviceSlot;
    }
    return device[inputIndex];
  };
  DeviceInputSystem2.prototype.dispose = function() {
    if (this._keyboardActive) {
      window.removeEventListener("keydown", this._keyboardDownEvent);
      window.removeEventListener("keyup", this._keyboardUpEvent);
    }
    if (this._pointerActive) {
      this._elementToAttachTo.removeEventListener("pointermove", this._pointerMoveEvent);
      this._elementToAttachTo.removeEventListener("pointerdown", this._pointerDownEvent);
      this._elementToAttachTo.removeEventListener("pointerup", this._pointerUpEvent);
    }
    window.removeEventListener("gamepadconnected", this._gamepadConnectedEvent);
    window.removeEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent);
  };
  DeviceInputSystem2.prototype._checkForConnectedDevices = function() {
    var gamepads = navigator.getGamepads();
    for (var _i = 0, gamepads_1 = gamepads; _i < gamepads_1.length; _i++) {
      var gamepad = gamepads_1[_i];
      if (gamepad) {
        this._addGamePad(gamepad);
      }
    }
    if (matchMedia("(pointer:fine)").matches) {
      this._addPointerDevice(DeviceType.Mouse, 0, 0, 0);
    }
  };
  DeviceInputSystem2.prototype._addGamePad = function(gamepad) {
    var deviceType = this._getGamepadDeviceType(gamepad.id);
    var deviceSlot = gamepad.index;
    this._registerDevice(deviceType, deviceSlot, gamepad.buttons.length + gamepad.axes.length);
    this._gamepads = this._gamepads || new Array(gamepad.index + 1);
    this._gamepads[deviceSlot] = deviceType;
  };
  DeviceInputSystem2.prototype._addPointerDevice = function(deviceType, deviceSlot, currentX, currentY) {
    this._pointerActive = true;
    this._registerDevice(deviceType, deviceSlot, DeviceInputSystem2._MAX_POINTER_INPUTS);
    var pointer = this._inputs[deviceType][deviceSlot];
    pointer[0] = currentX;
    pointer[1] = currentY;
  };
  DeviceInputSystem2.prototype._registerDevice = function(deviceType, deviceSlot, numberOfInputs) {
    if (!this._inputs[deviceType]) {
      this._inputs[deviceType] = [];
    }
    if (!this._inputs[deviceType][deviceSlot]) {
      var device = new Array(numberOfInputs);
      for (var i = 0; i < numberOfInputs; i++) {
        device[i] = 0;
      }
      this._inputs[deviceType][deviceSlot] = device;
      this.onDeviceConnected(deviceType, deviceSlot);
    }
  };
  DeviceInputSystem2.prototype._unregisterDevice = function(deviceType, deviceSlot) {
    if (this._inputs[deviceType][deviceSlot]) {
      delete this._inputs[deviceType][deviceSlot];
      this.onDeviceDisconnected(deviceType, deviceSlot);
    }
  };
  DeviceInputSystem2.prototype._handleKeyActions = function() {
    var _this = this;
    this._keyboardDownEvent = function(evt) {
      if (!_this._keyboardActive) {
        _this._keyboardActive = true;
        _this._registerDevice(DeviceType.Keyboard, 0, DeviceInputSystem2._MAX_KEYCODES);
      }
      var kbKey = _this._inputs[DeviceType.Keyboard][0];
      if (kbKey) {
        if (_this.onInputChanged) {
          _this.onInputChanged(DeviceType.Keyboard, 0, evt.keyCode, kbKey[evt.keyCode], 1);
        }
        kbKey[evt.keyCode] = 1;
      }
    };
    this._keyboardUpEvent = function(evt) {
      var kbKey = _this._inputs[DeviceType.Keyboard][0];
      if (kbKey) {
        if (_this.onInputChanged) {
          _this.onInputChanged(DeviceType.Keyboard, 0, evt.keyCode, kbKey[evt.keyCode], 0);
        }
        kbKey[evt.keyCode] = 0;
      }
    };
    window.addEventListener("keydown", this._keyboardDownEvent);
    window.addEventListener("keyup", this._keyboardUpEvent);
  };
  DeviceInputSystem2.prototype._handlePointerActions = function() {
    var _this = this;
    this._pointerMoveEvent = function(evt) {
      var deviceType = evt.pointerType == "mouse" ? DeviceType.Mouse : DeviceType.Touch;
      var deviceSlot = evt.pointerType == "mouse" ? 0 : evt.pointerId;
      if (!_this._inputs[deviceType]) {
        _this._inputs[deviceType] = [];
      }
      if (!_this._inputs[deviceType][deviceSlot]) {
        _this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);
      }
      var pointer = _this._inputs[deviceType][deviceSlot];
      if (pointer) {
        if (_this.onInputChanged) {
          _this.onInputChanged(deviceType, deviceSlot, 0, pointer[0], evt.clientX);
          _this.onInputChanged(deviceType, deviceSlot, 1, pointer[1], evt.clientY);
        }
        pointer[0] = evt.clientX;
        pointer[1] = evt.clientY;
      }
    };
    this._pointerDownEvent = function(evt) {
      var deviceType = evt.pointerType == "mouse" ? DeviceType.Mouse : DeviceType.Touch;
      var deviceSlot = evt.pointerType == "mouse" ? 0 : evt.pointerId;
      if (!_this._inputs[deviceType]) {
        _this._inputs[deviceType] = [];
      }
      if (!_this._inputs[deviceType][deviceSlot]) {
        _this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);
      }
      var pointer = _this._inputs[deviceType][deviceSlot];
      if (pointer) {
        if (_this.onInputChanged) {
          _this.onInputChanged(deviceType, deviceSlot, 0, pointer[0], evt.clientX);
          _this.onInputChanged(deviceType, deviceSlot, 1, pointer[1], evt.clientY);
          _this.onInputChanged(deviceType, deviceSlot, evt.button + 2, pointer[evt.button + 2], 1);
        }
        pointer[0] = evt.clientX;
        pointer[1] = evt.clientY;
        pointer[evt.button + 2] = 1;
      }
    };
    this._pointerUpEvent = function(evt) {
      var deviceType = evt.pointerType == "mouse" ? DeviceType.Mouse : DeviceType.Touch;
      var deviceSlot = evt.pointerType == "mouse" ? 0 : evt.pointerId;
      var pointer = _this._inputs[deviceType][deviceSlot];
      if (pointer) {
        if (_this.onInputChanged) {
          _this.onInputChanged(deviceType, deviceSlot, evt.button + 2, pointer[evt.button + 2], 0);
        }
        pointer[0] = evt.clientX;
        pointer[1] = evt.clientY;
        pointer[evt.button + 2] = 0;
      }
      if (evt.pointerType != "mouse") {
        _this._unregisterDevice(deviceType, deviceSlot);
      }
    };
    this._elementToAttachTo.addEventListener("pointermove", this._pointerMoveEvent);
    this._elementToAttachTo.addEventListener("pointerdown", this._pointerDownEvent);
    this._elementToAttachTo.addEventListener("pointerup", this._pointerUpEvent);
  };
  DeviceInputSystem2.prototype._handleGamepadActions = function() {
    var _this = this;
    this._gamepadConnectedEvent = function(evt) {
      _this._addGamePad(evt.gamepad);
    };
    this._gamepadDisconnectedEvent = function(evt) {
      if (_this._gamepads) {
        var deviceType = _this._getGamepadDeviceType(evt.gamepad.id);
        var deviceSlot = evt.gamepad.index;
        _this._unregisterDevice(deviceType, deviceSlot);
        delete _this._gamepads[deviceSlot];
      }
    };
    window.addEventListener("gamepadconnected", this._gamepadConnectedEvent);
    window.addEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent);
  };
  DeviceInputSystem2.prototype._updateDevice = function(deviceType, deviceSlot, inputIndex) {
    var gp = navigator.getGamepads()[deviceSlot];
    if (gp && deviceType == this._gamepads[deviceSlot]) {
      var device = this._inputs[deviceType][deviceSlot];
      if (inputIndex >= gp.buttons.length) {
        device[inputIndex] = gp.axes[inputIndex - gp.buttons.length].valueOf();
      } else {
        device[inputIndex] = gp.buttons[inputIndex].value;
      }
    }
  };
  DeviceInputSystem2.prototype._getGamepadDeviceType = function(deviceName) {
    if (deviceName.indexOf("054c") !== -1) {
      return DeviceType.DualShock;
    } else if (deviceName.indexOf("Xbox One") !== -1 || deviceName.search("Xbox 360") !== -1 || deviceName.search("xinput") !== -1) {
      return DeviceType.Xbox;
    } else if (deviceName.indexOf("057e") !== -1) {
      return DeviceType.Switch;
    }
    return DeviceType.Generic;
  };
  DeviceInputSystem2._MAX_KEYCODES = 255;
  DeviceInputSystem2._MAX_POINTER_INPUTS = 7;
  return DeviceInputSystem2;
}();

// node_modules/@babylonjs/core/DeviceInput/InputDevices/deviceSourceManager.js
var DeviceSource = function() {
  function DeviceSource2(deviceInputSystem, deviceType, deviceSlot) {
    if (deviceSlot === void 0) {
      deviceSlot = 0;
    }
    this.deviceType = deviceType;
    this.deviceSlot = deviceSlot;
    this.onInputChangedObservable = new Observable();
    this._deviceInputSystem = deviceInputSystem;
  }
  DeviceSource2.prototype.getInput = function(inputIndex) {
    return this._deviceInputSystem.pollInput(this.deviceType, this.deviceSlot, inputIndex);
  };
  return DeviceSource2;
}();
var DeviceSourceManager = function() {
  function DeviceSourceManager2(engine) {
    var _this = this;
    this.onDeviceConnectedObservable = new Observable(function(observer) {
      _this.getDevices().forEach(function(device) {
        _this.onDeviceConnectedObservable.notifyObserver(observer, device);
      });
    });
    this.onDeviceDisconnectedObservable = new Observable();
    var numberOfDeviceTypes = Object.keys(DeviceType).length / 2;
    this._devices = new Array(numberOfDeviceTypes);
    this._firstDevice = new Array(numberOfDeviceTypes);
    this._deviceInputSystem = DeviceInputSystem.Create(engine);
    this._deviceInputSystem.onDeviceConnected = function(deviceType, deviceSlot) {
      _this._addDevice(deviceType, deviceSlot);
      _this.onDeviceConnectedObservable.notifyObservers(_this.getDeviceSource(deviceType, deviceSlot));
    };
    this._deviceInputSystem.onDeviceDisconnected = function(deviceType, deviceSlot) {
      var device = _this.getDeviceSource(deviceType, deviceSlot);
      _this._removeDevice(deviceType, deviceSlot);
      _this.onDeviceDisconnectedObservable.notifyObservers(device);
    };
    if (!this._deviceInputSystem.onInputChanged) {
      this._deviceInputSystem.onInputChanged = function(deviceType, deviceSlot, inputIndex, previousState, currentState) {
        var _a;
        (_a = _this.getDeviceSource(deviceType, deviceSlot)) === null || _a === void 0 ? void 0 : _a.onInputChangedObservable.notifyObservers({ inputIndex, previousState, currentState });
      };
    }
  }
  DeviceSourceManager2.prototype.getDeviceSource = function(deviceType, deviceSlot) {
    if (deviceSlot === void 0) {
      if (this._firstDevice[deviceType] === void 0) {
        return null;
      }
      deviceSlot = this._firstDevice[deviceType];
    }
    if (!this._devices[deviceType] || this._devices[deviceType][deviceSlot] === void 0) {
      return null;
    }
    return this._devices[deviceType][deviceSlot];
  };
  DeviceSourceManager2.prototype.getDeviceSources = function(deviceType) {
    return this._devices[deviceType].filter(function(source) {
      return !!source;
    });
  };
  DeviceSourceManager2.prototype.getDevices = function() {
    var deviceArray = new Array();
    this._devices.forEach(function(deviceSet) {
      deviceArray.push.apply(deviceArray, deviceSet);
    });
    return deviceArray;
  };
  DeviceSourceManager2.prototype.dispose = function() {
    this.onDeviceConnectedObservable.clear();
    this.onDeviceDisconnectedObservable.clear();
    this._deviceInputSystem.dispose();
  };
  DeviceSourceManager2.prototype._addDevice = function(deviceType, deviceSlot) {
    if (!this._devices[deviceType]) {
      this._devices[deviceType] = new Array();
    }
    if (!this._devices[deviceType][deviceSlot]) {
      this._devices[deviceType][deviceSlot] = new DeviceSource(this._deviceInputSystem, deviceType, deviceSlot);
      this._updateFirstDevices(deviceType);
    }
  };
  DeviceSourceManager2.prototype._removeDevice = function(deviceType, deviceSlot) {
    delete this._devices[deviceType][deviceSlot];
    this._updateFirstDevices(deviceType);
  };
  DeviceSourceManager2.prototype._updateFirstDevices = function(type) {
    switch (type) {
      case DeviceType.Keyboard:
      case DeviceType.Mouse:
        this._firstDevice[type] = 0;
        break;
      case DeviceType.Touch:
      case DeviceType.DualShock:
      case DeviceType.Xbox:
      case DeviceType.Switch:
      case DeviceType.Generic:
        var devices = this._devices[type];
        delete this._firstDevice[type];
        for (var i = 0; i < devices.length; i++) {
          if (devices[i]) {
            this._firstDevice[type] = i;
            break;
          }
        }
        break;
    }
  };
  return DeviceSourceManager2;
}();

// node_modules/@babylonjs/core/Engines/nullEngine.js
var NullEngineOptions = function() {
  function NullEngineOptions2() {
    this.renderWidth = 512;
    this.renderHeight = 256;
    this.textureSize = 512;
    this.deterministicLockstep = false;
    this.lockstepMaxSteps = 4;
  }
  return NullEngineOptions2;
}();
var NullEngine = function(_super) {
  __extends(NullEngine2, _super);
  function NullEngine2(options) {
    if (options === void 0) {
      options = new NullEngineOptions();
    }
    var _this = _super.call(this, null) || this;
    Engine.Instances.push(_this);
    if (options.deterministicLockstep === void 0) {
      options.deterministicLockstep = false;
    }
    if (options.lockstepMaxSteps === void 0) {
      options.lockstepMaxSteps = 4;
    }
    _this._options = options;
    PerformanceConfigurator.SetMatrixPrecision(!!options.useHighPrecisionMatrix);
    _this._caps = {
      maxTexturesImageUnits: 16,
      maxVertexTextureImageUnits: 16,
      maxCombinedTexturesImageUnits: 32,
      maxTextureSize: 512,
      maxCubemapTextureSize: 512,
      maxRenderTextureSize: 512,
      maxVertexAttribs: 16,
      maxVaryingVectors: 16,
      maxFragmentUniformVectors: 16,
      maxVertexUniformVectors: 16,
      standardDerivatives: false,
      astc: null,
      pvrtc: null,
      etc1: null,
      etc2: null,
      bptc: null,
      maxAnisotropy: 0,
      uintIndices: false,
      fragmentDepthSupported: false,
      highPrecisionShaderSupported: true,
      colorBufferFloat: false,
      textureFloat: false,
      textureFloatLinearFiltering: false,
      textureFloatRender: false,
      textureHalfFloat: false,
      textureHalfFloatLinearFiltering: false,
      textureHalfFloatRender: false,
      textureLOD: false,
      drawBuffersExtension: false,
      depthTextureExtension: false,
      vertexArrayObject: false,
      instancedArrays: false,
      canUseTimestampForTimerQuery: false,
      maxMSAASamples: 1,
      blendMinMax: false
    };
    Logger.Log("Babylon.js v" + Engine.Version + " - Null engine");
    var theCurrentGlobal = typeof self !== "undefined" ? self : typeof global !== "undefined" ? global : window;
    if (typeof URL === "undefined") {
      theCurrentGlobal.URL = {
        createObjectURL: function() {
        },
        revokeObjectURL: function() {
        }
      };
    }
    if (typeof Blob === "undefined") {
      theCurrentGlobal.Blob = function() {
      };
    }
    return _this;
  }
  NullEngine2.prototype.isDeterministicLockStep = function() {
    return this._options.deterministicLockstep;
  };
  NullEngine2.prototype.getLockstepMaxSteps = function() {
    return this._options.lockstepMaxSteps;
  };
  NullEngine2.prototype.getHardwareScalingLevel = function() {
    return 1;
  };
  NullEngine2.prototype.createVertexBuffer = function(vertices) {
    var buffer = new DataBuffer();
    buffer.references = 1;
    return buffer;
  };
  NullEngine2.prototype.createIndexBuffer = function(indices) {
    var buffer = new DataBuffer();
    buffer.references = 1;
    return buffer;
  };
  NullEngine2.prototype.clear = function(color, backBuffer, depth, stencil) {
    if (stencil === void 0) {
      stencil = false;
    }
  };
  NullEngine2.prototype.getRenderWidth = function(useScreen) {
    if (useScreen === void 0) {
      useScreen = false;
    }
    if (!useScreen && this._currentRenderTarget) {
      return this._currentRenderTarget.width;
    }
    return this._options.renderWidth;
  };
  NullEngine2.prototype.getRenderHeight = function(useScreen) {
    if (useScreen === void 0) {
      useScreen = false;
    }
    if (!useScreen && this._currentRenderTarget) {
      return this._currentRenderTarget.height;
    }
    return this._options.renderHeight;
  };
  NullEngine2.prototype.setViewport = function(viewport, requiredWidth, requiredHeight) {
    this._cachedViewport = viewport;
  };
  NullEngine2.prototype.createShaderProgram = function(pipelineContext, vertexCode, fragmentCode, defines, context) {
    return {
      __SPECTOR_rebuildProgram: null
    };
  };
  NullEngine2.prototype.getUniforms = function(pipelineContext, uniformsNames) {
    return [];
  };
  NullEngine2.prototype.getAttributes = function(pipelineContext, attributesNames) {
    return [];
  };
  NullEngine2.prototype.bindSamplers = function(effect) {
    this._currentEffect = null;
  };
  NullEngine2.prototype.enableEffect = function(effect) {
    this._currentEffect = effect;
    if (effect.onBind) {
      effect.onBind(effect);
    }
    if (effect._onBindObservable) {
      effect._onBindObservable.notifyObservers(effect);
    }
  };
  NullEngine2.prototype.setState = function(culling, zOffset, force, reverseSide) {
    if (zOffset === void 0) {
      zOffset = 0;
    }
    if (reverseSide === void 0) {
      reverseSide = false;
    }
  };
  NullEngine2.prototype.setIntArray = function(uniform, array) {
    return true;
  };
  NullEngine2.prototype.setIntArray2 = function(uniform, array) {
    return true;
  };
  NullEngine2.prototype.setIntArray3 = function(uniform, array) {
    return true;
  };
  NullEngine2.prototype.setIntArray4 = function(uniform, array) {
    return true;
  };
  NullEngine2.prototype.setFloatArray = function(uniform, array) {
    return true;
  };
  NullEngine2.prototype.setFloatArray2 = function(uniform, array) {
    return true;
  };
  NullEngine2.prototype.setFloatArray3 = function(uniform, array) {
    return true;
  };
  NullEngine2.prototype.setFloatArray4 = function(uniform, array) {
    return true;
  };
  NullEngine2.prototype.setArray = function(uniform, array) {
    return true;
  };
  NullEngine2.prototype.setArray2 = function(uniform, array) {
    return true;
  };
  NullEngine2.prototype.setArray3 = function(uniform, array) {
    return true;
  };
  NullEngine2.prototype.setArray4 = function(uniform, array) {
    return true;
  };
  NullEngine2.prototype.setMatrices = function(uniform, matrices) {
    return true;
  };
  NullEngine2.prototype.setMatrix3x3 = function(uniform, matrix) {
    return true;
  };
  NullEngine2.prototype.setMatrix2x2 = function(uniform, matrix) {
    return true;
  };
  NullEngine2.prototype.setFloat = function(uniform, value) {
    return true;
  };
  NullEngine2.prototype.setFloat2 = function(uniform, x, y) {
    return true;
  };
  NullEngine2.prototype.setFloat3 = function(uniform, x, y, z) {
    return true;
  };
  NullEngine2.prototype.setBool = function(uniform, bool) {
    return true;
  };
  NullEngine2.prototype.setFloat4 = function(uniform, x, y, z, w) {
    return true;
  };
  NullEngine2.prototype.setAlphaMode = function(mode, noDepthWriteChange) {
    if (noDepthWriteChange === void 0) {
      noDepthWriteChange = false;
    }
    if (this._alphaMode === mode) {
      return;
    }
    this.alphaState.alphaBlend = mode !== 0;
    if (!noDepthWriteChange) {
      this.setDepthWrite(mode === 0);
    }
    this._alphaMode = mode;
  };
  NullEngine2.prototype.bindBuffers = function(vertexBuffers, indexBuffer, effect) {
  };
  NullEngine2.prototype.wipeCaches = function(bruteForce) {
    if (this.preventCacheWipeBetweenFrames) {
      return;
    }
    this.resetTextureCache();
    this._currentEffect = null;
    if (bruteForce) {
      this._currentProgram = null;
      this.stencilState.reset();
      this.depthCullingState.reset();
      this.alphaState.reset();
    }
    this._cachedVertexBuffers = null;
    this._cachedIndexBuffer = null;
    this._cachedEffectForVertexBuffers = null;
  };
  NullEngine2.prototype.draw = function(useTriangles, indexStart, indexCount, instancesCount) {
  };
  NullEngine2.prototype.drawElementsType = function(fillMode, indexStart, indexCount, instancesCount) {
  };
  NullEngine2.prototype.drawArraysType = function(fillMode, verticesStart, verticesCount, instancesCount) {
  };
  NullEngine2.prototype._createTexture = function() {
    return {};
  };
  NullEngine2.prototype._releaseTexture = function(texture) {
  };
  NullEngine2.prototype.createTexture = function(urlArg, noMipmap, invertY, scene, samplingMode, onLoad, onError, buffer, fallback, format, forcedExtension, mimeType) {
    if (samplingMode === void 0) {
      samplingMode = 3;
    }
    if (onLoad === void 0) {
      onLoad = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (buffer === void 0) {
      buffer = null;
    }
    if (fallback === void 0) {
      fallback = null;
    }
    if (format === void 0) {
      format = null;
    }
    if (forcedExtension === void 0) {
      forcedExtension = null;
    }
    var texture = new InternalTexture(this, InternalTextureSource.Url);
    var url = String(urlArg);
    texture.url = url;
    texture.generateMipMaps = !noMipmap;
    texture.samplingMode = samplingMode;
    texture.invertY = invertY;
    texture.baseWidth = this._options.textureSize;
    texture.baseHeight = this._options.textureSize;
    texture.width = this._options.textureSize;
    texture.height = this._options.textureSize;
    if (format) {
      texture.format = format;
    }
    texture.isReady = true;
    if (onLoad) {
      onLoad();
    }
    this._internalTexturesCache.push(texture);
    return texture;
  };
  NullEngine2.prototype.createRenderTargetTexture = function(size, options) {
    var fullOptions = new RenderTargetCreationOptions();
    if (options !== void 0 && typeof options === "object") {
      fullOptions.generateMipMaps = options.generateMipMaps;
      fullOptions.generateDepthBuffer = options.generateDepthBuffer === void 0 ? true : options.generateDepthBuffer;
      fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && options.generateStencilBuffer;
      fullOptions.type = options.type === void 0 ? 0 : options.type;
      fullOptions.samplingMode = options.samplingMode === void 0 ? 3 : options.samplingMode;
    } else {
      fullOptions.generateMipMaps = options;
      fullOptions.generateDepthBuffer = true;
      fullOptions.generateStencilBuffer = false;
      fullOptions.type = 0;
      fullOptions.samplingMode = 3;
    }
    var texture = new InternalTexture(this, InternalTextureSource.RenderTarget);
    var width = size.width || size;
    var height = size.height || size;
    texture._depthStencilBuffer = {};
    texture._framebuffer = {};
    texture.baseWidth = width;
    texture.baseHeight = height;
    texture.width = width;
    texture.height = height;
    texture.isReady = true;
    texture.samples = 1;
    texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;
    texture.samplingMode = fullOptions.samplingMode;
    texture.type = fullOptions.type;
    texture._generateDepthBuffer = fullOptions.generateDepthBuffer;
    texture._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;
    this._internalTexturesCache.push(texture);
    return texture;
  };
  NullEngine2.prototype.updateTextureSamplingMode = function(samplingMode, texture) {
    texture.samplingMode = samplingMode;
  };
  NullEngine2.prototype.bindFramebuffer = function(texture, faceIndex, requiredWidth, requiredHeight, forceFullscreenViewport) {
    if (this._currentRenderTarget) {
      this.unBindFramebuffer(this._currentRenderTarget);
    }
    this._currentRenderTarget = texture;
    this._currentFramebuffer = texture._MSAAFramebuffer ? texture._MSAAFramebuffer : texture._framebuffer;
    if (this._cachedViewport && !forceFullscreenViewport) {
      this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);
    }
  };
  NullEngine2.prototype.unBindFramebuffer = function(texture, disableGenerateMipMaps, onBeforeUnbind) {
    if (disableGenerateMipMaps === void 0) {
      disableGenerateMipMaps = false;
    }
    this._currentRenderTarget = null;
    if (onBeforeUnbind) {
      if (texture._MSAAFramebuffer) {
        this._currentFramebuffer = texture._framebuffer;
      }
      onBeforeUnbind();
    }
    this._currentFramebuffer = null;
  };
  NullEngine2.prototype.createDynamicVertexBuffer = function(vertices) {
    var buffer = new DataBuffer();
    buffer.references = 1;
    buffer.capacity = 1;
    return buffer;
  };
  NullEngine2.prototype.updateDynamicTexture = function(texture, canvas, invertY, premulAlpha, format) {
    if (premulAlpha === void 0) {
      premulAlpha = false;
    }
  };
  NullEngine2.prototype.areAllEffectsReady = function() {
    return true;
  };
  NullEngine2.prototype.getError = function() {
    return 0;
  };
  NullEngine2.prototype._getUnpackAlignement = function() {
    return 1;
  };
  NullEngine2.prototype._unpackFlipY = function(value) {
  };
  NullEngine2.prototype.updateDynamicIndexBuffer = function(indexBuffer, indices, offset) {
    if (offset === void 0) {
      offset = 0;
    }
  };
  NullEngine2.prototype.updateDynamicVertexBuffer = function(vertexBuffer, vertices, byteOffset, byteLength) {
  };
  NullEngine2.prototype._bindTextureDirectly = function(target, texture) {
    if (this._boundTexturesCache[this._activeChannel] !== texture) {
      this._boundTexturesCache[this._activeChannel] = texture;
      return true;
    }
    return false;
  };
  NullEngine2.prototype._bindTexture = function(channel, texture) {
    if (channel < 0) {
      return;
    }
    this._bindTextureDirectly(0, texture);
  };
  NullEngine2.prototype._deleteBuffer = function(buffer) {
  };
  NullEngine2.prototype.releaseEffects = function() {
  };
  NullEngine2.prototype.displayLoadingUI = function() {
  };
  NullEngine2.prototype.hideLoadingUI = function() {
  };
  NullEngine2.prototype._uploadCompressedDataToTextureDirectly = function(texture, internalFormat, width, height, data, faceIndex, lod) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lod === void 0) {
      lod = 0;
    }
  };
  NullEngine2.prototype._uploadDataToTextureDirectly = function(texture, imageData, faceIndex, lod) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lod === void 0) {
      lod = 0;
    }
  };
  NullEngine2.prototype._uploadArrayBufferViewToTexture = function(texture, imageData, faceIndex, lod) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lod === void 0) {
      lod = 0;
    }
  };
  NullEngine2.prototype._uploadImageToTexture = function(texture, image, faceIndex, lod) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lod === void 0) {
      lod = 0;
    }
  };
  return NullEngine2;
}(Engine);

// node_modules/@babylonjs/core/Instrumentation/timeToken.js
var _TimeToken = function() {
  function _TimeToken2() {
    this._timeElapsedQueryEnded = false;
  }
  return _TimeToken2;
}();

// node_modules/@babylonjs/core/Engines/Extensions/engine.occlusionQuery.js
var _OcclusionDataStorage = function() {
  function _OcclusionDataStorage2() {
    this.occlusionInternalRetryCounter = 0;
    this.isOcclusionQueryInProgress = false;
    this.isOccluded = false;
    this.occlusionRetryCount = -1;
    this.occlusionType = AbstractMesh.OCCLUSION_TYPE_NONE;
    this.occlusionQueryAlgorithmType = AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE;
  }
  return _OcclusionDataStorage2;
}();
Engine.prototype.createQuery = function() {
  return this._gl.createQuery();
};
Engine.prototype.deleteQuery = function(query) {
  this._gl.deleteQuery(query);
  return this;
};
Engine.prototype.isQueryResultAvailable = function(query) {
  return this._gl.getQueryParameter(query, this._gl.QUERY_RESULT_AVAILABLE);
};
Engine.prototype.getQueryResult = function(query) {
  return this._gl.getQueryParameter(query, this._gl.QUERY_RESULT);
};
Engine.prototype.beginOcclusionQuery = function(algorithmType, query) {
  var glAlgorithm = this._getGlAlgorithmType(algorithmType);
  this._gl.beginQuery(glAlgorithm, query);
  return this;
};
Engine.prototype.endOcclusionQuery = function(algorithmType) {
  var glAlgorithm = this._getGlAlgorithmType(algorithmType);
  this._gl.endQuery(glAlgorithm);
  return this;
};
Engine.prototype._createTimeQuery = function() {
  var timerQuery = this.getCaps().timerQuery;
  if (timerQuery.createQueryEXT) {
    return timerQuery.createQueryEXT();
  }
  return this.createQuery();
};
Engine.prototype._deleteTimeQuery = function(query) {
  var timerQuery = this.getCaps().timerQuery;
  if (timerQuery.deleteQueryEXT) {
    timerQuery.deleteQueryEXT(query);
    return;
  }
  this.deleteQuery(query);
};
Engine.prototype._getTimeQueryResult = function(query) {
  var timerQuery = this.getCaps().timerQuery;
  if (timerQuery.getQueryObjectEXT) {
    return timerQuery.getQueryObjectEXT(query, timerQuery.QUERY_RESULT_EXT);
  }
  return this.getQueryResult(query);
};
Engine.prototype._getTimeQueryAvailability = function(query) {
  var timerQuery = this.getCaps().timerQuery;
  if (timerQuery.getQueryObjectEXT) {
    return timerQuery.getQueryObjectEXT(query, timerQuery.QUERY_RESULT_AVAILABLE_EXT);
  }
  return this.isQueryResultAvailable(query);
};
Engine.prototype.startTimeQuery = function() {
  var caps = this.getCaps();
  var timerQuery = caps.timerQuery;
  if (!timerQuery) {
    return null;
  }
  var token = new _TimeToken();
  this._gl.getParameter(timerQuery.GPU_DISJOINT_EXT);
  if (caps.canUseTimestampForTimerQuery) {
    token._startTimeQuery = this._createTimeQuery();
    timerQuery.queryCounterEXT(token._startTimeQuery, timerQuery.TIMESTAMP_EXT);
  } else {
    if (this._currentNonTimestampToken) {
      return this._currentNonTimestampToken;
    }
    token._timeElapsedQuery = this._createTimeQuery();
    if (timerQuery.beginQueryEXT) {
      timerQuery.beginQueryEXT(timerQuery.TIME_ELAPSED_EXT, token._timeElapsedQuery);
    } else {
      this._gl.beginQuery(timerQuery.TIME_ELAPSED_EXT, token._timeElapsedQuery);
    }
    this._currentNonTimestampToken = token;
  }
  return token;
};
Engine.prototype.endTimeQuery = function(token) {
  var caps = this.getCaps();
  var timerQuery = caps.timerQuery;
  if (!timerQuery || !token) {
    return -1;
  }
  if (caps.canUseTimestampForTimerQuery) {
    if (!token._startTimeQuery) {
      return -1;
    }
    if (!token._endTimeQuery) {
      token._endTimeQuery = this._createTimeQuery();
      timerQuery.queryCounterEXT(token._endTimeQuery, timerQuery.TIMESTAMP_EXT);
    }
  } else if (!token._timeElapsedQueryEnded) {
    if (!token._timeElapsedQuery) {
      return -1;
    }
    if (timerQuery.endQueryEXT) {
      timerQuery.endQueryEXT(timerQuery.TIME_ELAPSED_EXT);
    } else {
      this._gl.endQuery(timerQuery.TIME_ELAPSED_EXT);
    }
    token._timeElapsedQueryEnded = true;
  }
  var disjoint = this._gl.getParameter(timerQuery.GPU_DISJOINT_EXT);
  var available = false;
  if (token._endTimeQuery) {
    available = this._getTimeQueryAvailability(token._endTimeQuery);
  } else if (token._timeElapsedQuery) {
    available = this._getTimeQueryAvailability(token._timeElapsedQuery);
  }
  if (available && !disjoint) {
    var result = 0;
    if (caps.canUseTimestampForTimerQuery) {
      if (!token._startTimeQuery || !token._endTimeQuery) {
        return -1;
      }
      var timeStart = this._getTimeQueryResult(token._startTimeQuery);
      var timeEnd = this._getTimeQueryResult(token._endTimeQuery);
      result = timeEnd - timeStart;
      this._deleteTimeQuery(token._startTimeQuery);
      this._deleteTimeQuery(token._endTimeQuery);
      token._startTimeQuery = null;
      token._endTimeQuery = null;
    } else {
      if (!token._timeElapsedQuery) {
        return -1;
      }
      result = this._getTimeQueryResult(token._timeElapsedQuery);
      this._deleteTimeQuery(token._timeElapsedQuery);
      token._timeElapsedQuery = null;
      token._timeElapsedQueryEnded = false;
      this._currentNonTimestampToken = null;
    }
    return result;
  }
  return -1;
};
Engine.prototype._getGlAlgorithmType = function(algorithmType) {
  return algorithmType === AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE ? this._gl.ANY_SAMPLES_PASSED_CONSERVATIVE : this._gl.ANY_SAMPLES_PASSED;
};
Object.defineProperty(AbstractMesh.prototype, "isOcclusionQueryInProgress", {
  get: function() {
    return this._occlusionDataStorage.isOcclusionQueryInProgress;
  },
  set: function(value) {
    this._occlusionDataStorage.isOcclusionQueryInProgress = value;
  },
  enumerable: false,
  configurable: true
});
Object.defineProperty(AbstractMesh.prototype, "_occlusionDataStorage", {
  get: function() {
    if (!this.__occlusionDataStorage) {
      this.__occlusionDataStorage = new _OcclusionDataStorage();
    }
    return this.__occlusionDataStorage;
  },
  enumerable: false,
  configurable: true
});
Object.defineProperty(AbstractMesh.prototype, "isOccluded", {
  get: function() {
    return this._occlusionDataStorage.isOccluded;
  },
  set: function(value) {
    this._occlusionDataStorage.isOccluded = value;
  },
  enumerable: true,
  configurable: true
});
Object.defineProperty(AbstractMesh.prototype, "occlusionQueryAlgorithmType", {
  get: function() {
    return this._occlusionDataStorage.occlusionQueryAlgorithmType;
  },
  set: function(value) {
    this._occlusionDataStorage.occlusionQueryAlgorithmType = value;
  },
  enumerable: true,
  configurable: true
});
Object.defineProperty(AbstractMesh.prototype, "occlusionType", {
  get: function() {
    return this._occlusionDataStorage.occlusionType;
  },
  set: function(value) {
    this._occlusionDataStorage.occlusionType = value;
  },
  enumerable: true,
  configurable: true
});
Object.defineProperty(AbstractMesh.prototype, "occlusionRetryCount", {
  get: function() {
    return this._occlusionDataStorage.occlusionRetryCount;
  },
  set: function(value) {
    this._occlusionDataStorage.occlusionRetryCount = value;
  },
  enumerable: true,
  configurable: true
});
AbstractMesh.prototype._checkOcclusionQuery = function() {
  var dataStorage = this._occlusionDataStorage;
  if (dataStorage.occlusionType === AbstractMesh.OCCLUSION_TYPE_NONE) {
    dataStorage.isOccluded = false;
    return false;
  }
  var engine = this.getEngine();
  if (engine.webGLVersion < 2) {
    dataStorage.isOccluded = false;
    return false;
  }
  if (!engine.isQueryResultAvailable) {
    dataStorage.isOccluded = false;
    return false;
  }
  if (this.isOcclusionQueryInProgress && this._occlusionQuery) {
    var isOcclusionQueryAvailable = engine.isQueryResultAvailable(this._occlusionQuery);
    if (isOcclusionQueryAvailable) {
      var occlusionQueryResult = engine.getQueryResult(this._occlusionQuery);
      dataStorage.isOcclusionQueryInProgress = false;
      dataStorage.occlusionInternalRetryCounter = 0;
      dataStorage.isOccluded = occlusionQueryResult === 1 ? false : true;
    } else {
      dataStorage.occlusionInternalRetryCounter++;
      if (dataStorage.occlusionRetryCount !== -1 && dataStorage.occlusionInternalRetryCounter > dataStorage.occlusionRetryCount) {
        dataStorage.isOcclusionQueryInProgress = false;
        dataStorage.occlusionInternalRetryCounter = 0;
        dataStorage.isOccluded = dataStorage.occlusionType === AbstractMesh.OCCLUSION_TYPE_OPTIMISTIC ? false : dataStorage.isOccluded;
      } else {
        return false;
      }
    }
  }
  var scene = this.getScene();
  if (scene.getBoundingBoxRenderer) {
    var occlusionBoundingBoxRenderer = scene.getBoundingBoxRenderer();
    if (!this._occlusionQuery) {
      this._occlusionQuery = engine.createQuery();
    }
    engine.beginOcclusionQuery(dataStorage.occlusionQueryAlgorithmType, this._occlusionQuery);
    occlusionBoundingBoxRenderer.renderOcclusionBoundingBox(this);
    engine.endOcclusionQuery(dataStorage.occlusionQueryAlgorithmType);
    this._occlusionDataStorage.isOcclusionQueryInProgress = true;
  }
  return dataStorage.isOccluded;
};

// node_modules/@babylonjs/core/Engines/Extensions/engine.transformFeedback.js
var _forceTransformFeedbackToBundle = true;
Engine.prototype.createTransformFeedback = function() {
  return this._gl.createTransformFeedback();
};
Engine.prototype.deleteTransformFeedback = function(value) {
  this._gl.deleteTransformFeedback(value);
};
Engine.prototype.bindTransformFeedback = function(value) {
  this._gl.bindTransformFeedback(this._gl.TRANSFORM_FEEDBACK, value);
};
Engine.prototype.beginTransformFeedback = function(usePoints) {
  if (usePoints === void 0) {
    usePoints = true;
  }
  this._gl.beginTransformFeedback(usePoints ? this._gl.POINTS : this._gl.TRIANGLES);
};
Engine.prototype.endTransformFeedback = function() {
  this._gl.endTransformFeedback();
};
Engine.prototype.setTranformFeedbackVaryings = function(program, value) {
  this._gl.transformFeedbackVaryings(program, value, this._gl.INTERLEAVED_ATTRIBS);
};
Engine.prototype.bindTransformFeedbackBuffer = function(value) {
  this._gl.bindBufferBase(this._gl.TRANSFORM_FEEDBACK_BUFFER, 0, value ? value.underlyingResource : null);
};

// node_modules/@babylonjs/core/Engines/Extensions/engine.videoTexture.js
ThinEngine.prototype.updateVideoTexture = function(texture, video, invertY) {
  if (!texture || texture._isDisabled) {
    return;
  }
  var wasPreviouslyBound = this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
  this._unpackFlipY(!invertY);
  try {
    if (this._videoTextureSupported === void 0) {
      this._gl.getError();
      this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, video);
      if (this._gl.getError() !== 0) {
        this._videoTextureSupported = false;
      } else {
        this._videoTextureSupported = true;
      }
    }
    if (!this._videoTextureSupported) {
      if (!texture._workingCanvas) {
        texture._workingCanvas = CanvasGenerator.CreateCanvas(texture.width, texture.height);
        var context = texture._workingCanvas.getContext("2d");
        if (!context) {
          throw new Error("Unable to get 2d context");
        }
        texture._workingContext = context;
        texture._workingCanvas.width = texture.width;
        texture._workingCanvas.height = texture.height;
      }
      texture._workingContext.clearRect(0, 0, texture.width, texture.height);
      texture._workingContext.drawImage(video, 0, 0, video.videoWidth, video.videoHeight, 0, 0, texture.width, texture.height);
      this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, texture._workingCanvas);
    } else {
      this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, video);
    }
    if (texture.generateMipMaps) {
      this._gl.generateMipmap(this._gl.TEXTURE_2D);
    }
    if (!wasPreviouslyBound) {
      this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
    }
    texture.isReady = true;
  } catch (ex) {
    texture._isDisabled = true;
  }
};

// node_modules/@babylonjs/core/Engines/Extensions/engine.multiRender.js
ThinEngine.prototype.restoreSingleAttachment = function() {
  var gl = this._gl;
  this.bindAttachments([gl.BACK]);
};
ThinEngine.prototype.buildTextureLayout = function(textureStatus) {
  var gl = this._gl;
  var result = [];
  for (var i = 0; i < textureStatus.length; i++) {
    if (textureStatus[i]) {
      result.push(gl["COLOR_ATTACHMENT" + i]);
    } else {
      result.push(gl.NONE);
    }
  }
  return result;
};
ThinEngine.prototype.bindAttachments = function(attachments) {
  var gl = this._gl;
  gl.drawBuffers(attachments);
};
ThinEngine.prototype.unBindMultiColorAttachmentFramebuffer = function(textures, disableGenerateMipMaps, onBeforeUnbind) {
  if (disableGenerateMipMaps === void 0) {
    disableGenerateMipMaps = false;
  }
  this._currentRenderTarget = null;
  var gl = this._gl;
  var attachments = textures[0]._attachments;
  var count = attachments.length;
  if (textures[0]._MSAAFramebuffer) {
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, textures[0]._MSAAFramebuffer);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, textures[0]._framebuffer);
    for (var i = 0; i < count; i++) {
      var texture = textures[i];
      for (var j = 0; j < count; j++) {
        attachments[j] = gl.NONE;
      }
      attachments[i] = gl[this.webGLVersion > 1 ? "COLOR_ATTACHMENT" + i : "COLOR_ATTACHMENT" + i + "_WEBGL"];
      gl.readBuffer(attachments[i]);
      gl.drawBuffers(attachments);
      gl.blitFramebuffer(0, 0, texture.width, texture.height, 0, 0, texture.width, texture.height, gl.COLOR_BUFFER_BIT, gl.NEAREST);
    }
    for (var i = 0; i < count; i++) {
      attachments[i] = gl[this.webGLVersion > 1 ? "COLOR_ATTACHMENT" + i : "COLOR_ATTACHMENT" + i + "_WEBGL"];
    }
    gl.drawBuffers(attachments);
  }
  for (var i = 0; i < count; i++) {
    var texture = textures[i];
    if (texture.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {
      this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);
      gl.generateMipmap(gl.TEXTURE_2D);
      this._bindTextureDirectly(gl.TEXTURE_2D, null);
    }
  }
  if (onBeforeUnbind) {
    if (textures[0]._MSAAFramebuffer) {
      this._bindUnboundFramebuffer(textures[0]._framebuffer);
    }
    onBeforeUnbind();
  }
  this._bindUnboundFramebuffer(null);
};
ThinEngine.prototype.createMultipleRenderTarget = function(size, options) {
  var generateMipMaps = false;
  var generateDepthBuffer = true;
  var generateStencilBuffer = false;
  var generateDepthTexture = false;
  var textureCount = 1;
  var defaultType = 0;
  var defaultSamplingMode = 3;
  var types = new Array();
  var samplingModes = new Array();
  if (options !== void 0) {
    generateMipMaps = options.generateMipMaps === void 0 ? false : options.generateMipMaps;
    generateDepthBuffer = options.generateDepthBuffer === void 0 ? true : options.generateDepthBuffer;
    generateStencilBuffer = options.generateStencilBuffer === void 0 ? false : options.generateStencilBuffer;
    generateDepthTexture = options.generateDepthTexture === void 0 ? false : options.generateDepthTexture;
    textureCount = options.textureCount || 1;
    if (options.types) {
      types = options.types;
    }
    if (options.samplingModes) {
      samplingModes = options.samplingModes;
    }
  }
  var gl = this._gl;
  var framebuffer = gl.createFramebuffer();
  this._bindUnboundFramebuffer(framebuffer);
  var width = size.width || size;
  var height = size.height || size;
  var textures = [];
  var attachments = [];
  var depthStencilBuffer = this._setupFramebufferDepthAttachments(generateStencilBuffer, generateDepthBuffer, width, height);
  for (var i = 0; i < textureCount; i++) {
    var samplingMode = samplingModes[i] || defaultSamplingMode;
    var type = types[i] || defaultType;
    if (type === 1 && !this._caps.textureFloatLinearFiltering) {
      samplingMode = 1;
    } else if (type === 2 && !this._caps.textureHalfFloatLinearFiltering) {
      samplingMode = 1;
    }
    var filters = this._getSamplingParameters(samplingMode, generateMipMaps);
    if (type === 1 && !this._caps.textureFloat) {
      type = 0;
      Logger.Warn("Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type");
    }
    var texture = new InternalTexture(this, InternalTextureSource.MultiRenderTarget);
    var attachment = gl[this.webGLVersion > 1 ? "COLOR_ATTACHMENT" + i : "COLOR_ATTACHMENT" + i + "_WEBGL"];
    textures.push(texture);
    attachments.push(attachment);
    gl.activeTexture(gl["TEXTURE" + i]);
    gl.bindTexture(gl.TEXTURE_2D, texture._webGLTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filters.mag);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filters.min);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, this._getRGBABufferInternalSizedFormat(type), width, height, 0, gl.RGBA, this._getWebGLTextureType(type), null);
    gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, attachment, gl.TEXTURE_2D, texture._webGLTexture, 0);
    if (generateMipMaps) {
      this._gl.generateMipmap(this._gl.TEXTURE_2D);
    }
    this._bindTextureDirectly(gl.TEXTURE_2D, null);
    texture._framebuffer = framebuffer;
    texture._depthStencilBuffer = depthStencilBuffer;
    texture.baseWidth = width;
    texture.baseHeight = height;
    texture.width = width;
    texture.height = height;
    texture.isReady = true;
    texture.samples = 1;
    texture.generateMipMaps = generateMipMaps;
    texture.samplingMode = samplingMode;
    texture.type = type;
    texture._generateDepthBuffer = generateDepthBuffer;
    texture._generateStencilBuffer = generateStencilBuffer;
    texture._attachments = attachments;
    texture._textureArray = textures;
    this._internalTexturesCache.push(texture);
  }
  if (generateDepthTexture && this._caps.depthTextureExtension) {
    var depthTexture = new InternalTexture(this, InternalTextureSource.MultiRenderTarget);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, depthTexture._webGLTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, this.webGLVersion < 2 ? gl.DEPTH_COMPONENT : gl.DEPTH_COMPONENT16, width, height, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_SHORT, null);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._webGLTexture, 0);
    depthTexture._framebuffer = framebuffer;
    depthTexture.baseWidth = width;
    depthTexture.baseHeight = height;
    depthTexture.width = width;
    depthTexture.height = height;
    depthTexture.isReady = true;
    depthTexture.samples = 1;
    depthTexture.generateMipMaps = generateMipMaps;
    depthTexture.samplingMode = gl.NEAREST;
    depthTexture._generateDepthBuffer = generateDepthBuffer;
    depthTexture._generateStencilBuffer = generateStencilBuffer;
    textures.push(depthTexture);
    this._internalTexturesCache.push(depthTexture);
  }
  gl.drawBuffers(attachments);
  this._bindUnboundFramebuffer(null);
  this.resetTextureCache();
  return textures;
};
ThinEngine.prototype.updateMultipleRenderTargetTextureSampleCount = function(textures, samples) {
  if (this.webGLVersion < 2 || !textures) {
    return 1;
  }
  if (textures[0].samples === samples) {
    return samples;
  }
  var count = textures[0]._attachments.length;
  if (count === 0) {
    return 1;
  }
  var gl = this._gl;
  samples = Math.min(samples, this.getCaps().maxMSAASamples);
  if (textures[0]._depthStencilBuffer) {
    gl.deleteRenderbuffer(textures[0]._depthStencilBuffer);
    textures[0]._depthStencilBuffer = null;
  }
  if (textures[0]._MSAAFramebuffer) {
    gl.deleteFramebuffer(textures[0]._MSAAFramebuffer);
    textures[0]._MSAAFramebuffer = null;
  }
  for (var i = 0; i < count; i++) {
    if (textures[i]._MSAARenderBuffer) {
      gl.deleteRenderbuffer(textures[i]._MSAARenderBuffer);
      textures[i]._MSAARenderBuffer = null;
    }
  }
  if (samples > 1 && gl.renderbufferStorageMultisample) {
    var framebuffer = gl.createFramebuffer();
    if (!framebuffer) {
      throw new Error("Unable to create multi sampled framebuffer");
    }
    this._bindUnboundFramebuffer(framebuffer);
    var depthStencilBuffer = this._setupFramebufferDepthAttachments(textures[0]._generateStencilBuffer, textures[0]._generateDepthBuffer, textures[0].width, textures[0].height, samples);
    var attachments = [];
    for (var i = 0; i < count; i++) {
      var texture = textures[i];
      var attachment = gl[this.webGLVersion > 1 ? "COLOR_ATTACHMENT" + i : "COLOR_ATTACHMENT" + i + "_WEBGL"];
      var colorRenderbuffer = gl.createRenderbuffer();
      if (!colorRenderbuffer) {
        throw new Error("Unable to create multi sampled framebuffer");
      }
      gl.bindRenderbuffer(gl.RENDERBUFFER, colorRenderbuffer);
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, this._getRGBAMultiSampleBufferFormat(texture.type), texture.width, texture.height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, colorRenderbuffer);
      texture._MSAAFramebuffer = framebuffer;
      texture._MSAARenderBuffer = colorRenderbuffer;
      texture.samples = samples;
      texture._depthStencilBuffer = depthStencilBuffer;
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      attachments.push(attachment);
    }
    gl.drawBuffers(attachments);
  } else {
    this._bindUnboundFramebuffer(textures[0]._framebuffer);
  }
  this._bindUnboundFramebuffer(null);
  return samples;
};

// node_modules/@babylonjs/core/Engines/Extensions/engine.views.js
var EngineView = function() {
  function EngineView2() {
  }
  return EngineView2;
}();
Engine.prototype.getInputElement = function() {
  return this.inputElement || this.getRenderingCanvas();
};
Engine.prototype.registerView = function(canvas, camera) {
  var _this = this;
  if (!this.views) {
    this.views = [];
  }
  for (var _i = 0, _a = this.views; _i < _a.length; _i++) {
    var view = _a[_i];
    if (view.target === canvas) {
      return view;
    }
  }
  var masterCanvas = this.getRenderingCanvas();
  if (masterCanvas) {
    canvas.width = masterCanvas.width;
    canvas.height = masterCanvas.height;
  }
  var newView = { target: canvas, camera };
  this.views.push(newView);
  if (camera) {
    camera.onDisposeObservable.add(function() {
      _this.unRegisterView(canvas);
    });
  }
  return newView;
};
Engine.prototype.unRegisterView = function(canvas) {
  if (!this.views) {
    return this;
  }
  for (var _i = 0, _a = this.views; _i < _a.length; _i++) {
    var view = _a[_i];
    if (view.target === canvas) {
      var index = this.views.indexOf(view);
      if (index !== -1) {
        this.views.splice(index, 1);
      }
      break;
    }
  }
  return this;
};
Engine.prototype._renderViews = function() {
  if (!this.views) {
    return false;
  }
  var parent = this.getRenderingCanvas();
  if (!parent) {
    return false;
  }
  for (var _i = 0, _a = this.views; _i < _a.length; _i++) {
    var view = _a[_i];
    var canvas = view.target;
    var context = canvas.getContext("2d");
    if (!context) {
      continue;
    }
    var camera = view.camera;
    var previewCamera = null;
    var scene = null;
    if (camera) {
      scene = camera.getScene();
      if (scene.activeCameras && scene.activeCameras.length) {
        continue;
      }
      this.activeView = view;
      previewCamera = scene.activeCamera;
      scene.activeCamera = camera;
    }
    var dimsChanged = canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight;
    if (canvas.clientWidth && canvas.clientHeight && dimsChanged) {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
      parent.width = canvas.clientWidth;
      parent.height = canvas.clientHeight;
      this.resize();
    }
    if (!parent.width || !parent.height) {
      return false;
    }
    this._renderFrame();
    context.drawImage(parent, 0, 0);
    if (previewCamera && scene) {
      scene.activeCamera = previewCamera;
    }
  }
  this.activeView = null;
  return true;
};

// node_modules/@babylonjs/core/Engines/Extensions/engine.textureSelector.js
function transformTextureUrl(url) {
  var excludeFn = function(entry) {
    var strRegExPattern = "\\b" + entry + "\\b";
    return url && (url === entry || url.match(new RegExp(strRegExPattern, "g")));
  };
  if (this._excludedCompressedTextures && this._excludedCompressedTextures.some(excludeFn)) {
    return url;
  }
  var lastDot = url.lastIndexOf(".");
  var lastQuestionMark = url.lastIndexOf("?");
  var querystring = lastQuestionMark > -1 ? url.substring(lastQuestionMark, url.length) : "";
  return (lastDot > -1 ? url.substring(0, lastDot) : url) + this._textureFormatInUse + querystring;
}
Object.defineProperty(Engine.prototype, "texturesSupported", {
  get: function() {
    var texturesSupported = new Array();
    if (this._caps.astc) {
      texturesSupported.push("-astc.ktx");
    }
    if (this._caps.s3tc) {
      texturesSupported.push("-dxt.ktx");
    }
    if (this._caps.pvrtc) {
      texturesSupported.push("-pvrtc.ktx");
    }
    if (this._caps.etc2) {
      texturesSupported.push("-etc2.ktx");
    }
    if (this._caps.etc1) {
      texturesSupported.push("-etc1.ktx");
    }
    return texturesSupported;
  },
  enumerable: true,
  configurable: true
});
Object.defineProperty(Engine.prototype, "textureFormatInUse", {
  get: function() {
    return this._textureFormatInUse || null;
  },
  enumerable: true,
  configurable: true
});
Engine.prototype.setCompressedTextureExclusions = function(skippedFiles) {
  this._excludedCompressedTextures = skippedFiles;
};
Engine.prototype.setTextureFormatToUse = function(formatsAvailable) {
  var texturesSupported = this.texturesSupported;
  for (var i = 0, len1 = texturesSupported.length; i < len1; i++) {
    for (var j = 0, len2 = formatsAvailable.length; j < len2; j++) {
      if (texturesSupported[i] === formatsAvailable[j].toLowerCase()) {
        this._transformTextureUrl = transformTextureUrl.bind(this);
        return this._textureFormatInUse = texturesSupported[i];
      }
    }
  }
  this._textureFormatInUse = "";
  this._transformTextureUrl = null;
  return null;
};

// node_modules/@babylonjs/core/Engines/Processors/shaderCodeInliner.js
var ShaderCodeInliner = function() {
  function ShaderCodeInliner2(sourceCode, numMaxIterations) {
    if (numMaxIterations === void 0) {
      numMaxIterations = 20;
    }
    this.debug = false;
    this._sourceCode = sourceCode;
    this._numMaxIterations = numMaxIterations;
    this._functionDescr = [];
    this.inlineToken = "#define inline";
  }
  Object.defineProperty(ShaderCodeInliner2.prototype, "code", {
    get: function() {
      return this._sourceCode;
    },
    enumerable: false,
    configurable: true
  });
  ShaderCodeInliner2.prototype.processCode = function() {
    if (this.debug) {
      console.log("Start inlining process (code size=" + this._sourceCode.length + ")...");
    }
    this._collectFunctions();
    this._processInlining(this._numMaxIterations);
    if (this.debug) {
      console.log("End of inlining process.");
    }
  };
  ShaderCodeInliner2.prototype._collectFunctions = function() {
    var startIndex = 0;
    while (startIndex < this._sourceCode.length) {
      var inlineTokenIndex = this._sourceCode.indexOf(this.inlineToken, startIndex);
      if (inlineTokenIndex < 0) {
        break;
      }
      var funcParamsStartIndex = this._sourceCode.indexOf("(", inlineTokenIndex + this.inlineToken.length);
      if (funcParamsStartIndex < 0) {
        if (this.debug) {
          console.warn("Could not find the opening parenthesis after the token. startIndex=" + startIndex);
        }
        startIndex = inlineTokenIndex + this.inlineToken.length;
        continue;
      }
      var funcNameMatch = ShaderCodeInliner2._RegexpFindFunctionNameAndType.exec(this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex));
      if (!funcNameMatch) {
        if (this.debug) {
          console.warn("Could not extract the name/type of the function from: " + this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex));
        }
        startIndex = inlineTokenIndex + this.inlineToken.length;
        continue;
      }
      var _a = [funcNameMatch[3], funcNameMatch[4]], funcType = _a[0], funcName = _a[1];
      var funcParamsEndIndex = this._extractBetweenMarkers("(", ")", this._sourceCode, funcParamsStartIndex);
      if (funcParamsEndIndex < 0) {
        if (this.debug) {
          console.warn("Could not extract the parameters the function '" + funcName + "' (type=" + funcType + "). funcParamsStartIndex=" + funcParamsStartIndex);
        }
        startIndex = inlineTokenIndex + this.inlineToken.length;
        continue;
      }
      var funcParams = this._sourceCode.substring(funcParamsStartIndex + 1, funcParamsEndIndex);
      var funcBodyStartIndex = this._skipWhitespaces(this._sourceCode, funcParamsEndIndex + 1);
      if (funcBodyStartIndex === this._sourceCode.length) {
        if (this.debug) {
          console.warn("Could not extract the body of the function '" + funcName + "' (type=" + funcType + "). funcParamsEndIndex=" + funcParamsEndIndex);
        }
        startIndex = inlineTokenIndex + this.inlineToken.length;
        continue;
      }
      var funcBodyEndIndex = this._extractBetweenMarkers("{", "}", this._sourceCode, funcBodyStartIndex);
      if (funcBodyEndIndex < 0) {
        if (this.debug) {
          console.warn("Could not extract the body of the function '" + funcName + "' (type=" + funcType + "). funcBodyStartIndex=" + funcBodyStartIndex);
        }
        startIndex = inlineTokenIndex + this.inlineToken.length;
        continue;
      }
      var funcBody = this._sourceCode.substring(funcBodyStartIndex, funcBodyEndIndex + 1);
      var params = this._removeComments(funcParams).split(",");
      var paramNames = [];
      for (var p = 0; p < params.length; ++p) {
        var param = params[p].trim();
        var idx = param.lastIndexOf(" ");
        if (idx >= 0) {
          paramNames.push(param.substring(idx + 1));
        }
      }
      if (funcType !== "void") {
        paramNames.push("return");
      }
      this._functionDescr.push({
        "name": funcName,
        "type": funcType,
        "parameters": paramNames,
        "body": funcBody,
        "callIndex": 0
      });
      startIndex = funcBodyEndIndex + 1;
      var partBefore = inlineTokenIndex > 0 ? this._sourceCode.substring(0, inlineTokenIndex) : "";
      var partAfter = funcBodyEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(funcBodyEndIndex + 1) : "";
      this._sourceCode = partBefore + partAfter;
      startIndex -= funcBodyEndIndex + 1 - inlineTokenIndex;
    }
    if (this.debug) {
      console.log("Collect functions: " + this._functionDescr.length + " functions found. functionDescr=", this._functionDescr);
    }
  };
  ShaderCodeInliner2.prototype._processInlining = function(numMaxIterations) {
    if (numMaxIterations === void 0) {
      numMaxIterations = 20;
    }
    while (numMaxIterations-- >= 0) {
      if (!this._replaceFunctionCallsByCode()) {
        break;
      }
    }
    if (this.debug) {
      console.log("numMaxIterations is " + numMaxIterations + " after inlining process");
    }
    return numMaxIterations >= 0;
  };
  ShaderCodeInliner2.prototype._extractBetweenMarkers = function(markerOpen, markerClose, block, startIndex) {
    var currPos = startIndex, openMarkers = 0, waitForChar = "";
    while (currPos < block.length) {
      var currChar = block.charAt(currPos);
      if (!waitForChar) {
        switch (currChar) {
          case markerOpen:
            openMarkers++;
            break;
          case markerClose:
            openMarkers--;
            break;
          case '"':
          case "'":
          case "`":
            waitForChar = currChar;
            break;
          case "/":
            if (currPos + 1 < block.length) {
              var nextChar = block.charAt(currPos + 1);
              if (nextChar === "/") {
                waitForChar = "\n";
              } else if (nextChar === "*") {
                waitForChar = "*/";
              }
            }
            break;
        }
      } else {
        if (currChar === waitForChar) {
          if (waitForChar === '"' || waitForChar === "'") {
            block.charAt(currPos - 1) !== "\\" && (waitForChar = "");
          } else {
            waitForChar = "";
          }
        } else if (waitForChar === "*/" && currChar === "*" && currPos + 1 < block.length) {
          block.charAt(currPos + 1) === "/" && (waitForChar = "");
          if (waitForChar === "") {
            currPos++;
          }
        }
      }
      currPos++;
      if (openMarkers === 0) {
        break;
      }
    }
    return openMarkers === 0 ? currPos - 1 : -1;
  };
  ShaderCodeInliner2.prototype._skipWhitespaces = function(s, index) {
    while (index < s.length) {
      var c = s[index];
      if (c !== " " && c !== "\n" && c !== "\r" && c !== "	" && c !== "\n" && c !== "\xA0") {
        break;
      }
      index++;
    }
    return index;
  };
  ShaderCodeInliner2.prototype._removeComments = function(block) {
    var currPos = 0, waitForChar = "", inComments = false, s = [];
    while (currPos < block.length) {
      var currChar = block.charAt(currPos);
      if (!waitForChar) {
        switch (currChar) {
          case '"':
          case "'":
          case "`":
            waitForChar = currChar;
            break;
          case "/":
            if (currPos + 1 < block.length) {
              var nextChar = block.charAt(currPos + 1);
              if (nextChar === "/") {
                waitForChar = "\n";
                inComments = true;
              } else if (nextChar === "*") {
                waitForChar = "*/";
                inComments = true;
              }
            }
            break;
        }
        if (!inComments) {
          s.push(currChar);
        }
      } else {
        if (currChar === waitForChar) {
          if (waitForChar === '"' || waitForChar === "'") {
            block.charAt(currPos - 1) !== "\\" && (waitForChar = "");
            s.push(currChar);
          } else {
            waitForChar = "";
            inComments = false;
          }
        } else if (waitForChar === "*/" && currChar === "*" && currPos + 1 < block.length) {
          block.charAt(currPos + 1) === "/" && (waitForChar = "");
          if (waitForChar === "") {
            inComments = false;
            currPos++;
          }
        } else {
          if (!inComments) {
            s.push(currChar);
          }
        }
      }
      currPos++;
    }
    return s.join("");
  };
  ShaderCodeInliner2.prototype._replaceFunctionCallsByCode = function() {
    var doAgain = false;
    for (var _i = 0, _a = this._functionDescr; _i < _a.length; _i++) {
      var func = _a[_i];
      var name_1 = func.name, type = func.type, parameters = func.parameters, body = func.body;
      var startIndex = 0;
      while (startIndex < this._sourceCode.length) {
        var functionCallIndex = this._sourceCode.indexOf(name_1, startIndex);
        if (functionCallIndex < 0) {
          break;
        }
        var callParamsStartIndex = this._skipWhitespaces(this._sourceCode, functionCallIndex + name_1.length);
        if (callParamsStartIndex === this._sourceCode.length || this._sourceCode.charAt(callParamsStartIndex) !== "(") {
          startIndex = functionCallIndex + name_1.length;
          continue;
        }
        var callParamsEndIndex = this._extractBetweenMarkers("(", ")", this._sourceCode, callParamsStartIndex);
        if (callParamsEndIndex < 0) {
          if (this.debug) {
            console.warn("Could not extract the parameters of the function call. Function '" + name_1 + "' (type=" + type + "). callParamsStartIndex=" + callParamsStartIndex);
          }
          startIndex = functionCallIndex + name_1.length;
          continue;
        }
        var callParams = this._sourceCode.substring(callParamsStartIndex + 1, callParamsEndIndex);
        var params = this._removeComments(callParams).split(",");
        var paramNames = [];
        for (var p = 0; p < params.length; ++p) {
          var param = params[p].trim();
          paramNames.push(param);
        }
        var retParamName = type !== "void" ? name_1 + "_" + func.callIndex++ : null;
        if (retParamName) {
          paramNames.push(retParamName + " =");
        }
        if (paramNames.length !== parameters.length) {
          if (this.debug) {
            console.warn("Invalid function call: not the same number of parameters for the call than the number expected by the function. Function '" + name_1 + "' (type=" + type + "). function parameters=" + parameters + ", call parameters=" + paramNames);
          }
          startIndex = functionCallIndex + name_1.length;
          continue;
        }
        startIndex = callParamsEndIndex + 1;
        var funcBody = this._replaceNames(body, parameters, paramNames);
        var partBefore = functionCallIndex > 0 ? this._sourceCode.substring(0, functionCallIndex) : "";
        var partAfter = callParamsEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(callParamsEndIndex + 1) : "";
        if (retParamName) {
          var injectDeclarationIndex = this._findBackward(this._sourceCode, functionCallIndex - 1, "\n");
          partBefore = this._sourceCode.substring(0, injectDeclarationIndex + 1);
          var partBetween = this._sourceCode.substring(injectDeclarationIndex + 1, functionCallIndex);
          this._sourceCode = partBefore + type + " " + retParamName + ";\n" + funcBody + "\n" + partBetween + retParamName + partAfter;
          if (this.debug) {
            console.log("Replace function call by code. Function '" + name_1 + "' (type=" + type + "). injectDeclarationIndex=" + injectDeclarationIndex);
          }
        } else {
          this._sourceCode = partBefore + funcBody + partAfter;
          startIndex += funcBody.length - (callParamsEndIndex + 1 - functionCallIndex);
          if (this.debug) {
            console.log("Replace function call by code. Function '" + name_1 + "' (type=" + type + "). functionCallIndex=" + functionCallIndex);
          }
        }
        doAgain = true;
      }
    }
    return doAgain;
  };
  ShaderCodeInliner2.prototype._findBackward = function(s, index, c) {
    while (index >= 0 && s.charAt(index) !== c) {
      index--;
    }
    return index;
  };
  ShaderCodeInliner2.prototype._escapeRegExp = function(s) {
    return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  };
  ShaderCodeInliner2.prototype._replaceNames = function(code, sources, destinations) {
    for (var i = 0; i < sources.length; ++i) {
      var source = new RegExp(this._escapeRegExp(sources[i]), "g"), destination = destinations[i];
      code = code.replace(source, destination);
    }
    return code;
  };
  ShaderCodeInliner2._RegexpFindFunctionNameAndType = /((\s+?)(\w+)\s+(\w+)\s*?)$/;
  return ShaderCodeInliner2;
}();

// node_modules/@babylonjs/core/Engines/nativeEngine.js
var NativePipelineContext = function() {
  function NativePipelineContext2() {
    this.isAsync = false;
    this.isReady = false;
  }
  NativePipelineContext2.prototype._getVertexShaderCode = function() {
    return null;
  };
  NativePipelineContext2.prototype._getFragmentShaderCode = function() {
    return null;
  };
  NativePipelineContext2.prototype._handlesSpectorRebuildCallback = function(onCompiled) {
    throw new Error("Not implemented");
  };
  return NativePipelineContext2;
}();
var NativeDataBuffer = function(_super) {
  __extends(NativeDataBuffer2, _super);
  function NativeDataBuffer2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return NativeDataBuffer2;
}(DataBuffer);
var NativeTexture = function(_super) {
  __extends(NativeTexture2, _super);
  function NativeTexture2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  NativeTexture2.prototype.getInternalTexture = function() {
    return this;
  };
  NativeTexture2.prototype.getViewCount = function() {
    return 1;
  };
  return NativeTexture2;
}(InternalTexture);
var NativeEngine = function(_super) {
  __extends(NativeEngine2, _super);
  function NativeEngine2() {
    var _this = _super.call(this, null) || this;
    _this._native = new _native.Engine();
    _this.INVALID_HANDLE = 65535;
    _this._boundBuffersVertexArray = null;
    _this._currentDepthTest = _this._native.DEPTH_TEST_LEQUAL;
    _this._webGLVersion = 2;
    _this.disableUniformBuffers = true;
    _this._caps = {
      maxTexturesImageUnits: 16,
      maxVertexTextureImageUnits: 16,
      maxCombinedTexturesImageUnits: 32,
      maxTextureSize: 512,
      maxCubemapTextureSize: 512,
      maxRenderTextureSize: 512,
      maxVertexAttribs: 16,
      maxVaryingVectors: 16,
      maxFragmentUniformVectors: 16,
      maxVertexUniformVectors: 16,
      standardDerivatives: true,
      astc: null,
      pvrtc: null,
      etc1: null,
      etc2: null,
      bptc: null,
      maxAnisotropy: 16,
      uintIndices: true,
      fragmentDepthSupported: false,
      highPrecisionShaderSupported: true,
      colorBufferFloat: false,
      textureFloat: false,
      textureFloatLinearFiltering: false,
      textureFloatRender: false,
      textureHalfFloat: false,
      textureHalfFloatLinearFiltering: false,
      textureHalfFloatRender: false,
      textureLOD: true,
      drawBuffersExtension: false,
      depthTextureExtension: false,
      vertexArrayObject: true,
      instancedArrays: false,
      canUseTimestampForTimerQuery: false,
      blendMinMax: false,
      maxMSAASamples: 1
    };
    Tools.Log("Babylon Native (v" + Engine.Version + ") launched");
    Tools.LoadScript = function(scriptUrl, onSuccess, onError, scriptId) {
      Tools.LoadFile(scriptUrl, function(data) {
        Function(data).apply(null);
        if (onSuccess) {
          onSuccess();
        }
      }, void 0, void 0, false, function(request, exception) {
        if (onError) {
          onError("LoadScript Error", exception);
        }
      });
    };
    if (typeof URL === "undefined") {
      window.URL = {
        createObjectURL: function() {
        },
        revokeObjectURL: function() {
        }
      };
    }
    if (typeof Blob === "undefined") {
      window.Blob = function() {
      };
    }
    _this._shaderProcessor = new WebGL2ShaderProcessor();
    return _this;
  }
  NativeEngine2.prototype.getHardwareScalingLevel = function() {
    return 1;
  };
  NativeEngine2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    if (this._boundBuffersVertexArray) {
      this._native.deleteVertexArray(this._boundBuffersVertexArray);
    }
    this._native.dispose();
  };
  NativeEngine2.prototype._queueNewFrame = function(bindedRenderFunction, requester) {
    if (requester.requestAnimationFrame && requester !== window) {
      requester.requestAnimationFrame(bindedRenderFunction);
    } else {
      this._native.requestAnimationFrame(bindedRenderFunction);
    }
    return 0;
  };
  NativeEngine2.prototype._bindUnboundFramebuffer = function(framebuffer) {
    if (this._currentFramebuffer !== framebuffer) {
      if (this._currentFramebuffer) {
        this._native.unbindFramebuffer(this._currentFramebuffer);
      }
      if (framebuffer) {
        this._native.bindFramebuffer(framebuffer);
      }
      this._currentFramebuffer = framebuffer;
    }
  };
  NativeEngine2.prototype.getHostDocument = function() {
    return null;
  };
  NativeEngine2.prototype.clear = function(color, backBuffer, depth, stencil) {
    if (stencil === void 0) {
      stencil = false;
    }
    var mode = 0;
    if (backBuffer && color) {
      this._native.clearColor(color.r, color.g, color.b, color.a !== void 0 ? color.a : 1);
      mode |= this._native.CLEAR_FLAG_COLOR;
    }
    if (depth) {
      this._native.clearDepth(1);
      mode |= this._native.CLEAR_FLAG_DEPTH;
    }
    if (stencil) {
      this._native.clearStencil(0);
      mode |= this._native.CLEAR_FLAG_STENCIL;
    }
    this._native.clear(mode);
  };
  NativeEngine2.prototype.createIndexBuffer = function(indices, updateable) {
    var data = this._normalizeIndexData(indices);
    var buffer = new NativeDataBuffer();
    buffer.references = 1;
    buffer.is32Bits = data.BYTES_PER_ELEMENT === 4;
    if (data.length) {
      buffer.nativeIndexBuffer = this._native.createIndexBuffer(data, updateable !== null && updateable !== void 0 ? updateable : false);
      if (buffer.nativeVertexBuffer === this.INVALID_HANDLE) {
        throw new Error("Could not create a native index buffer.");
      }
    } else {
      buffer.nativeVertexBuffer = this.INVALID_HANDLE;
    }
    return buffer;
  };
  NativeEngine2.prototype.createVertexBuffer = function(data, updateable) {
    var buffer = new NativeDataBuffer();
    buffer.references = 1;
    buffer.nativeVertexBuffer = this._native.createVertexBuffer(ArrayBuffer.isView(data) ? data : new Float32Array(data), updateable !== null && updateable !== void 0 ? updateable : false);
    if (buffer.nativeVertexBuffer === this.INVALID_HANDLE) {
      throw new Error("Could not create a native vertex buffer.");
    }
    return buffer;
  };
  NativeEngine2.prototype._recordVertexArrayObject = function(vertexArray, vertexBuffers, indexBuffer, effect) {
    if (indexBuffer) {
      this._native.recordIndexBuffer(vertexArray, indexBuffer.nativeIndexBuffer);
    }
    var attributes = effect.getAttributesNames();
    for (var index = 0; index < attributes.length; index++) {
      var location_1 = effect.getAttributeLocation(index);
      if (location_1 >= 0) {
        var kind = attributes[index];
        var vertexBuffer = vertexBuffers[kind];
        if (vertexBuffer) {
          var buffer = vertexBuffer.getBuffer();
          if (buffer) {
            this._native.recordVertexBuffer(vertexArray, buffer.nativeVertexBuffer, location_1, vertexBuffer.byteOffset, vertexBuffer.byteStride, vertexBuffer.getSize(), this._getNativeAttribType(vertexBuffer.type), vertexBuffer.normalized);
          }
        }
      }
    }
  };
  NativeEngine2.prototype.bindBuffers = function(vertexBuffers, indexBuffer, effect) {
    if (this._boundBuffersVertexArray) {
      this._native.deleteVertexArray(this._boundBuffersVertexArray);
    }
    this._boundBuffersVertexArray = this._native.createVertexArray();
    this._recordVertexArrayObject(this._boundBuffersVertexArray, vertexBuffers, indexBuffer, effect);
    this._native.bindVertexArray(this._boundBuffersVertexArray);
  };
  NativeEngine2.prototype.recordVertexArrayObject = function(vertexBuffers, indexBuffer, effect) {
    var vertexArray = this._native.createVertexArray();
    this._recordVertexArrayObject(vertexArray, vertexBuffers, indexBuffer, effect);
    return vertexArray;
  };
  NativeEngine2.prototype.bindVertexArrayObject = function(vertexArray) {
    this._native.bindVertexArray(vertexArray);
  };
  NativeEngine2.prototype.releaseVertexArrayObject = function(vertexArray) {
    this._native.deleteVertexArray(vertexArray);
  };
  NativeEngine2.prototype.getAttributes = function(pipelineContext, attributesNames) {
    var nativePipelineContext = pipelineContext;
    return this._native.getAttributes(nativePipelineContext.nativeProgram, attributesNames);
  };
  NativeEngine2.prototype.drawElementsType = function(fillMode, indexStart, indexCount, instancesCount) {
    this._drawCalls.addCount(1, false);
    this._native.drawIndexed(fillMode, indexStart, indexCount);
  };
  NativeEngine2.prototype.drawArraysType = function(fillMode, verticesStart, verticesCount, instancesCount) {
    this._drawCalls.addCount(1, false);
    this._native.draw(fillMode, verticesStart, verticesCount);
  };
  NativeEngine2.prototype.createPipelineContext = function() {
    return new NativePipelineContext();
  };
  NativeEngine2.prototype._preparePipelineContext = function(pipelineContext, vertexSourceCode, fragmentSourceCode, createAsRaw, rebuildRebind, defines, transformFeedbackVaryings) {
    var nativePipelineContext = pipelineContext;
    if (createAsRaw) {
      nativePipelineContext.nativeProgram = this.createRawShaderProgram(pipelineContext, vertexSourceCode, fragmentSourceCode, void 0, transformFeedbackVaryings);
    } else {
      nativePipelineContext.nativeProgram = this.createShaderProgram(pipelineContext, vertexSourceCode, fragmentSourceCode, defines, void 0, transformFeedbackVaryings);
    }
  };
  NativeEngine2.prototype._isRenderingStateCompiled = function(pipelineContext) {
    return true;
  };
  NativeEngine2.prototype._executeWhenRenderingStateIsCompiled = function(pipelineContext, action) {
    action();
  };
  NativeEngine2.prototype.createRawShaderProgram = function(pipelineContext, vertexCode, fragmentCode, context, transformFeedbackVaryings) {
    if (transformFeedbackVaryings === void 0) {
      transformFeedbackVaryings = null;
    }
    throw new Error("Not Supported");
  };
  NativeEngine2.prototype.createShaderProgram = function(pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings) {
    if (transformFeedbackVaryings === void 0) {
      transformFeedbackVaryings = null;
    }
    this.onBeforeShaderCompilationObservable.notifyObservers(this);
    var vertexInliner = new ShaderCodeInliner(vertexCode);
    vertexInliner.processCode();
    vertexCode = vertexInliner.code;
    var fragmentInliner = new ShaderCodeInliner(fragmentCode);
    fragmentInliner.processCode();
    fragmentCode = fragmentInliner.code;
    vertexCode = ThinEngine._ConcatenateShader(vertexCode, defines);
    fragmentCode = ThinEngine._ConcatenateShader(fragmentCode, defines);
    var program = this._native.createProgram(vertexCode, fragmentCode);
    this.onAfterShaderCompilationObservable.notifyObservers(this);
    return program;
  };
  NativeEngine2.prototype._setProgram = function(program) {
    if (this._currentProgram !== program) {
      this._native.setProgram(program);
      this._currentProgram = program;
    }
  };
  NativeEngine2.prototype._releaseEffect = function(effect) {
  };
  NativeEngine2.prototype._deletePipelineContext = function(pipelineContext) {
  };
  NativeEngine2.prototype.getUniforms = function(pipelineContext, uniformsNames) {
    var nativePipelineContext = pipelineContext;
    return this._native.getUniforms(nativePipelineContext.nativeProgram, uniformsNames);
  };
  NativeEngine2.prototype.bindUniformBlock = function(pipelineContext, blockName, index) {
    throw new Error("Not Implemented");
  };
  NativeEngine2.prototype.bindSamplers = function(effect) {
    var nativePipelineContext = effect.getPipelineContext();
    this._setProgram(nativePipelineContext.nativeProgram);
    var samplers = effect.getSamplers();
    for (var index = 0; index < samplers.length; index++) {
      var uniform = effect.getUniform(samplers[index]);
      if (uniform) {
        this._boundUniforms[index] = uniform;
      }
    }
    this._currentEffect = null;
  };
  NativeEngine2.prototype.setMatrix = function(uniform, matrix) {
    if (!uniform) {
      return;
    }
    this._native.setMatrix(uniform, matrix.toArray());
  };
  NativeEngine2.prototype.getRenderWidth = function(useScreen) {
    if (useScreen === void 0) {
      useScreen = false;
    }
    if (!useScreen && this._currentRenderTarget) {
      return this._currentRenderTarget.width;
    }
    return this._native.getRenderWidth();
  };
  NativeEngine2.prototype.getRenderHeight = function(useScreen) {
    if (useScreen === void 0) {
      useScreen = false;
    }
    if (!useScreen && this._currentRenderTarget) {
      return this._currentRenderTarget.height;
    }
    return this._native.getRenderHeight();
  };
  NativeEngine2.prototype.setViewport = function(viewport, requiredWidth, requiredHeight) {
    this._cachedViewport = viewport;
    this._native.setViewPort(viewport.x, viewport.y, viewport.width, viewport.height);
  };
  NativeEngine2.prototype.setState = function(culling, zOffset, force, reverseSide) {
    if (zOffset === void 0) {
      zOffset = 0;
    }
    if (reverseSide === void 0) {
      reverseSide = false;
    }
    this._native.setState(culling, zOffset, reverseSide);
  };
  NativeEngine2.prototype.setZOffset = function(value) {
    this._native.setZOffset(value);
  };
  NativeEngine2.prototype.getZOffset = function() {
    return this._native.getZOffset();
  };
  NativeEngine2.prototype.setDepthBuffer = function(enable) {
    this._native.setDepthTest(enable ? this._currentDepthTest : this._native.DEPTH_TEST_ALWAYS);
  };
  NativeEngine2.prototype.getDepthWrite = function() {
    return this._native.getDepthWrite();
  };
  NativeEngine2.prototype.setDepthFunctionToGreater = function() {
    this._currentDepthTest = this._native.DEPTH_TEST_GREATER;
    this._native.setDepthTest(this._currentDepthTest);
  };
  NativeEngine2.prototype.setDepthFunctionToGreaterOrEqual = function() {
    this._currentDepthTest = this._native.DEPTH_TEST_GEQUAL;
    this._native.setDepthTest(this._currentDepthTest);
  };
  NativeEngine2.prototype.setDepthFunctionToLess = function() {
    this._currentDepthTest = this._native.DEPTH_TEST_LESS;
    this._native.setDepthTest(this._currentDepthTest);
  };
  NativeEngine2.prototype.setDepthFunctionToLessOrEqual = function() {
    this._currentDepthTest = this._native.DEPTH_TEST_LEQUAL;
    this._native.setDepthTest(this._currentDepthTest);
  };
  NativeEngine2.prototype.setDepthWrite = function(enable) {
    this._native.setDepthWrite(enable);
  };
  NativeEngine2.prototype.setColorWrite = function(enable) {
    this._native.setColorWrite(enable);
    this._colorWrite = enable;
  };
  NativeEngine2.prototype.getColorWrite = function() {
    return this._colorWrite;
  };
  NativeEngine2.prototype.setAlphaConstants = function(r, g, b, a) {
    throw new Error("Setting alpha blend constant color not yet implemented.");
  };
  NativeEngine2.prototype.setAlphaMode = function(mode, noDepthWriteChange) {
    if (noDepthWriteChange === void 0) {
      noDepthWriteChange = false;
    }
    if (this._alphaMode === mode) {
      return;
    }
    mode = this._getNativeAlphaMode(mode);
    this._native.setBlendMode(mode);
    if (!noDepthWriteChange) {
      this.setDepthWrite(mode === 0);
    }
    this._alphaMode = mode;
  };
  NativeEngine2.prototype.getAlphaMode = function() {
    return this._alphaMode;
  };
  NativeEngine2.prototype.setInt = function(uniform, int) {
    if (!uniform) {
      return false;
    }
    this._native.setInt(uniform, int);
    return true;
  };
  NativeEngine2.prototype.setIntArray = function(uniform, array) {
    if (!uniform) {
      return false;
    }
    this._native.setIntArray(uniform, array);
    return true;
  };
  NativeEngine2.prototype.setIntArray2 = function(uniform, array) {
    if (!uniform) {
      return false;
    }
    this._native.setIntArray2(uniform, array);
    return true;
  };
  NativeEngine2.prototype.setIntArray3 = function(uniform, array) {
    if (!uniform) {
      return false;
    }
    this._native.setIntArray3(uniform, array);
    return true;
  };
  NativeEngine2.prototype.setIntArray4 = function(uniform, array) {
    if (!uniform) {
      return false;
    }
    this._native.setIntArray4(uniform, array);
    return true;
  };
  NativeEngine2.prototype.setFloatArray = function(uniform, array) {
    if (!uniform) {
      return false;
    }
    this._native.setFloatArray(uniform, array);
    return true;
  };
  NativeEngine2.prototype.setFloatArray2 = function(uniform, array) {
    if (!uniform) {
      return false;
    }
    this._native.setFloatArray2(uniform, array);
    return true;
  };
  NativeEngine2.prototype.setFloatArray3 = function(uniform, array) {
    if (!uniform) {
      return false;
    }
    this._native.setFloatArray3(uniform, array);
    return true;
  };
  NativeEngine2.prototype.setFloatArray4 = function(uniform, array) {
    if (!uniform) {
      return false;
    }
    this._native.setFloatArray4(uniform, array);
    return true;
  };
  NativeEngine2.prototype.setArray = function(uniform, array) {
    if (!uniform) {
      return false;
    }
    this._native.setFloatArray(uniform, array);
    return true;
  };
  NativeEngine2.prototype.setArray2 = function(uniform, array) {
    if (!uniform) {
      return false;
    }
    this._native.setFloatArray2(uniform, array);
    return true;
  };
  NativeEngine2.prototype.setArray3 = function(uniform, array) {
    if (!uniform) {
      return false;
    }
    this._native.setFloatArray3(uniform, array);
    return true;
  };
  NativeEngine2.prototype.setArray4 = function(uniform, array) {
    if (!uniform) {
      return false;
    }
    this._native.setFloatArray4(uniform, array);
    return true;
  };
  NativeEngine2.prototype.setMatrices = function(uniform, matrices) {
    if (!uniform) {
      return false;
    }
    this._native.setMatrices(uniform, matrices);
    return true;
  };
  NativeEngine2.prototype.setMatrix3x3 = function(uniform, matrix) {
    if (!uniform) {
      return false;
    }
    this._native.setMatrix3x3(uniform, matrix);
    return true;
  };
  NativeEngine2.prototype.setMatrix2x2 = function(uniform, matrix) {
    if (!uniform) {
      return false;
    }
    this._native.setMatrix2x2(uniform, matrix);
    return true;
  };
  NativeEngine2.prototype.setFloat = function(uniform, value) {
    if (!uniform) {
      return false;
    }
    this._native.setFloat(uniform, value);
    return true;
  };
  NativeEngine2.prototype.setFloat2 = function(uniform, x, y) {
    if (!uniform) {
      return false;
    }
    this._native.setFloat2(uniform, x, y);
    return true;
  };
  NativeEngine2.prototype.setFloat3 = function(uniform, x, y, z) {
    if (!uniform) {
      return false;
    }
    this._native.setFloat3(uniform, x, y, z);
    return true;
  };
  NativeEngine2.prototype.setFloat4 = function(uniform, x, y, z, w) {
    if (!uniform) {
      return false;
    }
    this._native.setFloat4(uniform, x, y, z, w);
    return true;
  };
  NativeEngine2.prototype.setColor3 = function(uniform, color3) {
    if (!uniform) {
      return false;
    }
    this._native.setFloat3(uniform, color3.r, color3.g, color3.b);
    return true;
  };
  NativeEngine2.prototype.setColor4 = function(uniform, color3, alpha) {
    if (!uniform) {
      return false;
    }
    this._native.setFloat4(uniform, color3.r, color3.g, color3.b, alpha);
    return true;
  };
  NativeEngine2.prototype.wipeCaches = function(bruteForce) {
    if (this.preventCacheWipeBetweenFrames) {
      return;
    }
    this.resetTextureCache();
    this._currentEffect = null;
    if (bruteForce) {
      this._currentProgram = null;
      this._stencilState.reset();
      this._depthCullingState.reset();
      this._alphaState.reset();
    }
    this._cachedVertexBuffers = null;
    this._cachedIndexBuffer = null;
    this._cachedEffectForVertexBuffers = null;
  };
  NativeEngine2.prototype._createTexture = function() {
    return this._native.createTexture();
  };
  NativeEngine2.prototype._deleteTexture = function(texture) {
    this._native.deleteTexture(texture);
  };
  NativeEngine2.prototype.updateDynamicTexture = function(texture, canvas, invertY, premulAlpha, format) {
    if (premulAlpha === void 0) {
      premulAlpha = false;
    }
    var imageData = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYSURBVChTY/z//z8DPsAEpXGC4aCAgQEAGGMDDWwwgqsAAAAASUVORK5CYII=";
    this.createTexture("data:my_image_name", true, invertY, null, Texture.BILINEAR_SAMPLINGMODE, void 0, void 0, imageData, texture, NativeEngine2.TEXTUREFORMAT_RGBA, null, void 0);
  };
  NativeEngine2.prototype.createTexture = function(url, noMipmap, invertY, scene, samplingMode, onLoad, onError, buffer, fallback, format, forcedExtension, mimeType, loaderOptions) {
    var _this = this;
    if (samplingMode === void 0) {
      samplingMode = 3;
    }
    if (onLoad === void 0) {
      onLoad = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (buffer === void 0) {
      buffer = null;
    }
    if (fallback === void 0) {
      fallback = null;
    }
    if (format === void 0) {
      format = null;
    }
    if (forcedExtension === void 0) {
      forcedExtension = null;
    }
    url = url || "";
    var fromData = url.substr(0, 5) === "data:";
    var isBase64 = fromData && url.indexOf(";base64,") !== -1;
    var texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Url);
    var originalUrl = url;
    if (this._transformTextureUrl && !isBase64 && !fallback && !buffer) {
      url = this._transformTextureUrl(url);
    }
    var lastDot = url.lastIndexOf(".");
    var extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : "";
    var loader = null;
    for (var _i = 0, _a = Engine._TextureLoaders; _i < _a.length; _i++) {
      var availableLoader = _a[_i];
      if (availableLoader.canLoad(extension)) {
        loader = availableLoader;
        break;
      }
    }
    if (scene) {
      scene._addPendingData(texture);
    }
    texture.url = url;
    texture.generateMipMaps = !noMipmap;
    texture.samplingMode = samplingMode;
    texture.invertY = invertY;
    if (!this.doNotHandleContextLost) {
      texture._buffer = buffer;
    }
    var onLoadObserver = null;
    if (onLoad && !fallback) {
      onLoadObserver = texture.onLoadedObservable.add(onLoad);
    }
    if (!fallback) {
      this._internalTexturesCache.push(texture);
    }
    var onInternalError = function(message, exception) {
      if (scene) {
        scene._removePendingData(texture);
      }
      if (url === originalUrl) {
        if (onLoadObserver) {
          texture.onLoadedObservable.remove(onLoadObserver);
        }
        if (EngineStore.UseFallbackTexture) {
          _this.createTexture(EngineStore.FallbackTexture, noMipmap, texture.invertY, scene, samplingMode, null, onError, buffer, texture);
        }
        if (onError) {
          onError((message || "Unknown error") + (EngineStore.UseFallbackTexture ? " - Fallback texture was used" : ""), exception);
        }
      } else {
        Logger.Warn("Failed to load " + url + ", falling back to " + originalUrl);
        _this.createTexture(originalUrl, noMipmap, texture.invertY, scene, samplingMode, onLoad, onError, buffer, texture, format, forcedExtension, mimeType, loaderOptions);
      }
    };
    if (loader) {
      throw new Error("Loading textures from IInternalTextureLoader not yet implemented.");
    } else {
      var onload_1 = function(data) {
        var webGLTexture = texture._webGLTexture;
        if (!webGLTexture) {
          if (scene) {
            scene._removePendingData(texture);
          }
          return;
        }
        _this._native.loadTexture(webGLTexture, data, !noMipmap, invertY, function() {
          texture.baseWidth = _this._native.getTextureWidth(webGLTexture);
          texture.baseHeight = _this._native.getTextureHeight(webGLTexture);
          texture.width = texture.baseWidth;
          texture.height = texture.baseHeight;
          texture.isReady = true;
          var filter = _this._getNativeSamplingMode(samplingMode);
          _this._native.setTextureSampling(webGLTexture, filter);
          if (scene) {
            scene._removePendingData(texture);
          }
          texture.onLoadedObservable.notifyObservers(texture);
          texture.onLoadedObservable.clear();
        }, function() {
          throw new Error("Could not load a native texture.");
        });
      };
      if (fromData) {
        if (buffer instanceof ArrayBuffer) {
          onload_1(new Uint8Array(buffer));
        } else if (ArrayBuffer.isView(buffer)) {
          onload_1(buffer);
        } else if (typeof buffer === "string") {
          onload_1(new Uint8Array(Tools.DecodeBase64(buffer)));
        } else {
          throw new Error("Unsupported buffer type");
        }
      } else {
        if (isBase64) {
          onload_1(new Uint8Array(Tools.DecodeBase64(url)));
        } else {
          this._loadFile(url, function(data) {
            return onload_1(new Uint8Array(data));
          }, void 0, void 0, true, function(request, exception) {
            onInternalError("Unable to load " + (request ? request.responseURL : url, exception));
          });
        }
      }
    }
    return texture;
  };
  NativeEngine2.prototype._createDepthStencilTexture = function(size, options) {
    var texture = new NativeTexture(this, InternalTextureSource.Depth);
    var width = size.width || size;
    var height = size.height || size;
    var framebuffer = this._native.createDepthTexture(texture._webGLTexture, width, height);
    texture._framebuffer = framebuffer;
    return texture;
  };
  NativeEngine2.prototype._releaseFramebufferObjects = function(texture) {
  };
  NativeEngine2.prototype.createCubeTexture = function(rootUrl, scene, files, noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, fallback) {
    var _this = this;
    if (onLoad === void 0) {
      onLoad = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (forcedExtension === void 0) {
      forcedExtension = null;
    }
    if (createPolynomials === void 0) {
      createPolynomials = false;
    }
    if (lodScale === void 0) {
      lodScale = 0;
    }
    if (lodOffset === void 0) {
      lodOffset = 0;
    }
    if (fallback === void 0) {
      fallback = null;
    }
    var texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Cube);
    texture.isCube = true;
    texture.url = rootUrl;
    texture.generateMipMaps = !noMipmap;
    texture._lodGenerationScale = lodScale;
    texture._lodGenerationOffset = lodOffset;
    if (!this._doNotHandleContextLost) {
      texture._extension = forcedExtension;
      texture._files = files;
    }
    var lastDot = rootUrl.lastIndexOf(".");
    var extension = forcedExtension ? forcedExtension : lastDot > -1 ? rootUrl.substring(lastDot).toLowerCase() : "";
    if (extension === ".env") {
      var onloaddata_1 = function(data) {
        var info = EnvironmentTextureTools.GetEnvInfo(data);
        texture.width = info.width;
        texture.height = info.width;
        EnvironmentTextureTools.UploadEnvSpherical(texture, info);
        if (info.version !== 1) {
          throw new Error('Unsupported babylon environment map version "' + info.version + '"');
        }
        var specularInfo = info.specular;
        if (!specularInfo) {
          throw new Error("Nothing else parsed so far");
        }
        texture._lodGenerationScale = specularInfo.lodGenerationScale;
        var imageData = EnvironmentTextureTools.CreateImageDataArrayBufferViews(data, info);
        texture.format = 5;
        texture.type = 0;
        texture.generateMipMaps = true;
        texture.getEngine().updateTextureSamplingMode(Texture.TRILINEAR_SAMPLINGMODE, texture);
        texture._isRGBD = true;
        texture.invertY = true;
        _this._native.loadCubeTextureWithMips(texture._webGLTexture, imageData, function() {
          texture.isReady = true;
          if (onLoad) {
            onLoad();
          }
        }, function() {
          throw new Error("Could not load a native cube texture.");
        });
      };
      if (files && files.length === 6) {
        throw new Error("Multi-file loading not allowed on env files.");
      } else {
        var onInternalError = function(request, exception) {
          if (onError && request) {
            onError(request.status + " " + request.statusText, exception);
          }
        };
        this._loadFile(rootUrl, function(data) {
          return onloaddata_1(new Uint8Array(data));
        }, void 0, void 0, true, onInternalError);
      }
    } else {
      if (!files || files.length !== 6) {
        throw new Error("Cannot load cubemap because 6 files were not defined");
      }
      var reorderedFiles = [files[0], files[3], files[1], files[4], files[2], files[5]];
      Promise.all(reorderedFiles.map(function(file) {
        return Tools.LoadFileAsync(file).then(function(data) {
          return new Uint8Array(data);
        });
      })).then(function(data) {
        return new Promise(function(resolve, reject) {
          _this._native.loadCubeTexture(texture._webGLTexture, data, !noMipmap, resolve, reject);
        });
      }).then(function() {
        texture.isReady = true;
        if (onLoad) {
          onLoad();
        }
      }, function(error) {
        if (onError) {
          onError("Failed to load cubemap: " + error.message, error);
        }
      });
    }
    this._internalTexturesCache.push(texture);
    return texture;
  };
  NativeEngine2.prototype.createRenderTargetTexture = function(size, options) {
    var fullOptions = new RenderTargetCreationOptions();
    if (options !== void 0 && typeof options === "object") {
      fullOptions.generateMipMaps = options.generateMipMaps;
      fullOptions.generateDepthBuffer = options.generateDepthBuffer === void 0 ? true : options.generateDepthBuffer;
      fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && options.generateStencilBuffer;
      fullOptions.type = options.type === void 0 ? 0 : options.type;
      fullOptions.samplingMode = options.samplingMode === void 0 ? 3 : options.samplingMode;
      fullOptions.format = options.format === void 0 ? 5 : options.format;
    } else {
      fullOptions.generateMipMaps = options;
      fullOptions.generateDepthBuffer = true;
      fullOptions.generateStencilBuffer = false;
      fullOptions.type = 0;
      fullOptions.samplingMode = 3;
      fullOptions.format = 5;
    }
    if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {
      fullOptions.samplingMode = 1;
    } else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {
      fullOptions.samplingMode = 1;
    }
    var texture = new NativeTexture(this, InternalTextureSource.RenderTarget);
    var width = size.width || size;
    var height = size.height || size;
    if (fullOptions.type === 1 && !this._caps.textureFloat) {
      fullOptions.type = 0;
      Logger.Warn("Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type");
    }
    var framebuffer = this._native.createFramebuffer(texture._webGLTexture, width, height, this._getNativeTextureFormat(fullOptions.format, fullOptions.type), fullOptions.samplingMode, fullOptions.generateStencilBuffer ? true : false, fullOptions.generateDepthBuffer, fullOptions.generateMipMaps ? true : false);
    texture._framebuffer = framebuffer;
    texture.baseWidth = width;
    texture.baseHeight = height;
    texture.width = width;
    texture.height = height;
    texture.isReady = true;
    texture.samples = 1;
    texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;
    texture.samplingMode = fullOptions.samplingMode;
    texture.type = fullOptions.type;
    texture.format = fullOptions.format;
    texture._generateDepthBuffer = fullOptions.generateDepthBuffer;
    texture._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;
    this._internalTexturesCache.push(texture);
    return texture;
  };
  NativeEngine2.prototype.updateTextureSamplingMode = function(samplingMode, texture) {
    if (texture._webGLTexture) {
      var filter = this._getNativeSamplingMode(samplingMode);
      this._native.setTextureSampling(texture._webGLTexture, filter);
    }
    texture.samplingMode = samplingMode;
  };
  NativeEngine2.prototype.bindFramebuffer = function(texture, faceIndex, requiredWidth, requiredHeight, forceFullscreenViewport) {
    if (faceIndex) {
      throw new Error("Cuboid frame buffers are not yet supported in NativeEngine.");
    }
    if (requiredWidth || requiredHeight) {
      throw new Error("Required width/height for frame buffers not yet supported in NativeEngine.");
    }
    if (forceFullscreenViewport) {
    }
    if (texture._depthStencilTexture) {
      this._bindUnboundFramebuffer(texture._depthStencilTexture._framebuffer);
    } else {
      this._bindUnboundFramebuffer(texture._framebuffer);
    }
  };
  NativeEngine2.prototype.unBindFramebuffer = function(texture, disableGenerateMipMaps, onBeforeUnbind) {
    if (disableGenerateMipMaps === void 0) {
      disableGenerateMipMaps = false;
    }
    if (disableGenerateMipMaps) {
      Logger.Warn("Disabling mipmap generation not yet supported in NativeEngine. Ignoring.");
    }
    if (onBeforeUnbind) {
      onBeforeUnbind();
    }
    this._bindUnboundFramebuffer(null);
  };
  NativeEngine2.prototype.createDynamicVertexBuffer = function(data) {
    return this.createVertexBuffer(data, true);
  };
  NativeEngine2.prototype.updateDynamicIndexBuffer = function(indexBuffer, indices, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    var buffer = indexBuffer;
    var data = this._normalizeIndexData(indices);
    buffer.is32Bits = data.BYTES_PER_ELEMENT === 4;
    this._native.updateDynamicIndexBuffer(buffer.nativeIndexBuffer, data, offset);
  };
  NativeEngine2.prototype.updateDynamicVertexBuffer = function(vertexBuffer, data, byteOffset, byteLength) {
    var buffer = vertexBuffer;
    var dataView = ArrayBuffer.isView(data) ? data : new Float32Array(data);
    this._native.updateDynamicVertexBuffer(buffer.nativeVertexBuffer, dataView, byteOffset !== null && byteOffset !== void 0 ? byteOffset : 0, byteLength !== null && byteLength !== void 0 ? byteLength : dataView.byteLength);
  };
  NativeEngine2.prototype._setTexture = function(channel, texture, isPartOfTextureArray, depthStencilTexture) {
    if (isPartOfTextureArray === void 0) {
      isPartOfTextureArray = false;
    }
    if (depthStencilTexture === void 0) {
      depthStencilTexture = false;
    }
    var uniform = this._boundUniforms[channel];
    if (!uniform) {
      return false;
    }
    if (!texture) {
      if (this._boundTexturesCache[channel] != null) {
        this._activeChannel = channel;
        this._native.setTexture(uniform, null);
      }
      return false;
    }
    if (texture.video) {
      this._activeChannel = channel;
      texture.update();
    } else if (texture.delayLoadState === 4) {
      texture.delayLoad();
      return false;
    }
    var internalTexture;
    if (depthStencilTexture) {
      internalTexture = texture.depthStencilTexture;
    } else if (texture.isReady()) {
      internalTexture = texture.getInternalTexture();
    } else if (texture.isCube) {
      internalTexture = this.emptyCubeTexture;
    } else if (texture.is3D) {
      internalTexture = this.emptyTexture3D;
    } else if (texture.is2DArray) {
      internalTexture = this.emptyTexture2DArray;
    } else {
      internalTexture = this.emptyTexture;
    }
    this._activeChannel = channel;
    if (!internalTexture || !internalTexture._webGLTexture) {
      return false;
    }
    this._native.setTextureWrapMode(internalTexture._webGLTexture, this._getAddressMode(texture.wrapU), this._getAddressMode(texture.wrapV), this._getAddressMode(texture.wrapR));
    this._updateAnisotropicLevel(texture);
    this._native.setTexture(uniform, internalTexture._webGLTexture);
    return true;
  };
  NativeEngine2.prototype._updateAnisotropicLevel = function(texture) {
    var internalTexture = texture.getInternalTexture();
    var value = texture.anisotropicFilteringLevel;
    if (!internalTexture || !internalTexture._webGLTexture) {
      return;
    }
    if (internalTexture._cachedAnisotropicFilteringLevel !== value) {
      this._native.setTextureAnisotropicLevel(internalTexture._webGLTexture, value);
      internalTexture._cachedAnisotropicFilteringLevel = value;
    }
  };
  NativeEngine2.prototype._getAddressMode = function(wrapMode) {
    switch (wrapMode) {
      case 1:
        return this._native.ADDRESS_MODE_WRAP;
      case 0:
        return this._native.ADDRESS_MODE_CLAMP;
      case 2:
        return this._native.ADDRESS_MODE_MIRROR;
      default:
        throw new Error("Unexpected wrap mode: " + wrapMode + ".");
    }
  };
  NativeEngine2.prototype._bindTexture = function(channel, texture) {
    var uniform = this._boundUniforms[channel];
    if (!uniform) {
      return;
    }
    this._native.setTexture(uniform, texture._webGLTexture);
  };
  NativeEngine2.prototype._deleteBuffer = function(buffer) {
    if (buffer.nativeIndexBuffer) {
      this._native.deleteIndexBuffer(buffer.nativeIndexBuffer);
      delete buffer.nativeIndexBuffer;
    }
    if (buffer.nativeVertexBuffer) {
      this._native.deleteVertexBuffer(buffer.nativeVertexBuffer);
      delete buffer.nativeVertexBuffer;
    }
  };
  NativeEngine2.prototype.releaseEffects = function() {
  };
  NativeEngine2.prototype._uploadCompressedDataToTextureDirectly = function(texture, internalFormat, width, height, data, faceIndex, lod) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lod === void 0) {
      lod = 0;
    }
    throw new Error("_uploadCompressedDataToTextureDirectly not implemented.");
  };
  NativeEngine2.prototype._uploadDataToTextureDirectly = function(texture, imageData, faceIndex, lod) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lod === void 0) {
      lod = 0;
    }
    throw new Error("_uploadDataToTextureDirectly not implemented.");
  };
  NativeEngine2.prototype._uploadArrayBufferViewToTexture = function(texture, imageData, faceIndex, lod) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lod === void 0) {
      lod = 0;
    }
    throw new Error("_uploadArrayBufferViewToTexture not implemented.");
  };
  NativeEngine2.prototype._uploadImageToTexture = function(texture, image, faceIndex, lod) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lod === void 0) {
      lod = 0;
    }
    throw new Error("_uploadArrayBufferViewToTexture not implemented.");
  };
  NativeEngine2.prototype._getNativeSamplingMode = function(samplingMode) {
    switch (samplingMode) {
      case 1:
        return this._native.TEXTURE_NEAREST_NEAREST;
      case 2:
        return this._native.TEXTURE_LINEAR_LINEAR;
      case 3:
        return this._native.TEXTURE_LINEAR_LINEAR_MIPLINEAR;
      case 4:
        return this._native.TEXTURE_NEAREST_NEAREST_MIPNEAREST;
      case 5:
        return this._native.TEXTURE_NEAREST_LINEAR_MIPNEAREST;
      case 6:
        return this._native.TEXTURE_NEAREST_LINEAR_MIPLINEAR;
      case 7:
        return this._native.TEXTURE_NEAREST_LINEAR;
      case 8:
        return this._native.TEXTURE_NEAREST_NEAREST_MIPLINEAR;
      case 9:
        return this._native.TEXTURE_LINEAR_NEAREST_MIPNEAREST;
      case 10:
        return this._native.TEXTURE_LINEAR_NEAREST_MIPLINEAR;
      case 11:
        return this._native.TEXTURE_LINEAR_LINEAR_MIPNEAREST;
      case 12:
        return this._native.TEXTURE_LINEAR_NEAREST;
      default:
        throw new Error("Unsupported sampling mode: " + samplingMode + ".");
    }
  };
  NativeEngine2.prototype._getNativeTextureFormat = function(format, type) {
    if (format == 5 && type == 0) {
      return this._native.TEXTURE_FORMAT_RGBA8;
    } else if (format == 5 && type == 1) {
      return this._native.TEXTURE_FORMAT_RGBA32F;
    } else {
      throw new Error("Unsupported texture format or type: format " + format + ", type " + type + ".");
    }
  };
  NativeEngine2.prototype._getNativeAlphaMode = function(mode) {
    switch (mode) {
      case 0:
        return this._native.ALPHA_DISABLE;
      case 1:
        return this._native.ALPHA_ADD;
      case 2:
        return this._native.ALPHA_COMBINE;
      case 3:
        return this._native.ALPHA_SUBTRACT;
      case 4:
        return this._native.ALPHA_MULTIPLY;
      case 5:
        return this._native.ALPHA_MAXIMIZED;
      case 6:
        return this._native.ALPHA_ONEONE;
      case 7:
        return this._native.ALPHA_PREMULTIPLIED;
      case 8:
        return this._native.ALPHA_PREMULTIPLIED_PORTERDUFF;
      case 9:
        return this._native.ALPHA_INTERPOLATE;
      case 10:
        return this._native.ALPHA_SCREENMODE;
      default:
        throw new Error("Unsupported alpha mode: " + mode + ".");
    }
  };
  NativeEngine2.prototype._getNativeAttribType = function(type) {
    switch (type) {
      case VertexBuffer.UNSIGNED_BYTE:
        return this._native.ATTRIB_TYPE_UINT8;
      case VertexBuffer.SHORT:
        return this._native.ATTRIB_TYPE_INT16;
      case VertexBuffer.FLOAT:
        return this._native.ATTRIB_TYPE_FLOAT;
      default:
        throw new Error("Unsupported attribute type: " + type + ".");
    }
  };
  return NativeEngine2;
}(Engine);

// node_modules/@babylonjs/core/Gamepads/Controllers/daydreamController.js
var DaydreamController = function(_super) {
  __extends(DaydreamController2, _super);
  function DaydreamController2(vrGamepad) {
    var _this = _super.call(this, vrGamepad) || this;
    _this.controllerType = PoseEnabledControllerType.DAYDREAM;
    return _this;
  }
  DaydreamController2.prototype.initControllerMesh = function(scene, meshLoaded) {
    var _this = this;
    SceneLoader.ImportMesh("", DaydreamController2.MODEL_BASE_URL, DaydreamController2.MODEL_FILENAME, scene, function(newMeshes) {
      _this._defaultModel = newMeshes[1];
      _this.attachToMesh(_this._defaultModel);
      if (meshLoaded) {
        meshLoaded(_this._defaultModel);
      }
    });
  };
  DaydreamController2.prototype._handleButtonChange = function(buttonIdx, state, changes) {
    if (buttonIdx === 0) {
      var observable = this.onTriggerStateChangedObservable;
      if (observable) {
        observable.notifyObservers(state);
      }
    } else {
      Logger.Warn("Unrecognized Daydream button index: " + buttonIdx);
    }
  };
  DaydreamController2.MODEL_BASE_URL = "https://controllers.babylonjs.com/generic/";
  DaydreamController2.MODEL_FILENAME = "generic.babylon";
  DaydreamController2.GAMEPAD_ID_PREFIX = "Daydream";
  return DaydreamController2;
}(WebVRController);
PoseEnabledControllerHelper._ControllerFactories.push({
  canCreate: function(gamepadInfo) {
    return gamepadInfo.id.indexOf(DaydreamController.GAMEPAD_ID_PREFIX) === 0;
  },
  create: function(gamepadInfo) {
    return new DaydreamController(gamepadInfo);
  }
});

// node_modules/@babylonjs/core/Gamepads/Controllers/gearVRController.js
var GearVRController = function(_super) {
  __extends(GearVRController2, _super);
  function GearVRController2(vrGamepad) {
    var _this = _super.call(this, vrGamepad) || this;
    _this._buttonIndexToObservableNameMap = [
      "onPadStateChangedObservable",
      "onTriggerStateChangedObservable"
    ];
    _this.controllerType = PoseEnabledControllerType.GEAR_VR;
    _this._calculatedPosition = new Vector3(_this.hand == "left" ? -0.15 : 0.15, -0.5, 0.25);
    _this._disableTrackPosition(_this._calculatedPosition);
    return _this;
  }
  GearVRController2.prototype.initControllerMesh = function(scene, meshLoaded) {
    var _this = this;
    SceneLoader.ImportMesh("", GearVRController2.MODEL_BASE_URL, GearVRController2.MODEL_FILENAME, scene, function(newMeshes) {
      var mesh = new Mesh("", scene);
      newMeshes[1].parent = mesh;
      newMeshes[1].position.z = -0.15;
      _this._defaultModel = mesh;
      _this.attachToMesh(_this._defaultModel);
      if (meshLoaded) {
        meshLoaded(_this._defaultModel);
      }
    });
  };
  GearVRController2.prototype._handleButtonChange = function(buttonIdx, state, changes) {
    if (buttonIdx < this._buttonIndexToObservableNameMap.length) {
      var observableName = this._buttonIndexToObservableNameMap[buttonIdx];
      var observable = this[observableName];
      if (observable) {
        observable.notifyObservers(state);
      }
    }
  };
  GearVRController2.MODEL_BASE_URL = "https://controllers.babylonjs.com/generic/";
  GearVRController2.MODEL_FILENAME = "generic.babylon";
  GearVRController2.GAMEPAD_ID_PREFIX = "Gear VR";
  return GearVRController2;
}(WebVRController);
PoseEnabledControllerHelper._ControllerFactories.push({
  canCreate: function(gamepadInfo) {
    return gamepadInfo.id.indexOf(GearVRController.GAMEPAD_ID_PREFIX) === 0 || gamepadInfo.id.indexOf("Oculus Go") !== -1 || gamepadInfo.id.indexOf("Vive Focus") !== -1;
  },
  create: function(gamepadInfo) {
    return new GearVRController(gamepadInfo);
  }
});

// node_modules/@babylonjs/core/Gamepads/Controllers/genericController.js
var GenericController = function(_super) {
  __extends(GenericController2, _super);
  function GenericController2(vrGamepad) {
    return _super.call(this, vrGamepad) || this;
  }
  GenericController2.prototype.initControllerMesh = function(scene, meshLoaded) {
    var _this = this;
    SceneLoader.ImportMesh("", GenericController2.MODEL_BASE_URL, GenericController2.MODEL_FILENAME, scene, function(newMeshes) {
      _this._defaultModel = newMeshes[1];
      _this.attachToMesh(_this._defaultModel);
      if (meshLoaded) {
        meshLoaded(_this._defaultModel);
      }
    });
  };
  GenericController2.prototype._handleButtonChange = function(buttonIdx, state, changes) {
    console.log("Button id: " + buttonIdx + "state: ");
    console.dir(state);
  };
  GenericController2.MODEL_BASE_URL = "https://controllers.babylonjs.com/generic/";
  GenericController2.MODEL_FILENAME = "generic.babylon";
  return GenericController2;
}(WebVRController);
PoseEnabledControllerHelper._DefaultControllerFactory = function(gamepadInfo) {
  return new GenericController(gamepadInfo);
};

// node_modules/@babylonjs/core/Gamepads/Controllers/oculusTouchController.js
var OculusTouchController = function(_super) {
  __extends(OculusTouchController2, _super);
  function OculusTouchController2(vrGamepad) {
    var _this = _super.call(this, vrGamepad) || this;
    _this.onSecondaryTriggerStateChangedObservable = new Observable();
    _this.onThumbRestChangedObservable = new Observable();
    _this.controllerType = PoseEnabledControllerType.OCULUS;
    return _this;
  }
  OculusTouchController2.prototype.initControllerMesh = function(scene, meshLoaded) {
    var _this = this;
    var meshName;
    if (this.hand === "left") {
      meshName = OculusTouchController2.MODEL_LEFT_FILENAME;
    } else {
      meshName = OculusTouchController2.MODEL_RIGHT_FILENAME;
    }
    SceneLoader.ImportMesh("", OculusTouchController2._IsQuest ? OculusTouchController2.QUEST_MODEL_BASE_URL : OculusTouchController2.MODEL_BASE_URL, meshName, scene, function(newMeshes) {
      _this._defaultModel = OculusTouchController2._IsQuest ? newMeshes[0] : newMeshes[1];
      _this.attachToMesh(_this._defaultModel);
      if (meshLoaded) {
        meshLoaded(_this._defaultModel);
      }
    });
  };
  Object.defineProperty(OculusTouchController2.prototype, "onAButtonStateChangedObservable", {
    get: function() {
      if (this.hand === "right") {
        return this.onMainButtonStateChangedObservable;
      } else {
        throw new Error("No A button on left hand");
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(OculusTouchController2.prototype, "onBButtonStateChangedObservable", {
    get: function() {
      if (this.hand === "right") {
        return this.onSecondaryButtonStateChangedObservable;
      } else {
        throw new Error("No B button on left hand");
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(OculusTouchController2.prototype, "onXButtonStateChangedObservable", {
    get: function() {
      if (this.hand === "left") {
        return this.onMainButtonStateChangedObservable;
      } else {
        throw new Error("No X button on right hand");
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(OculusTouchController2.prototype, "onYButtonStateChangedObservable", {
    get: function() {
      if (this.hand === "left") {
        return this.onSecondaryButtonStateChangedObservable;
      } else {
        throw new Error("No Y button on right hand");
      }
    },
    enumerable: false,
    configurable: true
  });
  OculusTouchController2.prototype._handleButtonChange = function(buttonIdx, state, changes) {
    var notifyObject = state;
    var triggerDirection = this.hand === "right" ? -1 : 1;
    switch (buttonIdx) {
      case 0:
        this.onPadStateChangedObservable.notifyObservers(notifyObject);
        return;
      case 1:
        if (!OculusTouchController2._IsQuest && this._defaultModel) {
          this._defaultModel.getChildren()[3].rotation.x = -notifyObject.value * 0.2;
          this._defaultModel.getChildren()[3].position.y = -notifyObject.value * 5e-3;
          this._defaultModel.getChildren()[3].position.z = -notifyObject.value * 5e-3;
        }
        this.onTriggerStateChangedObservable.notifyObservers(notifyObject);
        return;
      case 2:
        if (!OculusTouchController2._IsQuest && this._defaultModel) {
          this._defaultModel.getChildren()[4].position.x = triggerDirection * notifyObject.value * 35e-4;
        }
        this.onSecondaryTriggerStateChangedObservable.notifyObservers(notifyObject);
        return;
      case 3:
        if (!OculusTouchController2._IsQuest && this._defaultModel) {
          if (notifyObject.pressed) {
            this._defaultModel.getChildren()[1].position.y = -1e-3;
          } else {
            this._defaultModel.getChildren()[1].position.y = 0;
          }
        }
        this.onMainButtonStateChangedObservable.notifyObservers(notifyObject);
        return;
      case 4:
        if (!OculusTouchController2._IsQuest && this._defaultModel) {
          if (notifyObject.pressed) {
            this._defaultModel.getChildren()[2].position.y = -1e-3;
          } else {
            this._defaultModel.getChildren()[2].position.y = 0;
          }
        }
        this.onSecondaryButtonStateChangedObservable.notifyObservers(notifyObject);
        return;
      case 5:
        this.onThumbRestChangedObservable.notifyObservers(notifyObject);
        return;
    }
  };
  OculusTouchController2.MODEL_BASE_URL = "https://controllers.babylonjs.com/oculus/";
  OculusTouchController2.MODEL_LEFT_FILENAME = "left.babylon";
  OculusTouchController2.MODEL_RIGHT_FILENAME = "right.babylon";
  OculusTouchController2.QUEST_MODEL_BASE_URL = "https://controllers.babylonjs.com/oculusQuest/";
  OculusTouchController2._IsQuest = false;
  return OculusTouchController2;
}(WebVRController);
PoseEnabledControllerHelper._ControllerFactories.push({
  canCreate: function(gamepadInfo) {
    if (Engine.LastCreatedEngine && Engine.LastCreatedEngine._vrDisplay && Engine.LastCreatedEngine._vrDisplay.displayName === "Oculus Quest") {
      OculusTouchController._IsQuest = true;
    }
    return gamepadInfo.id.indexOf("Oculus Touch") !== -1;
  },
  create: function(gamepadInfo) {
    return new OculusTouchController(gamepadInfo);
  }
});

// node_modules/@babylonjs/core/Gamepads/Controllers/viveController.js
var ViveController = function(_super) {
  __extends(ViveController2, _super);
  function ViveController2(vrGamepad) {
    var _this = _super.call(this, vrGamepad) || this;
    _this.controllerType = PoseEnabledControllerType.VIVE;
    _this._invertLeftStickY = true;
    return _this;
  }
  ViveController2.prototype.initControllerMesh = function(scene, meshLoaded) {
    var _this = this;
    SceneLoader.ImportMesh("", ViveController2.MODEL_BASE_URL, ViveController2.MODEL_FILENAME, scene, function(newMeshes) {
      _this._defaultModel = newMeshes[1];
      _this.attachToMesh(_this._defaultModel);
      if (meshLoaded) {
        meshLoaded(_this._defaultModel);
      }
    });
  };
  Object.defineProperty(ViveController2.prototype, "onLeftButtonStateChangedObservable", {
    get: function() {
      return this.onMainButtonStateChangedObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ViveController2.prototype, "onRightButtonStateChangedObservable", {
    get: function() {
      return this.onMainButtonStateChangedObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ViveController2.prototype, "onMenuButtonStateChangedObservable", {
    get: function() {
      return this.onSecondaryButtonStateChangedObservable;
    },
    enumerable: false,
    configurable: true
  });
  ViveController2.prototype._handleButtonChange = function(buttonIdx, state, changes) {
    var notifyObject = state;
    switch (buttonIdx) {
      case 0:
        this.onPadStateChangedObservable.notifyObservers(notifyObject);
        return;
      case 1:
        if (this._defaultModel) {
          this._defaultModel.getChildren()[6].rotation.x = -notifyObject.value * 0.15;
        }
        this.onTriggerStateChangedObservable.notifyObservers(notifyObject);
        return;
      case 2:
        this.onMainButtonStateChangedObservable.notifyObservers(notifyObject);
        return;
      case 3:
        if (this._defaultModel) {
          if (notifyObject.pressed) {
            this._defaultModel.getChildren()[2].position.y = -1e-3;
          } else {
            this._defaultModel.getChildren()[2].position.y = 0;
          }
        }
        this.onSecondaryButtonStateChangedObservable.notifyObservers(notifyObject);
        return;
    }
  };
  ViveController2.MODEL_BASE_URL = "https://controllers.babylonjs.com/vive/";
  ViveController2.MODEL_FILENAME = "wand.babylon";
  return ViveController2;
}(WebVRController);
PoseEnabledControllerHelper._ControllerFactories.push({
  canCreate: function(gamepadInfo) {
    return gamepadInfo.id.toLowerCase().indexOf("openvr") !== -1;
  },
  create: function(gamepadInfo) {
    return new ViveController(gamepadInfo);
  }
});

// node_modules/@babylonjs/core/Gamepads/Controllers/windowsMotionController.js
var LoadedMeshInfo = function() {
  function LoadedMeshInfo2() {
    this.buttonMeshes = {};
    this.axisMeshes = {};
  }
  return LoadedMeshInfo2;
}();
var WindowsMotionController = function(_super) {
  __extends(WindowsMotionController2, _super);
  function WindowsMotionController2(vrGamepad) {
    var _this = _super.call(this, vrGamepad) || this;
    _this._mapping = {
      buttons: ["thumbstick", "trigger", "grip", "menu", "trackpad"],
      buttonMeshNames: {
        "trigger": "SELECT",
        "menu": "MENU",
        "grip": "GRASP",
        "thumbstick": "THUMBSTICK_PRESS",
        "trackpad": "TOUCHPAD_PRESS"
      },
      buttonObservableNames: {
        "trigger": "onTriggerStateChangedObservable",
        "menu": "onSecondaryButtonStateChangedObservable",
        "grip": "onMainButtonStateChangedObservable",
        "thumbstick": "onPadStateChangedObservable",
        "trackpad": "onTrackpadChangedObservable"
      },
      axisMeshNames: [
        "THUMBSTICK_X",
        "THUMBSTICK_Y",
        "TOUCHPAD_TOUCH_X",
        "TOUCHPAD_TOUCH_Y"
      ],
      pointingPoseMeshName: PoseEnabledController.POINTING_POSE
    };
    _this.onTrackpadChangedObservable = new Observable();
    _this.onTrackpadValuesChangedObservable = new Observable();
    _this.trackpad = { x: 0, y: 0 };
    _this.controllerType = PoseEnabledControllerType.WINDOWS;
    _this._loadedMeshInfo = null;
    return _this;
  }
  Object.defineProperty(WindowsMotionController2.prototype, "onTriggerButtonStateChangedObservable", {
    get: function() {
      return this.onTriggerStateChangedObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WindowsMotionController2.prototype, "onMenuButtonStateChangedObservable", {
    get: function() {
      return this.onSecondaryButtonStateChangedObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WindowsMotionController2.prototype, "onGripButtonStateChangedObservable", {
    get: function() {
      return this.onMainButtonStateChangedObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WindowsMotionController2.prototype, "onThumbstickButtonStateChangedObservable", {
    get: function() {
      return this.onPadStateChangedObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WindowsMotionController2.prototype, "onTouchpadButtonStateChangedObservable", {
    get: function() {
      return this.onTrackpadChangedObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WindowsMotionController2.prototype, "onTouchpadValuesChangedObservable", {
    get: function() {
      return this.onTrackpadValuesChangedObservable;
    },
    enumerable: false,
    configurable: true
  });
  WindowsMotionController2.prototype._updateTrackpad = function() {
    if (this.browserGamepad.axes && (this.browserGamepad.axes[2] != this.trackpad.x || this.browserGamepad.axes[3] != this.trackpad.y)) {
      this.trackpad.x = this.browserGamepad["axes"][this._mapping.axisMeshNames.indexOf("TOUCHPAD_TOUCH_X")];
      this.trackpad.y = this.browserGamepad["axes"][this._mapping.axisMeshNames.indexOf("TOUCHPAD_TOUCH_Y")];
      this.onTrackpadValuesChangedObservable.notifyObservers(this.trackpad);
    }
  };
  WindowsMotionController2.prototype.update = function() {
    _super.prototype.update.call(this);
    if (this.browserGamepad.axes) {
      this._updateTrackpad();
      if (this._loadedMeshInfo) {
        for (var axis = 0; axis < this._mapping.axisMeshNames.length; axis++) {
          this._lerpAxisTransform(axis, this.browserGamepad.axes[axis]);
        }
      }
    }
  };
  WindowsMotionController2.prototype._handleButtonChange = function(buttonIdx, state, changes) {
    var buttonName = this._mapping.buttons[buttonIdx];
    if (!buttonName) {
      return;
    }
    this._updateTrackpad();
    var observable = this[this._mapping.buttonObservableNames[buttonName]];
    if (observable) {
      observable.notifyObservers(state);
    }
    this._lerpButtonTransform(buttonName, state.value);
  };
  WindowsMotionController2.prototype._lerpButtonTransform = function(buttonName, buttonValue) {
    if (!this._loadedMeshInfo) {
      return;
    }
    var meshInfo = this._loadedMeshInfo.buttonMeshes[buttonName];
    if (!meshInfo || !meshInfo.unpressed.rotationQuaternion || !meshInfo.pressed.rotationQuaternion || !meshInfo.value.rotationQuaternion) {
      return;
    }
    Quaternion.SlerpToRef(meshInfo.unpressed.rotationQuaternion, meshInfo.pressed.rotationQuaternion, buttonValue, meshInfo.value.rotationQuaternion);
    Vector3.LerpToRef(meshInfo.unpressed.position, meshInfo.pressed.position, buttonValue, meshInfo.value.position);
  };
  WindowsMotionController2.prototype._lerpAxisTransform = function(axis, axisValue) {
    if (!this._loadedMeshInfo) {
      return;
    }
    var meshInfo = this._loadedMeshInfo.axisMeshes[axis];
    if (!meshInfo) {
      return;
    }
    if (!meshInfo.min.rotationQuaternion || !meshInfo.max.rotationQuaternion || !meshInfo.value.rotationQuaternion) {
      return;
    }
    var lerpValue = axisValue * 0.5 + 0.5;
    Quaternion.SlerpToRef(meshInfo.min.rotationQuaternion, meshInfo.max.rotationQuaternion, lerpValue, meshInfo.value.rotationQuaternion);
    Vector3.LerpToRef(meshInfo.min.position, meshInfo.max.position, lerpValue, meshInfo.value.position);
  };
  WindowsMotionController2.prototype.initControllerMesh = function(scene, meshLoaded, forceDefault) {
    var _this = this;
    if (forceDefault === void 0) {
      forceDefault = false;
    }
    var path;
    var filename;
    if (SceneLoader.IsPluginForExtensionAvailable(".glb")) {
      var device = "default";
      if (this.id && !forceDefault) {
        var match = this.id.match(WindowsMotionController2.GAMEPAD_ID_PATTERN);
        device = match && match[0] || device;
      }
      if (this.hand === "left") {
        filename = WindowsMotionController2.MODEL_LEFT_FILENAME;
      } else {
        filename = WindowsMotionController2.MODEL_RIGHT_FILENAME;
      }
      path = WindowsMotionController2.MODEL_BASE_URL + device + "/";
    } else {
      Logger.Warn("You need to reference GLTF loader to load Windows Motion Controllers model. Falling back to generic models");
      path = GenericController.MODEL_BASE_URL;
      filename = GenericController.MODEL_FILENAME;
    }
    SceneLoader.ImportMesh("", path, filename, scene, function(meshes) {
      _this._loadedMeshInfo = _this.processModel(scene, meshes);
      if (!_this._loadedMeshInfo) {
        return;
      }
      _this._defaultModel = _this._loadedMeshInfo.rootNode;
      _this.attachToMesh(_this._defaultModel);
      if (meshLoaded) {
        meshLoaded(_this._defaultModel);
      }
    }, null, function(scene2, message) {
      Logger.Log(message);
      Logger.Warn("Failed to retrieve controller model from the remote server: " + path + filename);
      if (!forceDefault) {
        _this.initControllerMesh(scene2, meshLoaded, true);
      }
    });
  };
  WindowsMotionController2.prototype.processModel = function(scene, meshes) {
    var loadedMeshInfo = null;
    var parentMesh = new Mesh(this.id + " " + this.hand, scene);
    var childMesh = null;
    for (var i = 0; i < meshes.length; i++) {
      var mesh = meshes[i];
      if (!mesh.parent) {
        mesh.isPickable = false;
        childMesh = mesh;
        break;
      }
    }
    if (childMesh) {
      childMesh.setParent(parentMesh);
      loadedMeshInfo = this.createMeshInfo(parentMesh);
    } else {
      Logger.Warn("Could not find root node in model file.");
    }
    return loadedMeshInfo;
  };
  WindowsMotionController2.prototype.createMeshInfo = function(rootNode) {
    var loadedMeshInfo = new LoadedMeshInfo();
    var i;
    loadedMeshInfo.rootNode = rootNode;
    loadedMeshInfo.buttonMeshes = {};
    loadedMeshInfo.axisMeshes = {};
    for (i = 0; i < this._mapping.buttons.length; i++) {
      var buttonMeshName = this._mapping.buttonMeshNames[this._mapping.buttons[i]];
      if (!buttonMeshName) {
        Logger.Log("Skipping unknown button at index: " + i + " with mapped name: " + this._mapping.buttons[i]);
        continue;
      }
      var buttonMesh = getChildByName(rootNode, buttonMeshName);
      if (!buttonMesh) {
        Logger.Warn("Missing button mesh with name: " + buttonMeshName);
        continue;
      }
      var buttonMeshInfo = {
        index: i,
        value: getImmediateChildByName(buttonMesh, "VALUE"),
        pressed: getImmediateChildByName(buttonMesh, "PRESSED"),
        unpressed: getImmediateChildByName(buttonMesh, "UNPRESSED")
      };
      if (buttonMeshInfo.value && buttonMeshInfo.pressed && buttonMeshInfo.unpressed) {
        loadedMeshInfo.buttonMeshes[this._mapping.buttons[i]] = buttonMeshInfo;
      } else {
        Logger.Warn("Missing button submesh under mesh with name: " + buttonMeshName + "(VALUE: " + !!buttonMeshInfo.value + ", PRESSED: " + !!buttonMeshInfo.pressed + ", UNPRESSED:" + !!buttonMeshInfo.unpressed + ")");
      }
    }
    for (i = 0; i < this._mapping.axisMeshNames.length; i++) {
      var axisMeshName = this._mapping.axisMeshNames[i];
      if (!axisMeshName) {
        Logger.Log("Skipping unknown axis at index: " + i);
        continue;
      }
      var axisMesh = getChildByName(rootNode, axisMeshName);
      if (!axisMesh) {
        Logger.Warn("Missing axis mesh with name: " + axisMeshName);
        continue;
      }
      var axisMeshInfo = {
        index: i,
        value: getImmediateChildByName(axisMesh, "VALUE"),
        min: getImmediateChildByName(axisMesh, "MIN"),
        max: getImmediateChildByName(axisMesh, "MAX")
      };
      if (axisMeshInfo.value && axisMeshInfo.min && axisMeshInfo.max) {
        loadedMeshInfo.axisMeshes[i] = axisMeshInfo;
      } else {
        Logger.Warn("Missing axis submesh under mesh with name: " + axisMeshName + "(VALUE: " + !!axisMeshInfo.value + ", MIN: " + !!axisMeshInfo.min + ", MAX:" + !!axisMeshInfo.max + ")");
      }
    }
    loadedMeshInfo.pointingPoseNode = getChildByName(rootNode, this._mapping.pointingPoseMeshName);
    if (!loadedMeshInfo.pointingPoseNode) {
      Logger.Warn("Missing pointing pose mesh with name: " + this._mapping.pointingPoseMeshName);
    } else {
      this._pointingPoseNode = loadedMeshInfo.pointingPoseNode;
    }
    return loadedMeshInfo;
    function getChildByName(node, name98) {
      return node.getChildren(function(n) {
        return n.name === name98;
      }, false)[0];
    }
    function getImmediateChildByName(node, name98) {
      return node.getChildren(function(n) {
        return n.name == name98;
      }, true)[0];
    }
  };
  WindowsMotionController2.prototype.getForwardRay = function(length) {
    if (length === void 0) {
      length = 100;
    }
    if (!(this._loadedMeshInfo && this._loadedMeshInfo.pointingPoseNode)) {
      return _super.prototype.getForwardRay.call(this, length);
    }
    var m = this._loadedMeshInfo.pointingPoseNode.getWorldMatrix();
    var origin = m.getTranslation();
    var forward = new Vector3(0, 0, -1);
    var forwardWorld = Vector3.TransformNormal(forward, m);
    var direction = Vector3.Normalize(forwardWorld);
    return new Ray(origin, direction, length);
  };
  WindowsMotionController2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this.onTrackpadChangedObservable.clear();
    this.onTrackpadValuesChangedObservable.clear();
  };
  WindowsMotionController2.MODEL_BASE_URL = "https://controllers.babylonjs.com/microsoft/";
  WindowsMotionController2.MODEL_LEFT_FILENAME = "left.glb";
  WindowsMotionController2.MODEL_RIGHT_FILENAME = "right.glb";
  WindowsMotionController2.GAMEPAD_ID_PREFIX = "Spatial Controller (Spatial Interaction Source) ";
  WindowsMotionController2.GAMEPAD_ID_PATTERN = /([0-9a-zA-Z]+-[0-9a-zA-Z]+)$/;
  return WindowsMotionController2;
}(WebVRController);
var XRWindowsMotionController = function(_super) {
  __extends(XRWindowsMotionController2, _super);
  function XRWindowsMotionController2(gamepadInfo) {
    var _this = _super.call(this, gamepadInfo) || this;
    _this._mapping = {
      buttons: ["trigger", "grip", "trackpad", "thumbstick", "menu"],
      buttonMeshNames: {
        "trigger": "SELECT",
        "menu": "MENU",
        "grip": "GRASP",
        "thumbstick": "THUMBSTICK_PRESS",
        "trackpad": "TOUCHPAD_PRESS"
      },
      buttonObservableNames: {
        "trigger": "onTriggerStateChangedObservable",
        "menu": "onSecondaryButtonStateChangedObservable",
        "grip": "onMainButtonStateChangedObservable",
        "thumbstick": "onThumbstickStateChangedObservable",
        "trackpad": "onTrackpadChangedObservable"
      },
      axisMeshNames: [
        "TOUCHPAD_TOUCH_X",
        "TOUCHPAD_TOUCH_Y",
        "THUMBSTICK_X",
        "THUMBSTICK_Y"
      ],
      pointingPoseMeshName: PoseEnabledController.POINTING_POSE
    };
    _this.thumbstickValues = { x: 0, y: 0 };
    _this.onThumbstickStateChangedObservable = new Observable();
    _this.onThumbstickValuesChangedObservable = new Observable();
    _this.onTrackpadChangedObservable = _this.onPadStateChangedObservable;
    _this.onTrackpadValuesChangedObservable = _this.onPadValuesChangedObservable;
    return _this;
  }
  Object.defineProperty(XRWindowsMotionController2.prototype, "onThumbstickButtonStateChangedObservable", {
    get: function() {
      return this.onThumbstickStateChangedObservable;
    },
    enumerable: false,
    configurable: true
  });
  XRWindowsMotionController2.prototype._updateTrackpad = function() {
    if (this.browserGamepad.axes && (this.browserGamepad.axes[2] != this.thumbstickValues.x || this.browserGamepad.axes[3] != this.thumbstickValues.y)) {
      this.trackpad.x = this.browserGamepad["axes"][2];
      this.trackpad.y = this.browserGamepad["axes"][3];
      this.onThumbstickValuesChangedObservable.notifyObservers(this.trackpad);
    }
  };
  XRWindowsMotionController2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this.onThumbstickStateChangedObservable.clear();
    this.onThumbstickValuesChangedObservable.clear();
  };
  return XRWindowsMotionController2;
}(WindowsMotionController);
PoseEnabledControllerHelper._ControllerFactories.push({
  canCreate: function(gamepadInfo) {
    return gamepadInfo.id.indexOf(WindowsMotionController.GAMEPAD_ID_PREFIX) === 0;
  },
  create: function(gamepadInfo) {
    return new WindowsMotionController(gamepadInfo);
  }
});

// node_modules/@babylonjs/core/Gizmos/axisScaleGizmo.js
var AxisScaleGizmo = function(_super) {
  __extends(AxisScaleGizmo2, _super);
  function AxisScaleGizmo2(dragAxis, color, gizmoLayer, parent, thickness) {
    if (color === void 0) {
      color = Color3.Gray();
    }
    if (gizmoLayer === void 0) {
      gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer;
    }
    if (parent === void 0) {
      parent = null;
    }
    if (thickness === void 0) {
      thickness = 1;
    }
    var _a, _b, _c, _d, _e, _f, _g;
    var _this = _super.call(this, gizmoLayer) || this;
    _this._pointerObserver = null;
    _this.snapDistance = 0;
    _this.onSnapObservable = new Observable();
    _this.uniformScaling = false;
    _this.sensitivity = 1;
    _this._isEnabled = true;
    _this._parent = null;
    _this._dragging = false;
    _this._tmpVector = new Vector3();
    _this._tmpMatrix = new Matrix();
    _this._tmpMatrix2 = new Matrix();
    _this._parent = parent;
    _this._coloredMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
    _this._coloredMaterial.diffuseColor = color;
    _this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));
    _this._hoverMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
    _this._hoverMaterial.diffuseColor = Color3.Yellow();
    _this._disableMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
    _this._disableMaterial.diffuseColor = Color3.Gray();
    _this._disableMaterial.alpha = 0.4;
    _this._gizmoMesh = new Mesh("axis", gizmoLayer.utilityLayerScene);
    var _h = _this._createGizmoMesh(_this._gizmoMesh, thickness), arrowMesh = _h.arrowMesh, arrowTail = _h.arrowTail;
    var collider = _this._createGizmoMesh(_this._gizmoMesh, thickness + 4, true);
    _this._gizmoMesh.lookAt(_this._rootMesh.position.add(dragAxis));
    _this._rootMesh.addChild(_this._gizmoMesh);
    _this._gizmoMesh.scaling.scaleInPlace(1 / 3);
    var nodePosition = arrowMesh.position.clone();
    var linePosition = arrowTail.position.clone();
    var lineScale = arrowTail.scaling.clone();
    var increaseGizmoMesh = function(dragDistance) {
      var dragStrength = dragDistance * (3 / _this._rootMesh.scaling.length()) * 6;
      arrowMesh.position.z += dragStrength / 3.5;
      arrowTail.scaling.y += dragStrength;
      arrowTail.position.z = arrowMesh.position.z / 2;
    };
    var resetGizmoMesh = function() {
      arrowMesh.position.set(nodePosition.x, nodePosition.y, nodePosition.z);
      arrowTail.position.set(linePosition.x, linePosition.y, linePosition.z);
      arrowTail.scaling.set(lineScale.x, lineScale.y, lineScale.z);
      _this._dragging = false;
    };
    _this.dragBehavior = new PointerDragBehavior({ dragAxis });
    _this.dragBehavior.moveAttached = false;
    _this._rootMesh.addBehavior(_this.dragBehavior);
    var currentSnapDragDistance = 0;
    var tmpVector = new Vector3();
    var tmpSnapEvent = { snapDistance: 0 };
    _this.dragBehavior.onDragObservable.add(function(event) {
      if (_this.attachedNode) {
        var dragStrength = _this.sensitivity * event.dragDistance * (_this.scaleRatio * 3 / _this._rootMesh.scaling.length());
        var snapped = false;
        var dragSteps = 0;
        if (_this.uniformScaling) {
          _this.attachedNode.getWorldMatrix().decompose(tmpVector);
          tmpVector.normalize();
          if (tmpVector.y < 0) {
            tmpVector.scaleInPlace(-1);
          }
        } else {
          tmpVector.copyFrom(dragAxis);
        }
        if (_this.snapDistance == 0) {
          tmpVector.scaleToRef(dragStrength, tmpVector);
        } else {
          currentSnapDragDistance += dragStrength;
          if (Math.abs(currentSnapDragDistance) > _this.snapDistance) {
            dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / _this.snapDistance);
            if (currentSnapDragDistance < 0) {
              dragSteps *= -1;
            }
            currentSnapDragDistance = currentSnapDragDistance % _this.snapDistance;
            tmpVector.scaleToRef(_this.snapDistance * dragSteps, tmpVector);
            snapped = true;
          } else {
            tmpVector.scaleInPlace(0);
          }
        }
        Matrix.ScalingToRef(1 + tmpVector.x, 1 + tmpVector.y, 1 + tmpVector.z, _this._tmpMatrix2);
        _this._tmpMatrix2.multiplyToRef(_this.attachedNode.getWorldMatrix(), _this._tmpMatrix);
        _this._tmpMatrix.decompose(_this._tmpVector);
        var maxScale = 1e5;
        if (Math.abs(_this._tmpVector.x) < maxScale && Math.abs(_this._tmpVector.y) < maxScale && Math.abs(_this._tmpVector.z) < maxScale) {
          _this.attachedNode.getWorldMatrix().copyFrom(_this._tmpMatrix);
        }
        if (snapped) {
          tmpSnapEvent.snapDistance = _this.snapDistance * dragSteps;
          _this.onSnapObservable.notifyObservers(tmpSnapEvent);
        }
        _this._matrixChanged();
      }
    });
    _this.dragBehavior.onDragStartObservable.add(function() {
      _this._dragging = true;
    });
    _this.dragBehavior.onDragObservable.add(function(e) {
      return increaseGizmoMesh(e.dragDistance);
    });
    _this.dragBehavior.onDragEndObservable.add(resetGizmoMesh);
    (_c = (_b = (_a = parent === null || parent === void 0 ? void 0 : parent.uniformScaleGizmo) === null || _a === void 0 ? void 0 : _a.dragBehavior) === null || _b === void 0 ? void 0 : _b.onDragObservable) === null || _c === void 0 ? void 0 : _c.add(function(e) {
      return increaseGizmoMesh(e.delta.y);
    });
    (_f = (_e = (_d = parent === null || parent === void 0 ? void 0 : parent.uniformScaleGizmo) === null || _d === void 0 ? void 0 : _d.dragBehavior) === null || _e === void 0 ? void 0 : _e.onDragEndObservable) === null || _f === void 0 ? void 0 : _f.add(resetGizmoMesh);
    var cache = {
      gizmoMeshes: [arrowMesh, arrowTail],
      colliderMeshes: [collider.arrowMesh, collider.arrowTail],
      material: _this._coloredMaterial,
      hoverMaterial: _this._hoverMaterial,
      disableMaterial: _this._disableMaterial,
      active: false
    };
    (_g = _this._parent) === null || _g === void 0 ? void 0 : _g.addToAxisCache(_this._gizmoMesh, cache);
    _this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function(pointerInfo) {
      var _a2;
      if (_this._customMeshSet) {
        return;
      }
      _this._isHovered = !!(cache.colliderMeshes.indexOf((_a2 = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _a2 === void 0 ? void 0 : _a2.pickedMesh) != -1);
      if (!_this._parent) {
        var material = _this._isHovered || _this._dragging ? _this._hoverMaterial : _this._coloredMaterial;
        cache.gizmoMeshes.forEach(function(m) {
          m.material = material;
          if (m.color) {
            m.color = material.diffuseColor;
          }
        });
      }
    });
    var light = gizmoLayer._getSharedGizmoLight();
    light.includedOnlyMeshes = light.includedOnlyMeshes.concat(_this._rootMesh.getChildMeshes());
    return _this;
  }
  AxisScaleGizmo2.prototype._createGizmoMesh = function(parentMesh, thickness, isCollider) {
    if (isCollider === void 0) {
      isCollider = false;
    }
    var arrowMesh = BoxBuilder.CreateBox("yPosMesh", { size: 0.4 * (1 + (thickness - 1) / 4) }, this.gizmoLayer.utilityLayerScene);
    var arrowTail = CylinderBuilder.CreateCylinder("cylinder", { diameterTop: 5e-3 * thickness, height: 0.275, diameterBottom: 5e-3 * thickness, tessellation: 96 }, this.gizmoLayer.utilityLayerScene);
    arrowMesh.scaling.scaleInPlace(0.1);
    arrowMesh.material = this._coloredMaterial;
    arrowMesh.rotation.x = Math.PI / 2;
    arrowMesh.position.z += 0.3;
    arrowTail.material = this._coloredMaterial;
    arrowTail.position.z += 0.275 / 2;
    arrowTail.rotation.x = Math.PI / 2;
    if (isCollider) {
      arrowMesh.visibility = 0;
      arrowTail.visibility = 0;
    }
    parentMesh.addChild(arrowMesh);
    parentMesh.addChild(arrowTail);
    return { arrowMesh, arrowTail };
  };
  AxisScaleGizmo2.prototype._attachedNodeChanged = function(value) {
    if (this.dragBehavior) {
      this.dragBehavior.enabled = value ? true : false;
    }
  };
  Object.defineProperty(AxisScaleGizmo2.prototype, "isEnabled", {
    get: function() {
      return this._isEnabled;
    },
    set: function(value) {
      this._isEnabled = value;
      if (!value) {
        this.attachedMesh = null;
        this.attachedNode = null;
      } else {
        if (this._parent) {
          this.attachedMesh = this._parent.attachedMesh;
          this.attachedNode = this._parent.attachedNode;
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  AxisScaleGizmo2.prototype.dispose = function() {
    this.onSnapObservable.clear();
    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
    this.dragBehavior.detach();
    if (this._gizmoMesh) {
      this._gizmoMesh.dispose();
    }
    [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach(function(matl) {
      if (matl) {
        matl.dispose();
      }
    });
    _super.prototype.dispose.call(this);
  };
  AxisScaleGizmo2.prototype.setCustomMesh = function(mesh, useGizmoMaterial) {
    var _this = this;
    if (useGizmoMaterial === void 0) {
      useGizmoMaterial = false;
    }
    _super.prototype.setCustomMesh.call(this, mesh);
    if (useGizmoMaterial) {
      this._rootMesh.getChildMeshes().forEach(function(m) {
        m.material = _this._coloredMaterial;
        if (m.color) {
          m.color = _this._coloredMaterial.diffuseColor;
        }
      });
      this._customMeshSet = false;
    }
  };
  return AxisScaleGizmo2;
}(Gizmo);

// node_modules/@babylonjs/core/Gizmos/boundingBoxGizmo.js
var BoundingBoxGizmo = function(_super) {
  __extends(BoundingBoxGizmo2, _super);
  function BoundingBoxGizmo2(color, gizmoLayer) {
    if (color === void 0) {
      color = Color3.Gray();
    }
    if (gizmoLayer === void 0) {
      gizmoLayer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer;
    }
    var _this = _super.call(this, gizmoLayer) || this;
    _this._boundingDimensions = new Vector3(1, 1, 1);
    _this._renderObserver = null;
    _this._pointerObserver = null;
    _this._scaleDragSpeed = 0.2;
    _this._tmpQuaternion = new Quaternion();
    _this._tmpVector = new Vector3(0, 0, 0);
    _this._tmpRotationMatrix = new Matrix();
    _this.ignoreChildren = false;
    _this.includeChildPredicate = null;
    _this.rotationSphereSize = 0.1;
    _this.scaleBoxSize = 0.1;
    _this.fixedDragMeshScreenSize = false;
    _this.fixedDragMeshBoundsSize = false;
    _this.fixedDragMeshScreenSizeDistanceFactor = 10;
    _this.onDragStartObservable = new Observable();
    _this.onScaleBoxDragObservable = new Observable();
    _this.onScaleBoxDragEndObservable = new Observable();
    _this.onRotationSphereDragObservable = new Observable();
    _this.onRotationSphereDragEndObservable = new Observable();
    _this.scalePivot = null;
    _this._existingMeshScale = new Vector3();
    _this._dragMesh = null;
    _this.pointerDragBehavior = new PointerDragBehavior();
    _this.updateScale = false;
    _this._anchorMesh = new AbstractMesh("anchor", gizmoLayer.utilityLayerScene);
    _this.coloredMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
    _this.coloredMaterial.disableLighting = true;
    _this.hoverColoredMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
    _this.hoverColoredMaterial.disableLighting = true;
    _this._lineBoundingBox = new AbstractMesh("", gizmoLayer.utilityLayerScene);
    _this._lineBoundingBox.rotationQuaternion = new Quaternion();
    var lines = [];
    lines.push(LinesBuilder.CreateLines("lines", { points: [new Vector3(0, 0, 0), new Vector3(_this._boundingDimensions.x, 0, 0)] }, gizmoLayer.utilityLayerScene));
    lines.push(LinesBuilder.CreateLines("lines", { points: [new Vector3(0, 0, 0), new Vector3(0, _this._boundingDimensions.y, 0)] }, gizmoLayer.utilityLayerScene));
    lines.push(LinesBuilder.CreateLines("lines", { points: [new Vector3(0, 0, 0), new Vector3(0, 0, _this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));
    lines.push(LinesBuilder.CreateLines("lines", { points: [new Vector3(_this._boundingDimensions.x, 0, 0), new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, 0)] }, gizmoLayer.utilityLayerScene));
    lines.push(LinesBuilder.CreateLines("lines", { points: [new Vector3(_this._boundingDimensions.x, 0, 0), new Vector3(_this._boundingDimensions.x, 0, _this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));
    lines.push(LinesBuilder.CreateLines("lines", { points: [new Vector3(0, _this._boundingDimensions.y, 0), new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, 0)] }, gizmoLayer.utilityLayerScene));
    lines.push(LinesBuilder.CreateLines("lines", { points: [new Vector3(0, _this._boundingDimensions.y, 0), new Vector3(0, _this._boundingDimensions.y, _this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));
    lines.push(LinesBuilder.CreateLines("lines", { points: [new Vector3(0, 0, _this._boundingDimensions.z), new Vector3(_this._boundingDimensions.x, 0, _this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));
    lines.push(LinesBuilder.CreateLines("lines", { points: [new Vector3(0, 0, _this._boundingDimensions.z), new Vector3(0, _this._boundingDimensions.y, _this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));
    lines.push(LinesBuilder.CreateLines("lines", { points: [new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, _this._boundingDimensions.z), new Vector3(0, _this._boundingDimensions.y, _this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));
    lines.push(LinesBuilder.CreateLines("lines", { points: [new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, _this._boundingDimensions.z), new Vector3(_this._boundingDimensions.x, 0, _this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));
    lines.push(LinesBuilder.CreateLines("lines", { points: [new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, _this._boundingDimensions.z), new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, 0)] }, gizmoLayer.utilityLayerScene));
    lines.forEach(function(l) {
      l.color = color;
      l.position.addInPlace(new Vector3(-_this._boundingDimensions.x / 2, -_this._boundingDimensions.y / 2, -_this._boundingDimensions.z / 2));
      l.isPickable = false;
      _this._lineBoundingBox.addChild(l);
    });
    _this._rootMesh.addChild(_this._lineBoundingBox);
    _this.setColor(color);
    _this._rotateSpheresParent = new AbstractMesh("", gizmoLayer.utilityLayerScene);
    _this._rotateSpheresParent.rotationQuaternion = new Quaternion();
    var _loop_1 = function(i_12) {
      var sphere = SphereBuilder.CreateSphere("", { diameter: 1 }, gizmoLayer.utilityLayerScene);
      sphere.rotationQuaternion = new Quaternion();
      sphere.material = this_1.coloredMaterial;
      _dragBehavior = new PointerDragBehavior({});
      _dragBehavior.moveAttached = false;
      _dragBehavior.updateDragPlane = false;
      sphere.addBehavior(_dragBehavior);
      var startingTurnDirection = new Vector3(1, 0, 0);
      var totalTurnAmountOfDrag = 0;
      _dragBehavior.onDragStartObservable.add(function() {
        startingTurnDirection.copyFrom(sphere.forward);
        totalTurnAmountOfDrag = 0;
      });
      _dragBehavior.onDragObservable.add(function(event) {
        _this.onRotationSphereDragObservable.notifyObservers({});
        if (_this.attachedMesh) {
          var originalParent = _this.attachedMesh.parent;
          if (originalParent && (originalParent.scaling && originalParent.scaling.isNonUniformWithinEpsilon(1e-3))) {
            Logger.Warn("BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling");
            return;
          }
          PivotTools._RemoveAndStorePivotPoint(_this.attachedMesh);
          var worldDragDirection = startingTurnDirection;
          var toSub = event.dragPlaneNormal.scale(Vector3.Dot(event.dragPlaneNormal, worldDragDirection));
          var dragAxis = worldDragDirection.subtract(toSub).normalizeToNew();
          var projectDist = Vector3.Dot(dragAxis, event.delta) < 0 ? Math.abs(event.delta.length()) : -Math.abs(event.delta.length());
          projectDist = projectDist / _this._boundingDimensions.length() * _this._anchorMesh.scaling.length();
          if (!_this.attachedMesh.rotationQuaternion) {
            _this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(_this.attachedMesh.rotation.y, _this.attachedMesh.rotation.x, _this.attachedMesh.rotation.z);
          }
          if (!_this._anchorMesh.rotationQuaternion) {
            _this._anchorMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(_this._anchorMesh.rotation.y, _this._anchorMesh.rotation.x, _this._anchorMesh.rotation.z);
          }
          totalTurnAmountOfDrag += projectDist;
          if (Math.abs(totalTurnAmountOfDrag) <= 2 * Math.PI) {
            if (i_12 >= 8) {
              Quaternion.RotationYawPitchRollToRef(0, 0, projectDist, _this._tmpQuaternion);
            } else if (i_12 >= 4) {
              Quaternion.RotationYawPitchRollToRef(projectDist, 0, 0, _this._tmpQuaternion);
            } else {
              Quaternion.RotationYawPitchRollToRef(0, projectDist, 0, _this._tmpQuaternion);
            }
            _this._anchorMesh.addChild(_this.attachedMesh);
            _this._anchorMesh.rotationQuaternion.multiplyToRef(_this._tmpQuaternion, _this._anchorMesh.rotationQuaternion);
            _this._anchorMesh.removeChild(_this.attachedMesh);
            _this.attachedMesh.setParent(originalParent);
          }
          _this.updateBoundingBox();
          PivotTools._RestorePivotPoint(_this.attachedMesh);
        }
        _this._updateDummy();
      });
      _dragBehavior.onDragStartObservable.add(function() {
        _this.onDragStartObservable.notifyObservers({});
        _this._selectNode(sphere);
      });
      _dragBehavior.onDragEndObservable.add(function() {
        _this.onRotationSphereDragEndObservable.notifyObservers({});
        _this._selectNode(null);
        _this._updateDummy();
      });
      this_1._rotateSpheresParent.addChild(sphere);
    };
    var this_1 = this, _dragBehavior;
    for (var i_1 = 0; i_1 < 12; i_1++) {
      _loop_1(i_1);
    }
    _this._rootMesh.addChild(_this._rotateSpheresParent);
    _this._scaleBoxesParent = new AbstractMesh("", gizmoLayer.utilityLayerScene);
    _this._scaleBoxesParent.rotationQuaternion = new Quaternion();
    for (var i = 0; i < 3; i++) {
      for (var j = 0; j < 3; j++) {
        var _loop_2 = function() {
          var zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);
          if (zeroAxisCount === 1 || zeroAxisCount === 3) {
            return "continue";
          }
          var box = BoxBuilder.CreateBox("", { size: 1 }, gizmoLayer.utilityLayerScene);
          box.material = this_2.coloredMaterial;
          box.metadata = zeroAxisCount === 2;
          var dragAxis = new Vector3(i - 1, j - 1, k - 1).normalize();
          _dragBehavior = new PointerDragBehavior({ dragAxis });
          _dragBehavior.updateDragPlane = false;
          _dragBehavior.moveAttached = false;
          box.addBehavior(_dragBehavior);
          _dragBehavior.onDragObservable.add(function(event) {
            _this.onScaleBoxDragObservable.notifyObservers({});
            if (_this.attachedMesh) {
              var originalParent = _this.attachedMesh.parent;
              if (originalParent && (originalParent.scaling && originalParent.scaling.isNonUniformWithinEpsilon(1e-3))) {
                Logger.Warn("BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling");
                return;
              }
              PivotTools._RemoveAndStorePivotPoint(_this.attachedMesh);
              var relativeDragDistance = event.dragDistance / _this._boundingDimensions.length() * _this._anchorMesh.scaling.length();
              var deltaScale = new Vector3(relativeDragDistance, relativeDragDistance, relativeDragDistance);
              if (zeroAxisCount === 2) {
                deltaScale.x *= Math.abs(dragAxis.x);
                deltaScale.y *= Math.abs(dragAxis.y);
                deltaScale.z *= Math.abs(dragAxis.z);
              }
              deltaScale.scaleInPlace(_this._scaleDragSpeed);
              _this.updateBoundingBox();
              if (_this.scalePivot) {
                _this.attachedMesh.getWorldMatrix().getRotationMatrixToRef(_this._tmpRotationMatrix);
                _this._boundingDimensions.scaleToRef(0.5, _this._tmpVector);
                Vector3.TransformCoordinatesToRef(_this._tmpVector, _this._tmpRotationMatrix, _this._tmpVector);
                _this._anchorMesh.position.subtractInPlace(_this._tmpVector);
                _this._boundingDimensions.multiplyToRef(_this.scalePivot, _this._tmpVector);
                Vector3.TransformCoordinatesToRef(_this._tmpVector, _this._tmpRotationMatrix, _this._tmpVector);
                _this._anchorMesh.position.addInPlace(_this._tmpVector);
              } else {
                box.absolutePosition.subtractToRef(_this._anchorMesh.position, _this._tmpVector);
                _this._anchorMesh.position.subtractInPlace(_this._tmpVector);
              }
              _this._anchorMesh.addChild(_this.attachedMesh);
              _this._anchorMesh.scaling.addInPlace(deltaScale);
              if (_this._anchorMesh.scaling.x < 0 || _this._anchorMesh.scaling.y < 0 || _this._anchorMesh.scaling.z < 0) {
                _this._anchorMesh.scaling.subtractInPlace(deltaScale);
              }
              _this._anchorMesh.removeChild(_this.attachedMesh);
              _this.attachedMesh.setParent(originalParent);
              PivotTools._RestorePivotPoint(_this.attachedMesh);
            }
            _this._updateDummy();
          });
          _dragBehavior.onDragStartObservable.add(function() {
            _this.onDragStartObservable.notifyObservers({});
            _this._selectNode(box);
          });
          _dragBehavior.onDragEndObservable.add(function() {
            _this.onScaleBoxDragEndObservable.notifyObservers({});
            _this._selectNode(null);
            _this._updateDummy();
          });
          this_2._scaleBoxesParent.addChild(box);
        };
        var this_2 = this, _dragBehavior;
        for (var k = 0; k < 3; k++) {
          _loop_2();
        }
      }
    }
    _this._rootMesh.addChild(_this._scaleBoxesParent);
    var pointerIds = new Array();
    _this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function(pointerInfo) {
      if (!pointerIds[pointerInfo.event.pointerId]) {
        _this._rotateSpheresParent.getChildMeshes().concat(_this._scaleBoxesParent.getChildMeshes()).forEach(function(mesh) {
          if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh == mesh) {
            pointerIds[pointerInfo.event.pointerId] = mesh;
            mesh.material = _this.hoverColoredMaterial;
          }
        });
      } else {
        if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh != pointerIds[pointerInfo.event.pointerId]) {
          pointerIds[pointerInfo.event.pointerId].material = _this.coloredMaterial;
          delete pointerIds[pointerInfo.event.pointerId];
        }
      }
    });
    _this._renderObserver = _this.gizmoLayer.originalScene.onBeforeRenderObservable.add(function() {
      if (_this.attachedMesh && !_this._existingMeshScale.equals(_this.attachedMesh.scaling)) {
        _this.updateBoundingBox();
      } else if (_this.fixedDragMeshScreenSize || _this.fixedDragMeshBoundsSize) {
        _this._updateRotationSpheres();
        _this._updateScaleBoxes();
      }
      if (_this._dragMesh && _this.attachedMesh && _this.pointerDragBehavior.dragging) {
        _this._lineBoundingBox.position.rotateByQuaternionToRef(_this._rootMesh.rotationQuaternion, _this._tmpVector);
        _this.attachedMesh.setAbsolutePosition(_this._dragMesh.position.add(_this._tmpVector.scale(-1)));
      }
    });
    _this.updateBoundingBox();
    return _this;
  }
  BoundingBoxGizmo2.prototype.setColor = function(color) {
    this.coloredMaterial.emissiveColor = color;
    this.hoverColoredMaterial.emissiveColor = color.clone().add(new Color3(0.3, 0.3, 0.3));
    this._lineBoundingBox.getChildren().forEach(function(l) {
      if (l.color) {
        l.color = color;
      }
    });
  };
  BoundingBoxGizmo2.prototype._attachedNodeChanged = function(value) {
    var _this = this;
    if (value) {
      PivotTools._RemoveAndStorePivotPoint(value);
      var originalParent = value.parent;
      this._anchorMesh.addChild(value);
      this._anchorMesh.removeChild(value);
      value.setParent(originalParent);
      PivotTools._RestorePivotPoint(value);
      this.updateBoundingBox();
      value.getChildMeshes(false).forEach(function(m) {
        m.markAsDirty("scaling");
      });
      this.gizmoLayer.utilityLayerScene.onAfterRenderObservable.addOnce(function() {
        _this._updateDummy();
      });
    }
  };
  BoundingBoxGizmo2.prototype._selectNode = function(selectedMesh) {
    this._rotateSpheresParent.getChildMeshes().concat(this._scaleBoxesParent.getChildMeshes()).forEach(function(m) {
      m.isVisible = !selectedMesh || m == selectedMesh;
    });
  };
  BoundingBoxGizmo2.prototype.updateBoundingBox = function() {
    if (this.attachedMesh) {
      PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);
      var originalParent = this.attachedMesh.parent;
      this.attachedMesh.setParent(null);
      var originalSkeletonOverrideMesh = null;
      if (this.attachedMesh.skeleton) {
        originalSkeletonOverrideMesh = this.attachedMesh.skeleton.overrideMesh;
        this.attachedMesh.skeleton.overrideMesh = null;
      }
      this._update();
      if (!this.attachedMesh.rotationQuaternion) {
        this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.attachedMesh.rotation.y, this.attachedMesh.rotation.x, this.attachedMesh.rotation.z);
      }
      if (!this._anchorMesh.rotationQuaternion) {
        this._anchorMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._anchorMesh.rotation.y, this._anchorMesh.rotation.x, this._anchorMesh.rotation.z);
      }
      this._anchorMesh.rotationQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);
      this._tmpQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);
      this._tmpVector.copyFrom(this.attachedMesh.position);
      this.attachedMesh.rotationQuaternion.set(0, 0, 0, 1);
      this.attachedMesh.position.set(0, 0, 0);
      var boundingMinMax = this.attachedMesh.getHierarchyBoundingVectors(!this.ignoreChildren, this.includeChildPredicate);
      boundingMinMax.max.subtractToRef(boundingMinMax.min, this._boundingDimensions);
      this._lineBoundingBox.scaling.copyFrom(this._boundingDimensions);
      this._lineBoundingBox.position.set((boundingMinMax.max.x + boundingMinMax.min.x) / 2, (boundingMinMax.max.y + boundingMinMax.min.y) / 2, (boundingMinMax.max.z + boundingMinMax.min.z) / 2);
      this._rotateSpheresParent.position.copyFrom(this._lineBoundingBox.position);
      this._scaleBoxesParent.position.copyFrom(this._lineBoundingBox.position);
      this._lineBoundingBox.computeWorldMatrix();
      this._anchorMesh.position.copyFrom(this._lineBoundingBox.absolutePosition);
      this.attachedMesh.rotationQuaternion.copyFrom(this._tmpQuaternion);
      this.attachedMesh.position.copyFrom(this._tmpVector);
      this.attachedMesh.setParent(originalParent);
      if (this.attachedMesh.skeleton) {
        this.attachedMesh.skeleton.overrideMesh = originalSkeletonOverrideMesh;
      }
    }
    this._updateRotationSpheres();
    this._updateScaleBoxes();
    if (this.attachedMesh) {
      this._existingMeshScale.copyFrom(this.attachedMesh.scaling);
      PivotTools._RestorePivotPoint(this.attachedMesh);
    }
  };
  BoundingBoxGizmo2.prototype._updateRotationSpheres = function() {
    var rotateSpheres = this._rotateSpheresParent.getChildMeshes();
    for (var i = 0; i < 3; i++) {
      for (var j = 0; j < 2; j++) {
        for (var k = 0; k < 2; k++) {
          var index = i * 4 + j * 2 + k;
          if (i == 0) {
            rotateSpheres[index].position.set(this._boundingDimensions.x / 2, this._boundingDimensions.y * j, this._boundingDimensions.z * k);
            rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));
            rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Right()).normalizeToNew().add(rotateSpheres[index].position));
          }
          if (i == 1) {
            rotateSpheres[index].position.set(this._boundingDimensions.x * j, this._boundingDimensions.y / 2, this._boundingDimensions.z * k);
            rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));
            rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Up()).normalizeToNew().add(rotateSpheres[index].position));
          }
          if (i == 2) {
            rotateSpheres[index].position.set(this._boundingDimensions.x * j, this._boundingDimensions.y * k, this._boundingDimensions.z / 2);
            rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));
            rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Forward()).normalizeToNew().add(rotateSpheres[index].position));
          }
          if (this.fixedDragMeshScreenSize && this.gizmoLayer.utilityLayerScene.activeCamera) {
            rotateSpheres[index].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);
            var distanceFromCamera = this.rotationSphereSize * this._tmpVector.length() / this.fixedDragMeshScreenSizeDistanceFactor;
            rotateSpheres[index].scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);
          } else if (this.fixedDragMeshBoundsSize) {
            rotateSpheres[index].scaling.set(this.rotationSphereSize * this._boundingDimensions.x, this.rotationSphereSize * this._boundingDimensions.y, this.rotationSphereSize * this._boundingDimensions.z);
          } else {
            rotateSpheres[index].scaling.set(this.rotationSphereSize, this.rotationSphereSize, this.rotationSphereSize);
          }
        }
      }
    }
  };
  BoundingBoxGizmo2.prototype._updateScaleBoxes = function() {
    var scaleBoxes = this._scaleBoxesParent.getChildMeshes();
    var index = 0;
    for (var i = 0; i < 3; i++) {
      for (var j = 0; j < 3; j++) {
        for (var k = 0; k < 3; k++) {
          var zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);
          if (zeroAxisCount === 1 || zeroAxisCount === 3) {
            continue;
          }
          if (scaleBoxes[index]) {
            scaleBoxes[index].position.set(this._boundingDimensions.x * (i / 2), this._boundingDimensions.y * (j / 2), this._boundingDimensions.z * (k / 2));
            scaleBoxes[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));
            if (this.fixedDragMeshScreenSize && this.gizmoLayer.utilityLayerScene.activeCamera) {
              scaleBoxes[index].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);
              var distanceFromCamera = this.scaleBoxSize * this._tmpVector.length() / this.fixedDragMeshScreenSizeDistanceFactor;
              scaleBoxes[index].scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);
            } else if (this.fixedDragMeshBoundsSize) {
              scaleBoxes[index].scaling.set(this.scaleBoxSize * this._boundingDimensions.x, this.scaleBoxSize * this._boundingDimensions.y, this.scaleBoxSize * this._boundingDimensions.z);
            } else {
              scaleBoxes[index].scaling.set(this.scaleBoxSize, this.scaleBoxSize, this.scaleBoxSize);
            }
          }
          index++;
        }
      }
    }
  };
  BoundingBoxGizmo2.prototype.setEnabledRotationAxis = function(axis) {
    this._rotateSpheresParent.getChildMeshes().forEach(function(m, i) {
      if (i < 4) {
        m.setEnabled(axis.indexOf("x") != -1);
      } else if (i < 8) {
        m.setEnabled(axis.indexOf("y") != -1);
      } else {
        m.setEnabled(axis.indexOf("z") != -1);
      }
    });
  };
  BoundingBoxGizmo2.prototype.setEnabledScaling = function(enable, homogeneousScaling) {
    if (homogeneousScaling === void 0) {
      homogeneousScaling = false;
    }
    this._scaleBoxesParent.getChildMeshes().forEach(function(m, i) {
      var enableMesh = enable;
      if (homogeneousScaling && m.metadata === true) {
        enableMesh = false;
      }
      m.setEnabled(enableMesh);
    });
  };
  BoundingBoxGizmo2.prototype._updateDummy = function() {
    if (this._dragMesh) {
      this._dragMesh.position.copyFrom(this._lineBoundingBox.getAbsolutePosition());
      this._dragMesh.scaling.copyFrom(this._lineBoundingBox.scaling);
      this._dragMesh.rotationQuaternion.copyFrom(this._rootMesh.rotationQuaternion);
    }
  };
  BoundingBoxGizmo2.prototype.enableDragBehavior = function() {
    this._dragMesh = Mesh.CreateBox("dummy", 1, this.gizmoLayer.utilityLayerScene);
    this._dragMesh.visibility = 0;
    this._dragMesh.rotationQuaternion = new Quaternion();
    this.pointerDragBehavior.useObjectOrientationForDragging = false;
    this._dragMesh.addBehavior(this.pointerDragBehavior);
  };
  BoundingBoxGizmo2.prototype.dispose = function() {
    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
    this.gizmoLayer.originalScene.onBeforeRenderObservable.remove(this._renderObserver);
    this._lineBoundingBox.dispose();
    this._rotateSpheresParent.dispose();
    this._scaleBoxesParent.dispose();
    if (this._dragMesh) {
      this._dragMesh.dispose();
    }
    _super.prototype.dispose.call(this);
  };
  BoundingBoxGizmo2.MakeNotPickableAndWrapInBoundingBox = function(mesh) {
    var makeNotPickable = function(root) {
      root.isPickable = false;
      root.getChildMeshes().forEach(function(c) {
        makeNotPickable(c);
      });
    };
    makeNotPickable(mesh);
    if (!mesh.rotationQuaternion) {
      mesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(mesh.rotation.y, mesh.rotation.x, mesh.rotation.z);
    }
    var oldPos = mesh.position.clone();
    var oldRot = mesh.rotationQuaternion.clone();
    mesh.rotationQuaternion.set(0, 0, 0, 1);
    mesh.position.set(0, 0, 0);
    var box = BoxBuilder.CreateBox("box", { size: 1 }, mesh.getScene());
    var boundingMinMax = mesh.getHierarchyBoundingVectors();
    boundingMinMax.max.subtractToRef(boundingMinMax.min, box.scaling);
    if (box.scaling.y === 0) {
      box.scaling.y = Epsilon;
    }
    if (box.scaling.x === 0) {
      box.scaling.x = Epsilon;
    }
    if (box.scaling.z === 0) {
      box.scaling.z = Epsilon;
    }
    box.position.set((boundingMinMax.max.x + boundingMinMax.min.x) / 2, (boundingMinMax.max.y + boundingMinMax.min.y) / 2, (boundingMinMax.max.z + boundingMinMax.min.z) / 2);
    mesh.addChild(box);
    mesh.rotationQuaternion.copyFrom(oldRot);
    mesh.position.copyFrom(oldPos);
    mesh.removeChild(box);
    box.addChild(mesh);
    box.visibility = 0;
    return box;
  };
  BoundingBoxGizmo2.prototype.setCustomMesh = function(mesh) {
    Logger.Error("Custom meshes are not supported on this gizmo");
  };
  return BoundingBoxGizmo2;
}(Gizmo);

// node_modules/@babylonjs/core/Gizmos/planeRotationGizmo.js
var PlaneRotationGizmo = function(_super) {
  __extends(PlaneRotationGizmo2, _super);
  function PlaneRotationGizmo2(planeNormal, color, gizmoLayer, tessellation, parent, useEulerRotation, thickness) {
    if (color === void 0) {
      color = Color3.Gray();
    }
    if (gizmoLayer === void 0) {
      gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer;
    }
    if (tessellation === void 0) {
      tessellation = 32;
    }
    if (parent === void 0) {
      parent = null;
    }
    if (useEulerRotation === void 0) {
      useEulerRotation = false;
    }
    if (thickness === void 0) {
      thickness = 1;
    }
    var _a;
    var _this = _super.call(this, gizmoLayer) || this;
    _this._pointerObserver = null;
    _this.snapDistance = 0;
    _this.onSnapObservable = new Observable();
    _this._isEnabled = true;
    _this._parent = null;
    _this._dragging = false;
    _this._parent = parent;
    _this._coloredMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
    _this._coloredMaterial.diffuseColor = color;
    _this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));
    _this._hoverMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
    _this._hoverMaterial.diffuseColor = Color3.Yellow();
    _this._disableMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
    _this._disableMaterial.diffuseColor = Color3.Gray();
    _this._disableMaterial.alpha = 0.4;
    _this._gizmoMesh = new Mesh("", gizmoLayer.utilityLayerScene);
    var _b = _this._createGizmoMesh(_this._gizmoMesh, thickness, tessellation), rotationMesh = _b.rotationMesh, collider = _b.collider;
    var rotationCirclePaths = [];
    _this._rotationCircle = _this.setupRotationCircle(rotationCirclePaths, _this._gizmoMesh);
    _this._gizmoMesh.lookAt(_this._rootMesh.position.add(planeNormal));
    _this._rootMesh.addChild(_this._gizmoMesh);
    _this._gizmoMesh.scaling.scaleInPlace(1 / 3);
    _this.dragBehavior = new PointerDragBehavior({ dragPlaneNormal: planeNormal });
    _this.dragBehavior.moveAttached = false;
    _this.dragBehavior.maxDragAngle = Math.PI * 9 / 20;
    _this.dragBehavior._useAlternatePickedPointAboveMaxDragAngle = true;
    _this._rootMesh.addBehavior(_this.dragBehavior);
    var dragDistance = 0;
    var lastDragPosition = new Vector3();
    var dragPlanePoint = new Vector3();
    var rotationMatrix = new Matrix();
    var planeNormalTowardsCamera = new Vector3();
    var localPlaneNormalTowardsCamera = new Vector3();
    _this.dragBehavior.onDragStartObservable.add(function(e) {
      if (_this.attachedNode) {
        lastDragPosition.copyFrom(e.dragPlanePoint);
        var forward = new Vector3(0, 0, 1);
        var direction = _this._rotationCircle.getDirection(forward);
        direction.normalize();
        _this._gizmoMesh.removeChild(_this._rotationCircle);
        lastDragPosition.copyFrom(e.dragPlanePoint);
        dragPlanePoint = e.dragPlanePoint;
        var origin_1 = _this._rotationCircle.getAbsolutePosition().clone();
        var originalRotationPoint = _this._rotationCircle.getAbsolutePosition().clone().addInPlace(direction);
        var dragStartPoint = e.dragPlanePoint;
        var angle = Vector3.GetAngleBetweenVectors(originalRotationPoint.subtract(origin_1), dragStartPoint.subtract(origin_1), _this._rotationCircle.up);
        _this._rotationCircle.addRotation(0, angle, 0);
        _this._dragging = true;
      }
    });
    _this.dragBehavior.onDragEndObservable.add(function() {
      dragDistance = 0;
      _this.updateRotationCircle(_this._rotationCircle, rotationCirclePaths, dragDistance, dragPlanePoint);
      _this._gizmoMesh.addChild(_this._rotationCircle);
      _this._dragging = false;
    });
    var tmpSnapEvent = { snapDistance: 0 };
    var currentSnapDragDistance = 0;
    var tmpMatrix4 = new Matrix();
    var amountToRotate = new Quaternion();
    _this.dragBehavior.onDragObservable.add(function(event) {
      if (_this.attachedNode) {
        var nodeScale = new Vector3(1, 1, 1);
        var nodeQuaternion = new Quaternion(0, 0, 0, 1);
        var nodeTranslation = new Vector3(0, 0, 0);
        _this.attachedNode.getWorldMatrix().decompose(nodeScale, nodeQuaternion, nodeTranslation);
        var newVector = event.dragPlanePoint.subtract(nodeTranslation).normalize();
        var originalVector = lastDragPosition.subtract(nodeTranslation).normalize();
        var cross = Vector3.Cross(newVector, originalVector);
        var dot = Vector3.Dot(newVector, originalVector);
        var angle = Math.atan2(cross.length(), dot);
        planeNormalTowardsCamera.copyFrom(planeNormal);
        localPlaneNormalTowardsCamera.copyFrom(planeNormal);
        if (_this.updateGizmoRotationToMatchAttachedMesh) {
          nodeQuaternion.toRotationMatrix(rotationMatrix);
          localPlaneNormalTowardsCamera = Vector3.TransformCoordinates(planeNormalTowardsCamera, rotationMatrix);
        }
        var cameraFlipped = false;
        if (gizmoLayer.utilityLayerScene.activeCamera) {
          var camVec = gizmoLayer.utilityLayerScene.activeCamera.position.subtract(nodeTranslation);
          if (Vector3.Dot(camVec, localPlaneNormalTowardsCamera) > 0) {
            planeNormalTowardsCamera.scaleInPlace(-1);
            localPlaneNormalTowardsCamera.scaleInPlace(-1);
            cameraFlipped = true;
          }
        }
        var halfCircleSide = Vector3.Dot(localPlaneNormalTowardsCamera, cross) > 0;
        if (halfCircleSide) {
          angle = -angle;
        }
        var snapped = false;
        if (_this.snapDistance != 0) {
          currentSnapDragDistance += angle;
          if (Math.abs(currentSnapDragDistance) > _this.snapDistance) {
            var dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / _this.snapDistance);
            if (currentSnapDragDistance < 0) {
              dragSteps *= -1;
            }
            currentSnapDragDistance = currentSnapDragDistance % _this.snapDistance;
            angle = _this.snapDistance * dragSteps;
            snapped = true;
          } else {
            angle = 0;
          }
        }
        dragDistance += cameraFlipped ? -angle : angle;
        _this.updateRotationCircle(_this._rotationCircle, rotationCirclePaths, dragDistance, dragPlanePoint);
        var quaternionCoefficient = Math.sin(angle / 2);
        amountToRotate.set(planeNormalTowardsCamera.x * quaternionCoefficient, planeNormalTowardsCamera.y * quaternionCoefficient, planeNormalTowardsCamera.z * quaternionCoefficient, Math.cos(angle / 2));
        if (tmpMatrix4.determinant() > 0) {
          var tmpVector = new Vector3();
          amountToRotate.toEulerAnglesToRef(tmpVector);
          Quaternion.RotationYawPitchRollToRef(tmpVector.y, -tmpVector.x, -tmpVector.z, amountToRotate);
        }
        if (_this.updateGizmoRotationToMatchAttachedMesh) {
          nodeQuaternion.multiplyToRef(amountToRotate, nodeQuaternion);
        } else {
          amountToRotate.multiplyToRef(nodeQuaternion, nodeQuaternion);
        }
        _this.attachedNode.getWorldMatrix().copyFrom(Matrix.Compose(nodeScale, nodeQuaternion, nodeTranslation));
        lastDragPosition.copyFrom(event.dragPlanePoint);
        if (snapped) {
          tmpSnapEvent.snapDistance = angle;
          _this.onSnapObservable.notifyObservers(tmpSnapEvent);
        }
        _this._matrixChanged();
      }
    });
    var light = gizmoLayer._getSharedGizmoLight();
    light.includedOnlyMeshes = light.includedOnlyMeshes.concat(_this._rootMesh.getChildMeshes(false));
    var cache = {
      colliderMeshes: [collider],
      gizmoMeshes: [rotationMesh],
      material: _this._coloredMaterial,
      hoverMaterial: _this._hoverMaterial,
      disableMaterial: _this._disableMaterial,
      active: false
    };
    (_a = _this._parent) === null || _a === void 0 ? void 0 : _a.addToAxisCache(_this._gizmoMesh, cache);
    _this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function(pointerInfo) {
      var _a2;
      if (_this._customMeshSet) {
        return;
      }
      _this._isHovered = !!(cache.colliderMeshes.indexOf((_a2 = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _a2 === void 0 ? void 0 : _a2.pickedMesh) != -1);
      if (!_this._parent) {
        var material = _this._isHovered || _this._dragging ? _this._hoverMaterial : _this._coloredMaterial;
        cache.gizmoMeshes.forEach(function(m) {
          m.material = material;
          if (m.color) {
            m.color = material.diffuseColor;
          }
        });
      }
    });
    return _this;
  }
  PlaneRotationGizmo2.prototype._createGizmoMesh = function(parentMesh, thickness, tessellation) {
    var collider = Mesh.CreateTorus("ignore", 0.6, 0.03 * thickness, tessellation, this.gizmoLayer.utilityLayerScene);
    collider.visibility = 0;
    var rotationMesh = Mesh.CreateTorus("", 0.6, 5e-3 * thickness, tessellation, this.gizmoLayer.utilityLayerScene);
    rotationMesh.material = this._coloredMaterial;
    rotationMesh.rotation.x = Math.PI / 2;
    collider.rotation.x = Math.PI / 2;
    parentMesh.addChild(rotationMesh);
    parentMesh.addChild(collider);
    return { rotationMesh, collider };
  };
  PlaneRotationGizmo2.prototype._attachedNodeChanged = function(value) {
    if (this.dragBehavior) {
      this.dragBehavior.enabled = value ? true : false;
    }
  };
  PlaneRotationGizmo2.prototype.setupRotationCircle = function(paths, parentMesh) {
    var fillRadians = 0;
    var step = PlaneRotationGizmo2._CircleConstants.pi2 / PlaneRotationGizmo2._CircleConstants.tessellation;
    for (var p = -Math.PI / 2; p < Math.PI / 2 - 1.5; p += step / 2) {
      var path = [];
      for (var i = 0; i < PlaneRotationGizmo2._CircleConstants.pi2 * PlaneRotationGizmo2._CircleConstants.rotationCircleRange + 0.01; i += step) {
        if (i < fillRadians) {
          var x = PlaneRotationGizmo2._CircleConstants.radius * Math.sin(i) * Math.cos(p);
          var z = PlaneRotationGizmo2._CircleConstants.radius * Math.cos(i) * Math.cos(p);
          var y = 0;
          path.push(new Vector3(x, y, z));
        } else {
          path.push(new Vector3(0, 0, 0));
        }
      }
      paths.push(path);
    }
    var mat = new StandardMaterial("", this.gizmoLayer.utilityLayerScene);
    mat.diffuseColor = Color3.Yellow();
    mat.backFaceCulling = false;
    var mesh = Mesh.CreateRibbon("rotationCircle", paths, false, false, 0, this.gizmoLayer.utilityLayerScene, true);
    mesh.material = mat;
    mesh.material.alpha = 0.25;
    mesh.rotation.x = Math.PI / 2;
    parentMesh.addChild(mesh);
    return mesh;
  };
  PlaneRotationGizmo2.prototype.updateRotationPath = function(pathArr, newFill) {
    var step = PlaneRotationGizmo2._CircleConstants.pi2 / PlaneRotationGizmo2._CircleConstants.tessellation;
    var tessellationCounter = 0;
    for (var p = -Math.PI / 2; p < Math.PI / 2 - 1.5; p += step / 2) {
      var path = pathArr[tessellationCounter];
      if (path) {
        var radianCounter = 0;
        for (var i = 0; i < PlaneRotationGizmo2._CircleConstants.pi2 * PlaneRotationGizmo2._CircleConstants.rotationCircleRange + 0.01; i += step) {
          if (path[radianCounter]) {
            if (i < Math.abs(newFill)) {
              var absI = newFill > 0 ? i : i * -1;
              var absP = newFill > 0 ? p : p * -1;
              path[radianCounter].set(PlaneRotationGizmo2._CircleConstants.radius * Math.sin(absI) * Math.cos(absP), 0, PlaneRotationGizmo2._CircleConstants.radius * Math.cos(absI) * Math.cos(absP));
            } else {
              path[radianCounter].set(0, 0, 0);
            }
          }
          radianCounter++;
        }
      }
      tessellationCounter++;
    }
  };
  PlaneRotationGizmo2.prototype.updateRotationCircle = function(mesh, paths, newFill, dragPlanePoint) {
    this.updateRotationPath(paths, newFill);
    Mesh.CreateRibbon("rotationCircle", paths, false, false, 0, this.gizmoLayer.utilityLayerScene, void 0, void 0, mesh.geometry ? mesh : void 0);
  };
  Object.defineProperty(PlaneRotationGizmo2.prototype, "isEnabled", {
    get: function() {
      return this._isEnabled;
    },
    set: function(value) {
      this._isEnabled = value;
      if (!value) {
        this.attachedMesh = null;
      } else {
        if (this._parent) {
          this.attachedMesh = this._parent.attachedMesh;
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  PlaneRotationGizmo2.prototype.dispose = function() {
    this.onSnapObservable.clear();
    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
    this.dragBehavior.detach();
    if (this._gizmoMesh) {
      this._gizmoMesh.dispose();
    }
    if (this._rotationCircle) {
      this._rotationCircle.dispose();
    }
    [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach(function(matl) {
      if (matl) {
        matl.dispose();
      }
    });
    _super.prototype.dispose.call(this);
  };
  PlaneRotationGizmo2._CircleConstants = {
    radius: 0.3,
    pi2: Math.PI * 2,
    tessellation: 70,
    rotationCircleRange: 4
  };
  return PlaneRotationGizmo2;
}(Gizmo);

// node_modules/@babylonjs/core/Gizmos/rotationGizmo.js
var RotationGizmo = function(_super) {
  __extends(RotationGizmo2, _super);
  function RotationGizmo2(gizmoLayer, tessellation, useEulerRotation, thickness, gizmoManager) {
    if (gizmoLayer === void 0) {
      gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer;
    }
    if (tessellation === void 0) {
      tessellation = 32;
    }
    if (useEulerRotation === void 0) {
      useEulerRotation = false;
    }
    if (thickness === void 0) {
      thickness = 1;
    }
    var _this = _super.call(this, gizmoLayer) || this;
    _this.onDragStartObservable = new Observable();
    _this.onDragEndObservable = new Observable();
    _this._observables = [];
    _this._gizmoAxisCache = /* @__PURE__ */ new Map();
    _this.xGizmo = new PlaneRotationGizmo(new Vector3(1, 0, 0), Color3.Red().scale(0.5), gizmoLayer, tessellation, _this, useEulerRotation, thickness);
    _this.yGizmo = new PlaneRotationGizmo(new Vector3(0, 1, 0), Color3.Green().scale(0.5), gizmoLayer, tessellation, _this, useEulerRotation, thickness);
    _this.zGizmo = new PlaneRotationGizmo(new Vector3(0, 0, 1), Color3.Blue().scale(0.5), gizmoLayer, tessellation, _this, useEulerRotation, thickness);
    [_this.xGizmo, _this.yGizmo, _this.zGizmo].forEach(function(gizmo) {
      gizmo.dragBehavior.onDragStartObservable.add(function() {
        _this.onDragStartObservable.notifyObservers({});
      });
      gizmo.dragBehavior.onDragEndObservable.add(function() {
        _this.onDragEndObservable.notifyObservers({});
      });
    });
    _this.attachedMesh = null;
    _this.attachedNode = null;
    if (gizmoManager) {
      gizmoManager.addToAxisCache(_this._gizmoAxisCache);
    } else {
      Gizmo.GizmoAxisPointerObserver(gizmoLayer, _this._gizmoAxisCache);
    }
    return _this;
  }
  Object.defineProperty(RotationGizmo2.prototype, "attachedMesh", {
    get: function() {
      return this._meshAttached;
    },
    set: function(mesh) {
      this._meshAttached = mesh;
      this._nodeAttached = mesh;
      this._checkBillboardTransform();
      [this.xGizmo, this.yGizmo, this.zGizmo].forEach(function(gizmo) {
        if (gizmo.isEnabled) {
          gizmo.attachedMesh = mesh;
        } else {
          gizmo.attachedMesh = null;
        }
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RotationGizmo2.prototype, "attachedNode", {
    get: function() {
      return this._nodeAttached;
    },
    set: function(node) {
      this._meshAttached = null;
      this._nodeAttached = node;
      this._checkBillboardTransform();
      [this.xGizmo, this.yGizmo, this.zGizmo].forEach(function(gizmo) {
        if (gizmo.isEnabled) {
          gizmo.attachedNode = node;
        } else {
          gizmo.attachedNode = null;
        }
      });
    },
    enumerable: false,
    configurable: true
  });
  RotationGizmo2.prototype._checkBillboardTransform = function() {
    if (this._nodeAttached && this._nodeAttached.billboardMode) {
      console.log("Rotation Gizmo will not work with transforms in billboard mode.");
    }
  };
  Object.defineProperty(RotationGizmo2.prototype, "isHovered", {
    get: function() {
      var hovered = false;
      [this.xGizmo, this.yGizmo, this.zGizmo].forEach(function(gizmo) {
        hovered = hovered || gizmo.isHovered;
      });
      return hovered;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RotationGizmo2.prototype, "updateGizmoRotationToMatchAttachedMesh", {
    get: function() {
      return this.xGizmo.updateGizmoRotationToMatchAttachedMesh;
    },
    set: function(value) {
      if (this.xGizmo) {
        this.xGizmo.updateGizmoRotationToMatchAttachedMesh = value;
        this.yGizmo.updateGizmoRotationToMatchAttachedMesh = value;
        this.zGizmo.updateGizmoRotationToMatchAttachedMesh = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RotationGizmo2.prototype, "snapDistance", {
    get: function() {
      return this.xGizmo.snapDistance;
    },
    set: function(value) {
      if (this.xGizmo) {
        this.xGizmo.snapDistance = value;
        this.yGizmo.snapDistance = value;
        this.zGizmo.snapDistance = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RotationGizmo2.prototype, "scaleRatio", {
    get: function() {
      return this.xGizmo.scaleRatio;
    },
    set: function(value) {
      if (this.xGizmo) {
        this.xGizmo.scaleRatio = value;
        this.yGizmo.scaleRatio = value;
        this.zGizmo.scaleRatio = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  RotationGizmo2.prototype.addToAxisCache = function(mesh, cache) {
    this._gizmoAxisCache.set(mesh, cache);
  };
  RotationGizmo2.prototype.dispose = function() {
    var _this = this;
    this.xGizmo.dispose();
    this.yGizmo.dispose();
    this.zGizmo.dispose();
    this.onDragStartObservable.clear();
    this.onDragEndObservable.clear();
    this._observables.forEach(function(obs) {
      _this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(obs);
    });
  };
  RotationGizmo2.prototype.setCustomMesh = function(mesh) {
    Logger.Error("Custom meshes are not supported on this gizmo, please set the custom meshes on the gizmos contained within this one (gizmo.xGizmo, gizmo.yGizmo, gizmo.zGizmo)");
  };
  return RotationGizmo2;
}(Gizmo);

// node_modules/@babylonjs/core/Gizmos/planeDragGizmo.js
var PlaneDragGizmo = function(_super) {
  __extends(PlaneDragGizmo2, _super);
  function PlaneDragGizmo2(dragPlaneNormal, color, gizmoLayer, parent) {
    if (color === void 0) {
      color = Color3.Gray();
    }
    if (gizmoLayer === void 0) {
      gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer;
    }
    if (parent === void 0) {
      parent = null;
    }
    var _a;
    var _this = _super.call(this, gizmoLayer) || this;
    _this._pointerObserver = null;
    _this.snapDistance = 0;
    _this.onSnapObservable = new Observable();
    _this._isEnabled = false;
    _this._parent = null;
    _this._dragging = false;
    _this._parent = parent;
    _this._coloredMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
    _this._coloredMaterial.diffuseColor = color;
    _this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));
    _this._hoverMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
    _this._hoverMaterial.diffuseColor = Color3.Yellow();
    _this._disableMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
    _this._disableMaterial.diffuseColor = Color3.Gray();
    _this._disableMaterial.alpha = 0.4;
    _this._gizmoMesh = PlaneDragGizmo2._CreatePlane(gizmoLayer.utilityLayerScene, _this._coloredMaterial);
    _this._gizmoMesh.lookAt(_this._rootMesh.position.add(dragPlaneNormal));
    _this._gizmoMesh.scaling.scaleInPlace(1 / 3);
    _this._gizmoMesh.parent = _this._rootMesh;
    var currentSnapDragDistance = 0;
    var tmpVector = new Vector3();
    var tmpSnapEvent = { snapDistance: 0 };
    _this.dragBehavior = new PointerDragBehavior({ dragPlaneNormal });
    _this.dragBehavior.moveAttached = false;
    _this._rootMesh.addBehavior(_this.dragBehavior);
    _this.dragBehavior.onDragObservable.add(function(event) {
      if (_this.attachedNode) {
        if (_this.snapDistance == 0) {
          _this.attachedNode.getWorldMatrix().addTranslationFromFloats(event.delta.x, event.delta.y, event.delta.z);
        } else {
          currentSnapDragDistance += event.dragDistance;
          if (Math.abs(currentSnapDragDistance) > _this.snapDistance) {
            var dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / _this.snapDistance);
            currentSnapDragDistance = currentSnapDragDistance % _this.snapDistance;
            event.delta.normalizeToRef(tmpVector);
            tmpVector.scaleInPlace(_this.snapDistance * dragSteps);
            _this.attachedNode.getWorldMatrix().addTranslationFromFloats(tmpVector.x, tmpVector.y, tmpVector.z);
            tmpSnapEvent.snapDistance = _this.snapDistance * dragSteps;
            _this.onSnapObservable.notifyObservers(tmpSnapEvent);
          }
        }
        _this._matrixChanged();
      }
    });
    _this.dragBehavior.onDragStartObservable.add(function() {
      _this._dragging = true;
    });
    _this.dragBehavior.onDragEndObservable.add(function() {
      _this._dragging = false;
    });
    var light = gizmoLayer._getSharedGizmoLight();
    light.includedOnlyMeshes = light.includedOnlyMeshes.concat(_this._rootMesh.getChildMeshes(false));
    var cache = {
      gizmoMeshes: _this._gizmoMesh.getChildMeshes(),
      colliderMeshes: _this._gizmoMesh.getChildMeshes(),
      material: _this._coloredMaterial,
      hoverMaterial: _this._hoverMaterial,
      disableMaterial: _this._disableMaterial,
      active: false
    };
    (_a = _this._parent) === null || _a === void 0 ? void 0 : _a.addToAxisCache(_this._gizmoMesh, cache);
    _this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function(pointerInfo) {
      var _a2;
      if (_this._customMeshSet) {
        return;
      }
      _this._isHovered = !!(cache.colliderMeshes.indexOf((_a2 = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _a2 === void 0 ? void 0 : _a2.pickedMesh) != -1);
      if (!_this._parent) {
        var material = _this._isHovered || _this._dragging ? _this._hoverMaterial : _this._coloredMaterial;
        cache.gizmoMeshes.forEach(function(m) {
          m.material = material;
        });
      }
    });
    return _this;
  }
  PlaneDragGizmo2._CreatePlane = function(scene, material) {
    var plane = new TransformNode("plane", scene);
    var dragPlane = PlaneBuilder.CreatePlane("dragPlane", { width: 0.1375, height: 0.1375, sideOrientation: 2 }, scene);
    dragPlane.material = material;
    dragPlane.parent = plane;
    return plane;
  };
  PlaneDragGizmo2.prototype._attachedNodeChanged = function(value) {
    if (this.dragBehavior) {
      this.dragBehavior.enabled = value ? true : false;
    }
  };
  Object.defineProperty(PlaneDragGizmo2.prototype, "isEnabled", {
    get: function() {
      return this._isEnabled;
    },
    set: function(value) {
      this._isEnabled = value;
      if (!value) {
        this.attachedNode = null;
      } else {
        if (this._parent) {
          this.attachedNode = this._parent.attachedNode;
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  PlaneDragGizmo2.prototype.dispose = function() {
    this.onSnapObservable.clear();
    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
    this.dragBehavior.detach();
    _super.prototype.dispose.call(this);
    if (this._gizmoMesh) {
      this._gizmoMesh.dispose();
    }
    [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach(function(matl) {
      if (matl) {
        matl.dispose();
      }
    });
  };
  return PlaneDragGizmo2;
}(Gizmo);

// node_modules/@babylonjs/core/Gizmos/positionGizmo.js
var PositionGizmo = function(_super) {
  __extends(PositionGizmo2, _super);
  function PositionGizmo2(gizmoLayer, thickness, gizmoManager) {
    if (gizmoLayer === void 0) {
      gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer;
    }
    if (thickness === void 0) {
      thickness = 1;
    }
    var _this = _super.call(this, gizmoLayer) || this;
    _this._meshAttached = null;
    _this._nodeAttached = null;
    _this._observables = [];
    _this._gizmoAxisCache = /* @__PURE__ */ new Map();
    _this.onDragStartObservable = new Observable();
    _this.onDragEndObservable = new Observable();
    _this._planarGizmoEnabled = false;
    _this.xGizmo = new AxisDragGizmo(new Vector3(1, 0, 0), Color3.Red().scale(0.5), gizmoLayer, _this, thickness);
    _this.yGizmo = new AxisDragGizmo(new Vector3(0, 1, 0), Color3.Green().scale(0.5), gizmoLayer, _this, thickness);
    _this.zGizmo = new AxisDragGizmo(new Vector3(0, 0, 1), Color3.Blue().scale(0.5), gizmoLayer, _this, thickness);
    _this.xPlaneGizmo = new PlaneDragGizmo(new Vector3(1, 0, 0), Color3.Red().scale(0.5), _this.gizmoLayer, _this);
    _this.yPlaneGizmo = new PlaneDragGizmo(new Vector3(0, 1, 0), Color3.Green().scale(0.5), _this.gizmoLayer, _this);
    _this.zPlaneGizmo = new PlaneDragGizmo(new Vector3(0, 0, 1), Color3.Blue().scale(0.5), _this.gizmoLayer, _this);
    [_this.xGizmo, _this.yGizmo, _this.zGizmo, _this.xPlaneGizmo, _this.yPlaneGizmo, _this.zPlaneGizmo].forEach(function(gizmo) {
      gizmo.dragBehavior.onDragStartObservable.add(function() {
        _this.onDragStartObservable.notifyObservers({});
      });
      gizmo.dragBehavior.onDragEndObservable.add(function() {
        _this.onDragEndObservable.notifyObservers({});
      });
    });
    _this.attachedMesh = null;
    if (gizmoManager) {
      gizmoManager.addToAxisCache(_this._gizmoAxisCache);
    } else {
      Gizmo.GizmoAxisPointerObserver(gizmoLayer, _this._gizmoAxisCache);
    }
    return _this;
  }
  Object.defineProperty(PositionGizmo2.prototype, "attachedMesh", {
    get: function() {
      return this._meshAttached;
    },
    set: function(mesh) {
      this._meshAttached = mesh;
      this._nodeAttached = mesh;
      [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach(function(gizmo) {
        if (gizmo.isEnabled) {
          gizmo.attachedMesh = mesh;
        } else {
          gizmo.attachedMesh = null;
        }
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PositionGizmo2.prototype, "attachedNode", {
    get: function() {
      return this._nodeAttached;
    },
    set: function(node) {
      this._meshAttached = null;
      this._nodeAttached = null;
      [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach(function(gizmo) {
        if (gizmo.isEnabled) {
          gizmo.attachedNode = node;
        } else {
          gizmo.attachedNode = null;
        }
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PositionGizmo2.prototype, "isHovered", {
    get: function() {
      var hovered = false;
      [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach(function(gizmo) {
        hovered = hovered || gizmo.isHovered;
      });
      return hovered;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PositionGizmo2.prototype, "planarGizmoEnabled", {
    get: function() {
      return this._planarGizmoEnabled;
    },
    set: function(value) {
      var _this = this;
      this._planarGizmoEnabled = value;
      [this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach(function(gizmo) {
        if (gizmo) {
          gizmo.isEnabled = value;
          if (value) {
            if (gizmo.attachedMesh) {
              gizmo.attachedMesh = _this.attachedMesh;
            } else {
              gizmo.attachedNode = _this.attachedNode;
            }
          }
        }
      }, this);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PositionGizmo2.prototype, "updateGizmoRotationToMatchAttachedMesh", {
    get: function() {
      return this._updateGizmoRotationToMatchAttachedMesh;
    },
    set: function(value) {
      this._updateGizmoRotationToMatchAttachedMesh = value;
      [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach(function(gizmo) {
        if (gizmo) {
          gizmo.updateGizmoRotationToMatchAttachedMesh = value;
        }
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PositionGizmo2.prototype, "snapDistance", {
    get: function() {
      return this._snapDistance;
    },
    set: function(value) {
      this._snapDistance = value;
      [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach(function(gizmo) {
        if (gizmo) {
          gizmo.snapDistance = value;
        }
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PositionGizmo2.prototype, "scaleRatio", {
    get: function() {
      return this._scaleRatio;
    },
    set: function(value) {
      this._scaleRatio = value;
      [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach(function(gizmo) {
        if (gizmo) {
          gizmo.scaleRatio = value;
        }
      });
    },
    enumerable: false,
    configurable: true
  });
  PositionGizmo2.prototype.addToAxisCache = function(mesh, cache) {
    this._gizmoAxisCache.set(mesh, cache);
  };
  PositionGizmo2.prototype.dispose = function() {
    var _this = this;
    [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach(function(gizmo) {
      if (gizmo) {
        gizmo.dispose();
      }
    });
    this._observables.forEach(function(obs) {
      _this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(obs);
    });
    this.onDragStartObservable.clear();
    this.onDragEndObservable.clear();
  };
  PositionGizmo2.prototype.setCustomMesh = function(mesh) {
    Logger.Error("Custom meshes are not supported on this gizmo, please set the custom meshes on the gizmos contained within this one (gizmo.xGizmo, gizmo.yGizmo, gizmo.zGizmo,gizmo.xPlaneGizmo, gizmo.yPlaneGizmo, gizmo.zPlaneGizmo)");
  };
  return PositionGizmo2;
}(Gizmo);

// node_modules/@babylonjs/core/Meshes/Builders/polyhedronBuilder.js
VertexData.CreatePolyhedron = function(options) {
  var polyhedra = [];
  polyhedra[0] = { vertex: [[0, 0, 1.732051], [1.632993, 0, -0.5773503], [-0.8164966, 1.414214, -0.5773503], [-0.8164966, -1.414214, -0.5773503]], face: [[0, 1, 2], [0, 2, 3], [0, 3, 1], [1, 3, 2]] };
  polyhedra[1] = { vertex: [[0, 0, 1.414214], [1.414214, 0, 0], [0, 1.414214, 0], [-1.414214, 0, 0], [0, -1.414214, 0], [0, 0, -1.414214]], face: [[0, 1, 2], [0, 2, 3], [0, 3, 4], [0, 4, 1], [1, 4, 5], [1, 5, 2], [2, 5, 3], [3, 5, 4]] };
  polyhedra[2] = {
    vertex: [[0, 0, 1.070466], [0.7136442, 0, 0.7978784], [-0.3568221, 0.618034, 0.7978784], [-0.3568221, -0.618034, 0.7978784], [0.7978784, 0.618034, 0.3568221], [0.7978784, -0.618034, 0.3568221], [-0.9341724, 0.381966, 0.3568221], [0.1362939, 1, 0.3568221], [0.1362939, -1, 0.3568221], [-0.9341724, -0.381966, 0.3568221], [0.9341724, 0.381966, -0.3568221], [0.9341724, -0.381966, -0.3568221], [-0.7978784, 0.618034, -0.3568221], [-0.1362939, 1, -0.3568221], [-0.1362939, -1, -0.3568221], [-0.7978784, -0.618034, -0.3568221], [0.3568221, 0.618034, -0.7978784], [0.3568221, -0.618034, -0.7978784], [-0.7136442, 0, -0.7978784], [0, 0, -1.070466]],
    face: [[0, 1, 4, 7, 2], [0, 2, 6, 9, 3], [0, 3, 8, 5, 1], [1, 5, 11, 10, 4], [2, 7, 13, 12, 6], [3, 9, 15, 14, 8], [4, 10, 16, 13, 7], [5, 8, 14, 17, 11], [6, 12, 18, 15, 9], [10, 11, 17, 19, 16], [12, 13, 16, 19, 18], [14, 15, 18, 19, 17]]
  };
  polyhedra[3] = {
    vertex: [[0, 0, 1.175571], [1.051462, 0, 0.5257311], [0.3249197, 1, 0.5257311], [-0.8506508, 0.618034, 0.5257311], [-0.8506508, -0.618034, 0.5257311], [0.3249197, -1, 0.5257311], [0.8506508, 0.618034, -0.5257311], [0.8506508, -0.618034, -0.5257311], [-0.3249197, 1, -0.5257311], [-1.051462, 0, -0.5257311], [-0.3249197, -1, -0.5257311], [0, 0, -1.175571]],
    face: [[0, 1, 2], [0, 2, 3], [0, 3, 4], [0, 4, 5], [0, 5, 1], [1, 5, 7], [1, 7, 6], [1, 6, 2], [2, 6, 8], [2, 8, 3], [3, 8, 9], [3, 9, 4], [4, 9, 10], [4, 10, 5], [5, 10, 7], [6, 7, 11], [6, 11, 8], [7, 10, 11], [8, 11, 9], [9, 11, 10]]
  };
  polyhedra[4] = {
    vertex: [[0, 0, 1.070722], [0.7148135, 0, 0.7971752], [-0.104682, 0.7071068, 0.7971752], [-0.6841528, 0.2071068, 0.7971752], [-0.104682, -0.7071068, 0.7971752], [0.6101315, 0.7071068, 0.5236279], [1.04156, 0.2071068, 0.1367736], [0.6101315, -0.7071068, 0.5236279], [-0.3574067, 1, 0.1367736], [-0.7888348, -0.5, 0.5236279], [-0.9368776, 0.5, 0.1367736], [-0.3574067, -1, 0.1367736], [0.3574067, 1, -0.1367736], [0.9368776, -0.5, -0.1367736], [0.7888348, 0.5, -0.5236279], [0.3574067, -1, -0.1367736], [-0.6101315, 0.7071068, -0.5236279], [-1.04156, -0.2071068, -0.1367736], [-0.6101315, -0.7071068, -0.5236279], [0.104682, 0.7071068, -0.7971752], [0.6841528, -0.2071068, -0.7971752], [0.104682, -0.7071068, -0.7971752], [-0.7148135, 0, -0.7971752], [0, 0, -1.070722]],
    face: [[0, 2, 3], [1, 6, 5], [4, 9, 11], [7, 15, 13], [8, 16, 10], [12, 14, 19], [17, 22, 18], [20, 21, 23], [0, 1, 5, 2], [0, 3, 9, 4], [0, 4, 7, 1], [1, 7, 13, 6], [2, 5, 12, 8], [2, 8, 10, 3], [3, 10, 17, 9], [4, 11, 15, 7], [5, 6, 14, 12], [6, 13, 20, 14], [8, 12, 19, 16], [9, 17, 18, 11], [10, 16, 22, 17], [11, 18, 21, 15], [13, 15, 21, 20], [14, 20, 23, 19], [16, 19, 23, 22], [18, 22, 23, 21]]
  };
  polyhedra[5] = { vertex: [[0, 0, 1.322876], [1.309307, 0, 0.1889822], [-0.9819805, 0.8660254, 0.1889822], [0.1636634, -1.299038, 0.1889822], [0.3273268, 0.8660254, -0.9449112], [-0.8183171, -0.4330127, -0.9449112]], face: [[0, 3, 1], [2, 4, 5], [0, 1, 4, 2], [0, 2, 5, 3], [1, 3, 5, 4]] };
  polyhedra[6] = { vertex: [[0, 0, 1.159953], [1.013464, 0, 0.5642542], [-0.3501431, 0.9510565, 0.5642542], [-0.7715208, -0.6571639, 0.5642542], [0.6633206, 0.9510565, -0.03144481], [0.8682979, -0.6571639, -0.3996071], [-1.121664, 0.2938926, -0.03144481], [-0.2348831, -1.063314, -0.3996071], [0.5181548, 0.2938926, -0.9953061], [-0.5850262, -0.112257, -0.9953061]], face: [[0, 1, 4, 2], [0, 2, 6, 3], [1, 5, 8, 4], [3, 6, 9, 7], [5, 7, 9, 8], [0, 3, 7, 5, 1], [2, 4, 8, 9, 6]] };
  polyhedra[7] = { vertex: [[0, 0, 1.118034], [0.8944272, 0, 0.6708204], [-0.2236068, 0.8660254, 0.6708204], [-0.7826238, -0.4330127, 0.6708204], [0.6708204, 0.8660254, 0.2236068], [1.006231, -0.4330127, -0.2236068], [-1.006231, 0.4330127, 0.2236068], [-0.6708204, -0.8660254, -0.2236068], [0.7826238, 0.4330127, -0.6708204], [0.2236068, -0.8660254, -0.6708204], [-0.8944272, 0, -0.6708204], [0, 0, -1.118034]], face: [[0, 1, 4, 2], [0, 2, 6, 3], [1, 5, 8, 4], [3, 6, 10, 7], [5, 9, 11, 8], [7, 10, 11, 9], [0, 3, 7, 9, 5, 1], [2, 4, 8, 11, 10, 6]] };
  polyhedra[8] = { vertex: [[-0.729665, 0.670121, 0.319155], [-0.655235, -0.29213, -0.754096], [-0.093922, -0.607123, 0.537818], [0.702196, 0.595691, 0.485187], [0.776626, -0.36656, -0.588064]], face: [[1, 4, 2], [0, 1, 2], [3, 0, 2], [4, 3, 2], [4, 1, 0, 3]] };
  polyhedra[9] = { vertex: [[-0.868849, -0.100041, 0.61257], [-0.329458, 0.976099, 0.28078], [-0.26629, -0.013796, -0.477654], [-0.13392, -1.034115, 0.229829], [0.738834, 0.707117, -0.307018], [0.859683, -0.535264, -0.338508]], face: [[3, 0, 2], [5, 3, 2], [4, 5, 2], [1, 4, 2], [0, 1, 2], [0, 3, 5, 4, 1]] };
  polyhedra[10] = { vertex: [[-0.610389, 0.243975, 0.531213], [-0.187812, -0.48795, -0.664016], [-0.187812, 0.9759, -0.664016], [0.187812, -0.9759, 0.664016], [0.798201, 0.243975, 0.132803]], face: [[1, 3, 0], [3, 4, 0], [3, 1, 4], [0, 2, 1], [0, 4, 2], [2, 4, 1]] };
  polyhedra[11] = { vertex: [[-1.028778, 0.392027, -0.048786], [-0.640503, -0.646161, 0.621837], [-0.125162, -0.395663, -0.540059], [4683e-6, 0.888447, -0.651988], [0.125161, 0.395663, 0.540059], [0.632925, -0.791376, 0.433102], [1.031672, 0.157063, -0.354165]], face: [[3, 2, 0], [2, 1, 0], [2, 5, 1], [0, 4, 3], [0, 1, 4], [4, 1, 5], [2, 3, 6], [3, 4, 6], [5, 2, 6], [4, 5, 6]] };
  polyhedra[12] = { vertex: [[-0.669867, 0.334933, -0.529576], [-0.669867, 0.334933, 0.529577], [-0.4043, 1.212901, 0], [-0.334933, -0.669867, -0.529576], [-0.334933, -0.669867, 0.529577], [0.334933, 0.669867, -0.529576], [0.334933, 0.669867, 0.529577], [0.4043, -1.212901, 0], [0.669867, -0.334933, -0.529576], [0.669867, -0.334933, 0.529577]], face: [[8, 9, 7], [6, 5, 2], [3, 8, 7], [5, 0, 2], [4, 3, 7], [0, 1, 2], [9, 4, 7], [1, 6, 2], [9, 8, 5, 6], [8, 3, 0, 5], [3, 4, 1, 0], [4, 9, 6, 1]] };
  polyhedra[13] = { vertex: [[-0.931836, 0.219976, -0.264632], [-0.636706, 0.318353, 0.692816], [-0.613483, -0.735083, -0.264632], [-0.326545, 0.979634, 0], [-0.318353, -0.636706, 0.692816], [-0.159176, 0.477529, -0.856368], [0.159176, -0.477529, -0.856368], [0.318353, 0.636706, 0.692816], [0.326545, -0.979634, 0], [0.613482, 0.735082, -0.264632], [0.636706, -0.318353, 0.692816], [0.931835, -0.219977, -0.264632]], face: [[11, 10, 8], [7, 9, 3], [6, 11, 8], [9, 5, 3], [2, 6, 8], [5, 0, 3], [4, 2, 8], [0, 1, 3], [10, 4, 8], [1, 7, 3], [10, 11, 9, 7], [11, 6, 5, 9], [6, 2, 0, 5], [2, 4, 1, 0], [4, 10, 7, 1]] };
  polyhedra[14] = {
    vertex: [[-0.93465, 0.300459, -0.271185], [-0.838689, -0.260219, -0.516017], [-0.711319, 0.717591, 0.128359], [-0.710334, -0.156922, 0.080946], [-0.599799, 0.556003, -0.725148], [-0.503838, -4675e-6, -0.969981], [-0.487004, 0.26021, 0.48049], [-0.460089, -0.750282, -0.512622], [-0.376468, 0.973135, -0.325605], [-0.331735, -0.646985, 0.084342], [-0.254001, 0.831847, 0.530001], [-0.125239, -0.494738, -0.966586], [0.029622, 0.027949, 0.730817], [0.056536, -0.982543, -0.262295], [0.08085, 1.087391, 0.076037], [0.125583, -0.532729, 0.485984], [0.262625, 0.599586, 0.780328], [0.391387, -0.726999, -0.716259], [0.513854, -0.868287, 0.139347], [0.597475, 0.85513, 0.326364], [0.641224, 0.109523, 0.783723], [0.737185, -0.451155, 0.538891], [0.848705, -0.612742, -0.314616], [0.976075, 0.365067, 0.32976], [1.072036, -0.19561, 0.084927]],
    face: [[15, 18, 21], [12, 20, 16], [6, 10, 2], [3, 0, 1], [9, 7, 13], [2, 8, 4, 0], [0, 4, 5, 1], [1, 5, 11, 7], [7, 11, 17, 13], [13, 17, 22, 18], [18, 22, 24, 21], [21, 24, 23, 20], [20, 23, 19, 16], [16, 19, 14, 10], [10, 14, 8, 2], [15, 9, 13, 18], [12, 15, 21, 20], [6, 12, 16, 10], [3, 6, 2, 0], [9, 3, 1, 7], [9, 15, 12, 6, 3], [22, 17, 11, 5, 4, 8, 14, 19, 23, 24]]
  };
  var type = options.type && (options.type < 0 || options.type >= polyhedra.length) ? 0 : options.type || 0;
  var size = options.size;
  var sizeX = options.sizeX || size || 1;
  var sizeY = options.sizeY || size || 1;
  var sizeZ = options.sizeZ || size || 1;
  var data = options.custom || polyhedra[type];
  var nbfaces = data.face.length;
  var faceUV = options.faceUV || new Array(nbfaces);
  var faceColors = options.faceColors;
  var flat = options.flat === void 0 ? true : options.flat;
  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  var positions = new Array();
  var indices = new Array();
  var normals = new Array();
  var uvs = new Array();
  var colors = new Array();
  var index = 0;
  var faceIdx = 0;
  var indexes = new Array();
  var i = 0;
  var f = 0;
  var u, v, ang, x, y, tmp;
  if (flat) {
    for (f = 0; f < nbfaces; f++) {
      if (faceColors && faceColors[f] === void 0) {
        faceColors[f] = new Color4(1, 1, 1, 1);
      }
      if (faceUV && faceUV[f] === void 0) {
        faceUV[f] = new Vector4(0, 0, 1, 1);
      }
    }
  }
  if (!flat) {
    for (i = 0; i < data.vertex.length; i++) {
      positions.push(data.vertex[i][0] * sizeX, data.vertex[i][1] * sizeY, data.vertex[i][2] * sizeZ);
      uvs.push(0, 0);
    }
    for (f = 0; f < nbfaces; f++) {
      for (i = 0; i < data.face[f].length - 2; i++) {
        indices.push(data.face[f][0], data.face[f][i + 2], data.face[f][i + 1]);
      }
    }
  } else {
    for (f = 0; f < nbfaces; f++) {
      var fl = data.face[f].length;
      ang = 2 * Math.PI / fl;
      x = 0.5 * Math.tan(ang / 2);
      y = 0.5;
      for (i = 0; i < fl; i++) {
        positions.push(data.vertex[data.face[f][i]][0] * sizeX, data.vertex[data.face[f][i]][1] * sizeY, data.vertex[data.face[f][i]][2] * sizeZ);
        indexes.push(index);
        index++;
        u = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * (0.5 + x);
        v = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * (y - 0.5);
        uvs.push(u, v);
        tmp = x * Math.cos(ang) - y * Math.sin(ang);
        y = x * Math.sin(ang) + y * Math.cos(ang);
        x = tmp;
        if (faceColors) {
          colors.push(faceColors[f].r, faceColors[f].g, faceColors[f].b, faceColors[f].a);
        }
      }
      for (i = 0; i < fl - 2; i++) {
        indices.push(indexes[0 + faceIdx], indexes[i + 2 + faceIdx], indexes[i + 1 + faceIdx]);
      }
      faceIdx += fl;
    }
  }
  VertexData.ComputeNormals(positions, indices, normals);
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  var vertexData = new VertexData();
  vertexData.positions = positions;
  vertexData.indices = indices;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  if (faceColors && flat) {
    vertexData.colors = colors;
  }
  return vertexData;
};
Mesh.CreatePolyhedron = function(name98, options, scene) {
  return PolyhedronBuilder.CreatePolyhedron(name98, options, scene);
};
var PolyhedronBuilder = function() {
  function PolyhedronBuilder2() {
  }
  PolyhedronBuilder2.CreatePolyhedron = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    var polyhedron = new Mesh(name98, scene);
    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
    polyhedron._originalBuilderSideOrientation = options.sideOrientation;
    var vertexData = VertexData.CreatePolyhedron(options);
    vertexData.applyToMesh(polyhedron, options.updatable);
    return polyhedron;
  };
  return PolyhedronBuilder2;
}();

// node_modules/@babylonjs/core/Gizmos/scaleGizmo.js
var ScaleGizmo = function(_super) {
  __extends(ScaleGizmo2, _super);
  function ScaleGizmo2(gizmoLayer, thickness, gizmoManager) {
    if (gizmoLayer === void 0) {
      gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer;
    }
    if (thickness === void 0) {
      thickness = 1;
    }
    var _this = _super.call(this, gizmoLayer) || this;
    _this._meshAttached = null;
    _this._nodeAttached = null;
    _this._sensitivity = 1;
    _this._observables = [];
    _this._gizmoAxisCache = /* @__PURE__ */ new Map();
    _this.onDragStartObservable = new Observable();
    _this.onDragEndObservable = new Observable();
    _this.uniformScaleGizmo = _this._createUniformScaleMesh();
    _this.xGizmo = new AxisScaleGizmo(new Vector3(1, 0, 0), Color3.Red().scale(0.5), gizmoLayer, _this, thickness);
    _this.yGizmo = new AxisScaleGizmo(new Vector3(0, 1, 0), Color3.Green().scale(0.5), gizmoLayer, _this, thickness);
    _this.zGizmo = new AxisScaleGizmo(new Vector3(0, 0, 1), Color3.Blue().scale(0.5), gizmoLayer, _this, thickness);
    [_this.xGizmo, _this.yGizmo, _this.zGizmo, _this.uniformScaleGizmo].forEach(function(gizmo) {
      gizmo.dragBehavior.onDragStartObservable.add(function() {
        _this.onDragStartObservable.notifyObservers({});
      });
      gizmo.dragBehavior.onDragEndObservable.add(function() {
        _this.onDragEndObservable.notifyObservers({});
      });
    });
    _this.attachedMesh = null;
    _this.attachedNode = null;
    if (gizmoManager) {
      gizmoManager.addToAxisCache(_this._gizmoAxisCache);
    } else {
      Gizmo.GizmoAxisPointerObserver(gizmoLayer, _this._gizmoAxisCache);
    }
    return _this;
  }
  Object.defineProperty(ScaleGizmo2.prototype, "attachedMesh", {
    get: function() {
      return this._meshAttached;
    },
    set: function(mesh) {
      this._meshAttached = mesh;
      this._nodeAttached = mesh;
      [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach(function(gizmo) {
        if (gizmo.isEnabled) {
          gizmo.attachedMesh = mesh;
        } else {
          gizmo.attachedMesh = null;
        }
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScaleGizmo2.prototype, "attachedNode", {
    get: function() {
      return this._nodeAttached;
    },
    set: function(node) {
      this._meshAttached = null;
      this._nodeAttached = node;
      [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach(function(gizmo) {
        if (gizmo.isEnabled) {
          gizmo.attachedNode = node;
        } else {
          gizmo.attachedNode = null;
        }
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScaleGizmo2.prototype, "isHovered", {
    get: function() {
      var hovered = false;
      [this.xGizmo, this.yGizmo, this.zGizmo].forEach(function(gizmo) {
        hovered = hovered || gizmo.isHovered;
      });
      return hovered;
    },
    enumerable: false,
    configurable: true
  });
  ScaleGizmo2.prototype._createUniformScaleMesh = function() {
    this._coloredMaterial = new StandardMaterial("", this.gizmoLayer.utilityLayerScene);
    this._coloredMaterial.diffuseColor = Color3.Gray();
    this._hoverMaterial = new StandardMaterial("", this.gizmoLayer.utilityLayerScene);
    this._hoverMaterial.diffuseColor = Color3.Yellow();
    this._disableMaterial = new StandardMaterial("", this.gizmoLayer.utilityLayerScene);
    this._disableMaterial.diffuseColor = Color3.Gray();
    this._disableMaterial.alpha = 0.4;
    var uniformScaleGizmo = new AxisScaleGizmo(new Vector3(0, 1, 0), Color3.Gray().scale(0.5), this.gizmoLayer, this);
    uniformScaleGizmo.updateGizmoRotationToMatchAttachedMesh = false;
    uniformScaleGizmo.uniformScaling = true;
    this._uniformScalingMesh = PolyhedronBuilder.CreatePolyhedron("uniform", { type: 1 }, uniformScaleGizmo.gizmoLayer.utilityLayerScene);
    this._uniformScalingMesh.scaling.scaleInPlace(0.01);
    this._uniformScalingMesh.visibility = 0;
    this._octahedron = PolyhedronBuilder.CreatePolyhedron("", { type: 1 }, uniformScaleGizmo.gizmoLayer.utilityLayerScene);
    this._octahedron.scaling.scaleInPlace(7e-3);
    this._uniformScalingMesh.addChild(this._octahedron);
    uniformScaleGizmo.setCustomMesh(this._uniformScalingMesh, true);
    var light = this.gizmoLayer._getSharedGizmoLight();
    light.includedOnlyMeshes = light.includedOnlyMeshes.concat(this._octahedron);
    var cache = {
      gizmoMeshes: [this._octahedron, this._uniformScalingMesh],
      colliderMeshes: [this._uniformScalingMesh],
      material: this._coloredMaterial,
      hoverMaterial: this._hoverMaterial,
      disableMaterial: this._disableMaterial,
      active: false
    };
    this.addToAxisCache(uniformScaleGizmo._rootMesh, cache);
    return uniformScaleGizmo;
  };
  Object.defineProperty(ScaleGizmo2.prototype, "updateGizmoRotationToMatchAttachedMesh", {
    get: function() {
      return this._updateGizmoRotationToMatchAttachedMesh;
    },
    set: function(value) {
      if (!value) {
        Logger.Warn("Setting updateGizmoRotationToMatchAttachedMesh = false on scaling gizmo is not supported.");
      } else {
        this._updateGizmoRotationToMatchAttachedMesh = value;
        [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach(function(gizmo) {
          if (gizmo) {
            gizmo.updateGizmoRotationToMatchAttachedMesh = value;
          }
        });
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScaleGizmo2.prototype, "snapDistance", {
    get: function() {
      return this._snapDistance;
    },
    set: function(value) {
      this._snapDistance = value;
      [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach(function(gizmo) {
        if (gizmo) {
          gizmo.snapDistance = value;
        }
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScaleGizmo2.prototype, "scaleRatio", {
    get: function() {
      return this._scaleRatio;
    },
    set: function(value) {
      this._scaleRatio = value;
      [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach(function(gizmo) {
        if (gizmo) {
          gizmo.scaleRatio = value;
        }
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScaleGizmo2.prototype, "sensitivity", {
    get: function() {
      return this._sensitivity;
    },
    set: function(value) {
      this._sensitivity = value;
      [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach(function(gizmo) {
        if (gizmo) {
          gizmo.sensitivity = value;
        }
      });
    },
    enumerable: false,
    configurable: true
  });
  ScaleGizmo2.prototype.addToAxisCache = function(mesh, cache) {
    this._gizmoAxisCache.set(mesh, cache);
  };
  ScaleGizmo2.prototype.dispose = function() {
    var _this = this;
    [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach(function(gizmo) {
      if (gizmo) {
        gizmo.dispose();
      }
    });
    this._observables.forEach(function(obs) {
      _this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(obs);
    });
    this.onDragStartObservable.clear();
    this.onDragEndObservable.clear();
    [this._uniformScalingMesh, this._octahedron].forEach(function(msh) {
      if (msh) {
        msh.dispose();
      }
    });
    [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach(function(matl) {
      if (matl) {
        matl.dispose();
      }
    });
  };
  return ScaleGizmo2;
}(Gizmo);

// node_modules/@babylonjs/core/Gizmos/gizmoManager.js
var GizmoManager = function() {
  function GizmoManager2(scene, thickness, utilityLayer, keepDepthUtilityLayer) {
    if (thickness === void 0) {
      thickness = 1;
    }
    if (utilityLayer === void 0) {
      utilityLayer = UtilityLayerRenderer.DefaultUtilityLayer;
    }
    if (keepDepthUtilityLayer === void 0) {
      keepDepthUtilityLayer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer;
    }
    this.scene = scene;
    this.clearGizmoOnEmptyPointerEvent = false;
    this.onAttachedToMeshObservable = new Observable();
    this.onAttachedToNodeObservable = new Observable();
    this._gizmosEnabled = { positionGizmo: false, rotationGizmo: false, scaleGizmo: false, boundingBoxGizmo: false };
    this._pointerObservers = [];
    this._attachedMesh = null;
    this._attachedNode = null;
    this._boundingBoxColor = Color3.FromHexString("#0984e3");
    this._thickness = 1;
    this._gizmoAxisCache = /* @__PURE__ */ new Map();
    this.boundingBoxDragBehavior = new SixDofDragBehavior();
    this.attachableMeshes = null;
    this.attachableNodes = null;
    this.usePointerToAttachGizmos = true;
    this._defaultUtilityLayer = utilityLayer;
    this._defaultKeepDepthUtilityLayer = keepDepthUtilityLayer;
    this._defaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;
    this._thickness = thickness;
    this.gizmos = { positionGizmo: null, rotationGizmo: null, scaleGizmo: null, boundingBoxGizmo: null };
    var attachToMeshPointerObserver = this._attachToMeshPointerObserver(scene);
    var gizmoAxisPointerObserver = Gizmo.GizmoAxisPointerObserver(this._defaultUtilityLayer, this._gizmoAxisCache);
    this._pointerObservers = [attachToMeshPointerObserver, gizmoAxisPointerObserver];
  }
  Object.defineProperty(GizmoManager2.prototype, "keepDepthUtilityLayer", {
    get: function() {
      return this._defaultKeepDepthUtilityLayer;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GizmoManager2.prototype, "utilityLayer", {
    get: function() {
      return this._defaultUtilityLayer;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GizmoManager2.prototype, "isHovered", {
    get: function() {
      var hovered = false;
      for (var key in this.gizmos) {
        var gizmo = this.gizmos[key];
        if (gizmo && gizmo.isHovered) {
          hovered = true;
          break;
        }
      }
      return hovered;
    },
    enumerable: false,
    configurable: true
  });
  GizmoManager2.prototype._attachToMeshPointerObserver = function(scene) {
    var _this = this;
    var pointerObserver = scene.onPointerObservable.add(function(pointerInfo) {
      if (!_this.usePointerToAttachGizmos) {
        return;
      }
      if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {
        if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh) {
          var node = pointerInfo.pickInfo.pickedMesh;
          if (_this.attachableMeshes == null) {
            while (node && node.parent != null) {
              node = node.parent;
            }
          } else {
            var found = false;
            _this.attachableMeshes.forEach(function(mesh) {
              if (node && (node == mesh || node.isDescendantOf(mesh))) {
                node = mesh;
                found = true;
              }
            });
            if (!found) {
              node = null;
            }
          }
          if (node instanceof AbstractMesh) {
            if (_this._attachedMesh != node) {
              _this.attachToMesh(node);
            }
          } else {
            if (_this.clearGizmoOnEmptyPointerEvent) {
              _this.attachToMesh(null);
            }
          }
        } else {
          if (_this.clearGizmoOnEmptyPointerEvent) {
            _this.attachToMesh(null);
          }
        }
      }
    });
    return pointerObserver;
  };
  GizmoManager2.prototype.attachToMesh = function(mesh) {
    if (this._attachedMesh) {
      this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);
    }
    if (this._attachedNode) {
      this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);
    }
    this._attachedMesh = mesh;
    this._attachedNode = null;
    for (var key in this.gizmos) {
      var gizmo = this.gizmos[key];
      if (gizmo && this._gizmosEnabled[key]) {
        gizmo.attachedMesh = mesh;
      }
    }
    if (this.boundingBoxGizmoEnabled && this._attachedMesh) {
      this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);
    }
    this.onAttachedToMeshObservable.notifyObservers(mesh);
  };
  GizmoManager2.prototype.attachToNode = function(node) {
    if (this._attachedMesh) {
      this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);
    }
    if (this._attachedNode) {
      this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);
    }
    this._attachedMesh = null;
    this._attachedNode = node;
    for (var key in this.gizmos) {
      var gizmo = this.gizmos[key];
      if (gizmo && this._gizmosEnabled[key]) {
        gizmo.attachedNode = node;
      }
    }
    if (this.boundingBoxGizmoEnabled && this._attachedNode) {
      this._attachedNode.addBehavior(this.boundingBoxDragBehavior);
    }
    this.onAttachedToNodeObservable.notifyObservers(node);
  };
  Object.defineProperty(GizmoManager2.prototype, "positionGizmoEnabled", {
    get: function() {
      return this._gizmosEnabled.positionGizmo;
    },
    set: function(value) {
      if (value) {
        if (!this.gizmos.positionGizmo) {
          this.gizmos.positionGizmo = new PositionGizmo(this._defaultUtilityLayer, this._thickness, this);
        }
        if (this._attachedNode) {
          this.gizmos.positionGizmo.attachedNode = this._attachedNode;
        } else {
          this.gizmos.positionGizmo.attachedMesh = this._attachedMesh;
        }
      } else if (this.gizmos.positionGizmo) {
        this.gizmos.positionGizmo.attachedNode = null;
      }
      this._gizmosEnabled.positionGizmo = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GizmoManager2.prototype, "rotationGizmoEnabled", {
    get: function() {
      return this._gizmosEnabled.rotationGizmo;
    },
    set: function(value) {
      if (value) {
        if (!this.gizmos.rotationGizmo) {
          this.gizmos.rotationGizmo = new RotationGizmo(this._defaultUtilityLayer, 32, false, this._thickness, this);
        }
        if (this._attachedNode) {
          this.gizmos.rotationGizmo.attachedNode = this._attachedNode;
        } else {
          this.gizmos.rotationGizmo.attachedMesh = this._attachedMesh;
        }
      } else if (this.gizmos.rotationGizmo) {
        this.gizmos.rotationGizmo.attachedNode = null;
      }
      this._gizmosEnabled.rotationGizmo = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GizmoManager2.prototype, "scaleGizmoEnabled", {
    get: function() {
      return this._gizmosEnabled.scaleGizmo;
    },
    set: function(value) {
      if (value) {
        this.gizmos.scaleGizmo = this.gizmos.scaleGizmo || new ScaleGizmo(this._defaultUtilityLayer, this._thickness, this);
        if (this._attachedNode) {
          this.gizmos.scaleGizmo.attachedNode = this._attachedNode;
        } else {
          this.gizmos.scaleGizmo.attachedMesh = this._attachedMesh;
        }
      } else if (this.gizmos.scaleGizmo) {
        this.gizmos.scaleGizmo.attachedNode = null;
      }
      this._gizmosEnabled.scaleGizmo = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GizmoManager2.prototype, "boundingBoxGizmoEnabled", {
    get: function() {
      return this._gizmosEnabled.boundingBoxGizmo;
    },
    set: function(value) {
      if (value) {
        this.gizmos.boundingBoxGizmo = this.gizmos.boundingBoxGizmo || new BoundingBoxGizmo(this._boundingBoxColor, this._defaultKeepDepthUtilityLayer);
        if (this._attachedMesh) {
          this.gizmos.boundingBoxGizmo.attachedMesh = this._attachedMesh;
        } else {
          this.gizmos.boundingBoxGizmo.attachedNode = this._attachedNode;
        }
        if (this._attachedMesh) {
          this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);
          this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);
        } else if (this._attachedNode) {
          this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);
          this._attachedNode.addBehavior(this.boundingBoxDragBehavior);
        }
      } else if (this.gizmos.boundingBoxGizmo) {
        if (this._attachedMesh) {
          this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);
        } else if (this._attachedNode) {
          this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);
        }
        this.gizmos.boundingBoxGizmo.attachedNode = null;
      }
      this._gizmosEnabled.boundingBoxGizmo = value;
    },
    enumerable: false,
    configurable: true
  });
  GizmoManager2.prototype.addToAxisCache = function(gizmoAxisCache) {
    var _this = this;
    if (gizmoAxisCache.size > 0) {
      gizmoAxisCache.forEach(function(v, k) {
        _this._gizmoAxisCache.set(k, v);
      });
    }
  };
  GizmoManager2.prototype.dispose = function() {
    var _this = this;
    this._pointerObservers.forEach(function(observer) {
      _this.scene.onPointerObservable.remove(observer);
    });
    for (var key in this.gizmos) {
      var gizmo = this.gizmos[key];
      if (gizmo) {
        gizmo.dispose();
      }
    }
    this._defaultKeepDepthUtilityLayer.dispose();
    this._defaultUtilityLayer.dispose();
    this.boundingBoxDragBehavior.detach();
    this.onAttachedToMeshObservable.clear();
  };
  return GizmoManager2;
}();

// node_modules/@babylonjs/core/Meshes/Builders/hemisphereBuilder.js
Mesh.CreateHemisphere = function(name98, segments, diameter, scene) {
  var options = {
    segments,
    diameter
  };
  return HemisphereBuilder.CreateHemisphere(name98, options, scene);
};
var HemisphereBuilder = function() {
  function HemisphereBuilder2() {
  }
  HemisphereBuilder2.CreateHemisphere = function(name98, options, scene) {
    if (!options.diameter) {
      options.diameter = 1;
    }
    if (!options.segments) {
      options.segments = 16;
    }
    var halfSphere = SphereBuilder.CreateSphere("", { slice: 0.5, diameter: options.diameter, segments: options.segments }, scene);
    var disc = Mesh.CreateDisc("", options.diameter / 2, options.segments * 3 + (4 - options.segments), scene);
    disc.rotation.x = -Math.PI / 2;
    disc.parent = halfSphere;
    var merged = Mesh.MergeMeshes([disc, halfSphere], true);
    merged.name = name98;
    return merged;
  };
  return HemisphereBuilder2;
}();

// node_modules/@babylonjs/core/Gizmos/lightGizmo.js
var LightGizmo = function(_super) {
  __extends(LightGizmo2, _super);
  function LightGizmo2(gizmoLayer) {
    if (gizmoLayer === void 0) {
      gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer;
    }
    var _this = _super.call(this, gizmoLayer) || this;
    _this._cachedPosition = new Vector3();
    _this._cachedForward = new Vector3(0, 0, 1);
    _this._pointerObserver = null;
    _this.onClickedObservable = new Observable();
    _this._light = null;
    _this.attachedMesh = new AbstractMesh("", _this.gizmoLayer.utilityLayerScene);
    _this._attachedMeshParent = new TransformNode("parent", _this.gizmoLayer.utilityLayerScene);
    _this.attachedMesh.parent = _this._attachedMeshParent;
    _this._material = new StandardMaterial("light", _this.gizmoLayer.utilityLayerScene);
    _this._material.diffuseColor = new Color3(0.5, 0.5, 0.5);
    _this._material.specularColor = new Color3(0.1, 0.1, 0.1);
    _this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function(pointerInfo) {
      if (!_this._light) {
        return;
      }
      _this._isHovered = !!(pointerInfo.pickInfo && _this._rootMesh.getChildMeshes().indexOf(pointerInfo.pickInfo.pickedMesh) != -1);
      if (_this._isHovered && pointerInfo.event.button === 0) {
        _this.onClickedObservable.notifyObservers(_this._light);
      }
    }, PointerEventTypes.POINTERDOWN);
    return _this;
  }
  Object.defineProperty(LightGizmo2.prototype, "light", {
    get: function() {
      return this._light;
    },
    set: function(light) {
      var _this = this;
      this._light = light;
      if (light) {
        if (this._lightMesh) {
          this._lightMesh.dispose();
        }
        if (light instanceof HemisphericLight) {
          this._lightMesh = LightGizmo2._CreateHemisphericLightMesh(this.gizmoLayer.utilityLayerScene);
        } else if (light instanceof DirectionalLight) {
          this._lightMesh = LightGizmo2._CreateDirectionalLightMesh(this.gizmoLayer.utilityLayerScene);
        } else if (light instanceof SpotLight) {
          this._lightMesh = LightGizmo2._CreateSpotLightMesh(this.gizmoLayer.utilityLayerScene);
        } else {
          this._lightMesh = LightGizmo2._CreatePointLightMesh(this.gizmoLayer.utilityLayerScene);
        }
        this._lightMesh.getChildMeshes(false).forEach(function(m) {
          m.material = _this._material;
        });
        this._lightMesh.parent = this._rootMesh;
        var gizmoLight = this.gizmoLayer._getSharedGizmoLight();
        gizmoLight.includedOnlyMeshes = gizmoLight.includedOnlyMeshes.concat(this._lightMesh.getChildMeshes(false));
        this._lightMesh.rotationQuaternion = new Quaternion();
        if (!this.attachedMesh.reservedDataStore) {
          this.attachedMesh.reservedDataStore = {};
        }
        this.attachedMesh.reservedDataStore.lightGizmo = this;
        if (light.parent) {
          this._attachedMeshParent.freezeWorldMatrix(light.parent.getWorldMatrix());
        }
        if (light.position) {
          this.attachedMesh.position.copyFrom(light.position);
          this.attachedMesh.computeWorldMatrix(true);
          this._cachedPosition.copyFrom(this.attachedMesh.position);
        }
        if (light.direction) {
          this.attachedMesh.setDirection(light.direction);
          this.attachedMesh.computeWorldMatrix(true);
          this._cachedForward.copyFrom(this.attachedMesh.forward);
        }
        this._update();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LightGizmo2.prototype, "material", {
    get: function() {
      return this._material;
    },
    enumerable: false,
    configurable: true
  });
  LightGizmo2.prototype._update = function() {
    _super.prototype._update.call(this);
    if (!this._light) {
      return;
    }
    if (this._light.parent) {
      this._attachedMeshParent.freezeWorldMatrix(this._light.parent.getWorldMatrix());
    }
    if (this._light.position) {
      if (!this.attachedMesh.position.equals(this._cachedPosition)) {
        this._light.position.copyFrom(this.attachedMesh.position);
        this._cachedPosition.copyFrom(this.attachedMesh.position);
      } else {
        this.attachedMesh.position.copyFrom(this._light.position);
        this.attachedMesh.computeWorldMatrix(true);
        this._cachedPosition.copyFrom(this.attachedMesh.position);
      }
    }
    if (this._light.direction) {
      if (Vector3.DistanceSquared(this.attachedMesh.forward, this._cachedForward) > 1e-4) {
        this._light.direction.copyFrom(this.attachedMesh.forward);
        this._cachedForward.copyFrom(this.attachedMesh.forward);
      } else if (Vector3.DistanceSquared(this.attachedMesh.forward, this._light.direction) > 1e-4) {
        this.attachedMesh.setDirection(this._light.direction);
        this.attachedMesh.computeWorldMatrix(true);
        this._cachedForward.copyFrom(this.attachedMesh.forward);
      }
    }
  };
  LightGizmo2.prototype.dispose = function() {
    this.onClickedObservable.clear();
    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
    this._material.dispose();
    _super.prototype.dispose.call(this);
    this._attachedMeshParent.dispose();
  };
  LightGizmo2._CreateHemisphericLightMesh = function(scene) {
    var root = new Mesh("hemisphereLight", scene);
    var hemisphere = HemisphereBuilder.CreateHemisphere(root.name, { segments: 10, diameter: 1 }, scene);
    hemisphere.position.z = -0.15;
    hemisphere.rotation.x = Math.PI / 2;
    hemisphere.parent = root;
    var lines = this._CreateLightLines(3, scene);
    lines.parent = root;
    lines.position.z - 0.15;
    root.scaling.scaleInPlace(LightGizmo2._Scale);
    root.rotation.x = Math.PI / 2;
    return root;
  };
  LightGizmo2._CreatePointLightMesh = function(scene) {
    var root = new Mesh("pointLight", scene);
    var sphere = SphereBuilder.CreateSphere(root.name, { segments: 10, diameter: 1 }, scene);
    sphere.rotation.x = Math.PI / 2;
    sphere.parent = root;
    var lines = this._CreateLightLines(5, scene);
    lines.parent = root;
    root.scaling.scaleInPlace(LightGizmo2._Scale);
    root.rotation.x = Math.PI / 2;
    return root;
  };
  LightGizmo2._CreateSpotLightMesh = function(scene) {
    var root = new Mesh("spotLight", scene);
    var sphere = SphereBuilder.CreateSphere(root.name, { segments: 10, diameter: 1 }, scene);
    sphere.parent = root;
    var hemisphere = HemisphereBuilder.CreateHemisphere(root.name, { segments: 10, diameter: 2 }, scene);
    hemisphere.parent = root;
    hemisphere.rotation.x = -Math.PI / 2;
    var lines = this._CreateLightLines(2, scene);
    lines.parent = root;
    root.scaling.scaleInPlace(LightGizmo2._Scale);
    root.rotation.x = Math.PI / 2;
    return root;
  };
  LightGizmo2._CreateDirectionalLightMesh = function(scene) {
    var root = new Mesh("directionalLight", scene);
    var mesh = new Mesh(root.name, scene);
    mesh.parent = root;
    var sphere = SphereBuilder.CreateSphere(root.name, { diameter: 1.2, segments: 10 }, scene);
    sphere.parent = mesh;
    var line = Mesh.CreateCylinder(root.name, 6, 0.3, 0.3, 6, 1, scene);
    line.parent = mesh;
    var left = line.clone(root.name);
    left.scaling.y = 0.5;
    left.position.x += 1.25;
    var right = line.clone(root.name);
    right.scaling.y = 0.5;
    right.position.x += -1.25;
    var arrowHead = Mesh.CreateCylinder(root.name, 1, 0, 0.6, 6, 1, scene);
    arrowHead.position.y += 3;
    arrowHead.parent = mesh;
    var left = arrowHead.clone(root.name);
    left.position.y = 1.5;
    left.position.x += 1.25;
    var right = arrowHead.clone(root.name);
    right.position.y = 1.5;
    right.position.x += -1.25;
    mesh.scaling.scaleInPlace(LightGizmo2._Scale);
    mesh.rotation.z = Math.PI / 2;
    mesh.rotation.y = Math.PI / 2;
    return root;
  };
  LightGizmo2._Scale = 7e-3;
  LightGizmo2._CreateLightLines = function(levels, scene) {
    var distFromSphere = 1.2;
    var root = new Mesh("root", scene);
    root.rotation.x = Math.PI / 2;
    var linePivot = new Mesh("linePivot", scene);
    linePivot.parent = root;
    var line = Mesh.CreateCylinder("line", 2, 0.2, 0.3, 6, 1, scene);
    line.position.y = line.scaling.y / 2 + distFromSphere;
    line.parent = linePivot;
    if (levels < 2) {
      return linePivot;
    }
    for (var i = 0; i < 4; i++) {
      var l = linePivot.clone("lineParentClone");
      l.rotation.z = Math.PI / 4;
      l.rotation.y = Math.PI / 2 + Math.PI / 2 * i;
      l.getChildMeshes()[0].scaling.y = 0.5;
      l.getChildMeshes()[0].scaling.x = l.getChildMeshes()[0].scaling.z = 0.8;
      l.getChildMeshes()[0].position.y = l.getChildMeshes()[0].scaling.y / 2 + distFromSphere;
    }
    if (levels < 3) {
      return root;
    }
    for (var i = 0; i < 4; i++) {
      var l = linePivot.clone("linePivotClone");
      l.rotation.z = Math.PI / 2;
      l.rotation.y = Math.PI / 2 * i;
    }
    if (levels < 4) {
      return root;
    }
    for (var i = 0; i < 4; i++) {
      var l = linePivot.clone("linePivotClone");
      l.rotation.z = Math.PI + Math.PI / 4;
      l.rotation.y = Math.PI / 2 + Math.PI / 2 * i;
      l.getChildMeshes()[0].scaling.y = 0.5;
      l.getChildMeshes()[0].scaling.x = l.getChildMeshes()[0].scaling.z = 0.8;
      l.getChildMeshes()[0].position.y = l.getChildMeshes()[0].scaling.y / 2 + distFromSphere;
    }
    if (levels < 5) {
      return root;
    }
    var l = linePivot.clone("linePivotClone");
    l.rotation.z = Math.PI;
    return root;
  };
  return LightGizmo2;
}(Gizmo);

// node_modules/@babylonjs/core/Maths/math.vertexFormat.js
var PositionNormalVertex = function() {
  function PositionNormalVertex2(position, normal) {
    if (position === void 0) {
      position = Vector3.Zero();
    }
    if (normal === void 0) {
      normal = Vector3.Up();
    }
    this.position = position;
    this.normal = normal;
  }
  PositionNormalVertex2.prototype.clone = function() {
    return new PositionNormalVertex2(this.position.clone(), this.normal.clone());
  };
  return PositionNormalVertex2;
}();
var PositionNormalTextureVertex = function() {
  function PositionNormalTextureVertex2(position, normal, uv) {
    if (position === void 0) {
      position = Vector3.Zero();
    }
    if (normal === void 0) {
      normal = Vector3.Up();
    }
    if (uv === void 0) {
      uv = Vector2.Zero();
    }
    this.position = position;
    this.normal = normal;
    this.uv = uv;
  }
  PositionNormalTextureVertex2.prototype.clone = function() {
    return new PositionNormalTextureVertex2(this.position.clone(), this.normal.clone(), this.uv.clone());
  };
  return PositionNormalTextureVertex2;
}();

// node_modules/@babylonjs/core/Gizmos/cameraGizmo.js
var CameraGizmo = function(_super) {
  __extends(CameraGizmo2, _super);
  function CameraGizmo2(gizmoLayer) {
    if (gizmoLayer === void 0) {
      gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer;
    }
    var _this = _super.call(this, gizmoLayer) || this;
    _this._pointerObserver = null;
    _this.onClickedObservable = new Observable();
    _this._camera = null;
    _this._invProjection = new Matrix();
    _this._material = new StandardMaterial("cameraGizmoMaterial", _this.gizmoLayer.utilityLayerScene);
    _this._material.diffuseColor = new Color3(0.5, 0.5, 0.5);
    _this._material.specularColor = new Color3(0.1, 0.1, 0.1);
    _this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function(pointerInfo) {
      if (!_this._camera) {
        return;
      }
      _this._isHovered = !!(pointerInfo.pickInfo && _this._rootMesh.getChildMeshes().indexOf(pointerInfo.pickInfo.pickedMesh) != -1);
      if (_this._isHovered && pointerInfo.event.button === 0) {
        _this.onClickedObservable.notifyObservers(_this._camera);
      }
    }, PointerEventTypes.POINTERDOWN);
    return _this;
  }
  Object.defineProperty(CameraGizmo2.prototype, "displayFrustum", {
    get: function() {
      return this._cameraLinesMesh.isEnabled();
    },
    set: function(value) {
      this._cameraLinesMesh.setEnabled(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CameraGizmo2.prototype, "camera", {
    get: function() {
      return this._camera;
    },
    set: function(camera) {
      var _this = this;
      this._camera = camera;
      this.attachedNode = camera;
      if (camera) {
        if (this._cameraMesh) {
          this._cameraMesh.dispose();
        }
        if (this._cameraLinesMesh) {
          this._cameraLinesMesh.dispose();
        }
        this._cameraMesh = CameraGizmo2._CreateCameraMesh(this.gizmoLayer.utilityLayerScene);
        this._cameraLinesMesh = CameraGizmo2._CreateCameraFrustum(this.gizmoLayer.utilityLayerScene);
        this._cameraMesh.getChildMeshes(false).forEach(function(m) {
          m.material = _this._material;
        });
        this._cameraMesh.parent = this._rootMesh;
        this._cameraLinesMesh.parent = this._rootMesh;
        if (this.gizmoLayer.utilityLayerScene.activeCamera && this.gizmoLayer.utilityLayerScene.activeCamera.maxZ < camera.maxZ * 1.5) {
          this.gizmoLayer.utilityLayerScene.activeCamera.maxZ = camera.maxZ * 1.5;
        }
        if (!this.attachedNode.reservedDataStore) {
          this.attachedNode.reservedDataStore = {};
        }
        this.attachedNode.reservedDataStore.cameraGizmo = this;
        var gizmoLight = this.gizmoLayer._getSharedGizmoLight();
        gizmoLight.includedOnlyMeshes = gizmoLight.includedOnlyMeshes.concat(this._cameraMesh.getChildMeshes(false));
        this._update();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CameraGizmo2.prototype, "material", {
    get: function() {
      return this._material;
    },
    enumerable: false,
    configurable: true
  });
  CameraGizmo2.prototype._update = function() {
    _super.prototype._update.call(this);
    if (!this._camera) {
      return;
    }
    this._camera.getProjectionMatrix().invertToRef(this._invProjection);
    this._cameraLinesMesh.setPivotMatrix(this._invProjection, false);
    this._cameraLinesMesh.scaling.x = 1 / this._rootMesh.scaling.x;
    this._cameraLinesMesh.scaling.y = 1 / this._rootMesh.scaling.y;
    this._cameraLinesMesh.scaling.z = 1 / this._rootMesh.scaling.z;
    this._cameraMesh.parent = null;
    this._cameraMesh.rotation.y = Math.PI * 0.5 * (this._camera.getScene().useRightHandedSystem ? 1 : -1);
    this._cameraMesh.parent = this._rootMesh;
  };
  CameraGizmo2.prototype.dispose = function() {
    this.onClickedObservable.clear();
    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
    if (this._cameraMesh) {
      this._cameraMesh.dispose();
    }
    if (this._cameraLinesMesh) {
      this._cameraLinesMesh.dispose();
    }
    this._material.dispose();
    _super.prototype.dispose.call(this);
  };
  CameraGizmo2._CreateCameraMesh = function(scene) {
    var root = new Mesh("rootCameraGizmo", scene);
    var mesh = new Mesh(root.name, scene);
    mesh.parent = root;
    var box = BoxBuilder.CreateBox(root.name, { width: 1, height: 0.8, depth: 0.5 }, scene);
    box.parent = mesh;
    var cyl1 = CylinderBuilder.CreateCylinder(root.name, { height: 0.5, diameterTop: 0.8, diameterBottom: 0.8 }, scene);
    cyl1.parent = mesh;
    cyl1.position.y = 0.3;
    cyl1.position.x = -0.6;
    cyl1.rotation.x = Math.PI * 0.5;
    var cyl2 = CylinderBuilder.CreateCylinder(root.name, { height: 0.5, diameterTop: 0.6, diameterBottom: 0.6 }, scene);
    cyl2.parent = mesh;
    cyl2.position.y = 0.5;
    cyl2.position.x = 0.4;
    cyl2.rotation.x = Math.PI * 0.5;
    var cyl3 = CylinderBuilder.CreateCylinder(root.name, { height: 0.5, diameterTop: 0.5, diameterBottom: 0.5 }, scene);
    cyl3.parent = mesh;
    cyl3.position.y = 0;
    cyl3.position.x = 0.6;
    cyl3.rotation.z = Math.PI * 0.5;
    root.scaling.scaleInPlace(CameraGizmo2._Scale);
    mesh.position.x = -0.9;
    return root;
  };
  CameraGizmo2._CreateCameraFrustum = function(scene) {
    var root = new Mesh("rootCameraGizmo", scene);
    var mesh = new Mesh(root.name, scene);
    mesh.parent = root;
    for (var y = 0; y < 4; y += 2) {
      for (var x = 0; x < 4; x += 2) {
        var line = LinesBuilder.CreateLines("lines", { points: [new Vector3(-1 + x, -1 + y, -1), new Vector3(-1 + x, -1 + y, 1)] }, scene);
        line.parent = mesh;
        line.alwaysSelectAsActiveMesh = true;
        line.isPickable = false;
        var line = LinesBuilder.CreateLines("lines", { points: [new Vector3(-1, -1 + x, -1 + y), new Vector3(1, -1 + x, -1 + y)] }, scene);
        line.parent = mesh;
        line.alwaysSelectAsActiveMesh = true;
        line.isPickable = false;
        var line = LinesBuilder.CreateLines("lines", { points: [new Vector3(-1 + x, -1, -1 + y), new Vector3(-1 + x, 1, -1 + y)] }, scene);
        line.parent = mesh;
        line.alwaysSelectAsActiveMesh = true;
        line.isPickable = false;
      }
    }
    return root;
  };
  CameraGizmo2._Scale = 0.05;
  return CameraGizmo2;
}(Gizmo);

// node_modules/@babylonjs/core/Shaders/ShadersInclude/kernelBlurVaryingDeclaration.js
var name9 = "kernelBlurVaryingDeclaration";
var shader9 = "varying vec2 sampleCoord{X};";
Effect.IncludesShadersStore[name9] = shader9;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/packingFunctions.js
var name10 = "packingFunctions";
var shader10 = "vec4 pack(float depth)\n{\nconst vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);\nconst vec4 bit_mask=vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);\nvec4 res=fract(depth*bit_shift);\nres-=res.xxyz*bit_mask;\nreturn res;\n}\nfloat unpack(vec4 color)\n{\nconst vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);\nreturn dot(color,bit_shift);\n}";
Effect.IncludesShadersStore[name10] = shader10;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/kernelBlurFragment.js
var name11 = "kernelBlurFragment";
var shader11 = "#ifdef DOF\nfactor=sampleCoC(sampleCoord{X});\ncomputedWeight=KERNEL_WEIGHT{X}*factor;\nsumOfWeights+=computedWeight;\n#else\ncomputedWeight=KERNEL_WEIGHT{X};\n#endif\n#ifdef PACKEDFLOAT\nblend+=unpack(texture2D(textureSampler,sampleCoord{X}))*computedWeight;\n#else\nblend+=texture2D(textureSampler,sampleCoord{X})*computedWeight;\n#endif";
Effect.IncludesShadersStore[name11] = shader11;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/kernelBlurFragment2.js
var name12 = "kernelBlurFragment2";
var shader12 = "#ifdef DOF\nfactor=sampleCoC(sampleCenter+delta*KERNEL_DEP_OFFSET{X});\ncomputedWeight=KERNEL_DEP_WEIGHT{X}*factor;\nsumOfWeights+=computedWeight;\n#else\ncomputedWeight=KERNEL_DEP_WEIGHT{X};\n#endif\n#ifdef PACKEDFLOAT\nblend+=unpack(texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X}))*computedWeight;\n#else\nblend+=texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X})*computedWeight;\n#endif";
Effect.IncludesShadersStore[name12] = shader12;

// node_modules/@babylonjs/core/Shaders/kernelBlur.fragment.js
var name13 = "kernelBlurPixelShader";
var shader13 = "\nuniform sampler2D textureSampler;\nuniform vec2 delta;\n\nvarying vec2 sampleCenter;\n#ifdef DOF\nuniform sampler2D circleOfConfusionSampler;\nuniform vec2 cameraMinMaxZ;\nfloat sampleDistance(const in vec2 offset) {\nfloat depth=texture2D(circleOfConfusionSampler,offset).g;\nreturn cameraMinMaxZ.x+(cameraMinMaxZ.y-cameraMinMaxZ.x)*depth;\n}\nfloat sampleCoC(const in vec2 offset) {\nfloat coc=texture2D(circleOfConfusionSampler,offset).r;\nreturn coc;\n}\n#endif\n#include<kernelBlurVaryingDeclaration>[0..varyingCount]\n#ifdef PACKEDFLOAT\n#include<packingFunctions>\n#endif\nvoid main(void)\n{\nfloat computedWeight=0.0;\n#ifdef PACKEDFLOAT\nfloat blend=0.;\n#else\nvec4 blend=vec4(0.);\n#endif\n#ifdef DOF\nfloat sumOfWeights=CENTER_WEIGHT;\nfloat factor=0.0;\n\n#ifdef PACKEDFLOAT\nblend+=unpack(texture2D(textureSampler,sampleCenter))*CENTER_WEIGHT;\n#else\nblend+=texture2D(textureSampler,sampleCenter)*CENTER_WEIGHT;\n#endif\n#endif\n#include<kernelBlurFragment>[0..varyingCount]\n#include<kernelBlurFragment2>[0..depCount]\n#ifdef PACKEDFLOAT\ngl_FragColor=pack(blend);\n#else\ngl_FragColor=blend;\n#endif\n#ifdef DOF\ngl_FragColor/=sumOfWeights;\n#endif\n}";
Effect.ShadersStore[name13] = shader13;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/kernelBlurVertex.js
var name14 = "kernelBlurVertex";
var shader14 = "sampleCoord{X}=sampleCenter+delta*KERNEL_OFFSET{X};";
Effect.IncludesShadersStore[name14] = shader14;

// node_modules/@babylonjs/core/Shaders/kernelBlur.vertex.js
var name15 = "kernelBlurVertexShader";
var shader15 = "\nattribute vec2 position;\n\nuniform vec2 delta;\n\nvarying vec2 sampleCenter;\n#include<kernelBlurVaryingDeclaration>[0..varyingCount]\nconst vec2 madd=vec2(0.5,0.5);\nvoid main(void) {\nsampleCenter=(position*madd+madd);\n#include<kernelBlurVertex>[0..varyingCount]\ngl_Position=vec4(position,0.0,1.0);\n}";
Effect.ShadersStore[name15] = shader15;

// node_modules/@babylonjs/core/PostProcesses/blurPostProcess.js
var BlurPostProcess = function(_super) {
  __extends(BlurPostProcess2, _super);
  function BlurPostProcess2(name98, direction, kernel, options, camera, samplingMode, engine, reusable, textureType, defines, blockCompilation) {
    if (samplingMode === void 0) {
      samplingMode = Texture.BILINEAR_SAMPLINGMODE;
    }
    if (textureType === void 0) {
      textureType = 0;
    }
    if (defines === void 0) {
      defines = "";
    }
    if (blockCompilation === void 0) {
      blockCompilation = false;
    }
    var _this = _super.call(this, name98, "kernelBlur", ["delta", "direction", "cameraMinMaxZ"], ["circleOfConfusionSampler"], options, camera, samplingMode, engine, reusable, null, textureType, "kernelBlur", { varyingCount: 0, depCount: 0 }, true) || this;
    _this.blockCompilation = blockCompilation;
    _this._packedFloat = false;
    _this._staticDefines = "";
    _this._staticDefines = defines;
    _this.direction = direction;
    _this.onApplyObservable.add(function(effect) {
      if (_this._outputTexture) {
        effect.setFloat2("delta", 1 / _this._outputTexture.width * _this.direction.x, 1 / _this._outputTexture.height * _this.direction.y);
      } else {
        effect.setFloat2("delta", 1 / _this.width * _this.direction.x, 1 / _this.height * _this.direction.y);
      }
    });
    _this.kernel = kernel;
    return _this;
  }
  Object.defineProperty(BlurPostProcess2.prototype, "kernel", {
    get: function() {
      return this._idealKernel;
    },
    set: function(v) {
      if (this._idealKernel === v) {
        return;
      }
      v = Math.max(v, 1);
      this._idealKernel = v;
      this._kernel = this._nearestBestKernel(v);
      if (!this.blockCompilation) {
        this._updateParameters();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BlurPostProcess2.prototype, "packedFloat", {
    get: function() {
      return this._packedFloat;
    },
    set: function(v) {
      if (this._packedFloat === v) {
        return;
      }
      this._packedFloat = v;
      if (!this.blockCompilation) {
        this._updateParameters();
      }
    },
    enumerable: false,
    configurable: true
  });
  BlurPostProcess2.prototype.getClassName = function() {
    return "BlurPostProcess";
  };
  BlurPostProcess2.prototype.updateEffect = function(defines, uniforms, samplers, indexParameters, onCompiled, onError) {
    if (defines === void 0) {
      defines = null;
    }
    if (uniforms === void 0) {
      uniforms = null;
    }
    if (samplers === void 0) {
      samplers = null;
    }
    this._updateParameters(onCompiled, onError);
  };
  BlurPostProcess2.prototype._updateParameters = function(onCompiled, onError) {
    var N = this._kernel;
    var centerIndex = (N - 1) / 2;
    var offsets = [];
    var weights = [];
    var totalWeight = 0;
    for (var i = 0; i < N; i++) {
      var u = i / (N - 1);
      var w = this._gaussianWeight(u * 2 - 1);
      offsets[i] = i - centerIndex;
      weights[i] = w;
      totalWeight += w;
    }
    for (var i = 0; i < weights.length; i++) {
      weights[i] /= totalWeight;
    }
    var linearSamplingWeights = [];
    var linearSamplingOffsets = [];
    var linearSamplingMap = [];
    for (var i = 0; i <= centerIndex; i += 2) {
      var j = Math.min(i + 1, Math.floor(centerIndex));
      var singleCenterSample = i === j;
      if (singleCenterSample) {
        linearSamplingMap.push({ o: offsets[i], w: weights[i] });
      } else {
        var sharedCell = j === centerIndex;
        var weightLinear = weights[i] + weights[j] * (sharedCell ? 0.5 : 1);
        var offsetLinear = offsets[i] + 1 / (1 + weights[i] / weights[j]);
        if (offsetLinear === 0) {
          linearSamplingMap.push({ o: offsets[i], w: weights[i] });
          linearSamplingMap.push({ o: offsets[i + 1], w: weights[i + 1] });
        } else {
          linearSamplingMap.push({ o: offsetLinear, w: weightLinear });
          linearSamplingMap.push({ o: -offsetLinear, w: weightLinear });
        }
      }
    }
    for (var i = 0; i < linearSamplingMap.length; i++) {
      linearSamplingOffsets[i] = linearSamplingMap[i].o;
      linearSamplingWeights[i] = linearSamplingMap[i].w;
    }
    offsets = linearSamplingOffsets;
    weights = linearSamplingWeights;
    var maxVaryingRows = this.getEngine().getCaps().maxVaryingVectors;
    var freeVaryingVec2 = Math.max(maxVaryingRows, 0) - 1;
    var varyingCount = Math.min(offsets.length, freeVaryingVec2);
    var defines = "";
    defines += this._staticDefines;
    if (this._staticDefines.indexOf("DOF") != -1) {
      defines += "#define CENTER_WEIGHT " + this._glslFloat(weights[varyingCount - 1]) + "\r\n";
      varyingCount--;
    }
    for (var i = 0; i < varyingCount; i++) {
      defines += "#define KERNEL_OFFSET" + i + " " + this._glslFloat(offsets[i]) + "\r\n";
      defines += "#define KERNEL_WEIGHT" + i + " " + this._glslFloat(weights[i]) + "\r\n";
    }
    var depCount = 0;
    for (var i = freeVaryingVec2; i < offsets.length; i++) {
      defines += "#define KERNEL_DEP_OFFSET" + depCount + " " + this._glslFloat(offsets[i]) + "\r\n";
      defines += "#define KERNEL_DEP_WEIGHT" + depCount + " " + this._glslFloat(weights[i]) + "\r\n";
      depCount++;
    }
    if (this.packedFloat) {
      defines += "#define PACKEDFLOAT 1";
    }
    this.blockCompilation = false;
    _super.prototype.updateEffect.call(this, defines, null, null, {
      varyingCount,
      depCount
    }, onCompiled, onError);
  };
  BlurPostProcess2.prototype._nearestBestKernel = function(idealKernel) {
    var v = Math.round(idealKernel);
    for (var _i = 0, _a = [v, v - 1, v + 1, v - 2, v + 2]; _i < _a.length; _i++) {
      var k = _a[_i];
      if (k % 2 !== 0 && Math.floor(k / 2) % 2 === 0 && k > 0) {
        return Math.max(k, 3);
      }
    }
    return Math.max(v, 3);
  };
  BlurPostProcess2.prototype._gaussianWeight = function(x) {
    var sigma = 1 / 3;
    var denominator = Math.sqrt(2 * Math.PI) * sigma;
    var exponent = -(x * x / (2 * sigma * sigma));
    var weight = 1 / denominator * Math.exp(exponent);
    return weight;
  };
  BlurPostProcess2.prototype._glslFloat = function(x, decimalFigures) {
    if (decimalFigures === void 0) {
      decimalFigures = 8;
    }
    return x.toFixed(decimalFigures).replace(/0+$/, "");
  };
  BlurPostProcess2._Parse = function(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(function() {
      return new BlurPostProcess2(parsedPostProcess.name, parsedPostProcess.direction, parsedPostProcess.kernel, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable, parsedPostProcess.textureType, void 0, false);
    }, parsedPostProcess, scene, rootUrl);
  };
  __decorate([
    serialize("kernel")
  ], BlurPostProcess2.prototype, "_kernel", void 0);
  __decorate([
    serialize("packedFloat")
  ], BlurPostProcess2.prototype, "_packedFloat", void 0);
  __decorate([
    serializeAsVector2()
  ], BlurPostProcess2.prototype, "direction", void 0);
  return BlurPostProcess2;
}(PostProcess);
_TypeStore.RegisteredTypes["BABYLON.BlurPostProcess"] = BlurPostProcess;

// node_modules/@babylonjs/core/Materials/Textures/mirrorTexture.js
var MirrorTexture = function(_super) {
  __extends(MirrorTexture2, _super);
  function MirrorTexture2(name98, size, scene, generateMipMaps, type, samplingMode, generateDepthBuffer) {
    if (type === void 0) {
      type = 0;
    }
    if (samplingMode === void 0) {
      samplingMode = Texture.BILINEAR_SAMPLINGMODE;
    }
    if (generateDepthBuffer === void 0) {
      generateDepthBuffer = true;
    }
    var _this = _super.call(this, name98, size, scene, generateMipMaps, true, type, false, samplingMode, generateDepthBuffer) || this;
    _this.scene = scene;
    _this.mirrorPlane = new Plane(0, 1, 0, 1);
    _this._transformMatrix = Matrix.Zero();
    _this._mirrorMatrix = Matrix.Zero();
    _this._adaptiveBlurKernel = 0;
    _this._blurKernelX = 0;
    _this._blurKernelY = 0;
    _this._blurRatio = 1;
    _this.ignoreCameraViewport = true;
    _this._updateGammaSpace();
    _this._imageProcessingConfigChangeObserver = scene.imageProcessingConfiguration.onUpdateParameters.add(function() {
      _this._updateGammaSpace;
    });
    _this.onBeforeRenderObservable.add(function() {
      Matrix.ReflectionToRef(_this.mirrorPlane, _this._mirrorMatrix);
      _this._savedViewMatrix = scene.getViewMatrix();
      _this._mirrorMatrix.multiplyToRef(_this._savedViewMatrix, _this._transformMatrix);
      scene.setTransformMatrix(_this._transformMatrix, scene.getProjectionMatrix());
      scene.clipPlane = _this.mirrorPlane;
      scene.getEngine().cullBackFaces = false;
      scene._mirroredCameraPosition = Vector3.TransformCoordinates(scene.activeCamera.globalPosition, _this._mirrorMatrix);
    });
    _this.onAfterRenderObservable.add(function() {
      scene.setTransformMatrix(_this._savedViewMatrix, scene.getProjectionMatrix());
      scene.getEngine().cullBackFaces = true;
      scene._mirroredCameraPosition = null;
      scene.clipPlane = null;
    });
    return _this;
  }
  Object.defineProperty(MirrorTexture2.prototype, "blurRatio", {
    get: function() {
      return this._blurRatio;
    },
    set: function(value) {
      if (this._blurRatio === value) {
        return;
      }
      this._blurRatio = value;
      this._preparePostProcesses();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MirrorTexture2.prototype, "adaptiveBlurKernel", {
    set: function(value) {
      this._adaptiveBlurKernel = value;
      this._autoComputeBlurKernel();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MirrorTexture2.prototype, "blurKernel", {
    set: function(value) {
      this.blurKernelX = value;
      this.blurKernelY = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MirrorTexture2.prototype, "blurKernelX", {
    get: function() {
      return this._blurKernelX;
    },
    set: function(value) {
      if (this._blurKernelX === value) {
        return;
      }
      this._blurKernelX = value;
      this._preparePostProcesses();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MirrorTexture2.prototype, "blurKernelY", {
    get: function() {
      return this._blurKernelY;
    },
    set: function(value) {
      if (this._blurKernelY === value) {
        return;
      }
      this._blurKernelY = value;
      this._preparePostProcesses();
    },
    enumerable: false,
    configurable: true
  });
  MirrorTexture2.prototype._autoComputeBlurKernel = function() {
    var engine = this.getScene().getEngine();
    var dw = this.getRenderWidth() / engine.getRenderWidth();
    var dh = this.getRenderHeight() / engine.getRenderHeight();
    this.blurKernelX = this._adaptiveBlurKernel * dw;
    this.blurKernelY = this._adaptiveBlurKernel * dh;
  };
  MirrorTexture2.prototype._onRatioRescale = function() {
    if (this._sizeRatio) {
      this.resize(this._initialSizeParameter);
      if (!this._adaptiveBlurKernel) {
        this._preparePostProcesses();
      }
    }
    if (this._adaptiveBlurKernel) {
      this._autoComputeBlurKernel();
    }
  };
  MirrorTexture2.prototype._updateGammaSpace = function() {
    this.gammaSpace = !this.scene.imageProcessingConfiguration.isEnabled || !this.scene.imageProcessingConfiguration.applyByPostProcess;
  };
  MirrorTexture2.prototype._preparePostProcesses = function() {
    this.clearPostProcesses(true);
    if (this._blurKernelX && this._blurKernelY) {
      var engine = this.getScene().getEngine();
      var textureType = engine.getCaps().textureFloatRender ? 1 : 2;
      this._blurX = new BlurPostProcess("horizontal blur", new Vector2(1, 0), this._blurKernelX, this._blurRatio, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, textureType);
      this._blurX.autoClear = false;
      if (this._blurRatio === 1 && this.samples < 2 && this._texture) {
        this._blurX.inputTexture = this._texture;
      } else {
        this._blurX.alwaysForcePOT = true;
      }
      this._blurY = new BlurPostProcess("vertical blur", new Vector2(0, 1), this._blurKernelY, this._blurRatio, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, textureType);
      this._blurY.autoClear = false;
      this._blurY.alwaysForcePOT = this._blurRatio !== 1;
      this.addPostProcess(this._blurX);
      this.addPostProcess(this._blurY);
    } else {
      if (this._blurY) {
        this.removePostProcess(this._blurY);
        this._blurY.dispose();
        this._blurY = null;
      }
      if (this._blurX) {
        this.removePostProcess(this._blurX);
        this._blurX.dispose();
        this._blurX = null;
      }
    }
  };
  MirrorTexture2.prototype.clone = function() {
    var scene = this.getScene();
    if (!scene) {
      return this;
    }
    var textureSize = this.getSize();
    var newTexture = new MirrorTexture2(this.name, textureSize.width, scene, this._renderTargetOptions.generateMipMaps, this._renderTargetOptions.type, this._renderTargetOptions.samplingMode, this._renderTargetOptions.generateDepthBuffer);
    newTexture.hasAlpha = this.hasAlpha;
    newTexture.level = this.level;
    newTexture.mirrorPlane = this.mirrorPlane.clone();
    if (this.renderList) {
      newTexture.renderList = this.renderList.slice(0);
    }
    return newTexture;
  };
  MirrorTexture2.prototype.serialize = function() {
    if (!this.name) {
      return null;
    }
    var serializationObject = _super.prototype.serialize.call(this);
    serializationObject.mirrorPlane = this.mirrorPlane.asArray();
    return serializationObject;
  };
  MirrorTexture2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this.scene.imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingConfigChangeObserver);
  };
  return MirrorTexture2;
}(RenderTargetTexture);
Texture._CreateMirror = function(name98, renderTargetSize, scene, generateMipMaps) {
  return new MirrorTexture(name98, renderTargetSize, scene, generateMipMaps);
};

// node_modules/@babylonjs/core/Shaders/ShadersInclude/backgroundFragmentDeclaration.js
var name16 = "backgroundFragmentDeclaration";
var shader16 = " uniform vec4 vPrimaryColor;\n#ifdef USEHIGHLIGHTANDSHADOWCOLORS\nuniform vec4 vPrimaryColorShadow;\n#endif\nuniform float shadowLevel;\nuniform float alpha;\n#ifdef DIFFUSE\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;\nuniform mat4 reflectionMatrix;\nuniform vec3 vReflectionMicrosurfaceInfos;\n#endif\n#if defined(REFLECTIONFRESNEL) || defined(OPACITYFRESNEL)\nuniform vec3 vBackgroundCenter;\n#endif\n#ifdef REFLECTIONFRESNEL\nuniform vec4 vReflectionControl;\n#endif\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION)\nuniform mat4 view;\n#endif";
Effect.IncludesShadersStore[name16] = shader16;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/backgroundUboDeclaration.js
var name17 = "backgroundUboDeclaration";
var shader17 = "layout(std140,column_major) uniform;\nuniform Material\n{\nuniform vec4 vPrimaryColor;\nuniform vec4 vPrimaryColorShadow;\nuniform vec2 vDiffuseInfos;\nuniform vec2 vReflectionInfos;\nuniform mat4 diffuseMatrix;\nuniform mat4 reflectionMatrix;\nuniform vec3 vReflectionMicrosurfaceInfos;\nuniform float fFovMultiplier;\nuniform float pointSize;\nuniform float shadowLevel;\nuniform float alpha;\n#if defined(REFLECTIONFRESNEL) || defined(OPACITYFRESNEL)\nuniform vec3 vBackgroundCenter;\n#endif\n#ifdef REFLECTIONFRESNEL\nuniform vec4 vReflectionControl;\n#endif\n};\nuniform Scene {\nmat4 viewProjection;\n#ifdef MULTIVIEW\nmat4 viewProjectionR;\n#endif\nmat4 view;\n};";
Effect.IncludesShadersStore[name17] = shader17;

// node_modules/@babylonjs/core/Shaders/background.fragment.js
var name18 = "backgroundPixelShader";
var shader18 = "#ifdef TEXTURELODSUPPORT\n#extension GL_EXT_shader_texture_lod : enable\n#endif\nprecision highp float;\n#include<__decl__backgroundFragment>\n#define RECIPROCAL_PI2 0.15915494\n\nuniform vec3 vEyePosition;\n\nvarying vec3 vPositionW;\n#ifdef MAINUV1\nvarying vec2 vMainUV1;\n#endif\n#ifdef MAINUV2\nvarying vec2 vMainUV2;\n#endif\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef DIFFUSE\n#if DIFFUSEDIRECTUV == 1\n#define vDiffuseUV vMainUV1\n#elif DIFFUSEDIRECTUV == 2\n#define vDiffuseUV vMainUV2\n#else\nvarying vec2 vDiffuseUV;\n#endif\nuniform sampler2D diffuseSampler;\n#endif\n\n#ifdef REFLECTION\n#ifdef REFLECTIONMAP_3D\n#define sampleReflection(s,c) textureCube(s,c)\nuniform samplerCube reflectionSampler;\n#ifdef TEXTURELODSUPPORT\n#define sampleReflectionLod(s,c,l) textureCubeLodEXT(s,c,l)\n#else\nuniform samplerCube reflectionSamplerLow;\nuniform samplerCube reflectionSamplerHigh;\n#endif\n#else\n#define sampleReflection(s,c) texture2D(s,c)\nuniform sampler2D reflectionSampler;\n#ifdef TEXTURELODSUPPORT\n#define sampleReflectionLod(s,c,l) texture2DLodEXT(s,c,l)\n#else\nuniform samplerCube reflectionSamplerLow;\nuniform samplerCube reflectionSamplerHigh;\n#endif\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#else\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#endif\n#include<reflectionFunction>\n#endif\n\n#ifndef FROMLINEARSPACE\n#define FROMLINEARSPACE;\n#endif\n\n#ifndef SHADOWONLY\n#define SHADOWONLY;\n#endif\n#include<imageProcessingDeclaration>\n\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<helperFunctions>\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<imageProcessingFunctions>\n#include<clipPlaneFragmentDeclaration>\n\n#include<fogFragmentDeclaration>\n#ifdef REFLECTIONFRESNEL\n#define FRESNEL_MAXIMUM_ON_ROUGH 0.25\nvec3 fresnelSchlickEnvironmentGGX(float VdotN,vec3 reflectance0,vec3 reflectance90,float smoothness)\n{\n\nfloat weight=mix(FRESNEL_MAXIMUM_ON_ROUGH,1.0,smoothness);\nreturn reflectance0+weight*(reflectance90-reflectance0)*pow5(saturate(1.0-VdotN));\n}\n#endif\nvoid main(void) {\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition-vPositionW);\n\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(0.0,1.0,0.0);\n#endif\n\nfloat shadow=1.;\nfloat globalShadow=0.;\nfloat shadowLightCount=0.;\n#include<lightFragment>[0..maxSimultaneousLights]\n#ifdef SHADOWINUSE\nglobalShadow/=shadowLightCount;\n#else\nglobalShadow=1.0;\n#endif\n#ifndef BACKMAT_SHADOWONLY\n\nvec4 reflectionColor=vec4(1.,1.,1.,1.);\n#ifdef REFLECTION\nvec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\n#ifdef REFLECTIONMAP_OPPOSITEZ\nreflectionVector.z*=-1.0;\n#endif\n\n#ifdef REFLECTIONMAP_3D\nvec3 reflectionCoords=reflectionVector;\n#else\nvec2 reflectionCoords=reflectionVector.xy;\n#ifdef REFLECTIONMAP_PROJECTION\nreflectionCoords/=reflectionVector.z;\n#endif\nreflectionCoords.y=1.0-reflectionCoords.y;\n#endif\n#ifdef REFLECTIONBLUR\nfloat reflectionLOD=vReflectionInfos.y;\n#ifdef TEXTURELODSUPPORT\n\nreflectionLOD=reflectionLOD*log2(vReflectionMicrosurfaceInfos.x)*vReflectionMicrosurfaceInfos.y+vReflectionMicrosurfaceInfos.z;\nreflectionColor=sampleReflectionLod(reflectionSampler,reflectionCoords,reflectionLOD);\n#else\nfloat lodReflectionNormalized=saturate(reflectionLOD);\nfloat lodReflectionNormalizedDoubled=lodReflectionNormalized*2.0;\nvec4 reflectionSpecularMid=sampleReflection(reflectionSampler,reflectionCoords);\nif(lodReflectionNormalizedDoubled<1.0){\nreflectionColor=mix(\nsampleReflection(reflectionSamplerHigh,reflectionCoords),\nreflectionSpecularMid,\nlodReflectionNormalizedDoubled\n);\n} else {\nreflectionColor=mix(\nreflectionSpecularMid,\nsampleReflection(reflectionSamplerLow,reflectionCoords),\nlodReflectionNormalizedDoubled-1.0\n);\n}\n#endif\n#else\nvec4 reflectionSample=sampleReflection(reflectionSampler,reflectionCoords);\nreflectionColor=reflectionSample;\n#endif\n#ifdef RGBDREFLECTION\nreflectionColor.rgb=fromRGBD(reflectionColor);\n#endif\n#ifdef GAMMAREFLECTION\nreflectionColor.rgb=toLinearSpace(reflectionColor.rgb);\n#endif\n#ifdef REFLECTIONBGR\nreflectionColor.rgb=reflectionColor.bgr;\n#endif\n\nreflectionColor.rgb*=vReflectionInfos.x;\n#endif\n\nvec3 diffuseColor=vec3(1.,1.,1.);\nfloat finalAlpha=alpha;\n#ifdef DIFFUSE\nvec4 diffuseMap=texture2D(diffuseSampler,vDiffuseUV);\n#ifdef GAMMADIFFUSE\ndiffuseMap.rgb=toLinearSpace(diffuseMap.rgb);\n#endif\n\ndiffuseMap.rgb*=vDiffuseInfos.y;\n#ifdef DIFFUSEHASALPHA\nfinalAlpha*=diffuseMap.a;\n#endif\ndiffuseColor=diffuseMap.rgb;\n#endif\n\n#ifdef REFLECTIONFRESNEL\nvec3 colorBase=diffuseColor;\n#else\nvec3 colorBase=reflectionColor.rgb*diffuseColor;\n#endif\ncolorBase=max(colorBase,0.0);\n\n#ifdef USERGBCOLOR\nvec3 finalColor=colorBase;\n#else\n#ifdef USEHIGHLIGHTANDSHADOWCOLORS\nvec3 mainColor=mix(vPrimaryColorShadow.rgb,vPrimaryColor.rgb,colorBase);\n#else\nvec3 mainColor=vPrimaryColor.rgb;\n#endif\nvec3 finalColor=colorBase*mainColor;\n#endif\n\n#ifdef REFLECTIONFRESNEL\nvec3 reflectionAmount=vReflectionControl.xxx;\nvec3 reflectionReflectance0=vReflectionControl.yyy;\nvec3 reflectionReflectance90=vReflectionControl.zzz;\nfloat VdotN=dot(normalize(vEyePosition),normalW);\nvec3 planarReflectionFresnel=fresnelSchlickEnvironmentGGX(saturate(VdotN),reflectionReflectance0,reflectionReflectance90,1.0);\nreflectionAmount*=planarReflectionFresnel;\n#ifdef REFLECTIONFALLOFF\nfloat reflectionDistanceFalloff=1.0-saturate(length(vPositionW.xyz-vBackgroundCenter)*vReflectionControl.w);\nreflectionDistanceFalloff*=reflectionDistanceFalloff;\nreflectionAmount*=reflectionDistanceFalloff;\n#endif\nfinalColor=mix(finalColor,reflectionColor.rgb,saturate(reflectionAmount));\n#endif\n#ifdef OPACITYFRESNEL\nfloat viewAngleToFloor=dot(normalW,normalize(vEyePosition-vBackgroundCenter));\n\nconst float startAngle=0.1;\nfloat fadeFactor=saturate(viewAngleToFloor/startAngle);\nfinalAlpha*=fadeFactor*fadeFactor;\n#endif\n\n#ifdef SHADOWINUSE\nfinalColor=mix(finalColor*shadowLevel,finalColor,globalShadow);\n#endif\n\nvec4 color=vec4(finalColor,finalAlpha);\n#else\nvec4 color=vec4(vPrimaryColor.rgb,(1.0-clamp(globalShadow,0.,1.))*alpha);\n#endif\n#include<fogFragment>\n#ifdef IMAGEPROCESSINGPOSTPROCESS\n\n\ncolor.rgb=clamp(color.rgb,0.,30.0);\n#else\n\ncolor=applyImageProcessing(color);\n#endif\n#ifdef PREMULTIPLYALPHA\n\ncolor.rgb*=color.a;\n#endif\n#ifdef NOISE\ncolor.rgb+=dither(vPositionW.xy,0.5);\ncolor=max(color,0.0);\n#endif\ngl_FragColor=color;\n}\n";
Effect.ShadersStore[name18] = shader18;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/backgroundVertexDeclaration.js
var name19 = "backgroundVertexDeclaration";
var shader19 = "uniform mat4 view;\nuniform mat4 viewProjection;\nuniform float shadowLevel;\n#ifdef DIFFUSE\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;\nuniform mat4 reflectionMatrix;\nuniform vec3 vReflectionMicrosurfaceInfos;\nuniform float fFovMultiplier;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif";
Effect.IncludesShadersStore[name19] = shader19;

// node_modules/@babylonjs/core/Shaders/background.vertex.js
var name20 = "backgroundVertexShader";
var shader20 = "precision highp float;\n#include<__decl__backgroundVertex>\n#include<helperFunctions>\n\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#include<bonesDeclaration>\n\n#include<instancesDeclaration>\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef MAINUV1\nvarying vec2 vMainUV1;\n#endif\n#ifdef MAINUV2\nvarying vec2 vMainUV2;\n#endif\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV == 0\nvarying vec2 vDiffuseUV;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\nvoid main(void) {\n#ifdef REFLECTIONMAP_SKYBOX\nvPositionUVW=position;\n#endif\n#include<instancesVertex>\n#include<bonesVertex>\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR == 0u) {\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\n} else {\ngl_Position=viewProjectionR*finalWorld*vec4(position,1.0);\n}\n#else\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\n#endif\nvec4 worldPos=finalWorld*vec4(position,1.0);\nvPositionW=vec3(worldPos);\n#ifdef NORMAL\nmat3 normalWorld=mat3(finalWorld);\n#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\n#endif\nvNormalW=normalize(normalWorld*normal);\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvDirectionW=normalize(vec3(finalWorld*vec4(position,0.0)));\n#ifdef EQUIRECTANGULAR_RELFECTION_FOV\nmat3 screenToWorld=inverseMat3(mat3(finalWorld*viewProjection));\nvec3 segment=mix(vDirectionW,screenToWorld*vec3(0.0,0.0,1.0),abs(fFovMultiplier-1.0));\nif (fFovMultiplier<=1.0) {\nvDirectionW=normalize(segment);\n} else {\nvDirectionW=normalize(vDirectionW+(vDirectionW-segment));\n}\n#endif\n#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef MAINUV1\nvMainUV1=uv;\n#endif\n#ifdef MAINUV2\nvMainUV2=uv2;\n#endif\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV == 0\nif (vDiffuseInfos.x == 0.)\n{\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\n}\nelse\n{\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n\n#include<clipPlaneVertex>\n\n#include<fogVertex>\n\n#include<shadowsVertex>[0..maxSimultaneousLights]\n\n#ifdef VERTEXCOLOR\nvColor=color;\n#endif\n\n#ifdef POINTSIZE\ngl_PointSize=pointSize;\n#endif\n}\n";
Effect.ShadersStore[name20] = shader20;

// node_modules/@babylonjs/core/Materials/Background/backgroundMaterial.js
var BackgroundMaterialDefines = function(_super) {
  __extends(BackgroundMaterialDefines2, _super);
  function BackgroundMaterialDefines2() {
    var _this = _super.call(this) || this;
    _this.DIFFUSE = false;
    _this.DIFFUSEDIRECTUV = 0;
    _this.GAMMADIFFUSE = false;
    _this.DIFFUSEHASALPHA = false;
    _this.OPACITYFRESNEL = false;
    _this.REFLECTIONBLUR = false;
    _this.REFLECTIONFRESNEL = false;
    _this.REFLECTIONFALLOFF = false;
    _this.TEXTURELODSUPPORT = false;
    _this.PREMULTIPLYALPHA = false;
    _this.USERGBCOLOR = false;
    _this.USEHIGHLIGHTANDSHADOWCOLORS = false;
    _this.BACKMAT_SHADOWONLY = false;
    _this.NOISE = false;
    _this.REFLECTIONBGR = false;
    _this.IMAGEPROCESSING = false;
    _this.VIGNETTE = false;
    _this.VIGNETTEBLENDMODEMULTIPLY = false;
    _this.VIGNETTEBLENDMODEOPAQUE = false;
    _this.TONEMAPPING = false;
    _this.TONEMAPPING_ACES = false;
    _this.CONTRAST = false;
    _this.COLORCURVES = false;
    _this.COLORGRADING = false;
    _this.COLORGRADING3D = false;
    _this.SAMPLER3DGREENDEPTH = false;
    _this.SAMPLER3DBGRMAP = false;
    _this.IMAGEPROCESSINGPOSTPROCESS = false;
    _this.EXPOSURE = false;
    _this.MULTIVIEW = false;
    _this.REFLECTION = false;
    _this.REFLECTIONMAP_3D = false;
    _this.REFLECTIONMAP_SPHERICAL = false;
    _this.REFLECTIONMAP_PLANAR = false;
    _this.REFLECTIONMAP_CUBIC = false;
    _this.REFLECTIONMAP_PROJECTION = false;
    _this.REFLECTIONMAP_SKYBOX = false;
    _this.REFLECTIONMAP_EXPLICIT = false;
    _this.REFLECTIONMAP_EQUIRECTANGULAR = false;
    _this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
    _this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
    _this.INVERTCUBICMAP = false;
    _this.REFLECTIONMAP_OPPOSITEZ = false;
    _this.LODINREFLECTIONALPHA = false;
    _this.GAMMAREFLECTION = false;
    _this.RGBDREFLECTION = false;
    _this.EQUIRECTANGULAR_RELFECTION_FOV = false;
    _this.MAINUV1 = false;
    _this.MAINUV2 = false;
    _this.UV1 = false;
    _this.UV2 = false;
    _this.CLIPPLANE = false;
    _this.CLIPPLANE2 = false;
    _this.CLIPPLANE3 = false;
    _this.CLIPPLANE4 = false;
    _this.CLIPPLANE5 = false;
    _this.CLIPPLANE6 = false;
    _this.POINTSIZE = false;
    _this.FOG = false;
    _this.NORMAL = false;
    _this.NUM_BONE_INFLUENCERS = 0;
    _this.BonesPerMesh = 0;
    _this.INSTANCES = false;
    _this.SHADOWFLOAT = false;
    _this.rebuild();
    return _this;
  }
  return BackgroundMaterialDefines2;
}(MaterialDefines);
var BackgroundMaterial = function(_super) {
  __extends(BackgroundMaterial2, _super);
  function BackgroundMaterial2(name98, scene) {
    var _this = _super.call(this, name98, scene) || this;
    _this.primaryColor = Color3.White();
    _this._primaryColorShadowLevel = 0;
    _this._primaryColorHighlightLevel = 0;
    _this.reflectionTexture = null;
    _this.reflectionBlur = 0;
    _this.diffuseTexture = null;
    _this._shadowLights = null;
    _this.shadowLights = null;
    _this.shadowLevel = 0;
    _this.sceneCenter = Vector3.Zero();
    _this.opacityFresnel = true;
    _this.reflectionFresnel = false;
    _this.reflectionFalloffDistance = 0;
    _this.reflectionAmount = 1;
    _this.reflectionReflectance0 = 0.05;
    _this.reflectionReflectance90 = 0.5;
    _this.useRGBColor = true;
    _this.enableNoise = false;
    _this._fovMultiplier = 1;
    _this.useEquirectangularFOV = false;
    _this._maxSimultaneousLights = 4;
    _this.maxSimultaneousLights = 4;
    _this._shadowOnly = false;
    _this.shadowOnly = false;
    _this._imageProcessingObserver = null;
    _this.switchToBGR = false;
    _this._renderTargets = new SmartArray(16);
    _this._reflectionControls = Vector4.Zero();
    _this._white = Color3.White();
    _this._primaryShadowColor = Color3.Black();
    _this._primaryHighlightColor = Color3.Black();
    _this._attachImageProcessingConfiguration(null);
    _this.getRenderTargetTextures = function() {
      _this._renderTargets.reset();
      if (_this._diffuseTexture && _this._diffuseTexture.isRenderTarget) {
        _this._renderTargets.push(_this._diffuseTexture);
      }
      if (_this._reflectionTexture && _this._reflectionTexture.isRenderTarget) {
        _this._renderTargets.push(_this._reflectionTexture);
      }
      return _this._renderTargets;
    };
    return _this;
  }
  Object.defineProperty(BackgroundMaterial2.prototype, "_perceptualColor", {
    get: function() {
      return this.__perceptualColor;
    },
    set: function(value) {
      this.__perceptualColor = value;
      this._computePrimaryColorFromPerceptualColor();
      this._markAllSubMeshesAsLightsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BackgroundMaterial2.prototype, "primaryColorShadowLevel", {
    get: function() {
      return this._primaryColorShadowLevel;
    },
    set: function(value) {
      this._primaryColorShadowLevel = value;
      this._computePrimaryColors();
      this._markAllSubMeshesAsLightsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BackgroundMaterial2.prototype, "primaryColorHighlightLevel", {
    get: function() {
      return this._primaryColorHighlightLevel;
    },
    set: function(value) {
      this._primaryColorHighlightLevel = value;
      this._computePrimaryColors();
      this._markAllSubMeshesAsLightsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BackgroundMaterial2.prototype, "reflectionStandardFresnelWeight", {
    set: function(value) {
      var reflectionWeight = value;
      if (reflectionWeight < 0.5) {
        reflectionWeight = reflectionWeight * 2;
        this.reflectionReflectance0 = BackgroundMaterial2.StandardReflectance0 * reflectionWeight;
        this.reflectionReflectance90 = BackgroundMaterial2.StandardReflectance90 * reflectionWeight;
      } else {
        reflectionWeight = reflectionWeight * 2 - 1;
        this.reflectionReflectance0 = BackgroundMaterial2.StandardReflectance0 + (1 - BackgroundMaterial2.StandardReflectance0) * reflectionWeight;
        this.reflectionReflectance90 = BackgroundMaterial2.StandardReflectance90 + (1 - BackgroundMaterial2.StandardReflectance90) * reflectionWeight;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BackgroundMaterial2.prototype, "fovMultiplier", {
    get: function() {
      return this._fovMultiplier;
    },
    set: function(value) {
      if (isNaN(value)) {
        value = 1;
      }
      this._fovMultiplier = Math.max(0, Math.min(2, value));
    },
    enumerable: false,
    configurable: true
  });
  BackgroundMaterial2.prototype._attachImageProcessingConfiguration = function(configuration) {
    var _this = this;
    if (configuration === this._imageProcessingConfiguration) {
      return;
    }
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    if (!configuration) {
      this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;
    } else {
      this._imageProcessingConfiguration = configuration;
    }
    if (this._imageProcessingConfiguration) {
      this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(function() {
        _this._computePrimaryColorFromPerceptualColor();
        _this._markAllSubMeshesAsImageProcessingDirty();
      });
    }
  };
  Object.defineProperty(BackgroundMaterial2.prototype, "imageProcessingConfiguration", {
    get: function() {
      return this._imageProcessingConfiguration;
    },
    set: function(value) {
      this._attachImageProcessingConfiguration(value);
      this._markAllSubMeshesAsTexturesDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BackgroundMaterial2.prototype, "cameraColorCurvesEnabled", {
    get: function() {
      return this.imageProcessingConfiguration.colorCurvesEnabled;
    },
    set: function(value) {
      this.imageProcessingConfiguration.colorCurvesEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BackgroundMaterial2.prototype, "cameraColorGradingEnabled", {
    get: function() {
      return this.imageProcessingConfiguration.colorGradingEnabled;
    },
    set: function(value) {
      this.imageProcessingConfiguration.colorGradingEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BackgroundMaterial2.prototype, "cameraToneMappingEnabled", {
    get: function() {
      return this._imageProcessingConfiguration.toneMappingEnabled;
    },
    set: function(value) {
      this._imageProcessingConfiguration.toneMappingEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BackgroundMaterial2.prototype, "cameraExposure", {
    get: function() {
      return this._imageProcessingConfiguration.exposure;
    },
    set: function(value) {
      this._imageProcessingConfiguration.exposure = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BackgroundMaterial2.prototype, "cameraContrast", {
    get: function() {
      return this._imageProcessingConfiguration.contrast;
    },
    set: function(value) {
      this._imageProcessingConfiguration.contrast = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BackgroundMaterial2.prototype, "cameraColorGradingTexture", {
    get: function() {
      return this._imageProcessingConfiguration.colorGradingTexture;
    },
    set: function(value) {
      this.imageProcessingConfiguration.colorGradingTexture = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BackgroundMaterial2.prototype, "cameraColorCurves", {
    get: function() {
      return this.imageProcessingConfiguration.colorCurves;
    },
    set: function(value) {
      this.imageProcessingConfiguration.colorCurves = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BackgroundMaterial2.prototype, "hasRenderTargetTextures", {
    get: function() {
      if (this._diffuseTexture && this._diffuseTexture.isRenderTarget) {
        return true;
      }
      if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
        return true;
      }
      return false;
    },
    enumerable: false,
    configurable: true
  });
  BackgroundMaterial2.prototype.needAlphaTesting = function() {
    return true;
  };
  BackgroundMaterial2.prototype.needAlphaBlending = function() {
    return this.alpha < 1 || this._diffuseTexture != null && this._diffuseTexture.hasAlpha || this._shadowOnly;
  };
  BackgroundMaterial2.prototype.isReadyForSubMesh = function(mesh, subMesh, useInstances) {
    var _this = this;
    if (useInstances === void 0) {
      useInstances = false;
    }
    if (subMesh.effect && this.isFrozen) {
      if (subMesh.effect._wasPreviouslyReady) {
        return true;
      }
    }
    if (!subMesh._materialDefines) {
      subMesh._materialDefines = new BackgroundMaterialDefines();
    }
    var scene = this.getScene();
    var defines = subMesh._materialDefines;
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    var engine = scene.getEngine();
    MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights);
    defines._needNormals = true;
    MaterialHelper.PrepareDefinesForMultiview(scene, defines);
    if (defines._areTexturesDirty) {
      defines._needUVs = false;
      if (scene.texturesEnabled) {
        if (scene.getEngine().getCaps().textureLOD) {
          defines.TEXTURELODSUPPORT = true;
        }
        if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {
          if (!this._diffuseTexture.isReadyOrNotBlocking()) {
            return false;
          }
          MaterialHelper.PrepareDefinesForMergedUV(this._diffuseTexture, defines, "DIFFUSE");
          defines.DIFFUSEHASALPHA = this._diffuseTexture.hasAlpha;
          defines.GAMMADIFFUSE = this._diffuseTexture.gammaSpace;
          defines.OPACITYFRESNEL = this._opacityFresnel;
        } else {
          defines.DIFFUSE = false;
          defines.DIFFUSEHASALPHA = false;
          defines.GAMMADIFFUSE = false;
          defines.OPACITYFRESNEL = false;
        }
        var reflectionTexture = this._reflectionTexture;
        if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
          if (!reflectionTexture.isReadyOrNotBlocking()) {
            return false;
          }
          defines.REFLECTION = true;
          defines.GAMMAREFLECTION = reflectionTexture.gammaSpace;
          defines.RGBDREFLECTION = reflectionTexture.isRGBD;
          defines.REFLECTIONBLUR = this._reflectionBlur > 0;
          defines.REFLECTIONMAP_OPPOSITEZ = this.getScene().useRightHandedSystem ? !reflectionTexture.invertZ : reflectionTexture.invertZ;
          defines.LODINREFLECTIONALPHA = reflectionTexture.lodLevelInAlpha;
          defines.EQUIRECTANGULAR_RELFECTION_FOV = this.useEquirectangularFOV;
          defines.REFLECTIONBGR = this.switchToBGR;
          if (reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE) {
            defines.INVERTCUBICMAP = true;
          }
          defines.REFLECTIONMAP_3D = reflectionTexture.isCube;
          switch (reflectionTexture.coordinatesMode) {
            case Texture.EXPLICIT_MODE:
              defines.REFLECTIONMAP_EXPLICIT = true;
              break;
            case Texture.PLANAR_MODE:
              defines.REFLECTIONMAP_PLANAR = true;
              break;
            case Texture.PROJECTION_MODE:
              defines.REFLECTIONMAP_PROJECTION = true;
              break;
            case Texture.SKYBOX_MODE:
              defines.REFLECTIONMAP_SKYBOX = true;
              break;
            case Texture.SPHERICAL_MODE:
              defines.REFLECTIONMAP_SPHERICAL = true;
              break;
            case Texture.EQUIRECTANGULAR_MODE:
              defines.REFLECTIONMAP_EQUIRECTANGULAR = true;
              break;
            case Texture.FIXED_EQUIRECTANGULAR_MODE:
              defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = true;
              break;
            case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:
              defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = true;
              break;
            case Texture.CUBIC_MODE:
            case Texture.INVCUBIC_MODE:
            default:
              defines.REFLECTIONMAP_CUBIC = true;
              break;
          }
          if (this.reflectionFresnel) {
            defines.REFLECTIONFRESNEL = true;
            defines.REFLECTIONFALLOFF = this.reflectionFalloffDistance > 0;
            this._reflectionControls.x = this.reflectionAmount;
            this._reflectionControls.y = this.reflectionReflectance0;
            this._reflectionControls.z = this.reflectionReflectance90;
            this._reflectionControls.w = 1 / this.reflectionFalloffDistance;
          } else {
            defines.REFLECTIONFRESNEL = false;
            defines.REFLECTIONFALLOFF = false;
          }
        } else {
          defines.REFLECTION = false;
          defines.REFLECTIONFRESNEL = false;
          defines.REFLECTIONFALLOFF = false;
          defines.REFLECTIONBLUR = false;
          defines.REFLECTIONMAP_3D = false;
          defines.REFLECTIONMAP_SPHERICAL = false;
          defines.REFLECTIONMAP_PLANAR = false;
          defines.REFLECTIONMAP_CUBIC = false;
          defines.REFLECTIONMAP_PROJECTION = false;
          defines.REFLECTIONMAP_SKYBOX = false;
          defines.REFLECTIONMAP_EXPLICIT = false;
          defines.REFLECTIONMAP_EQUIRECTANGULAR = false;
          defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
          defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
          defines.INVERTCUBICMAP = false;
          defines.REFLECTIONMAP_OPPOSITEZ = false;
          defines.LODINREFLECTIONALPHA = false;
          defines.GAMMAREFLECTION = false;
          defines.RGBDREFLECTION = false;
        }
      }
      defines.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8;
      defines.USERGBCOLOR = this._useRGBColor;
      defines.NOISE = this._enableNoise;
    }
    if (defines._areLightsDirty) {
      defines.USEHIGHLIGHTANDSHADOWCOLORS = !this._useRGBColor && (this._primaryColorShadowLevel !== 0 || this._primaryColorHighlightLevel !== 0);
      defines.BACKMAT_SHADOWONLY = this._shadowOnly;
    }
    if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
      if (!this._imageProcessingConfiguration.isReady()) {
        return false;
      }
      this._imageProcessingConfiguration.prepareDefines(defines);
    }
    MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);
    MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, defines, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);
    if (MaterialHelper.PrepareDefinesForAttributes(mesh, defines, false, true, false)) {
      if (mesh) {
        if (!scene.getEngine().getCaps().standardDerivatives && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
          mesh.createNormals(true);
          Logger.Warn("BackgroundMaterial: Normals have been created for the mesh: " + mesh.name);
        }
      }
    }
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      var fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(0, "FOG");
      }
      if (defines.POINTSIZE) {
        fallbacks.addFallback(1, "POINTSIZE");
      }
      if (defines.MULTIVIEW) {
        fallbacks.addFallback(0, "MULTIVIEW");
      }
      MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights);
      var attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
      MaterialHelper.PrepareAttributesForInstances(attribs, defines);
      var uniforms = [
        "world",
        "view",
        "viewProjection",
        "vEyePosition",
        "vLightsType",
        "vFogInfos",
        "vFogColor",
        "pointSize",
        "vClipPlane",
        "vClipPlane2",
        "vClipPlane3",
        "vClipPlane4",
        "vClipPlane5",
        "vClipPlane6",
        "mBones",
        "vPrimaryColor",
        "vPrimaryColorShadow",
        "vReflectionInfos",
        "reflectionMatrix",
        "vReflectionMicrosurfaceInfos",
        "fFovMultiplier",
        "shadowLevel",
        "alpha",
        "vBackgroundCenter",
        "vReflectionControl",
        "vDiffuseInfos",
        "diffuseMatrix"
      ];
      var samplers = ["diffuseSampler", "reflectionSampler", "reflectionSamplerLow", "reflectionSamplerHigh"];
      var uniformBuffers = ["Material", "Scene"];
      if (ImageProcessingConfiguration) {
        ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);
        ImageProcessingConfiguration.PrepareSamplers(samplers, defines);
      }
      MaterialHelper.PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: this._maxSimultaneousLights
      });
      var onCompiled = function(effect) {
        if (_this.onCompiled) {
          _this.onCompiled(effect);
        }
        _this.bindSceneUniformBuffer(effect, scene.getSceneUniformBuffer());
      };
      var join = defines.toString();
      subMesh.setEffect(scene.getEngine().createEffect("background", {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights }
      }, engine), defines);
      this.buildUniformLayout();
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    subMesh.effect._wasPreviouslyReady = true;
    return true;
  };
  BackgroundMaterial2.prototype._computePrimaryColorFromPerceptualColor = function() {
    if (!this.__perceptualColor) {
      return;
    }
    this._primaryColor.copyFrom(this.__perceptualColor);
    this._primaryColor.toLinearSpaceToRef(this._primaryColor);
    if (this._imageProcessingConfiguration) {
      this._primaryColor.scaleToRef(1 / this._imageProcessingConfiguration.exposure, this._primaryColor);
    }
    this._computePrimaryColors();
  };
  BackgroundMaterial2.prototype._computePrimaryColors = function() {
    if (this._primaryColorShadowLevel === 0 && this._primaryColorHighlightLevel === 0) {
      return;
    }
    this._primaryColor.scaleToRef(this._primaryColorShadowLevel, this._primaryShadowColor);
    this._primaryColor.subtractToRef(this._primaryShadowColor, this._primaryShadowColor);
    this._white.subtractToRef(this._primaryColor, this._primaryHighlightColor);
    this._primaryHighlightColor.scaleToRef(this._primaryColorHighlightLevel, this._primaryHighlightColor);
    this._primaryColor.addToRef(this._primaryHighlightColor, this._primaryHighlightColor);
  };
  BackgroundMaterial2.prototype.buildUniformLayout = function() {
    this._uniformBuffer.addUniform("vPrimaryColor", 4);
    this._uniformBuffer.addUniform("vPrimaryColorShadow", 4);
    this._uniformBuffer.addUniform("vDiffuseInfos", 2);
    this._uniformBuffer.addUniform("vReflectionInfos", 2);
    this._uniformBuffer.addUniform("diffuseMatrix", 16);
    this._uniformBuffer.addUniform("reflectionMatrix", 16);
    this._uniformBuffer.addUniform("vReflectionMicrosurfaceInfos", 3);
    this._uniformBuffer.addUniform("fFovMultiplier", 1);
    this._uniformBuffer.addUniform("pointSize", 1);
    this._uniformBuffer.addUniform("shadowLevel", 1);
    this._uniformBuffer.addUniform("alpha", 1);
    this._uniformBuffer.addUniform("vBackgroundCenter", 3);
    this._uniformBuffer.addUniform("vReflectionControl", 4);
    this._uniformBuffer.create();
  };
  BackgroundMaterial2.prototype.unbind = function() {
    if (this._diffuseTexture && this._diffuseTexture.isRenderTarget) {
      this._uniformBuffer.setTexture("diffuseSampler", null);
    }
    if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
      this._uniformBuffer.setTexture("reflectionSampler", null);
    }
    _super.prototype.unbind.call(this);
  };
  BackgroundMaterial2.prototype.bindOnlyWorldMatrix = function(world) {
    this._activeEffect.setMatrix("world", world);
  };
  BackgroundMaterial2.prototype.bindForSubMesh = function(world, mesh, subMesh) {
    var scene = this.getScene();
    var defines = subMesh._materialDefines;
    if (!defines) {
      return;
    }
    var effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    MaterialHelper.BindBonesParameters(mesh, this._activeEffect);
    var mustRebind = this._mustRebind(scene, effect, mesh.visibility);
    if (mustRebind) {
      this._uniformBuffer.bindToEffect(effect, "Material");
      this.bindViewProjection(effect);
      var reflectionTexture = this._reflectionTexture;
      if (!this._uniformBuffer.useUbo || !this.isFrozen || !this._uniformBuffer.isSync) {
        if (scene.texturesEnabled) {
          if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {
            this._uniformBuffer.updateFloat2("vDiffuseInfos", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);
            MaterialHelper.BindTextureMatrix(this._diffuseTexture, this._uniformBuffer, "diffuse");
          }
          if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
            this._uniformBuffer.updateMatrix("reflectionMatrix", reflectionTexture.getReflectionTextureMatrix());
            this._uniformBuffer.updateFloat2("vReflectionInfos", reflectionTexture.level, this._reflectionBlur);
            this._uniformBuffer.updateFloat3("vReflectionMicrosurfaceInfos", reflectionTexture.getSize().width, reflectionTexture.lodGenerationScale, reflectionTexture.lodGenerationOffset);
          }
        }
        if (this.shadowLevel > 0) {
          this._uniformBuffer.updateFloat("shadowLevel", this.shadowLevel);
        }
        this._uniformBuffer.updateFloat("alpha", this.alpha);
        if (this.pointsCloud) {
          this._uniformBuffer.updateFloat("pointSize", this.pointSize);
        }
        if (defines.USEHIGHLIGHTANDSHADOWCOLORS) {
          this._uniformBuffer.updateColor4("vPrimaryColor", this._primaryHighlightColor, 1);
          this._uniformBuffer.updateColor4("vPrimaryColorShadow", this._primaryShadowColor, 1);
        } else {
          this._uniformBuffer.updateColor4("vPrimaryColor", this._primaryColor, 1);
        }
      }
      this._uniformBuffer.updateFloat("fFovMultiplier", this._fovMultiplier);
      if (scene.texturesEnabled) {
        if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {
          this._uniformBuffer.setTexture("diffuseSampler", this._diffuseTexture);
        }
        if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
          if (defines.REFLECTIONBLUR && defines.TEXTURELODSUPPORT) {
            this._uniformBuffer.setTexture("reflectionSampler", reflectionTexture);
          } else if (!defines.REFLECTIONBLUR) {
            this._uniformBuffer.setTexture("reflectionSampler", reflectionTexture);
          } else {
            this._uniformBuffer.setTexture("reflectionSampler", reflectionTexture._lodTextureMid || reflectionTexture);
            this._uniformBuffer.setTexture("reflectionSamplerLow", reflectionTexture._lodTextureLow || reflectionTexture);
            this._uniformBuffer.setTexture("reflectionSamplerHigh", reflectionTexture._lodTextureHigh || reflectionTexture);
          }
          if (defines.REFLECTIONFRESNEL) {
            this._uniformBuffer.updateFloat3("vBackgroundCenter", this.sceneCenter.x, this.sceneCenter.y, this.sceneCenter.z);
            this._uniformBuffer.updateFloat4("vReflectionControl", this._reflectionControls.x, this._reflectionControls.y, this._reflectionControls.z, this._reflectionControls.w);
          }
        }
      }
      MaterialHelper.BindClipPlane(this._activeEffect, scene);
      MaterialHelper.BindEyePosition(effect, scene);
    }
    if (mustRebind || !this.isFrozen) {
      if (scene.lightsEnabled) {
        MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights, false);
      }
      this.bindView(effect);
      MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect, true);
      if (this._imageProcessingConfiguration) {
        this._imageProcessingConfiguration.bind(this._activeEffect);
      }
    }
    this._uniformBuffer.update();
    this._afterBind(mesh, this._activeEffect);
  };
  BackgroundMaterial2.prototype.hasTexture = function(texture) {
    if (_super.prototype.hasTexture.call(this, texture)) {
      return true;
    }
    if (this._reflectionTexture === texture) {
      return true;
    }
    if (this._diffuseTexture === texture) {
      return true;
    }
    return false;
  };
  BackgroundMaterial2.prototype.dispose = function(forceDisposeEffect, forceDisposeTextures) {
    if (forceDisposeEffect === void 0) {
      forceDisposeEffect = false;
    }
    if (forceDisposeTextures === void 0) {
      forceDisposeTextures = false;
    }
    if (forceDisposeTextures) {
      if (this.diffuseTexture) {
        this.diffuseTexture.dispose();
      }
      if (this.reflectionTexture) {
        this.reflectionTexture.dispose();
      }
    }
    this._renderTargets.dispose();
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    _super.prototype.dispose.call(this, forceDisposeEffect);
  };
  BackgroundMaterial2.prototype.clone = function(name98) {
    var _this = this;
    return SerializationHelper.Clone(function() {
      return new BackgroundMaterial2(name98, _this.getScene());
    }, this);
  };
  BackgroundMaterial2.prototype.serialize = function() {
    var serializationObject = SerializationHelper.Serialize(this);
    serializationObject.customType = "BABYLON.BackgroundMaterial";
    return serializationObject;
  };
  BackgroundMaterial2.prototype.getClassName = function() {
    return "BackgroundMaterial";
  };
  BackgroundMaterial2.Parse = function(source, scene, rootUrl) {
    return SerializationHelper.Parse(function() {
      return new BackgroundMaterial2(source.name, scene);
    }, source, scene, rootUrl);
  };
  BackgroundMaterial2.StandardReflectance0 = 0.05;
  BackgroundMaterial2.StandardReflectance90 = 0.5;
  __decorate([
    serializeAsColor3()
  ], BackgroundMaterial2.prototype, "_primaryColor", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsLightsDirty")
  ], BackgroundMaterial2.prototype, "primaryColor", void 0);
  __decorate([
    serializeAsColor3()
  ], BackgroundMaterial2.prototype, "__perceptualColor", void 0);
  __decorate([
    serialize()
  ], BackgroundMaterial2.prototype, "_primaryColorShadowLevel", void 0);
  __decorate([
    serialize()
  ], BackgroundMaterial2.prototype, "_primaryColorHighlightLevel", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsLightsDirty")
  ], BackgroundMaterial2.prototype, "primaryColorHighlightLevel", null);
  __decorate([
    serializeAsTexture()
  ], BackgroundMaterial2.prototype, "_reflectionTexture", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], BackgroundMaterial2.prototype, "reflectionTexture", void 0);
  __decorate([
    serialize()
  ], BackgroundMaterial2.prototype, "_reflectionBlur", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], BackgroundMaterial2.prototype, "reflectionBlur", void 0);
  __decorate([
    serializeAsTexture()
  ], BackgroundMaterial2.prototype, "_diffuseTexture", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], BackgroundMaterial2.prototype, "diffuseTexture", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], BackgroundMaterial2.prototype, "shadowLights", void 0);
  __decorate([
    serialize()
  ], BackgroundMaterial2.prototype, "_shadowLevel", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], BackgroundMaterial2.prototype, "shadowLevel", void 0);
  __decorate([
    serializeAsVector3()
  ], BackgroundMaterial2.prototype, "_sceneCenter", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], BackgroundMaterial2.prototype, "sceneCenter", void 0);
  __decorate([
    serialize()
  ], BackgroundMaterial2.prototype, "_opacityFresnel", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], BackgroundMaterial2.prototype, "opacityFresnel", void 0);
  __decorate([
    serialize()
  ], BackgroundMaterial2.prototype, "_reflectionFresnel", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], BackgroundMaterial2.prototype, "reflectionFresnel", void 0);
  __decorate([
    serialize()
  ], BackgroundMaterial2.prototype, "_reflectionFalloffDistance", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], BackgroundMaterial2.prototype, "reflectionFalloffDistance", void 0);
  __decorate([
    serialize()
  ], BackgroundMaterial2.prototype, "_reflectionAmount", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], BackgroundMaterial2.prototype, "reflectionAmount", void 0);
  __decorate([
    serialize()
  ], BackgroundMaterial2.prototype, "_reflectionReflectance0", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], BackgroundMaterial2.prototype, "reflectionReflectance0", void 0);
  __decorate([
    serialize()
  ], BackgroundMaterial2.prototype, "_reflectionReflectance90", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], BackgroundMaterial2.prototype, "reflectionReflectance90", void 0);
  __decorate([
    serialize()
  ], BackgroundMaterial2.prototype, "_useRGBColor", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], BackgroundMaterial2.prototype, "useRGBColor", void 0);
  __decorate([
    serialize()
  ], BackgroundMaterial2.prototype, "_enableNoise", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], BackgroundMaterial2.prototype, "enableNoise", void 0);
  __decorate([
    serialize()
  ], BackgroundMaterial2.prototype, "_maxSimultaneousLights", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], BackgroundMaterial2.prototype, "maxSimultaneousLights", void 0);
  __decorate([
    serialize()
  ], BackgroundMaterial2.prototype, "_shadowOnly", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsLightsDirty")
  ], BackgroundMaterial2.prototype, "shadowOnly", void 0);
  __decorate([
    serializeAsImageProcessingConfiguration()
  ], BackgroundMaterial2.prototype, "_imageProcessingConfiguration", void 0);
  return BackgroundMaterial2;
}(PushMaterial);
_TypeStore.RegisteredTypes["BABYLON.BackgroundMaterial"] = BackgroundMaterial;

// node_modules/@babylonjs/core/Helpers/environmentHelper.js
var EnvironmentHelper = function() {
  function EnvironmentHelper2(options, scene) {
    var _this = this;
    this._errorHandler = function(message, exception) {
      _this.onErrorObservable.notifyObservers({ message, exception });
    };
    this._options = __assign(__assign({}, EnvironmentHelper2._getDefaultOptions()), options);
    this._scene = scene;
    this.onErrorObservable = new Observable();
    this._setupBackground();
    this._setupImageProcessing();
  }
  EnvironmentHelper2._getDefaultOptions = function() {
    return {
      createGround: true,
      groundSize: 15,
      groundTexture: this._groundTextureCDNUrl,
      groundColor: new Color3(0.2, 0.2, 0.3).toLinearSpace().scale(3),
      groundOpacity: 0.9,
      enableGroundShadow: true,
      groundShadowLevel: 0.5,
      enableGroundMirror: false,
      groundMirrorSizeRatio: 0.3,
      groundMirrorBlurKernel: 64,
      groundMirrorAmount: 1,
      groundMirrorFresnelWeight: 1,
      groundMirrorFallOffDistance: 0,
      groundMirrorTextureType: 0,
      groundYBias: 1e-5,
      createSkybox: true,
      skyboxSize: 20,
      skyboxTexture: this._skyboxTextureCDNUrl,
      skyboxColor: new Color3(0.2, 0.2, 0.3).toLinearSpace().scale(3),
      backgroundYRotation: 0,
      sizeAuto: true,
      rootPosition: Vector3.Zero(),
      setupImageProcessing: true,
      environmentTexture: this._environmentTextureCDNUrl,
      cameraExposure: 0.8,
      cameraContrast: 1.2,
      toneMappingEnabled: true
    };
  };
  Object.defineProperty(EnvironmentHelper2.prototype, "rootMesh", {
    get: function() {
      return this._rootMesh;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EnvironmentHelper2.prototype, "skybox", {
    get: function() {
      return this._skybox;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EnvironmentHelper2.prototype, "skyboxTexture", {
    get: function() {
      return this._skyboxTexture;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EnvironmentHelper2.prototype, "skyboxMaterial", {
    get: function() {
      return this._skyboxMaterial;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EnvironmentHelper2.prototype, "ground", {
    get: function() {
      return this._ground;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EnvironmentHelper2.prototype, "groundTexture", {
    get: function() {
      return this._groundTexture;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EnvironmentHelper2.prototype, "groundMirror", {
    get: function() {
      return this._groundMirror;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EnvironmentHelper2.prototype, "groundMirrorRenderList", {
    get: function() {
      if (this._groundMirror) {
        return this._groundMirror.renderList;
      }
      return null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EnvironmentHelper2.prototype, "groundMaterial", {
    get: function() {
      return this._groundMaterial;
    },
    enumerable: false,
    configurable: true
  });
  EnvironmentHelper2.prototype.updateOptions = function(options) {
    var newOptions = __assign(__assign({}, this._options), options);
    if (this._ground && !newOptions.createGround) {
      this._ground.dispose();
      this._ground = null;
    }
    if (this._groundMaterial && !newOptions.createGround) {
      this._groundMaterial.dispose();
      this._groundMaterial = null;
    }
    if (this._groundTexture) {
      if (this._options.groundTexture != newOptions.groundTexture) {
        this._groundTexture.dispose();
        this._groundTexture = null;
      }
    }
    if (this._skybox && !newOptions.createSkybox) {
      this._skybox.dispose();
      this._skybox = null;
    }
    if (this._skyboxMaterial && !newOptions.createSkybox) {
      this._skyboxMaterial.dispose();
      this._skyboxMaterial = null;
    }
    if (this._skyboxTexture) {
      if (this._options.skyboxTexture != newOptions.skyboxTexture) {
        this._skyboxTexture.dispose();
        this._skyboxTexture = null;
      }
    }
    if (this._groundMirror && !newOptions.enableGroundMirror) {
      this._groundMirror.dispose();
      this._groundMirror = null;
    }
    if (this._scene.environmentTexture) {
      if (this._options.environmentTexture != newOptions.environmentTexture) {
        this._scene.environmentTexture.dispose();
      }
    }
    this._options = newOptions;
    this._setupBackground();
    this._setupImageProcessing();
  };
  EnvironmentHelper2.prototype.setMainColor = function(color) {
    if (this.groundMaterial) {
      this.groundMaterial.primaryColor = color;
    }
    if (this.skyboxMaterial) {
      this.skyboxMaterial.primaryColor = color;
    }
    if (this.groundMirror) {
      this.groundMirror.clearColor = new Color4(color.r, color.g, color.b, 1);
    }
  };
  EnvironmentHelper2.prototype._setupImageProcessing = function() {
    if (this._options.setupImageProcessing) {
      this._scene.imageProcessingConfiguration.contrast = this._options.cameraContrast;
      this._scene.imageProcessingConfiguration.exposure = this._options.cameraExposure;
      this._scene.imageProcessingConfiguration.toneMappingEnabled = this._options.toneMappingEnabled;
      this._setupEnvironmentTexture();
    }
  };
  EnvironmentHelper2.prototype._setupEnvironmentTexture = function() {
    if (this._scene.environmentTexture) {
      return;
    }
    if (this._options.environmentTexture instanceof BaseTexture) {
      this._scene.environmentTexture = this._options.environmentTexture;
      return;
    }
    var environmentTexture = CubeTexture.CreateFromPrefilteredData(this._options.environmentTexture, this._scene);
    this._scene.environmentTexture = environmentTexture;
  };
  EnvironmentHelper2.prototype._setupBackground = function() {
    if (!this._rootMesh) {
      this._rootMesh = new Mesh("BackgroundHelper", this._scene);
    }
    this._rootMesh.rotation.y = this._options.backgroundYRotation;
    var sceneSize = this._getSceneSize();
    if (this._options.createGround) {
      this._setupGround(sceneSize);
      this._setupGroundMaterial();
      this._setupGroundDiffuseTexture();
      if (this._options.enableGroundMirror) {
        this._setupGroundMirrorTexture(sceneSize);
      }
      this._setupMirrorInGroundMaterial();
    }
    if (this._options.createSkybox) {
      this._setupSkybox(sceneSize);
      this._setupSkyboxMaterial();
      this._setupSkyboxReflectionTexture();
    }
    this._rootMesh.position.x = sceneSize.rootPosition.x;
    this._rootMesh.position.z = sceneSize.rootPosition.z;
    this._rootMesh.position.y = sceneSize.rootPosition.y;
  };
  EnvironmentHelper2.prototype._getSceneSize = function() {
    var _this = this;
    var groundSize = this._options.groundSize;
    var skyboxSize = this._options.skyboxSize;
    var rootPosition = this._options.rootPosition;
    if (!this._scene.meshes || this._scene.meshes.length === 1) {
      return { groundSize, skyboxSize, rootPosition };
    }
    var sceneExtends = this._scene.getWorldExtends(function(mesh) {
      return mesh !== _this._ground && mesh !== _this._rootMesh && mesh !== _this._skybox;
    });
    var sceneDiagonal = sceneExtends.max.subtract(sceneExtends.min);
    if (this._options.sizeAuto) {
      if (this._scene.activeCamera instanceof ArcRotateCamera && this._scene.activeCamera.upperRadiusLimit) {
        groundSize = this._scene.activeCamera.upperRadiusLimit * 2;
        skyboxSize = groundSize;
      }
      var sceneDiagonalLenght = sceneDiagonal.length();
      if (sceneDiagonalLenght > groundSize) {
        groundSize = sceneDiagonalLenght * 2;
        skyboxSize = groundSize;
      }
      groundSize *= 1.1;
      skyboxSize *= 1.5;
      rootPosition = sceneExtends.min.add(sceneDiagonal.scale(0.5));
      rootPosition.y = sceneExtends.min.y - this._options.groundYBias;
    }
    return { groundSize, skyboxSize, rootPosition };
  };
  EnvironmentHelper2.prototype._setupGround = function(sceneSize) {
    var _this = this;
    if (!this._ground || this._ground.isDisposed()) {
      this._ground = Mesh.CreatePlane("BackgroundPlane", sceneSize.groundSize, this._scene);
      this._ground.rotation.x = Math.PI / 2;
      this._ground.parent = this._rootMesh;
      this._ground.onDisposeObservable.add(function() {
        _this._ground = null;
      });
    }
    this._ground.receiveShadows = this._options.enableGroundShadow;
  };
  EnvironmentHelper2.prototype._setupGroundMaterial = function() {
    if (!this._groundMaterial) {
      this._groundMaterial = new BackgroundMaterial("BackgroundPlaneMaterial", this._scene);
    }
    this._groundMaterial.alpha = this._options.groundOpacity;
    this._groundMaterial.alphaMode = 8;
    this._groundMaterial.shadowLevel = this._options.groundShadowLevel;
    this._groundMaterial.primaryColor = this._options.groundColor;
    this._groundMaterial.useRGBColor = false;
    this._groundMaterial.enableNoise = true;
    if (this._ground) {
      this._ground.material = this._groundMaterial;
    }
  };
  EnvironmentHelper2.prototype._setupGroundDiffuseTexture = function() {
    if (!this._groundMaterial) {
      return;
    }
    if (this._groundTexture) {
      return;
    }
    if (this._options.groundTexture instanceof BaseTexture) {
      this._groundMaterial.diffuseTexture = this._options.groundTexture;
      return;
    }
    this._groundTexture = new Texture(this._options.groundTexture, this._scene, void 0, void 0, void 0, void 0, this._errorHandler);
    this._groundTexture.gammaSpace = false;
    this._groundTexture.hasAlpha = true;
    this._groundMaterial.diffuseTexture = this._groundTexture;
  };
  EnvironmentHelper2.prototype._setupGroundMirrorTexture = function(sceneSize) {
    var wrapping = Texture.CLAMP_ADDRESSMODE;
    if (!this._groundMirror) {
      this._groundMirror = new MirrorTexture("BackgroundPlaneMirrorTexture", { ratio: this._options.groundMirrorSizeRatio }, this._scene, false, this._options.groundMirrorTextureType, Texture.BILINEAR_SAMPLINGMODE, true);
      this._groundMirror.mirrorPlane = new Plane(0, -1, 0, sceneSize.rootPosition.y);
      this._groundMirror.anisotropicFilteringLevel = 1;
      this._groundMirror.wrapU = wrapping;
      this._groundMirror.wrapV = wrapping;
      this._groundMirror.gammaSpace = false;
      if (this._groundMirror.renderList) {
        for (var i = 0; i < this._scene.meshes.length; i++) {
          var mesh = this._scene.meshes[i];
          if (mesh !== this._ground && mesh !== this._skybox && mesh !== this._rootMesh) {
            this._groundMirror.renderList.push(mesh);
          }
        }
      }
    }
    this._groundMirror.clearColor = new Color4(this._options.groundColor.r, this._options.groundColor.g, this._options.groundColor.b, 1);
    this._groundMirror.adaptiveBlurKernel = this._options.groundMirrorBlurKernel;
  };
  EnvironmentHelper2.prototype._setupMirrorInGroundMaterial = function() {
    if (this._groundMaterial) {
      this._groundMaterial.reflectionTexture = this._groundMirror;
      this._groundMaterial.reflectionFresnel = true;
      this._groundMaterial.reflectionAmount = this._options.groundMirrorAmount;
      this._groundMaterial.reflectionStandardFresnelWeight = this._options.groundMirrorFresnelWeight;
      this._groundMaterial.reflectionFalloffDistance = this._options.groundMirrorFallOffDistance;
    }
  };
  EnvironmentHelper2.prototype._setupSkybox = function(sceneSize) {
    var _this = this;
    if (!this._skybox || this._skybox.isDisposed()) {
      this._skybox = Mesh.CreateBox("BackgroundSkybox", sceneSize.skyboxSize, this._scene, void 0, Mesh.BACKSIDE);
      this._skybox.onDisposeObservable.add(function() {
        _this._skybox = null;
      });
    }
    this._skybox.parent = this._rootMesh;
  };
  EnvironmentHelper2.prototype._setupSkyboxMaterial = function() {
    if (!this._skybox) {
      return;
    }
    if (!this._skyboxMaterial) {
      this._skyboxMaterial = new BackgroundMaterial("BackgroundSkyboxMaterial", this._scene);
    }
    this._skyboxMaterial.useRGBColor = false;
    this._skyboxMaterial.primaryColor = this._options.skyboxColor;
    this._skyboxMaterial.enableNoise = true;
    this._skybox.material = this._skyboxMaterial;
  };
  EnvironmentHelper2.prototype._setupSkyboxReflectionTexture = function() {
    if (!this._skyboxMaterial) {
      return;
    }
    if (this._skyboxTexture) {
      return;
    }
    if (this._options.skyboxTexture instanceof BaseTexture) {
      this._skyboxMaterial.reflectionTexture = this._options.skyboxTexture;
      return;
    }
    this._skyboxTexture = new CubeTexture(this._options.skyboxTexture, this._scene, void 0, void 0, void 0, void 0, this._errorHandler);
    this._skyboxTexture.coordinatesMode = Texture.SKYBOX_MODE;
    this._skyboxTexture.gammaSpace = false;
    this._skyboxMaterial.reflectionTexture = this._skyboxTexture;
  };
  EnvironmentHelper2.prototype.dispose = function() {
    if (this._groundMaterial) {
      this._groundMaterial.dispose(true, true);
    }
    if (this._skyboxMaterial) {
      this._skyboxMaterial.dispose(true, true);
    }
    this._rootMesh.dispose(false);
  };
  EnvironmentHelper2._groundTextureCDNUrl = "https://assets.babylonjs.com/environments/backgroundGround.png";
  EnvironmentHelper2._skyboxTextureCDNUrl = "https://assets.babylonjs.com/environments/backgroundSkybox.dds";
  EnvironmentHelper2._environmentTextureCDNUrl = "https://assets.babylonjs.com/environments/environmentSpecular.env";
  return EnvironmentHelper2;
}();

// node_modules/@babylonjs/core/Helpers/textureDome.js
var TextureDome = function(_super) {
  __extends(TextureDome2, _super);
  function TextureDome2(name98, textureUrlOrElement, options, scene, onError) {
    if (onError === void 0) {
      onError = null;
    }
    var _this = _super.call(this, name98, scene) || this;
    _this.onError = onError;
    _this._halfDome = false;
    _this._crossEye = false;
    _this._useDirectMapping = false;
    _this._textureMode = TextureDome2.MODE_MONOSCOPIC;
    _this._onBeforeCameraRenderObserver = null;
    _this.onLoadErrorObservable = new Observable();
    scene = _this.getScene();
    name98 = name98 || "textureDome";
    options.resolution = Math.abs(options.resolution) | 0 || 32;
    options.clickToPlay = Boolean(options.clickToPlay);
    options.autoPlay = options.autoPlay === void 0 ? true : Boolean(options.autoPlay);
    options.loop = options.loop === void 0 ? true : Boolean(options.loop);
    options.size = Math.abs(options.size) || (scene.activeCamera ? scene.activeCamera.maxZ * 0.48 : 1e3);
    if (options.useDirectMapping === void 0) {
      _this._useDirectMapping = true;
    } else {
      _this._useDirectMapping = options.useDirectMapping;
    }
    if (options.faceForward === void 0) {
      options.faceForward = true;
    }
    _this._setReady(false);
    _this._mesh = Mesh.CreateSphere(name98 + "_mesh", options.resolution, options.size, scene, false, Mesh.BACKSIDE);
    var material = _this._material = new BackgroundMaterial(name98 + "_material", scene);
    material.useEquirectangularFOV = true;
    material.fovMultiplier = 1;
    material.opacityFresnel = false;
    var texture = _this._initTexture(textureUrlOrElement, scene, options);
    _this.texture = texture;
    _this._mesh.material = material;
    _this._mesh.parent = _this;
    _this._halfDomeMask = SphereBuilder.CreateSphere("", { slice: 0.5, diameter: options.size * 0.98, segments: options.resolution * 2, sideOrientation: Mesh.BACKSIDE }, scene);
    _this._halfDomeMask.rotate(Axis.X, -Math.PI / 2);
    _this._halfDomeMask.parent = _this._mesh;
    _this._halfDome = !!options.halfDomeMode;
    _this._halfDomeMask.setEnabled(_this._halfDome);
    _this._crossEye = !!options.crossEyeMode;
    _this._texture.anisotropicFilteringLevel = 1;
    _this._texture.onLoadObservable.addOnce(function() {
      _this._setReady(true);
    });
    if (options.faceForward && scene.activeCamera) {
      var camera = scene.activeCamera;
      var forward = Vector3.Forward();
      var direction = Vector3.TransformNormal(forward, camera.getViewMatrix());
      direction.normalize();
      _this.rotation.y = Math.acos(Vector3.Dot(forward, direction));
    }
    _this._changeTextureMode(_this._textureMode);
    return _this;
  }
  Object.defineProperty(TextureDome2.prototype, "texture", {
    get: function() {
      return this._texture;
    },
    set: function(newTexture) {
      if (this._texture === newTexture) {
        return;
      }
      this._texture = newTexture;
      if (this._useDirectMapping) {
        this._texture.wrapU = Texture.CLAMP_ADDRESSMODE;
        this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;
        this._material.diffuseTexture = this._texture;
      } else {
        this._texture.coordinatesMode = Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE;
        this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;
        this._material.reflectionTexture = this._texture;
      }
      this._changeTextureMode(this._textureMode);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextureDome2.prototype, "mesh", {
    get: function() {
      return this._mesh;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextureDome2.prototype, "fovMultiplier", {
    get: function() {
      return this._material.fovMultiplier;
    },
    set: function(value) {
      this._material.fovMultiplier = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextureDome2.prototype, "textureMode", {
    get: function() {
      return this._textureMode;
    },
    set: function(value) {
      if (this._textureMode === value) {
        return;
      }
      this._changeTextureMode(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextureDome2.prototype, "halfDome", {
    get: function() {
      return this._halfDome;
    },
    set: function(enabled) {
      this._halfDome = enabled;
      this._halfDomeMask.setEnabled(enabled);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextureDome2.prototype, "crossEye", {
    get: function() {
      return this._crossEye;
    },
    set: function(enabled) {
      this._crossEye = enabled;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextureDome2.prototype, "material", {
    get: function() {
      return this._material;
    },
    enumerable: false,
    configurable: true
  });
  TextureDome2.prototype._changeTextureMode = function(value) {
    var _this = this;
    this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);
    this._textureMode = value;
    this._texture.uScale = 1;
    this._texture.vScale = 1;
    this._texture.uOffset = 0;
    this._texture.vOffset = 0;
    this._texture.vAng = 0;
    switch (value) {
      case TextureDome2.MODE_MONOSCOPIC:
        if (this._halfDome) {
          this._texture.uScale = 2;
          this._texture.uOffset = -1;
        }
        break;
      case TextureDome2.MODE_SIDEBYSIDE:
        this._texture.uScale = this._halfDome ? 0.99999 : 0.5;
        var rightOffset_1 = this._halfDome ? 0 : 0.5;
        var leftOffset_1 = this._halfDome ? -0.5 : 0;
        this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add(function(camera) {
          var isRightCamera = camera.isRightCamera;
          if (_this._crossEye) {
            isRightCamera = !isRightCamera;
          }
          if (isRightCamera) {
            _this._texture.uOffset = rightOffset_1;
          } else {
            _this._texture.uOffset = leftOffset_1;
          }
        });
        break;
      case TextureDome2.MODE_TOPBOTTOM:
        this._texture.vScale = this._halfDome ? 0.99999 : 0.5;
        this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add(function(camera) {
          var isRightCamera = camera.isRightCamera;
          if (_this._crossEye) {
            isRightCamera = !isRightCamera;
          }
          _this._texture.vOffset = isRightCamera ? 0.5 : 0;
        });
        break;
    }
  };
  TextureDome2.prototype.dispose = function(doNotRecurse, disposeMaterialAndTextures) {
    if (disposeMaterialAndTextures === void 0) {
      disposeMaterialAndTextures = false;
    }
    this._texture.dispose();
    this._mesh.dispose();
    this._material.dispose();
    this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);
    this.onLoadErrorObservable.clear();
    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);
  };
  TextureDome2.MODE_MONOSCOPIC = 0;
  TextureDome2.MODE_TOPBOTTOM = 1;
  TextureDome2.MODE_SIDEBYSIDE = 2;
  return TextureDome2;
}(TransformNode);

// node_modules/@babylonjs/core/Helpers/photoDome.js
var PhotoDome = function(_super) {
  __extends(PhotoDome2, _super);
  function PhotoDome2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Object.defineProperty(PhotoDome2.prototype, "photoTexture", {
    get: function() {
      return this.texture;
    },
    set: function(value) {
      this.texture = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PhotoDome2.prototype, "imageMode", {
    get: function() {
      return this.textureMode;
    },
    set: function(value) {
      this.textureMode = value;
    },
    enumerable: false,
    configurable: true
  });
  PhotoDome2.prototype._initTexture = function(urlsOrElement, scene, options) {
    var _this = this;
    return new Texture(urlsOrElement, scene, !options.generateMipMaps, !this._useDirectMapping, void 0, void 0, function(message, exception) {
      _this.onLoadErrorObservable.notifyObservers(message || "Unknown error occured");
      if (_this.onError) {
        _this.onError(message, exception);
      }
    });
  };
  PhotoDome2.MODE_MONOSCOPIC = TextureDome.MODE_MONOSCOPIC;
  PhotoDome2.MODE_TOPBOTTOM = TextureDome.MODE_TOPBOTTOM;
  PhotoDome2.MODE_SIDEBYSIDE = TextureDome.MODE_SIDEBYSIDE;
  return PhotoDome2;
}(TextureDome);

// node_modules/@babylonjs/core/Misc/dds.js
var DDS_MAGIC = 542327876;
var DDSD_MIPMAPCOUNT = 131072;
var DDSCAPS2_CUBEMAP = 512;
var DDPF_FOURCC = 4;
var DDPF_RGB = 64;
var DDPF_LUMINANCE = 131072;
function FourCCToInt32(value) {
  return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);
}
function Int32ToFourCC(value) {
  return String.fromCharCode(value & 255, value >> 8 & 255, value >> 16 & 255, value >> 24 & 255);
}
var FOURCC_DXT1 = FourCCToInt32("DXT1");
var FOURCC_DXT3 = FourCCToInt32("DXT3");
var FOURCC_DXT5 = FourCCToInt32("DXT5");
var FOURCC_DX10 = FourCCToInt32("DX10");
var FOURCC_D3DFMT_R16G16B16A16F = 113;
var FOURCC_D3DFMT_R32G32B32A32F = 116;
var DXGI_FORMAT_R32G32B32A32_FLOAT = 2;
var DXGI_FORMAT_R16G16B16A16_FLOAT = 10;
var DXGI_FORMAT_B8G8R8X8_UNORM = 88;
var headerLengthInt = 31;
var off_magic = 0;
var off_size = 1;
var off_flags = 2;
var off_height = 3;
var off_width = 4;
var off_mipmapCount = 7;
var off_pfFlags = 20;
var off_pfFourCC = 21;
var off_RGBbpp = 22;
var off_RMask = 23;
var off_GMask = 24;
var off_BMask = 25;
var off_AMask = 26;
var off_caps2 = 28;
var off_dxgiFormat = 32;
var DDSTools = function() {
  function DDSTools2() {
  }
  DDSTools2.GetDDSInfo = function(data) {
    var header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);
    var extendedHeader = new Int32Array(data.buffer, data.byteOffset, headerLengthInt + 4);
    var mipmapCount = 1;
    if (header[off_flags] & DDSD_MIPMAPCOUNT) {
      mipmapCount = Math.max(1, header[off_mipmapCount]);
    }
    var fourCC = header[off_pfFourCC];
    var dxgiFormat = fourCC === FOURCC_DX10 ? extendedHeader[off_dxgiFormat] : 0;
    var textureType = 0;
    switch (fourCC) {
      case FOURCC_D3DFMT_R16G16B16A16F:
        textureType = 2;
        break;
      case FOURCC_D3DFMT_R32G32B32A32F:
        textureType = 1;
        break;
      case FOURCC_DX10:
        if (dxgiFormat === DXGI_FORMAT_R16G16B16A16_FLOAT) {
          textureType = 2;
          break;
        }
        if (dxgiFormat === DXGI_FORMAT_R32G32B32A32_FLOAT) {
          textureType = 1;
          break;
        }
    }
    return {
      width: header[off_width],
      height: header[off_height],
      mipmapCount,
      isFourCC: (header[off_pfFlags] & DDPF_FOURCC) === DDPF_FOURCC,
      isRGB: (header[off_pfFlags] & DDPF_RGB) === DDPF_RGB,
      isLuminance: (header[off_pfFlags] & DDPF_LUMINANCE) === DDPF_LUMINANCE,
      isCube: (header[off_caps2] & DDSCAPS2_CUBEMAP) === DDSCAPS2_CUBEMAP,
      isCompressed: fourCC === FOURCC_DXT1 || fourCC === FOURCC_DXT3 || fourCC === FOURCC_DXT5,
      dxgiFormat,
      textureType
    };
  };
  DDSTools2._ToHalfFloat = function(value) {
    if (!DDSTools2._FloatView) {
      DDSTools2._FloatView = new Float32Array(1);
      DDSTools2._Int32View = new Int32Array(DDSTools2._FloatView.buffer);
    }
    DDSTools2._FloatView[0] = value;
    var x = DDSTools2._Int32View[0];
    var bits = x >> 16 & 32768;
    var m = x >> 12 & 2047;
    var e = x >> 23 & 255;
    if (e < 103) {
      return bits;
    }
    if (e > 142) {
      bits |= 31744;
      bits |= (e == 255 ? 0 : 1) && x & 8388607;
      return bits;
    }
    if (e < 113) {
      m |= 2048;
      bits |= (m >> 114 - e) + (m >> 113 - e & 1);
      return bits;
    }
    bits |= e - 112 << 10 | m >> 1;
    bits += m & 1;
    return bits;
  };
  DDSTools2._FromHalfFloat = function(value) {
    var s = (value & 32768) >> 15;
    var e = (value & 31744) >> 10;
    var f = value & 1023;
    if (e === 0) {
      return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));
    } else if (e == 31) {
      return f ? NaN : (s ? -1 : 1) * Infinity;
    }
    return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));
  };
  DDSTools2._GetHalfFloatAsFloatRGBAArrayBuffer = function(width, height, dataOffset, dataLength, arrayBuffer, lod) {
    var destArray = new Float32Array(dataLength);
    var srcData = new Uint16Array(arrayBuffer, dataOffset);
    var index = 0;
    for (var y = 0; y < height; y++) {
      for (var x = 0; x < width; x++) {
        var srcPos = (x + y * width) * 4;
        destArray[index] = DDSTools2._FromHalfFloat(srcData[srcPos]);
        destArray[index + 1] = DDSTools2._FromHalfFloat(srcData[srcPos + 1]);
        destArray[index + 2] = DDSTools2._FromHalfFloat(srcData[srcPos + 2]);
        if (DDSTools2.StoreLODInAlphaChannel) {
          destArray[index + 3] = lod;
        } else {
          destArray[index + 3] = DDSTools2._FromHalfFloat(srcData[srcPos + 3]);
        }
        index += 4;
      }
    }
    return destArray;
  };
  DDSTools2._GetHalfFloatRGBAArrayBuffer = function(width, height, dataOffset, dataLength, arrayBuffer, lod) {
    if (DDSTools2.StoreLODInAlphaChannel) {
      var destArray = new Uint16Array(dataLength);
      var srcData = new Uint16Array(arrayBuffer, dataOffset);
      var index = 0;
      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          var srcPos = (x + y * width) * 4;
          destArray[index] = srcData[srcPos];
          destArray[index + 1] = srcData[srcPos + 1];
          destArray[index + 2] = srcData[srcPos + 2];
          destArray[index + 3] = DDSTools2._ToHalfFloat(lod);
          index += 4;
        }
      }
      return destArray;
    }
    return new Uint16Array(arrayBuffer, dataOffset, dataLength);
  };
  DDSTools2._GetFloatRGBAArrayBuffer = function(width, height, dataOffset, dataLength, arrayBuffer, lod) {
    if (DDSTools2.StoreLODInAlphaChannel) {
      var destArray = new Float32Array(dataLength);
      var srcData = new Float32Array(arrayBuffer, dataOffset);
      var index = 0;
      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          var srcPos = (x + y * width) * 4;
          destArray[index] = srcData[srcPos];
          destArray[index + 1] = srcData[srcPos + 1];
          destArray[index + 2] = srcData[srcPos + 2];
          destArray[index + 3] = lod;
          index += 4;
        }
      }
      return destArray;
    }
    return new Float32Array(arrayBuffer, dataOffset, dataLength);
  };
  DDSTools2._GetFloatAsUIntRGBAArrayBuffer = function(width, height, dataOffset, dataLength, arrayBuffer, lod) {
    var destArray = new Uint8Array(dataLength);
    var srcData = new Float32Array(arrayBuffer, dataOffset);
    var index = 0;
    for (var y = 0; y < height; y++) {
      for (var x = 0; x < width; x++) {
        var srcPos = (x + y * width) * 4;
        destArray[index] = Scalar.Clamp(srcData[srcPos]) * 255;
        destArray[index + 1] = Scalar.Clamp(srcData[srcPos + 1]) * 255;
        destArray[index + 2] = Scalar.Clamp(srcData[srcPos + 2]) * 255;
        if (DDSTools2.StoreLODInAlphaChannel) {
          destArray[index + 3] = lod;
        } else {
          destArray[index + 3] = Scalar.Clamp(srcData[srcPos + 3]) * 255;
        }
        index += 4;
      }
    }
    return destArray;
  };
  DDSTools2._GetHalfFloatAsUIntRGBAArrayBuffer = function(width, height, dataOffset, dataLength, arrayBuffer, lod) {
    var destArray = new Uint8Array(dataLength);
    var srcData = new Uint16Array(arrayBuffer, dataOffset);
    var index = 0;
    for (var y = 0; y < height; y++) {
      for (var x = 0; x < width; x++) {
        var srcPos = (x + y * width) * 4;
        destArray[index] = Scalar.Clamp(DDSTools2._FromHalfFloat(srcData[srcPos])) * 255;
        destArray[index + 1] = Scalar.Clamp(DDSTools2._FromHalfFloat(srcData[srcPos + 1])) * 255;
        destArray[index + 2] = Scalar.Clamp(DDSTools2._FromHalfFloat(srcData[srcPos + 2])) * 255;
        if (DDSTools2.StoreLODInAlphaChannel) {
          destArray[index + 3] = lod;
        } else {
          destArray[index + 3] = Scalar.Clamp(DDSTools2._FromHalfFloat(srcData[srcPos + 3])) * 255;
        }
        index += 4;
      }
    }
    return destArray;
  };
  DDSTools2._GetRGBAArrayBuffer = function(width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset, aOffset) {
    var byteArray = new Uint8Array(dataLength);
    var srcData = new Uint8Array(arrayBuffer, dataOffset);
    var index = 0;
    for (var y = 0; y < height; y++) {
      for (var x = 0; x < width; x++) {
        var srcPos = (x + y * width) * 4;
        byteArray[index] = srcData[srcPos + rOffset];
        byteArray[index + 1] = srcData[srcPos + gOffset];
        byteArray[index + 2] = srcData[srcPos + bOffset];
        byteArray[index + 3] = srcData[srcPos + aOffset];
        index += 4;
      }
    }
    return byteArray;
  };
  DDSTools2._ExtractLongWordOrder = function(value) {
    if (value === 0 || value === 255 || value === -16777216) {
      return 0;
    }
    return 1 + DDSTools2._ExtractLongWordOrder(value >> 8);
  };
  DDSTools2._GetRGBArrayBuffer = function(width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset) {
    var byteArray = new Uint8Array(dataLength);
    var srcData = new Uint8Array(arrayBuffer, dataOffset);
    var index = 0;
    for (var y = 0; y < height; y++) {
      for (var x = 0; x < width; x++) {
        var srcPos = (x + y * width) * 3;
        byteArray[index] = srcData[srcPos + rOffset];
        byteArray[index + 1] = srcData[srcPos + gOffset];
        byteArray[index + 2] = srcData[srcPos + bOffset];
        index += 3;
      }
    }
    return byteArray;
  };
  DDSTools2._GetLuminanceArrayBuffer = function(width, height, dataOffset, dataLength, arrayBuffer) {
    var byteArray = new Uint8Array(dataLength);
    var srcData = new Uint8Array(arrayBuffer, dataOffset);
    var index = 0;
    for (var y = 0; y < height; y++) {
      for (var x = 0; x < width; x++) {
        var srcPos = x + y * width;
        byteArray[index] = srcData[srcPos];
        index++;
      }
    }
    return byteArray;
  };
  DDSTools2.UploadDDSLevels = function(engine, texture, data, info, loadMipmaps, faces, lodIndex, currentFace) {
    if (lodIndex === void 0) {
      lodIndex = -1;
    }
    var sphericalPolynomialFaces = null;
    if (info.sphericalPolynomial) {
      sphericalPolynomialFaces = new Array();
    }
    var ext = engine.getCaps().s3tc;
    var header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);
    var fourCC, width, height, dataLength = 0, dataOffset;
    var byteArray, mipmapCount, mip;
    var internalCompressedFormat = 0;
    var blockBytes = 1;
    if (header[off_magic] !== DDS_MAGIC) {
      Logger.Error("Invalid magic number in DDS header");
      return;
    }
    if (!info.isFourCC && !info.isRGB && !info.isLuminance) {
      Logger.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");
      return;
    }
    if (info.isCompressed && !ext) {
      Logger.Error("Compressed textures are not supported on this platform.");
      return;
    }
    var bpp = header[off_RGBbpp];
    dataOffset = header[off_size] + 4;
    var computeFormats = false;
    if (info.isFourCC) {
      fourCC = header[off_pfFourCC];
      switch (fourCC) {
        case FOURCC_DXT1:
          blockBytes = 8;
          internalCompressedFormat = ext.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          break;
        case FOURCC_DXT3:
          blockBytes = 16;
          internalCompressedFormat = ext.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          break;
        case FOURCC_DXT5:
          blockBytes = 16;
          internalCompressedFormat = ext.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          break;
        case FOURCC_D3DFMT_R16G16B16A16F:
          computeFormats = true;
          break;
        case FOURCC_D3DFMT_R32G32B32A32F:
          computeFormats = true;
          break;
        case FOURCC_DX10:
          dataOffset += 5 * 4;
          var supported = false;
          switch (info.dxgiFormat) {
            case DXGI_FORMAT_R16G16B16A16_FLOAT:
            case DXGI_FORMAT_R32G32B32A32_FLOAT:
              computeFormats = true;
              supported = true;
              break;
            case DXGI_FORMAT_B8G8R8X8_UNORM:
              info.isRGB = true;
              info.isFourCC = false;
              bpp = 32;
              supported = true;
              break;
          }
          if (supported) {
            break;
          }
        default:
          console.error("Unsupported FourCC code:", Int32ToFourCC(fourCC));
          return;
      }
    }
    var rOffset = DDSTools2._ExtractLongWordOrder(header[off_RMask]);
    var gOffset = DDSTools2._ExtractLongWordOrder(header[off_GMask]);
    var bOffset = DDSTools2._ExtractLongWordOrder(header[off_BMask]);
    var aOffset = DDSTools2._ExtractLongWordOrder(header[off_AMask]);
    if (computeFormats) {
      internalCompressedFormat = engine._getRGBABufferInternalSizedFormat(info.textureType);
    }
    mipmapCount = 1;
    if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {
      mipmapCount = Math.max(1, header[off_mipmapCount]);
    }
    var startFace = currentFace || 0;
    for (var face = startFace; face < faces; face++) {
      width = header[off_width];
      height = header[off_height];
      for (mip = 0; mip < mipmapCount; ++mip) {
        if (lodIndex === -1 || lodIndex === mip) {
          var i = lodIndex === -1 ? mip : 0;
          if (!info.isCompressed && info.isFourCC) {
            texture.format = 5;
            dataLength = width * height * 4;
            var floatArray = null;
            if (engine._badOS || engine._badDesktopOS || !engine.getCaps().textureHalfFloat && !engine.getCaps().textureFloat) {
              if (bpp === 128) {
                floatArray = DDSTools2._GetFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);
                if (sphericalPolynomialFaces && i == 0) {
                  sphericalPolynomialFaces.push(DDSTools2._GetFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));
                }
              } else if (bpp === 64) {
                floatArray = DDSTools2._GetHalfFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);
                if (sphericalPolynomialFaces && i == 0) {
                  sphericalPolynomialFaces.push(DDSTools2._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));
                }
              }
              texture.type = 0;
            } else {
              if (bpp === 128) {
                texture.type = 1;
                floatArray = DDSTools2._GetFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);
                if (sphericalPolynomialFaces && i == 0) {
                  sphericalPolynomialFaces.push(floatArray);
                }
              } else if (bpp === 64 && !engine.getCaps().textureHalfFloat) {
                texture.type = 1;
                floatArray = DDSTools2._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);
                if (sphericalPolynomialFaces && i == 0) {
                  sphericalPolynomialFaces.push(floatArray);
                }
              } else {
                texture.type = 2;
                floatArray = DDSTools2._GetHalfFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);
                if (sphericalPolynomialFaces && i == 0) {
                  sphericalPolynomialFaces.push(DDSTools2._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, data.buffer, i));
                }
              }
            }
            if (floatArray) {
              engine._uploadDataToTextureDirectly(texture, floatArray, face, i);
            }
          } else if (info.isRGB) {
            texture.type = 0;
            if (bpp === 24) {
              texture.format = 4;
              dataLength = width * height * 3;
              byteArray = DDSTools2._GetRGBArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset);
              engine._uploadDataToTextureDirectly(texture, byteArray, face, i);
            } else {
              texture.format = 5;
              dataLength = width * height * 4;
              byteArray = DDSTools2._GetRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset, aOffset);
              engine._uploadDataToTextureDirectly(texture, byteArray, face, i);
            }
          } else if (info.isLuminance) {
            var unpackAlignment = engine._getUnpackAlignement();
            var unpaddedRowSize = width;
            var paddedRowSize = Math.floor((width + unpackAlignment - 1) / unpackAlignment) * unpackAlignment;
            dataLength = paddedRowSize * (height - 1) + unpaddedRowSize;
            byteArray = DDSTools2._GetLuminanceArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer);
            texture.format = 1;
            texture.type = 0;
            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);
          } else {
            dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;
            byteArray = new Uint8Array(data.buffer, data.byteOffset + dataOffset, dataLength);
            texture.type = 0;
            engine._uploadCompressedDataToTextureDirectly(texture, internalCompressedFormat, width, height, byteArray, face, i);
          }
        }
        dataOffset += bpp ? width * height * (bpp / 8) : dataLength;
        width *= 0.5;
        height *= 0.5;
        width = Math.max(1, width);
        height = Math.max(1, height);
      }
      if (currentFace !== void 0) {
        break;
      }
    }
    if (sphericalPolynomialFaces && sphericalPolynomialFaces.length > 0) {
      info.sphericalPolynomial = CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial({
        size: header[off_width],
        right: sphericalPolynomialFaces[0],
        left: sphericalPolynomialFaces[1],
        up: sphericalPolynomialFaces[2],
        down: sphericalPolynomialFaces[3],
        front: sphericalPolynomialFaces[4],
        back: sphericalPolynomialFaces[5],
        format: 5,
        type: 1,
        gammaSpace: false
      });
    } else {
      info.sphericalPolynomial = void 0;
    }
  };
  DDSTools2.StoreLODInAlphaChannel = false;
  return DDSTools2;
}();
ThinEngine.prototype.createPrefilteredCubeTexture = function(rootUrl, scene, lodScale, lodOffset, onLoad, onError, format, forcedExtension, createPolynomials) {
  var _this = this;
  if (onLoad === void 0) {
    onLoad = null;
  }
  if (onError === void 0) {
    onError = null;
  }
  if (forcedExtension === void 0) {
    forcedExtension = null;
  }
  if (createPolynomials === void 0) {
    createPolynomials = true;
  }
  var callback = function(loadData) {
    if (!loadData) {
      if (onLoad) {
        onLoad(null);
      }
      return;
    }
    var texture = loadData.texture;
    if (!createPolynomials) {
      texture._sphericalPolynomial = new SphericalPolynomial();
    } else if (loadData.info.sphericalPolynomial) {
      texture._sphericalPolynomial = loadData.info.sphericalPolynomial;
    }
    texture._source = InternalTextureSource.CubePrefiltered;
    if (_this.getCaps().textureLOD) {
      if (onLoad) {
        onLoad(texture);
      }
      return;
    }
    var mipSlices = 3;
    var gl = _this._gl;
    var width = loadData.width;
    if (!width) {
      return;
    }
    var textures = [];
    for (var i = 0; i < mipSlices; i++) {
      var smoothness = i / (mipSlices - 1);
      var roughness = 1 - smoothness;
      var minLODIndex = lodOffset;
      var maxLODIndex = Scalar.Log2(width) * lodScale + lodOffset;
      var lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;
      var mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));
      var glTextureFromLod = new InternalTexture(_this, InternalTextureSource.Temp);
      glTextureFromLod.type = texture.type;
      glTextureFromLod.format = texture.format;
      glTextureFromLod.width = Math.pow(2, Math.max(Scalar.Log2(width) - mipmapIndex, 0));
      glTextureFromLod.height = glTextureFromLod.width;
      glTextureFromLod.isCube = true;
      _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, glTextureFromLod, true);
      glTextureFromLod.samplingMode = 2;
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      if (loadData.isDDS) {
        var info = loadData.info;
        var data = loadData.data;
        _this._unpackFlipY(info.isCompressed);
        DDSTools.UploadDDSLevels(_this, glTextureFromLod, data, info, true, 6, mipmapIndex);
      } else {
        Logger.Warn("DDS is the only prefiltered cube map supported so far.");
      }
      _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
      var lodTexture = new BaseTexture(scene);
      lodTexture.isCube = true;
      lodTexture._texture = glTextureFromLod;
      glTextureFromLod.isReady = true;
      textures.push(lodTexture);
    }
    texture._lodTextureHigh = textures[2];
    texture._lodTextureMid = textures[1];
    texture._lodTextureLow = textures[0];
    if (onLoad) {
      onLoad(texture);
    }
  };
  return this.createCubeTexture(rootUrl, scene, null, false, callback, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset);
};

// node_modules/@babylonjs/core/Materials/Textures/Loaders/ddsTextureLoader.js
var _DDSTextureLoader = function() {
  function _DDSTextureLoader2() {
    this.supportCascades = true;
  }
  _DDSTextureLoader2.prototype.canLoad = function(extension) {
    return StringTools.EndsWith(extension, ".dds");
  };
  _DDSTextureLoader2.prototype.loadCubeData = function(imgs, texture, createPolynomials, onLoad, onError) {
    var engine = texture.getEngine();
    var info;
    var loadMipmap = false;
    if (Array.isArray(imgs)) {
      for (var index = 0; index < imgs.length; index++) {
        var data_1 = imgs[index];
        info = DDSTools.GetDDSInfo(data_1);
        texture.width = info.width;
        texture.height = info.height;
        loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps;
        engine._unpackFlipY(info.isCompressed);
        DDSTools.UploadDDSLevels(engine, texture, data_1, info, loadMipmap, 6, -1, index);
        if (!info.isFourCC && info.mipmapCount === 1) {
          engine.generateMipMapsForCubemap(texture);
        }
      }
    } else {
      var data = imgs;
      info = DDSTools.GetDDSInfo(data);
      texture.width = info.width;
      texture.height = info.height;
      if (createPolynomials) {
        info.sphericalPolynomial = new SphericalPolynomial();
      }
      loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps;
      engine._unpackFlipY(info.isCompressed);
      DDSTools.UploadDDSLevels(engine, texture, data, info, loadMipmap, 6);
      if (!info.isFourCC && info.mipmapCount === 1) {
        engine.generateMipMapsForCubemap(texture, false);
      }
    }
    engine._setCubeMapTextureParams(texture, loadMipmap);
    texture.isReady = true;
    texture.onLoadedObservable.notifyObservers(texture);
    texture.onLoadedObservable.clear();
    if (onLoad) {
      onLoad({ isDDS: true, width: texture.width, info, data: imgs, texture });
    }
  };
  _DDSTextureLoader2.prototype.loadData = function(data, texture, callback) {
    var info = DDSTools.GetDDSInfo(data);
    var loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps && info.width >> info.mipmapCount - 1 === 1;
    callback(info.width, info.height, loadMipmap, info.isFourCC, function() {
      DDSTools.UploadDDSLevels(texture.getEngine(), texture, data, info, loadMipmap, 1);
    });
  };
  return _DDSTextureLoader2;
}();
Engine._TextureLoaders.push(new _DDSTextureLoader());

// node_modules/@babylonjs/core/Materials/Textures/Loaders/envTextureLoader.js
var _ENVTextureLoader = function() {
  function _ENVTextureLoader2() {
    this.supportCascades = false;
  }
  _ENVTextureLoader2.prototype.canLoad = function(extension) {
    return StringTools.EndsWith(extension, ".env");
  };
  _ENVTextureLoader2.prototype.loadCubeData = function(data, texture, createPolynomials, onLoad, onError) {
    if (Array.isArray(data)) {
      return;
    }
    var info = EnvironmentTextureTools.GetEnvInfo(data);
    if (info) {
      texture.width = info.width;
      texture.height = info.width;
      EnvironmentTextureTools.UploadEnvSpherical(texture, info);
      EnvironmentTextureTools.UploadEnvLevelsAsync(texture, data, info).then(function() {
        texture.isReady = true;
        texture.onLoadedObservable.notifyObservers(texture);
        texture.onLoadedObservable.clear();
        if (onLoad) {
          onLoad();
        }
      });
    } else if (onError) {
      onError("Can not parse the environment file", null);
    }
  };
  _ENVTextureLoader2.prototype.loadData = function(data, texture, callback) {
    throw ".env not supported in 2d.";
  };
  return _ENVTextureLoader2;
}();
Engine._TextureLoaders.push(new _ENVTextureLoader());

// node_modules/@babylonjs/core/Misc/khronosTextureContainer.js
var KhronosTextureContainer = function() {
  function KhronosTextureContainer3(data, facesExpected, threeDExpected, textureArrayExpected) {
    this.data = data;
    this.isInvalid = false;
    if (!KhronosTextureContainer3.IsValid(data)) {
      this.isInvalid = true;
      Logger.Error("texture missing KTX identifier");
      return;
    }
    var dataSize = Uint32Array.BYTES_PER_ELEMENT;
    var headerDataView = new DataView(this.data.buffer, this.data.byteOffset + 12, 13 * dataSize);
    var endianness = headerDataView.getUint32(0, true);
    var littleEndian = endianness === 67305985;
    this.glType = headerDataView.getUint32(1 * dataSize, littleEndian);
    this.glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian);
    this.glFormat = headerDataView.getUint32(3 * dataSize, littleEndian);
    this.glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian);
    this.glBaseInternalFormat = headerDataView.getUint32(5 * dataSize, littleEndian);
    this.pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian);
    this.pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian);
    this.pixelDepth = headerDataView.getUint32(8 * dataSize, littleEndian);
    this.numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian);
    this.numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian);
    this.numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian);
    this.bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian);
    if (this.glType !== 0) {
      Logger.Error("only compressed formats currently supported");
      return;
    } else {
      this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels);
    }
    if (this.pixelHeight === 0 || this.pixelDepth !== 0) {
      Logger.Error("only 2D textures currently supported");
      return;
    }
    if (this.numberOfArrayElements !== 0) {
      Logger.Error("texture arrays not currently supported");
      return;
    }
    if (this.numberOfFaces !== facesExpected) {
      Logger.Error("number of faces expected" + facesExpected + ", but found " + this.numberOfFaces);
      return;
    }
    this.loadType = KhronosTextureContainer3.COMPRESSED_2D;
  }
  KhronosTextureContainer3.prototype.uploadLevels = function(texture, loadMipmaps) {
    switch (this.loadType) {
      case KhronosTextureContainer3.COMPRESSED_2D:
        this._upload2DCompressedLevels(texture, loadMipmaps);
        break;
      case KhronosTextureContainer3.TEX_2D:
      case KhronosTextureContainer3.COMPRESSED_3D:
      case KhronosTextureContainer3.TEX_3D:
    }
  };
  KhronosTextureContainer3.prototype._upload2DCompressedLevels = function(texture, loadMipmaps) {
    var dataOffset = KhronosTextureContainer3.HEADER_LEN + this.bytesOfKeyValueData;
    var width = this.pixelWidth;
    var height = this.pixelHeight;
    var mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;
    for (var level = 0; level < mipmapCount; level++) {
      var imageSize = new Int32Array(this.data.buffer, this.data.byteOffset + dataOffset, 1)[0];
      dataOffset += 4;
      for (var face = 0; face < this.numberOfFaces; face++) {
        var byteArray = new Uint8Array(this.data.buffer, this.data.byteOffset + dataOffset, imageSize);
        var engine = texture.getEngine();
        engine._uploadCompressedDataToTextureDirectly(texture, this.glInternalFormat, width, height, byteArray, face, level);
        dataOffset += imageSize;
        dataOffset += 3 - (imageSize + 3) % 4;
      }
      width = Math.max(1, width * 0.5);
      height = Math.max(1, height * 0.5);
    }
  };
  KhronosTextureContainer3.IsValid = function(data) {
    if (data.byteLength >= 12) {
      var identifier = new Uint8Array(data.buffer, data.byteOffset, 12);
      if (identifier[0] === 171 && identifier[1] === 75 && identifier[2] === 84 && identifier[3] === 88 && identifier[4] === 32 && identifier[5] === 49 && identifier[6] === 49 && identifier[7] === 187 && identifier[8] === 13 && identifier[9] === 10 && identifier[10] === 26 && identifier[11] === 10) {
        return true;
      }
    }
    return false;
  };
  KhronosTextureContainer3.HEADER_LEN = 12 + 13 * 4;
  KhronosTextureContainer3.COMPRESSED_2D = 0;
  KhronosTextureContainer3.COMPRESSED_3D = 1;
  KhronosTextureContainer3.TEX_2D = 2;
  KhronosTextureContainer3.TEX_3D = 3;
  return KhronosTextureContainer3;
}();

// node_modules/@babylonjs/core/Misc/khronosTextureContainer2.js
var KhronosTextureContainer2 = function() {
  function KhronosTextureContainer22(engine, numWorkers) {
    if (numWorkers === void 0) {
      numWorkers = KhronosTextureContainer22.DefaultNumWorkers;
    }
    this._engine = engine;
    if (!KhronosTextureContainer22._Initialized) {
      KhronosTextureContainer22._CreateWorkerPool(numWorkers);
    }
  }
  KhronosTextureContainer22.GetDefaultNumWorkers = function() {
    if (typeof navigator !== "object" || !navigator.hardwareConcurrency) {
      return 1;
    }
    return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);
  };
  KhronosTextureContainer22._CreateWorkerPool = function(numWorkers) {
    this._Initialized = true;
    if (numWorkers && typeof Worker === "function") {
      KhronosTextureContainer22._WorkerPoolPromise = new Promise(function(resolve) {
        var workerContent = "(" + workerFunc + ")()";
        var workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: "application/javascript" }));
        var workerPromises = new Array(numWorkers);
        for (var i = 0; i < workerPromises.length; i++) {
          workerPromises[i] = new Promise(function(resolve2, reject) {
            var worker = new Worker(workerBlobUrl);
            var onError = function(error) {
              worker.removeEventListener("error", onError);
              worker.removeEventListener("message", onMessage);
              reject(error);
            };
            var onMessage = function(message) {
              if (message.data.action === "init") {
                worker.removeEventListener("error", onError);
                worker.removeEventListener("message", onMessage);
                resolve2(worker);
              }
            };
            worker.addEventListener("error", onError);
            worker.addEventListener("message", onMessage);
            worker.postMessage({
              action: "init",
              urls: KhronosTextureContainer22.URLConfig
            });
          });
        }
        Promise.all(workerPromises).then(function(workers) {
          resolve(new WorkerPool(workers));
        });
      });
    } else {
      KTX2DECODER.MSCTranscoder.UseFromWorkerThread = false;
      KTX2DECODER.WASMMemoryManager.LoadBinariesFromCurrentThread = true;
    }
  };
  KhronosTextureContainer22.prototype.uploadAsync = function(data, internalTexture, options) {
    var _this = this;
    var caps = this._engine.getCaps();
    var compressedTexturesCaps = {
      astc: !!caps.astc,
      bptc: !!caps.bptc,
      s3tc: !!caps.s3tc,
      pvrtc: !!caps.pvrtc,
      etc2: !!caps.etc2,
      etc1: !!caps.etc1
    };
    if (KhronosTextureContainer22._WorkerPoolPromise) {
      return KhronosTextureContainer22._WorkerPoolPromise.then(function(workerPool) {
        return new Promise(function(resolve, reject) {
          workerPool.push(function(worker, onComplete) {
            var onError = function(error) {
              worker.removeEventListener("error", onError);
              worker.removeEventListener("message", onMessage);
              reject(error);
              onComplete();
            };
            var onMessage = function(message) {
              if (message.data.action === "decoded") {
                worker.removeEventListener("error", onError);
                worker.removeEventListener("message", onMessage);
                if (!message.data.success) {
                  reject({ message: message.data.msg });
                } else {
                  try {
                    _this._createTexture(message.data.decodedData, internalTexture, options);
                    resolve();
                  } catch (err) {
                    reject({ message: err });
                  }
                }
                onComplete();
              }
            };
            worker.addEventListener("error", onError);
            worker.addEventListener("message", onMessage);
            worker.postMessage({ action: "decode", data, caps: compressedTexturesCaps, options });
          });
        });
      });
    }
    return new Promise(function(resolve, reject) {
      if (!KhronosTextureContainer22._Ktx2Decoder) {
        KhronosTextureContainer22._Ktx2Decoder = new KTX2DECODER.KTX2Decoder();
      }
      KhronosTextureContainer22._Ktx2Decoder.decode(data, caps).then(function(data2) {
        _this._createTexture(data2, internalTexture);
        resolve();
      }).catch(function(reason) {
        reject({ message: reason });
      });
    });
  };
  KhronosTextureContainer22.prototype.dispose = function() {
    if (KhronosTextureContainer22._WorkerPoolPromise) {
      KhronosTextureContainer22._WorkerPoolPromise.then(function(workerPool) {
        workerPool.dispose();
      });
    }
    delete KhronosTextureContainer22._WorkerPoolPromise;
  };
  KhronosTextureContainer22.prototype._createTexture = function(data, internalTexture, options) {
    this._engine._bindTextureDirectly(this._engine._gl.TEXTURE_2D, internalTexture);
    if (options) {
      options.transcodedFormat = data.transcodedFormat;
      options.isInGammaSpace = data.isInGammaSpace;
      options.transcoderName = data.transcoderName;
    }
    if (data.transcodedFormat === 32856) {
      internalTexture.type = 0;
      internalTexture.format = 5;
    } else {
      internalTexture.format = data.transcodedFormat;
    }
    internalTexture._gammaSpace = data.isInGammaSpace;
    if (data.errors) {
      throw new Error("KTX2 container - could not transcode the data. " + data.errors);
    }
    for (var t = 0; t < data.mipmaps.length; ++t) {
      var mipmap = data.mipmaps[t];
      if (!mipmap || !mipmap.data) {
        throw new Error("KTX2 container - could not transcode one of the image");
      }
      if (data.transcodedFormat === 32856) {
        internalTexture.width = mipmap.width;
        internalTexture.height = mipmap.height;
        this._engine._uploadDataToTextureDirectly(internalTexture, mipmap.data, 0, t, void 0, true);
      } else {
        this._engine._uploadCompressedDataToTextureDirectly(internalTexture, data.transcodedFormat, mipmap.width, mipmap.height, mipmap.data, 0, t);
      }
    }
    internalTexture.width = data.mipmaps[0].width;
    internalTexture.height = data.mipmaps[0].height;
    internalTexture.generateMipMaps = data.mipmaps.length > 1;
    internalTexture.isReady = true;
    this._engine._bindTextureDirectly(this._engine._gl.TEXTURE_2D, null);
  };
  KhronosTextureContainer22.IsValid = function(data) {
    if (data.byteLength >= 12) {
      var identifier = new Uint8Array(data.buffer, data.byteOffset, 12);
      if (identifier[0] === 171 && identifier[1] === 75 && identifier[2] === 84 && identifier[3] === 88 && identifier[4] === 32 && identifier[5] === 50 && identifier[6] === 48 && identifier[7] === 187 && identifier[8] === 13 && identifier[9] === 10 && identifier[10] === 26 && identifier[11] === 10) {
        return true;
      }
    }
    return false;
  };
  KhronosTextureContainer22.URLConfig = {
    jsDecoderModule: "https://preview.babylonjs.com/babylon.ktx2Decoder.js",
    wasmUASTCToASTC: null,
    wasmUASTCToBC7: null,
    wasmUASTCToRGBA_UNORM: null,
    wasmUASTCToRGBA_SRGB: null,
    jsMSCTranscoder: null,
    wasmMSCTranscoder: null
  };
  KhronosTextureContainer22.DefaultNumWorkers = KhronosTextureContainer22.GetDefaultNumWorkers();
  return KhronosTextureContainer22;
}();
function workerFunc() {
  var ktx2Decoder;
  onmessage = function(event) {
    switch (event.data.action) {
      case "init":
        var urls = event.data.urls;
        importScripts(urls.jsDecoderModule);
        if (urls.wasmUASTCToASTC !== null) {
          KTX2DECODER.LiteTranscoder_UASTC_ASTC.WasmModuleURL = urls.wasmUASTCToASTC;
        }
        if (urls.wasmUASTCToBC7 !== null) {
          KTX2DECODER.LiteTranscoder_UASTC_BC7.WasmModuleURL = urls.wasmUASTCToBC7;
        }
        if (urls.wasmUASTCToRGBA_UNORM !== null) {
          KTX2DECODER.LiteTranscoder_UASTC_RGBA_UNORM.WasmModuleURL = urls.wasmUASTCToRGBA_UNORM;
        }
        if (urls.wasmUASTCToRGBA_SRGB !== null) {
          KTX2DECODER.LiteTranscoder_UASTC_RGBA_SRGB.WasmModuleURL = urls.wasmUASTCToRGBA_SRGB;
        }
        if (urls.jsMSCTranscoder !== null) {
          KTX2DECODER.MSCTranscoder.JSModuleURL = urls.jsMSCTranscoder;
        }
        if (urls.wasmMSCTranscoder !== null) {
          KTX2DECODER.MSCTranscoder.WasmModuleURL = urls.wasmMSCTranscoder;
        }
        ktx2Decoder = new KTX2DECODER.KTX2Decoder();
        postMessage({ action: "init" });
        break;
      case "decode":
        ktx2Decoder.decode(event.data.data, event.data.caps, event.data.options).then(function(data) {
          var buffers = [];
          for (var mip = 0; mip < data.mipmaps.length; ++mip) {
            var mipmap = data.mipmaps[mip];
            if (mipmap && mipmap.data) {
              buffers.push(mipmap.data.buffer);
            }
          }
          postMessage({ action: "decoded", success: true, decodedData: data }, buffers);
        }).catch(function(reason) {
          postMessage({ action: "decoded", success: false, msg: reason });
        });
        break;
    }
  };
}

// node_modules/@babylonjs/core/Materials/Textures/Loaders/ktxTextureLoader.js
var _KTXTextureLoader = function() {
  function _KTXTextureLoader2() {
    this.supportCascades = false;
  }
  _KTXTextureLoader2.prototype.canLoad = function(extension, mimeType) {
    return StringTools.EndsWith(extension, ".ktx") || StringTools.EndsWith(extension, ".ktx2") || mimeType === "image/ktx" || mimeType === "image/ktx2";
  };
  _KTXTextureLoader2.prototype.loadCubeData = function(data, texture, createPolynomials, onLoad, onError) {
    if (Array.isArray(data)) {
      return;
    }
    texture._invertVScale = !texture.invertY;
    var engine = texture.getEngine();
    var ktx = new KhronosTextureContainer(data, 6);
    var loadMipmap = ktx.numberOfMipmapLevels > 1 && texture.generateMipMaps;
    engine._unpackFlipY(true);
    ktx.uploadLevels(texture, texture.generateMipMaps);
    texture.width = ktx.pixelWidth;
    texture.height = ktx.pixelHeight;
    engine._setCubeMapTextureParams(texture, loadMipmap);
    texture.isReady = true;
    texture.onLoadedObservable.notifyObservers(texture);
    texture.onLoadedObservable.clear();
    if (onLoad) {
      onLoad();
    }
  };
  _KTXTextureLoader2.prototype.loadData = function(data, texture, callback, options) {
    if (KhronosTextureContainer.IsValid(data)) {
      texture._invertVScale = !texture.invertY;
      var ktx_1 = new KhronosTextureContainer(data, 1);
      callback(ktx_1.pixelWidth, ktx_1.pixelHeight, texture.generateMipMaps, true, function() {
        ktx_1.uploadLevels(texture, texture.generateMipMaps);
      }, ktx_1.isInvalid);
    } else if (KhronosTextureContainer2.IsValid(data)) {
      var ktx2 = new KhronosTextureContainer2(texture.getEngine());
      ktx2.uploadAsync(data, texture, options).then(function() {
        callback(texture.width, texture.height, texture.generateMipMaps, true, function() {
        }, false);
      }, function(error) {
        Logger.Warn("Failed to load KTX2 texture data: " + error.message);
        callback(0, 0, false, false, function() {
        }, true);
      });
    } else {
      Logger.Error("texture missing KTX identifier");
      callback(0, 0, false, false, function() {
      }, true);
    }
  };
  return _KTXTextureLoader2;
}();
Engine._TextureLoaders.unshift(new _KTXTextureLoader());

// node_modules/@babylonjs/core/XR/webXRCamera.js
var WebXRCamera = function(_super) {
  __extends(WebXRCamera2, _super);
  function WebXRCamera2(name98, scene, _xrSessionManager) {
    var _this = _super.call(this, name98, Vector3.Zero(), scene) || this;
    _this._xrSessionManager = _xrSessionManager;
    _this._firstFrame = false;
    _this._referenceQuaternion = Quaternion.Identity();
    _this._referencedPosition = new Vector3();
    _this._xrInvPositionCache = new Vector3();
    _this._xrInvQuaternionCache = Quaternion.Identity();
    _this._trackingState = WebXRTrackingState.NOT_TRACKING;
    _this.onBeforeCameraTeleport = new Observable();
    _this.onAfterCameraTeleport = new Observable();
    _this.onTrackingStateChanged = new Observable();
    _this.compensateOnFirstFrame = true;
    _this._rotate180 = new Quaternion(0, 1, 0, 0);
    _this.minZ = 0.1;
    _this.rotationQuaternion = new Quaternion();
    _this.cameraRigMode = Camera.RIG_MODE_CUSTOM;
    _this.updateUpVectorFromRotation = true;
    _this._updateNumberOfRigCameras(1);
    _this.freezeProjectionMatrix();
    _this._xrSessionManager.onXRSessionInit.add(function() {
      _this._referencedPosition.copyFromFloats(0, 0, 0);
      _this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);
      _this._firstFrame = _this.compensateOnFirstFrame;
    });
    _this._xrSessionManager.onXRFrameObservable.add(function(frame) {
      if (_this._firstFrame) {
        _this._updateFromXRSession();
      }
      _this._updateReferenceSpace();
      _this._updateFromXRSession();
    }, void 0, true);
    return _this;
  }
  Object.defineProperty(WebXRCamera2.prototype, "trackingState", {
    get: function() {
      return this._trackingState;
    },
    enumerable: false,
    configurable: true
  });
  WebXRCamera2.prototype._setTrackingState = function(newState) {
    if (this._trackingState !== newState) {
      this._trackingState = newState;
      this.onTrackingStateChanged.notifyObservers(newState);
    }
  };
  Object.defineProperty(WebXRCamera2.prototype, "realWorldHeight", {
    get: function() {
      var basePose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.baseReferenceSpace);
      if (basePose && basePose.transform) {
        return basePose.transform.position.y;
      } else {
        return 0;
      }
    },
    enumerable: false,
    configurable: true
  });
  WebXRCamera2.prototype._updateForDualEyeDebugging = function() {
    this._updateNumberOfRigCameras(2);
    this.rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1);
    this.rigCameras[0].outputRenderTarget = null;
    this.rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1);
    this.rigCameras[1].outputRenderTarget = null;
  };
  WebXRCamera2.prototype.setTransformationFromNonVRCamera = function(otherCamera, resetToBaseReferenceSpace) {
    if (otherCamera === void 0) {
      otherCamera = this.getScene().activeCamera;
    }
    if (resetToBaseReferenceSpace === void 0) {
      resetToBaseReferenceSpace = true;
    }
    if (!otherCamera || otherCamera === this) {
      return;
    }
    var mat = otherCamera.computeWorldMatrix();
    mat.decompose(void 0, this.rotationQuaternion, this.position);
    this.position.y = 0;
    Quaternion.FromEulerAnglesToRef(0, this.rotationQuaternion.toEulerAngles().y, 0, this.rotationQuaternion);
    this._firstFrame = true;
    if (resetToBaseReferenceSpace) {
      this._xrSessionManager.resetReferenceSpace();
    }
  };
  WebXRCamera2.prototype.getClassName = function() {
    return "WebXRCamera";
  };
  WebXRCamera2.prototype._updateFromXRSession = function() {
    var _this = this;
    var pose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.referenceSpace);
    if (!pose) {
      this._setTrackingState(WebXRTrackingState.NOT_TRACKING);
      return;
    }
    var trackingState = pose.emulatedPosition ? WebXRTrackingState.TRACKING_LOST : WebXRTrackingState.TRACKING;
    this._setTrackingState(trackingState);
    if (pose.transform) {
      var pos = pose.transform.position;
      this._referencedPosition.set(pos.x, pos.y, pos.z);
      var orientation_1 = pose.transform.orientation;
      this._referenceQuaternion.set(orientation_1.x, orientation_1.y, orientation_1.z, orientation_1.w);
      if (!this._scene.useRightHandedSystem) {
        this._referencedPosition.z *= -1;
        this._referenceQuaternion.z *= -1;
        this._referenceQuaternion.w *= -1;
      }
      if (this._firstFrame) {
        this._firstFrame = false;
        this.position.y += this._referencedPosition.y;
        this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);
      } else {
        this.rotationQuaternion.copyFrom(this._referenceQuaternion);
        this.position.copyFrom(this._referencedPosition);
      }
    }
    if (this.rigCameras.length !== pose.views.length) {
      this._updateNumberOfRigCameras(pose.views.length);
    }
    pose.views.forEach(function(view, i) {
      var currentRig = _this.rigCameras[i];
      if (!currentRig.isLeftCamera && !currentRig.isRightCamera) {
        if (view.eye === "right") {
          currentRig._isRightCamera = true;
        } else if (view.eye === "left") {
          currentRig._isLeftCamera = true;
        }
      }
      var pos2 = view.transform.position;
      var orientation = view.transform.orientation;
      currentRig.position.set(pos2.x, pos2.y, pos2.z);
      currentRig.rotationQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);
      if (!_this._scene.useRightHandedSystem) {
        currentRig.position.z *= -1;
        currentRig.rotationQuaternion.z *= -1;
        currentRig.rotationQuaternion.w *= -1;
      } else {
        currentRig.rotationQuaternion.multiplyInPlace(_this._rotate180);
      }
      Matrix.FromFloat32ArrayToRefScaled(view.projectionMatrix, 0, 1, currentRig._projectionMatrix);
      if (!_this._scene.useRightHandedSystem) {
        currentRig._projectionMatrix.toggleProjectionMatrixHandInPlace();
      }
      if (i === 0) {
        _this._projectionMatrix.copyFrom(currentRig._projectionMatrix);
      }
      if (_this._xrSessionManager.session.renderState.baseLayer) {
        var viewport = _this._xrSessionManager.session.renderState.baseLayer.getViewport(view);
        var width = _this._xrSessionManager.session.renderState.baseLayer.framebufferWidth;
        var height = _this._xrSessionManager.session.renderState.baseLayer.framebufferHeight;
        currentRig.viewport.width = viewport.width / width;
        currentRig.viewport.height = viewport.height / height;
        currentRig.viewport.x = viewport.x / width;
        currentRig.viewport.y = viewport.y / height;
      }
      currentRig.outputRenderTarget = _this._xrSessionManager.getRenderTargetTextureForEye(view.eye);
    });
  };
  WebXRCamera2.prototype._updateNumberOfRigCameras = function(viewCount) {
    if (viewCount === void 0) {
      viewCount = 1;
    }
    while (this.rigCameras.length < viewCount) {
      var newCamera = new TargetCamera("XR-RigCamera: " + this.rigCameras.length, Vector3.Zero(), this.getScene());
      newCamera.minZ = 0.1;
      newCamera.rotationQuaternion = new Quaternion();
      newCamera.updateUpVectorFromRotation = true;
      newCamera.isRigCamera = true;
      newCamera.rigParent = this;
      newCamera.freezeProjectionMatrix();
      this.rigCameras.push(newCamera);
    }
    while (this.rigCameras.length > viewCount) {
      var removedCamera = this.rigCameras.pop();
      if (removedCamera) {
        removedCamera.dispose();
      }
    }
  };
  WebXRCamera2.prototype._updateReferenceSpace = function() {
    if (!this.position.equals(this._referencedPosition) || !this.rotationQuaternion.equals(this._referenceQuaternion)) {
      this.position.subtractToRef(this._referencedPosition, this._referencedPosition);
      this._referenceQuaternion.conjugateInPlace();
      this._referenceQuaternion.multiplyToRef(this.rotationQuaternion, this._referenceQuaternion);
      this._updateReferenceSpaceOffset(this._referencedPosition, this._referenceQuaternion.normalize());
    }
  };
  WebXRCamera2.prototype._updateReferenceSpaceOffset = function(positionOffset, rotationOffset, ignoreHeight) {
    if (ignoreHeight === void 0) {
      ignoreHeight = false;
    }
    if (!this._xrSessionManager.referenceSpace || !this._xrSessionManager.currentFrame) {
      return;
    }
    this._xrInvPositionCache.copyFrom(positionOffset);
    if (rotationOffset) {
      this._xrInvQuaternionCache.copyFrom(rotationOffset);
    } else {
      this._xrInvQuaternionCache.copyFromFloats(0, 0, 0, 1);
    }
    if (!this._scene.useRightHandedSystem) {
      this._xrInvPositionCache.z *= -1;
      this._xrInvQuaternionCache.z *= -1;
      this._xrInvQuaternionCache.w *= -1;
    }
    this._xrInvPositionCache.negateInPlace();
    this._xrInvQuaternionCache.conjugateInPlace();
    this._xrInvPositionCache.rotateByQuaternionToRef(this._xrInvQuaternionCache, this._xrInvPositionCache);
    if (ignoreHeight) {
      this._xrInvPositionCache.y = 0;
    }
    var transform = new XRRigidTransform({ x: this._xrInvPositionCache.x, y: this._xrInvPositionCache.y, z: this._xrInvPositionCache.z }, { x: this._xrInvQuaternionCache.x, y: this._xrInvQuaternionCache.y, z: this._xrInvQuaternionCache.z, w: this._xrInvQuaternionCache.w });
    var referenceSpace = this._xrSessionManager.referenceSpace.getOffsetReferenceSpace(transform);
    var pose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(referenceSpace);
    if (pose) {
      var pos = new Vector3(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z);
      if (!this._scene.useRightHandedSystem) {
        pos.z *= -1;
      }
      this.position.subtractToRef(pos, pos);
      if (!this._scene.useRightHandedSystem) {
        pos.z *= -1;
      }
      pos.negateInPlace();
      var transform2 = new XRRigidTransform({ x: pos.x, y: pos.y, z: pos.z });
      this._xrSessionManager.referenceSpace = referenceSpace.getOffsetReferenceSpace(transform2);
    }
  };
  return WebXRCamera2;
}(FreeCamera);

// node_modules/@babylonjs/core/XR/webXRFeaturesManager.js
var WebXRFeatureName = function() {
  function WebXRFeatureName2() {
  }
  WebXRFeatureName2.ANCHOR_SYSTEM = "xr-anchor-system";
  WebXRFeatureName2.BACKGROUND_REMOVER = "xr-background-remover";
  WebXRFeatureName2.HIT_TEST = "xr-hit-test";
  WebXRFeatureName2.PHYSICS_CONTROLLERS = "xr-physics-controller";
  WebXRFeatureName2.PLANE_DETECTION = "xr-plane-detection";
  WebXRFeatureName2.POINTER_SELECTION = "xr-controller-pointer-selection";
  WebXRFeatureName2.TELEPORTATION = "xr-controller-teleportation";
  WebXRFeatureName2.FEATURE_POINTS = "xr-feature-points";
  WebXRFeatureName2.HAND_TRACKING = "xr-hand-tracking";
  return WebXRFeatureName2;
}();
var WebXRFeaturesManager = function() {
  function WebXRFeaturesManager2(_xrSessionManager) {
    var _this = this;
    this._xrSessionManager = _xrSessionManager;
    this._features = {};
    this._xrSessionManager.onXRSessionInit.add(function() {
      _this.getEnabledFeatures().forEach(function(featureName) {
        var feature = _this._features[featureName];
        if (feature.enabled && !feature.featureImplementation.attached && !feature.featureImplementation.disableAutoAttach) {
          _this.attachFeature(featureName);
        }
      });
    });
    this._xrSessionManager.onXRSessionEnded.add(function() {
      _this.getEnabledFeatures().forEach(function(featureName) {
        var feature = _this._features[featureName];
        if (feature.enabled && feature.featureImplementation.attached) {
          _this.detachFeature(featureName);
        }
      });
    });
  }
  WebXRFeaturesManager2.AddWebXRFeature = function(featureName, constructorFunction, version, stable) {
    if (version === void 0) {
      version = 1;
    }
    if (stable === void 0) {
      stable = false;
    }
    this._AvailableFeatures[featureName] = this._AvailableFeatures[featureName] || { latest: version };
    if (version > this._AvailableFeatures[featureName].latest) {
      this._AvailableFeatures[featureName].latest = version;
    }
    if (stable) {
      this._AvailableFeatures[featureName].stable = version;
    }
    this._AvailableFeatures[featureName][version] = constructorFunction;
  };
  WebXRFeaturesManager2.ConstructFeature = function(featureName, version, xrSessionManager, options) {
    if (version === void 0) {
      version = 1;
    }
    var constructorFunction = this._AvailableFeatures[featureName][version];
    if (!constructorFunction) {
      throw new Error("feature not found");
    }
    return constructorFunction(xrSessionManager, options);
  };
  WebXRFeaturesManager2.GetAvailableFeatures = function() {
    return Object.keys(this._AvailableFeatures);
  };
  WebXRFeaturesManager2.GetAvailableVersions = function(featureName) {
    return Object.keys(this._AvailableFeatures[featureName]);
  };
  WebXRFeaturesManager2.GetLatestVersionOfFeature = function(featureName) {
    return this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].latest || -1;
  };
  WebXRFeaturesManager2.GetStableVersionOfFeature = function(featureName) {
    return this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].stable || -1;
  };
  WebXRFeaturesManager2.prototype.attachFeature = function(featureName) {
    var feature = this._features[featureName];
    if (feature && feature.enabled && !feature.featureImplementation.attached) {
      feature.featureImplementation.attach();
    }
  };
  WebXRFeaturesManager2.prototype.detachFeature = function(featureName) {
    var feature = this._features[featureName];
    if (feature && feature.featureImplementation.attached) {
      feature.featureImplementation.detach();
    }
  };
  WebXRFeaturesManager2.prototype.disableFeature = function(featureName) {
    var name98 = typeof featureName === "string" ? featureName : featureName.Name;
    var feature = this._features[name98];
    if (feature && feature.enabled) {
      feature.enabled = false;
      this.detachFeature(name98);
      feature.featureImplementation.dispose();
      return true;
    }
    return false;
  };
  WebXRFeaturesManager2.prototype.dispose = function() {
    var _this = this;
    this.getEnabledFeatures().forEach(function(feature) {
      _this.disableFeature(feature);
      _this._features[feature].featureImplementation.dispose();
    });
  };
  WebXRFeaturesManager2.prototype.enableFeature = function(featureName, version, moduleOptions, attachIfPossible, required) {
    var _this = this;
    if (version === void 0) {
      version = "latest";
    }
    if (moduleOptions === void 0) {
      moduleOptions = {};
    }
    if (attachIfPossible === void 0) {
      attachIfPossible = true;
    }
    if (required === void 0) {
      required = true;
    }
    var name98 = typeof featureName === "string" ? featureName : featureName.Name;
    var versionToLoad = 0;
    if (typeof version === "string") {
      if (!version) {
        throw new Error("Error in provided version - " + name98 + " (" + version + ")");
      }
      if (version === "stable") {
        versionToLoad = WebXRFeaturesManager2.GetStableVersionOfFeature(name98);
      } else if (version === "latest") {
        versionToLoad = WebXRFeaturesManager2.GetLatestVersionOfFeature(name98);
      } else {
        versionToLoad = +version;
      }
      if (versionToLoad === -1 || isNaN(versionToLoad)) {
        throw new Error("feature not found - " + name98 + " (" + version + ")");
      }
    } else {
      versionToLoad = version;
    }
    var feature = this._features[name98];
    var constructFunction = WebXRFeaturesManager2.ConstructFeature(name98, versionToLoad, this._xrSessionManager, moduleOptions);
    if (!constructFunction) {
      throw new Error("feature not found - " + name98);
    }
    if (feature) {
      this.disableFeature(name98);
    }
    var constructed = constructFunction();
    if (constructed.dependsOn) {
      var dependentsFound = constructed.dependsOn.every(function(featureName2) {
        return !!_this._features[featureName2];
      });
      if (!dependentsFound) {
        throw new Error("Dependant features missing. Make sure the following features are enabled - " + constructed.dependsOn.join(", "));
      }
    }
    if (constructed.isCompatible()) {
      this._features[name98] = {
        featureImplementation: constructed,
        enabled: true,
        version: versionToLoad,
        required
      };
      if (attachIfPossible) {
        if (this._xrSessionManager.session && !this._features[name98].featureImplementation.attached) {
          this.attachFeature(name98);
        }
      } else {
        this._features[name98].featureImplementation.disableAutoAttach = true;
      }
      return this._features[name98].featureImplementation;
    } else {
      if (required) {
        throw new Error("required feature not compatible");
      } else {
        Tools.Warn("Feature " + name98 + " not compatible with the current environment/browser and was not enabled.");
        return constructed;
      }
    }
  };
  WebXRFeaturesManager2.prototype.getEnabledFeature = function(featureName) {
    return this._features[featureName] && this._features[featureName].featureImplementation;
  };
  WebXRFeaturesManager2.prototype.getEnabledFeatures = function() {
    return Object.keys(this._features);
  };
  WebXRFeaturesManager2.prototype.extendXRSessionInitObject = function(xrSessionInit) {
    var _this = this;
    var enabledFeatures = this.getEnabledFeatures();
    enabledFeatures.forEach(function(featureName) {
      var feature = _this._features[featureName];
      var nativeName = feature.featureImplementation.xrNativeFeatureName;
      if (nativeName) {
        if (feature.required) {
          xrSessionInit.requiredFeatures = xrSessionInit.requiredFeatures || [];
          if (xrSessionInit.requiredFeatures.indexOf(nativeName) === -1) {
            xrSessionInit.requiredFeatures.push(nativeName);
          }
        } else {
          xrSessionInit.optionalFeatures = xrSessionInit.optionalFeatures || [];
          if (xrSessionInit.optionalFeatures.indexOf(nativeName) === -1) {
            xrSessionInit.optionalFeatures.push(nativeName);
          }
        }
      }
    });
    return xrSessionInit;
  };
  WebXRFeaturesManager2._AvailableFeatures = {};
  return WebXRFeaturesManager2;
}();

// node_modules/@babylonjs/core/XR/webXRExperienceHelper.js
var WebXRExperienceHelper = function() {
  function WebXRExperienceHelper2(scene) {
    var _this = this;
    this.scene = scene;
    this._nonVRCamera = null;
    this._originalSceneAutoClear = true;
    this._supported = false;
    this.onInitialXRPoseSetObservable = new Observable();
    this.onStateChangedObservable = new Observable();
    this.state = WebXRState.NOT_IN_XR;
    this.sessionManager = new WebXRSessionManager(scene);
    this.camera = new WebXRCamera("", scene, this.sessionManager);
    this.featuresManager = new WebXRFeaturesManager(this.sessionManager);
    scene.onDisposeObservable.add(function() {
      _this.exitXRAsync();
    });
  }
  WebXRExperienceHelper2.CreateAsync = function(scene) {
    var helper = new WebXRExperienceHelper2(scene);
    return helper.sessionManager.initializeAsync().then(function() {
      helper._supported = true;
      return helper;
    }).catch(function(e) {
      helper._setState(WebXRState.NOT_IN_XR);
      helper.dispose();
      throw e;
    });
  };
  WebXRExperienceHelper2.prototype.dispose = function() {
    this.camera.dispose();
    this.onStateChangedObservable.clear();
    this.onInitialXRPoseSetObservable.clear();
    this.sessionManager.dispose();
    if (this._nonVRCamera) {
      this.scene.activeCamera = this._nonVRCamera;
    }
  };
  WebXRExperienceHelper2.prototype.enterXRAsync = function(sessionMode, referenceSpaceType, renderTarget, sessionCreationOptions) {
    var _this = this;
    if (renderTarget === void 0) {
      renderTarget = this.sessionManager.getWebXRRenderTarget();
    }
    if (sessionCreationOptions === void 0) {
      sessionCreationOptions = {};
    }
    if (!this._supported) {
      throw "WebXR not supported in this browser or environment";
    }
    this._setState(WebXRState.ENTERING_XR);
    if (referenceSpaceType !== "viewer" && referenceSpaceType !== "local") {
      sessionCreationOptions.optionalFeatures = sessionCreationOptions.optionalFeatures || [];
      sessionCreationOptions.optionalFeatures.push(referenceSpaceType);
    }
    this.featuresManager.extendXRSessionInitObject(sessionCreationOptions);
    if (sessionMode === "immersive-ar" && referenceSpaceType !== "unbounded") {
      Logger.Warn("We recommend using 'unbounded' reference space type when using 'immersive-ar' session mode");
    }
    return this.sessionManager.initializeSessionAsync(sessionMode, sessionCreationOptions).then(function() {
      return _this.sessionManager.setReferenceSpaceTypeAsync(referenceSpaceType);
    }).then(function() {
      return renderTarget.initializeXRLayerAsync(_this.sessionManager.session);
    }).then(function() {
      return _this.sessionManager.updateRenderStateAsync({
        depthFar: _this.camera.maxZ,
        depthNear: _this.camera.minZ,
        baseLayer: renderTarget.xrLayer
      });
    }).then(function() {
      _this.sessionManager.runXRRenderLoop();
      _this._originalSceneAutoClear = _this.scene.autoClear;
      _this._nonVRCamera = _this.scene.activeCamera;
      _this.scene.activeCamera = _this.camera;
      if (sessionMode !== "immersive-ar") {
        _this._nonXRToXRCamera();
      } else {
        _this.scene.autoClear = false;
        _this.camera.compensateOnFirstFrame = false;
      }
      _this.sessionManager.onXRSessionEnded.addOnce(function() {
        _this.camera.rigCameras.forEach(function(c) {
          c.outputRenderTarget = null;
        });
        _this.scene.autoClear = _this._originalSceneAutoClear;
        _this.scene.activeCamera = _this._nonVRCamera;
        if (sessionMode !== "immersive-ar" && _this.camera.compensateOnFirstFrame) {
          if (_this._nonVRCamera.setPosition) {
            _this._nonVRCamera.setPosition(_this.camera.position);
          } else {
            _this._nonVRCamera.position.copyFrom(_this.camera.position);
          }
        }
        _this._setState(WebXRState.NOT_IN_XR);
      });
      _this.sessionManager.onXRFrameObservable.addOnce(function() {
        _this._setState(WebXRState.IN_XR);
      });
      return _this.sessionManager;
    }).catch(function(e) {
      console.log(e);
      console.log(e.message);
      _this._setState(WebXRState.NOT_IN_XR);
      throw e;
    });
  };
  WebXRExperienceHelper2.prototype.exitXRAsync = function() {
    if (this.state !== WebXRState.IN_XR) {
      return Promise.resolve();
    }
    this._setState(WebXRState.EXITING_XR);
    return this.sessionManager.exitXRAsync();
  };
  WebXRExperienceHelper2.prototype._nonXRToXRCamera = function() {
    this.camera.setTransformationFromNonVRCamera(this._nonVRCamera);
    this.onInitialXRPoseSetObservable.notifyObservers(this.camera);
  };
  WebXRExperienceHelper2.prototype._setState = function(val) {
    if (this.state === val) {
      return;
    }
    this.state = val;
    this.onStateChangedObservable.notifyObservers(this.state);
  };
  return WebXRExperienceHelper2;
}();

// node_modules/@babylonjs/core/XR/motionController/webXRControllerComponent.js
var WebXRControllerComponent = function() {
  function WebXRControllerComponent2(id, type, _buttonIndex, _axesIndices) {
    if (_buttonIndex === void 0) {
      _buttonIndex = -1;
    }
    if (_axesIndices === void 0) {
      _axesIndices = [];
    }
    this.id = id;
    this.type = type;
    this._buttonIndex = _buttonIndex;
    this._axesIndices = _axesIndices;
    this._axes = {
      x: 0,
      y: 0
    };
    this._changes = {};
    this._currentValue = 0;
    this._hasChanges = false;
    this._pressed = false;
    this._touched = false;
    this.onAxisValueChangedObservable = new Observable();
    this.onButtonStateChangedObservable = new Observable();
  }
  Object.defineProperty(WebXRControllerComponent2.prototype, "axes", {
    get: function() {
      return this._axes;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebXRControllerComponent2.prototype, "changes", {
    get: function() {
      return this._changes;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebXRControllerComponent2.prototype, "hasChanges", {
    get: function() {
      return this._hasChanges;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebXRControllerComponent2.prototype, "pressed", {
    get: function() {
      return this._pressed;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebXRControllerComponent2.prototype, "touched", {
    get: function() {
      return this._touched;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebXRControllerComponent2.prototype, "value", {
    get: function() {
      return this._currentValue;
    },
    enumerable: false,
    configurable: true
  });
  WebXRControllerComponent2.prototype.dispose = function() {
    this.onAxisValueChangedObservable.clear();
    this.onButtonStateChangedObservable.clear();
  };
  WebXRControllerComponent2.prototype.isAxes = function() {
    return this._axesIndices.length !== 0;
  };
  WebXRControllerComponent2.prototype.isButton = function() {
    return this._buttonIndex !== -1;
  };
  WebXRControllerComponent2.prototype.update = function(nativeController) {
    var buttonUpdated = false;
    var axesUpdate = false;
    this._hasChanges = false;
    this._changes = {};
    if (this.isButton()) {
      var button = nativeController.buttons[this._buttonIndex];
      if (!button) {
        return;
      }
      if (this._currentValue !== button.value) {
        this.changes.value = {
          current: button.value,
          previous: this._currentValue
        };
        buttonUpdated = true;
        this._currentValue = button.value;
      }
      if (this._touched !== button.touched) {
        this.changes.touched = {
          current: button.touched,
          previous: this._touched
        };
        buttonUpdated = true;
        this._touched = button.touched;
      }
      if (this._pressed !== button.pressed) {
        this.changes.pressed = {
          current: button.pressed,
          previous: this._pressed
        };
        buttonUpdated = true;
        this._pressed = button.pressed;
      }
    }
    if (this.isAxes()) {
      if (this._axes.x !== nativeController.axes[this._axesIndices[0]]) {
        this.changes.axes = {
          current: {
            x: nativeController.axes[this._axesIndices[0]],
            y: this._axes.y
          },
          previous: {
            x: this._axes.x,
            y: this._axes.y
          }
        };
        this._axes.x = nativeController.axes[this._axesIndices[0]];
        axesUpdate = true;
      }
      if (this._axes.y !== nativeController.axes[this._axesIndices[1]]) {
        if (this.changes.axes) {
          this.changes.axes.current.y = nativeController.axes[this._axesIndices[1]];
        } else {
          this.changes.axes = {
            current: {
              x: this._axes.x,
              y: nativeController.axes[this._axesIndices[1]]
            },
            previous: {
              x: this._axes.x,
              y: this._axes.y
            }
          };
        }
        this._axes.y = nativeController.axes[this._axesIndices[1]];
        axesUpdate = true;
      }
    }
    if (buttonUpdated) {
      this._hasChanges = true;
      this.onButtonStateChangedObservable.notifyObservers(this);
    }
    if (axesUpdate) {
      this._hasChanges = true;
      this.onAxisValueChangedObservable.notifyObservers(this._axes);
    }
  };
  WebXRControllerComponent2.BUTTON_TYPE = "button";
  WebXRControllerComponent2.SQUEEZE_TYPE = "squeeze";
  WebXRControllerComponent2.THUMBSTICK_TYPE = "thumbstick";
  WebXRControllerComponent2.TOUCHPAD_TYPE = "touchpad";
  WebXRControllerComponent2.TRIGGER_TYPE = "trigger";
  return WebXRControllerComponent2;
}();

// node_modules/@babylonjs/core/XR/motionController/webXRAbstractMotionController.js
var WebXRAbstractMotionController = function() {
  function WebXRAbstractMotionController2(scene, layout, gamepadObject, handedness, _doNotLoadControllerMesh) {
    var _this = this;
    if (_doNotLoadControllerMesh === void 0) {
      _doNotLoadControllerMesh = false;
    }
    this.scene = scene;
    this.layout = layout;
    this.gamepadObject = gamepadObject;
    this.handedness = handedness;
    this._initComponent = function(id) {
      if (!id) {
        return;
      }
      var componentDef = _this.layout.components[id];
      var type = componentDef.type;
      var buttonIndex = componentDef.gamepadIndices.button;
      var axes = [];
      if (componentDef.gamepadIndices.xAxis !== void 0 && componentDef.gamepadIndices.yAxis !== void 0) {
        axes.push(componentDef.gamepadIndices.xAxis, componentDef.gamepadIndices.yAxis);
      }
      _this.components[id] = new WebXRControllerComponent(id, type, buttonIndex, axes);
    };
    this._modelReady = false;
    this.components = {};
    this.disableAnimation = false;
    this.onModelLoadedObservable = new Observable();
    if (layout.components) {
      Object.keys(layout.components).forEach(this._initComponent);
    }
  }
  WebXRAbstractMotionController2.prototype.dispose = function() {
    var _this = this;
    this.getComponentIds().forEach(function(id) {
      return _this.getComponent(id).dispose();
    });
    if (this.rootMesh) {
      this.rootMesh.dispose();
    }
  };
  WebXRAbstractMotionController2.prototype.getAllComponentsOfType = function(type) {
    var _this = this;
    return this.getComponentIds().map(function(id) {
      return _this.components[id];
    }).filter(function(component) {
      return component.type === type;
    });
  };
  WebXRAbstractMotionController2.prototype.getComponent = function(id) {
    return this.components[id];
  };
  WebXRAbstractMotionController2.prototype.getComponentIds = function() {
    return Object.keys(this.components);
  };
  WebXRAbstractMotionController2.prototype.getComponentOfType = function(type) {
    return this.getAllComponentsOfType(type)[0] || null;
  };
  WebXRAbstractMotionController2.prototype.getMainComponent = function() {
    return this.getComponent(this.layout.selectComponentId);
  };
  WebXRAbstractMotionController2.prototype.loadModel = function() {
    return __awaiter(this, void 0, void 0, function() {
      var useGeneric, loadingParams;
      var _this = this;
      return __generator(this, function(_a) {
        useGeneric = !this._getModelLoadingConstraints();
        loadingParams = this._getGenericFilenameAndPath();
        if (useGeneric) {
          Logger.Warn("Falling back to generic models");
        } else {
          loadingParams = this._getFilenameAndPath();
        }
        return [2, new Promise(function(resolve, reject) {
          SceneLoader.ImportMesh("", loadingParams.path, loadingParams.filename, _this.scene, function(meshes) {
            if (useGeneric) {
              _this._getGenericParentMesh(meshes);
            } else {
              _this._setRootMesh(meshes);
            }
            _this._processLoadedModel(meshes);
            _this._modelReady = true;
            _this.onModelLoadedObservable.notifyObservers(_this);
            resolve(true);
          }, null, function(_scene, message) {
            Logger.Log(message);
            Logger.Warn("Failed to retrieve controller model of type " + _this.profileId + " from the remote server: " + loadingParams.path + loadingParams.filename);
            reject(message);
          });
        })];
      });
    });
  };
  WebXRAbstractMotionController2.prototype.updateFromXRFrame = function(xrFrame) {
    var _this = this;
    this.getComponentIds().forEach(function(id) {
      return _this.getComponent(id).update(_this.gamepadObject);
    });
    this.updateModel(xrFrame);
  };
  Object.defineProperty(WebXRAbstractMotionController2.prototype, "handness", {
    get: function() {
      return this.handedness;
    },
    enumerable: false,
    configurable: true
  });
  WebXRAbstractMotionController2.prototype.pulse = function(value, duration, hapticActuatorIndex) {
    if (hapticActuatorIndex === void 0) {
      hapticActuatorIndex = 0;
    }
    if (this.gamepadObject.hapticActuators && this.gamepadObject.hapticActuators[hapticActuatorIndex]) {
      return this.gamepadObject.hapticActuators[hapticActuatorIndex].pulse(value, duration);
    } else {
      return Promise.resolve(false);
    }
  };
  WebXRAbstractMotionController2.prototype._getChildByName = function(node, name98) {
    return node.getChildren(function(n) {
      return n.name === name98;
    }, false)[0];
  };
  WebXRAbstractMotionController2.prototype._getImmediateChildByName = function(node, name98) {
    return node.getChildren(function(n) {
      return n.name == name98;
    }, true)[0];
  };
  WebXRAbstractMotionController2.prototype._lerpTransform = function(axisMap, axisValue, fixValueCoordinates) {
    if (!axisMap.minMesh || !axisMap.maxMesh || !axisMap.valueMesh) {
      return;
    }
    if (!axisMap.minMesh.rotationQuaternion || !axisMap.maxMesh.rotationQuaternion || !axisMap.valueMesh.rotationQuaternion) {
      return;
    }
    var lerpValue = fixValueCoordinates ? axisValue * 0.5 + 0.5 : axisValue;
    Quaternion.SlerpToRef(axisMap.minMesh.rotationQuaternion, axisMap.maxMesh.rotationQuaternion, lerpValue, axisMap.valueMesh.rotationQuaternion);
    Vector3.LerpToRef(axisMap.minMesh.position, axisMap.maxMesh.position, lerpValue, axisMap.valueMesh.position);
  };
  WebXRAbstractMotionController2.prototype.updateModel = function(xrFrame) {
    if (!this._modelReady) {
      return;
    }
    this._updateModel(xrFrame);
  };
  WebXRAbstractMotionController2.prototype._getGenericFilenameAndPath = function() {
    return {
      filename: "generic.babylon",
      path: "https://controllers.babylonjs.com/generic/"
    };
  };
  WebXRAbstractMotionController2.prototype._getGenericParentMesh = function(meshes) {
    var _this = this;
    this.rootMesh = new Mesh(this.profileId + " " + this.handedness, this.scene);
    meshes.forEach(function(mesh) {
      if (!mesh.parent) {
        mesh.isPickable = false;
        mesh.setParent(_this.rootMesh);
      }
    });
    this.rootMesh.rotationQuaternion = Quaternion.FromEulerAngles(0, Math.PI, 0);
  };
  return WebXRAbstractMotionController2;
}();

// node_modules/@babylonjs/core/XR/motionController/webXRGenericMotionController.js
var WebXRGenericTriggerMotionController = function(_super) {
  __extends(WebXRGenericTriggerMotionController2, _super);
  function WebXRGenericTriggerMotionController2(scene, gamepadObject, handedness) {
    var _this = _super.call(this, scene, GenericTriggerLayout[handedness], gamepadObject, handedness) || this;
    _this.profileId = WebXRGenericTriggerMotionController2.ProfileId;
    return _this;
  }
  WebXRGenericTriggerMotionController2.prototype._getFilenameAndPath = function() {
    return {
      filename: "generic.babylon",
      path: "https://controllers.babylonjs.com/generic/"
    };
  };
  WebXRGenericTriggerMotionController2.prototype._getModelLoadingConstraints = function() {
    return true;
  };
  WebXRGenericTriggerMotionController2.prototype._processLoadedModel = function(meshes) {
  };
  WebXRGenericTriggerMotionController2.prototype._setRootMesh = function(meshes) {
    var _this = this;
    this.rootMesh = new Mesh(this.profileId + " " + this.handedness, this.scene);
    meshes.forEach(function(mesh) {
      mesh.isPickable = false;
      if (!mesh.parent) {
        mesh.setParent(_this.rootMesh);
      }
    });
    this.rootMesh.rotationQuaternion = Quaternion.FromEulerAngles(0, Math.PI, 0);
  };
  WebXRGenericTriggerMotionController2.prototype._updateModel = function() {
  };
  WebXRGenericTriggerMotionController2.ProfileId = "generic-trigger";
  return WebXRGenericTriggerMotionController2;
}(WebXRAbstractMotionController);
var GenericTriggerLayout = {
  left: {
    selectComponentId: "xr-standard-trigger",
    components: {
      "xr-standard-trigger": {
        type: "trigger",
        gamepadIndices: {
          button: 0
        },
        rootNodeName: "xr_standard_trigger",
        visualResponses: {}
      }
    },
    gamepadMapping: "xr-standard",
    rootNodeName: "generic-trigger-left",
    assetPath: "left.glb"
  },
  right: {
    selectComponentId: "xr-standard-trigger",
    components: {
      "xr-standard-trigger": {
        type: "trigger",
        gamepadIndices: {
          button: 0
        },
        rootNodeName: "xr_standard_trigger",
        visualResponses: {}
      }
    },
    gamepadMapping: "xr-standard",
    rootNodeName: "generic-trigger-right",
    assetPath: "right.glb"
  },
  none: {
    selectComponentId: "xr-standard-trigger",
    components: {
      "xr-standard-trigger": {
        type: "trigger",
        gamepadIndices: {
          button: 0
        },
        rootNodeName: "xr_standard_trigger",
        visualResponses: {}
      }
    },
    gamepadMapping: "xr-standard",
    rootNodeName: "generic-trigger-none",
    assetPath: "none.glb"
  }
};

// node_modules/@babylonjs/core/XR/motionController/webXRProfiledMotionController.js
var WebXRProfiledMotionController = function(_super) {
  __extends(WebXRProfiledMotionController2, _super);
  function WebXRProfiledMotionController2(scene, xrInput, _profile, _repositoryUrl) {
    var _this = _super.call(this, scene, _profile.layouts[xrInput.handedness || "none"], xrInput.gamepad, xrInput.handedness) || this;
    _this._repositoryUrl = _repositoryUrl;
    _this._buttonMeshMapping = {};
    _this._touchDots = {};
    _this.profileId = _profile.profileId;
    return _this;
  }
  WebXRProfiledMotionController2.prototype.dispose = function() {
    var _this = this;
    _super.prototype.dispose.call(this);
    Object.keys(this._touchDots).forEach(function(visResKey) {
      _this._touchDots[visResKey].dispose();
    });
  };
  WebXRProfiledMotionController2.prototype._getFilenameAndPath = function() {
    return {
      filename: this.layout.assetPath,
      path: this._repositoryUrl + "/profiles/" + this.profileId + "/"
    };
  };
  WebXRProfiledMotionController2.prototype._getModelLoadingConstraints = function() {
    var glbLoaded = SceneLoader.IsPluginForExtensionAvailable(".glb");
    if (!glbLoaded) {
      Logger.Warn("glTF / glb loaded was not registered, using generic controller instead");
    }
    return glbLoaded;
  };
  WebXRProfiledMotionController2.prototype._processLoadedModel = function(_meshes) {
    var _this = this;
    this.getComponentIds().forEach(function(type) {
      var componentInLayout = _this.layout.components[type];
      _this._buttonMeshMapping[type] = {
        mainMesh: _this._getChildByName(_this.rootMesh, componentInLayout.rootNodeName),
        states: {}
      };
      Object.keys(componentInLayout.visualResponses).forEach(function(visualResponseKey) {
        var visResponse = componentInLayout.visualResponses[visualResponseKey];
        if (visResponse.valueNodeProperty === "transform") {
          _this._buttonMeshMapping[type].states[visualResponseKey] = {
            valueMesh: _this._getChildByName(_this.rootMesh, visResponse.valueNodeName),
            minMesh: _this._getChildByName(_this.rootMesh, visResponse.minNodeName),
            maxMesh: _this._getChildByName(_this.rootMesh, visResponse.maxNodeName)
          };
        } else {
          var nameOfMesh = componentInLayout.type === WebXRControllerComponent.TOUCHPAD_TYPE && componentInLayout.touchPointNodeName ? componentInLayout.touchPointNodeName : visResponse.valueNodeName;
          _this._buttonMeshMapping[type].states[visualResponseKey] = {
            valueMesh: _this._getChildByName(_this.rootMesh, nameOfMesh)
          };
          if (componentInLayout.type === WebXRControllerComponent.TOUCHPAD_TYPE && !_this._touchDots[visualResponseKey]) {
            var dot = SphereBuilder.CreateSphere(visualResponseKey + "dot", {
              diameter: 15e-4,
              segments: 8
            }, _this.scene);
            dot.material = new StandardMaterial(visualResponseKey + "mat", _this.scene);
            dot.material.diffuseColor = Color3.Red();
            dot.parent = _this._buttonMeshMapping[type].states[visualResponseKey].valueMesh || null;
            dot.isVisible = false;
            _this._touchDots[visualResponseKey] = dot;
          }
        }
      });
    });
  };
  WebXRProfiledMotionController2.prototype._setRootMesh = function(meshes) {
    this.rootMesh = new Mesh(this.profileId + "-" + this.handedness, this.scene);
    this.rootMesh.isPickable = false;
    var rootMesh;
    for (var i = 0; i < meshes.length; i++) {
      var mesh = meshes[i];
      mesh.isPickable = false;
      if (!mesh.parent) {
        rootMesh = mesh;
      }
    }
    if (rootMesh) {
      rootMesh.setParent(this.rootMesh);
    }
    if (!this.scene.useRightHandedSystem) {
      this.rootMesh.rotate(Axis.Y, Math.PI, Space.WORLD);
    }
  };
  WebXRProfiledMotionController2.prototype._updateModel = function(_xrFrame) {
    var _this = this;
    if (this.disableAnimation) {
      return;
    }
    this.getComponentIds().forEach(function(id) {
      var component = _this.getComponent(id);
      if (!component.hasChanges) {
        return;
      }
      var meshes = _this._buttonMeshMapping[id];
      var componentInLayout = _this.layout.components[id];
      Object.keys(componentInLayout.visualResponses).forEach(function(visualResponseKey) {
        var visResponse = componentInLayout.visualResponses[visualResponseKey];
        var value = component.value;
        if (visResponse.componentProperty === "xAxis") {
          value = component.axes.x;
        } else if (visResponse.componentProperty === "yAxis") {
          value = component.axes.y;
        }
        if (visResponse.valueNodeProperty === "transform") {
          _this._lerpTransform(meshes.states[visualResponseKey], value, visResponse.componentProperty !== "button");
        } else {
          var valueMesh = meshes.states[visualResponseKey].valueMesh;
          if (valueMesh) {
            valueMesh.isVisible = component.touched || component.pressed;
          }
          if (_this._touchDots[visualResponseKey]) {
            _this._touchDots[visualResponseKey].isVisible = component.touched || component.pressed;
          }
        }
      });
    });
  };
  return WebXRProfiledMotionController2;
}(WebXRAbstractMotionController);

// node_modules/@babylonjs/core/XR/motionController/webXRMotionControllerManager.js
var WebXRMotionControllerManager = function() {
  function WebXRMotionControllerManager2() {
  }
  WebXRMotionControllerManager2.ClearProfilesCache = function() {
    this._ProfilesList = null;
    this._ProfileLoadingPromises = {};
  };
  WebXRMotionControllerManager2.DefaultFallbacks = function() {
    this.RegisterFallbacksForProfileId("google-daydream", ["generic-touchpad"]);
    this.RegisterFallbacksForProfileId("htc-vive-focus", ["generic-trigger-touchpad"]);
    this.RegisterFallbacksForProfileId("htc-vive", ["generic-trigger-squeeze-touchpad"]);
    this.RegisterFallbacksForProfileId("magicleap-one", ["generic-trigger-squeeze-touchpad"]);
    this.RegisterFallbacksForProfileId("windows-mixed-reality", ["generic-trigger-squeeze-touchpad-thumbstick"]);
    this.RegisterFallbacksForProfileId("microsoft-mixed-reality", ["windows-mixed-reality", "generic-trigger-squeeze-touchpad-thumbstick"]);
    this.RegisterFallbacksForProfileId("oculus-go", ["generic-trigger-touchpad"]);
    this.RegisterFallbacksForProfileId("oculus-touch-v2", ["oculus-touch", "generic-trigger-squeeze-thumbstick"]);
    this.RegisterFallbacksForProfileId("oculus-touch", ["generic-trigger-squeeze-thumbstick"]);
    this.RegisterFallbacksForProfileId("samsung-gearvr", ["windows-mixed-reality", "generic-trigger-squeeze-touchpad-thumbstick"]);
    this.RegisterFallbacksForProfileId("samsung-odyssey", ["generic-touchpad"]);
    this.RegisterFallbacksForProfileId("valve-index", ["generic-trigger-squeeze-touchpad-thumbstick"]);
  };
  WebXRMotionControllerManager2.FindFallbackWithProfileId = function(profileId) {
    var returnArray = this._Fallbacks[profileId] || [];
    returnArray.unshift(profileId);
    return returnArray;
  };
  WebXRMotionControllerManager2.GetMotionControllerWithXRInput = function(xrInput, scene, forceProfile) {
    var _this = this;
    var profileArray = [];
    if (forceProfile) {
      profileArray.push(forceProfile);
    }
    profileArray.push.apply(profileArray, xrInput.profiles || []);
    if (profileArray.length && !profileArray[0]) {
      profileArray.pop();
    }
    if (xrInput.gamepad && xrInput.gamepad.id) {
      switch (xrInput.gamepad.id) {
        case (xrInput.gamepad.id.match(/oculus touch/gi) ? xrInput.gamepad.id : void 0):
          profileArray.push("oculus-touch-v2");
          break;
      }
    }
    var windowsMRIdx = profileArray.indexOf("windows-mixed-reality");
    if (windowsMRIdx !== -1) {
      profileArray.splice(windowsMRIdx, 0, "microsoft-mixed-reality");
    }
    if (!profileArray.length) {
      profileArray.push("generic-trigger");
    }
    if (this.UseOnlineRepository) {
      var firstFunction = this.PrioritizeOnlineRepository ? this._LoadProfileFromRepository : this._LoadProfilesFromAvailableControllers;
      var secondFunction_1 = this.PrioritizeOnlineRepository ? this._LoadProfilesFromAvailableControllers : this._LoadProfileFromRepository;
      return firstFunction.call(this, profileArray, xrInput, scene).catch(function() {
        return secondFunction_1.call(_this, profileArray, xrInput, scene);
      });
    } else {
      return this._LoadProfilesFromAvailableControllers(profileArray, xrInput, scene);
    }
  };
  WebXRMotionControllerManager2.RegisterController = function(type, constructFunction) {
    this._AvailableControllers[type] = constructFunction;
  };
  WebXRMotionControllerManager2.RegisterFallbacksForProfileId = function(profileId, fallbacks) {
    var _a;
    if (this._Fallbacks[profileId]) {
      (_a = this._Fallbacks[profileId]).push.apply(_a, fallbacks);
    } else {
      this._Fallbacks[profileId] = fallbacks;
    }
  };
  WebXRMotionControllerManager2.UpdateProfilesList = function() {
    this._ProfilesList = Tools.LoadFileAsync(this.BaseRepositoryUrl + "/profiles/profilesList.json", false).then(function(data) {
      return JSON.parse(data.toString());
    });
    return this._ProfilesList;
  };
  WebXRMotionControllerManager2._LoadProfileFromRepository = function(profileArray, xrInput, scene) {
    var _this = this;
    return Promise.resolve().then(function() {
      if (!_this._ProfilesList) {
        return _this.UpdateProfilesList();
      } else {
        return _this._ProfilesList;
      }
    }).then(function(profilesList) {
      for (var i = 0; i < profileArray.length; ++i) {
        if (!profileArray[i]) {
          continue;
        }
        if (profilesList[profileArray[i]]) {
          return profileArray[i];
        }
      }
      throw new Error("neither controller " + profileArray[0] + " nor all fallbacks were found in the repository,");
    }).then(function(profileToLoad) {
      if (!_this._ProfileLoadingPromises[profileToLoad]) {
        _this._ProfileLoadingPromises[profileToLoad] = Tools.LoadFileAsync(_this.BaseRepositoryUrl + "/profiles/" + profileToLoad + "/profile.json", false).then(function(data) {
          return JSON.parse(data);
        });
      }
      return _this._ProfileLoadingPromises[profileToLoad];
    }).then(function(profile) {
      return new WebXRProfiledMotionController(scene, xrInput, profile, _this.BaseRepositoryUrl);
    });
  };
  WebXRMotionControllerManager2._LoadProfilesFromAvailableControllers = function(profileArray, xrInput, scene) {
    for (var i = 0; i < profileArray.length; ++i) {
      if (!profileArray[i]) {
        continue;
      }
      var fallbacks = this.FindFallbackWithProfileId(profileArray[i]);
      for (var j = 0; j < fallbacks.length; ++j) {
        var constructionFunction = this._AvailableControllers[fallbacks[j]];
        if (constructionFunction) {
          return Promise.resolve(constructionFunction(xrInput, scene));
        }
      }
    }
    throw new Error("no controller requested was found in the available controllers list");
  };
  WebXRMotionControllerManager2._AvailableControllers = {};
  WebXRMotionControllerManager2._Fallbacks = {};
  WebXRMotionControllerManager2._ProfileLoadingPromises = {};
  WebXRMotionControllerManager2.BaseRepositoryUrl = "https://immersive-web.github.io/webxr-input-profiles/packages/viewer/dist";
  WebXRMotionControllerManager2.PrioritizeOnlineRepository = true;
  WebXRMotionControllerManager2.UseOnlineRepository = true;
  return WebXRMotionControllerManager2;
}();
WebXRMotionControllerManager.RegisterController(WebXRGenericTriggerMotionController.ProfileId, function(xrInput, scene) {
  return new WebXRGenericTriggerMotionController(scene, xrInput.gamepad, xrInput.handedness);
});
WebXRMotionControllerManager.DefaultFallbacks();

// node_modules/@babylonjs/core/XR/webXRInputSource.js
var idCount = 0;
var WebXRInputSource = function() {
  function WebXRInputSource2(_scene, inputSource, _options) {
    var _this = this;
    if (_options === void 0) {
      _options = {};
    }
    this._scene = _scene;
    this.inputSource = inputSource;
    this._options = _options;
    this._tmpVector = new Vector3();
    this._disposed = false;
    this.onDisposeObservable = new Observable();
    this.onMeshLoadedObservable = new Observable();
    this.onMotionControllerInitObservable = new Observable();
    this._uniqueId = "controller-" + idCount++ + "-" + inputSource.targetRayMode + "-" + inputSource.handedness;
    this.pointer = new AbstractMesh(this._uniqueId + "-pointer", _scene);
    this.pointer.rotationQuaternion = new Quaternion();
    if (this.inputSource.gripSpace) {
      this.grip = new AbstractMesh(this._uniqueId + "-grip", this._scene);
      this.grip.rotationQuaternion = new Quaternion();
    }
    this._tmpVector.set(0, 0, this._scene.useRightHandedSystem ? -1 : 1);
    if (this.inputSource.gamepad) {
      WebXRMotionControllerManager.GetMotionControllerWithXRInput(inputSource, _scene, this._options.forceControllerProfile).then(function(motionController) {
        _this.motionController = motionController;
        _this.onMotionControllerInitObservable.notifyObservers(motionController);
        if (!_this._options.doNotLoadControllerMesh) {
          _this.motionController.loadModel().then(function(success) {
            var _a;
            if (success && _this.motionController && _this.motionController.rootMesh) {
              if (_this._options.renderingGroupId) {
                _this.motionController.rootMesh.renderingGroupId = _this._options.renderingGroupId;
                _this.motionController.rootMesh.getChildMeshes(false).forEach(function(mesh) {
                  return mesh.renderingGroupId = _this._options.renderingGroupId;
                });
              }
              _this.onMeshLoadedObservable.notifyObservers(_this.motionController.rootMesh);
              _this.motionController.rootMesh.parent = _this.grip || _this.pointer;
              _this.motionController.disableAnimation = !!_this._options.disableMotionControllerAnimation;
            }
            if (_this._disposed) {
              (_a = _this.motionController) === null || _a === void 0 ? void 0 : _a.dispose();
            }
          });
        }
      }, function() {
        Tools.Warn("Could not find a matching motion controller for the registered input source");
      });
    }
  }
  Object.defineProperty(WebXRInputSource2.prototype, "uniqueId", {
    get: function() {
      return this._uniqueId;
    },
    enumerable: false,
    configurable: true
  });
  WebXRInputSource2.prototype.dispose = function() {
    if (this.grip) {
      this.grip.dispose();
    }
    if (this.motionController) {
      this.motionController.dispose();
    }
    this.pointer.dispose();
    this.onMotionControllerInitObservable.clear();
    this.onMeshLoadedObservable.clear();
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    this._disposed = true;
  };
  WebXRInputSource2.prototype.getWorldPointerRayToRef = function(result, gripIfAvailable) {
    if (gripIfAvailable === void 0) {
      gripIfAvailable = false;
    }
    var object = gripIfAvailable && this.grip ? this.grip : this.pointer;
    Vector3.TransformNormalToRef(this._tmpVector, object.getWorldMatrix(), result.direction);
    result.direction.normalize();
    result.origin.copyFrom(object.absolutePosition);
    result.length = 1e3;
  };
  WebXRInputSource2.prototype.updateFromXRFrame = function(xrFrame, referenceSpace) {
    var pose = xrFrame.getPose(this.inputSource.targetRaySpace, referenceSpace);
    if (pose) {
      var pos = pose.transform.position;
      this.pointer.position.set(pos.x, pos.y, pos.z);
      var orientation_1 = pose.transform.orientation;
      this.pointer.rotationQuaternion.set(orientation_1.x, orientation_1.y, orientation_1.z, orientation_1.w);
      if (!this._scene.useRightHandedSystem) {
        this.pointer.position.z *= -1;
        this.pointer.rotationQuaternion.z *= -1;
        this.pointer.rotationQuaternion.w *= -1;
      }
    }
    if (this.inputSource.gripSpace && this.grip) {
      var pose_1 = xrFrame.getPose(this.inputSource.gripSpace, referenceSpace);
      if (pose_1) {
        var pos = pose_1.transform.position;
        var orientation_2 = pose_1.transform.orientation;
        this.grip.position.set(pos.x, pos.y, pos.z);
        this.grip.rotationQuaternion.set(orientation_2.x, orientation_2.y, orientation_2.z, orientation_2.w);
        if (!this._scene.useRightHandedSystem) {
          this.grip.position.z *= -1;
          this.grip.rotationQuaternion.z *= -1;
          this.grip.rotationQuaternion.w *= -1;
        }
      }
    }
    if (this.motionController) {
      this.motionController.updateFromXRFrame(xrFrame);
    }
  };
  return WebXRInputSource2;
}();

// node_modules/@babylonjs/core/XR/webXRInput.js
var WebXRInput = function() {
  function WebXRInput2(xrSessionManager, xrCamera, options) {
    var _this = this;
    if (options === void 0) {
      options = {};
    }
    this.xrSessionManager = xrSessionManager;
    this.xrCamera = xrCamera;
    this.options = options;
    this.controllers = [];
    this.onControllerAddedObservable = new Observable();
    this.onControllerRemovedObservable = new Observable();
    this._onInputSourcesChange = function(event) {
      _this._addAndRemoveControllers(event.added, event.removed);
    };
    this._sessionEndedObserver = this.xrSessionManager.onXRSessionEnded.add(function() {
      _this._addAndRemoveControllers([], _this.controllers.map(function(c) {
        return c.inputSource;
      }));
    });
    this._sessionInitObserver = this.xrSessionManager.onXRSessionInit.add(function(session) {
      session.addEventListener("inputsourceschange", _this._onInputSourcesChange);
    });
    this._frameObserver = this.xrSessionManager.onXRFrameObservable.add(function(frame) {
      _this.controllers.forEach(function(controller) {
        controller.updateFromXRFrame(frame, _this.xrSessionManager.referenceSpace);
      });
    });
    if (this.options.customControllersRepositoryURL) {
      WebXRMotionControllerManager.BaseRepositoryUrl = this.options.customControllersRepositoryURL;
    }
    WebXRMotionControllerManager.UseOnlineRepository = !this.options.disableOnlineControllerRepository;
    if (WebXRMotionControllerManager.UseOnlineRepository) {
      try {
        WebXRMotionControllerManager.UpdateProfilesList().catch(function() {
          WebXRMotionControllerManager.UseOnlineRepository = false;
        });
      } catch (e) {
        WebXRMotionControllerManager.UseOnlineRepository = false;
      }
    }
  }
  WebXRInput2.prototype._addAndRemoveControllers = function(addInputs, removeInputs) {
    var _this = this;
    var sources = this.controllers.map(function(c) {
      return c.inputSource;
    });
    for (var _i = 0, addInputs_1 = addInputs; _i < addInputs_1.length; _i++) {
      var input = addInputs_1[_i];
      if (sources.indexOf(input) === -1) {
        var controller = new WebXRInputSource(this.xrSessionManager.scene, input, __assign(__assign({}, this.options.controllerOptions || {}), { forceControllerProfile: this.options.forceInputProfile, doNotLoadControllerMesh: this.options.doNotLoadControllerMeshes, disableMotionControllerAnimation: this.options.disableControllerAnimation }));
        this.controllers.push(controller);
        this.onControllerAddedObservable.notifyObservers(controller);
      }
    }
    var keepControllers = [];
    var removedControllers = [];
    this.controllers.forEach(function(c) {
      if (removeInputs.indexOf(c.inputSource) === -1) {
        keepControllers.push(c);
      } else {
        removedControllers.push(c);
      }
    });
    this.controllers = keepControllers;
    removedControllers.forEach(function(c) {
      _this.onControllerRemovedObservable.notifyObservers(c);
      c.dispose();
    });
  };
  WebXRInput2.prototype.dispose = function() {
    this.controllers.forEach(function(c) {
      c.dispose();
    });
    this.xrSessionManager.onXRFrameObservable.remove(this._frameObserver);
    this.xrSessionManager.onXRSessionInit.remove(this._sessionInitObserver);
    this.xrSessionManager.onXRSessionEnded.remove(this._sessionEndedObserver);
    this.onControllerAddedObservable.clear();
    this.onControllerRemovedObservable.clear();
  };
  return WebXRInput2;
}();

// node_modules/@babylonjs/core/XR/features/WebXRAbstractFeature.js
var WebXRAbstractFeature = function() {
  function WebXRAbstractFeature2(_xrSessionManager) {
    this._xrSessionManager = _xrSessionManager;
    this._attached = false;
    this._removeOnDetach = [];
    this.isDisposed = false;
    this.disableAutoAttach = false;
    this.xrNativeFeatureName = "";
  }
  Object.defineProperty(WebXRAbstractFeature2.prototype, "attached", {
    get: function() {
      return this._attached;
    },
    enumerable: false,
    configurable: true
  });
  WebXRAbstractFeature2.prototype.attach = function(force) {
    var _this = this;
    if (this.isDisposed) {
      return false;
    }
    if (!force) {
      if (this.attached) {
        return false;
      }
    } else {
      if (this.attached) {
        this.detach();
      }
    }
    this._attached = true;
    this._addNewAttachObserver(this._xrSessionManager.onXRFrameObservable, function(frame) {
      return _this._onXRFrame(frame);
    });
    return true;
  };
  WebXRAbstractFeature2.prototype.detach = function() {
    if (!this._attached) {
      this.disableAutoAttach = true;
      return false;
    }
    this._attached = false;
    this._removeOnDetach.forEach(function(toRemove) {
      toRemove.observable.remove(toRemove.observer);
    });
    return true;
  };
  WebXRAbstractFeature2.prototype.dispose = function() {
    this.detach();
    this.isDisposed = true;
  };
  WebXRAbstractFeature2.prototype.isCompatible = function() {
    return true;
  };
  WebXRAbstractFeature2.prototype._addNewAttachObserver = function(observable, callback) {
    this._removeOnDetach.push({
      observable,
      observer: observable.add(callback)
    });
  };
  return WebXRAbstractFeature2;
}();

// node_modules/@babylonjs/core/XR/features/WebXRControllerPointerSelection.js
var WebXRControllerPointerSelection = function(_super) {
  __extends(WebXRControllerPointerSelection2, _super);
  function WebXRControllerPointerSelection2(_xrSessionManager, _options) {
    var _this = _super.call(this, _xrSessionManager) || this;
    _this._options = _options;
    _this._attachController = function(xrController) {
      if (_this._controllers[xrController.uniqueId]) {
        return;
      }
      var _a = _this._generateNewMeshPair(xrController.pointer), laserPointer = _a.laserPointer, selectionMesh = _a.selectionMesh;
      _this._controllers[xrController.uniqueId] = {
        xrController,
        laserPointer,
        selectionMesh,
        meshUnderPointer: null,
        pick: null,
        tmpRay: new Ray(new Vector3(), new Vector3()),
        id: WebXRControllerPointerSelection2._idCounter++
      };
      if (_this._attachedController) {
        if (!_this._options.enablePointerSelectionOnAllControllers && _this._options.preferredHandedness && xrController.inputSource.handedness === _this._options.preferredHandedness) {
          _this._attachedController = xrController.uniqueId;
        }
      } else {
        if (!_this._options.enablePointerSelectionOnAllControllers) {
          _this._attachedController = xrController.uniqueId;
        }
      }
      switch (xrController.inputSource.targetRayMode) {
        case "tracked-pointer":
          return _this._attachTrackedPointerRayMode(xrController);
        case "gaze":
          return _this._attachGazeMode(xrController);
        case "screen":
          return _this._attachScreenRayMode(xrController);
      }
    };
    _this._controllers = {};
    _this._tmpVectorForPickCompare = new Vector3();
    _this.disablePointerLighting = true;
    _this.disableSelectionMeshLighting = true;
    _this.displayLaserPointer = true;
    _this.displaySelectionMesh = true;
    _this.laserPointerPickedColor = new Color3(0.9, 0.9, 0.9);
    _this.laserPointerDefaultColor = new Color3(0.7, 0.7, 0.7);
    _this.selectionMeshDefaultColor = new Color3(0.8, 0.8, 0.8);
    _this.selectionMeshPickedColor = new Color3(0.3, 0.3, 1);
    _this._identityMatrix = Matrix.Identity();
    _this._screenCoordinatesRef = Vector3.Zero();
    _this._viewportRef = new Viewport(0, 0, 0, 0);
    _this._scene = _this._xrSessionManager.scene;
    return _this;
  }
  WebXRControllerPointerSelection2.prototype.attach = function() {
    var _this = this;
    if (!_super.prototype.attach.call(this)) {
      return false;
    }
    this._options.xrInput.controllers.forEach(this._attachController);
    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);
    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, function(controller) {
      _this._detachController(controller.uniqueId);
    });
    this._scene.constantlyUpdateMeshUnderPointer = true;
    if (this._options.gazeCamera) {
      var webXRCamera = this._options.gazeCamera;
      var _a = this._generateNewMeshPair(webXRCamera), laserPointer = _a.laserPointer, selectionMesh = _a.selectionMesh;
      this._controllers["camera"] = {
        webXRCamera,
        laserPointer,
        selectionMesh,
        meshUnderPointer: null,
        pick: null,
        tmpRay: new Ray(new Vector3(), new Vector3()),
        id: WebXRControllerPointerSelection2._idCounter++
      };
      this._attachGazeMode();
    }
    return true;
  };
  WebXRControllerPointerSelection2.prototype.detach = function() {
    var _this = this;
    if (!_super.prototype.detach.call(this)) {
      return false;
    }
    Object.keys(this._controllers).forEach(function(controllerId) {
      _this._detachController(controllerId);
    });
    return true;
  };
  WebXRControllerPointerSelection2.prototype.getMeshUnderPointer = function(controllerId) {
    if (this._controllers[controllerId]) {
      return this._controllers[controllerId].meshUnderPointer;
    } else {
      return null;
    }
  };
  WebXRControllerPointerSelection2.prototype.getXRControllerByPointerId = function(id) {
    var keys = Object.keys(this._controllers);
    for (var i = 0; i < keys.length; ++i) {
      if (this._controllers[keys[i]].id === id) {
        return this._controllers[keys[i]].xrController || null;
      }
    }
    return null;
  };
  WebXRControllerPointerSelection2.prototype._onXRFrame = function(_xrFrame) {
    var _this = this;
    Object.keys(this._controllers).forEach(function(id) {
      var controllerData = _this._controllers[id];
      if (!_this._options.enablePointerSelectionOnAllControllers && id !== _this._attachedController) {
        controllerData.selectionMesh.isVisible = false;
        controllerData.laserPointer.isVisible = false;
        controllerData.pick = null;
        return;
      }
      controllerData.laserPointer.isVisible = _this.displayLaserPointer;
      var controllerGlobalPosition;
      if (controllerData.xrController) {
        controllerGlobalPosition = controllerData.xrController.pointer.position;
        controllerData.xrController.getWorldPointerRayToRef(controllerData.tmpRay);
      } else if (controllerData.webXRCamera) {
        controllerGlobalPosition = controllerData.webXRCamera.position;
        controllerData.webXRCamera.getForwardRayToRef(controllerData.tmpRay);
      } else {
        return;
      }
      if (_this._options.maxPointerDistance) {
        controllerData.tmpRay.length = _this._options.maxPointerDistance;
      }
      if (!_this._options.disableScenePointerVectorUpdate && controllerGlobalPosition) {
        var scene = _this._xrSessionManager.scene;
        var camera = _this._options.xrInput.xrCamera;
        if (camera) {
          camera.viewport.toGlobalToRef(scene.getEngine().getRenderWidth(), scene.getEngine().getRenderHeight(), _this._viewportRef);
          Vector3.ProjectToRef(controllerGlobalPosition, _this._identityMatrix, scene.getTransformMatrix(), _this._viewportRef, _this._screenCoordinatesRef);
          scene.pointerX = _this._screenCoordinatesRef.x;
          scene.pointerY = _this._screenCoordinatesRef.y;
        }
      }
      controllerData.pick = _this._scene.pickWithRay(controllerData.tmpRay, _this._scene.pointerMovePredicate || _this.raySelectionPredicate);
      var pick = controllerData.pick;
      if (pick && pick.pickedPoint && pick.hit) {
        _this._updatePointerDistance(controllerData.laserPointer, pick.distance);
        controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);
        controllerData.selectionMesh.scaling.x = Math.sqrt(pick.distance);
        controllerData.selectionMesh.scaling.y = Math.sqrt(pick.distance);
        controllerData.selectionMesh.scaling.z = Math.sqrt(pick.distance);
        var pickNormal = _this._convertNormalToDirectionOfRay(pick.getNormal(true), controllerData.tmpRay);
        var deltaFighting = 1e-3;
        controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);
        if (pickNormal) {
          var axis1 = Vector3.Cross(Axis.Y, pickNormal);
          var axis2 = Vector3.Cross(pickNormal, axis1);
          Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, controllerData.selectionMesh.rotation);
          controllerData.selectionMesh.position.addInPlace(pickNormal.scale(deltaFighting));
        }
        controllerData.selectionMesh.isVisible = _this.displaySelectionMesh;
        controllerData.meshUnderPointer = pick.pickedMesh;
      } else {
        controllerData.selectionMesh.isVisible = false;
        _this._updatePointerDistance(controllerData.laserPointer, 1);
        controllerData.meshUnderPointer = null;
      }
    });
  };
  WebXRControllerPointerSelection2.prototype._attachGazeMode = function(xrController) {
    var _this = this;
    var controllerData = this._controllers[xrController && xrController.uniqueId || "camera"];
    var timeToSelect = this._options.timeToSelect || 3e3;
    var sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;
    var oldPick = new PickingInfo();
    var discMesh = TorusBuilder.CreateTorus("selection", {
      diameter: 35e-4 * 15,
      thickness: 25e-4 * 6,
      tessellation: 20
    }, sceneToRenderTo);
    discMesh.isVisible = false;
    discMesh.isPickable = false;
    discMesh.parent = controllerData.selectionMesh;
    var timer = 0;
    var downTriggered = false;
    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(function() {
      if (!controllerData.pick) {
        return;
      }
      controllerData.laserPointer.material.alpha = 0;
      discMesh.isVisible = false;
      if (controllerData.pick.hit) {
        if (!_this._pickingMoved(oldPick, controllerData.pick)) {
          if (timer > timeToSelect / 10) {
            discMesh.isVisible = true;
          }
          timer += _this._scene.getEngine().getDeltaTime();
          if (timer >= timeToSelect) {
            _this._scene.simulatePointerDown(controllerData.pick, { pointerId: controllerData.id });
            downTriggered = true;
            if (_this._options.disablePointerUpOnTouchOut) {
              _this._scene.simulatePointerUp(controllerData.pick, { pointerId: controllerData.id });
            }
            discMesh.isVisible = false;
          } else {
            var scaleFactor = 1 - timer / timeToSelect;
            discMesh.scaling.set(scaleFactor, scaleFactor, scaleFactor);
          }
        } else {
          if (downTriggered) {
            if (!_this._options.disablePointerUpOnTouchOut) {
              _this._scene.simulatePointerUp(controllerData.pick, { pointerId: controllerData.id });
            }
          }
          downTriggered = false;
          timer = 0;
        }
      } else {
        downTriggered = false;
        timer = 0;
      }
      _this._scene.simulatePointerMove(controllerData.pick, { pointerId: controllerData.id });
      oldPick = controllerData.pick;
    });
    if (this._options.renderingGroupId !== void 0) {
      discMesh.renderingGroupId = this._options.renderingGroupId;
    }
    if (xrController) {
      xrController.onDisposeObservable.addOnce(function() {
        if (controllerData.pick && !_this._options.disablePointerUpOnTouchOut && downTriggered) {
          _this._scene.simulatePointerUp(controllerData.pick, { pointerId: controllerData.id });
        }
        discMesh.dispose();
      });
    }
  };
  WebXRControllerPointerSelection2.prototype._attachScreenRayMode = function(xrController) {
    var _this = this;
    var controllerData = this._controllers[xrController.uniqueId];
    var downTriggered = false;
    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(function() {
      if (!controllerData.pick || _this._options.disablePointerUpOnTouchOut && downTriggered) {
        return;
      }
      if (!downTriggered) {
        _this._scene.simulatePointerDown(controllerData.pick, { pointerId: controllerData.id });
        downTriggered = true;
        if (_this._options.disablePointerUpOnTouchOut) {
          _this._scene.simulatePointerUp(controllerData.pick, { pointerId: controllerData.id });
        }
      } else {
        _this._scene.simulatePointerMove(controllerData.pick, { pointerId: controllerData.id });
      }
    });
    xrController.onDisposeObservable.addOnce(function() {
      if (controllerData.pick && downTriggered && !_this._options.disablePointerUpOnTouchOut) {
        _this._scene.simulatePointerUp(controllerData.pick, { pointerId: controllerData.id });
      }
    });
  };
  WebXRControllerPointerSelection2.prototype._attachTrackedPointerRayMode = function(xrController) {
    var _this = this;
    var controllerData = this._controllers[xrController.uniqueId];
    if (this._options.forceGazeMode) {
      return this._attachGazeMode(xrController);
    }
    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(function() {
      controllerData.laserPointer.material.disableLighting = _this.disablePointerLighting;
      controllerData.selectionMesh.material.disableLighting = _this.disableSelectionMeshLighting;
      if (controllerData.pick) {
        _this._scene.simulatePointerMove(controllerData.pick, { pointerId: controllerData.id });
      }
    });
    if (xrController.inputSource.gamepad) {
      var init = function(motionController) {
        if (_this._options.overrideButtonId) {
          controllerData.selectionComponent = motionController.getComponent(_this._options.overrideButtonId);
        }
        if (!controllerData.selectionComponent) {
          controllerData.selectionComponent = motionController.getMainComponent();
        }
        controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add(function(component) {
          if (component.changes.pressed) {
            var pressed = component.changes.pressed.current;
            if (controllerData.pick) {
              if (_this._options.enablePointerSelectionOnAllControllers || xrController.uniqueId === _this._attachedController) {
                if (pressed) {
                  _this._scene.simulatePointerDown(controllerData.pick, { pointerId: controllerData.id });
                  controllerData.selectionMesh.material.emissiveColor = _this.selectionMeshPickedColor;
                  controllerData.laserPointer.material.emissiveColor = _this.laserPointerPickedColor;
                } else {
                  _this._scene.simulatePointerUp(controllerData.pick, { pointerId: controllerData.id });
                  controllerData.selectionMesh.material.emissiveColor = _this.selectionMeshDefaultColor;
                  controllerData.laserPointer.material.emissiveColor = _this.laserPointerDefaultColor;
                }
              } else {
              }
            } else {
              if (pressed && !_this._options.enablePointerSelectionOnAllControllers && !_this._options.disableSwitchOnClick) {
                _this._attachedController = xrController.uniqueId;
              }
            }
          }
        });
      };
      if (xrController.motionController) {
        init(xrController.motionController);
      } else {
        xrController.onMotionControllerInitObservable.add(init);
      }
    } else {
      var selectStartListener = function(event) {
        if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {
          _this._scene.simulatePointerDown(controllerData.pick, { pointerId: controllerData.id });
          controllerData.selectionMesh.material.emissiveColor = _this.selectionMeshPickedColor;
          controllerData.laserPointer.material.emissiveColor = _this.laserPointerPickedColor;
        }
      };
      var selectEndListener = function(event) {
        if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {
          _this._scene.simulatePointerUp(controllerData.pick, { pointerId: controllerData.id });
          controllerData.selectionMesh.material.emissiveColor = _this.selectionMeshDefaultColor;
          controllerData.laserPointer.material.emissiveColor = _this.laserPointerDefaultColor;
        }
      };
      controllerData.eventListeners = {
        selectend: selectEndListener,
        selectstart: selectStartListener
      };
      this._xrSessionManager.session.addEventListener("selectstart", selectStartListener);
      this._xrSessionManager.session.addEventListener("selectend", selectEndListener);
    }
  };
  WebXRControllerPointerSelection2.prototype._convertNormalToDirectionOfRay = function(normal, ray) {
    if (normal) {
      var angle = Math.acos(Vector3.Dot(normal, ray.direction));
      if (angle < Math.PI / 2) {
        normal.scaleInPlace(-1);
      }
    }
    return normal;
  };
  WebXRControllerPointerSelection2.prototype._detachController = function(xrControllerUniqueId) {
    var _this = this;
    var controllerData = this._controllers[xrControllerUniqueId];
    if (!controllerData) {
      return;
    }
    if (controllerData.selectionComponent) {
      if (controllerData.onButtonChangedObserver) {
        controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);
      }
    }
    if (controllerData.onFrameObserver) {
      this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);
    }
    if (controllerData.eventListeners) {
      Object.keys(controllerData.eventListeners).forEach(function(eventName) {
        var func = controllerData.eventListeners && controllerData.eventListeners[eventName];
        if (func) {
          _this._xrSessionManager.session.removeEventListener(eventName, func);
        }
      });
    }
    controllerData.selectionMesh.dispose();
    controllerData.laserPointer.dispose();
    delete this._controllers[xrControllerUniqueId];
    if (this._attachedController === xrControllerUniqueId) {
      var keys = Object.keys(this._controllers);
      if (keys.length) {
        this._attachedController = keys[0];
      } else {
        this._attachedController = "";
      }
    }
  };
  WebXRControllerPointerSelection2.prototype._generateNewMeshPair = function(meshParent) {
    var sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;
    var laserPointer = CylinderBuilder.CreateCylinder("laserPointer", {
      height: 1,
      diameterTop: 2e-4,
      diameterBottom: 4e-3,
      tessellation: 20,
      subdivisions: 1
    }, sceneToRenderTo);
    laserPointer.parent = meshParent;
    var laserPointerMaterial = new StandardMaterial("laserPointerMat", sceneToRenderTo);
    laserPointerMaterial.emissiveColor = this.laserPointerDefaultColor;
    laserPointerMaterial.alpha = 0.7;
    laserPointer.material = laserPointerMaterial;
    laserPointer.rotation.x = Math.PI / 2;
    this._updatePointerDistance(laserPointer, 1);
    laserPointer.isPickable = false;
    var selectionMesh = TorusBuilder.CreateTorus("gazeTracker", {
      diameter: 35e-4 * 3,
      thickness: 25e-4 * 3,
      tessellation: 20
    }, sceneToRenderTo);
    selectionMesh.bakeCurrentTransformIntoVertices();
    selectionMesh.isPickable = false;
    selectionMesh.isVisible = false;
    var targetMat = new StandardMaterial("targetMat", sceneToRenderTo);
    targetMat.specularColor = Color3.Black();
    targetMat.emissiveColor = this.selectionMeshDefaultColor;
    targetMat.backFaceCulling = false;
    selectionMesh.material = targetMat;
    if (this._options.renderingGroupId !== void 0) {
      laserPointer.renderingGroupId = this._options.renderingGroupId;
      selectionMesh.renderingGroupId = this._options.renderingGroupId;
    }
    return {
      laserPointer,
      selectionMesh
    };
  };
  WebXRControllerPointerSelection2.prototype._pickingMoved = function(oldPick, newPick) {
    var _a;
    if (!oldPick.hit || !newPick.hit) {
      return true;
    }
    if (!oldPick.pickedMesh || !oldPick.pickedPoint || !newPick.pickedMesh || !newPick.pickedPoint) {
      return true;
    }
    if (oldPick.pickedMesh !== newPick.pickedMesh) {
      return true;
    }
    (_a = oldPick.pickedPoint) === null || _a === void 0 ? void 0 : _a.subtractToRef(newPick.pickedPoint, this._tmpVectorForPickCompare);
    this._tmpVectorForPickCompare.set(Math.abs(this._tmpVectorForPickCompare.x), Math.abs(this._tmpVectorForPickCompare.y), Math.abs(this._tmpVectorForPickCompare.z));
    var delta = (this._options.gazeModePointerMovedFactor || 1) * 0.01 * newPick.distance;
    var length = this._tmpVectorForPickCompare.length();
    if (length > delta) {
      return true;
    }
    return false;
  };
  WebXRControllerPointerSelection2.prototype._updatePointerDistance = function(_laserPointer, distance) {
    if (distance === void 0) {
      distance = 100;
    }
    _laserPointer.scaling.y = distance;
    if (this._scene.useRightHandedSystem) {
      distance *= -1;
    }
    _laserPointer.position.z = distance / 2 + 0.05;
  };
  Object.defineProperty(WebXRControllerPointerSelection2.prototype, "lasterPointerDefaultColor", {
    get: function() {
      return this.laserPointerDefaultColor;
    },
    enumerable: false,
    configurable: true
  });
  WebXRControllerPointerSelection2._idCounter = 200;
  WebXRControllerPointerSelection2.Name = WebXRFeatureName.POINTER_SELECTION;
  WebXRControllerPointerSelection2.Version = 1;
  return WebXRControllerPointerSelection2;
}(WebXRAbstractFeature);
WebXRFeaturesManager.AddWebXRFeature(WebXRControllerPointerSelection.Name, function(xrSessionManager, options) {
  return function() {
    return new WebXRControllerPointerSelection(xrSessionManager, options);
  };
}, WebXRControllerPointerSelection.Version, true);

// node_modules/@babylonjs/core/XR/webXREnterExitUI.js
var WebXREnterExitUIButton = function() {
  function WebXREnterExitUIButton2(element, sessionMode, referenceSpaceType) {
    this.element = element;
    this.sessionMode = sessionMode;
    this.referenceSpaceType = referenceSpaceType;
  }
  WebXREnterExitUIButton2.prototype.update = function(activeButton) {
  };
  return WebXREnterExitUIButton2;
}();
var WebXREnterExitUIOptions = function() {
  function WebXREnterExitUIOptions2() {
  }
  return WebXREnterExitUIOptions2;
}();
var WebXREnterExitUI = function() {
  function WebXREnterExitUI2(scene, options) {
    var _this = this;
    this.scene = scene;
    this.options = options;
    this._activeButton = null;
    this._buttons = [];
    this.activeButtonChangedObservable = new Observable();
    this.overlay = document.createElement("div");
    this.overlay.classList.add("xr-button-overlay");
    this.overlay.style.cssText = "z-index:11;position: absolute; right: 20px;bottom: 50px;";
    if (typeof window !== "undefined") {
      if (window.location && window.location.protocol === "http:") {
        Tools.Warn("WebXR can only be served over HTTPS");
      }
    }
    if (options.customButtons) {
      this._buttons = options.customButtons;
    } else {
      var sessionMode = options.sessionMode || "immersive-vr";
      var referenceSpaceType = options.referenceSpaceType || "local-floor";
      var url = typeof SVGSVGElement === "undefined" ? "https://cdn.babylonjs.com/Assets/vrButton.png" : "data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%222048%22%20height%3D%221152%22%20viewBox%3D%220%200%202048%201152%22%20version%3D%221.1%22%3E%3Cpath%20transform%3D%22rotate%28180%201024%2C576.0000000000001%29%22%20d%3D%22m1109%2C896q17%2C0%2030%2C-12t13%2C-30t-12.5%2C-30.5t-30.5%2C-12.5l-170%2C0q-18%2C0%20-30.5%2C12.5t-12.5%2C30.5t13%2C30t30%2C12l170%2C0zm-85%2C256q59%2C0%20132.5%2C-1.5t154.5%2C-5.5t164.5%2C-11.5t163%2C-20t150%2C-30t124.5%2C-41.5q23%2C-11%2042%2C-24t38%2C-30q27%2C-25%2041%2C-61.5t14%2C-72.5l0%2C-257q0%2C-123%20-47%2C-232t-128%2C-190t-190%2C-128t-232%2C-47l-81%2C0q-37%2C0%20-68.5%2C14t-60.5%2C34.5t-55.5%2C45t-53%2C45t-53%2C34.5t-55.5%2C14t-55.5%2C-14t-53%2C-34.5t-53%2C-45t-55.5%2C-45t-60.5%2C-34.5t-68.5%2C-14l-81%2C0q-123%2C0%20-232%2C47t-190%2C128t-128%2C190t-47%2C232l0%2C257q0%2C68%2038%2C115t97%2C73q54%2C24%20124.5%2C41.5t150%2C30t163%2C20t164.5%2C11.5t154.5%2C5.5t132.5%2C1.5zm939%2C-298q0%2C39%20-24.5%2C67t-58.5%2C42q-54%2C23%20-122%2C39.5t-143.5%2C28t-155.5%2C19t-157%2C11t-148.5%2C5t-129.5%2C1.5q-59%2C0%20-130%2C-1.5t-148%2C-5t-157%2C-11t-155.5%2C-19t-143.5%2C-28t-122%2C-39.5q-34%2C-14%20-58.5%2C-42t-24.5%2C-67l0%2C-257q0%2C-106%2040.5%2C-199t110%2C-162.5t162.5%2C-109.5t199%2C-40l81%2C0q27%2C0%2052%2C14t50%2C34.5t51%2C44.5t55.5%2C44.5t63.5%2C34.5t74%2C14t74%2C-14t63.5%2C-34.5t55.5%2C-44.5t51%2C-44.5t50%2C-34.5t52%2C-14l14%2C0q37%2C0%2070%2C0.5t64.5%2C4.5t63.5%2C12t68%2C23q71%2C30%20128.5%2C78.5t98.5%2C110t63.5%2C133.5t22.5%2C149l0%2C257z%22%20fill%3D%22white%22%20/%3E%3C/svg%3E%0A";
      var css = ".babylonVRicon { color: #868686; border-color: #868686; border-style: solid; margin-left: 10px; height: 50px; width: 80px; background-color: rgba(51,51,51,0.7); background-image: url(" + url + "); background-size: 80%; background-repeat:no-repeat; background-position: center; border: none; outline: none; transition: transform 0.125s ease-out } .babylonVRicon:hover { transform: scale(1.05) } .babylonVRicon:active {background-color: rgba(51,51,51,1) } .babylonVRicon:focus {background-color: rgba(51,51,51,1) }";
      css += '.babylonVRicon.vrdisplaypresenting { background-image: none;} .vrdisplaypresenting::after { content: "EXIT"} .xr-error::after { content: "ERROR"}';
      var style = document.createElement("style");
      style.appendChild(document.createTextNode(css));
      document.getElementsByTagName("head")[0].appendChild(style);
      var hmdBtn = document.createElement("button");
      hmdBtn.className = "babylonVRicon";
      hmdBtn.title = sessionMode + " - " + referenceSpaceType;
      this._buttons.push(new WebXREnterExitUIButton(hmdBtn, sessionMode, referenceSpaceType));
      this._buttons[this._buttons.length - 1].update = function(activeButton) {
        this.element.style.display = activeButton === null || activeButton === this ? "" : "none";
        hmdBtn.className = "babylonVRicon" + (activeButton === this ? " vrdisplaypresenting" : "");
      };
      this._updateButtons(null);
    }
    var renderCanvas = scene.getEngine().getInputElement();
    if (renderCanvas && renderCanvas.parentNode) {
      renderCanvas.parentNode.appendChild(this.overlay);
      scene.onDisposeObservable.addOnce(function() {
        _this.dispose();
      });
    }
  }
  WebXREnterExitUI2.CreateAsync = function(scene, helper, options) {
    var _this = this;
    var ui = new WebXREnterExitUI2(scene, options);
    var supportedPromises = ui._buttons.map(function(btn) {
      return helper.sessionManager.isSessionSupportedAsync(btn.sessionMode);
    });
    helper.onStateChangedObservable.add(function(state) {
      if (state == WebXRState.NOT_IN_XR) {
        ui._updateButtons(null);
      }
    });
    return Promise.all(supportedPromises).then(function(results) {
      results.forEach(function(supported, i) {
        if (supported) {
          ui.overlay.appendChild(ui._buttons[i].element);
          ui._buttons[i].element.onclick = function() {
            return __awaiter(_this, void 0, void 0, function() {
              var e_1, element, prevTitle;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    if (!(helper.state == WebXRState.IN_XR))
                      return [3, 2];
                    return [4, helper.exitXRAsync()];
                  case 1:
                    _a.sent();
                    ui._updateButtons(null);
                    return [3, 6];
                  case 2:
                    if (!(helper.state == WebXRState.NOT_IN_XR))
                      return [3, 6];
                    if (!options.renderTarget)
                      return [3, 6];
                    _a.label = 3;
                  case 3:
                    _a.trys.push([3, 5, , 6]);
                    return [4, helper.enterXRAsync(ui._buttons[i].sessionMode, ui._buttons[i].referenceSpaceType, options.renderTarget, { optionalFeatures: options.optionalFeatures, requiredFeatures: options.requiredFeatures })];
                  case 4:
                    _a.sent();
                    ui._updateButtons(ui._buttons[i]);
                    return [3, 6];
                  case 5:
                    e_1 = _a.sent();
                    ui._updateButtons(null);
                    element = ui._buttons[i].element;
                    prevTitle = element.title;
                    element.title = "Error entering XR session : " + prevTitle;
                    element.classList.add("xr-error");
                    if (options.onError) {
                      options.onError(e_1);
                    }
                    return [3, 6];
                  case 6:
                    return [2];
                }
              });
            });
          };
        } else {
          Tools.Warn('Session mode "' + ui._buttons[i].sessionMode + '" not supported in browser');
        }
      });
      return ui;
    });
  };
  WebXREnterExitUI2.prototype.dispose = function() {
    var renderCanvas = this.scene.getEngine().getInputElement();
    if (renderCanvas && renderCanvas.parentNode && renderCanvas.parentNode.contains(this.overlay)) {
      renderCanvas.parentNode.removeChild(this.overlay);
    }
    this.activeButtonChangedObservable.clear();
  };
  WebXREnterExitUI2.prototype._updateButtons = function(activeButton) {
    var _this = this;
    this._activeButton = activeButton;
    this._buttons.forEach(function(b) {
      b.update(_this._activeButton);
    });
    this.activeButtonChangedObservable.notifyObservers(this._activeButton);
  };
  return WebXREnterExitUI2;
}();

// node_modules/@babylonjs/core/Misc/timer.js
var TimerState;
(function(TimerState2) {
  TimerState2[TimerState2["INIT"] = 0] = "INIT";
  TimerState2[TimerState2["STARTED"] = 1] = "STARTED";
  TimerState2[TimerState2["ENDED"] = 2] = "ENDED";
})(TimerState || (TimerState = {}));
function setAndStartTimer(options) {
  var _a;
  var timer = 0;
  var startTime = Date.now();
  options.observableParameters = (_a = options.observableParameters) !== null && _a !== void 0 ? _a : {};
  var observer = options.contextObservable.add(function(payload) {
    var now = Date.now();
    timer = now - startTime;
    var data = {
      startTime,
      currentTime: now,
      deltaTime: timer,
      completeRate: timer / options.timeout,
      payload
    };
    options.onTick && options.onTick(data);
    if (options.breakCondition && options.breakCondition()) {
      options.contextObservable.remove(observer);
      options.onAborted && options.onAborted(data);
    }
    if (timer >= options.timeout) {
      options.contextObservable.remove(observer);
      options.onEnded && options.onEnded(data);
    }
  }, options.observableParameters.mask, options.observableParameters.insertFirst, options.observableParameters.scope);
  return observer;
}
var AdvancedTimer = function() {
  function AdvancedTimer2(options) {
    var _this = this;
    var _a, _b;
    this.onEachCountObservable = new Observable();
    this.onTimerAbortedObservable = new Observable();
    this.onTimerEndedObservable = new Observable();
    this.onStateChangedObservable = new Observable();
    this._observer = null;
    this._breakOnNextTick = false;
    this._tick = function(payload) {
      var now = Date.now();
      _this._timer = now - _this._startTime;
      var data = {
        startTime: _this._startTime,
        currentTime: now,
        deltaTime: _this._timer,
        completeRate: _this._timer / _this._timeToEnd,
        payload
      };
      var shouldBreak = _this._breakOnNextTick || _this._breakCondition(data);
      if (shouldBreak || _this._timer >= _this._timeToEnd) {
        _this._stop(data, shouldBreak);
      } else {
        _this.onEachCountObservable.notifyObservers(data);
      }
    };
    this._setState(TimerState.INIT);
    this._contextObservable = options.contextObservable;
    this._observableParameters = (_a = options.observableParameters) !== null && _a !== void 0 ? _a : {};
    this._breakCondition = (_b = options.breakCondition) !== null && _b !== void 0 ? _b : function() {
      return false;
    };
    if (options.onEnded) {
      this.onTimerEndedObservable.add(options.onEnded);
    }
    if (options.onTick) {
      this.onEachCountObservable.add(options.onTick);
    }
    if (options.onAborted) {
      this.onTimerAbortedObservable.add(options.onAborted);
    }
  }
  Object.defineProperty(AdvancedTimer2.prototype, "breakCondition", {
    set: function(predicate) {
      this._breakCondition = predicate;
    },
    enumerable: false,
    configurable: true
  });
  AdvancedTimer2.prototype.clearObservables = function() {
    this.onEachCountObservable.clear();
    this.onTimerAbortedObservable.clear();
    this.onTimerEndedObservable.clear();
    this.onStateChangedObservable.clear();
  };
  AdvancedTimer2.prototype.start = function(timeToEnd) {
    if (timeToEnd === void 0) {
      timeToEnd = this._timeToEnd;
    }
    if (this._state === TimerState.STARTED) {
      throw new Error("Timer already started. Please stop it before starting again");
    }
    this._timeToEnd = timeToEnd;
    this._startTime = Date.now();
    this._timer = 0;
    this._observer = this._contextObservable.add(this._tick, this._observableParameters.mask, this._observableParameters.insertFirst, this._observableParameters.scope);
    this._setState(TimerState.STARTED);
  };
  AdvancedTimer2.prototype.stop = function() {
    if (this._state !== TimerState.STARTED) {
      return;
    }
    this._breakOnNextTick = true;
  };
  AdvancedTimer2.prototype.dispose = function() {
    if (this._observer) {
      this._contextObservable.remove(this._observer);
    }
    this.clearObservables();
  };
  AdvancedTimer2.prototype._setState = function(newState) {
    this._state = newState;
    this.onStateChangedObservable.notifyObservers(this._state);
  };
  AdvancedTimer2.prototype._stop = function(data, aborted) {
    if (aborted === void 0) {
      aborted = false;
    }
    this._contextObservable.remove(this._observer);
    this._setState(TimerState.ENDED);
    if (aborted) {
      this.onTimerAbortedObservable.notifyObservers(data);
    } else {
      this.onTimerEndedObservable.notifyObservers(data);
    }
  };
  return AdvancedTimer2;
}();

// node_modules/@babylonjs/core/XR/features/WebXRControllerTeleportation.js
var WebXRMotionControllerTeleportation = function(_super) {
  __extends(WebXRMotionControllerTeleportation2, _super);
  function WebXRMotionControllerTeleportation2(_xrSessionManager, _options) {
    var _this = _super.call(this, _xrSessionManager) || this;
    _this._options = _options;
    _this._controllers = {};
    _this._snappedToPoint = false;
    _this._tmpRay = new Ray(new Vector3(), new Vector3());
    _this._tmpVector = new Vector3();
    _this._tmpQuaternion = new Quaternion();
    _this.backwardsMovementEnabled = true;
    _this.backwardsTeleportationDistance = 0.7;
    _this.parabolicCheckRadius = 5;
    _this.parabolicRayEnabled = true;
    _this.straightRayEnabled = true;
    _this.rotationAngle = Math.PI / 8;
    _this._rotationEnabled = true;
    _this._attachController = function(xrController) {
      if (_this._controllers[xrController.uniqueId] || _this._options.forceHandedness && xrController.inputSource.handedness !== _this._options.forceHandedness) {
        return;
      }
      _this._controllers[xrController.uniqueId] = {
        xrController,
        teleportationState: {
          forward: false,
          backwards: false,
          rotating: false,
          currentRotation: 0,
          baseRotation: 0
        }
      };
      var controllerData = _this._controllers[xrController.uniqueId];
      if (controllerData.xrController.inputSource.targetRayMode === "tracked-pointer" && controllerData.xrController.inputSource.gamepad) {
        var initMotionController_1 = function() {
          if (xrController.motionController) {
            var movementController = xrController.motionController.getComponentOfType(WebXRControllerComponent.THUMBSTICK_TYPE) || xrController.motionController.getComponentOfType(WebXRControllerComponent.TOUCHPAD_TYPE);
            if (!movementController || _this._options.useMainComponentOnly) {
              var mainComponent_1 = xrController.motionController.getMainComponent();
              if (!mainComponent_1) {
                return;
              }
              controllerData.teleportationComponent = mainComponent_1;
              controllerData.onButtonChangedObserver = mainComponent_1.onButtonStateChangedObservable.add(function() {
                if (mainComponent_1.changes.pressed) {
                  if (mainComponent_1.changes.pressed.current) {
                    controllerData.teleportationState.forward = true;
                    _this._currentTeleportationControllerId = controllerData.xrController.uniqueId;
                    controllerData.teleportationState.baseRotation = _this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;
                    controllerData.teleportationState.currentRotation = 0;
                    var timeToSelect = _this._options.timeToTeleport || 3e3;
                    setAndStartTimer({
                      timeout: timeToSelect,
                      contextObservable: _this._xrSessionManager.onXRFrameObservable,
                      breakCondition: function() {
                        return !mainComponent_1.pressed;
                      },
                      onEnded: function() {
                        if (_this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {
                          _this._teleportForward(xrController.uniqueId);
                        }
                      }
                    });
                  } else {
                    controllerData.teleportationState.forward = false;
                    _this._currentTeleportationControllerId = "";
                  }
                }
              });
            } else {
              controllerData.teleportationComponent = movementController;
              controllerData.onAxisChangedObserver = movementController.onAxisValueChangedObservable.add(function(axesData) {
                if (axesData.y <= 0.7 && controllerData.teleportationState.backwards) {
                  controllerData.teleportationState.backwards = false;
                }
                if (axesData.y > 0.7 && !controllerData.teleportationState.forward && _this.backwardsMovementEnabled && !_this.snapPointsOnly) {
                  if (!controllerData.teleportationState.backwards) {
                    controllerData.teleportationState.backwards = true;
                    _this._tmpQuaternion.copyFrom(_this._options.xrInput.xrCamera.rotationQuaternion);
                    _this._tmpQuaternion.toEulerAnglesToRef(_this._tmpVector);
                    _this._tmpVector.x = 0;
                    _this._tmpVector.z = 0;
                    Quaternion.FromEulerVectorToRef(_this._tmpVector, _this._tmpQuaternion);
                    _this._tmpVector.set(0, 0, _this.backwardsTeleportationDistance * (_this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1));
                    _this._tmpVector.rotateByQuaternionToRef(_this._tmpQuaternion, _this._tmpVector);
                    _this._tmpVector.addInPlace(_this._options.xrInput.xrCamera.position);
                    _this._tmpRay.origin.copyFrom(_this._tmpVector);
                    _this._tmpRay.length = _this._options.xrInput.xrCamera.realWorldHeight + 0.1;
                    _this._tmpRay.direction.set(0, -1, 0);
                    var pick = _this._xrSessionManager.scene.pickWithRay(_this._tmpRay, function(o) {
                      return _this._floorMeshes.indexOf(o) !== -1;
                    });
                    if (pick && pick.pickedPoint) {
                      _this._options.xrInput.xrCamera.position.x = pick.pickedPoint.x;
                      _this._options.xrInput.xrCamera.position.z = pick.pickedPoint.z;
                    }
                  }
                }
                if (axesData.y < -0.7 && !_this._currentTeleportationControllerId && !controllerData.teleportationState.rotating) {
                  controllerData.teleportationState.forward = true;
                  _this._currentTeleportationControllerId = controllerData.xrController.uniqueId;
                  controllerData.teleportationState.baseRotation = _this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;
                }
                if (axesData.x) {
                  if (!controllerData.teleportationState.forward) {
                    if (!controllerData.teleportationState.rotating && Math.abs(axesData.x) > 0.7) {
                      controllerData.teleportationState.rotating = true;
                      var rotation = _this.rotationAngle * (axesData.x > 0 ? 1 : -1) * (_this._xrSessionManager.scene.useRightHandedSystem ? -1 : 1);
                      _this._options.xrInput.xrCamera.rotationQuaternion.multiplyInPlace(Quaternion.FromEulerAngles(0, rotation, 0));
                    }
                  } else {
                    if (_this._currentTeleportationControllerId === controllerData.xrController.uniqueId) {
                      if (_this.rotationEnabled) {
                        setTimeout(function() {
                          controllerData.teleportationState.currentRotation = Math.atan2(axesData.x, axesData.y * (_this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1));
                        });
                      } else {
                        controllerData.teleportationState.currentRotation = 0;
                      }
                    }
                  }
                } else {
                  controllerData.teleportationState.rotating = false;
                }
                if (axesData.x === 0 && axesData.y === 0) {
                  if (controllerData.teleportationState.forward) {
                    _this._teleportForward(xrController.uniqueId);
                  }
                }
              });
            }
          }
        };
        if (xrController.motionController) {
          initMotionController_1();
        } else {
          xrController.onMotionControllerInitObservable.addOnce(function() {
            initMotionController_1();
          });
        }
      } else {
        _this._xrSessionManager.scene.onPointerObservable.add(function(pointerInfo) {
          if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {
            controllerData.teleportationState.forward = true;
            _this._currentTeleportationControllerId = controllerData.xrController.uniqueId;
            controllerData.teleportationState.baseRotation = _this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;
            controllerData.teleportationState.currentRotation = 0;
            var timeToSelect = _this._options.timeToTeleport || 3e3;
            setAndStartTimer({
              timeout: timeToSelect,
              contextObservable: _this._xrSessionManager.onXRFrameObservable,
              onEnded: function() {
                if (_this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {
                  _this._teleportForward(xrController.uniqueId);
                }
              }
            });
          } else if (pointerInfo.type === PointerEventTypes.POINTERUP) {
            controllerData.teleportationState.forward = false;
            _this._currentTeleportationControllerId = "";
          }
        });
      }
    };
    if (!_this._options.teleportationTargetMesh) {
      _this._createDefaultTargetMesh();
    }
    _this._floorMeshes = _this._options.floorMeshes || [];
    _this._snapToPositions = _this._options.snapPositions || [];
    _this._setTargetMeshVisibility(false);
    return _this;
  }
  Object.defineProperty(WebXRMotionControllerTeleportation2.prototype, "rotationEnabled", {
    get: function() {
      return this._rotationEnabled;
    },
    set: function(enabled) {
      this._rotationEnabled = enabled;
      if (this._options.teleportationTargetMesh) {
        var children = this._options.teleportationTargetMesh.getChildMeshes(false, function(node) {
          return node.name === "rotationCone";
        });
        if (children[0]) {
          children[0].setEnabled(enabled);
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebXRMotionControllerTeleportation2.prototype, "teleportationTargetMesh", {
    get: function() {
      return this._options.teleportationTargetMesh || null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebXRMotionControllerTeleportation2.prototype, "snapPointsOnly", {
    get: function() {
      return !!this._options.snapPointsOnly;
    },
    set: function(snapToPoints) {
      this._options.snapPointsOnly = snapToPoints;
    },
    enumerable: false,
    configurable: true
  });
  WebXRMotionControllerTeleportation2.prototype.addFloorMesh = function(mesh) {
    this._floorMeshes.push(mesh);
  };
  WebXRMotionControllerTeleportation2.prototype.addSnapPoint = function(newSnapPoint) {
    this._snapToPositions.push(newSnapPoint);
  };
  WebXRMotionControllerTeleportation2.prototype.attach = function() {
    var _this = this;
    if (!_super.prototype.attach.call(this)) {
      return false;
    }
    this._currentTeleportationControllerId = "";
    this._options.xrInput.controllers.forEach(this._attachController);
    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);
    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, function(controller) {
      _this._detachController(controller.uniqueId);
    });
    return true;
  };
  WebXRMotionControllerTeleportation2.prototype.detach = function() {
    var _this = this;
    if (!_super.prototype.detach.call(this)) {
      return false;
    }
    Object.keys(this._controllers).forEach(function(controllerId) {
      _this._detachController(controllerId);
    });
    this._setTargetMeshVisibility(false);
    this._currentTeleportationControllerId = "";
    this._controllers = {};
    return true;
  };
  WebXRMotionControllerTeleportation2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.dispose(false, true);
  };
  WebXRMotionControllerTeleportation2.prototype.removeFloorMesh = function(mesh) {
    var index = this._floorMeshes.indexOf(mesh);
    if (index !== -1) {
      this._floorMeshes.splice(index, 1);
    }
  };
  WebXRMotionControllerTeleportation2.prototype.removeFloorMeshByName = function(name98) {
    var mesh = this._xrSessionManager.scene.getMeshByName(name98);
    if (mesh) {
      this.removeFloorMesh(mesh);
    }
  };
  WebXRMotionControllerTeleportation2.prototype.removeSnapPoint = function(snapPointToRemove) {
    var index = this._snapToPositions.indexOf(snapPointToRemove);
    if (index === -1) {
      for (var i = 0; i < this._snapToPositions.length; ++i) {
        if (this._snapToPositions[i].equals(snapPointToRemove)) {
          index = i;
          break;
        }
      }
    }
    if (index !== -1) {
      this._snapToPositions.splice(index, 1);
      return true;
    }
    return false;
  };
  WebXRMotionControllerTeleportation2.prototype.setSelectionFeature = function(selectionFeature) {
    this._selectionFeature = selectionFeature;
  };
  WebXRMotionControllerTeleportation2.prototype._onXRFrame = function(_xrFrame) {
    var _this = this;
    var frame = this._xrSessionManager.currentFrame;
    var scene = this._xrSessionManager.scene;
    if (!this.attach || !frame) {
      return;
    }
    var targetMesh = this._options.teleportationTargetMesh;
    if (this._currentTeleportationControllerId) {
      if (!targetMesh) {
        return;
      }
      targetMesh.rotationQuaternion = targetMesh.rotationQuaternion || new Quaternion();
      var controllerData = this._controllers[this._currentTeleportationControllerId];
      if (controllerData && controllerData.teleportationState.forward) {
        Quaternion.RotationYawPitchRollToRef(controllerData.teleportationState.currentRotation + controllerData.teleportationState.baseRotation, 0, 0, targetMesh.rotationQuaternion);
        var hitPossible = false;
        controllerData.xrController.getWorldPointerRayToRef(this._tmpRay);
        if (this.straightRayEnabled) {
          var pick = scene.pickWithRay(this._tmpRay, function(o) {
            if (_this._options.pickBlockerMeshes && _this._options.pickBlockerMeshes.indexOf(o) !== -1) {
              return true;
            }
            var index = _this._floorMeshes.indexOf(o);
            if (index === -1) {
              return false;
            }
            return _this._floorMeshes[index].absolutePosition.y < _this._options.xrInput.xrCamera.position.y;
          });
          if (pick && pick.pickedMesh && this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(pick.pickedMesh) !== -1) {
            return;
          } else if (pick && pick.pickedPoint) {
            hitPossible = true;
            this._setTargetMeshPosition(pick.pickedPoint);
            this._setTargetMeshVisibility(true);
            this._showParabolicPath(pick);
          }
        }
        if (this.parabolicRayEnabled && !hitPossible) {
          var xRotation = controllerData.xrController.pointer.rotationQuaternion.toEulerAngles().x;
          var compensation = 1 + (Math.PI / 2 - Math.abs(xRotation));
          var radius = this.parabolicCheckRadius * compensation;
          this._tmpRay.origin.addToRef(this._tmpRay.direction.scale(radius * 2), this._tmpVector);
          this._tmpVector.y = this._tmpRay.origin.y;
          this._tmpRay.origin.addInPlace(this._tmpRay.direction.scale(radius));
          this._tmpVector.subtractToRef(this._tmpRay.origin, this._tmpRay.direction);
          this._tmpRay.direction.normalize();
          var pick = scene.pickWithRay(this._tmpRay, function(o) {
            if (_this._options.pickBlockerMeshes && _this._options.pickBlockerMeshes.indexOf(o) !== -1) {
              return true;
            }
            return _this._floorMeshes.indexOf(o) !== -1;
          });
          if (pick && pick.pickedMesh && this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(pick.pickedMesh) !== -1) {
            return;
          } else if (pick && pick.pickedPoint) {
            hitPossible = true;
            this._setTargetMeshPosition(pick.pickedPoint);
            this._setTargetMeshVisibility(true);
            this._showParabolicPath(pick);
          }
        }
        this._setTargetMeshVisibility(hitPossible);
      } else {
        this._setTargetMeshVisibility(false);
      }
    } else {
      this._setTargetMeshVisibility(false);
    }
  };
  WebXRMotionControllerTeleportation2.prototype._createDefaultTargetMesh = function() {
    this._options.defaultTargetMeshOptions = this._options.defaultTargetMeshOptions || {};
    var sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._xrSessionManager.scene;
    var teleportationTarget = GroundBuilder.CreateGround("teleportationTarget", { width: 2, height: 2, subdivisions: 2 }, sceneToRenderTo);
    teleportationTarget.isPickable = false;
    var length = 512;
    var dynamicTexture = new DynamicTexture("teleportationPlaneDynamicTexture", length, sceneToRenderTo, true);
    dynamicTexture.hasAlpha = true;
    var context = dynamicTexture.getContext();
    var centerX = length / 2;
    var centerY = length / 2;
    var radius = 200;
    context.beginPath();
    context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
    context.fillStyle = this._options.defaultTargetMeshOptions.teleportationFillColor || "#444444";
    context.fill();
    context.lineWidth = 10;
    context.strokeStyle = this._options.defaultTargetMeshOptions.teleportationBorderColor || "#FFFFFF";
    context.stroke();
    context.closePath();
    dynamicTexture.update();
    var teleportationCircleMaterial = new StandardMaterial("teleportationPlaneMaterial", sceneToRenderTo);
    teleportationCircleMaterial.diffuseTexture = dynamicTexture;
    teleportationTarget.material = teleportationCircleMaterial;
    var torus = TorusBuilder.CreateTorus("torusTeleportation", {
      diameter: 0.75,
      thickness: 0.1,
      tessellation: 20
    }, sceneToRenderTo);
    torus.isPickable = false;
    torus.parent = teleportationTarget;
    if (!this._options.defaultTargetMeshOptions.disableAnimation) {
      var animationInnerCircle = new Animation("animationInnerCircle", "position.y", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);
      var keys = [];
      keys.push({
        frame: 0,
        value: 0
      });
      keys.push({
        frame: 30,
        value: 0.4
      });
      keys.push({
        frame: 60,
        value: 0
      });
      animationInnerCircle.setKeys(keys);
      var easingFunction = new SineEase();
      easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);
      animationInnerCircle.setEasingFunction(easingFunction);
      torus.animations = [];
      torus.animations.push(animationInnerCircle);
      sceneToRenderTo.beginAnimation(torus, 0, 60, true);
    }
    var cone = CylinderBuilder.CreateCylinder("rotationCone", { diameterTop: 0, tessellation: 4 }, sceneToRenderTo);
    cone.isPickable = false;
    cone.scaling.set(0.5, 0.12, 0.2);
    cone.rotate(Axis.X, Math.PI / 2);
    cone.position.z = 0.6;
    cone.parent = torus;
    if (this._options.defaultTargetMeshOptions.torusArrowMaterial) {
      torus.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;
      cone.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;
    } else {
      var torusConeMaterial = new StandardMaterial("torusConsMat", sceneToRenderTo);
      torusConeMaterial.disableLighting = !!this._options.defaultTargetMeshOptions.disableLighting;
      if (torusConeMaterial.disableLighting) {
        torusConeMaterial.emissiveColor = new Color3(0.3, 0.3, 1);
      } else {
        torusConeMaterial.diffuseColor = new Color3(0.3, 0.3, 1);
      }
      torusConeMaterial.alpha = 0.9;
      torus.material = torusConeMaterial;
      cone.material = torusConeMaterial;
      this._teleportationRingMaterial = torusConeMaterial;
    }
    if (this._options.renderingGroupId !== void 0) {
      teleportationTarget.renderingGroupId = this._options.renderingGroupId;
      torus.renderingGroupId = this._options.renderingGroupId;
      cone.renderingGroupId = this._options.renderingGroupId;
    }
    this._options.teleportationTargetMesh = teleportationTarget;
  };
  WebXRMotionControllerTeleportation2.prototype._detachController = function(xrControllerUniqueId) {
    var controllerData = this._controllers[xrControllerUniqueId];
    if (!controllerData) {
      return;
    }
    if (controllerData.teleportationComponent) {
      if (controllerData.onAxisChangedObserver) {
        controllerData.teleportationComponent.onAxisValueChangedObservable.remove(controllerData.onAxisChangedObserver);
      }
      if (controllerData.onButtonChangedObserver) {
        controllerData.teleportationComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);
      }
    }
    delete this._controllers[xrControllerUniqueId];
  };
  WebXRMotionControllerTeleportation2.prototype._findClosestSnapPointWithRadius = function(realPosition, radius) {
    if (radius === void 0) {
      radius = this._options.snapToPositionRadius || 0.8;
    }
    var closestPoint = null;
    var closestDistance = Number.MAX_VALUE;
    if (this._snapToPositions.length) {
      var radiusSquared_1 = radius * radius;
      this._snapToPositions.forEach(function(position) {
        var dist = Vector3.DistanceSquared(position, realPosition);
        if (dist <= radiusSquared_1 && dist < closestDistance) {
          closestDistance = dist;
          closestPoint = position;
        }
      });
    }
    return closestPoint;
  };
  WebXRMotionControllerTeleportation2.prototype._setTargetMeshPosition = function(newPosition) {
    if (!this._options.teleportationTargetMesh) {
      return;
    }
    var snapPosition = this._findClosestSnapPointWithRadius(newPosition);
    this._snappedToPoint = !!snapPosition;
    if (this.snapPointsOnly && !this._snappedToPoint && this._teleportationRingMaterial) {
      this._teleportationRingMaterial.diffuseColor.set(1, 0.3, 0.3);
    } else if (this.snapPointsOnly && this._snappedToPoint && this._teleportationRingMaterial) {
      this._teleportationRingMaterial.diffuseColor.set(0.3, 0.3, 1);
    }
    this._options.teleportationTargetMesh.position.copyFrom(snapPosition || newPosition);
    this._options.teleportationTargetMesh.position.y += 0.01;
  };
  WebXRMotionControllerTeleportation2.prototype._setTargetMeshVisibility = function(visible) {
    if (!this._options.teleportationTargetMesh) {
      return;
    }
    if (this._options.teleportationTargetMesh.isVisible === visible) {
      return;
    }
    this._options.teleportationTargetMesh.isVisible = visible;
    this._options.teleportationTargetMesh.getChildren(void 0, false).forEach(function(m) {
      m.isVisible = visible;
    });
    if (!visible) {
      if (this._quadraticBezierCurve) {
        this._quadraticBezierCurve.dispose();
        this._quadraticBezierCurve = null;
      }
      if (this._selectionFeature) {
        this._selectionFeature.attach();
      }
    } else {
      if (this._selectionFeature) {
        this._selectionFeature.detach();
      }
    }
  };
  WebXRMotionControllerTeleportation2.prototype._showParabolicPath = function(pickInfo) {
    if (!pickInfo.pickedPoint) {
      return;
    }
    var controllerData = this._controllers[this._currentTeleportationControllerId];
    var quadraticBezierVectors = Curve3.CreateQuadraticBezier(controllerData.xrController.pointer.absolutePosition, pickInfo.ray.origin, pickInfo.pickedPoint, 25);
    if (!this._options.generateRayPathMesh) {
      this._quadraticBezierCurve = LinesBuilder.CreateLines("teleportation path line", { points: quadraticBezierVectors.getPoints(), instance: this._quadraticBezierCurve, updatable: true });
    } else {
      this._quadraticBezierCurve = this._options.generateRayPathMesh(quadraticBezierVectors.getPoints());
    }
    this._quadraticBezierCurve.isPickable = false;
  };
  WebXRMotionControllerTeleportation2.prototype._teleportForward = function(controllerId) {
    var controllerData = this._controllers[controllerId];
    if (!controllerData || !controllerData.teleportationState.forward) {
      return;
    }
    controllerData.teleportationState.forward = false;
    this._currentTeleportationControllerId = "";
    if (this.snapPointsOnly && !this._snappedToPoint) {
      return;
    }
    if (this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.isVisible) {
      var height = this._options.xrInput.xrCamera.realWorldHeight;
      this._options.xrInput.xrCamera.onBeforeCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);
      this._options.xrInput.xrCamera.position.copyFrom(this._options.teleportationTargetMesh.position);
      this._options.xrInput.xrCamera.position.y += height;
      this._options.xrInput.xrCamera.rotationQuaternion.multiplyInPlace(Quaternion.FromEulerAngles(0, controllerData.teleportationState.currentRotation - (this._xrSessionManager.scene.useRightHandedSystem ? Math.PI : 0), 0));
      this._options.xrInput.xrCamera.onAfterCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);
    }
  };
  WebXRMotionControllerTeleportation2.Name = WebXRFeatureName.TELEPORTATION;
  WebXRMotionControllerTeleportation2.Version = 1;
  return WebXRMotionControllerTeleportation2;
}(WebXRAbstractFeature);
WebXRFeaturesManager.AddWebXRFeature(WebXRMotionControllerTeleportation.Name, function(xrSessionManager, options) {
  return function() {
    return new WebXRMotionControllerTeleportation(xrSessionManager, options);
  };
}, WebXRMotionControllerTeleportation.Version, true);

// node_modules/@babylonjs/core/XR/webXRDefaultExperience.js
var WebXRDefaultExperienceOptions = function() {
  function WebXRDefaultExperienceOptions2() {
  }
  return WebXRDefaultExperienceOptions2;
}();
var WebXRDefaultExperience = function() {
  function WebXRDefaultExperience2() {
  }
  WebXRDefaultExperience2.CreateAsync = function(scene, options) {
    if (options === void 0) {
      options = {};
    }
    var result = new WebXRDefaultExperience2();
    return WebXRExperienceHelper.CreateAsync(scene).then(function(xrHelper) {
      result.baseExperience = xrHelper;
      if (options.ignoreNativeCameraTransformation) {
        result.baseExperience.camera.compensateOnFirstFrame = false;
      }
      result.input = new WebXRInput(xrHelper.sessionManager, xrHelper.camera, __assign({ controllerOptions: {
        renderingGroupId: options.renderingGroupId
      } }, options.inputOptions || {}));
      result.pointerSelection = result.baseExperience.featuresManager.enableFeature(WebXRControllerPointerSelection.Name, options.useStablePlugins ? "stable" : "latest", {
        xrInput: result.input,
        renderingGroupId: options.renderingGroupId
      });
      if (!options.disableTeleportation) {
        result.teleportation = result.baseExperience.featuresManager.enableFeature(WebXRMotionControllerTeleportation.Name, options.useStablePlugins ? "stable" : "latest", {
          floorMeshes: options.floorMeshes,
          xrInput: result.input,
          renderingGroupId: options.renderingGroupId
        });
        result.teleportation.setSelectionFeature(result.pointerSelection);
      }
      result.renderTarget = result.baseExperience.sessionManager.getWebXRRenderTarget(options.outputCanvasOptions);
      if (!options.disableDefaultUI) {
        var uiOptions = __assign({ renderTarget: result.renderTarget }, options.uiOptions || {});
        if (options.optionalFeatures) {
          if (typeof options.optionalFeatures === "boolean") {
            uiOptions.optionalFeatures = ["hit-test", "anchors", "plane-detection", "hand-tracking"];
          } else {
            uiOptions.optionalFeatures = options.optionalFeatures;
          }
        }
        return WebXREnterExitUI.CreateAsync(scene, result.baseExperience, uiOptions).then(function(ui) {
          result.enterExitUI = ui;
        });
      } else {
        return;
      }
    }).then(function() {
      return result;
    }).catch(function(error) {
      Logger.Error("Error initializing XR");
      Logger.Error(error);
      return result;
    });
  };
  WebXRDefaultExperience2.prototype.dispose = function() {
    if (this.baseExperience) {
      this.baseExperience.dispose();
    }
    if (this.input) {
      this.input.dispose();
    }
    if (this.enterExitUI) {
      this.enterExitUI.dispose();
    }
    if (this.renderTarget) {
      this.renderTarget.dispose();
    }
  };
  return WebXRDefaultExperience2;
}();

// node_modules/@babylonjs/core/Helpers/sceneHelpers.js
var _forceSceneHelpersToBundle = true;
Scene.prototype.createDefaultLight = function(replace) {
  if (replace === void 0) {
    replace = false;
  }
  if (replace) {
    if (this.lights) {
      for (var i = 0; i < this.lights.length; i++) {
        this.lights[i].dispose();
      }
    }
  }
  if (this.lights.length === 0) {
    new HemisphericLight("default light", Vector3.Up(), this);
  }
};
Scene.prototype.createDefaultCamera = function(createArcRotateCamera, replace, attachCameraControls) {
  if (createArcRotateCamera === void 0) {
    createArcRotateCamera = false;
  }
  if (replace === void 0) {
    replace = false;
  }
  if (attachCameraControls === void 0) {
    attachCameraControls = false;
  }
  if (replace) {
    if (this.activeCamera) {
      this.activeCamera.dispose();
      this.activeCamera = null;
    }
  }
  if (!this.activeCamera) {
    var worldExtends = this.getWorldExtends(function(mesh) {
      return mesh.isVisible && mesh.isEnabled();
    });
    var worldSize = worldExtends.max.subtract(worldExtends.min);
    var worldCenter = worldExtends.min.add(worldSize.scale(0.5));
    var camera;
    var radius = worldSize.length() * 1.5;
    if (!isFinite(radius)) {
      radius = 1;
      worldCenter.copyFromFloats(0, 0, 0);
    }
    if (createArcRotateCamera) {
      var arcRotateCamera = new ArcRotateCamera("default camera", -(Math.PI / 2), Math.PI / 2, radius, worldCenter, this);
      arcRotateCamera.lowerRadiusLimit = radius * 0.01;
      arcRotateCamera.wheelPrecision = 100 / radius;
      camera = arcRotateCamera;
    } else {
      var freeCamera = new FreeCamera("default camera", new Vector3(worldCenter.x, worldCenter.y, -radius), this);
      freeCamera.setTarget(worldCenter);
      camera = freeCamera;
    }
    camera.minZ = radius * 0.01;
    camera.maxZ = radius * 1e3;
    camera.speed = radius * 0.2;
    this.activeCamera = camera;
    var canvas = this.getEngine().getInputElement();
    if (attachCameraControls && canvas) {
      camera.attachControl();
    }
  }
};
Scene.prototype.createDefaultCameraOrLight = function(createArcRotateCamera, replace, attachCameraControls) {
  if (createArcRotateCamera === void 0) {
    createArcRotateCamera = false;
  }
  if (replace === void 0) {
    replace = false;
  }
  if (attachCameraControls === void 0) {
    attachCameraControls = false;
  }
  this.createDefaultLight(replace);
  this.createDefaultCamera(createArcRotateCamera, replace, attachCameraControls);
};
Scene.prototype.createDefaultSkybox = function(environmentTexture, pbr, scale, blur, setGlobalEnvTexture) {
  if (pbr === void 0) {
    pbr = false;
  }
  if (scale === void 0) {
    scale = 1e3;
  }
  if (blur === void 0) {
    blur = 0;
  }
  if (setGlobalEnvTexture === void 0) {
    setGlobalEnvTexture = true;
  }
  if (!environmentTexture) {
    Logger.Warn("Can not create default skybox without environment texture.");
    return null;
  }
  if (setGlobalEnvTexture) {
    if (environmentTexture) {
      this.environmentTexture = environmentTexture;
    }
  }
  var hdrSkybox = Mesh.CreateBox("hdrSkyBox", scale, this);
  if (pbr) {
    var hdrSkyboxMaterial = new PBRMaterial("skyBox", this);
    hdrSkyboxMaterial.backFaceCulling = false;
    hdrSkyboxMaterial.reflectionTexture = environmentTexture.clone();
    if (hdrSkyboxMaterial.reflectionTexture) {
      hdrSkyboxMaterial.reflectionTexture.coordinatesMode = Texture.SKYBOX_MODE;
    }
    hdrSkyboxMaterial.microSurface = 1 - blur;
    hdrSkyboxMaterial.disableLighting = true;
    hdrSkyboxMaterial.twoSidedLighting = true;
    hdrSkybox.infiniteDistance = true;
    hdrSkybox.material = hdrSkyboxMaterial;
  } else {
    var skyboxMaterial = new StandardMaterial("skyBox", this);
    skyboxMaterial.backFaceCulling = false;
    skyboxMaterial.reflectionTexture = environmentTexture.clone();
    if (skyboxMaterial.reflectionTexture) {
      skyboxMaterial.reflectionTexture.coordinatesMode = Texture.SKYBOX_MODE;
    }
    skyboxMaterial.disableLighting = true;
    hdrSkybox.infiniteDistance = true;
    hdrSkybox.material = skyboxMaterial;
  }
  hdrSkybox.isPickable = false;
  return hdrSkybox;
};
Scene.prototype.createDefaultEnvironment = function(options) {
  if (EnvironmentHelper) {
    return new EnvironmentHelper(options, this);
  }
  return null;
};
Scene.prototype.createDefaultVRExperience = function(webVROptions) {
  if (webVROptions === void 0) {
    webVROptions = {};
  }
  return new VRExperienceHelper(this, webVROptions);
};
Scene.prototype.createDefaultXRExperienceAsync = function(options) {
  if (options === void 0) {
    options = {};
  }
  return WebXRDefaultExperience.CreateAsync(this, options).then(function(helper) {
    return helper;
  });
};

// node_modules/@babylonjs/core/Materials/Textures/videoTexture.js
var VideoTexture = function(_super) {
  __extends(VideoTexture2, _super);
  function VideoTexture2(name98, src, scene, generateMipMaps, invertY, samplingMode, settings) {
    if (generateMipMaps === void 0) {
      generateMipMaps = false;
    }
    if (invertY === void 0) {
      invertY = false;
    }
    if (samplingMode === void 0) {
      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;
    }
    if (settings === void 0) {
      settings = {
        autoPlay: true,
        loop: true,
        autoUpdateTexture: true
      };
    }
    var _this = _super.call(this, null, scene, !generateMipMaps, invertY) || this;
    _this._onUserActionRequestedObservable = null;
    _this._stillImageCaptured = false;
    _this._displayingPosterTexture = false;
    _this._frameId = -1;
    _this._currentSrc = null;
    _this._createInternalTexture = function() {
      if (_this._texture != null) {
        if (_this._displayingPosterTexture) {
          _this._texture.dispose();
          _this._displayingPosterTexture = false;
        } else {
          return;
        }
      }
      if (!_this._getEngine().needPOTTextures || Tools.IsExponentOfTwo(_this.video.videoWidth) && Tools.IsExponentOfTwo(_this.video.videoHeight)) {
        _this.wrapU = Texture.WRAP_ADDRESSMODE;
        _this.wrapV = Texture.WRAP_ADDRESSMODE;
      } else {
        _this.wrapU = Texture.CLAMP_ADDRESSMODE;
        _this.wrapV = Texture.CLAMP_ADDRESSMODE;
        _this._generateMipMaps = false;
      }
      _this._texture = _this._getEngine().createDynamicTexture(_this.video.videoWidth, _this.video.videoHeight, _this._generateMipMaps, _this.samplingMode);
      if (!_this.video.autoplay && !_this._settings.poster) {
        var oldHandler_1 = _this.video.onplaying;
        var error_1 = false;
        var oldMuted_1 = _this.video.muted;
        _this.video.muted = true;
        _this.video.onplaying = function() {
          _this.video.muted = oldMuted_1;
          _this.video.onplaying = oldHandler_1;
          _this._texture.isReady = true;
          _this._updateInternalTexture();
          if (!error_1) {
            _this.video.pause();
          }
          if (_this.onLoadObservable.hasObservers()) {
            _this.onLoadObservable.notifyObservers(_this);
          }
        };
        var playing = _this.video.play();
        if (playing) {
          playing.then(function() {
          }).catch(function() {
            error_1 = true;
            if (_this._onUserActionRequestedObservable && _this._onUserActionRequestedObservable.hasObservers()) {
              _this._onUserActionRequestedObservable.notifyObservers(_this);
            }
          });
        } else {
          _this.video.onplaying = oldHandler_1;
          _this._texture.isReady = true;
          _this._updateInternalTexture();
          if (_this.onLoadObservable.hasObservers()) {
            _this.onLoadObservable.notifyObservers(_this);
          }
        }
      } else {
        _this._texture.isReady = true;
        _this._updateInternalTexture();
        if (_this.onLoadObservable.hasObservers()) {
          _this.onLoadObservable.notifyObservers(_this);
        }
      }
    };
    _this.reset = function() {
      if (_this._texture == null) {
        return;
      }
      if (!_this._displayingPosterTexture) {
        _this._texture.dispose();
        _this._texture = null;
      }
    };
    _this._updateInternalTexture = function() {
      if (_this._texture == null || !_this._texture.isReady) {
        return;
      }
      if (_this.video.readyState < _this.video.HAVE_CURRENT_DATA) {
        return;
      }
      if (_this._displayingPosterTexture) {
        return;
      }
      var frameId = _this.getScene().getFrameId();
      if (_this._frameId === frameId) {
        return;
      }
      _this._frameId = frameId;
      _this._getEngine().updateVideoTexture(_this._texture, _this.video, _this._invertY);
    };
    _this._generateMipMaps = generateMipMaps;
    _this._initialSamplingMode = samplingMode;
    _this.autoUpdateTexture = settings.autoUpdateTexture;
    _this._currentSrc = src;
    _this.name = name98 || _this._getName(src);
    _this.video = _this._getVideo(src);
    _this._settings = settings;
    if (settings.poster) {
      _this.video.poster = settings.poster;
    }
    if (settings.autoPlay !== void 0) {
      _this.video.autoplay = settings.autoPlay;
    }
    if (settings.loop !== void 0) {
      _this.video.loop = settings.loop;
    }
    if (settings.muted !== void 0) {
      _this.video.muted = settings.muted;
    }
    _this.video.setAttribute("playsinline", "");
    _this.video.addEventListener("paused", _this._updateInternalTexture);
    _this.video.addEventListener("seeked", _this._updateInternalTexture);
    _this.video.addEventListener("emptied", _this.reset);
    _this._createInternalTextureOnEvent = settings.poster && !settings.autoPlay ? "play" : "canplay";
    _this.video.addEventListener(_this._createInternalTextureOnEvent, _this._createInternalTexture);
    if (settings.autoPlay) {
      _this.video.play();
    }
    var videoHasEnoughData = _this.video.readyState >= _this.video.HAVE_CURRENT_DATA;
    if (settings.poster && (!settings.autoPlay || !videoHasEnoughData)) {
      _this._texture = _this._getEngine().createTexture(settings.poster, false, !_this.invertY, scene);
      _this._displayingPosterTexture = true;
    } else if (videoHasEnoughData) {
      _this._createInternalTexture();
    }
    return _this;
  }
  Object.defineProperty(VideoTexture2.prototype, "onUserActionRequestedObservable", {
    get: function() {
      if (!this._onUserActionRequestedObservable) {
        this._onUserActionRequestedObservable = new Observable();
      }
      return this._onUserActionRequestedObservable;
    },
    enumerable: false,
    configurable: true
  });
  VideoTexture2.prototype._getName = function(src) {
    if (src instanceof HTMLVideoElement) {
      return src.currentSrc;
    }
    if (typeof src === "object") {
      return src.toString();
    }
    return src;
  };
  VideoTexture2.prototype._getVideo = function(src) {
    if (src instanceof HTMLVideoElement) {
      Tools.SetCorsBehavior(src.currentSrc, src);
      return src;
    }
    var video = document.createElement("video");
    if (typeof src === "string") {
      Tools.SetCorsBehavior(src, video);
      video.src = src;
    } else {
      Tools.SetCorsBehavior(src[0], video);
      src.forEach(function(url) {
        var source = document.createElement("source");
        source.src = url;
        video.appendChild(source);
      });
    }
    return video;
  };
  VideoTexture2.prototype._rebuild = function() {
    this.update();
  };
  VideoTexture2.prototype.update = function() {
    if (!this.autoUpdateTexture) {
      return;
    }
    this.updateTexture(true);
  };
  VideoTexture2.prototype.updateTexture = function(isVisible) {
    if (!isVisible) {
      return;
    }
    if (this.video.paused && this._stillImageCaptured) {
      return;
    }
    this._stillImageCaptured = true;
    this._updateInternalTexture();
  };
  VideoTexture2.prototype.updateURL = function(url) {
    this.video.src = url;
    this._currentSrc = url;
  };
  VideoTexture2.prototype.clone = function() {
    return new VideoTexture2(this.name, this._currentSrc, this.getScene(), this._generateMipMaps, this.invertY, this.samplingMode, this._settings);
  };
  VideoTexture2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this._currentSrc = null;
    if (this._onUserActionRequestedObservable) {
      this._onUserActionRequestedObservable.clear();
      this._onUserActionRequestedObservable = null;
    }
    this.video.removeEventListener(this._createInternalTextureOnEvent, this._createInternalTexture);
    this.video.removeEventListener("paused", this._updateInternalTexture);
    this.video.removeEventListener("seeked", this._updateInternalTexture);
    this.video.removeEventListener("emptied", this.reset);
    this.video.pause();
  };
  VideoTexture2.CreateFromStreamAsync = function(scene, stream) {
    var video = document.createElement("video");
    if (scene.getEngine()._badOS) {
      document.body.appendChild(video);
      video.style.transform = "scale(0.0001, 0.0001)";
      video.style.opacity = "0";
      video.style.position = "fixed";
      video.style.bottom = "0px";
      video.style.right = "0px";
    }
    video.setAttribute("autoplay", "");
    video.setAttribute("muted", "true");
    video.setAttribute("playsinline", "");
    video.muted = true;
    if (video.mozSrcObject !== void 0) {
      video.mozSrcObject = stream;
    } else {
      if (typeof video.srcObject == "object") {
        video.srcObject = stream;
      } else {
        window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;
        video.src = window.URL && window.URL.createObjectURL(stream);
      }
    }
    return new Promise(function(resolve) {
      var onPlaying = function() {
        resolve(new VideoTexture2("video", video, scene, true, true));
        video.removeEventListener("playing", onPlaying);
      };
      video.addEventListener("playing", onPlaying);
      video.play();
    });
  };
  VideoTexture2.CreateFromWebCamAsync = function(scene, constraints, audioConstaints) {
    var _this = this;
    if (audioConstaints === void 0) {
      audioConstaints = false;
    }
    var constraintsDeviceId;
    if (constraints && constraints.deviceId) {
      constraintsDeviceId = {
        exact: constraints.deviceId
      };
    }
    if (navigator.mediaDevices) {
      return navigator.mediaDevices.getUserMedia({
        video: constraints,
        audio: audioConstaints
      }).then(function(stream) {
        return _this.CreateFromStreamAsync(scene, stream);
      });
    } else {
      navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
      if (navigator.getUserMedia) {
        navigator.getUserMedia({
          video: {
            deviceId: constraintsDeviceId,
            width: {
              min: constraints && constraints.minWidth || 256,
              max: constraints && constraints.maxWidth || 640
            },
            height: {
              min: constraints && constraints.minHeight || 256,
              max: constraints && constraints.maxHeight || 480
            }
          },
          audio: audioConstaints
        }, function(stream) {
          return _this.CreateFromStreamAsync(scene, stream);
        }, function(e) {
          Logger.Error(e.name);
        });
      }
    }
    return Promise.reject("No support for userMedia on this device");
  };
  VideoTexture2.CreateFromWebCam = function(scene, onReady, constraints, audioConstaints) {
    if (audioConstaints === void 0) {
      audioConstaints = false;
    }
    this.CreateFromWebCamAsync(scene, constraints, audioConstaints).then(function(videoTexture) {
      if (onReady) {
        onReady(videoTexture);
      }
    }).catch(function(err) {
      Logger.Error(err.name);
    });
  };
  return VideoTexture2;
}(Texture);

// node_modules/@babylonjs/core/Helpers/videoDome.js
var VideoDome = function(_super) {
  __extends(VideoDome2, _super);
  function VideoDome2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Object.defineProperty(VideoDome2.prototype, "videoTexture", {
    get: function() {
      return this._texture;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VideoDome2.prototype, "videoMode", {
    get: function() {
      return this.textureMode;
    },
    set: function(value) {
      this.textureMode = value;
    },
    enumerable: false,
    configurable: true
  });
  VideoDome2.prototype._initTexture = function(urlsOrElement, scene, options) {
    var _this = this;
    var tempOptions = { loop: options.loop, autoPlay: options.autoPlay, autoUpdateTexture: true, poster: options.poster };
    var texture = new VideoTexture((this.name || "videoDome") + "_texture", urlsOrElement, scene, options.generateMipMaps, this._useDirectMapping, Texture.TRILINEAR_SAMPLINGMODE, tempOptions);
    if (options.clickToPlay) {
      scene.onPointerUp = function() {
        _this._texture.video.play();
      };
    }
    return texture;
  };
  VideoDome2.MODE_MONOSCOPIC = TextureDome.MODE_MONOSCOPIC;
  VideoDome2.MODE_TOPBOTTOM = TextureDome.MODE_TOPBOTTOM;
  VideoDome2.MODE_SIDEBYSIDE = TextureDome.MODE_SIDEBYSIDE;
  return VideoDome2;
}(TextureDome);

// node_modules/@babylonjs/core/Instrumentation/engineInstrumentation.js
var EngineInstrumentation = function() {
  function EngineInstrumentation2(engine) {
    this.engine = engine;
    this._captureGPUFrameTime = false;
    this._gpuFrameTime = new PerfCounter();
    this._captureShaderCompilationTime = false;
    this._shaderCompilationTime = new PerfCounter();
    this._onBeginFrameObserver = null;
    this._onEndFrameObserver = null;
    this._onBeforeShaderCompilationObserver = null;
    this._onAfterShaderCompilationObserver = null;
  }
  Object.defineProperty(EngineInstrumentation2.prototype, "gpuFrameTimeCounter", {
    get: function() {
      return this._gpuFrameTime;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EngineInstrumentation2.prototype, "captureGPUFrameTime", {
    get: function() {
      return this._captureGPUFrameTime;
    },
    set: function(value) {
      var _this = this;
      if (value === this._captureGPUFrameTime) {
        return;
      }
      this._captureGPUFrameTime = value;
      if (value) {
        this._onBeginFrameObserver = this.engine.onBeginFrameObservable.add(function() {
          if (!_this._gpuFrameTimeToken) {
            _this._gpuFrameTimeToken = _this.engine.startTimeQuery();
          }
        });
        this._onEndFrameObserver = this.engine.onEndFrameObservable.add(function() {
          if (!_this._gpuFrameTimeToken) {
            return;
          }
          var time = _this.engine.endTimeQuery(_this._gpuFrameTimeToken);
          if (time > -1) {
            _this._gpuFrameTimeToken = null;
            _this._gpuFrameTime.fetchNewFrame();
            _this._gpuFrameTime.addCount(time, true);
          }
        });
      } else {
        this.engine.onBeginFrameObservable.remove(this._onBeginFrameObserver);
        this._onBeginFrameObserver = null;
        this.engine.onEndFrameObservable.remove(this._onEndFrameObserver);
        this._onEndFrameObserver = null;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EngineInstrumentation2.prototype, "shaderCompilationTimeCounter", {
    get: function() {
      return this._shaderCompilationTime;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EngineInstrumentation2.prototype, "captureShaderCompilationTime", {
    get: function() {
      return this._captureShaderCompilationTime;
    },
    set: function(value) {
      var _this = this;
      if (value === this._captureShaderCompilationTime) {
        return;
      }
      this._captureShaderCompilationTime = value;
      if (value) {
        this._onBeforeShaderCompilationObserver = this.engine.onBeforeShaderCompilationObservable.add(function() {
          _this._shaderCompilationTime.fetchNewFrame();
          _this._shaderCompilationTime.beginMonitoring();
        });
        this._onAfterShaderCompilationObserver = this.engine.onAfterShaderCompilationObservable.add(function() {
          _this._shaderCompilationTime.endMonitoring();
        });
      } else {
        this.engine.onBeforeShaderCompilationObservable.remove(this._onBeforeShaderCompilationObserver);
        this._onBeforeShaderCompilationObserver = null;
        this.engine.onAfterShaderCompilationObservable.remove(this._onAfterShaderCompilationObserver);
        this._onAfterShaderCompilationObserver = null;
      }
    },
    enumerable: false,
    configurable: true
  });
  EngineInstrumentation2.prototype.dispose = function() {
    this.engine.onBeginFrameObservable.remove(this._onBeginFrameObserver);
    this._onBeginFrameObserver = null;
    this.engine.onEndFrameObservable.remove(this._onEndFrameObserver);
    this._onEndFrameObserver = null;
    this.engine.onBeforeShaderCompilationObservable.remove(this._onBeforeShaderCompilationObserver);
    this._onBeforeShaderCompilationObserver = null;
    this.engine.onAfterShaderCompilationObservable.remove(this._onAfterShaderCompilationObserver);
    this._onAfterShaderCompilationObserver = null;
    this.engine = null;
  };
  return EngineInstrumentation2;
}();

// node_modules/@babylonjs/core/Instrumentation/sceneInstrumentation.js
var SceneInstrumentation = function() {
  function SceneInstrumentation2(scene) {
    var _this = this;
    this.scene = scene;
    this._captureActiveMeshesEvaluationTime = false;
    this._activeMeshesEvaluationTime = new PerfCounter();
    this._captureRenderTargetsRenderTime = false;
    this._renderTargetsRenderTime = new PerfCounter();
    this._captureFrameTime = false;
    this._frameTime = new PerfCounter();
    this._captureRenderTime = false;
    this._renderTime = new PerfCounter();
    this._captureInterFrameTime = false;
    this._interFrameTime = new PerfCounter();
    this._captureParticlesRenderTime = false;
    this._particlesRenderTime = new PerfCounter();
    this._captureSpritesRenderTime = false;
    this._spritesRenderTime = new PerfCounter();
    this._capturePhysicsTime = false;
    this._physicsTime = new PerfCounter();
    this._captureAnimationsTime = false;
    this._animationsTime = new PerfCounter();
    this._captureCameraRenderTime = false;
    this._cameraRenderTime = new PerfCounter();
    this._onBeforeActiveMeshesEvaluationObserver = null;
    this._onAfterActiveMeshesEvaluationObserver = null;
    this._onBeforeRenderTargetsRenderObserver = null;
    this._onAfterRenderTargetsRenderObserver = null;
    this._onAfterRenderObserver = null;
    this._onBeforeDrawPhaseObserver = null;
    this._onAfterDrawPhaseObserver = null;
    this._onBeforeAnimationsObserver = null;
    this._onBeforeParticlesRenderingObserver = null;
    this._onAfterParticlesRenderingObserver = null;
    this._onBeforeSpritesRenderingObserver = null;
    this._onAfterSpritesRenderingObserver = null;
    this._onBeforePhysicsObserver = null;
    this._onAfterPhysicsObserver = null;
    this._onAfterAnimationsObserver = null;
    this._onBeforeCameraRenderObserver = null;
    this._onAfterCameraRenderObserver = null;
    this._onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(function() {
      if (_this._captureActiveMeshesEvaluationTime) {
        _this._activeMeshesEvaluationTime.fetchNewFrame();
      }
      if (_this._captureRenderTargetsRenderTime) {
        _this._renderTargetsRenderTime.fetchNewFrame();
      }
      if (_this._captureFrameTime) {
        Tools.StartPerformanceCounter("Scene rendering");
        _this._frameTime.beginMonitoring();
      }
      if (_this._captureInterFrameTime) {
        _this._interFrameTime.endMonitoring();
      }
      if (_this._captureParticlesRenderTime) {
        _this._particlesRenderTime.fetchNewFrame();
      }
      if (_this._captureSpritesRenderTime) {
        _this._spritesRenderTime.fetchNewFrame();
      }
      if (_this._captureAnimationsTime) {
        _this._animationsTime.beginMonitoring();
      }
      _this.scene.getEngine()._drawCalls.fetchNewFrame();
    });
    this._onAfterRenderObserver = scene.onAfterRenderObservable.add(function() {
      if (_this._captureFrameTime) {
        Tools.EndPerformanceCounter("Scene rendering");
        _this._frameTime.endMonitoring();
      }
      if (_this._captureRenderTime) {
        _this._renderTime.endMonitoring(false);
      }
      if (_this._captureInterFrameTime) {
        _this._interFrameTime.beginMonitoring();
      }
    });
  }
  Object.defineProperty(SceneInstrumentation2.prototype, "activeMeshesEvaluationTimeCounter", {
    get: function() {
      return this._activeMeshesEvaluationTime;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneInstrumentation2.prototype, "captureActiveMeshesEvaluationTime", {
    get: function() {
      return this._captureActiveMeshesEvaluationTime;
    },
    set: function(value) {
      var _this = this;
      if (value === this._captureActiveMeshesEvaluationTime) {
        return;
      }
      this._captureActiveMeshesEvaluationTime = value;
      if (value) {
        this._onBeforeActiveMeshesEvaluationObserver = this.scene.onBeforeActiveMeshesEvaluationObservable.add(function() {
          Tools.StartPerformanceCounter("Active meshes evaluation");
          _this._activeMeshesEvaluationTime.beginMonitoring();
        });
        this._onAfterActiveMeshesEvaluationObserver = this.scene.onAfterActiveMeshesEvaluationObservable.add(function() {
          Tools.EndPerformanceCounter("Active meshes evaluation");
          _this._activeMeshesEvaluationTime.endMonitoring();
        });
      } else {
        this.scene.onBeforeActiveMeshesEvaluationObservable.remove(this._onBeforeActiveMeshesEvaluationObserver);
        this._onBeforeActiveMeshesEvaluationObserver = null;
        this.scene.onAfterActiveMeshesEvaluationObservable.remove(this._onAfterActiveMeshesEvaluationObserver);
        this._onAfterActiveMeshesEvaluationObserver = null;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneInstrumentation2.prototype, "renderTargetsRenderTimeCounter", {
    get: function() {
      return this._renderTargetsRenderTime;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneInstrumentation2.prototype, "captureRenderTargetsRenderTime", {
    get: function() {
      return this._captureRenderTargetsRenderTime;
    },
    set: function(value) {
      var _this = this;
      if (value === this._captureRenderTargetsRenderTime) {
        return;
      }
      this._captureRenderTargetsRenderTime = value;
      if (value) {
        this._onBeforeRenderTargetsRenderObserver = this.scene.onBeforeRenderTargetsRenderObservable.add(function() {
          Tools.StartPerformanceCounter("Render targets rendering");
          _this._renderTargetsRenderTime.beginMonitoring();
        });
        this._onAfterRenderTargetsRenderObserver = this.scene.onAfterRenderTargetsRenderObservable.add(function() {
          Tools.EndPerformanceCounter("Render targets rendering");
          _this._renderTargetsRenderTime.endMonitoring(false);
        });
      } else {
        this.scene.onBeforeRenderTargetsRenderObservable.remove(this._onBeforeRenderTargetsRenderObserver);
        this._onBeforeRenderTargetsRenderObserver = null;
        this.scene.onAfterRenderTargetsRenderObservable.remove(this._onAfterRenderTargetsRenderObserver);
        this._onAfterRenderTargetsRenderObserver = null;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneInstrumentation2.prototype, "particlesRenderTimeCounter", {
    get: function() {
      return this._particlesRenderTime;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneInstrumentation2.prototype, "captureParticlesRenderTime", {
    get: function() {
      return this._captureParticlesRenderTime;
    },
    set: function(value) {
      var _this = this;
      if (value === this._captureParticlesRenderTime) {
        return;
      }
      this._captureParticlesRenderTime = value;
      if (value) {
        this._onBeforeParticlesRenderingObserver = this.scene.onBeforeParticlesRenderingObservable.add(function() {
          Tools.StartPerformanceCounter("Particles");
          _this._particlesRenderTime.beginMonitoring();
        });
        this._onAfterParticlesRenderingObserver = this.scene.onAfterParticlesRenderingObservable.add(function() {
          Tools.EndPerformanceCounter("Particles");
          _this._particlesRenderTime.endMonitoring(false);
        });
      } else {
        this.scene.onBeforeParticlesRenderingObservable.remove(this._onBeforeParticlesRenderingObserver);
        this._onBeforeParticlesRenderingObserver = null;
        this.scene.onAfterParticlesRenderingObservable.remove(this._onAfterParticlesRenderingObserver);
        this._onAfterParticlesRenderingObserver = null;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneInstrumentation2.prototype, "spritesRenderTimeCounter", {
    get: function() {
      return this._spritesRenderTime;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneInstrumentation2.prototype, "captureSpritesRenderTime", {
    get: function() {
      return this._captureSpritesRenderTime;
    },
    set: function(value) {
      var _this = this;
      if (value === this._captureSpritesRenderTime) {
        return;
      }
      this._captureSpritesRenderTime = value;
      if (!this.scene.spriteManagers) {
        return;
      }
      if (value) {
        this._onBeforeSpritesRenderingObserver = this.scene.onBeforeSpritesRenderingObservable.add(function() {
          Tools.StartPerformanceCounter("Sprites");
          _this._spritesRenderTime.beginMonitoring();
        });
        this._onAfterSpritesRenderingObserver = this.scene.onAfterSpritesRenderingObservable.add(function() {
          Tools.EndPerformanceCounter("Sprites");
          _this._spritesRenderTime.endMonitoring(false);
        });
      } else {
        this.scene.onBeforeSpritesRenderingObservable.remove(this._onBeforeSpritesRenderingObserver);
        this._onBeforeSpritesRenderingObserver = null;
        this.scene.onAfterSpritesRenderingObservable.remove(this._onAfterSpritesRenderingObserver);
        this._onAfterSpritesRenderingObserver = null;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneInstrumentation2.prototype, "physicsTimeCounter", {
    get: function() {
      return this._physicsTime;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneInstrumentation2.prototype, "capturePhysicsTime", {
    get: function() {
      return this._capturePhysicsTime;
    },
    set: function(value) {
      var _this = this;
      if (value === this._capturePhysicsTime) {
        return;
      }
      if (!this.scene.onBeforePhysicsObservable) {
        return;
      }
      this._capturePhysicsTime = value;
      if (value) {
        this._onBeforePhysicsObserver = this.scene.onBeforePhysicsObservable.add(function() {
          Tools.StartPerformanceCounter("Physics");
          _this._physicsTime.beginMonitoring();
        });
        this._onAfterPhysicsObserver = this.scene.onAfterPhysicsObservable.add(function() {
          Tools.EndPerformanceCounter("Physics");
          _this._physicsTime.endMonitoring();
        });
      } else {
        this.scene.onBeforePhysicsObservable.remove(this._onBeforePhysicsObserver);
        this._onBeforePhysicsObserver = null;
        this.scene.onAfterPhysicsObservable.remove(this._onAfterPhysicsObserver);
        this._onAfterPhysicsObserver = null;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneInstrumentation2.prototype, "animationsTimeCounter", {
    get: function() {
      return this._animationsTime;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneInstrumentation2.prototype, "captureAnimationsTime", {
    get: function() {
      return this._captureAnimationsTime;
    },
    set: function(value) {
      var _this = this;
      if (value === this._captureAnimationsTime) {
        return;
      }
      this._captureAnimationsTime = value;
      if (value) {
        this._onAfterAnimationsObserver = this.scene.onAfterAnimationsObservable.add(function() {
          _this._animationsTime.endMonitoring();
        });
      } else {
        this.scene.onAfterAnimationsObservable.remove(this._onAfterAnimationsObserver);
        this._onAfterAnimationsObserver = null;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneInstrumentation2.prototype, "frameTimeCounter", {
    get: function() {
      return this._frameTime;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneInstrumentation2.prototype, "captureFrameTime", {
    get: function() {
      return this._captureFrameTime;
    },
    set: function(value) {
      this._captureFrameTime = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneInstrumentation2.prototype, "interFrameTimeCounter", {
    get: function() {
      return this._interFrameTime;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneInstrumentation2.prototype, "captureInterFrameTime", {
    get: function() {
      return this._captureInterFrameTime;
    },
    set: function(value) {
      this._captureInterFrameTime = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneInstrumentation2.prototype, "renderTimeCounter", {
    get: function() {
      return this._renderTime;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneInstrumentation2.prototype, "captureRenderTime", {
    get: function() {
      return this._captureRenderTime;
    },
    set: function(value) {
      var _this = this;
      if (value === this._captureRenderTime) {
        return;
      }
      this._captureRenderTime = value;
      if (value) {
        this._onBeforeDrawPhaseObserver = this.scene.onBeforeDrawPhaseObservable.add(function() {
          _this._renderTime.beginMonitoring();
          Tools.StartPerformanceCounter("Main render");
        });
        this._onAfterDrawPhaseObserver = this.scene.onAfterDrawPhaseObservable.add(function() {
          _this._renderTime.endMonitoring(false);
          Tools.EndPerformanceCounter("Main render");
        });
      } else {
        this.scene.onBeforeDrawPhaseObservable.remove(this._onBeforeDrawPhaseObserver);
        this._onBeforeDrawPhaseObserver = null;
        this.scene.onAfterDrawPhaseObservable.remove(this._onAfterDrawPhaseObserver);
        this._onAfterDrawPhaseObserver = null;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneInstrumentation2.prototype, "cameraRenderTimeCounter", {
    get: function() {
      return this._cameraRenderTime;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneInstrumentation2.prototype, "captureCameraRenderTime", {
    get: function() {
      return this._captureCameraRenderTime;
    },
    set: function(value) {
      var _this = this;
      if (value === this._captureCameraRenderTime) {
        return;
      }
      this._captureCameraRenderTime = value;
      if (value) {
        this._onBeforeCameraRenderObserver = this.scene.onBeforeCameraRenderObservable.add(function(camera) {
          _this._cameraRenderTime.beginMonitoring();
          Tools.StartPerformanceCounter("Rendering camera " + camera.name);
        });
        this._onAfterCameraRenderObserver = this.scene.onAfterCameraRenderObservable.add(function(camera) {
          _this._cameraRenderTime.endMonitoring(false);
          Tools.EndPerformanceCounter("Rendering camera " + camera.name);
        });
      } else {
        this.scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);
        this._onBeforeCameraRenderObserver = null;
        this.scene.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);
        this._onAfterCameraRenderObserver = null;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneInstrumentation2.prototype, "drawCallsCounter", {
    get: function() {
      return this.scene.getEngine()._drawCalls;
    },
    enumerable: false,
    configurable: true
  });
  SceneInstrumentation2.prototype.dispose = function() {
    this.scene.onAfterRenderObservable.remove(this._onAfterRenderObserver);
    this._onAfterRenderObserver = null;
    this.scene.onBeforeActiveMeshesEvaluationObservable.remove(this._onBeforeActiveMeshesEvaluationObserver);
    this._onBeforeActiveMeshesEvaluationObserver = null;
    this.scene.onAfterActiveMeshesEvaluationObservable.remove(this._onAfterActiveMeshesEvaluationObserver);
    this._onAfterActiveMeshesEvaluationObserver = null;
    this.scene.onBeforeRenderTargetsRenderObservable.remove(this._onBeforeRenderTargetsRenderObserver);
    this._onBeforeRenderTargetsRenderObserver = null;
    this.scene.onAfterRenderTargetsRenderObservable.remove(this._onAfterRenderTargetsRenderObserver);
    this._onAfterRenderTargetsRenderObserver = null;
    this.scene.onBeforeAnimationsObservable.remove(this._onBeforeAnimationsObserver);
    this._onBeforeAnimationsObserver = null;
    this.scene.onBeforeParticlesRenderingObservable.remove(this._onBeforeParticlesRenderingObserver);
    this._onBeforeParticlesRenderingObserver = null;
    this.scene.onAfterParticlesRenderingObservable.remove(this._onAfterParticlesRenderingObserver);
    this._onAfterParticlesRenderingObserver = null;
    if (this._onBeforeSpritesRenderingObserver) {
      this.scene.onBeforeSpritesRenderingObservable.remove(this._onBeforeSpritesRenderingObserver);
      this._onBeforeSpritesRenderingObserver = null;
    }
    if (this._onAfterSpritesRenderingObserver) {
      this.scene.onAfterSpritesRenderingObservable.remove(this._onAfterSpritesRenderingObserver);
      this._onAfterSpritesRenderingObserver = null;
    }
    this.scene.onBeforeDrawPhaseObservable.remove(this._onBeforeDrawPhaseObserver);
    this._onBeforeDrawPhaseObserver = null;
    this.scene.onAfterDrawPhaseObservable.remove(this._onAfterDrawPhaseObserver);
    this._onAfterDrawPhaseObserver = null;
    if (this._onBeforePhysicsObserver) {
      this.scene.onBeforePhysicsObservable.remove(this._onBeforePhysicsObserver);
      this._onBeforePhysicsObserver = null;
    }
    if (this._onAfterPhysicsObserver) {
      this.scene.onAfterPhysicsObservable.remove(this._onAfterPhysicsObserver);
      this._onAfterPhysicsObserver = null;
    }
    this.scene.onAfterAnimationsObservable.remove(this._onAfterAnimationsObserver);
    this._onAfterAnimationsObserver = null;
    this.scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);
    this._onBeforeCameraRenderObserver = null;
    this.scene.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);
    this._onAfterCameraRenderObserver = null;
    this.scene = null;
  };
  return SceneInstrumentation2;
}();

// node_modules/@babylonjs/core/Shaders/glowMapGeneration.fragment.js
var name21 = "glowMapGenerationPixelShader";
var shader21 = "#ifdef DIFFUSE\nvarying vec2 vUVDiffuse;\nuniform sampler2D diffuseSampler;\n#endif\n#ifdef OPACITY\nvarying vec2 vUVOpacity;\nuniform sampler2D opacitySampler;\nuniform float opacityIntensity;\n#endif\n#ifdef EMISSIVE\nvarying vec2 vUVEmissive;\nuniform sampler2D emissiveSampler;\n#endif\n#ifdef VERTEXALPHA\nvarying vec4 vColor;\n#endif\nuniform vec4 glowColor;\nvoid main(void)\n{\nvec4 finalColor=glowColor;\n\n#ifdef DIFFUSE\nvec4 albedoTexture=texture2D(diffuseSampler,vUVDiffuse);\n#ifdef GLOW\n\nfinalColor.a*=albedoTexture.a;\n#endif\n#ifdef HIGHLIGHT\n\nfinalColor.a=albedoTexture.a;\n#endif\n#endif\n#ifdef OPACITY\nvec4 opacityMap=texture2D(opacitySampler,vUVOpacity);\n#ifdef OPACITYRGB\nfinalColor.a*=getLuminance(opacityMap.rgb);\n#else\nfinalColor.a*=opacityMap.a;\n#endif\nfinalColor.a*=opacityIntensity;\n#endif\n#ifdef VERTEXALPHA\nfinalColor.a*=vColor.a;\n#endif\n#ifdef ALPHATEST\nif (finalColor.a<ALPHATESTVALUE)\ndiscard;\n#endif\n#ifdef EMISSIVE\ngl_FragColor=texture2D(emissiveSampler,vUVEmissive)*finalColor;\n#else\ngl_FragColor=finalColor;\n#endif\n#ifdef HIGHLIGHT\n\ngl_FragColor.a=glowColor.a;\n#endif\n}";
Effect.ShadersStore[name21] = shader21;

// node_modules/@babylonjs/core/Shaders/glowMapGeneration.vertex.js
var name22 = "glowMapGenerationVertexShader";
var shader22 = "\nattribute vec3 position;\n#include<bonesDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\nvarying vec4 vPosition;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef DIFFUSE\nvarying vec2 vUVDiffuse;\nuniform mat4 diffuseMatrix;\n#endif\n#ifdef OPACITY\nvarying vec2 vUVOpacity;\nuniform mat4 opacityMatrix;\n#endif\n#ifdef EMISSIVE\nvarying vec2 vUVEmissive;\nuniform mat4 emissiveMatrix;\n#endif\n#ifdef VERTEXALPHA\nattribute vec4 color;\nvarying vec4 vColor;\n#endif\nvoid main(void)\n{\nvec3 positionUpdated=position;\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#ifdef CUBEMAP\nvPosition=finalWorld*vec4(positionUpdated,1.0);\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\n#else\nvPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);\ngl_Position=vPosition;\n#endif\n#ifdef DIFFUSE\n#ifdef DIFFUSEUV1\nvUVDiffuse=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef DIFFUSEUV2\nvUVDiffuse=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n#ifdef OPACITY\n#ifdef OPACITYUV1\nvUVOpacity=vec2(opacityMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef OPACITYUV2\nvUVOpacity=vec2(opacityMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n#ifdef EMISSIVE\n#ifdef EMISSIVEUV1\nvUVEmissive=vec2(emissiveMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef EMISSIVEUV2\nvUVEmissive=vec2(emissiveMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n#ifdef VERTEXALPHA\nvColor=color;\n#endif\n}";
Effect.ShadersStore[name22] = shader22;

// node_modules/@babylonjs/core/Layers/effectLayer.js
var EffectLayer = function() {
  function EffectLayer2(name98, scene) {
    this._vertexBuffers = {};
    this._maxSize = 0;
    this._mainTextureDesiredSize = { width: 0, height: 0 };
    this._shouldRender = true;
    this._postProcesses = [];
    this._textures = [];
    this._emissiveTextureAndColor = { texture: null, color: new Color4() };
    this.neutralColor = new Color4();
    this.isEnabled = true;
    this.disableBoundingBoxesFromEffectLayer = false;
    this.onDisposeObservable = new Observable();
    this.onBeforeRenderMainTextureObservable = new Observable();
    this.onBeforeComposeObservable = new Observable();
    this.onBeforeRenderMeshToEffect = new Observable();
    this.onAfterRenderMeshToEffect = new Observable();
    this.onAfterComposeObservable = new Observable();
    this.onSizeChangedObservable = new Observable();
    this.name = name98;
    this._scene = scene || EngineStore.LastCreatedScene;
    EffectLayer2._SceneComponentInitialization(this._scene);
    this._engine = this._scene.getEngine();
    this._maxSize = this._engine.getCaps().maxTextureSize;
    this._scene.effectLayers.push(this);
    this._generateIndexBuffer();
    this._generateVertexBuffer();
  }
  Object.defineProperty(EffectLayer2.prototype, "camera", {
    get: function() {
      return this._effectLayerOptions.camera;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EffectLayer2.prototype, "renderingGroupId", {
    get: function() {
      return this._effectLayerOptions.renderingGroupId;
    },
    set: function(renderingGroupId) {
      this._effectLayerOptions.renderingGroupId = renderingGroupId;
    },
    enumerable: false,
    configurable: true
  });
  EffectLayer2.prototype._init = function(options) {
    this._effectLayerOptions = __assign({ mainTextureRatio: 0.5, alphaBlendingMode: 2, camera: null, renderingGroupId: -1 }, options);
    this._setMainTextureSize();
    this._createMainTexture();
    this._createTextureAndPostProcesses();
    this._mergeEffect = this._createMergeEffect();
  };
  EffectLayer2.prototype._generateIndexBuffer = function() {
    var indices = [];
    indices.push(0);
    indices.push(1);
    indices.push(2);
    indices.push(0);
    indices.push(2);
    indices.push(3);
    this._indexBuffer = this._engine.createIndexBuffer(indices);
  };
  EffectLayer2.prototype._generateVertexBuffer = function() {
    var vertices = [];
    vertices.push(1, 1);
    vertices.push(-1, 1);
    vertices.push(-1, -1);
    vertices.push(1, -1);
    var vertexBuffer = new VertexBuffer(this._engine, vertices, VertexBuffer.PositionKind, false, false, 2);
    this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;
  };
  EffectLayer2.prototype._setMainTextureSize = function() {
    if (this._effectLayerOptions.mainTextureFixedSize) {
      this._mainTextureDesiredSize.width = this._effectLayerOptions.mainTextureFixedSize;
      this._mainTextureDesiredSize.height = this._effectLayerOptions.mainTextureFixedSize;
    } else {
      this._mainTextureDesiredSize.width = this._engine.getRenderWidth() * this._effectLayerOptions.mainTextureRatio;
      this._mainTextureDesiredSize.height = this._engine.getRenderHeight() * this._effectLayerOptions.mainTextureRatio;
      this._mainTextureDesiredSize.width = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.width, this._maxSize) : this._mainTextureDesiredSize.width;
      this._mainTextureDesiredSize.height = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.height, this._maxSize) : this._mainTextureDesiredSize.height;
    }
    this._mainTextureDesiredSize.width = Math.floor(this._mainTextureDesiredSize.width);
    this._mainTextureDesiredSize.height = Math.floor(this._mainTextureDesiredSize.height);
  };
  EffectLayer2.prototype._createMainTexture = function() {
    var _this = this;
    this._mainTexture = new RenderTargetTexture("HighlightLayerMainRTT", {
      width: this._mainTextureDesiredSize.width,
      height: this._mainTextureDesiredSize.height
    }, this._scene, false, true, 0);
    this._mainTexture.activeCamera = this._effectLayerOptions.camera;
    this._mainTexture.wrapU = Texture.CLAMP_ADDRESSMODE;
    this._mainTexture.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._mainTexture.anisotropicFilteringLevel = 1;
    this._mainTexture.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
    this._mainTexture.renderParticles = false;
    this._mainTexture.renderList = null;
    this._mainTexture.ignoreCameraViewport = true;
    this._mainTexture.customRenderFunction = function(opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {
      _this.onBeforeRenderMainTextureObservable.notifyObservers(_this);
      var index;
      var engine = _this._scene.getEngine();
      if (depthOnlySubMeshes.length) {
        engine.setColorWrite(false);
        for (index = 0; index < depthOnlySubMeshes.length; index++) {
          _this._renderSubMesh(depthOnlySubMeshes.data[index]);
        }
        engine.setColorWrite(true);
      }
      for (index = 0; index < opaqueSubMeshes.length; index++) {
        _this._renderSubMesh(opaqueSubMeshes.data[index]);
      }
      for (index = 0; index < alphaTestSubMeshes.length; index++) {
        _this._renderSubMesh(alphaTestSubMeshes.data[index]);
      }
      var previousAlphaMode = engine.getAlphaMode();
      for (index = 0; index < transparentSubMeshes.length; index++) {
        _this._renderSubMesh(transparentSubMeshes.data[index], true);
      }
      engine.setAlphaMode(previousAlphaMode);
    };
    this._mainTexture.onClearObservable.add(function(engine) {
      engine.clear(_this.neutralColor, true, true, true);
    });
    var boundingBoxRendererEnabled = this._scene.getBoundingBoxRenderer().enabled;
    this._mainTexture.onBeforeBindObservable.add(function() {
      _this._scene.getBoundingBoxRenderer().enabled = !_this.disableBoundingBoxesFromEffectLayer && boundingBoxRendererEnabled;
    });
    this._mainTexture.onAfterUnbindObservable.add(function() {
      _this._scene.getBoundingBoxRenderer().enabled = boundingBoxRendererEnabled;
    });
  };
  EffectLayer2.prototype._addCustomEffectDefines = function(defines) {
  };
  EffectLayer2.prototype._isReady = function(subMesh, useInstances, emissiveTexture) {
    var material = subMesh.getMaterial();
    if (!material) {
      return false;
    }
    if (!material.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances)) {
      return false;
    }
    var defines = [];
    var attribs = [VertexBuffer.PositionKind];
    var mesh = subMesh.getMesh();
    var uv1 = false;
    var uv2 = false;
    if (material) {
      var needAlphaTest = material.needAlphaTesting();
      var diffuseTexture = material.getAlphaTestTexture();
      var needAlphaBlendFromDiffuse = diffuseTexture && diffuseTexture.hasAlpha && (material.useAlphaFromDiffuseTexture || material._useAlphaFromAlbedoTexture);
      if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {
        defines.push("#define DIFFUSE");
        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && diffuseTexture.coordinatesIndex === 1) {
          defines.push("#define DIFFUSEUV2");
          uv2 = true;
        } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
          defines.push("#define DIFFUSEUV1");
          uv1 = true;
        }
        if (needAlphaTest) {
          defines.push("#define ALPHATEST");
          defines.push("#define ALPHATESTVALUE 0.4");
        }
      }
      var opacityTexture = material.opacityTexture;
      if (opacityTexture) {
        defines.push("#define OPACITY");
        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && opacityTexture.coordinatesIndex === 1) {
          defines.push("#define OPACITYUV2");
          uv2 = true;
        } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
          defines.push("#define OPACITYUV1");
          uv1 = true;
        }
      }
    }
    if (emissiveTexture) {
      defines.push("#define EMISSIVE");
      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && emissiveTexture.coordinatesIndex === 1) {
        defines.push("#define EMISSIVEUV2");
        uv2 = true;
      } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
        defines.push("#define EMISSIVEUV1");
        uv1 = true;
      }
    }
    if (mesh.isVerticesDataPresent(VertexBuffer.ColorKind) && mesh.hasVertexAlpha) {
      attribs.push(VertexBuffer.ColorKind);
      defines.push("#define VERTEXALPHA");
    }
    if (uv1) {
      attribs.push(VertexBuffer.UVKind);
      defines.push("#define UV1");
    }
    if (uv2) {
      attribs.push(VertexBuffer.UV2Kind);
      defines.push("#define UV2");
    }
    var fallbacks = new EffectFallbacks();
    if (mesh.useBones && mesh.computeBonesUsingShaders) {
      attribs.push(VertexBuffer.MatricesIndicesKind);
      attribs.push(VertexBuffer.MatricesWeightsKind);
      if (mesh.numBoneInfluencers > 4) {
        attribs.push(VertexBuffer.MatricesIndicesExtraKind);
        attribs.push(VertexBuffer.MatricesWeightsExtraKind);
      }
      defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
      var skeleton = mesh.skeleton;
      if (skeleton && skeleton.isUsingTextureForMatrices) {
        defines.push("#define BONETEXTURE");
      } else {
        defines.push("#define BonesPerMesh " + (skeleton ? skeleton.bones.length + 1 : 0));
      }
      if (mesh.numBoneInfluencers > 0) {
        fallbacks.addCPUSkinningFallback(0, mesh);
      }
    } else {
      defines.push("#define NUM_BONE_INFLUENCERS 0");
    }
    var manager = mesh.morphTargetManager;
    var morphInfluencers = 0;
    if (manager) {
      if (manager.numInfluencers > 0) {
        defines.push("#define MORPHTARGETS");
        morphInfluencers = manager.numInfluencers;
        defines.push("#define NUM_MORPH_INFLUENCERS " + morphInfluencers);
        MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, morphInfluencers);
      }
    }
    if (useInstances) {
      defines.push("#define INSTANCES");
      MaterialHelper.PushAttributesForInstances(attribs);
      if (subMesh.getRenderingMesh().hasThinInstances) {
        defines.push("#define THIN_INSTANCES");
      }
    }
    this._addCustomEffectDefines(defines);
    var join = defines.join("\n");
    if (this._cachedDefines !== join) {
      this._cachedDefines = join;
      this._effectLayerMapGenerationEffect = this._scene.getEngine().createEffect("glowMapGeneration", attribs, [
        "world",
        "mBones",
        "viewProjection",
        "glowColor",
        "morphTargetInfluences",
        "boneTextureWidth",
        "diffuseMatrix",
        "emissiveMatrix",
        "opacityMatrix",
        "opacityIntensity"
      ], ["diffuseSampler", "emissiveSampler", "opacitySampler", "boneSampler"], join, fallbacks, void 0, void 0, { maxSimultaneousMorphTargets: morphInfluencers });
    }
    return this._effectLayerMapGenerationEffect.isReady();
  };
  EffectLayer2.prototype.render = function() {
    var currentEffect = this._mergeEffect;
    if (!currentEffect.isReady()) {
      return;
    }
    for (var i = 0; i < this._postProcesses.length; i++) {
      if (!this._postProcesses[i].isReady()) {
        return;
      }
    }
    var engine = this._scene.getEngine();
    this.onBeforeComposeObservable.notifyObservers(this);
    engine.enableEffect(currentEffect);
    engine.setState(false);
    engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect);
    var previousAlphaMode = engine.getAlphaMode();
    engine.setAlphaMode(this._effectLayerOptions.alphaBlendingMode);
    this._internalRender(currentEffect);
    engine.setAlphaMode(previousAlphaMode);
    this.onAfterComposeObservable.notifyObservers(this);
    var size = this._mainTexture.getSize();
    this._setMainTextureSize();
    if (size.width !== this._mainTextureDesiredSize.width || size.height !== this._mainTextureDesiredSize.height) {
      this.onSizeChangedObservable.notifyObservers(this);
      this._disposeTextureAndPostProcesses();
      this._createMainTexture();
      this._createTextureAndPostProcesses();
    }
  };
  EffectLayer2.prototype.hasMesh = function(mesh) {
    if (this.renderingGroupId === -1 || mesh.renderingGroupId === this.renderingGroupId) {
      return true;
    }
    return false;
  };
  EffectLayer2.prototype.shouldRender = function() {
    return this.isEnabled && this._shouldRender;
  };
  EffectLayer2.prototype._shouldRenderMesh = function(mesh) {
    return true;
  };
  EffectLayer2.prototype._canRenderMesh = function(mesh, material) {
    return !material.needAlphaBlendingForMesh(mesh);
  };
  EffectLayer2.prototype._shouldRenderEmissiveTextureForMesh = function() {
    return true;
  };
  EffectLayer2.prototype._renderSubMesh = function(subMesh, enableAlphaMode) {
    var _this = this;
    var _a;
    if (enableAlphaMode === void 0) {
      enableAlphaMode = false;
    }
    if (!this.shouldRender()) {
      return;
    }
    var material = subMesh.getMaterial();
    var ownerMesh = subMesh.getMesh();
    var replacementMesh = subMesh.getReplacementMesh();
    var renderingMesh = subMesh.getRenderingMesh();
    var effectiveMesh = subMesh.getEffectiveMesh();
    var scene = this._scene;
    var engine = scene.getEngine();
    effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;
    if (!material) {
      return;
    }
    if (!this._canRenderMesh(renderingMesh, material)) {
      return;
    }
    var sideOrientation = (_a = renderingMesh.overrideMaterialSideOrientation) !== null && _a !== void 0 ? _a : material.sideOrientation;
    var mainDeterminant = renderingMesh._getWorldMatrixDeterminant();
    if (mainDeterminant < 0) {
      sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;
    }
    var reverse = sideOrientation === Material.ClockWiseSideOrientation;
    engine.setState(material.backFaceCulling, material.zOffset, void 0, reverse);
    var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!replacementMesh);
    if (batch.mustReturn) {
      return;
    }
    if (!this._shouldRenderMesh(renderingMesh)) {
      return;
    }
    var hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;
    this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);
    this.onBeforeRenderMeshToEffect.notifyObservers(ownerMesh);
    if (this._useMeshMaterial(renderingMesh)) {
      renderingMesh.render(subMesh, hardwareInstancedRendering, replacementMesh || void 0);
    } else if (this._isReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {
      engine.enableEffect(this._effectLayerMapGenerationEffect);
      renderingMesh._bind(subMesh, this._effectLayerMapGenerationEffect, Material.TriangleFillMode);
      this._effectLayerMapGenerationEffect.setMatrix("viewProjection", scene.getTransformMatrix());
      this._effectLayerMapGenerationEffect.setMatrix("world", effectiveMesh.getWorldMatrix());
      this._effectLayerMapGenerationEffect.setFloat4("glowColor", this._emissiveTextureAndColor.color.r, this._emissiveTextureAndColor.color.g, this._emissiveTextureAndColor.color.b, this._emissiveTextureAndColor.color.a);
      var needAlphaTest = material.needAlphaTesting();
      var diffuseTexture = material.getAlphaTestTexture();
      var needAlphaBlendFromDiffuse = diffuseTexture && diffuseTexture.hasAlpha && (material.useAlphaFromDiffuseTexture || material._useAlphaFromAlbedoTexture);
      if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {
        this._effectLayerMapGenerationEffect.setTexture("diffuseSampler", diffuseTexture);
        var textureMatrix = diffuseTexture.getTextureMatrix();
        if (textureMatrix) {
          this._effectLayerMapGenerationEffect.setMatrix("diffuseMatrix", textureMatrix);
        }
      }
      var opacityTexture = material.opacityTexture;
      if (opacityTexture) {
        this._effectLayerMapGenerationEffect.setTexture("opacitySampler", opacityTexture);
        this._effectLayerMapGenerationEffect.setFloat("opacityIntensity", opacityTexture.level);
        var textureMatrix = opacityTexture.getTextureMatrix();
        if (textureMatrix) {
          this._effectLayerMapGenerationEffect.setMatrix("opacityMatrix", textureMatrix);
        }
      }
      if (this._emissiveTextureAndColor.texture) {
        this._effectLayerMapGenerationEffect.setTexture("emissiveSampler", this._emissiveTextureAndColor.texture);
        this._effectLayerMapGenerationEffect.setMatrix("emissiveMatrix", this._emissiveTextureAndColor.texture.getTextureMatrix());
      }
      if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {
        var skeleton = renderingMesh.skeleton;
        if (skeleton.isUsingTextureForMatrices) {
          var boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);
          if (!boneTexture) {
            return;
          }
          this._effectLayerMapGenerationEffect.setTexture("boneSampler", boneTexture);
          this._effectLayerMapGenerationEffect.setFloat("boneTextureWidth", 4 * (skeleton.bones.length + 1));
        } else {
          this._effectLayerMapGenerationEffect.setMatrices("mBones", skeleton.getTransformMatrices(renderingMesh));
        }
      }
      MaterialHelper.BindMorphTargetParameters(renderingMesh, this._effectLayerMapGenerationEffect);
      if (enableAlphaMode) {
        engine.setAlphaMode(material.alphaMode);
      }
      renderingMesh._processRendering(effectiveMesh, subMesh, this._effectLayerMapGenerationEffect, material.fillMode, batch, hardwareInstancedRendering, function(isInstance, world) {
        return _this._effectLayerMapGenerationEffect.setMatrix("world", world);
      });
    } else {
      this._mainTexture.resetRefreshCounter();
    }
    this.onAfterRenderMeshToEffect.notifyObservers(ownerMesh);
  };
  EffectLayer2.prototype._useMeshMaterial = function(mesh) {
    return false;
  };
  EffectLayer2.prototype._rebuild = function() {
    var vb = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vb) {
      vb._rebuild();
    }
    this._generateIndexBuffer();
  };
  EffectLayer2.prototype._disposeTextureAndPostProcesses = function() {
    this._mainTexture.dispose();
    for (var i = 0; i < this._postProcesses.length; i++) {
      if (this._postProcesses[i]) {
        this._postProcesses[i].dispose();
      }
    }
    this._postProcesses = [];
    for (var i = 0; i < this._textures.length; i++) {
      if (this._textures[i]) {
        this._textures[i].dispose();
      }
    }
    this._textures = [];
  };
  EffectLayer2.prototype.dispose = function() {
    var vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vertexBuffer) {
      vertexBuffer.dispose();
      this._vertexBuffers[VertexBuffer.PositionKind] = null;
    }
    if (this._indexBuffer) {
      this._scene.getEngine()._releaseBuffer(this._indexBuffer);
      this._indexBuffer = null;
    }
    this._disposeTextureAndPostProcesses();
    var index = this._scene.effectLayers.indexOf(this, 0);
    if (index > -1) {
      this._scene.effectLayers.splice(index, 1);
    }
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    this.onBeforeRenderMainTextureObservable.clear();
    this.onBeforeComposeObservable.clear();
    this.onBeforeRenderMeshToEffect.clear();
    this.onAfterRenderMeshToEffect.clear();
    this.onAfterComposeObservable.clear();
    this.onSizeChangedObservable.clear();
  };
  EffectLayer2.prototype.getClassName = function() {
    return "EffectLayer";
  };
  EffectLayer2.Parse = function(parsedEffectLayer, scene, rootUrl) {
    var effectLayerType = Tools.Instantiate(parsedEffectLayer.customType);
    return effectLayerType.Parse(parsedEffectLayer, scene, rootUrl);
  };
  EffectLayer2._SceneComponentInitialization = function(_) {
    throw _DevTools.WarnImport("EffectLayerSceneComponent");
  };
  __decorate([
    serialize()
  ], EffectLayer2.prototype, "name", void 0);
  __decorate([
    serializeAsColor4()
  ], EffectLayer2.prototype, "neutralColor", void 0);
  __decorate([
    serialize()
  ], EffectLayer2.prototype, "isEnabled", void 0);
  __decorate([
    serializeAsCameraReference()
  ], EffectLayer2.prototype, "camera", null);
  __decorate([
    serialize()
  ], EffectLayer2.prototype, "renderingGroupId", null);
  __decorate([
    serialize()
  ], EffectLayer2.prototype, "disableBoundingBoxesFromEffectLayer", void 0);
  return EffectLayer2;
}();

// node_modules/@babylonjs/core/Layers/effectLayerSceneComponent.js
AbstractScene.AddParser(SceneComponentConstants.NAME_EFFECTLAYER, function(parsedData, scene, container, rootUrl) {
  if (parsedData.effectLayers) {
    if (!container.effectLayers) {
      container.effectLayers = new Array();
    }
    for (var index = 0; index < parsedData.effectLayers.length; index++) {
      var effectLayer = EffectLayer.Parse(parsedData.effectLayers[index], scene, rootUrl);
      container.effectLayers.push(effectLayer);
    }
  }
});
AbstractScene.prototype.removeEffectLayer = function(toRemove) {
  var index = this.effectLayers.indexOf(toRemove);
  if (index !== -1) {
    this.effectLayers.splice(index, 1);
  }
  return index;
};
AbstractScene.prototype.addEffectLayer = function(newEffectLayer) {
  this.effectLayers.push(newEffectLayer);
};
var EffectLayerSceneComponent = function() {
  function EffectLayerSceneComponent2(scene) {
    this.name = SceneComponentConstants.NAME_EFFECTLAYER;
    this._renderEffects = false;
    this._needStencil = false;
    this._previousStencilState = false;
    this.scene = scene;
    this._engine = scene.getEngine();
    scene.effectLayers = new Array();
  }
  EffectLayerSceneComponent2.prototype.register = function() {
    this.scene._isReadyForMeshStage.registerStep(SceneComponentConstants.STEP_ISREADYFORMESH_EFFECTLAYER, this, this._isReadyForMesh);
    this.scene._cameraDrawRenderTargetStage.registerStep(SceneComponentConstants.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER, this, this._renderMainTexture);
    this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_EFFECTLAYER, this, this._setStencil);
    this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW, this, this._drawRenderingGroup);
    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER, this, this._setStencilBack);
    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW, this, this._drawCamera);
  };
  EffectLayerSceneComponent2.prototype.rebuild = function() {
    var layers = this.scene.effectLayers;
    for (var _i = 0, layers_1 = layers; _i < layers_1.length; _i++) {
      var effectLayer = layers_1[_i];
      effectLayer._rebuild();
    }
  };
  EffectLayerSceneComponent2.prototype.serialize = function(serializationObject) {
    serializationObject.effectLayers = [];
    var layers = this.scene.effectLayers;
    for (var _i = 0, layers_2 = layers; _i < layers_2.length; _i++) {
      var effectLayer = layers_2[_i];
      if (effectLayer.serialize) {
        serializationObject.effectLayers.push(effectLayer.serialize());
      }
    }
  };
  EffectLayerSceneComponent2.prototype.addFromContainer = function(container) {
    var _this = this;
    if (!container.effectLayers) {
      return;
    }
    container.effectLayers.forEach(function(o) {
      _this.scene.addEffectLayer(o);
    });
  };
  EffectLayerSceneComponent2.prototype.removeFromContainer = function(container, dispose) {
    var _this = this;
    if (!container.effectLayers) {
      return;
    }
    container.effectLayers.forEach(function(o) {
      _this.scene.removeEffectLayer(o);
      if (dispose) {
        o.dispose();
      }
    });
  };
  EffectLayerSceneComponent2.prototype.dispose = function() {
    var layers = this.scene.effectLayers;
    while (layers.length) {
      layers[0].dispose();
    }
  };
  EffectLayerSceneComponent2.prototype._isReadyForMesh = function(mesh, hardwareInstancedRendering) {
    var layers = this.scene.effectLayers;
    for (var _i = 0, layers_3 = layers; _i < layers_3.length; _i++) {
      var layer = layers_3[_i];
      if (!layer.hasMesh(mesh)) {
        continue;
      }
      for (var _a = 0, _b = mesh.subMeshes; _a < _b.length; _a++) {
        var subMesh = _b[_a];
        if (!layer.isReady(subMesh, hardwareInstancedRendering)) {
          return false;
        }
      }
    }
    return true;
  };
  EffectLayerSceneComponent2.prototype._renderMainTexture = function(camera) {
    this._renderEffects = false;
    this._needStencil = false;
    var needRebind = false;
    var layers = this.scene.effectLayers;
    if (layers && layers.length > 0) {
      this._previousStencilState = this._engine.getStencilBuffer();
      for (var _i = 0, layers_4 = layers; _i < layers_4.length; _i++) {
        var effectLayer = layers_4[_i];
        if (effectLayer.shouldRender() && (!effectLayer.camera || effectLayer.camera.cameraRigMode === Camera.RIG_MODE_NONE && camera === effectLayer.camera || effectLayer.camera.cameraRigMode !== Camera.RIG_MODE_NONE && effectLayer.camera._rigCameras.indexOf(camera) > -1)) {
          this._renderEffects = true;
          this._needStencil = this._needStencil || effectLayer.needStencil();
          var renderTarget = effectLayer._mainTexture;
          if (renderTarget._shouldRender()) {
            this.scene.incrementRenderId();
            renderTarget.render(false, false);
            needRebind = true;
          }
        }
      }
      this.scene.incrementRenderId();
    }
    return needRebind;
  };
  EffectLayerSceneComponent2.prototype._setStencil = function() {
    if (this._needStencil) {
      this._engine.setStencilBuffer(true);
    }
  };
  EffectLayerSceneComponent2.prototype._setStencilBack = function() {
    if (this._needStencil) {
      this._engine.setStencilBuffer(this._previousStencilState);
    }
  };
  EffectLayerSceneComponent2.prototype._draw = function(renderingGroupId) {
    if (this._renderEffects) {
      this._engine.setDepthBuffer(false);
      var layers = this.scene.effectLayers;
      for (var i = 0; i < layers.length; i++) {
        var effectLayer = layers[i];
        if (effectLayer.renderingGroupId === renderingGroupId) {
          if (effectLayer.shouldRender()) {
            effectLayer.render();
          }
        }
      }
      this._engine.setDepthBuffer(true);
    }
  };
  EffectLayerSceneComponent2.prototype._drawCamera = function() {
    if (this._renderEffects) {
      this._draw(-1);
    }
  };
  EffectLayerSceneComponent2.prototype._drawRenderingGroup = function(index) {
    if (!this.scene._isInIntermediateRendering() && this._renderEffects) {
      this._draw(index);
    }
  };
  return EffectLayerSceneComponent2;
}();
EffectLayer._SceneComponentInitialization = function(scene) {
  var component = scene._getComponent(SceneComponentConstants.NAME_EFFECTLAYER);
  if (!component) {
    component = new EffectLayerSceneComponent(scene);
    scene._addComponent(component);
  }
};

// node_modules/@babylonjs/core/Shaders/glowMapMerge.fragment.js
var name23 = "glowMapMergePixelShader";
var shader23 = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n#ifdef EMISSIVE\nuniform sampler2D textureSampler2;\n#endif\n\nuniform float offset;\nvoid main(void) {\nvec4 baseColor=texture2D(textureSampler,vUV);\n#ifdef EMISSIVE\nbaseColor+=texture2D(textureSampler2,vUV);\nbaseColor*=offset;\n#else\nbaseColor.a=abs(offset-baseColor.a);\n#ifdef STROKE\nfloat alpha=smoothstep(.0,.1,baseColor.a);\nbaseColor.a=alpha;\nbaseColor.rgb=baseColor.rgb*alpha;\n#endif\n#endif\ngl_FragColor=baseColor;\n}";
Effect.ShadersStore[name23] = shader23;

// node_modules/@babylonjs/core/Shaders/glowMapMerge.vertex.js
var name24 = "glowMapMergeVertexShader";
var shader24 = "\nattribute vec2 position;\n\nvarying vec2 vUV;\nconst vec2 madd=vec2(0.5,0.5);\nvoid main(void) {\nvUV=position*madd+madd;\ngl_Position=vec4(position,0.0,1.0);\n}";
Effect.ShadersStore[name24] = shader24;

// node_modules/@babylonjs/core/Layers/glowLayer.js
AbstractScene.prototype.getGlowLayerByName = function(name98) {
  for (var index = 0; index < this.effectLayers.length; index++) {
    if (this.effectLayers[index].name === name98 && this.effectLayers[index].getEffectName() === GlowLayer.EffectName) {
      return this.effectLayers[index];
    }
  }
  return null;
};
var GlowLayer = function(_super) {
  __extends(GlowLayer2, _super);
  function GlowLayer2(name98, scene, options) {
    var _this = _super.call(this, name98, scene) || this;
    _this._intensity = 1;
    _this._includedOnlyMeshes = [];
    _this._excludedMeshes = [];
    _this._meshesUsingTheirOwnMaterials = [];
    _this.neutralColor = new Color4(0, 0, 0, 1);
    _this._options = __assign({ mainTextureRatio: GlowLayer2.DefaultTextureRatio, blurKernelSize: 32, mainTextureFixedSize: void 0, camera: null, mainTextureSamples: 1, renderingGroupId: -1 }, options);
    _this._init({
      alphaBlendingMode: 1,
      camera: _this._options.camera,
      mainTextureFixedSize: _this._options.mainTextureFixedSize,
      mainTextureRatio: _this._options.mainTextureRatio,
      renderingGroupId: _this._options.renderingGroupId
    });
    return _this;
  }
  Object.defineProperty(GlowLayer2.prototype, "blurKernelSize", {
    get: function() {
      return this._horizontalBlurPostprocess1.kernel;
    },
    set: function(value) {
      this._horizontalBlurPostprocess1.kernel = value;
      this._verticalBlurPostprocess1.kernel = value;
      this._horizontalBlurPostprocess2.kernel = value;
      this._verticalBlurPostprocess2.kernel = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GlowLayer2.prototype, "intensity", {
    get: function() {
      return this._intensity;
    },
    set: function(value) {
      this._intensity = value;
    },
    enumerable: false,
    configurable: true
  });
  GlowLayer2.prototype.getEffectName = function() {
    return GlowLayer2.EffectName;
  };
  GlowLayer2.prototype._createMergeEffect = function() {
    return this._engine.createEffect("glowMapMerge", [VertexBuffer.PositionKind], ["offset"], ["textureSampler", "textureSampler2"], "#define EMISSIVE \n");
  };
  GlowLayer2.prototype._createTextureAndPostProcesses = function() {
    var _this = this;
    var blurTextureWidth = this._mainTextureDesiredSize.width;
    var blurTextureHeight = this._mainTextureDesiredSize.height;
    blurTextureWidth = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureWidth, this._maxSize) : blurTextureWidth;
    blurTextureHeight = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureHeight, this._maxSize) : blurTextureHeight;
    var textureType = 0;
    if (this._engine.getCaps().textureHalfFloatRender) {
      textureType = 2;
    } else {
      textureType = 0;
    }
    this._blurTexture1 = new RenderTargetTexture("GlowLayerBlurRTT", {
      width: blurTextureWidth,
      height: blurTextureHeight
    }, this._scene, false, true, textureType);
    this._blurTexture1.wrapU = Texture.CLAMP_ADDRESSMODE;
    this._blurTexture1.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._blurTexture1.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
    this._blurTexture1.renderParticles = false;
    this._blurTexture1.ignoreCameraViewport = true;
    var blurTextureWidth2 = Math.floor(blurTextureWidth / 2);
    var blurTextureHeight2 = Math.floor(blurTextureHeight / 2);
    this._blurTexture2 = new RenderTargetTexture("GlowLayerBlurRTT2", {
      width: blurTextureWidth2,
      height: blurTextureHeight2
    }, this._scene, false, true, textureType);
    this._blurTexture2.wrapU = Texture.CLAMP_ADDRESSMODE;
    this._blurTexture2.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._blurTexture2.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
    this._blurTexture2.renderParticles = false;
    this._blurTexture2.ignoreCameraViewport = true;
    this._textures = [this._blurTexture1, this._blurTexture2];
    this._horizontalBlurPostprocess1 = new BlurPostProcess("GlowLayerHBP1", new Vector2(1, 0), this._options.blurKernelSize / 2, {
      width: blurTextureWidth,
      height: blurTextureHeight
    }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);
    this._horizontalBlurPostprocess1.width = blurTextureWidth;
    this._horizontalBlurPostprocess1.height = blurTextureHeight;
    this._horizontalBlurPostprocess1.onApplyObservable.add(function(effect) {
      effect.setTexture("textureSampler", _this._mainTexture);
    });
    this._verticalBlurPostprocess1 = new BlurPostProcess("GlowLayerVBP1", new Vector2(0, 1), this._options.blurKernelSize / 2, {
      width: blurTextureWidth,
      height: blurTextureHeight
    }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);
    this._horizontalBlurPostprocess2 = new BlurPostProcess("GlowLayerHBP2", new Vector2(1, 0), this._options.blurKernelSize / 2, {
      width: blurTextureWidth2,
      height: blurTextureHeight2
    }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);
    this._horizontalBlurPostprocess2.width = blurTextureWidth2;
    this._horizontalBlurPostprocess2.height = blurTextureHeight2;
    this._horizontalBlurPostprocess2.onApplyObservable.add(function(effect) {
      effect.setTexture("textureSampler", _this._blurTexture1);
    });
    this._verticalBlurPostprocess2 = new BlurPostProcess("GlowLayerVBP2", new Vector2(0, 1), this._options.blurKernelSize / 2, {
      width: blurTextureWidth2,
      height: blurTextureHeight2
    }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);
    this._postProcesses = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1, this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];
    this._postProcesses1 = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1];
    this._postProcesses2 = [this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];
    this._mainTexture.samples = this._options.mainTextureSamples;
    this._mainTexture.onAfterUnbindObservable.add(function() {
      var internalTexture = _this._blurTexture1.getInternalTexture();
      if (internalTexture) {
        _this._scene.postProcessManager.directRender(_this._postProcesses1, internalTexture, true);
        var internalTexture2 = _this._blurTexture2.getInternalTexture();
        if (internalTexture2) {
          _this._scene.postProcessManager.directRender(_this._postProcesses2, internalTexture2, true);
        }
        _this._engine.unBindFramebuffer(internalTexture2 !== null && internalTexture2 !== void 0 ? internalTexture2 : internalTexture, true);
      }
    });
    this._postProcesses.map(function(pp) {
      pp.autoClear = false;
    });
  };
  GlowLayer2.prototype.isReady = function(subMesh, useInstances) {
    var material = subMesh.getMaterial();
    var mesh = subMesh.getRenderingMesh();
    if (!material || !mesh) {
      return false;
    }
    var emissiveTexture = material.emissiveTexture;
    return _super.prototype._isReady.call(this, subMesh, useInstances, emissiveTexture);
  };
  GlowLayer2.prototype.needStencil = function() {
    return false;
  };
  GlowLayer2.prototype._canRenderMesh = function(mesh, material) {
    return true;
  };
  GlowLayer2.prototype._internalRender = function(effect) {
    effect.setTexture("textureSampler", this._blurTexture1);
    effect.setTexture("textureSampler2", this._blurTexture2);
    effect.setFloat("offset", this._intensity);
    var engine = this._engine;
    var previousStencilBuffer = engine.getStencilBuffer();
    engine.setStencilBuffer(false);
    engine.drawElementsType(Material.TriangleFillMode, 0, 6);
    engine.setStencilBuffer(previousStencilBuffer);
  };
  GlowLayer2.prototype._setEmissiveTextureAndColor = function(mesh, subMesh, material) {
    var textureLevel = 1;
    if (this.customEmissiveTextureSelector) {
      this._emissiveTextureAndColor.texture = this.customEmissiveTextureSelector(mesh, subMesh, material);
    } else {
      if (material) {
        this._emissiveTextureAndColor.texture = material.emissiveTexture;
        if (this._emissiveTextureAndColor.texture) {
          textureLevel = this._emissiveTextureAndColor.texture.level;
        }
      } else {
        this._emissiveTextureAndColor.texture = null;
      }
    }
    if (this.customEmissiveColorSelector) {
      this.customEmissiveColorSelector(mesh, subMesh, material, this._emissiveTextureAndColor.color);
    } else {
      if (material.emissiveColor) {
        this._emissiveTextureAndColor.color.set(material.emissiveColor.r * textureLevel, material.emissiveColor.g * textureLevel, material.emissiveColor.b * textureLevel, material.alpha);
      } else {
        this._emissiveTextureAndColor.color.set(this.neutralColor.r, this.neutralColor.g, this.neutralColor.b, this.neutralColor.a);
      }
    }
  };
  GlowLayer2.prototype._shouldRenderMesh = function(mesh) {
    return this.hasMesh(mesh);
  };
  GlowLayer2.prototype._addCustomEffectDefines = function(defines) {
    defines.push("#define GLOW");
  };
  GlowLayer2.prototype.addExcludedMesh = function(mesh) {
    if (this._excludedMeshes.indexOf(mesh.uniqueId) === -1) {
      this._excludedMeshes.push(mesh.uniqueId);
    }
  };
  GlowLayer2.prototype.removeExcludedMesh = function(mesh) {
    var index = this._excludedMeshes.indexOf(mesh.uniqueId);
    if (index !== -1) {
      this._excludedMeshes.splice(index, 1);
    }
  };
  GlowLayer2.prototype.addIncludedOnlyMesh = function(mesh) {
    if (this._includedOnlyMeshes.indexOf(mesh.uniqueId) === -1) {
      this._includedOnlyMeshes.push(mesh.uniqueId);
    }
  };
  GlowLayer2.prototype.removeIncludedOnlyMesh = function(mesh) {
    var index = this._includedOnlyMeshes.indexOf(mesh.uniqueId);
    if (index !== -1) {
      this._includedOnlyMeshes.splice(index, 1);
    }
  };
  GlowLayer2.prototype.hasMesh = function(mesh) {
    if (!_super.prototype.hasMesh.call(this, mesh)) {
      return false;
    }
    if (this._includedOnlyMeshes.length) {
      return this._includedOnlyMeshes.indexOf(mesh.uniqueId) !== -1;
    }
    if (this._excludedMeshes.length) {
      return this._excludedMeshes.indexOf(mesh.uniqueId) === -1;
    }
    return true;
  };
  GlowLayer2.prototype._useMeshMaterial = function(mesh) {
    if (this._meshesUsingTheirOwnMaterials.length == 0) {
      return false;
    }
    return this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId) > -1;
  };
  GlowLayer2.prototype.referenceMeshToUseItsOwnMaterial = function(mesh) {
    this._meshesUsingTheirOwnMaterials.push(mesh.uniqueId);
  };
  GlowLayer2.prototype.unReferenceMeshFromUsingItsOwnMaterial = function(mesh) {
    var index = this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId);
    while (index >= 0) {
      this._meshesUsingTheirOwnMaterials.splice(index, 1);
      index = this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId);
    }
  };
  GlowLayer2.prototype._disposeMesh = function(mesh) {
    this.removeIncludedOnlyMesh(mesh);
    this.removeExcludedMesh(mesh);
  };
  GlowLayer2.prototype.getClassName = function() {
    return "GlowLayer";
  };
  GlowLayer2.prototype.serialize = function() {
    var serializationObject = SerializationHelper.Serialize(this);
    serializationObject.customType = "BABYLON.GlowLayer";
    var index;
    serializationObject.includedMeshes = [];
    if (this._includedOnlyMeshes.length) {
      for (index = 0; index < this._includedOnlyMeshes.length; index++) {
        var mesh = this._scene.getMeshByUniqueID(this._includedOnlyMeshes[index]);
        if (mesh) {
          serializationObject.includedMeshes.push(mesh.id);
        }
      }
    }
    serializationObject.excludedMeshes = [];
    if (this._excludedMeshes.length) {
      for (index = 0; index < this._excludedMeshes.length; index++) {
        var mesh = this._scene.getMeshByUniqueID(this._excludedMeshes[index]);
        if (mesh) {
          serializationObject.excludedMeshes.push(mesh.id);
        }
      }
    }
    return serializationObject;
  };
  GlowLayer2.Parse = function(parsedGlowLayer, scene, rootUrl) {
    var gl = SerializationHelper.Parse(function() {
      return new GlowLayer2(parsedGlowLayer.name, scene, parsedGlowLayer.options);
    }, parsedGlowLayer, scene, rootUrl);
    var index;
    for (index = 0; index < parsedGlowLayer.excludedMeshes.length; index++) {
      var mesh = scene.getMeshByID(parsedGlowLayer.excludedMeshes[index]);
      if (mesh) {
        gl.addExcludedMesh(mesh);
      }
    }
    for (index = 0; index < parsedGlowLayer.includedMeshes.length; index++) {
      var mesh = scene.getMeshByID(parsedGlowLayer.includedMeshes[index]);
      if (mesh) {
        gl.addIncludedOnlyMesh(mesh);
      }
    }
    return gl;
  };
  GlowLayer2.EffectName = "GlowLayer";
  GlowLayer2.DefaultBlurKernelSize = 32;
  GlowLayer2.DefaultTextureRatio = 0.5;
  __decorate([
    serialize()
  ], GlowLayer2.prototype, "blurKernelSize", null);
  __decorate([
    serialize()
  ], GlowLayer2.prototype, "intensity", null);
  __decorate([
    serialize("options")
  ], GlowLayer2.prototype, "_options", void 0);
  return GlowLayer2;
}(EffectLayer);
_TypeStore.RegisteredTypes["BABYLON.GlowLayer"] = GlowLayer;

// node_modules/@babylonjs/core/Shaders/glowBlurPostProcess.fragment.js
var name25 = "glowBlurPostProcessPixelShader";
var shader25 = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nuniform vec2 screenSize;\nuniform vec2 direction;\nuniform float blurWidth;\n\nfloat getLuminance(vec3 color)\n{\nreturn dot(color,vec3(0.2126,0.7152,0.0722));\n}\nvoid main(void)\n{\nfloat weights[7];\nweights[0]=0.05;\nweights[1]=0.1;\nweights[2]=0.2;\nweights[3]=0.3;\nweights[4]=0.2;\nweights[5]=0.1;\nweights[6]=0.05;\nvec2 texelSize=vec2(1.0/screenSize.x,1.0/screenSize.y);\nvec2 texelStep=texelSize*direction*blurWidth;\nvec2 start=vUV-3.0*texelStep;\nvec4 baseColor=vec4(0.,0.,0.,0.);\nvec2 texelOffset=vec2(0.,0.);\nfor (int i=0; i<7; i++)\n{\n\nvec4 texel=texture2D(textureSampler,start+texelOffset);\nbaseColor.a+=texel.a*weights[i];\n\nfloat luminance=getLuminance(baseColor.rgb);\nfloat luminanceTexel=getLuminance(texel.rgb);\nfloat choice=step(luminanceTexel,luminance);\nbaseColor.rgb=choice*baseColor.rgb+(1.0-choice)*texel.rgb;\ntexelOffset+=texelStep;\n}\ngl_FragColor=baseColor;\n}";
Effect.ShadersStore[name25] = shader25;

// node_modules/@babylonjs/core/Layers/highlightLayer.js
AbstractScene.prototype.getHighlightLayerByName = function(name98) {
  for (var index = 0; index < this.effectLayers.length; index++) {
    if (this.effectLayers[index].name === name98 && this.effectLayers[index].getEffectName() === HighlightLayer.EffectName) {
      return this.effectLayers[index];
    }
  }
  return null;
};
var GlowBlurPostProcess = function(_super) {
  __extends(GlowBlurPostProcess2, _super);
  function GlowBlurPostProcess2(name98, direction, kernel, options, camera, samplingMode, engine, reusable) {
    if (samplingMode === void 0) {
      samplingMode = Texture.BILINEAR_SAMPLINGMODE;
    }
    var _this = _super.call(this, name98, "glowBlurPostProcess", ["screenSize", "direction", "blurWidth"], null, options, camera, samplingMode, engine, reusable) || this;
    _this.direction = direction;
    _this.kernel = kernel;
    _this.onApplyObservable.add(function(effect) {
      effect.setFloat2("screenSize", _this.width, _this.height);
      effect.setVector2("direction", _this.direction);
      effect.setFloat("blurWidth", _this.kernel);
    });
    return _this;
  }
  return GlowBlurPostProcess2;
}(PostProcess);
var HighlightLayer = function(_super) {
  __extends(HighlightLayer2, _super);
  function HighlightLayer2(name98, scene, options) {
    var _this = _super.call(this, name98, scene) || this;
    _this.name = name98;
    _this.innerGlow = true;
    _this.outerGlow = true;
    _this.onBeforeBlurObservable = new Observable();
    _this.onAfterBlurObservable = new Observable();
    _this._instanceGlowingMeshStencilReference = HighlightLayer2.GlowingMeshStencilReference++;
    _this._meshes = {};
    _this._excludedMeshes = {};
    _this.neutralColor = HighlightLayer2.NeutralColor;
    if (!_this._engine.isStencilEnable) {
      Logger.Warn("Rendering the Highlight Layer requires the stencil to be active on the canvas. var engine = new Engine(canvas, antialias, { stencil: true }");
    }
    _this._options = __assign({ mainTextureRatio: 0.5, blurTextureSizeRatio: 0.5, blurHorizontalSize: 1, blurVerticalSize: 1, alphaBlendingMode: 2, camera: null, renderingGroupId: -1 }, options);
    _this._init({
      alphaBlendingMode: _this._options.alphaBlendingMode,
      camera: _this._options.camera,
      mainTextureFixedSize: _this._options.mainTextureFixedSize,
      mainTextureRatio: _this._options.mainTextureRatio,
      renderingGroupId: _this._options.renderingGroupId
    });
    _this._shouldRender = false;
    return _this;
  }
  Object.defineProperty(HighlightLayer2.prototype, "blurHorizontalSize", {
    get: function() {
      return this._horizontalBlurPostprocess.kernel;
    },
    set: function(value) {
      this._horizontalBlurPostprocess.kernel = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(HighlightLayer2.prototype, "blurVerticalSize", {
    get: function() {
      return this._verticalBlurPostprocess.kernel;
    },
    set: function(value) {
      this._verticalBlurPostprocess.kernel = value;
    },
    enumerable: false,
    configurable: true
  });
  HighlightLayer2.prototype.getEffectName = function() {
    return HighlightLayer2.EffectName;
  };
  HighlightLayer2.prototype._createMergeEffect = function() {
    return this._engine.createEffect("glowMapMerge", [VertexBuffer.PositionKind], ["offset"], ["textureSampler"], this._options.isStroke ? "#define STROKE \n" : void 0);
  };
  HighlightLayer2.prototype._createTextureAndPostProcesses = function() {
    var _this = this;
    var blurTextureWidth = this._mainTextureDesiredSize.width * this._options.blurTextureSizeRatio;
    var blurTextureHeight = this._mainTextureDesiredSize.height * this._options.blurTextureSizeRatio;
    blurTextureWidth = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureWidth, this._maxSize) : blurTextureWidth;
    blurTextureHeight = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureHeight, this._maxSize) : blurTextureHeight;
    var textureType = 0;
    if (this._engine.getCaps().textureHalfFloatRender) {
      textureType = 2;
    } else {
      textureType = 0;
    }
    this._blurTexture = new RenderTargetTexture("HighlightLayerBlurRTT", {
      width: blurTextureWidth,
      height: blurTextureHeight
    }, this._scene, false, true, textureType);
    this._blurTexture.wrapU = Texture.CLAMP_ADDRESSMODE;
    this._blurTexture.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._blurTexture.anisotropicFilteringLevel = 16;
    this._blurTexture.updateSamplingMode(Texture.TRILINEAR_SAMPLINGMODE);
    this._blurTexture.renderParticles = false;
    this._blurTexture.ignoreCameraViewport = true;
    this._textures = [this._blurTexture];
    if (this._options.alphaBlendingMode === 2) {
      this._downSamplePostprocess = new PassPostProcess("HighlightLayerPPP", this._options.blurTextureSizeRatio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());
      this._downSamplePostprocess.onApplyObservable.add(function(effect) {
        effect.setTexture("textureSampler", _this._mainTexture);
      });
      this._horizontalBlurPostprocess = new GlowBlurPostProcess("HighlightLayerHBP", new Vector2(1, 0), this._options.blurHorizontalSize, 1, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());
      this._horizontalBlurPostprocess.onApplyObservable.add(function(effect) {
        effect.setFloat2("screenSize", blurTextureWidth, blurTextureHeight);
      });
      this._verticalBlurPostprocess = new GlowBlurPostProcess("HighlightLayerVBP", new Vector2(0, 1), this._options.blurVerticalSize, 1, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());
      this._verticalBlurPostprocess.onApplyObservable.add(function(effect) {
        effect.setFloat2("screenSize", blurTextureWidth, blurTextureHeight);
      });
      this._postProcesses = [this._downSamplePostprocess, this._horizontalBlurPostprocess, this._verticalBlurPostprocess];
    } else {
      this._horizontalBlurPostprocess = new BlurPostProcess("HighlightLayerHBP", new Vector2(1, 0), this._options.blurHorizontalSize / 2, {
        width: blurTextureWidth,
        height: blurTextureHeight
      }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);
      this._horizontalBlurPostprocess.width = blurTextureWidth;
      this._horizontalBlurPostprocess.height = blurTextureHeight;
      this._horizontalBlurPostprocess.onApplyObservable.add(function(effect) {
        effect.setTexture("textureSampler", _this._mainTexture);
      });
      this._verticalBlurPostprocess = new BlurPostProcess("HighlightLayerVBP", new Vector2(0, 1), this._options.blurVerticalSize / 2, {
        width: blurTextureWidth,
        height: blurTextureHeight
      }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);
      this._postProcesses = [this._horizontalBlurPostprocess, this._verticalBlurPostprocess];
    }
    this._mainTexture.onAfterUnbindObservable.add(function() {
      _this.onBeforeBlurObservable.notifyObservers(_this);
      var internalTexture = _this._blurTexture.getInternalTexture();
      if (internalTexture) {
        _this._scene.postProcessManager.directRender(_this._postProcesses, internalTexture, true);
        _this._engine.unBindFramebuffer(internalTexture, true);
      }
      _this.onAfterBlurObservable.notifyObservers(_this);
    });
    this._postProcesses.map(function(pp) {
      pp.autoClear = false;
    });
  };
  HighlightLayer2.prototype.needStencil = function() {
    return true;
  };
  HighlightLayer2.prototype.isReady = function(subMesh, useInstances) {
    var material = subMesh.getMaterial();
    var mesh = subMesh.getRenderingMesh();
    if (!material || !mesh || !this._meshes) {
      return false;
    }
    var emissiveTexture = null;
    var highlightLayerMesh = this._meshes[mesh.uniqueId];
    if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {
      emissiveTexture = material.emissiveTexture;
    }
    return _super.prototype._isReady.call(this, subMesh, useInstances, emissiveTexture);
  };
  HighlightLayer2.prototype._internalRender = function(effect) {
    effect.setTexture("textureSampler", this._blurTexture);
    var engine = this._engine;
    engine.cacheStencilState();
    engine.setStencilOperationPass(7681);
    engine.setStencilOperationFail(7680);
    engine.setStencilOperationDepthFail(7680);
    engine.setStencilMask(0);
    engine.setStencilBuffer(true);
    engine.setStencilFunctionReference(this._instanceGlowingMeshStencilReference);
    if (this.outerGlow) {
      effect.setFloat("offset", 0);
      engine.setStencilFunction(517);
      engine.drawElementsType(Material.TriangleFillMode, 0, 6);
    }
    if (this.innerGlow) {
      effect.setFloat("offset", 1);
      engine.setStencilFunction(514);
      engine.drawElementsType(Material.TriangleFillMode, 0, 6);
    }
    engine.restoreStencilState();
  };
  HighlightLayer2.prototype.shouldRender = function() {
    if (_super.prototype.shouldRender.call(this)) {
      return this._meshes ? true : false;
    }
    return false;
  };
  HighlightLayer2.prototype._shouldRenderMesh = function(mesh) {
    if (this._excludedMeshes && this._excludedMeshes[mesh.uniqueId]) {
      return false;
    }
    if (!_super.prototype.hasMesh.call(this, mesh)) {
      return false;
    }
    return true;
  };
  HighlightLayer2.prototype._canRenderMesh = function(mesh, material) {
    return true;
  };
  HighlightLayer2.prototype._addCustomEffectDefines = function(defines) {
    defines.push("#define HIGHLIGHT");
  };
  HighlightLayer2.prototype._setEmissiveTextureAndColor = function(mesh, subMesh, material) {
    var highlightLayerMesh = this._meshes[mesh.uniqueId];
    if (highlightLayerMesh) {
      this._emissiveTextureAndColor.color.set(highlightLayerMesh.color.r, highlightLayerMesh.color.g, highlightLayerMesh.color.b, 1);
    } else {
      this._emissiveTextureAndColor.color.set(this.neutralColor.r, this.neutralColor.g, this.neutralColor.b, this.neutralColor.a);
    }
    if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {
      this._emissiveTextureAndColor.texture = material.emissiveTexture;
      this._emissiveTextureAndColor.color.set(1, 1, 1, 1);
    } else {
      this._emissiveTextureAndColor.texture = null;
    }
  };
  HighlightLayer2.prototype.addExcludedMesh = function(mesh) {
    if (!this._excludedMeshes) {
      return;
    }
    var meshExcluded = this._excludedMeshes[mesh.uniqueId];
    if (!meshExcluded) {
      this._excludedMeshes[mesh.uniqueId] = {
        mesh,
        beforeBind: mesh.onBeforeBindObservable.add(function(mesh2) {
          mesh2.getEngine().setStencilBuffer(false);
        }),
        afterRender: mesh.onAfterRenderObservable.add(function(mesh2) {
          mesh2.getEngine().setStencilBuffer(true);
        })
      };
    }
  };
  HighlightLayer2.prototype.removeExcludedMesh = function(mesh) {
    if (!this._excludedMeshes) {
      return;
    }
    var meshExcluded = this._excludedMeshes[mesh.uniqueId];
    if (meshExcluded) {
      if (meshExcluded.beforeBind) {
        mesh.onBeforeBindObservable.remove(meshExcluded.beforeBind);
      }
      if (meshExcluded.afterRender) {
        mesh.onAfterRenderObservable.remove(meshExcluded.afterRender);
      }
    }
    this._excludedMeshes[mesh.uniqueId] = null;
  };
  HighlightLayer2.prototype.hasMesh = function(mesh) {
    if (!this._meshes) {
      return false;
    }
    if (!_super.prototype.hasMesh.call(this, mesh)) {
      return false;
    }
    return this._meshes[mesh.uniqueId] !== void 0 && this._meshes[mesh.uniqueId] !== null;
  };
  HighlightLayer2.prototype.addMesh = function(mesh, color, glowEmissiveOnly) {
    var _this = this;
    if (glowEmissiveOnly === void 0) {
      glowEmissiveOnly = false;
    }
    if (!this._meshes) {
      return;
    }
    var meshHighlight = this._meshes[mesh.uniqueId];
    if (meshHighlight) {
      meshHighlight.color = color;
    } else {
      this._meshes[mesh.uniqueId] = {
        mesh,
        color,
        observerHighlight: mesh.onBeforeBindObservable.add(function(mesh2) {
          if (_this.isEnabled) {
            if (_this._excludedMeshes && _this._excludedMeshes[mesh2.uniqueId]) {
              _this._defaultStencilReference(mesh2);
            } else {
              mesh2.getScene().getEngine().setStencilFunctionReference(_this._instanceGlowingMeshStencilReference);
            }
          }
        }),
        observerDefault: mesh.onAfterRenderObservable.add(function(mesh2) {
          if (_this.isEnabled) {
            _this._defaultStencilReference(mesh2);
          }
        }),
        glowEmissiveOnly
      };
      mesh.onDisposeObservable.add(function() {
        _this._disposeMesh(mesh);
      });
    }
    this._shouldRender = true;
  };
  HighlightLayer2.prototype.removeMesh = function(mesh) {
    if (!this._meshes) {
      return;
    }
    var meshHighlight = this._meshes[mesh.uniqueId];
    if (meshHighlight) {
      if (meshHighlight.observerHighlight) {
        mesh.onBeforeBindObservable.remove(meshHighlight.observerHighlight);
      }
      if (meshHighlight.observerDefault) {
        mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);
      }
      delete this._meshes[mesh.uniqueId];
    }
    this._shouldRender = false;
    for (var meshHighlightToCheck in this._meshes) {
      if (this._meshes[meshHighlightToCheck]) {
        this._shouldRender = true;
        break;
      }
    }
  };
  HighlightLayer2.prototype.removeAllMeshes = function() {
    if (!this._meshes) {
      return;
    }
    for (var uniqueId in this._meshes) {
      if (this._meshes.hasOwnProperty(uniqueId)) {
        var mesh = this._meshes[uniqueId];
        if (mesh) {
          this.removeMesh(mesh.mesh);
        }
      }
    }
  };
  HighlightLayer2.prototype._defaultStencilReference = function(mesh) {
    mesh.getScene().getEngine().setStencilFunctionReference(HighlightLayer2.NormalMeshStencilReference);
  };
  HighlightLayer2.prototype._disposeMesh = function(mesh) {
    this.removeMesh(mesh);
    this.removeExcludedMesh(mesh);
  };
  HighlightLayer2.prototype.dispose = function() {
    if (this._meshes) {
      for (var id in this._meshes) {
        var meshHighlight = this._meshes[id];
        if (meshHighlight && meshHighlight.mesh) {
          if (meshHighlight.observerHighlight) {
            meshHighlight.mesh.onBeforeBindObservable.remove(meshHighlight.observerHighlight);
          }
          if (meshHighlight.observerDefault) {
            meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);
          }
        }
      }
      this._meshes = null;
    }
    if (this._excludedMeshes) {
      for (var id in this._excludedMeshes) {
        var meshHighlight = this._excludedMeshes[id];
        if (meshHighlight) {
          if (meshHighlight.beforeBind) {
            meshHighlight.mesh.onBeforeBindObservable.remove(meshHighlight.beforeBind);
          }
          if (meshHighlight.afterRender) {
            meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.afterRender);
          }
        }
      }
      this._excludedMeshes = null;
    }
    _super.prototype.dispose.call(this);
  };
  HighlightLayer2.prototype.getClassName = function() {
    return "HighlightLayer";
  };
  HighlightLayer2.prototype.serialize = function() {
    var serializationObject = SerializationHelper.Serialize(this);
    serializationObject.customType = "BABYLON.HighlightLayer";
    serializationObject.meshes = [];
    if (this._meshes) {
      for (var m in this._meshes) {
        var mesh = this._meshes[m];
        if (mesh) {
          serializationObject.meshes.push({
            glowEmissiveOnly: mesh.glowEmissiveOnly,
            color: mesh.color.asArray(),
            meshId: mesh.mesh.id
          });
        }
      }
    }
    serializationObject.excludedMeshes = [];
    if (this._excludedMeshes) {
      for (var e in this._excludedMeshes) {
        var excludedMesh = this._excludedMeshes[e];
        if (excludedMesh) {
          serializationObject.excludedMeshes.push(excludedMesh.mesh.id);
        }
      }
    }
    return serializationObject;
  };
  HighlightLayer2.Parse = function(parsedHightlightLayer, scene, rootUrl) {
    var hl = SerializationHelper.Parse(function() {
      return new HighlightLayer2(parsedHightlightLayer.name, scene, parsedHightlightLayer.options);
    }, parsedHightlightLayer, scene, rootUrl);
    var index;
    for (index = 0; index < parsedHightlightLayer.excludedMeshes.length; index++) {
      var mesh = scene.getMeshByID(parsedHightlightLayer.excludedMeshes[index]);
      if (mesh) {
        hl.addExcludedMesh(mesh);
      }
    }
    for (index = 0; index < parsedHightlightLayer.meshes.length; index++) {
      var highlightedMesh = parsedHightlightLayer.meshes[index];
      var mesh = scene.getMeshByID(highlightedMesh.meshId);
      if (mesh) {
        hl.addMesh(mesh, Color3.FromArray(highlightedMesh.color), highlightedMesh.glowEmissiveOnly);
      }
    }
    return hl;
  };
  HighlightLayer2.EffectName = "HighlightLayer";
  HighlightLayer2.NeutralColor = new Color4(0, 0, 0, 0);
  HighlightLayer2.GlowingMeshStencilReference = 2;
  HighlightLayer2.NormalMeshStencilReference = 1;
  __decorate([
    serialize()
  ], HighlightLayer2.prototype, "innerGlow", void 0);
  __decorate([
    serialize()
  ], HighlightLayer2.prototype, "outerGlow", void 0);
  __decorate([
    serialize()
  ], HighlightLayer2.prototype, "blurHorizontalSize", null);
  __decorate([
    serialize()
  ], HighlightLayer2.prototype, "blurVerticalSize", null);
  __decorate([
    serialize("options")
  ], HighlightLayer2.prototype, "_options", void 0);
  return HighlightLayer2;
}(EffectLayer);
_TypeStore.RegisteredTypes["BABYLON.HighlightLayer"] = HighlightLayer;

// node_modules/@babylonjs/core/LensFlares/lensFlare.js
var LensFlare = function() {
  function LensFlare2(size, position, color, imgUrl, system) {
    this.size = size;
    this.position = position;
    this.alphaMode = 6;
    this.color = color || new Color3(1, 1, 1);
    this.texture = imgUrl ? new Texture(imgUrl, system.getScene(), true) : null;
    this._system = system;
    system.lensFlares.push(this);
  }
  LensFlare2.AddFlare = function(size, position, color, imgUrl, system) {
    return new LensFlare2(size, position, color, imgUrl, system);
  };
  LensFlare2.prototype.dispose = function() {
    if (this.texture) {
      this.texture.dispose();
    }
    var index = this._system.lensFlares.indexOf(this);
    this._system.lensFlares.splice(index, 1);
  };
  return LensFlare2;
}();

// node_modules/@babylonjs/core/Shaders/lensFlare.fragment.js
var name26 = "lensFlarePixelShader";
var shader26 = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nuniform vec4 color;\nvoid main(void) {\nvec4 baseColor=texture2D(textureSampler,vUV);\ngl_FragColor=baseColor*color;\n}";
Effect.ShadersStore[name26] = shader26;

// node_modules/@babylonjs/core/Shaders/lensFlare.vertex.js
var name27 = "lensFlareVertexShader";
var shader27 = "\nattribute vec2 position;\n\nuniform mat4 viewportMatrix;\n\nvarying vec2 vUV;\nconst vec2 madd=vec2(0.5,0.5);\nvoid main(void) {\nvUV=position*madd+madd;\ngl_Position=viewportMatrix*vec4(position,0.0,1.0);\n}";
Effect.ShadersStore[name27] = shader27;

// node_modules/@babylonjs/core/LensFlares/lensFlareSystem.js
var LensFlareSystem = function() {
  function LensFlareSystem2(name98, emitter, scene) {
    this.name = name98;
    this.lensFlares = new Array();
    this.borderLimit = 300;
    this.viewportBorder = 0;
    this.layerMask = 268435455;
    this._vertexBuffers = {};
    this._isEnabled = true;
    this._scene = scene || EngineStore.LastCreatedScene;
    LensFlareSystem2._SceneComponentInitialization(this._scene);
    this._emitter = emitter;
    this.id = name98;
    scene.lensFlareSystems.push(this);
    this.meshesSelectionPredicate = function(m) {
      return scene.activeCamera && m.material && m.isVisible && m.isEnabled() && m.isBlocker && (m.layerMask & scene.activeCamera.layerMask) != 0;
    };
    var engine = scene.getEngine();
    var vertices = [];
    vertices.push(1, 1);
    vertices.push(-1, 1);
    vertices.push(-1, -1);
    vertices.push(1, -1);
    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2);
    var indices = [];
    indices.push(0);
    indices.push(1);
    indices.push(2);
    indices.push(0);
    indices.push(2);
    indices.push(3);
    this._indexBuffer = engine.createIndexBuffer(indices);
    this._effect = engine.createEffect("lensFlare", [VertexBuffer.PositionKind], ["color", "viewportMatrix"], ["textureSampler"], "");
  }
  Object.defineProperty(LensFlareSystem2.prototype, "isEnabled", {
    get: function() {
      return this._isEnabled;
    },
    set: function(value) {
      this._isEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  LensFlareSystem2.prototype.getScene = function() {
    return this._scene;
  };
  LensFlareSystem2.prototype.getEmitter = function() {
    return this._emitter;
  };
  LensFlareSystem2.prototype.setEmitter = function(newEmitter) {
    this._emitter = newEmitter;
  };
  LensFlareSystem2.prototype.getEmitterPosition = function() {
    return this._emitter.getAbsolutePosition ? this._emitter.getAbsolutePosition() : this._emitter.position;
  };
  LensFlareSystem2.prototype.computeEffectivePosition = function(globalViewport) {
    var position = this.getEmitterPosition();
    position = Vector3.Project(position, Matrix.Identity(), this._scene.getTransformMatrix(), globalViewport);
    this._positionX = position.x;
    this._positionY = position.y;
    position = Vector3.TransformCoordinates(this.getEmitterPosition(), this._scene.getViewMatrix());
    if (this.viewportBorder > 0) {
      globalViewport.x -= this.viewportBorder;
      globalViewport.y -= this.viewportBorder;
      globalViewport.width += this.viewportBorder * 2;
      globalViewport.height += this.viewportBorder * 2;
      position.x += this.viewportBorder;
      position.y += this.viewportBorder;
      this._positionX += this.viewportBorder;
      this._positionY += this.viewportBorder;
    }
    if (position.z > 0) {
      if (this._positionX > globalViewport.x && this._positionX < globalViewport.x + globalViewport.width) {
        if (this._positionY > globalViewport.y && this._positionY < globalViewport.y + globalViewport.height) {
          return true;
        }
      }
      return true;
    }
    return false;
  };
  LensFlareSystem2.prototype._isVisible = function() {
    if (!this._isEnabled || !this._scene.activeCamera) {
      return false;
    }
    var emitterPosition = this.getEmitterPosition();
    var direction = emitterPosition.subtract(this._scene.activeCamera.globalPosition);
    var distance = direction.length();
    direction.normalize();
    var ray = new Ray(this._scene.activeCamera.globalPosition, direction);
    var pickInfo = this._scene.pickWithRay(ray, this.meshesSelectionPredicate, true);
    return !pickInfo || !pickInfo.hit || pickInfo.distance > distance;
  };
  LensFlareSystem2.prototype.render = function() {
    if (!this._effect.isReady() || !this._scene.activeCamera) {
      return false;
    }
    var engine = this._scene.getEngine();
    var viewport = this._scene.activeCamera.viewport;
    var globalViewport = viewport.toGlobal(engine.getRenderWidth(true), engine.getRenderHeight(true));
    if (!this.computeEffectivePosition(globalViewport)) {
      return false;
    }
    if (!this._isVisible()) {
      return false;
    }
    var awayX;
    var awayY;
    if (this._positionX < this.borderLimit + globalViewport.x) {
      awayX = this.borderLimit + globalViewport.x - this._positionX;
    } else if (this._positionX > globalViewport.x + globalViewport.width - this.borderLimit) {
      awayX = this._positionX - globalViewport.x - globalViewport.width + this.borderLimit;
    } else {
      awayX = 0;
    }
    if (this._positionY < this.borderLimit + globalViewport.y) {
      awayY = this.borderLimit + globalViewport.y - this._positionY;
    } else if (this._positionY > globalViewport.y + globalViewport.height - this.borderLimit) {
      awayY = this._positionY - globalViewport.y - globalViewport.height + this.borderLimit;
    } else {
      awayY = 0;
    }
    var away = awayX > awayY ? awayX : awayY;
    away -= this.viewportBorder;
    if (away > this.borderLimit) {
      away = this.borderLimit;
    }
    var intensity = 1 - Scalar.Clamp(away / this.borderLimit, 0, 1);
    if (intensity < 0) {
      return false;
    }
    if (intensity > 1) {
      intensity = 1;
    }
    if (this.viewportBorder > 0) {
      globalViewport.x += this.viewportBorder;
      globalViewport.y += this.viewportBorder;
      globalViewport.width -= this.viewportBorder * 2;
      globalViewport.height -= this.viewportBorder * 2;
      this._positionX -= this.viewportBorder;
      this._positionY -= this.viewportBorder;
    }
    var centerX = globalViewport.x + globalViewport.width / 2;
    var centerY = globalViewport.y + globalViewport.height / 2;
    var distX = centerX - this._positionX;
    var distY = centerY - this._positionY;
    engine.enableEffect(this._effect);
    engine.setState(false);
    engine.setDepthBuffer(false);
    engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._effect);
    for (var index = 0; index < this.lensFlares.length; index++) {
      var flare = this.lensFlares[index];
      if (flare.texture && !flare.texture.isReady()) {
        continue;
      }
      engine.setAlphaMode(flare.alphaMode);
      var x = centerX - distX * flare.position;
      var y = centerY - distY * flare.position;
      var cw = flare.size;
      var ch = flare.size * engine.getAspectRatio(this._scene.activeCamera, true);
      var cx = 2 * (x / (globalViewport.width + globalViewport.x * 2)) - 1;
      var cy = 1 - 2 * (y / (globalViewport.height + globalViewport.y * 2));
      var viewportMatrix = Matrix.FromValues(cw / 2, 0, 0, 0, 0, ch / 2, 0, 0, 0, 0, 1, 0, cx, cy, 0, 1);
      this._effect.setMatrix("viewportMatrix", viewportMatrix);
      this._effect.setTexture("textureSampler", flare.texture);
      this._effect.setFloat4("color", flare.color.r * intensity, flare.color.g * intensity, flare.color.b * intensity, 1);
      engine.drawElementsType(Material.TriangleFillMode, 0, 6);
    }
    engine.setDepthBuffer(true);
    engine.setAlphaMode(0);
    return true;
  };
  LensFlareSystem2.prototype.dispose = function() {
    var vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vertexBuffer) {
      vertexBuffer.dispose();
      this._vertexBuffers[VertexBuffer.PositionKind] = null;
    }
    if (this._indexBuffer) {
      this._scene.getEngine()._releaseBuffer(this._indexBuffer);
      this._indexBuffer = null;
    }
    while (this.lensFlares.length) {
      this.lensFlares[0].dispose();
    }
    var index = this._scene.lensFlareSystems.indexOf(this);
    this._scene.lensFlareSystems.splice(index, 1);
  };
  LensFlareSystem2.Parse = function(parsedLensFlareSystem, scene, rootUrl) {
    var emitter = scene.getLastEntryByID(parsedLensFlareSystem.emitterId);
    var name98 = parsedLensFlareSystem.name || "lensFlareSystem#" + parsedLensFlareSystem.emitterId;
    var lensFlareSystem = new LensFlareSystem2(name98, emitter, scene);
    lensFlareSystem.id = parsedLensFlareSystem.id || name98;
    lensFlareSystem.borderLimit = parsedLensFlareSystem.borderLimit;
    for (var index = 0; index < parsedLensFlareSystem.flares.length; index++) {
      var parsedFlare = parsedLensFlareSystem.flares[index];
      LensFlare.AddFlare(parsedFlare.size, parsedFlare.position, Color3.FromArray(parsedFlare.color), parsedFlare.textureName ? rootUrl + parsedFlare.textureName : "", lensFlareSystem);
    }
    return lensFlareSystem;
  };
  LensFlareSystem2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.id = this.id;
    serializationObject.name = this.name;
    serializationObject.emitterId = this.getEmitter().id;
    serializationObject.borderLimit = this.borderLimit;
    serializationObject.flares = [];
    for (var index = 0; index < this.lensFlares.length; index++) {
      var flare = this.lensFlares[index];
      serializationObject.flares.push({
        size: flare.size,
        position: flare.position,
        color: flare.color.asArray(),
        textureName: Tools.GetFilename(flare.texture ? flare.texture.name : "")
      });
    }
    return serializationObject;
  };
  LensFlareSystem2._SceneComponentInitialization = function(_) {
    throw _DevTools.WarnImport("LensFlareSystemSceneComponent");
  };
  return LensFlareSystem2;
}();

// node_modules/@babylonjs/core/LensFlares/lensFlareSystemSceneComponent.js
AbstractScene.AddParser(SceneComponentConstants.NAME_LENSFLARESYSTEM, function(parsedData, scene, container, rootUrl) {
  if (parsedData.lensFlareSystems !== void 0 && parsedData.lensFlareSystems !== null) {
    if (!container.lensFlareSystems) {
      container.lensFlareSystems = new Array();
    }
    for (var index = 0, cache = parsedData.lensFlareSystems.length; index < cache; index++) {
      var parsedLensFlareSystem = parsedData.lensFlareSystems[index];
      var lf = LensFlareSystem.Parse(parsedLensFlareSystem, scene, rootUrl);
      container.lensFlareSystems.push(lf);
    }
  }
});
AbstractScene.prototype.getLensFlareSystemByName = function(name98) {
  for (var index = 0; index < this.lensFlareSystems.length; index++) {
    if (this.lensFlareSystems[index].name === name98) {
      return this.lensFlareSystems[index];
    }
  }
  return null;
};
AbstractScene.prototype.getLensFlareSystemByID = function(id) {
  for (var index = 0; index < this.lensFlareSystems.length; index++) {
    if (this.lensFlareSystems[index].id === id) {
      return this.lensFlareSystems[index];
    }
  }
  return null;
};
AbstractScene.prototype.removeLensFlareSystem = function(toRemove) {
  var index = this.lensFlareSystems.indexOf(toRemove);
  if (index !== -1) {
    this.lensFlareSystems.splice(index, 1);
  }
  return index;
};
AbstractScene.prototype.addLensFlareSystem = function(newLensFlareSystem) {
  this.lensFlareSystems.push(newLensFlareSystem);
};
var LensFlareSystemSceneComponent = function() {
  function LensFlareSystemSceneComponent2(scene) {
    this.name = SceneComponentConstants.NAME_LENSFLARESYSTEM;
    this.scene = scene;
    scene.lensFlareSystems = new Array();
  }
  LensFlareSystemSceneComponent2.prototype.register = function() {
    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_LENSFLARESYSTEM, this, this._draw);
  };
  LensFlareSystemSceneComponent2.prototype.rebuild = function() {
  };
  LensFlareSystemSceneComponent2.prototype.addFromContainer = function(container) {
    var _this = this;
    if (!container.lensFlareSystems) {
      return;
    }
    container.lensFlareSystems.forEach(function(o) {
      _this.scene.addLensFlareSystem(o);
    });
  };
  LensFlareSystemSceneComponent2.prototype.removeFromContainer = function(container, dispose) {
    var _this = this;
    if (!container.lensFlareSystems) {
      return;
    }
    container.lensFlareSystems.forEach(function(o) {
      _this.scene.removeLensFlareSystem(o);
      if (dispose) {
        o.dispose();
      }
    });
  };
  LensFlareSystemSceneComponent2.prototype.serialize = function(serializationObject) {
    serializationObject.lensFlareSystems = [];
    var lensFlareSystems = this.scene.lensFlareSystems;
    for (var _i = 0, lensFlareSystems_1 = lensFlareSystems; _i < lensFlareSystems_1.length; _i++) {
      var lensFlareSystem = lensFlareSystems_1[_i];
      serializationObject.lensFlareSystems.push(lensFlareSystem.serialize());
    }
  };
  LensFlareSystemSceneComponent2.prototype.dispose = function() {
    var lensFlareSystems = this.scene.lensFlareSystems;
    while (lensFlareSystems.length) {
      lensFlareSystems[0].dispose();
    }
  };
  LensFlareSystemSceneComponent2.prototype._draw = function(camera) {
    if (this.scene.lensFlaresEnabled) {
      var lensFlareSystems = this.scene.lensFlareSystems;
      Tools.StartPerformanceCounter("Lens flares", lensFlareSystems.length > 0);
      for (var _i = 0, lensFlareSystems_2 = lensFlareSystems; _i < lensFlareSystems_2.length; _i++) {
        var lensFlareSystem = lensFlareSystems_2[_i];
        if ((camera.layerMask & lensFlareSystem.layerMask) !== 0) {
          lensFlareSystem.render();
        }
      }
      Tools.EndPerformanceCounter("Lens flares", lensFlareSystems.length > 0);
    }
  };
  return LensFlareSystemSceneComponent2;
}();
LensFlareSystem._SceneComponentInitialization = function(scene) {
  var component = scene._getComponent(SceneComponentConstants.NAME_LENSFLARESYSTEM);
  if (!component) {
    component = new LensFlareSystemSceneComponent(scene);
    scene._addComponent(component);
  }
};

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bayerDitherFunctions.js
var name28 = "bayerDitherFunctions";
var shader28 = "\n\n\n\n\nfloat bayerDither2(vec2 _P) {\nreturn mod(2.0*_P.y+_P.x+1.0,4.0);\n}\n\n\nfloat bayerDither4(vec2 _P) {\nvec2 P1=mod(_P,2.0);\nvec2 P2=floor(0.5*mod(_P,4.0));\nreturn 4.0*bayerDither2(P1)+bayerDither2(P2);\n}\n\nfloat bayerDither8(vec2 _P) {\nvec2 P1=mod(_P,2.0);\nvec2 P2=floor(0.5*mod(_P,4.0));\nvec2 P4=floor(0.25*mod(_P,8.0));\nreturn 4.0*(4.0*bayerDither2(P1)+bayerDither2(P2))+bayerDither2(P4);\n}\n";
Effect.IncludesShadersStore[name28] = shader28;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapFragmentDeclaration.js
var name29 = "shadowMapFragmentDeclaration";
var shader29 = "#if SM_FLOAT == 0\n#include<packingFunctions>\n#endif\n#if SM_SOFTTRANSPARENTSHADOW == 1\n#include<bayerDitherFunctions>\nuniform float softTransparentShadowSM;\n#endif\nvarying float vDepthMetricSM;\n#if SM_USEDISTANCE == 1\nuniform vec3 lightDataSM;\nvarying vec3 vPositionWSM;\n#endif\nuniform vec3 biasAndScaleSM;\nuniform vec2 depthValuesSM;\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP == 1\nvarying float zSM;\n#endif\n";
Effect.IncludesShadersStore[name29] = shader29;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapFragment.js
var name30 = "shadowMapFragment";
var shader30 = " float depthSM=vDepthMetricSM;\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP == 1\n#if SM_USEDISTANCE == 1\ndepthSM=clamp(((length(vPositionWSM-lightDataSM)+depthValuesSM.x)/(depthValuesSM.y))+biasAndScaleSM.x,0.0,1.0);\n#else\ndepthSM=clamp(((zSM+depthValuesSM.x)/(depthValuesSM.y))+biasAndScaleSM.x,0.0,1.0);\n#endif\ngl_FragDepth=depthSM;\n#elif SM_USEDISTANCE == 1\ndepthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/(depthValuesSM.y)+biasAndScaleSM.x;\n#endif\n#if SM_ESM == 1\ndepthSM=clamp(exp(-min(87.,biasAndScaleSM.z*depthSM)),0.,1.);\n#endif\n#if SM_FLOAT == 1\ngl_FragColor=vec4(depthSM,1.0,1.0,1.0);\n#else\ngl_FragColor=pack(depthSM);\n#endif\nreturn;";
Effect.IncludesShadersStore[name30] = shader30;

// node_modules/@babylonjs/core/Shaders/shadowMap.fragment.js
var name31 = "shadowMapPixelShader";
var shader31 = "#include<shadowMapFragmentDeclaration>\n#ifdef ALPHATEST\nvarying vec2 vUV;\nuniform sampler2D diffuseSampler;\n#endif\n#include<clipPlaneFragmentDeclaration>\nvoid main(void)\n{\n#include<clipPlaneFragment>\n#ifdef ALPHATEST\nfloat alphaFromAlphaTexture=texture2D(diffuseSampler,vUV).a;\nif (alphaFromAlphaTexture<0.4)\ndiscard;\n#endif\n#if SM_SOFTTRANSPARENTSHADOW == 1\n#ifdef ALPHATEST\nif ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM*alphaFromAlphaTexture) discard;\n#else\nif ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM) discard;\n#endif\n#endif\n#include<shadowMapFragment>\n}";
Effect.ShadersStore[name31] = shader31;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapVertexDeclaration.js
var name32 = "shadowMapVertexDeclaration";
var shader32 = "#if SM_NORMALBIAS == 1\nuniform vec3 lightDataSM;\n#endif\nuniform vec3 biasAndScaleSM;\nuniform vec2 depthValuesSM;\nvarying float vDepthMetricSM;\n#if SM_USEDISTANCE == 1\nvarying vec3 vPositionWSM;\n#endif\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP == 1\nvarying float zSM;\n#endif\n";
Effect.IncludesShadersStore[name32] = shader32;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapVertexNormalBias.js
var name33 = "shadowMapVertexNormalBias";
var shader33 = "\n#if SM_NORMALBIAS == 1\n#if SM_DIRECTIONINLIGHTDATA == 1\nvec3 worldLightDirSM=normalize(-lightDataSM.xyz);\n#else\nvec3 directionToLightSM=lightDataSM.xyz-worldPos.xyz;\nvec3 worldLightDirSM=normalize(directionToLightSM);\n#endif\nfloat ndlSM=dot(vNormalW,worldLightDirSM);\nfloat sinNLSM=sqrt(1.0-ndlSM*ndlSM);\nfloat normalBiasSM=biasAndScaleSM.y*sinNLSM;\nworldPos.xyz-=vNormalW*normalBiasSM;\n#endif\n";
Effect.IncludesShadersStore[name33] = shader33;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapVertexMetric.js
var name34 = "shadowMapVertexMetric";
var shader34 = "#if SM_USEDISTANCE == 1\nvPositionWSM=worldPos.xyz;\n#endif\n#if SM_DEPTHTEXTURE == 1\n\ngl_Position.z+=biasAndScaleSM.x*gl_Position.w;\n#endif\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP == 1\nzSM=gl_Position.z;\ngl_Position.z=0.0;\n#elif SM_USEDISTANCE == 0\n\nvDepthMetricSM=((gl_Position.z+depthValuesSM.x)/(depthValuesSM.y))+biasAndScaleSM.x;\n#endif\n";
Effect.IncludesShadersStore[name34] = shader34;

// node_modules/@babylonjs/core/Shaders/shadowMap.vertex.js
var name35 = "shadowMapVertexShader";
var shader35 = "\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#include<bonesDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n\n#include<instancesDeclaration>\n#include<helperFunctions>\nuniform mat4 viewProjection;\n#ifdef ALPHATEST\nvarying vec2 vUV;\nuniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\n#include<shadowMapVertexDeclaration>\n#include<clipPlaneVertexDeclaration>\nvoid main(void)\n{\nvec3 positionUpdated=position;\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#ifdef NORMAL\nvec3 normalUpdated=normal;\n#endif\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\n#ifdef NORMAL\nmat3 normWorldSM=mat3(finalWorld);\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvec3 vNormalW=normalUpdated/vec3(dot(normWorldSM[0],normWorldSM[0]),dot(normWorldSM[1],normWorldSM[1]),dot(normWorldSM[2],normWorldSM[2]));\nvNormalW=normalize(normWorldSM*vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormWorldSM=transposeMat3(inverseMat3(normWorldSM));\n#endif\nvec3 vNormalW=normalize(normWorldSM*normalUpdated);\n#endif\n#endif\n#include<shadowMapVertexNormalBias>\n\ngl_Position=viewProjection*worldPos;\n#include<shadowMapVertexMetric>\n#ifdef ALPHATEST\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n#include<clipPlaneVertex>\n}";
Effect.ShadersStore[name35] = shader35;

// node_modules/@babylonjs/core/Shaders/depthBoxBlur.fragment.js
var name36 = "depthBoxBlurPixelShader";
var shader36 = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nuniform vec2 screenSize;\nvoid main(void)\n{\nvec4 colorDepth=vec4(0.0);\nfor (int x=-OFFSET; x<=OFFSET; x++)\nfor (int y=-OFFSET; y<=OFFSET; y++)\ncolorDepth+=texture2D(textureSampler,vUV+vec2(x,y)/screenSize);\ngl_FragColor=(colorDepth/float((OFFSET*2+1)*(OFFSET*2+1)));\n}";
Effect.ShadersStore[name36] = shader36;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapFragmentSoftTransparentShadow.js
var name37 = "shadowMapFragmentSoftTransparentShadow";
var shader37 = "#if SM_SOFTTRANSPARENTSHADOW == 1\nif ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM*alpha) discard;\n#endif\n";
Effect.IncludesShadersStore[name37] = shader37;

// node_modules/@babylonjs/core/Lights/Shadows/shadowGenerator.js
var tmpMatrix = new Matrix();
var tmpMatrix2 = new Matrix();
var ShadowGenerator = function() {
  function ShadowGenerator2(mapSize, light, usefulFloatFirst) {
    this.onBeforeShadowMapRenderObservable = new Observable();
    this.onAfterShadowMapRenderObservable = new Observable();
    this.onBeforeShadowMapRenderMeshObservable = new Observable();
    this.onAfterShadowMapRenderMeshObservable = new Observable();
    this._bias = 5e-5;
    this._normalBias = 0;
    this._blurBoxOffset = 1;
    this._blurScale = 2;
    this._blurKernel = 1;
    this._useKernelBlur = false;
    this._filter = ShadowGenerator2.FILTER_NONE;
    this._filteringQuality = ShadowGenerator2.QUALITY_HIGH;
    this._contactHardeningLightSizeUVRatio = 0.1;
    this._darkness = 0;
    this._transparencyShadow = false;
    this.enableSoftTransparentShadow = false;
    this.frustumEdgeFalloff = 0;
    this.forceBackFacesOnly = false;
    this._lightDirection = Vector3.Zero();
    this._viewMatrix = Matrix.Zero();
    this._projectionMatrix = Matrix.Zero();
    this._transformMatrix = Matrix.Zero();
    this._cachedPosition = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cachedDirection = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._currentFaceIndex = 0;
    this._currentFaceIndexCache = 0;
    this._defaultTextureMatrix = Matrix.Identity();
    this._mapSize = mapSize;
    this._light = light;
    this._scene = light.getScene();
    light._shadowGenerator = this;
    this.id = light.id;
    ShadowGenerator2._SceneComponentInitialization(this._scene);
    var caps = this._scene.getEngine().getCaps();
    if (!usefulFloatFirst) {
      if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
        this._textureType = 2;
      } else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
        this._textureType = 1;
      } else {
        this._textureType = 0;
      }
    } else {
      if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
        this._textureType = 1;
      } else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
        this._textureType = 2;
      } else {
        this._textureType = 0;
      }
    }
    this._initializeGenerator();
    this._applyFilterValues();
  }
  Object.defineProperty(ShadowGenerator2.prototype, "bias", {
    get: function() {
      return this._bias;
    },
    set: function(bias) {
      this._bias = bias;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "normalBias", {
    get: function() {
      return this._normalBias;
    },
    set: function(normalBias) {
      this._normalBias = normalBias;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "blurBoxOffset", {
    get: function() {
      return this._blurBoxOffset;
    },
    set: function(value) {
      if (this._blurBoxOffset === value) {
        return;
      }
      this._blurBoxOffset = value;
      this._disposeBlurPostProcesses();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "blurScale", {
    get: function() {
      return this._blurScale;
    },
    set: function(value) {
      if (this._blurScale === value) {
        return;
      }
      this._blurScale = value;
      this._disposeBlurPostProcesses();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "blurKernel", {
    get: function() {
      return this._blurKernel;
    },
    set: function(value) {
      if (this._blurKernel === value) {
        return;
      }
      this._blurKernel = value;
      this._disposeBlurPostProcesses();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "useKernelBlur", {
    get: function() {
      return this._useKernelBlur;
    },
    set: function(value) {
      if (this._useKernelBlur === value) {
        return;
      }
      this._useKernelBlur = value;
      this._disposeBlurPostProcesses();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "depthScale", {
    get: function() {
      return this._depthScale !== void 0 ? this._depthScale : this._light.getDepthScale();
    },
    set: function(value) {
      this._depthScale = value;
    },
    enumerable: false,
    configurable: true
  });
  ShadowGenerator2.prototype._validateFilter = function(filter) {
    return filter;
  };
  Object.defineProperty(ShadowGenerator2.prototype, "filter", {
    get: function() {
      return this._filter;
    },
    set: function(value) {
      value = this._validateFilter(value);
      if (this._light.needCube()) {
        if (value === ShadowGenerator2.FILTER_BLUREXPONENTIALSHADOWMAP) {
          this.useExponentialShadowMap = true;
          return;
        } else if (value === ShadowGenerator2.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) {
          this.useCloseExponentialShadowMap = true;
          return;
        } else if (value === ShadowGenerator2.FILTER_PCF || value === ShadowGenerator2.FILTER_PCSS) {
          this.usePoissonSampling = true;
          return;
        }
      }
      if (value === ShadowGenerator2.FILTER_PCF || value === ShadowGenerator2.FILTER_PCSS) {
        if (this._scene.getEngine().webGLVersion === 1) {
          this.usePoissonSampling = true;
          return;
        }
      }
      if (this._filter === value) {
        return;
      }
      this._filter = value;
      this._disposeBlurPostProcesses();
      this._applyFilterValues();
      this._light._markMeshesAsLightDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "usePoissonSampling", {
    get: function() {
      return this.filter === ShadowGenerator2.FILTER_POISSONSAMPLING;
    },
    set: function(value) {
      var filter = this._validateFilter(ShadowGenerator2.FILTER_POISSONSAMPLING);
      if (!value && this.filter !== ShadowGenerator2.FILTER_POISSONSAMPLING) {
        return;
      }
      this.filter = value ? filter : ShadowGenerator2.FILTER_NONE;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "useExponentialShadowMap", {
    get: function() {
      return this.filter === ShadowGenerator2.FILTER_EXPONENTIALSHADOWMAP;
    },
    set: function(value) {
      var filter = this._validateFilter(ShadowGenerator2.FILTER_EXPONENTIALSHADOWMAP);
      if (!value && this.filter !== ShadowGenerator2.FILTER_EXPONENTIALSHADOWMAP) {
        return;
      }
      this.filter = value ? filter : ShadowGenerator2.FILTER_NONE;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "useBlurExponentialShadowMap", {
    get: function() {
      return this.filter === ShadowGenerator2.FILTER_BLUREXPONENTIALSHADOWMAP;
    },
    set: function(value) {
      var filter = this._validateFilter(ShadowGenerator2.FILTER_BLUREXPONENTIALSHADOWMAP);
      if (!value && this.filter !== ShadowGenerator2.FILTER_BLUREXPONENTIALSHADOWMAP) {
        return;
      }
      this.filter = value ? filter : ShadowGenerator2.FILTER_NONE;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "useCloseExponentialShadowMap", {
    get: function() {
      return this.filter === ShadowGenerator2.FILTER_CLOSEEXPONENTIALSHADOWMAP;
    },
    set: function(value) {
      var filter = this._validateFilter(ShadowGenerator2.FILTER_CLOSEEXPONENTIALSHADOWMAP);
      if (!value && this.filter !== ShadowGenerator2.FILTER_CLOSEEXPONENTIALSHADOWMAP) {
        return;
      }
      this.filter = value ? filter : ShadowGenerator2.FILTER_NONE;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "useBlurCloseExponentialShadowMap", {
    get: function() {
      return this.filter === ShadowGenerator2.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP;
    },
    set: function(value) {
      var filter = this._validateFilter(ShadowGenerator2.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP);
      if (!value && this.filter !== ShadowGenerator2.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) {
        return;
      }
      this.filter = value ? filter : ShadowGenerator2.FILTER_NONE;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "usePercentageCloserFiltering", {
    get: function() {
      return this.filter === ShadowGenerator2.FILTER_PCF;
    },
    set: function(value) {
      var filter = this._validateFilter(ShadowGenerator2.FILTER_PCF);
      if (!value && this.filter !== ShadowGenerator2.FILTER_PCF) {
        return;
      }
      this.filter = value ? filter : ShadowGenerator2.FILTER_NONE;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "filteringQuality", {
    get: function() {
      return this._filteringQuality;
    },
    set: function(filteringQuality) {
      if (this._filteringQuality === filteringQuality) {
        return;
      }
      this._filteringQuality = filteringQuality;
      this._disposeBlurPostProcesses();
      this._applyFilterValues();
      this._light._markMeshesAsLightDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "useContactHardeningShadow", {
    get: function() {
      return this.filter === ShadowGenerator2.FILTER_PCSS;
    },
    set: function(value) {
      var filter = this._validateFilter(ShadowGenerator2.FILTER_PCSS);
      if (!value && this.filter !== ShadowGenerator2.FILTER_PCSS) {
        return;
      }
      this.filter = value ? filter : ShadowGenerator2.FILTER_NONE;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "contactHardeningLightSizeUVRatio", {
    get: function() {
      return this._contactHardeningLightSizeUVRatio;
    },
    set: function(contactHardeningLightSizeUVRatio) {
      this._contactHardeningLightSizeUVRatio = contactHardeningLightSizeUVRatio;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "darkness", {
    get: function() {
      return this._darkness;
    },
    set: function(value) {
      this.setDarkness(value);
    },
    enumerable: false,
    configurable: true
  });
  ShadowGenerator2.prototype.getDarkness = function() {
    return this._darkness;
  };
  ShadowGenerator2.prototype.setDarkness = function(darkness) {
    if (darkness >= 1) {
      this._darkness = 1;
    } else if (darkness <= 0) {
      this._darkness = 0;
    } else {
      this._darkness = darkness;
    }
    return this;
  };
  Object.defineProperty(ShadowGenerator2.prototype, "transparencyShadow", {
    get: function() {
      return this._transparencyShadow;
    },
    set: function(value) {
      this.setTransparencyShadow(value);
    },
    enumerable: false,
    configurable: true
  });
  ShadowGenerator2.prototype.setTransparencyShadow = function(transparent) {
    this._transparencyShadow = transparent;
    return this;
  };
  ShadowGenerator2.prototype.getShadowMap = function() {
    return this._shadowMap;
  };
  ShadowGenerator2.prototype.getShadowMapForRendering = function() {
    if (this._shadowMap2) {
      return this._shadowMap2;
    }
    return this._shadowMap;
  };
  ShadowGenerator2.prototype.getClassName = function() {
    return ShadowGenerator2.CLASSNAME;
  };
  ShadowGenerator2.prototype.addShadowCaster = function(mesh, includeDescendants) {
    var _a;
    if (includeDescendants === void 0) {
      includeDescendants = true;
    }
    if (!this._shadowMap) {
      return this;
    }
    if (!this._shadowMap.renderList) {
      this._shadowMap.renderList = [];
    }
    this._shadowMap.renderList.push(mesh);
    if (includeDescendants) {
      (_a = this._shadowMap.renderList).push.apply(_a, mesh.getChildMeshes());
    }
    return this;
  };
  ShadowGenerator2.prototype.removeShadowCaster = function(mesh, includeDescendants) {
    if (includeDescendants === void 0) {
      includeDescendants = true;
    }
    if (!this._shadowMap || !this._shadowMap.renderList) {
      return this;
    }
    var index = this._shadowMap.renderList.indexOf(mesh);
    if (index !== -1) {
      this._shadowMap.renderList.splice(index, 1);
    }
    if (includeDescendants) {
      for (var _i = 0, _a = mesh.getChildren(); _i < _a.length; _i++) {
        var child = _a[_i];
        this.removeShadowCaster(child);
      }
    }
    return this;
  };
  ShadowGenerator2.prototype.getLight = function() {
    return this._light;
  };
  Object.defineProperty(ShadowGenerator2.prototype, "mapSize", {
    get: function() {
      return this._mapSize;
    },
    set: function(size) {
      this._mapSize = size;
      this._light._markMeshesAsLightDirty();
      this.recreateShadowMap();
    },
    enumerable: false,
    configurable: true
  });
  ShadowGenerator2.prototype._initializeGenerator = function() {
    this._light._markMeshesAsLightDirty();
    this._initializeShadowMap();
  };
  ShadowGenerator2.prototype._createTargetRenderTexture = function() {
    var engine = this._scene.getEngine();
    if (engine.webGLVersion > 1) {
      this._shadowMap = new RenderTargetTexture(this._light.name + "_shadowMap", this._mapSize, this._scene, false, true, this._textureType, this._light.needCube(), void 0, false, false);
      this._shadowMap.createDepthStencilTexture(513, true);
    } else {
      this._shadowMap = new RenderTargetTexture(this._light.name + "_shadowMap", this._mapSize, this._scene, false, true, this._textureType, this._light.needCube());
    }
  };
  ShadowGenerator2.prototype._initializeShadowMap = function() {
    var _this = this;
    this._createTargetRenderTexture();
    if (this._shadowMap === null) {
      return;
    }
    this._shadowMap.wrapU = Texture.CLAMP_ADDRESSMODE;
    this._shadowMap.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._shadowMap.anisotropicFilteringLevel = 1;
    this._shadowMap.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
    this._shadowMap.renderParticles = false;
    this._shadowMap.ignoreCameraViewport = true;
    if (this._storedUniqueId) {
      this._shadowMap.uniqueId = this._storedUniqueId;
    }
    this._shadowMap.customRenderFunction = this._renderForShadowMap.bind(this);
    this._shadowMap.customIsReadyFunction = function(m, r) {
      return true;
    };
    var engine = this._scene.getEngine();
    this._shadowMap.onBeforeRenderObservable.add(function(faceIndex) {
      _this._currentFaceIndex = faceIndex;
      if (_this._filter === ShadowGenerator2.FILTER_PCF) {
        engine.setColorWrite(false);
      }
      if (_this._scene.getSceneUniformBuffer().useUbo) {
        var sceneUBO = _this._scene.getSceneUniformBuffer();
        sceneUBO.updateMatrix("viewProjection", _this.getTransformMatrix());
        sceneUBO.updateMatrix("view", _this._viewMatrix);
        sceneUBO.update();
      }
    });
    this._shadowMap.onAfterUnbindObservable.add(function() {
      if (_this._scene.getSceneUniformBuffer().useUbo) {
        var sceneUBO = _this._scene.getSceneUniformBuffer();
        sceneUBO.updateMatrix("viewProjection", _this._scene.getTransformMatrix());
        sceneUBO.updateMatrix("view", _this._scene.getViewMatrix());
        sceneUBO.update();
      }
      if (_this._filter === ShadowGenerator2.FILTER_PCF) {
        engine.setColorWrite(true);
      }
      if (!_this.useBlurExponentialShadowMap && !_this.useBlurCloseExponentialShadowMap) {
        return;
      }
      var shadowMap = _this.getShadowMapForRendering();
      if (shadowMap) {
        var texture = shadowMap.getInternalTexture();
        _this._scene.postProcessManager.directRender(_this._blurPostProcesses, texture, true);
        engine.unBindFramebuffer(texture, true);
      }
    });
    var clearZero = new Color4(0, 0, 0, 0);
    var clearOne = new Color4(1, 1, 1, 1);
    this._shadowMap.onClearObservable.add(function(engine2) {
      if (_this._filter === ShadowGenerator2.FILTER_PCF) {
        engine2.clear(clearOne, false, true, false);
      } else if (_this.useExponentialShadowMap || _this.useBlurExponentialShadowMap) {
        engine2.clear(clearZero, true, true, false);
      } else {
        engine2.clear(clearOne, true, true, false);
      }
    });
    this._shadowMap.onResizeObservable.add(function(RTT) {
      _this._storedUniqueId = _this._shadowMap.uniqueId;
      _this._mapSize = RTT.getRenderSize();
      _this._light._markMeshesAsLightDirty();
      _this.recreateShadowMap();
    });
    for (var i = RenderingManager.MIN_RENDERINGGROUPS; i < RenderingManager.MAX_RENDERINGGROUPS; i++) {
      this._shadowMap.setRenderingAutoClearDepthStencil(i, false);
    }
  };
  ShadowGenerator2.prototype._initializeBlurRTTAndPostProcesses = function() {
    var _this = this;
    var engine = this._scene.getEngine();
    var targetSize = this._mapSize / this.blurScale;
    if (!this.useKernelBlur || this.blurScale !== 1) {
      this._shadowMap2 = new RenderTargetTexture(this._light.name + "_shadowMap2", targetSize, this._scene, false, true, this._textureType);
      this._shadowMap2.wrapU = Texture.CLAMP_ADDRESSMODE;
      this._shadowMap2.wrapV = Texture.CLAMP_ADDRESSMODE;
      this._shadowMap2.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
    }
    if (this.useKernelBlur) {
      this._kernelBlurXPostprocess = new BlurPostProcess(this._light.name + "KernelBlurX", new Vector2(1, 0), this.blurKernel, 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._textureType);
      this._kernelBlurXPostprocess.width = targetSize;
      this._kernelBlurXPostprocess.height = targetSize;
      this._kernelBlurXPostprocess.onApplyObservable.add(function(effect) {
        effect.setTexture("textureSampler", _this._shadowMap);
      });
      this._kernelBlurYPostprocess = new BlurPostProcess(this._light.name + "KernelBlurY", new Vector2(0, 1), this.blurKernel, 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._textureType);
      this._kernelBlurXPostprocess.autoClear = false;
      this._kernelBlurYPostprocess.autoClear = false;
      if (this._textureType === 0) {
        this._kernelBlurXPostprocess.packedFloat = true;
        this._kernelBlurYPostprocess.packedFloat = true;
      }
      this._blurPostProcesses = [this._kernelBlurXPostprocess, this._kernelBlurYPostprocess];
    } else {
      this._boxBlurPostprocess = new PostProcess(this._light.name + "DepthBoxBlur", "depthBoxBlur", ["screenSize", "boxOffset"], [], 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, "#define OFFSET " + this._blurBoxOffset, this._textureType);
      this._boxBlurPostprocess.onApplyObservable.add(function(effect) {
        effect.setFloat2("screenSize", targetSize, targetSize);
        effect.setTexture("textureSampler", _this._shadowMap);
      });
      this._boxBlurPostprocess.autoClear = false;
      this._blurPostProcesses = [this._boxBlurPostprocess];
    }
  };
  ShadowGenerator2.prototype._renderForShadowMap = function(opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {
    var index;
    var engine = this._scene.getEngine();
    var colorWrite = engine.getColorWrite();
    if (depthOnlySubMeshes.length) {
      engine.setColorWrite(false);
      for (index = 0; index < depthOnlySubMeshes.length; index++) {
        this._renderSubMeshForShadowMap(depthOnlySubMeshes.data[index]);
      }
      engine.setColorWrite(colorWrite);
    }
    for (index = 0; index < opaqueSubMeshes.length; index++) {
      this._renderSubMeshForShadowMap(opaqueSubMeshes.data[index]);
    }
    for (index = 0; index < alphaTestSubMeshes.length; index++) {
      this._renderSubMeshForShadowMap(alphaTestSubMeshes.data[index]);
    }
    if (this._transparencyShadow) {
      for (index = 0; index < transparentSubMeshes.length; index++) {
        this._renderSubMeshForShadowMap(transparentSubMeshes.data[index], true);
      }
    } else {
      for (index = 0; index < transparentSubMeshes.length; index++) {
        transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;
      }
    }
  };
  ShadowGenerator2.prototype._bindCustomEffectForRenderSubMeshForShadowMap = function(subMesh, effect, matriceNames, mesh) {
    var _a, _b, _c, _d, _e, _f;
    effect.setMatrix((_a = matriceNames === null || matriceNames === void 0 ? void 0 : matriceNames.viewProjection) !== null && _a !== void 0 ? _a : "viewProjection", this.getTransformMatrix());
    effect.setMatrix((_b = matriceNames === null || matriceNames === void 0 ? void 0 : matriceNames.view) !== null && _b !== void 0 ? _b : "view", this._viewMatrix);
    effect.setMatrix((_c = matriceNames === null || matriceNames === void 0 ? void 0 : matriceNames.projection) !== null && _c !== void 0 ? _c : "projection", this._projectionMatrix);
    var world = mesh.getWorldMatrix();
    effect.setMatrix((_d = matriceNames === null || matriceNames === void 0 ? void 0 : matriceNames.world) !== null && _d !== void 0 ? _d : "world", world);
    world.multiplyToRef(this.getTransformMatrix(), tmpMatrix);
    effect.setMatrix((_e = matriceNames === null || matriceNames === void 0 ? void 0 : matriceNames.worldViewProjection) !== null && _e !== void 0 ? _e : "worldViewProjection", tmpMatrix);
    world.multiplyToRef(this._viewMatrix, tmpMatrix2);
    effect.setMatrix((_f = matriceNames === null || matriceNames === void 0 ? void 0 : matriceNames.worldView) !== null && _f !== void 0 ? _f : "worldView", tmpMatrix2);
  };
  ShadowGenerator2.prototype._renderSubMeshForShadowMap = function(subMesh, isTransparent) {
    var _a, _b;
    if (isTransparent === void 0) {
      isTransparent = false;
    }
    var renderingMesh = subMesh.getRenderingMesh();
    var effectiveMesh = subMesh.getEffectiveMesh();
    var scene = this._scene;
    var engine = scene.getEngine();
    var material = subMesh.getMaterial();
    effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;
    if (!material || subMesh.verticesCount === 0 || subMesh._renderId === scene.getRenderId()) {
      return;
    }
    engine.setState(material.backFaceCulling);
    var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
    if (batch.mustReturn) {
      return;
    }
    var hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== void 0 || renderingMesh.hasThinInstances);
    if (this.customAllowRendering && !this.customAllowRendering(subMesh)) {
      return;
    }
    if (this.isReady(subMesh, hardwareInstancedRendering, isTransparent)) {
      subMesh._renderId = scene.getRenderId();
      var shadowDepthWrapper = (_a = renderingMesh.material) === null || _a === void 0 ? void 0 : _a.shadowDepthWrapper;
      var effect_1 = (_b = shadowDepthWrapper === null || shadowDepthWrapper === void 0 ? void 0 : shadowDepthWrapper.getEffect(subMesh, this)) !== null && _b !== void 0 ? _b : this._effect;
      engine.enableEffect(effect_1);
      renderingMesh._bind(subMesh, effect_1, material.fillMode);
      this.getTransformMatrix();
      effect_1.setFloat3("biasAndScaleSM", this.bias, this.normalBias, this.depthScale);
      if (this.getLight().getTypeID() === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {
        effect_1.setVector3("lightDataSM", this._cachedDirection);
      } else {
        effect_1.setVector3("lightDataSM", this._cachedPosition);
      }
      if (scene.activeCamera) {
        effect_1.setFloat2("depthValuesSM", this.getLight().getDepthMinZ(scene.activeCamera), this.getLight().getDepthMinZ(scene.activeCamera) + this.getLight().getDepthMaxZ(scene.activeCamera));
      }
      if (isTransparent && this.enableSoftTransparentShadow) {
        effect_1.setFloat("softTransparentShadowSM", effectiveMesh.visibility);
      }
      if (shadowDepthWrapper) {
        subMesh._effectOverride = effect_1;
        if (shadowDepthWrapper.standalone) {
          shadowDepthWrapper.baseMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), renderingMesh, subMesh);
        } else {
          material.bindForSubMesh(effectiveMesh.getWorldMatrix(), renderingMesh, subMesh);
        }
        subMesh._effectOverride = null;
      } else {
        effect_1.setMatrix("viewProjection", this.getTransformMatrix());
        if (material && material.needAlphaTesting()) {
          var alphaTexture = material.getAlphaTestTexture();
          if (alphaTexture) {
            effect_1.setTexture("diffuseSampler", alphaTexture);
            effect_1.setMatrix("diffuseMatrix", alphaTexture.getTextureMatrix() || this._defaultTextureMatrix);
          }
        }
        if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {
          var skeleton = renderingMesh.skeleton;
          if (skeleton.isUsingTextureForMatrices) {
            var boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);
            if (!boneTexture) {
              return;
            }
            effect_1.setTexture("boneSampler", boneTexture);
            effect_1.setFloat("boneTextureWidth", 4 * (skeleton.bones.length + 1));
          } else {
            effect_1.setMatrices("mBones", skeleton.getTransformMatrices(renderingMesh));
          }
        }
        MaterialHelper.BindMorphTargetParameters(renderingMesh, effect_1);
        MaterialHelper.BindClipPlane(effect_1, scene);
      }
      this._bindCustomEffectForRenderSubMeshForShadowMap(subMesh, effect_1, shadowDepthWrapper === null || shadowDepthWrapper === void 0 ? void 0 : shadowDepthWrapper._matriceNames, effectiveMesh);
      if (this.forceBackFacesOnly) {
        engine.setState(true, 0, false, true);
      }
      this.onBeforeShadowMapRenderMeshObservable.notifyObservers(renderingMesh);
      this.onBeforeShadowMapRenderObservable.notifyObservers(effect_1);
      renderingMesh._processRendering(effectiveMesh, subMesh, effect_1, material.fillMode, batch, hardwareInstancedRendering, function(isInstance, world) {
        return effect_1.setMatrix("world", world);
      });
      if (this.forceBackFacesOnly) {
        engine.setState(true, 0, false, false);
      }
      this.onAfterShadowMapRenderObservable.notifyObservers(effect_1);
      this.onAfterShadowMapRenderMeshObservable.notifyObservers(renderingMesh);
    } else {
      if (this._shadowMap) {
        this._shadowMap.resetRefreshCounter();
      }
    }
  };
  ShadowGenerator2.prototype._applyFilterValues = function() {
    if (!this._shadowMap) {
      return;
    }
    if (this.filter === ShadowGenerator2.FILTER_NONE || this.filter === ShadowGenerator2.FILTER_PCSS) {
      this._shadowMap.updateSamplingMode(Texture.NEAREST_SAMPLINGMODE);
    } else {
      this._shadowMap.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
    }
  };
  ShadowGenerator2.prototype.forceCompilation = function(onCompiled, options) {
    var _this = this;
    var localOptions = __assign({ useInstances: false }, options);
    var shadowMap = this.getShadowMap();
    if (!shadowMap) {
      if (onCompiled) {
        onCompiled(this);
      }
      return;
    }
    var renderList = shadowMap.renderList;
    if (!renderList) {
      if (onCompiled) {
        onCompiled(this);
      }
      return;
    }
    var subMeshes = new Array();
    for (var _i = 0, renderList_1 = renderList; _i < renderList_1.length; _i++) {
      var mesh = renderList_1[_i];
      subMeshes.push.apply(subMeshes, mesh.subMeshes);
    }
    if (subMeshes.length === 0) {
      if (onCompiled) {
        onCompiled(this);
      }
      return;
    }
    var currentIndex = 0;
    var checkReady = function() {
      var _a, _b;
      if (!_this._scene || !_this._scene.getEngine()) {
        return;
      }
      while (_this.isReady(subMeshes[currentIndex], localOptions.useInstances, (_b = (_a = subMeshes[currentIndex].getMaterial()) === null || _a === void 0 ? void 0 : _a.needAlphaBlendingForMesh(subMeshes[currentIndex].getMesh())) !== null && _b !== void 0 ? _b : false)) {
        currentIndex++;
        if (currentIndex >= subMeshes.length) {
          if (onCompiled) {
            onCompiled(_this);
          }
          return;
        }
      }
      setTimeout(checkReady, 16);
    };
    checkReady();
  };
  ShadowGenerator2.prototype.forceCompilationAsync = function(options) {
    var _this = this;
    return new Promise(function(resolve) {
      _this.forceCompilation(function() {
        resolve();
      }, options);
    });
  };
  ShadowGenerator2.prototype._isReadyCustomDefines = function(defines, subMesh, useInstances) {
  };
  ShadowGenerator2.prototype._prepareShadowDefines = function(subMesh, useInstances, defines, isTransparent) {
    defines.push("#define SM_FLOAT " + (this._textureType !== 0 ? "1" : "0"));
    defines.push("#define SM_ESM " + (this.useExponentialShadowMap || this.useBlurExponentialShadowMap ? "1" : "0"));
    defines.push("#define SM_DEPTHTEXTURE " + (this.usePercentageCloserFiltering || this.useContactHardeningShadow ? "1" : "0"));
    var mesh = subMesh.getMesh();
    defines.push("#define SM_NORMALBIAS " + (this.normalBias && mesh.isVerticesDataPresent(VertexBuffer.NormalKind) ? "1" : "0"));
    defines.push("#define SM_DIRECTIONINLIGHTDATA " + (this.getLight().getTypeID() === Light.LIGHTTYPEID_DIRECTIONALLIGHT ? "1" : "0"));
    defines.push("#define SM_USEDISTANCE " + (this._light.needCube() ? "1" : "0"));
    defines.push("#define SM_SOFTTRANSPARENTSHADOW " + (this.enableSoftTransparentShadow && isTransparent ? "1" : "0"));
    this._isReadyCustomDefines(defines, subMesh, useInstances);
    return defines;
  };
  ShadowGenerator2.prototype.isReady = function(subMesh, useInstances, isTransparent) {
    var material = subMesh.getMaterial(), shadowDepthWrapper = material === null || material === void 0 ? void 0 : material.shadowDepthWrapper;
    var defines = [];
    this._prepareShadowDefines(subMesh, useInstances, defines, isTransparent);
    if (shadowDepthWrapper) {
      if (!shadowDepthWrapper.isReadyForSubMesh(subMesh, defines, this, useInstances)) {
        return false;
      }
    } else {
      var attribs = [VertexBuffer.PositionKind];
      var mesh = subMesh.getMesh();
      if (this.normalBias && mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
        attribs.push(VertexBuffer.NormalKind);
        defines.push("#define NORMAL");
        if (mesh.nonUniformScaling) {
          defines.push("#define NONUNIFORMSCALING");
        }
      }
      if (material && material.needAlphaTesting()) {
        var alphaTexture = material.getAlphaTestTexture();
        if (alphaTexture) {
          if (!alphaTexture.isReady()) {
            return false;
          }
          defines.push("#define ALPHATEST");
          if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
            attribs.push(VertexBuffer.UVKind);
            defines.push("#define UV1");
          }
          if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
            if (alphaTexture.coordinatesIndex === 1) {
              attribs.push(VertexBuffer.UV2Kind);
              defines.push("#define UV2");
            }
          }
        }
      }
      var fallbacks = new EffectFallbacks();
      if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
        attribs.push(VertexBuffer.MatricesIndicesKind);
        attribs.push(VertexBuffer.MatricesWeightsKind);
        if (mesh.numBoneInfluencers > 4) {
          attribs.push(VertexBuffer.MatricesIndicesExtraKind);
          attribs.push(VertexBuffer.MatricesWeightsExtraKind);
        }
        var skeleton = mesh.skeleton;
        defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
        if (mesh.numBoneInfluencers > 0) {
          fallbacks.addCPUSkinningFallback(0, mesh);
        }
        if (skeleton.isUsingTextureForMatrices) {
          defines.push("#define BONETEXTURE");
        } else {
          defines.push("#define BonesPerMesh " + (skeleton.bones.length + 1));
        }
      } else {
        defines.push("#define NUM_BONE_INFLUENCERS 0");
      }
      var manager = mesh.morphTargetManager;
      var morphInfluencers = 0;
      if (manager) {
        if (manager.numInfluencers > 0) {
          defines.push("#define MORPHTARGETS");
          morphInfluencers = manager.numInfluencers;
          defines.push("#define NUM_MORPH_INFLUENCERS " + morphInfluencers);
          MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, morphInfluencers);
        }
      }
      var scene = this._scene;
      if (scene.clipPlane) {
        defines.push("#define CLIPPLANE");
      }
      if (scene.clipPlane2) {
        defines.push("#define CLIPPLANE2");
      }
      if (scene.clipPlane3) {
        defines.push("#define CLIPPLANE3");
      }
      if (scene.clipPlane4) {
        defines.push("#define CLIPPLANE4");
      }
      if (scene.clipPlane5) {
        defines.push("#define CLIPPLANE5");
      }
      if (scene.clipPlane6) {
        defines.push("#define CLIPPLANE6");
      }
      if (useInstances) {
        defines.push("#define INSTANCES");
        MaterialHelper.PushAttributesForInstances(attribs);
        if (subMesh.getRenderingMesh().hasThinInstances) {
          defines.push("#define THIN_INSTANCES");
        }
      }
      if (this.customShaderOptions) {
        if (this.customShaderOptions.defines) {
          for (var _i = 0, _a = this.customShaderOptions.defines; _i < _a.length; _i++) {
            var define = _a[_i];
            if (defines.indexOf(define) === -1) {
              defines.push(define);
            }
          }
        }
      }
      var join = defines.join("\n");
      if (this._cachedDefines !== join) {
        this._cachedDefines = join;
        var shaderName = "shadowMap";
        var uniforms = [
          "world",
          "mBones",
          "viewProjection",
          "diffuseMatrix",
          "lightDataSM",
          "depthValuesSM",
          "biasAndScaleSM",
          "morphTargetInfluences",
          "boneTextureWidth",
          "vClipPlane",
          "vClipPlane2",
          "vClipPlane3",
          "vClipPlane4",
          "vClipPlane5",
          "vClipPlane6",
          "softTransparentShadowSM"
        ];
        var samplers = ["diffuseSampler", "boneSampler"];
        if (this.customShaderOptions) {
          shaderName = this.customShaderOptions.shaderName;
          if (this.customShaderOptions.attributes) {
            for (var _b = 0, _c = this.customShaderOptions.attributes; _b < _c.length; _b++) {
              var attrib = _c[_b];
              if (attribs.indexOf(attrib) === -1) {
                attribs.push(attrib);
              }
            }
          }
          if (this.customShaderOptions.uniforms) {
            for (var _d = 0, _e = this.customShaderOptions.uniforms; _d < _e.length; _d++) {
              var uniform = _e[_d];
              if (uniforms.indexOf(uniform) === -1) {
                uniforms.push(uniform);
              }
            }
          }
          if (this.customShaderOptions.samplers) {
            for (var _f = 0, _g = this.customShaderOptions.samplers; _f < _g.length; _f++) {
              var sampler = _g[_f];
              if (samplers.indexOf(sampler) === -1) {
                samplers.push(sampler);
              }
            }
          }
        }
        this._effect = this._scene.getEngine().createEffect(shaderName, attribs, uniforms, samplers, join, fallbacks, void 0, void 0, { maxSimultaneousMorphTargets: morphInfluencers });
      }
      if (!this._effect.isReady()) {
        return false;
      }
    }
    if (this.useBlurExponentialShadowMap || this.useBlurCloseExponentialShadowMap) {
      if (!this._blurPostProcesses || !this._blurPostProcesses.length) {
        this._initializeBlurRTTAndPostProcesses();
      }
    }
    if (this._kernelBlurXPostprocess && !this._kernelBlurXPostprocess.isReady()) {
      return false;
    }
    if (this._kernelBlurYPostprocess && !this._kernelBlurYPostprocess.isReady()) {
      return false;
    }
    if (this._boxBlurPostprocess && !this._boxBlurPostprocess.isReady()) {
      return false;
    }
    return true;
  };
  ShadowGenerator2.prototype.prepareDefines = function(defines, lightIndex) {
    var scene = this._scene;
    var light = this._light;
    if (!scene.shadowsEnabled || !light.shadowEnabled) {
      return;
    }
    defines["SHADOW" + lightIndex] = true;
    if (this.useContactHardeningShadow) {
      defines["SHADOWPCSS" + lightIndex] = true;
      if (this._filteringQuality === ShadowGenerator2.QUALITY_LOW) {
        defines["SHADOWLOWQUALITY" + lightIndex] = true;
      } else if (this._filteringQuality === ShadowGenerator2.QUALITY_MEDIUM) {
        defines["SHADOWMEDIUMQUALITY" + lightIndex] = true;
      }
    } else if (this.usePercentageCloserFiltering) {
      defines["SHADOWPCF" + lightIndex] = true;
      if (this._filteringQuality === ShadowGenerator2.QUALITY_LOW) {
        defines["SHADOWLOWQUALITY" + lightIndex] = true;
      } else if (this._filteringQuality === ShadowGenerator2.QUALITY_MEDIUM) {
        defines["SHADOWMEDIUMQUALITY" + lightIndex] = true;
      }
    } else if (this.usePoissonSampling) {
      defines["SHADOWPOISSON" + lightIndex] = true;
    } else if (this.useExponentialShadowMap || this.useBlurExponentialShadowMap) {
      defines["SHADOWESM" + lightIndex] = true;
    } else if (this.useCloseExponentialShadowMap || this.useBlurCloseExponentialShadowMap) {
      defines["SHADOWCLOSEESM" + lightIndex] = true;
    }
    if (light.needCube()) {
      defines["SHADOWCUBE" + lightIndex] = true;
    }
  };
  ShadowGenerator2.prototype.bindShadowLight = function(lightIndex, effect) {
    var light = this._light;
    var scene = this._scene;
    if (!scene.shadowsEnabled || !light.shadowEnabled) {
      return;
    }
    var camera = scene.activeCamera;
    if (!camera) {
      return;
    }
    var shadowMap = this.getShadowMap();
    if (!shadowMap) {
      return;
    }
    if (!light.needCube()) {
      effect.setMatrix("lightMatrix" + lightIndex, this.getTransformMatrix());
    }
    if (this._filter === ShadowGenerator2.FILTER_PCF) {
      effect.setDepthStencilTexture("shadowSampler" + lightIndex, this.getShadowMapForRendering());
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), shadowMap.getSize().width, 1 / shadowMap.getSize().width, this.frustumEdgeFalloff, lightIndex);
    } else if (this._filter === ShadowGenerator2.FILTER_PCSS) {
      effect.setDepthStencilTexture("shadowSampler" + lightIndex, this.getShadowMapForRendering());
      effect.setTexture("depthSampler" + lightIndex, this.getShadowMapForRendering());
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), 1 / shadowMap.getSize().width, this._contactHardeningLightSizeUVRatio * shadowMap.getSize().width, this.frustumEdgeFalloff, lightIndex);
    } else {
      effect.setTexture("shadowSampler" + lightIndex, this.getShadowMapForRendering());
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), this.blurScale / shadowMap.getSize().width, this.depthScale, this.frustumEdgeFalloff, lightIndex);
    }
    light._uniformBuffer.updateFloat2("depthValues", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera), lightIndex);
  };
  ShadowGenerator2.prototype.getTransformMatrix = function() {
    var scene = this._scene;
    if (this._currentRenderID === scene.getRenderId() && this._currentFaceIndexCache === this._currentFaceIndex) {
      return this._transformMatrix;
    }
    this._currentRenderID = scene.getRenderId();
    this._currentFaceIndexCache = this._currentFaceIndex;
    var lightPosition = this._light.position;
    if (this._light.computeTransformedInformation()) {
      lightPosition = this._light.transformedPosition;
    }
    Vector3.NormalizeToRef(this._light.getShadowDirection(this._currentFaceIndex), this._lightDirection);
    if (Math.abs(Vector3.Dot(this._lightDirection, Vector3.Up())) === 1) {
      this._lightDirection.z = 1e-13;
    }
    if (this._light.needProjectionMatrixCompute() || !this._cachedPosition || !this._cachedDirection || !lightPosition.equals(this._cachedPosition) || !this._lightDirection.equals(this._cachedDirection)) {
      this._cachedPosition.copyFrom(lightPosition);
      this._cachedDirection.copyFrom(this._lightDirection);
      Matrix.LookAtLHToRef(lightPosition, lightPosition.add(this._lightDirection), Vector3.Up(), this._viewMatrix);
      var shadowMap = this.getShadowMap();
      if (shadowMap) {
        var renderList = shadowMap.renderList;
        if (renderList) {
          this._light.setShadowProjectionMatrix(this._projectionMatrix, this._viewMatrix, renderList);
        }
      }
      this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
    }
    return this._transformMatrix;
  };
  ShadowGenerator2.prototype.recreateShadowMap = function() {
    var shadowMap = this._shadowMap;
    if (!shadowMap) {
      return;
    }
    var renderList = shadowMap.renderList;
    this._disposeRTTandPostProcesses();
    this._initializeGenerator();
    this.filter = this.filter;
    this._applyFilterValues();
    this._shadowMap.renderList = renderList;
  };
  ShadowGenerator2.prototype._disposeBlurPostProcesses = function() {
    if (this._shadowMap2) {
      this._shadowMap2.dispose();
      this._shadowMap2 = null;
    }
    if (this._boxBlurPostprocess) {
      this._boxBlurPostprocess.dispose();
      this._boxBlurPostprocess = null;
    }
    if (this._kernelBlurXPostprocess) {
      this._kernelBlurXPostprocess.dispose();
      this._kernelBlurXPostprocess = null;
    }
    if (this._kernelBlurYPostprocess) {
      this._kernelBlurYPostprocess.dispose();
      this._kernelBlurYPostprocess = null;
    }
    this._blurPostProcesses = [];
  };
  ShadowGenerator2.prototype._disposeRTTandPostProcesses = function() {
    if (this._shadowMap) {
      this._shadowMap.dispose();
      this._shadowMap = null;
    }
    this._disposeBlurPostProcesses();
  };
  ShadowGenerator2.prototype.dispose = function() {
    this._disposeRTTandPostProcesses();
    if (this._light) {
      this._light._shadowGenerator = null;
      this._light._markMeshesAsLightDirty();
    }
    this.onBeforeShadowMapRenderMeshObservable.clear();
    this.onBeforeShadowMapRenderObservable.clear();
    this.onAfterShadowMapRenderMeshObservable.clear();
    this.onAfterShadowMapRenderObservable.clear();
  };
  ShadowGenerator2.prototype.serialize = function() {
    var serializationObject = {};
    var shadowMap = this.getShadowMap();
    if (!shadowMap) {
      return serializationObject;
    }
    serializationObject.className = this.getClassName();
    serializationObject.lightId = this._light.id;
    serializationObject.id = this._light.id;
    serializationObject.mapSize = shadowMap.getRenderSize();
    serializationObject.forceBackFacesOnly = this.forceBackFacesOnly;
    serializationObject.darkness = this.getDarkness();
    serializationObject.transparencyShadow = this._transparencyShadow;
    serializationObject.frustumEdgeFalloff = this.frustumEdgeFalloff;
    serializationObject.bias = this.bias;
    serializationObject.normalBias = this.normalBias;
    serializationObject.usePercentageCloserFiltering = this.usePercentageCloserFiltering;
    serializationObject.useContactHardeningShadow = this.useContactHardeningShadow;
    serializationObject.contactHardeningLightSizeUVRatio = this.contactHardeningLightSizeUVRatio;
    serializationObject.filteringQuality = this.filteringQuality;
    serializationObject.useExponentialShadowMap = this.useExponentialShadowMap;
    serializationObject.useBlurExponentialShadowMap = this.useBlurExponentialShadowMap;
    serializationObject.useCloseExponentialShadowMap = this.useBlurExponentialShadowMap;
    serializationObject.useBlurCloseExponentialShadowMap = this.useBlurExponentialShadowMap;
    serializationObject.usePoissonSampling = this.usePoissonSampling;
    serializationObject.depthScale = this.depthScale;
    serializationObject.blurBoxOffset = this.blurBoxOffset;
    serializationObject.blurKernel = this.blurKernel;
    serializationObject.blurScale = this.blurScale;
    serializationObject.useKernelBlur = this.useKernelBlur;
    serializationObject.renderList = [];
    if (shadowMap.renderList) {
      for (var meshIndex = 0; meshIndex < shadowMap.renderList.length; meshIndex++) {
        var mesh = shadowMap.renderList[meshIndex];
        serializationObject.renderList.push(mesh.id);
      }
    }
    return serializationObject;
  };
  ShadowGenerator2.Parse = function(parsedShadowGenerator, scene, constr) {
    var light = scene.getLightByID(parsedShadowGenerator.lightId);
    var shadowGenerator = constr ? constr(parsedShadowGenerator.mapSize, light) : new ShadowGenerator2(parsedShadowGenerator.mapSize, light);
    var shadowMap = shadowGenerator.getShadowMap();
    for (var meshIndex = 0; meshIndex < parsedShadowGenerator.renderList.length; meshIndex++) {
      var meshes = scene.getMeshesByID(parsedShadowGenerator.renderList[meshIndex]);
      meshes.forEach(function(mesh) {
        if (!shadowMap) {
          return;
        }
        if (!shadowMap.renderList) {
          shadowMap.renderList = [];
        }
        shadowMap.renderList.push(mesh);
      });
    }
    if (parsedShadowGenerator.id !== void 0) {
      shadowGenerator.id = parsedShadowGenerator.id;
    }
    shadowGenerator.forceBackFacesOnly = !!parsedShadowGenerator.forceBackFacesOnly;
    if (parsedShadowGenerator.darkness !== void 0) {
      shadowGenerator.setDarkness(parsedShadowGenerator.darkness);
    }
    if (parsedShadowGenerator.transparencyShadow) {
      shadowGenerator.setTransparencyShadow(true);
    }
    if (parsedShadowGenerator.frustumEdgeFalloff !== void 0) {
      shadowGenerator.frustumEdgeFalloff = parsedShadowGenerator.frustumEdgeFalloff;
    }
    if (parsedShadowGenerator.bias !== void 0) {
      shadowGenerator.bias = parsedShadowGenerator.bias;
    }
    if (parsedShadowGenerator.normalBias !== void 0) {
      shadowGenerator.normalBias = parsedShadowGenerator.normalBias;
    }
    if (parsedShadowGenerator.usePercentageCloserFiltering) {
      shadowGenerator.usePercentageCloserFiltering = true;
    } else if (parsedShadowGenerator.useContactHardeningShadow) {
      shadowGenerator.useContactHardeningShadow = true;
    } else if (parsedShadowGenerator.usePoissonSampling) {
      shadowGenerator.usePoissonSampling = true;
    } else if (parsedShadowGenerator.useExponentialShadowMap) {
      shadowGenerator.useExponentialShadowMap = true;
    } else if (parsedShadowGenerator.useBlurExponentialShadowMap) {
      shadowGenerator.useBlurExponentialShadowMap = true;
    } else if (parsedShadowGenerator.useCloseExponentialShadowMap) {
      shadowGenerator.useCloseExponentialShadowMap = true;
    } else if (parsedShadowGenerator.useBlurCloseExponentialShadowMap) {
      shadowGenerator.useBlurCloseExponentialShadowMap = true;
    } else if (parsedShadowGenerator.useVarianceShadowMap) {
      shadowGenerator.useExponentialShadowMap = true;
    } else if (parsedShadowGenerator.useBlurVarianceShadowMap) {
      shadowGenerator.useBlurExponentialShadowMap = true;
    }
    if (parsedShadowGenerator.contactHardeningLightSizeUVRatio !== void 0) {
      shadowGenerator.contactHardeningLightSizeUVRatio = parsedShadowGenerator.contactHardeningLightSizeUVRatio;
    }
    if (parsedShadowGenerator.filteringQuality !== void 0) {
      shadowGenerator.filteringQuality = parsedShadowGenerator.filteringQuality;
    }
    if (parsedShadowGenerator.depthScale) {
      shadowGenerator.depthScale = parsedShadowGenerator.depthScale;
    }
    if (parsedShadowGenerator.blurScale) {
      shadowGenerator.blurScale = parsedShadowGenerator.blurScale;
    }
    if (parsedShadowGenerator.blurBoxOffset) {
      shadowGenerator.blurBoxOffset = parsedShadowGenerator.blurBoxOffset;
    }
    if (parsedShadowGenerator.useKernelBlur) {
      shadowGenerator.useKernelBlur = parsedShadowGenerator.useKernelBlur;
    }
    if (parsedShadowGenerator.blurKernel) {
      shadowGenerator.blurKernel = parsedShadowGenerator.blurKernel;
    }
    return shadowGenerator;
  };
  ShadowGenerator2.CLASSNAME = "ShadowGenerator";
  ShadowGenerator2.FILTER_NONE = 0;
  ShadowGenerator2.FILTER_EXPONENTIALSHADOWMAP = 1;
  ShadowGenerator2.FILTER_POISSONSAMPLING = 2;
  ShadowGenerator2.FILTER_BLUREXPONENTIALSHADOWMAP = 3;
  ShadowGenerator2.FILTER_CLOSEEXPONENTIALSHADOWMAP = 4;
  ShadowGenerator2.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP = 5;
  ShadowGenerator2.FILTER_PCF = 6;
  ShadowGenerator2.FILTER_PCSS = 7;
  ShadowGenerator2.QUALITY_HIGH = 0;
  ShadowGenerator2.QUALITY_MEDIUM = 1;
  ShadowGenerator2.QUALITY_LOW = 2;
  ShadowGenerator2._SceneComponentInitialization = function(_) {
    throw _DevTools.WarnImport("ShadowGeneratorSceneComponent");
  };
  return ShadowGenerator2;
}();

// node_modules/@babylonjs/core/Shaders/depth.fragment.js
var name38 = "depthPixelShader";
var shader38 = "#ifdef ALPHATEST\nvarying vec2 vUV;\nuniform sampler2D diffuseSampler;\n#endif\nvarying float vDepthMetric;\n#ifdef PACKED\n#include<packingFunctions>\n#endif\nvoid main(void)\n{\n#ifdef ALPHATEST\nif (texture2D(diffuseSampler,vUV).a<0.4)\ndiscard;\n#endif\n#ifdef NONLINEARDEPTH\n#ifdef PACKED\ngl_FragColor=pack(gl_FragCoord.z);\n#else\ngl_FragColor=vec4(gl_FragCoord.z,0.0,0.0,0.0);\n#endif\n#else\n#ifdef PACKED\ngl_FragColor=pack(vDepthMetric);\n#else\ngl_FragColor=vec4(vDepthMetric,0.0,0.0,1.0);\n#endif\n#endif\n}";
Effect.ShadersStore[name38] = shader38;

// node_modules/@babylonjs/core/Shaders/depth.vertex.js
var name39 = "depthVertexShader";
var shader39 = "\nattribute vec3 position;\n#include<bonesDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\nuniform vec2 depthValues;\n#if defined(ALPHATEST) || defined(NEED_UV)\nvarying vec2 vUV;\nuniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\nvarying float vDepthMetric;\nvoid main(void)\n{\nvec3 positionUpdated=position;\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\ngl_Position=viewProjection*finalWorld*vec4(positionUpdated,1.0);\nvDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y));\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n}\n";
Effect.ShadersStore[name39] = shader39;

// node_modules/@babylonjs/core/Rendering/depthRenderer.js
var DepthRenderer = function() {
  function DepthRenderer2(scene, type, camera, storeNonLinearDepth) {
    var _this = this;
    if (type === void 0) {
      type = 1;
    }
    if (camera === void 0) {
      camera = null;
    }
    if (storeNonLinearDepth === void 0) {
      storeNonLinearDepth = false;
    }
    this.enabled = true;
    this.useOnlyInActiveCamera = false;
    this._scene = scene;
    this._storeNonLinearDepth = storeNonLinearDepth;
    this.isPacked = type === 0;
    if (this.isPacked) {
      this._clearColor = new Color4(1, 1, 1, 1);
    } else {
      this._clearColor = new Color4(1, 0, 0, 1);
    }
    DepthRenderer2._SceneComponentInitialization(this._scene);
    this._camera = camera;
    var engine = scene.getEngine();
    var format = this.isPacked || engine.webGLVersion === 1 ? 5 : 6;
    this._depthMap = new RenderTargetTexture("depthMap", { width: engine.getRenderWidth(), height: engine.getRenderHeight() }, this._scene, false, true, type, false, void 0, void 0, void 0, void 0, format);
    this._depthMap.wrapU = Texture.CLAMP_ADDRESSMODE;
    this._depthMap.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._depthMap.refreshRate = 1;
    this._depthMap.renderParticles = false;
    this._depthMap.renderList = null;
    this._depthMap.activeCamera = this._camera;
    this._depthMap.ignoreCameraViewport = true;
    this._depthMap.useCameraPostProcesses = false;
    this._depthMap.onClearObservable.add(function(engine2) {
      engine2.clear(_this._clearColor, true, true, true);
    });
    var renderSubMesh = function(subMesh) {
      var renderingMesh = subMesh.getRenderingMesh();
      var effectiveMesh = subMesh.getEffectiveMesh();
      var scene2 = _this._scene;
      var engine2 = scene2.getEngine();
      var material = subMesh.getMaterial();
      effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;
      if (!material || subMesh.verticesCount === 0 || subMesh._renderId === scene2.getRenderId()) {
        return;
      }
      engine2.setState(material.backFaceCulling, 0, false, scene2.useRightHandedSystem);
      var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
      if (batch.mustReturn) {
        return;
      }
      var hardwareInstancedRendering = engine2.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== void 0 || renderingMesh.hasThinInstances);
      var camera2 = _this._camera || scene2.activeCamera;
      if (_this.isReady(subMesh, hardwareInstancedRendering) && camera2) {
        subMesh._renderId = scene2.getRenderId();
        engine2.enableEffect(_this._effect);
        renderingMesh._bind(subMesh, _this._effect, material.fillMode);
        _this._effect.setMatrix("viewProjection", scene2.getTransformMatrix());
        _this._effect.setFloat2("depthValues", camera2.minZ, camera2.minZ + camera2.maxZ);
        if (material && material.needAlphaTesting()) {
          var alphaTexture = material.getAlphaTestTexture();
          if (alphaTexture) {
            _this._effect.setTexture("diffuseSampler", alphaTexture);
            _this._effect.setMatrix("diffuseMatrix", alphaTexture.getTextureMatrix());
          }
        }
        if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {
          _this._effect.setMatrices("mBones", renderingMesh.skeleton.getTransformMatrices(renderingMesh));
        }
        MaterialHelper.BindMorphTargetParameters(renderingMesh, _this._effect);
        renderingMesh._processRendering(effectiveMesh, subMesh, _this._effect, material.fillMode, batch, hardwareInstancedRendering, function(isInstance, world) {
          return _this._effect.setMatrix("world", world);
        });
      }
    };
    this._depthMap.customRenderFunction = function(opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {
      var index;
      if (depthOnlySubMeshes.length) {
        engine.setColorWrite(false);
        for (index = 0; index < depthOnlySubMeshes.length; index++) {
          renderSubMesh(depthOnlySubMeshes.data[index]);
        }
        engine.setColorWrite(true);
      }
      for (index = 0; index < opaqueSubMeshes.length; index++) {
        renderSubMesh(opaqueSubMeshes.data[index]);
      }
      for (index = 0; index < alphaTestSubMeshes.length; index++) {
        renderSubMesh(alphaTestSubMeshes.data[index]);
      }
    };
  }
  DepthRenderer2.prototype.isReady = function(subMesh, useInstances) {
    var material = subMesh.getMaterial();
    if (material.disableDepthWrite) {
      return false;
    }
    var defines = [];
    var attribs = [VertexBuffer.PositionKind];
    var mesh = subMesh.getMesh();
    if (material && material.needAlphaTesting() && material.getAlphaTestTexture()) {
      defines.push("#define ALPHATEST");
      if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
        attribs.push(VertexBuffer.UVKind);
        defines.push("#define UV1");
      }
      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
        attribs.push(VertexBuffer.UV2Kind);
        defines.push("#define UV2");
      }
    }
    if (mesh.useBones && mesh.computeBonesUsingShaders) {
      attribs.push(VertexBuffer.MatricesIndicesKind);
      attribs.push(VertexBuffer.MatricesWeightsKind);
      if (mesh.numBoneInfluencers > 4) {
        attribs.push(VertexBuffer.MatricesIndicesExtraKind);
        attribs.push(VertexBuffer.MatricesWeightsExtraKind);
      }
      defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
      defines.push("#define BonesPerMesh " + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));
    } else {
      defines.push("#define NUM_BONE_INFLUENCERS 0");
    }
    var morphTargetManager = mesh.morphTargetManager;
    var numMorphInfluencers = 0;
    if (morphTargetManager) {
      if (morphTargetManager.numInfluencers > 0) {
        numMorphInfluencers = morphTargetManager.numInfluencers;
        defines.push("#define MORPHTARGETS");
        defines.push("#define NUM_MORPH_INFLUENCERS " + numMorphInfluencers);
        MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);
      }
    }
    if (useInstances) {
      defines.push("#define INSTANCES");
      MaterialHelper.PushAttributesForInstances(attribs);
      if (subMesh.getRenderingMesh().hasThinInstances) {
        defines.push("#define THIN_INSTANCES");
      }
    }
    if (this._storeNonLinearDepth) {
      defines.push("#define NONLINEARDEPTH");
    }
    if (this.isPacked) {
      defines.push("#define PACKED");
    }
    var join = defines.join("\n");
    if (this._cachedDefines !== join) {
      this._cachedDefines = join;
      this._effect = this._scene.getEngine().createEffect("depth", attribs, ["world", "mBones", "viewProjection", "diffuseMatrix", "depthValues", "morphTargetInfluences"], ["diffuseSampler"], join, void 0, void 0, void 0, { maxSimultaneousMorphTargets: numMorphInfluencers });
    }
    return this._effect.isReady();
  };
  DepthRenderer2.prototype.getDepthMap = function() {
    return this._depthMap;
  };
  DepthRenderer2.prototype.dispose = function() {
    this._depthMap.dispose();
  };
  DepthRenderer2._SceneComponentInitialization = function(_) {
    throw _DevTools.WarnImport("DepthRendererSceneComponent");
  };
  return DepthRenderer2;
}();

// node_modules/@babylonjs/core/Shaders/minmaxRedux.fragment.js
var name40 = "minmaxReduxPixelShader";
var shader40 = "attribute vec2 vUV;\nuniform sampler2D textureSampler;\n#if defined(INITIAL)\nuniform sampler2D sourceTexture;\nuniform vec2 texSize;\nvoid main(void)\n{\nivec2 coord=ivec2(vUV*(texSize-1.0));\nfloat f1=texelFetch(sourceTexture,coord,0).r;\nfloat f2=texelFetch(sourceTexture,coord+ivec2(1,0),0).r;\nfloat f3=texelFetch(sourceTexture,coord+ivec2(1,1),0).r;\nfloat f4=texelFetch(sourceTexture,coord+ivec2(0,1),0).r;\nfloat minz=min(min(min(f1,f2),f3),f4);\n#ifdef DEPTH_REDUX\nfloat maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);\n#else\nfloat maxz=max(max(max(f1,f2),f3),f4);\n#endif\nglFragColor=vec4(minz,maxz,0.,0.);\n}\n#elif defined(MAIN)\nuniform vec2 texSize;\nvoid main(void)\n{\nivec2 coord=ivec2(vUV*(texSize-1.0));\nvec2 f1=texelFetch(textureSampler,coord,0).rg;\nvec2 f2=texelFetch(textureSampler,coord+ivec2(1,0),0).rg;\nvec2 f3=texelFetch(textureSampler,coord+ivec2(1,1),0).rg;\nvec2 f4=texelFetch(textureSampler,coord+ivec2(0,1),0).rg;\nfloat minz=min(min(min(f1.x,f2.x),f3.x),f4.x);\nfloat maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);\nglFragColor=vec4(minz,maxz,0.,0.);\n}\n#elif defined(ONEBEFORELAST)\nuniform ivec2 texSize;\nvoid main(void)\n{\nivec2 coord=ivec2(vUV*vec2(texSize-1));\nvec2 f1=texelFetch(textureSampler,coord % texSize,0).rg;\nvec2 f2=texelFetch(textureSampler,(coord+ivec2(1,0)) % texSize,0).rg;\nvec2 f3=texelFetch(textureSampler,(coord+ivec2(1,1)) % texSize,0).rg;\nvec2 f4=texelFetch(textureSampler,(coord+ivec2(0,1)) % texSize,0).rg;\nfloat minz=min(f1.x,f2.x);\nfloat maxz=max(f1.y,f2.y);\nglFragColor=vec4(minz,maxz,0.,0.);\n}\n#elif defined(LAST)\nvoid main(void)\n{\ndiscard;\nglFragColor=vec4(0.);\n}\n#endif\n";
Effect.ShadersStore[name40] = shader40;

// node_modules/@babylonjs/core/Misc/minMaxReducer.js
var MinMaxReducer = function() {
  function MinMaxReducer2(camera) {
    this.onAfterReductionPerformed = new Observable();
    this._forceFullscreenViewport = true;
    this._activated = false;
    this._camera = camera;
    this._postProcessManager = new PostProcessManager(camera.getScene());
  }
  Object.defineProperty(MinMaxReducer2.prototype, "sourceTexture", {
    get: function() {
      return this._sourceTexture;
    },
    enumerable: false,
    configurable: true
  });
  MinMaxReducer2.prototype.setSourceTexture = function(sourceTexture, depthRedux, type, forceFullscreenViewport) {
    var _this = this;
    if (type === void 0) {
      type = 2;
    }
    if (forceFullscreenViewport === void 0) {
      forceFullscreenViewport = true;
    }
    if (sourceTexture === this._sourceTexture) {
      return;
    }
    this.dispose(false);
    this._sourceTexture = sourceTexture;
    this._reductionSteps = [];
    this._forceFullscreenViewport = forceFullscreenViewport;
    var scene = this._camera.getScene();
    var reductionInitial = new PostProcess("Initial reduction phase", "minmaxRedux", ["texSize"], ["sourceTexture"], 1, null, 1, scene.getEngine(), false, "#define INITIAL" + (depthRedux ? "\n#define DEPTH_REDUX" : ""), type, void 0, void 0, void 0, 7);
    reductionInitial.autoClear = false;
    reductionInitial.forceFullscreenViewport = forceFullscreenViewport;
    var w = this._sourceTexture.getRenderWidth(), h = this._sourceTexture.getRenderHeight();
    reductionInitial.onApply = function(w2, h2) {
      return function(effect) {
        effect.setTexture("sourceTexture", _this._sourceTexture);
        effect.setFloatArray2("texSize", new Float32Array([w2, h2]));
      };
    }(w, h);
    this._reductionSteps.push(reductionInitial);
    var index = 1;
    while (w > 1 || h > 1) {
      w = Math.max(Math.round(w / 2), 1);
      h = Math.max(Math.round(h / 2), 1);
      var reduction = new PostProcess("Reduction phase " + index, "minmaxRedux", ["texSize"], null, { width: w, height: h }, null, 1, scene.getEngine(), false, "#define " + (w == 1 && h == 1 ? "LAST" : w == 1 || h == 1 ? "ONEBEFORELAST" : "MAIN"), type, void 0, void 0, void 0, 7);
      reduction.autoClear = false;
      reduction.forceFullscreenViewport = forceFullscreenViewport;
      reduction.onApply = function(w2, h2) {
        return function(effect) {
          if (w2 == 1 || h2 == 1) {
            effect.setIntArray2("texSize", new Int32Array([w2, h2]));
          } else {
            effect.setFloatArray2("texSize", new Float32Array([w2, h2]));
          }
        };
      }(w, h);
      this._reductionSteps.push(reduction);
      index++;
      if (w == 1 && h == 1) {
        var func = function(w2, h2, reduction2) {
          var buffer = new Float32Array(4 * w2 * h2), minmax = { min: 0, max: 0 };
          return function() {
            scene.getEngine()._readTexturePixels(reduction2.inputTexture, w2, h2, -1, 0, buffer);
            minmax.min = buffer[0];
            minmax.max = buffer[1];
            _this.onAfterReductionPerformed.notifyObservers(minmax);
          };
        };
        reduction.onAfterRenderObservable.add(func(w, h, reduction));
      }
    }
  };
  Object.defineProperty(MinMaxReducer2.prototype, "refreshRate", {
    get: function() {
      return this._sourceTexture ? this._sourceTexture.refreshRate : -1;
    },
    set: function(value) {
      if (this._sourceTexture) {
        this._sourceTexture.refreshRate = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MinMaxReducer2.prototype, "activated", {
    get: function() {
      return this._activated;
    },
    enumerable: false,
    configurable: true
  });
  MinMaxReducer2.prototype.activate = function() {
    var _this = this;
    if (this._onAfterUnbindObserver || !this._sourceTexture) {
      return;
    }
    this._onAfterUnbindObserver = this._sourceTexture.onAfterUnbindObservable.add(function() {
      _this._reductionSteps[0].activate(_this._camera);
      _this._postProcessManager.directRender(_this._reductionSteps, _this._reductionSteps[0].inputTexture, _this._forceFullscreenViewport);
      _this._camera.getScene().getEngine().unBindFramebuffer(_this._reductionSteps[0].inputTexture, false);
    });
    this._activated = true;
  };
  MinMaxReducer2.prototype.deactivate = function() {
    if (!this._onAfterUnbindObserver || !this._sourceTexture) {
      return;
    }
    this._sourceTexture.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);
    this._onAfterUnbindObserver = null;
    this._activated = false;
  };
  MinMaxReducer2.prototype.dispose = function(disposeAll) {
    if (disposeAll === void 0) {
      disposeAll = true;
    }
    if (disposeAll) {
      this.onAfterReductionPerformed.clear();
    }
    this.deactivate();
    if (this._reductionSteps) {
      for (var i = 0; i < this._reductionSteps.length; ++i) {
        this._reductionSteps[i].dispose();
      }
      this._reductionSteps = null;
    }
    if (this._postProcessManager && disposeAll) {
      this._postProcessManager.dispose();
    }
    this._sourceTexture = null;
  };
  return MinMaxReducer2;
}();

// node_modules/@babylonjs/core/Misc/depthReducer.js
var DepthReducer = function(_super) {
  __extends(DepthReducer2, _super);
  function DepthReducer2(camera) {
    return _super.call(this, camera) || this;
  }
  Object.defineProperty(DepthReducer2.prototype, "depthRenderer", {
    get: function() {
      return this._depthRenderer;
    },
    enumerable: false,
    configurable: true
  });
  DepthReducer2.prototype.setDepthRenderer = function(depthRenderer, type, forceFullscreenViewport) {
    if (depthRenderer === void 0) {
      depthRenderer = null;
    }
    if (type === void 0) {
      type = 2;
    }
    if (forceFullscreenViewport === void 0) {
      forceFullscreenViewport = true;
    }
    var scene = this._camera.getScene();
    if (this._depthRenderer) {
      delete scene._depthRenderer[this._depthRendererId];
      this._depthRenderer.dispose();
      this._depthRenderer = null;
    }
    if (depthRenderer === null) {
      if (!scene._depthRenderer) {
        scene._depthRenderer = {};
      }
      depthRenderer = this._depthRenderer = new DepthRenderer(scene, type, this._camera, false);
      depthRenderer.enabled = false;
      this._depthRendererId = "minmax" + this._camera.id;
      scene._depthRenderer[this._depthRendererId] = depthRenderer;
    }
    _super.prototype.setSourceTexture.call(this, depthRenderer.getDepthMap(), true, type, forceFullscreenViewport);
  };
  DepthReducer2.prototype.setSourceTexture = function(sourceTexture, depthRedux, type, forceFullscreenViewport) {
    if (type === void 0) {
      type = 2;
    }
    if (forceFullscreenViewport === void 0) {
      forceFullscreenViewport = true;
    }
    _super.prototype.setSourceTexture.call(this, sourceTexture, depthRedux, type, forceFullscreenViewport);
  };
  DepthReducer2.prototype.activate = function() {
    if (this._depthRenderer) {
      this._depthRenderer.enabled = true;
    }
    _super.prototype.activate.call(this);
  };
  DepthReducer2.prototype.deactivate = function() {
    _super.prototype.deactivate.call(this);
    if (this._depthRenderer) {
      this._depthRenderer.enabled = false;
    }
  };
  DepthReducer2.prototype.dispose = function(disposeAll) {
    if (disposeAll === void 0) {
      disposeAll = true;
    }
    _super.prototype.dispose.call(this, disposeAll);
    if (this._depthRenderer && disposeAll) {
      var scene = this._depthRenderer.getDepthMap().getScene();
      if (scene) {
        delete scene._depthRenderer[this._depthRendererId];
      }
      this._depthRenderer.dispose();
      this._depthRenderer = null;
    }
  };
  return DepthReducer2;
}(MinMaxReducer);

// node_modules/@babylonjs/core/Lights/Shadows/cascadedShadowGenerator.js
var UpDir = Vector3.Up();
var ZeroVec = Vector3.Zero();
var tmpv1 = new Vector3();
var tmpv2 = new Vector3();
var tmpMatrix3 = new Matrix();
var tmpMatrix22 = new Matrix();
var CascadedShadowGenerator = function(_super) {
  __extends(CascadedShadowGenerator2, _super);
  function CascadedShadowGenerator2(mapSize, light, usefulFloatFirst) {
    var _this = this;
    if (!CascadedShadowGenerator2.IsSupported) {
      Logger.Error("CascadedShadowMap needs WebGL 2 support.");
      return;
    }
    _this = _super.call(this, mapSize, light, usefulFloatFirst) || this;
    _this.usePercentageCloserFiltering = true;
    return _this;
  }
  CascadedShadowGenerator2.prototype._validateFilter = function(filter) {
    if (filter === ShadowGenerator.FILTER_NONE || filter === ShadowGenerator.FILTER_PCF || filter === ShadowGenerator.FILTER_PCSS) {
      return filter;
    }
    console.error('Unsupported filter "' + filter + '"!');
    return ShadowGenerator.FILTER_NONE;
  };
  Object.defineProperty(CascadedShadowGenerator2.prototype, "numCascades", {
    get: function() {
      return this._numCascades;
    },
    set: function(value) {
      value = Math.min(Math.max(value, CascadedShadowGenerator2.MIN_CASCADES_COUNT), CascadedShadowGenerator2.MAX_CASCADES_COUNT);
      if (value === this._numCascades) {
        return;
      }
      this._numCascades = value;
      this.recreateShadowMap();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CascadedShadowGenerator2.prototype, "freezeShadowCastersBoundingInfo", {
    get: function() {
      return this._freezeShadowCastersBoundingInfo;
    },
    set: function(freeze) {
      if (this._freezeShadowCastersBoundingInfoObservable && freeze) {
        this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable);
        this._freezeShadowCastersBoundingInfoObservable = null;
      }
      if (!this._freezeShadowCastersBoundingInfoObservable && !freeze) {
        this._freezeShadowCastersBoundingInfoObservable = this._scene.onBeforeRenderObservable.add(this._computeShadowCastersBoundingInfo.bind(this));
      }
      this._freezeShadowCastersBoundingInfo = freeze;
      if (freeze) {
        this._computeShadowCastersBoundingInfo();
      }
    },
    enumerable: false,
    configurable: true
  });
  CascadedShadowGenerator2.prototype._computeShadowCastersBoundingInfo = function() {
    this._scbiMin.copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._scbiMax.copyFromFloats(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);
    if (this._shadowMap && this._shadowMap.renderList) {
      var renderList = this._shadowMap.renderList;
      for (var meshIndex = 0; meshIndex < renderList.length; meshIndex++) {
        var mesh = renderList[meshIndex];
        if (!mesh) {
          continue;
        }
        var boundingInfo = mesh.getBoundingInfo(), boundingBox = boundingInfo.boundingBox;
        this._scbiMin.minimizeInPlace(boundingBox.minimumWorld);
        this._scbiMax.maximizeInPlace(boundingBox.maximumWorld);
      }
      var meshes = this._scene.meshes;
      for (var meshIndex = 0; meshIndex < meshes.length; meshIndex++) {
        var mesh = meshes[meshIndex];
        if (!mesh || !mesh.isVisible || !mesh.isEnabled || !mesh.receiveShadows) {
          continue;
        }
        var boundingInfo = mesh.getBoundingInfo(), boundingBox = boundingInfo.boundingBox;
        this._scbiMin.minimizeInPlace(boundingBox.minimumWorld);
        this._scbiMax.maximizeInPlace(boundingBox.maximumWorld);
      }
    }
    this._shadowCastersBoundingInfo.reConstruct(this._scbiMin, this._scbiMax);
  };
  Object.defineProperty(CascadedShadowGenerator2.prototype, "shadowCastersBoundingInfo", {
    get: function() {
      return this._shadowCastersBoundingInfo;
    },
    set: function(boundingInfo) {
      this._shadowCastersBoundingInfo = boundingInfo;
    },
    enumerable: false,
    configurable: true
  });
  CascadedShadowGenerator2.prototype.setMinMaxDistance = function(min, max) {
    if (this._minDistance === min && this._maxDistance === max) {
      return;
    }
    if (min > max) {
      min = 0;
      max = 1;
    }
    if (min < 0) {
      min = 0;
    }
    if (max > 1) {
      max = 1;
    }
    this._minDistance = min;
    this._maxDistance = max;
    this._breaksAreDirty = true;
  };
  Object.defineProperty(CascadedShadowGenerator2.prototype, "minDistance", {
    get: function() {
      return this._minDistance;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CascadedShadowGenerator2.prototype, "maxDistance", {
    get: function() {
      return this._maxDistance;
    },
    enumerable: false,
    configurable: true
  });
  CascadedShadowGenerator2.prototype.getClassName = function() {
    return CascadedShadowGenerator2.CLASSNAME;
  };
  CascadedShadowGenerator2.prototype.getCascadeMinExtents = function(cascadeIndex) {
    return cascadeIndex >= 0 && cascadeIndex < this._numCascades ? this._cascadeMinExtents[cascadeIndex] : null;
  };
  CascadedShadowGenerator2.prototype.getCascadeMaxExtents = function(cascadeIndex) {
    return cascadeIndex >= 0 && cascadeIndex < this._numCascades ? this._cascadeMaxExtents[cascadeIndex] : null;
  };
  Object.defineProperty(CascadedShadowGenerator2.prototype, "shadowMaxZ", {
    get: function() {
      if (!this._scene || !this._scene.activeCamera) {
        return 0;
      }
      return this._shadowMaxZ;
    },
    set: function(value) {
      if (!this._scene || !this._scene.activeCamera) {
        this._shadowMaxZ = value;
        return;
      }
      if (this._shadowMaxZ === value || value < this._scene.activeCamera.minZ || value > this._scene.activeCamera.maxZ) {
        return;
      }
      this._shadowMaxZ = value;
      this._light._markMeshesAsLightDirty();
      this._breaksAreDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CascadedShadowGenerator2.prototype, "debug", {
    get: function() {
      return this._debug;
    },
    set: function(dbg) {
      this._debug = dbg;
      this._light._markMeshesAsLightDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CascadedShadowGenerator2.prototype, "depthClamp", {
    get: function() {
      return this._depthClamp;
    },
    set: function(value) {
      this._depthClamp = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CascadedShadowGenerator2.prototype, "cascadeBlendPercentage", {
    get: function() {
      return this._cascadeBlendPercentage;
    },
    set: function(value) {
      this._cascadeBlendPercentage = value;
      this._light._markMeshesAsLightDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CascadedShadowGenerator2.prototype, "lambda", {
    get: function() {
      return this._lambda;
    },
    set: function(value) {
      var lambda = Math.min(Math.max(value, 0), 1);
      if (this._lambda == lambda) {
        return;
      }
      this._lambda = lambda;
      this._breaksAreDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  CascadedShadowGenerator2.prototype.getCascadeViewMatrix = function(cascadeNum) {
    return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._viewMatrices[cascadeNum] : null;
  };
  CascadedShadowGenerator2.prototype.getCascadeProjectionMatrix = function(cascadeNum) {
    return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._projectionMatrices[cascadeNum] : null;
  };
  CascadedShadowGenerator2.prototype.getCascadeTransformMatrix = function(cascadeNum) {
    return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._transformMatrices[cascadeNum] : null;
  };
  CascadedShadowGenerator2.prototype.setDepthRenderer = function(depthRenderer) {
    this._depthRenderer = depthRenderer;
    if (this._depthReducer) {
      this._depthReducer.setDepthRenderer(this._depthRenderer);
    }
  };
  Object.defineProperty(CascadedShadowGenerator2.prototype, "autoCalcDepthBounds", {
    get: function() {
      return this._autoCalcDepthBounds;
    },
    set: function(value) {
      var _this = this;
      var camera = this._scene.activeCamera;
      if (!camera) {
        return;
      }
      this._autoCalcDepthBounds = value;
      if (!value) {
        if (this._depthReducer) {
          this._depthReducer.deactivate();
        }
        this.setMinMaxDistance(0, 1);
        return;
      }
      if (!this._depthReducer) {
        this._depthReducer = new DepthReducer(camera);
        this._depthReducer.onAfterReductionPerformed.add(function(minmax) {
          var min = minmax.min, max = minmax.max;
          if (min >= max) {
            min = 0;
            max = 1;
          }
          if (min != _this._minDistance || max != _this._maxDistance) {
            _this.setMinMaxDistance(min, max);
          }
        });
        this._depthReducer.setDepthRenderer(this._depthRenderer);
      }
      this._depthReducer.activate();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CascadedShadowGenerator2.prototype, "autoCalcDepthBoundsRefreshRate", {
    get: function() {
      var _a, _b, _c;
      return (_c = (_b = (_a = this._depthReducer) === null || _a === void 0 ? void 0 : _a.depthRenderer) === null || _b === void 0 ? void 0 : _b.getDepthMap().refreshRate) !== null && _c !== void 0 ? _c : -1;
    },
    set: function(value) {
      var _a;
      if ((_a = this._depthReducer) === null || _a === void 0 ? void 0 : _a.depthRenderer) {
        this._depthReducer.depthRenderer.getDepthMap().refreshRate = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  CascadedShadowGenerator2.prototype.splitFrustum = function() {
    this._breaksAreDirty = true;
  };
  CascadedShadowGenerator2.prototype._splitFrustum = function() {
    var camera = this._scene.activeCamera;
    if (!camera) {
      return;
    }
    var near = camera.minZ, far = camera.maxZ, cameraRange = far - near, minDistance = this._minDistance, maxDistance = this._shadowMaxZ < far && this._shadowMaxZ >= near ? Math.min((this._shadowMaxZ - near) / (far - near), this._maxDistance) : this._maxDistance;
    var minZ = near + minDistance * cameraRange, maxZ = near + maxDistance * cameraRange;
    var range = maxZ - minZ, ratio = maxZ / minZ;
    for (var cascadeIndex = 0; cascadeIndex < this._cascades.length; ++cascadeIndex) {
      var p = (cascadeIndex + 1) / this._numCascades, log = minZ * Math.pow(ratio, p), uniform = minZ + range * p;
      var d = this._lambda * (log - uniform) + uniform;
      this._cascades[cascadeIndex].prevBreakDistance = cascadeIndex === 0 ? minDistance : this._cascades[cascadeIndex - 1].breakDistance;
      this._cascades[cascadeIndex].breakDistance = (d - near) / cameraRange;
      this._viewSpaceFrustumsZ[cascadeIndex] = near + this._cascades[cascadeIndex].breakDistance * cameraRange;
      this._frustumLengths[cascadeIndex] = (this._cascades[cascadeIndex].breakDistance - this._cascades[cascadeIndex].prevBreakDistance) * cameraRange;
    }
    this._breaksAreDirty = false;
  };
  CascadedShadowGenerator2.prototype._computeMatrices = function() {
    var scene = this._scene;
    var camera = scene.activeCamera;
    if (!camera) {
      return;
    }
    Vector3.NormalizeToRef(this._light.getShadowDirection(0), this._lightDirection);
    if (Math.abs(Vector3.Dot(this._lightDirection, Vector3.Up())) === 1) {
      this._lightDirection.z = 1e-13;
    }
    this._cachedDirection.copyFrom(this._lightDirection);
    for (var cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {
      this._computeFrustumInWorldSpace(cascadeIndex);
      this._computeCascadeFrustum(cascadeIndex);
      this._cascadeMaxExtents[cascadeIndex].subtractToRef(this._cascadeMinExtents[cascadeIndex], tmpv1);
      this._frustumCenter[cascadeIndex].addToRef(this._lightDirection.scale(this._cascadeMinExtents[cascadeIndex].z), this._shadowCameraPos[cascadeIndex]);
      Matrix.LookAtLHToRef(this._shadowCameraPos[cascadeIndex], this._frustumCenter[cascadeIndex], UpDir, this._viewMatrices[cascadeIndex]);
      var minZ = 0, maxZ = tmpv1.z;
      var boundingInfo = this._shadowCastersBoundingInfo;
      boundingInfo.update(this._viewMatrices[cascadeIndex]);
      maxZ = Math.min(maxZ, boundingInfo.boundingBox.maximumWorld.z);
      if (!this._depthClamp || this.filter === ShadowGenerator.FILTER_PCSS) {
        minZ = Math.min(minZ, boundingInfo.boundingBox.minimumWorld.z);
      } else {
        minZ = Math.max(minZ, boundingInfo.boundingBox.minimumWorld.z);
      }
      Matrix.OrthoOffCenterLHToRef(this._cascadeMinExtents[cascadeIndex].x, this._cascadeMaxExtents[cascadeIndex].x, this._cascadeMinExtents[cascadeIndex].y, this._cascadeMaxExtents[cascadeIndex].y, minZ, maxZ, this._projectionMatrices[cascadeIndex]);
      this._cascadeMinExtents[cascadeIndex].z = minZ;
      this._cascadeMaxExtents[cascadeIndex].z = maxZ;
      this._viewMatrices[cascadeIndex].multiplyToRef(this._projectionMatrices[cascadeIndex], this._transformMatrices[cascadeIndex]);
      Vector3.TransformCoordinatesToRef(ZeroVec, this._transformMatrices[cascadeIndex], tmpv1);
      tmpv1.scaleInPlace(this._mapSize / 2);
      tmpv2.copyFromFloats(Math.round(tmpv1.x), Math.round(tmpv1.y), Math.round(tmpv1.z));
      tmpv2.subtractInPlace(tmpv1).scaleInPlace(2 / this._mapSize);
      Matrix.TranslationToRef(tmpv2.x, tmpv2.y, 0, tmpMatrix3);
      this._projectionMatrices[cascadeIndex].multiplyToRef(tmpMatrix3, this._projectionMatrices[cascadeIndex]);
      this._viewMatrices[cascadeIndex].multiplyToRef(this._projectionMatrices[cascadeIndex], this._transformMatrices[cascadeIndex]);
      this._transformMatrices[cascadeIndex].copyToArray(this._transformMatricesAsArray, cascadeIndex * 16);
    }
  };
  CascadedShadowGenerator2.prototype._computeFrustumInWorldSpace = function(cascadeIndex) {
    if (!this._scene.activeCamera) {
      return;
    }
    var prevSplitDist = this._cascades[cascadeIndex].prevBreakDistance, splitDist = this._cascades[cascadeIndex].breakDistance;
    this._scene.activeCamera.getViewMatrix();
    var invViewProj = Matrix.Invert(this._scene.activeCamera.getTransformationMatrix());
    for (var cornerIndex = 0; cornerIndex < CascadedShadowGenerator2.frustumCornersNDCSpace.length; ++cornerIndex) {
      Vector3.TransformCoordinatesToRef(CascadedShadowGenerator2.frustumCornersNDCSpace[cornerIndex], invViewProj, this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);
    }
    for (var cornerIndex = 0; cornerIndex < CascadedShadowGenerator2.frustumCornersNDCSpace.length / 2; ++cornerIndex) {
      tmpv1.copyFrom(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex + 4]).subtractInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);
      tmpv2.copyFrom(tmpv1).scaleInPlace(prevSplitDist);
      tmpv1.scaleInPlace(splitDist);
      tmpv1.addInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);
      this._frustumCornersWorldSpace[cascadeIndex][cornerIndex + 4].copyFrom(tmpv1);
      this._frustumCornersWorldSpace[cascadeIndex][cornerIndex].addInPlace(tmpv2);
    }
  };
  CascadedShadowGenerator2.prototype._computeCascadeFrustum = function(cascadeIndex) {
    this._cascadeMinExtents[cascadeIndex].copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cascadeMaxExtents[cascadeIndex].copyFromFloats(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);
    this._frustumCenter[cascadeIndex].copyFromFloats(0, 0, 0);
    var camera = this._scene.activeCamera;
    if (!camera) {
      return;
    }
    for (var cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {
      this._frustumCenter[cascadeIndex].addInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);
    }
    this._frustumCenter[cascadeIndex].scaleInPlace(1 / this._frustumCornersWorldSpace[cascadeIndex].length);
    if (this.stabilizeCascades) {
      var sphereRadius = 0;
      for (var cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {
        var dist = this._frustumCornersWorldSpace[cascadeIndex][cornerIndex].subtractToRef(this._frustumCenter[cascadeIndex], tmpv1).length();
        sphereRadius = Math.max(sphereRadius, dist);
      }
      sphereRadius = Math.ceil(sphereRadius * 16) / 16;
      this._cascadeMaxExtents[cascadeIndex].copyFromFloats(sphereRadius, sphereRadius, sphereRadius);
      this._cascadeMinExtents[cascadeIndex].copyFromFloats(-sphereRadius, -sphereRadius, -sphereRadius);
    } else {
      var lightCameraPos = this._frustumCenter[cascadeIndex];
      this._frustumCenter[cascadeIndex].addToRef(this._lightDirection, tmpv1);
      Matrix.LookAtLHToRef(lightCameraPos, tmpv1, UpDir, tmpMatrix3);
      for (var cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {
        Vector3.TransformCoordinatesToRef(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex], tmpMatrix3, tmpv1);
        this._cascadeMinExtents[cascadeIndex].minimizeInPlace(tmpv1);
        this._cascadeMaxExtents[cascadeIndex].maximizeInPlace(tmpv1);
      }
    }
  };
  Object.defineProperty(CascadedShadowGenerator2, "IsSupported", {
    get: function() {
      var engine = EngineStore.LastCreatedEngine;
      if (!engine) {
        return false;
      }
      return engine.webGLVersion != 1;
    },
    enumerable: false,
    configurable: true
  });
  CascadedShadowGenerator2.prototype._initializeGenerator = function() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
    this.penumbraDarkness = (_a = this.penumbraDarkness) !== null && _a !== void 0 ? _a : 1;
    this._numCascades = (_b = this._numCascades) !== null && _b !== void 0 ? _b : CascadedShadowGenerator2.DEFAULT_CASCADES_COUNT;
    this.stabilizeCascades = (_c = this.stabilizeCascades) !== null && _c !== void 0 ? _c : false;
    this._freezeShadowCastersBoundingInfoObservable = (_d = this._freezeShadowCastersBoundingInfoObservable) !== null && _d !== void 0 ? _d : null;
    this.freezeShadowCastersBoundingInfo = (_e = this.freezeShadowCastersBoundingInfo) !== null && _e !== void 0 ? _e : false;
    this._scbiMin = (_f = this._scbiMin) !== null && _f !== void 0 ? _f : new Vector3(0, 0, 0);
    this._scbiMax = (_g = this._scbiMax) !== null && _g !== void 0 ? _g : new Vector3(0, 0, 0);
    this._shadowCastersBoundingInfo = (_h = this._shadowCastersBoundingInfo) !== null && _h !== void 0 ? _h : new BoundingInfo(new Vector3(0, 0, 0), new Vector3(0, 0, 0));
    this._breaksAreDirty = (_j = this._breaksAreDirty) !== null && _j !== void 0 ? _j : true;
    this._minDistance = (_k = this._minDistance) !== null && _k !== void 0 ? _k : 0;
    this._maxDistance = (_l = this._maxDistance) !== null && _l !== void 0 ? _l : 1;
    this._currentLayer = (_m = this._currentLayer) !== null && _m !== void 0 ? _m : 0;
    this._shadowMaxZ = (_q = (_o = this._shadowMaxZ) !== null && _o !== void 0 ? _o : (_p = this._scene.activeCamera) === null || _p === void 0 ? void 0 : _p.maxZ) !== null && _q !== void 0 ? _q : 1e4;
    this._debug = (_r = this._debug) !== null && _r !== void 0 ? _r : false;
    this._depthClamp = (_s = this._depthClamp) !== null && _s !== void 0 ? _s : true;
    this._cascadeBlendPercentage = (_t = this._cascadeBlendPercentage) !== null && _t !== void 0 ? _t : 0.1;
    this._lambda = (_u = this._lambda) !== null && _u !== void 0 ? _u : 0.5;
    this._autoCalcDepthBounds = (_v = this._autoCalcDepthBounds) !== null && _v !== void 0 ? _v : false;
    _super.prototype._initializeGenerator.call(this);
  };
  CascadedShadowGenerator2.prototype._createTargetRenderTexture = function() {
    var size = { width: this._mapSize, height: this._mapSize, layers: this.numCascades };
    this._shadowMap = new RenderTargetTexture(this._light.name + "_shadowMap", size, this._scene, false, true, this._textureType, false, void 0, false, false, void 0);
    this._shadowMap.createDepthStencilTexture(513, true);
  };
  CascadedShadowGenerator2.prototype._initializeShadowMap = function() {
    var _this = this;
    _super.prototype._initializeShadowMap.call(this);
    if (this._shadowMap === null) {
      return;
    }
    this._transformMatricesAsArray = new Float32Array(this._numCascades * 16);
    this._viewSpaceFrustumsZ = new Array(this._numCascades);
    this._frustumLengths = new Array(this._numCascades);
    this._lightSizeUVCorrection = new Array(this._numCascades * 2);
    this._depthCorrection = new Array(this._numCascades);
    this._cascades = [];
    this._viewMatrices = [];
    this._projectionMatrices = [];
    this._transformMatrices = [];
    this._cascadeMinExtents = [];
    this._cascadeMaxExtents = [];
    this._frustumCenter = [];
    this._shadowCameraPos = [];
    this._frustumCornersWorldSpace = [];
    for (var cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {
      this._cascades[cascadeIndex] = {
        prevBreakDistance: 0,
        breakDistance: 0
      };
      this._viewMatrices[cascadeIndex] = Matrix.Zero();
      this._projectionMatrices[cascadeIndex] = Matrix.Zero();
      this._transformMatrices[cascadeIndex] = Matrix.Zero();
      this._cascadeMinExtents[cascadeIndex] = new Vector3();
      this._cascadeMaxExtents[cascadeIndex] = new Vector3();
      this._frustumCenter[cascadeIndex] = new Vector3();
      this._shadowCameraPos[cascadeIndex] = new Vector3();
      this._frustumCornersWorldSpace[cascadeIndex] = new Array(CascadedShadowGenerator2.frustumCornersNDCSpace.length);
      for (var i = 0; i < CascadedShadowGenerator2.frustumCornersNDCSpace.length; ++i) {
        this._frustumCornersWorldSpace[cascadeIndex][i] = new Vector3();
      }
    }
    this._shadowMap.onBeforeRenderObservable.add(function(layer) {
      _this._currentLayer = layer;
      if (_this._scene.getSceneUniformBuffer().useUbo) {
        var sceneUBO = _this._scene.getSceneUniformBuffer();
        sceneUBO.updateMatrix("viewProjection", _this.getCascadeTransformMatrix(layer));
        sceneUBO.updateMatrix("view", _this.getCascadeViewMatrix(layer));
        sceneUBO.update();
      }
    });
    this._shadowMap.onBeforeBindObservable.add(function() {
      if (_this._breaksAreDirty) {
        _this._splitFrustum();
      }
      _this._computeMatrices();
    });
    this._splitFrustum();
  };
  CascadedShadowGenerator2.prototype._bindCustomEffectForRenderSubMeshForShadowMap = function(subMesh, effect, matriceNames, mesh) {
    var _a, _b, _c, _d, _e, _f;
    effect.setMatrix((_a = matriceNames === null || matriceNames === void 0 ? void 0 : matriceNames.viewProjection) !== null && _a !== void 0 ? _a : "viewProjection", this.getCascadeTransformMatrix(this._currentLayer));
    effect.setMatrix((_b = matriceNames === null || matriceNames === void 0 ? void 0 : matriceNames.view) !== null && _b !== void 0 ? _b : "view", this.getCascadeViewMatrix(this._currentLayer));
    effect.setMatrix((_c = matriceNames === null || matriceNames === void 0 ? void 0 : matriceNames.projection) !== null && _c !== void 0 ? _c : "projection", this.getCascadeProjectionMatrix(this._currentLayer));
    var world = mesh.getWorldMatrix();
    effect.setMatrix((_d = matriceNames === null || matriceNames === void 0 ? void 0 : matriceNames.world) !== null && _d !== void 0 ? _d : "world", world);
    world.multiplyToRef(this.getCascadeTransformMatrix(this._currentLayer), tmpMatrix3);
    effect.setMatrix((_e = matriceNames === null || matriceNames === void 0 ? void 0 : matriceNames.worldViewProjection) !== null && _e !== void 0 ? _e : "worldViewProjection", tmpMatrix3);
    world.multiplyToRef(this.getCascadeViewMatrix(this._currentLayer), tmpMatrix22);
    effect.setMatrix((_f = matriceNames === null || matriceNames === void 0 ? void 0 : matriceNames.worldView) !== null && _f !== void 0 ? _f : "worldView", tmpMatrix22);
  };
  CascadedShadowGenerator2.prototype._isReadyCustomDefines = function(defines, subMesh, useInstances) {
    defines.push("#define SM_DEPTHCLAMP " + (this._depthClamp && this._filter !== ShadowGenerator.FILTER_PCSS ? "1" : "0"));
  };
  CascadedShadowGenerator2.prototype.prepareDefines = function(defines, lightIndex) {
    _super.prototype.prepareDefines.call(this, defines, lightIndex);
    var scene = this._scene;
    var light = this._light;
    if (!scene.shadowsEnabled || !light.shadowEnabled) {
      return;
    }
    defines["SHADOWCSM" + lightIndex] = true;
    defines["SHADOWCSMDEBUG" + lightIndex] = this.debug;
    defines["SHADOWCSMNUM_CASCADES" + lightIndex] = this.numCascades;
    defines["SHADOWCSM_RIGHTHANDED" + lightIndex] = scene.useRightHandedSystem;
    var camera = scene.activeCamera;
    if (camera && this._shadowMaxZ < camera.maxZ) {
      defines["SHADOWCSMUSESHADOWMAXZ" + lightIndex] = true;
    }
    if (this.cascadeBlendPercentage === 0) {
      defines["SHADOWCSMNOBLEND" + lightIndex] = true;
    }
  };
  CascadedShadowGenerator2.prototype.bindShadowLight = function(lightIndex, effect) {
    var light = this._light;
    var scene = this._scene;
    if (!scene.shadowsEnabled || !light.shadowEnabled) {
      return;
    }
    var camera = scene.activeCamera;
    if (!camera) {
      return;
    }
    var shadowMap = this.getShadowMap();
    if (!shadowMap) {
      return;
    }
    var width = shadowMap.getSize().width;
    effect.setMatrices("lightMatrix" + lightIndex, this._transformMatricesAsArray);
    effect.setArray("viewFrustumZ" + lightIndex, this._viewSpaceFrustumsZ);
    effect.setFloat("cascadeBlendFactor" + lightIndex, this.cascadeBlendPercentage === 0 ? 1e4 : 1 / this.cascadeBlendPercentage);
    effect.setArray("frustumLengths" + lightIndex, this._frustumLengths);
    if (this._filter === ShadowGenerator.FILTER_PCF) {
      effect.setDepthStencilTexture("shadowSampler" + lightIndex, shadowMap);
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), width, 1 / width, this.frustumEdgeFalloff, lightIndex);
    } else if (this._filter === ShadowGenerator.FILTER_PCSS) {
      for (var cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {
        this._lightSizeUVCorrection[cascadeIndex * 2 + 0] = cascadeIndex === 0 ? 1 : (this._cascadeMaxExtents[0].x - this._cascadeMinExtents[0].x) / (this._cascadeMaxExtents[cascadeIndex].x - this._cascadeMinExtents[cascadeIndex].x);
        this._lightSizeUVCorrection[cascadeIndex * 2 + 1] = cascadeIndex === 0 ? 1 : (this._cascadeMaxExtents[0].y - this._cascadeMinExtents[0].y) / (this._cascadeMaxExtents[cascadeIndex].y - this._cascadeMinExtents[cascadeIndex].y);
        this._depthCorrection[cascadeIndex] = cascadeIndex === 0 ? 1 : (this._cascadeMaxExtents[cascadeIndex].z - this._cascadeMinExtents[cascadeIndex].z) / (this._cascadeMaxExtents[0].z - this._cascadeMinExtents[0].z);
      }
      effect.setDepthStencilTexture("shadowSampler" + lightIndex, shadowMap);
      effect.setTexture("depthSampler" + lightIndex, shadowMap);
      effect.setArray2("lightSizeUVCorrection" + lightIndex, this._lightSizeUVCorrection);
      effect.setArray("depthCorrection" + lightIndex, this._depthCorrection);
      effect.setFloat("penumbraDarkness" + lightIndex, this.penumbraDarkness);
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), 1 / width, this._contactHardeningLightSizeUVRatio * width, this.frustumEdgeFalloff, lightIndex);
    } else {
      effect.setTexture("shadowSampler" + lightIndex, shadowMap);
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), width, 1 / width, this.frustumEdgeFalloff, lightIndex);
    }
    light._uniformBuffer.updateFloat2("depthValues", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera), lightIndex);
  };
  CascadedShadowGenerator2.prototype.getTransformMatrix = function() {
    return this.getCascadeTransformMatrix(0);
  };
  CascadedShadowGenerator2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    if (this._freezeShadowCastersBoundingInfoObservable) {
      this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable);
      this._freezeShadowCastersBoundingInfoObservable = null;
    }
    if (this._depthReducer) {
      this._depthReducer.dispose();
      this._depthReducer = null;
    }
  };
  CascadedShadowGenerator2.prototype.serialize = function() {
    var serializationObject = _super.prototype.serialize.call(this);
    var shadowMap = this.getShadowMap();
    if (!shadowMap) {
      return serializationObject;
    }
    serializationObject.numCascades = this._numCascades;
    serializationObject.debug = this._debug;
    serializationObject.stabilizeCascades = this.stabilizeCascades;
    serializationObject.lambda = this._lambda;
    serializationObject.cascadeBlendPercentage = this.cascadeBlendPercentage;
    serializationObject.depthClamp = this._depthClamp;
    serializationObject.autoCalcDepthBounds = this.autoCalcDepthBounds;
    serializationObject.shadowMaxZ = this._shadowMaxZ;
    serializationObject.penumbraDarkness = this.penumbraDarkness;
    serializationObject.freezeShadowCastersBoundingInfo = this._freezeShadowCastersBoundingInfo;
    serializationObject.minDistance = this.minDistance;
    serializationObject.maxDistance = this.maxDistance;
    serializationObject.renderList = [];
    if (shadowMap.renderList) {
      for (var meshIndex = 0; meshIndex < shadowMap.renderList.length; meshIndex++) {
        var mesh = shadowMap.renderList[meshIndex];
        serializationObject.renderList.push(mesh.id);
      }
    }
    return serializationObject;
  };
  CascadedShadowGenerator2.Parse = function(parsedShadowGenerator, scene) {
    var shadowGenerator = ShadowGenerator.Parse(parsedShadowGenerator, scene, function(mapSize, light) {
      return new CascadedShadowGenerator2(mapSize, light);
    });
    if (parsedShadowGenerator.numCascades !== void 0) {
      shadowGenerator.numCascades = parsedShadowGenerator.numCascades;
    }
    if (parsedShadowGenerator.debug !== void 0) {
      shadowGenerator.debug = parsedShadowGenerator.debug;
    }
    if (parsedShadowGenerator.stabilizeCascades !== void 0) {
      shadowGenerator.stabilizeCascades = parsedShadowGenerator.stabilizeCascades;
    }
    if (parsedShadowGenerator.lambda !== void 0) {
      shadowGenerator.lambda = parsedShadowGenerator.lambda;
    }
    if (parsedShadowGenerator.cascadeBlendPercentage !== void 0) {
      shadowGenerator.cascadeBlendPercentage = parsedShadowGenerator.cascadeBlendPercentage;
    }
    if (parsedShadowGenerator.depthClamp !== void 0) {
      shadowGenerator.depthClamp = parsedShadowGenerator.depthClamp;
    }
    if (parsedShadowGenerator.autoCalcDepthBounds !== void 0) {
      shadowGenerator.autoCalcDepthBounds = parsedShadowGenerator.autoCalcDepthBounds;
    }
    if (parsedShadowGenerator.shadowMaxZ !== void 0) {
      shadowGenerator.shadowMaxZ = parsedShadowGenerator.shadowMaxZ;
    }
    if (parsedShadowGenerator.penumbraDarkness !== void 0) {
      shadowGenerator.penumbraDarkness = parsedShadowGenerator.penumbraDarkness;
    }
    if (parsedShadowGenerator.freezeShadowCastersBoundingInfo !== void 0) {
      shadowGenerator.freezeShadowCastersBoundingInfo = parsedShadowGenerator.freezeShadowCastersBoundingInfo;
    }
    if (parsedShadowGenerator.minDistance !== void 0 && parsedShadowGenerator.maxDistance !== void 0) {
      shadowGenerator.setMinMaxDistance(parsedShadowGenerator.minDistance, parsedShadowGenerator.maxDistance);
    }
    return shadowGenerator;
  };
  CascadedShadowGenerator2.frustumCornersNDCSpace = [
    new Vector3(-1, 1, -1),
    new Vector3(1, 1, -1),
    new Vector3(1, -1, -1),
    new Vector3(-1, -1, -1),
    new Vector3(-1, 1, 1),
    new Vector3(1, 1, 1),
    new Vector3(1, -1, 1),
    new Vector3(-1, -1, 1)
  ];
  CascadedShadowGenerator2.CLASSNAME = "CascadedShadowGenerator";
  CascadedShadowGenerator2.DEFAULT_CASCADES_COUNT = 4;
  CascadedShadowGenerator2.MIN_CASCADES_COUNT = 2;
  CascadedShadowGenerator2.MAX_CASCADES_COUNT = 4;
  CascadedShadowGenerator2._SceneComponentInitialization = function(_) {
    throw _DevTools.WarnImport("ShadowGeneratorSceneComponent");
  };
  return CascadedShadowGenerator2;
}(ShadowGenerator);

// node_modules/@babylonjs/core/Lights/Shadows/shadowGeneratorSceneComponent.js
AbstractScene.AddParser(SceneComponentConstants.NAME_SHADOWGENERATOR, function(parsedData, scene) {
  if (parsedData.shadowGenerators !== void 0 && parsedData.shadowGenerators !== null) {
    for (var index = 0, cache = parsedData.shadowGenerators.length; index < cache; index++) {
      var parsedShadowGenerator = parsedData.shadowGenerators[index];
      if (parsedShadowGenerator.className === CascadedShadowGenerator.CLASSNAME) {
        CascadedShadowGenerator.Parse(parsedShadowGenerator, scene);
      } else {
        ShadowGenerator.Parse(parsedShadowGenerator, scene);
      }
    }
  }
});
var ShadowGeneratorSceneComponent = function() {
  function ShadowGeneratorSceneComponent2(scene) {
    this.name = SceneComponentConstants.NAME_SHADOWGENERATOR;
    this.scene = scene;
  }
  ShadowGeneratorSceneComponent2.prototype.register = function() {
    this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR, this, this._gatherRenderTargets);
  };
  ShadowGeneratorSceneComponent2.prototype.rebuild = function() {
  };
  ShadowGeneratorSceneComponent2.prototype.serialize = function(serializationObject) {
    serializationObject.shadowGenerators = [];
    var lights = this.scene.lights;
    for (var _i = 0, lights_1 = lights; _i < lights_1.length; _i++) {
      var light = lights_1[_i];
      var shadowGenerator = light.getShadowGenerator();
      if (shadowGenerator) {
        serializationObject.shadowGenerators.push(shadowGenerator.serialize());
      }
    }
  };
  ShadowGeneratorSceneComponent2.prototype.addFromContainer = function(container) {
  };
  ShadowGeneratorSceneComponent2.prototype.removeFromContainer = function(container, dispose) {
  };
  ShadowGeneratorSceneComponent2.prototype.dispose = function() {
  };
  ShadowGeneratorSceneComponent2.prototype._gatherRenderTargets = function(renderTargets) {
    var scene = this.scene;
    if (this.scene.shadowsEnabled) {
      for (var lightIndex = 0; lightIndex < scene.lights.length; lightIndex++) {
        var light = scene.lights[lightIndex];
        var shadowGenerator = light.getShadowGenerator();
        if (light.isEnabled() && light.shadowEnabled && shadowGenerator) {
          var shadowMap = shadowGenerator.getShadowMap();
          if (scene.textures.indexOf(shadowMap) !== -1) {
            renderTargets.push(shadowMap);
          }
        }
      }
    }
  };
  return ShadowGeneratorSceneComponent2;
}();
ShadowGenerator._SceneComponentInitialization = function(scene) {
  var component = scene._getComponent(SceneComponentConstants.NAME_SHADOWGENERATOR);
  if (!component) {
    component = new ShadowGeneratorSceneComponent(scene);
    scene._addComponent(component);
  }
};

// node_modules/@babylonjs/core/Loading/loadingScreen.js
var DefaultLoadingScreen = function() {
  function DefaultLoadingScreen2(_renderingCanvas, _loadingText, _loadingDivBackgroundColor) {
    var _this = this;
    if (_loadingText === void 0) {
      _loadingText = "";
    }
    if (_loadingDivBackgroundColor === void 0) {
      _loadingDivBackgroundColor = "black";
    }
    this._renderingCanvas = _renderingCanvas;
    this._loadingText = _loadingText;
    this._loadingDivBackgroundColor = _loadingDivBackgroundColor;
    this._resizeLoadingUI = function() {
      var canvasRect = _this._renderingCanvas.getBoundingClientRect();
      var canvasPositioning = window.getComputedStyle(_this._renderingCanvas).position;
      if (!_this._loadingDiv) {
        return;
      }
      _this._loadingDiv.style.position = canvasPositioning === "fixed" ? "fixed" : "absolute";
      _this._loadingDiv.style.left = canvasRect.left + "px";
      _this._loadingDiv.style.top = canvasRect.top + "px";
      _this._loadingDiv.style.width = canvasRect.width + "px";
      _this._loadingDiv.style.height = canvasRect.height + "px";
    };
  }
  DefaultLoadingScreen2.prototype.displayLoadingUI = function() {
    if (this._loadingDiv) {
      return;
    }
    this._loadingDiv = document.createElement("div");
    this._loadingDiv.id = "babylonjsLoadingDiv";
    this._loadingDiv.style.opacity = "0";
    this._loadingDiv.style.transition = "opacity 1.5s ease";
    this._loadingDiv.style.pointerEvents = "none";
    this._loadingDiv.style.display = "grid";
    this._loadingDiv.style.gridTemplateRows = "100%";
    this._loadingDiv.style.gridTemplateColumns = "100%";
    this._loadingDiv.style.justifyItems = "center";
    this._loadingDiv.style.alignItems = "center";
    this._loadingTextDiv = document.createElement("div");
    this._loadingTextDiv.style.position = "absolute";
    this._loadingTextDiv.style.left = "0";
    this._loadingTextDiv.style.top = "50%";
    this._loadingTextDiv.style.marginTop = "80px";
    this._loadingTextDiv.style.width = "100%";
    this._loadingTextDiv.style.height = "20px";
    this._loadingTextDiv.style.fontFamily = "Arial";
    this._loadingTextDiv.style.fontSize = "14px";
    this._loadingTextDiv.style.color = "white";
    this._loadingTextDiv.style.textAlign = "center";
    this._loadingTextDiv.style.zIndex = "1";
    this._loadingTextDiv.innerHTML = "Loading";
    this._loadingDiv.appendChild(this._loadingTextDiv);
    this._loadingTextDiv.innerHTML = this._loadingText;
    var style = document.createElement("style");
    style.type = "text/css";
    var keyFrames = "@-webkit-keyframes spin1 {                    0% { -webkit-transform: rotate(0deg);}\n                    100% { -webkit-transform: rotate(360deg);}\n                }                @keyframes spin1 {                    0% { transform: rotate(0deg);}\n                    100% { transform: rotate(360deg);}\n                }";
    style.innerHTML = keyFrames;
    document.getElementsByTagName("head")[0].appendChild(style);
    var svgSupport = !!window.SVGSVGElement;
    var imgBack = new Image();
    if (!DefaultLoadingScreen2.DefaultLogoUrl) {
      imgBack.src = !svgSupport ? "https://cdn.babylonjs.com/Assets/babylonLogo.png" : "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxODAuMTcgMjA4LjA0Ij48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2ZmZjt9LmNscy0ye2ZpbGw6I2UwNjg0Yjt9LmNscy0ze2ZpbGw6I2JiNDY0Yjt9LmNscy00e2ZpbGw6I2UwZGVkODt9LmNscy01e2ZpbGw6I2Q1ZDJjYTt9PC9zdHlsZT48L2RlZnM+PHRpdGxlPkJhYnlsb25Mb2dvPC90aXRsZT48ZyBpZD0iTGF5ZXJfMiIgZGF0YS1uYW1lPSJMYXllciAyIj48ZyBpZD0iUGFnZV9FbGVtZW50cyIgZGF0YS1uYW1lPSJQYWdlIEVsZW1lbnRzIj48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik05MC4wOSwwLDAsNTJWMTU2bDkwLjA5LDUyLDkwLjA4LTUyVjUyWiIvPjxwb2x5Z29uIGNsYXNzPSJjbHMtMiIgcG9pbnRzPSIxODAuMTcgNTIuMDEgMTUxLjk3IDM1LjczIDEyNC44NSA1MS4zOSAxNTMuMDUgNjcuNjcgMTgwLjE3IDUyLjAxIi8+PHBvbHlnb24gY2xhc3M9ImNscy0yIiBwb2ludHM9IjI3LjEyIDY3LjY3IDExNy4yMSAxNS42NiA5MC4wOCAwIDAgNTIuMDEgMjcuMTIgNjcuNjciLz48cG9seWdvbiBjbGFzcz0iY2xzLTIiIHBvaW50cz0iNjEuODkgMTIwLjMgOTAuMDggMTM2LjU4IDExOC4yOCAxMjAuMyA5MC4wOCAxMDQuMDIgNjEuODkgMTIwLjMiLz48cG9seWdvbiBjbGFzcz0iY2xzLTMiIHBvaW50cz0iMTUzLjA1IDY3LjY3IDE1My4wNSAxNDAuMzcgOTAuMDggMTc2LjcyIDI3LjEyIDE0MC4zNyAyNy4xMiA2Ny42NyAwIDUyLjAxIDAgMTU2LjAzIDkwLjA4IDIwOC4wNCAxODAuMTcgMTU2LjAzIDE4MC4xNyA1Mi4wMSAxNTMuMDUgNjcuNjciLz48cG9seWdvbiBjbGFzcz0iY2xzLTMiIHBvaW50cz0iOTAuMDggNzEuNDYgNjEuODkgODcuNzQgNjEuODkgMTIwLjMgOTAuMDggMTA0LjAyIDExOC4yOCAxMjAuMyAxMTguMjggODcuNzQgOTAuMDggNzEuNDYiLz48cG9seWdvbiBjbGFzcz0iY2xzLTQiIHBvaW50cz0iMTUzLjA1IDY3LjY3IDExOC4yOCA4Ny43NCAxMTguMjggMTIwLjMgOTAuMDggMTM2LjU4IDkwLjA4IDE3Ni43MiAxNTMuMDUgMTQwLjM3IDE1My4wNSA2Ny42NyIvPjxwb2x5Z29uIGNsYXNzPSJjbHMtNSIgcG9pbnRzPSIyNy4xMiA2Ny42NyA2MS44OSA4Ny43NCA2MS44OSAxMjAuMyA5MC4wOCAxMzYuNTggOTAuMDggMTc2LjcyIDI3LjEyIDE0MC4zNyAyNy4xMiA2Ny42NyIvPjwvZz48L2c+PC9zdmc+";
    } else {
      imgBack.src = DefaultLoadingScreen2.DefaultLogoUrl;
    }
    imgBack.style.width = "150px";
    imgBack.style.gridColumn = "1";
    imgBack.style.gridRow = "1";
    imgBack.style.top = "50%";
    imgBack.style.left = "50%";
    imgBack.style.transform = "translate(-50%, -50%)";
    imgBack.style.position = "absolute";
    var imageSpinnerContainer = document.createElement("div");
    imageSpinnerContainer.style.width = "300px";
    imageSpinnerContainer.style.gridColumn = "1";
    imageSpinnerContainer.style.gridRow = "1";
    imageSpinnerContainer.style.top = "50%";
    imageSpinnerContainer.style.left = "50%";
    imageSpinnerContainer.style.transform = "translate(-50%, -50%)";
    imageSpinnerContainer.style.position = "absolute";
    var imgSpinner = new Image();
    if (!DefaultLoadingScreen2.DefaultSpinnerUrl) {
      imgSpinner.src = !svgSupport ? "https://cdn.babylonjs.com/Assets/loadingIcon.png" : "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzOTIgMzkyIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2UwNjg0Yjt9LmNscy0ye2ZpbGw6bm9uZTt9PC9zdHlsZT48L2RlZnM+PHRpdGxlPlNwaW5uZXJJY29uPC90aXRsZT48ZyBpZD0iTGF5ZXJfMiIgZGF0YS1uYW1lPSJMYXllciAyIj48ZyBpZD0iU3Bpbm5lciI+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNNDAuMjEsMTI2LjQzYzMuNy03LjMxLDcuNjctMTQuNDQsMTItMjEuMzJsMy4zNi01LjEsMy41Mi01YzEuMjMtMS42MywyLjQxLTMuMjksMy42NS00LjkxczIuNTMtMy4yMSwzLjgyLTQuNzlBMTg1LjIsMTg1LjIsMCwwLDEsODMuNCw2Ny40M2EyMDgsMjA4LDAsMCwxLDE5LTE1LjY2YzMuMzUtMi40MSw2Ljc0LTQuNzgsMTAuMjUtN3M3LjExLTQuMjgsMTAuNzUtNi4zMmM3LjI5LTQsMTQuNzMtOCwyMi41My0xMS40OSwzLjktMS43Miw3Ljg4LTMuMywxMi00LjY0YTEwNC4yMiwxMDQuMjIsMCwwLDEsMTIuNDQtMy4yMyw2Mi40NCw2Mi40NCwwLDAsMSwxMi43OC0xLjM5QTI1LjkyLDI1LjkyLDAsMCwxLDE5NiwyMS40NGE2LjU1LDYuNTUsMCwwLDEsMi4wNSw5LDYuNjYsNi42NiwwLDAsMS0xLjY0LDEuNzhsLS40MS4yOWEyMi4wNywyMi4wNywwLDAsMS01Ljc4LDMsMzAuNDIsMzAuNDIsMCwwLDEtNS42NywxLjYyLDM3LjgyLDM3LjgyLDAsMCwxLTUuNjkuNzFjLTEsMC0xLjkuMTgtMi44NS4yNmwtMi44NS4yNHEtNS43Mi41MS0xMS40OCwxLjFjLTMuODQuNC03LjcxLjgyLTExLjU4LDEuNGExMTIuMzQsMTEyLjM0LDAsMCwwLTIyLjk0LDUuNjFjLTMuNzIsMS4zNS03LjM0LDMtMTAuOTQsNC42NHMtNy4xNCwzLjUxLTEwLjYsNS41MUExNTEuNiwxNTEuNiwwLDAsMCw2OC41Niw4N0M2Ny4yMyw4OC40OCw2Niw5MCw2NC42NCw5MS41NnMtMi41MSwzLjE1LTMuNzUsNC43M2wtMy41NCw0LjljLTEuMTMsMS42Ni0yLjIzLDMuMzUtMy4zMyw1YTEyNywxMjcsMCwwLDAtMTAuOTMsMjEuNDksMS41OCwxLjU4LDAsMSwxLTMtMS4xNVM0MC4xOSwxMjYuNDcsNDAuMjEsMTI2LjQzWiIvPjxyZWN0IGNsYXNzPSJjbHMtMiIgd2lkdGg9IjM5MiIgaGVpZ2h0PSIzOTIiLz48L2c+PC9nPjwvc3ZnPg==";
    } else {
      imgSpinner.src = DefaultLoadingScreen2.DefaultSpinnerUrl;
    }
    imgSpinner.style.animation = "spin1 0.75s infinite linear";
    imgSpinner.style.webkitAnimation = "spin1 0.75s infinite linear";
    imgSpinner.style.transformOrigin = "50% 50%";
    imgSpinner.style.webkitTransformOrigin = "50% 50%";
    if (!svgSupport) {
      var logoSize = { w: 16, h: 18.5 };
      var loadingSize = { w: 30, h: 30 };
      imgBack.style.width = logoSize.w + "vh";
      imgBack.style.height = logoSize.h + "vh";
      imgBack.style.left = "calc(50% - " + logoSize.w / 2 + "vh)";
      imgBack.style.top = "calc(50% - " + logoSize.h / 2 + "vh)";
      imgSpinner.style.width = loadingSize.w + "vh";
      imgSpinner.style.height = loadingSize.h + "vh";
      imgSpinner.style.left = "calc(50% - " + loadingSize.w / 2 + "vh)";
      imgSpinner.style.top = "calc(50% - " + loadingSize.h / 2 + "vh)";
    }
    imageSpinnerContainer.appendChild(imgSpinner);
    this._loadingDiv.appendChild(imgBack);
    this._loadingDiv.appendChild(imageSpinnerContainer);
    this._resizeLoadingUI();
    window.addEventListener("resize", this._resizeLoadingUI);
    this._loadingDiv.style.backgroundColor = this._loadingDivBackgroundColor;
    document.body.appendChild(this._loadingDiv);
    this._loadingDiv.style.opacity = "1";
  };
  DefaultLoadingScreen2.prototype.hideLoadingUI = function() {
    var _this = this;
    if (!this._loadingDiv) {
      return;
    }
    var onTransitionEnd = function() {
      if (!_this._loadingDiv) {
        return;
      }
      if (_this._loadingDiv.parentElement) {
        _this._loadingDiv.parentElement.removeChild(_this._loadingDiv);
      }
      window.removeEventListener("resize", _this._resizeLoadingUI);
      _this._loadingDiv = null;
    };
    this._loadingDiv.style.opacity = "0";
    this._loadingDiv.addEventListener("transitionend", onTransitionEnd);
  };
  Object.defineProperty(DefaultLoadingScreen2.prototype, "loadingUIText", {
    get: function() {
      return this._loadingText;
    },
    set: function(text) {
      this._loadingText = text;
      if (this._loadingTextDiv) {
        this._loadingTextDiv.innerHTML = this._loadingText;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DefaultLoadingScreen2.prototype, "loadingUIBackgroundColor", {
    get: function() {
      return this._loadingDivBackgroundColor;
    },
    set: function(color) {
      this._loadingDivBackgroundColor = color;
      if (!this._loadingDiv) {
        return;
      }
      this._loadingDiv.style.backgroundColor = this._loadingDivBackgroundColor;
    },
    enumerable: false,
    configurable: true
  });
  DefaultLoadingScreen2.DefaultLogoUrl = "";
  DefaultLoadingScreen2.DefaultSpinnerUrl = "";
  return DefaultLoadingScreen2;
}();
Engine.DefaultLoadingScreenFactory = function(canvas) {
  return new DefaultLoadingScreen(canvas);
};

// node_modules/@babylonjs/core/Misc/HighDynamicRange/panoramaToCubemap.js
var PanoramaToCubeMapTools = function() {
  function PanoramaToCubeMapTools2() {
  }
  PanoramaToCubeMapTools2.ConvertPanoramaToCubemap = function(float32Array, inputWidth, inputHeight, size) {
    if (!float32Array) {
      throw "ConvertPanoramaToCubemap: input cannot be null";
    }
    if (float32Array.length != inputWidth * inputHeight * 3) {
      throw "ConvertPanoramaToCubemap: input size is wrong";
    }
    var textureFront = this.CreateCubemapTexture(size, this.FACE_FRONT, float32Array, inputWidth, inputHeight);
    var textureBack = this.CreateCubemapTexture(size, this.FACE_BACK, float32Array, inputWidth, inputHeight);
    var textureLeft = this.CreateCubemapTexture(size, this.FACE_LEFT, float32Array, inputWidth, inputHeight);
    var textureRight = this.CreateCubemapTexture(size, this.FACE_RIGHT, float32Array, inputWidth, inputHeight);
    var textureUp = this.CreateCubemapTexture(size, this.FACE_UP, float32Array, inputWidth, inputHeight);
    var textureDown = this.CreateCubemapTexture(size, this.FACE_DOWN, float32Array, inputWidth, inputHeight);
    return {
      front: textureFront,
      back: textureBack,
      left: textureLeft,
      right: textureRight,
      up: textureUp,
      down: textureDown,
      size,
      type: 1,
      format: 4,
      gammaSpace: false
    };
  };
  PanoramaToCubeMapTools2.CreateCubemapTexture = function(texSize, faceData, float32Array, inputWidth, inputHeight) {
    var buffer = new ArrayBuffer(texSize * texSize * 4 * 3);
    var textureArray = new Float32Array(buffer);
    var rotDX1 = faceData[1].subtract(faceData[0]).scale(1 / texSize);
    var rotDX2 = faceData[3].subtract(faceData[2]).scale(1 / texSize);
    var dy = 1 / texSize;
    var fy = 0;
    for (var y = 0; y < texSize; y++) {
      var xv1 = faceData[0];
      var xv2 = faceData[2];
      for (var x = 0; x < texSize; x++) {
        var v = xv2.subtract(xv1).scale(fy).add(xv1);
        v.normalize();
        var color = this.CalcProjectionSpherical(v, float32Array, inputWidth, inputHeight);
        textureArray[y * texSize * 3 + x * 3 + 0] = color.r;
        textureArray[y * texSize * 3 + x * 3 + 1] = color.g;
        textureArray[y * texSize * 3 + x * 3 + 2] = color.b;
        xv1 = xv1.add(rotDX1);
        xv2 = xv2.add(rotDX2);
      }
      fy += dy;
    }
    return textureArray;
  };
  PanoramaToCubeMapTools2.CalcProjectionSpherical = function(vDir, float32Array, inputWidth, inputHeight) {
    var theta = Math.atan2(vDir.z, vDir.x);
    var phi = Math.acos(vDir.y);
    while (theta < -Math.PI) {
      theta += 2 * Math.PI;
    }
    while (theta > Math.PI) {
      theta -= 2 * Math.PI;
    }
    var dx = theta / Math.PI;
    var dy = phi / Math.PI;
    dx = dx * 0.5 + 0.5;
    var px = Math.round(dx * inputWidth);
    if (px < 0) {
      px = 0;
    } else if (px >= inputWidth) {
      px = inputWidth - 1;
    }
    var py = Math.round(dy * inputHeight);
    if (py < 0) {
      py = 0;
    } else if (py >= inputHeight) {
      py = inputHeight - 1;
    }
    var inputY = inputHeight - py - 1;
    var r = float32Array[inputY * inputWidth * 3 + px * 3 + 0];
    var g = float32Array[inputY * inputWidth * 3 + px * 3 + 1];
    var b = float32Array[inputY * inputWidth * 3 + px * 3 + 2];
    return {
      r,
      g,
      b
    };
  };
  PanoramaToCubeMapTools2.FACE_LEFT = [
    new Vector3(-1, -1, -1),
    new Vector3(1, -1, -1),
    new Vector3(-1, 1, -1),
    new Vector3(1, 1, -1)
  ];
  PanoramaToCubeMapTools2.FACE_RIGHT = [
    new Vector3(1, -1, 1),
    new Vector3(-1, -1, 1),
    new Vector3(1, 1, 1),
    new Vector3(-1, 1, 1)
  ];
  PanoramaToCubeMapTools2.FACE_FRONT = [
    new Vector3(1, -1, -1),
    new Vector3(1, -1, 1),
    new Vector3(1, 1, -1),
    new Vector3(1, 1, 1)
  ];
  PanoramaToCubeMapTools2.FACE_BACK = [
    new Vector3(-1, -1, 1),
    new Vector3(-1, -1, -1),
    new Vector3(-1, 1, 1),
    new Vector3(-1, 1, -1)
  ];
  PanoramaToCubeMapTools2.FACE_DOWN = [
    new Vector3(1, 1, -1),
    new Vector3(1, 1, 1),
    new Vector3(-1, 1, -1),
    new Vector3(-1, 1, 1)
  ];
  PanoramaToCubeMapTools2.FACE_UP = [
    new Vector3(-1, -1, -1),
    new Vector3(-1, -1, 1),
    new Vector3(1, -1, -1),
    new Vector3(1, -1, 1)
  ];
  return PanoramaToCubeMapTools2;
}();

// node_modules/@babylonjs/core/Misc/HighDynamicRange/hdr.js
var HDRTools = function() {
  function HDRTools2() {
  }
  HDRTools2.Ldexp = function(mantissa, exponent) {
    if (exponent > 1023) {
      return mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023);
    }
    if (exponent < -1074) {
      return mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074);
    }
    return mantissa * Math.pow(2, exponent);
  };
  HDRTools2.Rgbe2float = function(float32array, red, green, blue, exponent, index) {
    if (exponent > 0) {
      exponent = this.Ldexp(1, exponent - (128 + 8));
      float32array[index + 0] = red * exponent;
      float32array[index + 1] = green * exponent;
      float32array[index + 2] = blue * exponent;
    } else {
      float32array[index + 0] = 0;
      float32array[index + 1] = 0;
      float32array[index + 2] = 0;
    }
  };
  HDRTools2.readStringLine = function(uint8array, startIndex) {
    var line = "";
    var character = "";
    for (var i = startIndex; i < uint8array.length - startIndex; i++) {
      character = String.fromCharCode(uint8array[i]);
      if (character == "\n") {
        break;
      }
      line += character;
    }
    return line;
  };
  HDRTools2.RGBE_ReadHeader = function(uint8array) {
    var height = 0;
    var width = 0;
    var line = this.readStringLine(uint8array, 0);
    if (line[0] != "#" || line[1] != "?") {
      throw "Bad HDR Format.";
    }
    var endOfHeader = false;
    var findFormat = false;
    var lineIndex = 0;
    do {
      lineIndex += line.length + 1;
      line = this.readStringLine(uint8array, lineIndex);
      if (line == "FORMAT=32-bit_rle_rgbe") {
        findFormat = true;
      } else if (line.length == 0) {
        endOfHeader = true;
      }
    } while (!endOfHeader);
    if (!findFormat) {
      throw "HDR Bad header format, unsupported FORMAT";
    }
    lineIndex += line.length + 1;
    line = this.readStringLine(uint8array, lineIndex);
    var sizeRegexp = /^\-Y (.*) \+X (.*)$/g;
    var match = sizeRegexp.exec(line);
    if (!match || match.length < 3) {
      throw "HDR Bad header format, no size";
    }
    width = parseInt(match[2]);
    height = parseInt(match[1]);
    if (width < 8 || width > 32767) {
      throw "HDR Bad header format, unsupported size";
    }
    lineIndex += line.length + 1;
    return {
      height,
      width,
      dataPosition: lineIndex
    };
  };
  HDRTools2.GetCubeMapTextureData = function(buffer, size) {
    var uint8array = new Uint8Array(buffer);
    var hdrInfo = this.RGBE_ReadHeader(uint8array);
    var data = this.RGBE_ReadPixels(uint8array, hdrInfo);
    var cubeMapData = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(data, hdrInfo.width, hdrInfo.height, size);
    return cubeMapData;
  };
  HDRTools2.RGBE_ReadPixels = function(uint8array, hdrInfo) {
    return this.RGBE_ReadPixels_RLE(uint8array, hdrInfo);
  };
  HDRTools2.RGBE_ReadPixels_RLE = function(uint8array, hdrInfo) {
    var num_scanlines = hdrInfo.height;
    var scanline_width = hdrInfo.width;
    var a, b, c, d, count;
    var dataIndex = hdrInfo.dataPosition;
    var index = 0, endIndex = 0, i = 0;
    var scanLineArrayBuffer = new ArrayBuffer(scanline_width * 4);
    var scanLineArray = new Uint8Array(scanLineArrayBuffer);
    var resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);
    var resultArray = new Float32Array(resultBuffer);
    while (num_scanlines > 0) {
      a = uint8array[dataIndex++];
      b = uint8array[dataIndex++];
      c = uint8array[dataIndex++];
      d = uint8array[dataIndex++];
      if (a != 2 || b != 2 || c & 128 || hdrInfo.width < 8 || hdrInfo.width > 32767) {
        return this.RGBE_ReadPixels_NOT_RLE(uint8array, hdrInfo);
      }
      if ((c << 8 | d) != scanline_width) {
        throw "HDR Bad header format, wrong scan line width";
      }
      index = 0;
      for (i = 0; i < 4; i++) {
        endIndex = (i + 1) * scanline_width;
        while (index < endIndex) {
          a = uint8array[dataIndex++];
          b = uint8array[dataIndex++];
          if (a > 128) {
            count = a - 128;
            if (count == 0 || count > endIndex - index) {
              throw "HDR Bad Format, bad scanline data (run)";
            }
            while (count-- > 0) {
              scanLineArray[index++] = b;
            }
          } else {
            count = a;
            if (count == 0 || count > endIndex - index) {
              throw "HDR Bad Format, bad scanline data (non-run)";
            }
            scanLineArray[index++] = b;
            if (--count > 0) {
              for (var j = 0; j < count; j++) {
                scanLineArray[index++] = uint8array[dataIndex++];
              }
            }
          }
        }
      }
      for (i = 0; i < scanline_width; i++) {
        a = scanLineArray[i];
        b = scanLineArray[i + scanline_width];
        c = scanLineArray[i + 2 * scanline_width];
        d = scanLineArray[i + 3 * scanline_width];
        this.Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);
      }
      num_scanlines--;
    }
    return resultArray;
  };
  HDRTools2.RGBE_ReadPixels_NOT_RLE = function(uint8array, hdrInfo) {
    var num_scanlines = hdrInfo.height;
    var scanline_width = hdrInfo.width;
    var a, b, c, d, i;
    var dataIndex = hdrInfo.dataPosition;
    var resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);
    var resultArray = new Float32Array(resultBuffer);
    while (num_scanlines > 0) {
      for (i = 0; i < hdrInfo.width; i++) {
        a = uint8array[dataIndex++];
        b = uint8array[dataIndex++];
        c = uint8array[dataIndex++];
        d = uint8array[dataIndex++];
        this.Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);
      }
      num_scanlines--;
    }
    return resultArray;
  };
  return HDRTools2;
}();

// node_modules/@babylonjs/core/Materials/effectRenderer.js
var EffectRenderer = function() {
  function EffectRenderer2(engine, options) {
    var _a;
    if (options === void 0) {
      options = EffectRenderer2._DefaultOptions;
    }
    this.engine = engine;
    this._fullscreenViewport = new Viewport(0, 0, 1, 1);
    options = __assign(__assign({}, EffectRenderer2._DefaultOptions), options);
    this._vertexBuffers = (_a = {}, _a[VertexBuffer.PositionKind] = new VertexBuffer(engine, options.positions, VertexBuffer.PositionKind, false, false, 2), _a);
    this._indexBuffer = engine.createIndexBuffer(options.indices);
  }
  EffectRenderer2.prototype.setViewport = function(viewport) {
    if (viewport === void 0) {
      viewport = this._fullscreenViewport;
    }
    this.engine.setViewport(viewport);
  };
  EffectRenderer2.prototype.bindBuffers = function(effect) {
    this.engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
  };
  EffectRenderer2.prototype.applyEffectWrapper = function(effectWrapper) {
    this.engine.depthCullingState.depthTest = false;
    this.engine.stencilState.stencilTest = false;
    this.engine.enableEffect(effectWrapper.effect);
    this.bindBuffers(effectWrapper.effect);
    effectWrapper.onApplyObservable.notifyObservers({});
  };
  EffectRenderer2.prototype.restoreStates = function() {
    this.engine.depthCullingState.depthTest = true;
    this.engine.stencilState.stencilTest = true;
  };
  EffectRenderer2.prototype.draw = function() {
    this.engine.drawElementsType(0, 0, 6);
  };
  EffectRenderer2.prototype.isRenderTargetTexture = function(texture) {
    return texture.renderList !== void 0;
  };
  EffectRenderer2.prototype.render = function(effectWrapper, outputTexture) {
    if (outputTexture === void 0) {
      outputTexture = null;
    }
    if (!effectWrapper.effect.isReady()) {
      return;
    }
    this.setViewport();
    var out = outputTexture === null ? null : this.isRenderTargetTexture(outputTexture) ? outputTexture.getInternalTexture() : outputTexture;
    if (out) {
      this.engine.bindFramebuffer(out);
    }
    this.applyEffectWrapper(effectWrapper);
    this.draw();
    if (out) {
      this.engine.unBindFramebuffer(out);
    }
    this.restoreStates();
  };
  EffectRenderer2.prototype.dispose = function() {
    var vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vertexBuffer) {
      vertexBuffer.dispose();
      delete this._vertexBuffers[VertexBuffer.PositionKind];
    }
    if (this._indexBuffer) {
      this.engine._releaseBuffer(this._indexBuffer);
    }
  };
  EffectRenderer2._DefaultOptions = {
    positions: [1, 1, -1, 1, -1, -1, 1, -1],
    indices: [0, 1, 2, 0, 2, 3]
  };
  return EffectRenderer2;
}();
var EffectWrapper = function() {
  function EffectWrapper2(creationOptions) {
    var _this = this;
    this.onApplyObservable = new Observable();
    var effectCreationOptions;
    var uniformNames = creationOptions.uniformNames || [];
    if (creationOptions.vertexShader) {
      effectCreationOptions = {
        fragmentSource: creationOptions.fragmentShader,
        vertexSource: creationOptions.vertexShader,
        spectorName: creationOptions.name || "effectWrapper"
      };
    } else {
      uniformNames.push("scale");
      effectCreationOptions = {
        fragmentSource: creationOptions.fragmentShader,
        vertex: "postprocess",
        spectorName: creationOptions.name || "effectWrapper"
      };
      this.onApplyObservable.add(function() {
        _this.effect.setFloat2("scale", 1, 1);
      });
    }
    var defines = creationOptions.defines ? creationOptions.defines.join("\n") : "";
    if (creationOptions.useShaderStore) {
      effectCreationOptions.fragment = effectCreationOptions.fragmentSource;
      if (!effectCreationOptions.vertex) {
        effectCreationOptions.vertex = effectCreationOptions.vertexSource;
      }
      delete effectCreationOptions.fragmentSource;
      delete effectCreationOptions.vertexSource;
      this.effect = creationOptions.engine.createEffect(effectCreationOptions.spectorName, creationOptions.attributeNames || ["position"], uniformNames, creationOptions.samplerNames, defines, void 0, creationOptions.onCompiled);
    } else {
      this.effect = new Effect(effectCreationOptions, creationOptions.attributeNames || ["position"], uniformNames, creationOptions.samplerNames, creationOptions.engine, defines, void 0, creationOptions.onCompiled);
    }
  }
  EffectWrapper2.prototype.dispose = function() {
    this.effect.dispose();
  };
  return EffectWrapper2;
}();

// node_modules/@babylonjs/core/Shaders/hdrFiltering.vertex.js
var name41 = "hdrFilteringVertexShader";
var shader41 = "\nattribute vec2 position;\n\nvarying vec3 direction;\n\nuniform vec3 up;\nuniform vec3 right;\nuniform vec3 front;\nvoid main(void) {\nmat3 view=mat3(up,right,front);\ndirection=view*vec3(position,1.0);\ngl_Position=vec4(position,0.0,1.0);\n}";
Effect.ShadersStore[name41] = shader41;

// node_modules/@babylonjs/core/Shaders/hdrFiltering.fragment.js
var name42 = "hdrFilteringPixelShader";
var shader42 = "#include<helperFunctions>\n#include<importanceSampling>\n#include<pbrBRDFFunctions>\n#include<hdrFilteringFunctions>\nuniform float alphaG;\nuniform samplerCube inputTexture;\nuniform vec2 vFilteringInfo;\nuniform float hdrScale;\nvarying vec3 direction;\nvoid main() {\nvec3 color=radiance(alphaG,inputTexture,direction,vFilteringInfo);\ngl_FragColor=vec4(color*hdrScale,1.0);\n}";
Effect.ShadersStore[name42] = shader42;

// node_modules/@babylonjs/core/Materials/Textures/Filtering/hdrFiltering.js
var HDRFiltering = function() {
  function HDRFiltering2(engine, options) {
    if (options === void 0) {
      options = {};
    }
    this._lodGenerationOffset = 0;
    this._lodGenerationScale = 0.8;
    this.quality = 4096;
    this.hdrScale = 1;
    this._engine = engine;
    this.hdrScale = options.hdrScale || this.hdrScale;
    this.quality = options.hdrScale || this.quality;
  }
  HDRFiltering2.prototype._createRenderTarget = function(size) {
    var textureType = 0;
    if (this._engine.getCaps().textureHalfFloatRender) {
      textureType = 2;
    } else if (this._engine.getCaps().textureFloatRender) {
      textureType = 1;
    }
    var texture = this._engine.createRenderTargetCubeTexture(size, {
      format: 5,
      type: textureType,
      generateMipMaps: false,
      generateDepthBuffer: false,
      generateStencilBuffer: false,
      samplingMode: 1
    });
    this._engine.updateTextureWrappingMode(texture, 0, 0, 0);
    this._engine.updateTextureSamplingMode(3, texture, true);
    return texture;
  };
  HDRFiltering2.prototype._prefilterInternal = function(texture) {
    var width = texture.getSize().width;
    var mipmapsCount = Math.round(Scalar.Log2(width)) + 1;
    var effect = this._effectWrapper.effect;
    var outputTexture = this._createRenderTarget(width);
    this._effectRenderer.setViewport();
    var intTexture = texture.getInternalTexture();
    if (intTexture) {
      this._engine.updateTextureSamplingMode(3, intTexture, true);
    }
    this._effectRenderer.applyEffectWrapper(this._effectWrapper);
    var directions = [
      [new Vector3(0, 0, -1), new Vector3(0, -1, 0), new Vector3(1, 0, 0)],
      [new Vector3(0, 0, 1), new Vector3(0, -1, 0), new Vector3(-1, 0, 0)],
      [new Vector3(1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 1, 0)],
      [new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)],
      [new Vector3(1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, 1)],
      [new Vector3(-1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, -1)]
    ];
    effect.setFloat("hdrScale", this.hdrScale);
    effect.setFloat2("vFilteringInfo", texture.getSize().width, mipmapsCount);
    effect.setTexture("inputTexture", texture);
    for (var face = 0; face < 6; face++) {
      effect.setVector3("up", directions[face][0]);
      effect.setVector3("right", directions[face][1]);
      effect.setVector3("front", directions[face][2]);
      for (var lod = 0; lod < mipmapsCount; lod++) {
        this._engine.bindFramebuffer(outputTexture, face, void 0, void 0, true, lod);
        this._effectRenderer.applyEffectWrapper(this._effectWrapper);
        var alpha = Math.pow(2, (lod - this._lodGenerationOffset) / this._lodGenerationScale) / width;
        if (lod === 0) {
          alpha = 0;
        }
        effect.setFloat("alphaG", alpha);
        this._effectRenderer.draw();
      }
    }
    this._effectRenderer.restoreStates();
    this._engine.restoreDefaultFramebuffer();
    this._engine._releaseFramebufferObjects(outputTexture);
    this._engine._releaseTexture(texture._texture);
    outputTexture._swapAndDie(texture._texture);
    texture._prefiltered = true;
    return texture;
  };
  HDRFiltering2.prototype._createEffect = function(texture, onCompiled) {
    var defines = [];
    if (texture.gammaSpace) {
      defines.push("#define GAMMA_INPUT");
    }
    defines.push("#define NUM_SAMPLES " + this.quality + "u");
    var effectWrapper = new EffectWrapper({
      engine: this._engine,
      name: "hdrFiltering",
      vertexShader: "hdrFiltering",
      fragmentShader: "hdrFiltering",
      samplerNames: ["inputTexture"],
      uniformNames: ["vSampleDirections", "vWeights", "up", "right", "front", "vFilteringInfo", "hdrScale", "alphaG"],
      useShaderStore: true,
      defines,
      onCompiled
    });
    return effectWrapper;
  };
  HDRFiltering2.prototype.isReady = function(texture) {
    return texture.isReady() && this._effectWrapper.effect.isReady();
  };
  HDRFiltering2.prototype.prefilter = function(texture, onFinished) {
    var _this = this;
    if (onFinished === void 0) {
      onFinished = null;
    }
    if (this._engine.webGLVersion === 1) {
      Logger.Warn("HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.");
      return;
    }
    return new Promise(function(resolve) {
      _this._effectRenderer = new EffectRenderer(_this._engine);
      _this._effectWrapper = _this._createEffect(texture);
      _this._effectWrapper.effect.executeWhenCompiled(function() {
        _this._prefilterInternal(texture);
        _this._effectRenderer.dispose();
        _this._effectWrapper.dispose();
        resolve();
        if (onFinished) {
          onFinished();
        }
      });
    });
  };
  return HDRFiltering2;
}();

// node_modules/@babylonjs/core/Materials/Textures/hdrCubeTexture.js
var HDRCubeTexture = function(_super) {
  __extends(HDRCubeTexture2, _super);
  function HDRCubeTexture2(url, sceneOrEngine, size, noMipmap, generateHarmonics, gammaSpace, prefilterOnLoad, onLoad, onError) {
    if (noMipmap === void 0) {
      noMipmap = false;
    }
    if (generateHarmonics === void 0) {
      generateHarmonics = true;
    }
    if (gammaSpace === void 0) {
      gammaSpace = false;
    }
    if (prefilterOnLoad === void 0) {
      prefilterOnLoad = false;
    }
    if (onLoad === void 0) {
      onLoad = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    var _a;
    var _this = _super.call(this, sceneOrEngine) || this;
    _this._generateHarmonics = true;
    _this._onLoad = null;
    _this._onError = null;
    _this._isBlocking = true;
    _this._rotationY = 0;
    _this.boundingBoxPosition = Vector3.Zero();
    if (!url) {
      return _this;
    }
    _this._coordinatesMode = Texture.CUBIC_MODE;
    _this.name = url;
    _this.url = url;
    _this.hasAlpha = false;
    _this.isCube = true;
    _this._textureMatrix = Matrix.Identity();
    _this._prefilterOnLoad = prefilterOnLoad;
    _this._onLoad = onLoad;
    _this._onError = onError;
    _this.gammaSpace = gammaSpace;
    _this._noMipmap = noMipmap;
    _this._size = size;
    _this._generateHarmonics = generateHarmonics;
    _this._texture = _this._getFromCache(url, _this._noMipmap);
    if (!_this._texture) {
      if (!((_a = _this.getScene()) === null || _a === void 0 ? void 0 : _a.useDelayedTextureLoading)) {
        _this.loadTexture();
      } else {
        _this.delayLoadState = 4;
      }
    } else if (onLoad) {
      if (_this._texture.isReady) {
        Tools.SetImmediate(function() {
          return onLoad();
        });
      } else {
        _this._texture.onLoadedObservable.add(onLoad);
      }
    }
    return _this;
  }
  Object.defineProperty(HDRCubeTexture2.prototype, "isBlocking", {
    get: function() {
      return this._isBlocking;
    },
    set: function(value) {
      this._isBlocking = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(HDRCubeTexture2.prototype, "rotationY", {
    get: function() {
      return this._rotationY;
    },
    set: function(value) {
      this._rotationY = value;
      this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(HDRCubeTexture2.prototype, "boundingBoxSize", {
    get: function() {
      return this._boundingBoxSize;
    },
    set: function(value) {
      if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {
        return;
      }
      this._boundingBoxSize = value;
      var scene = this.getScene();
      if (scene) {
        scene.markAllMaterialsAsDirty(1);
      }
    },
    enumerable: false,
    configurable: true
  });
  HDRCubeTexture2.prototype.getClassName = function() {
    return "HDRCubeTexture";
  };
  HDRCubeTexture2.prototype.loadTexture = function() {
    var _this = this;
    var engine = this._getEngine();
    var callback = function(buffer) {
      _this.lodGenerationOffset = 0;
      _this.lodGenerationScale = 0.8;
      var data = HDRTools.GetCubeMapTextureData(buffer, _this._size);
      if (_this._generateHarmonics) {
        var sphericalPolynomial = CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial(data);
        _this.sphericalPolynomial = sphericalPolynomial;
      }
      var results = [];
      var byteArray = null;
      for (var j = 0; j < 6; j++) {
        if (!engine.getCaps().textureFloat) {
          var byteBuffer = new ArrayBuffer(_this._size * _this._size * 3);
          byteArray = new Uint8Array(byteBuffer);
        }
        var dataFace = data[HDRCubeTexture2._facesMapping[j]];
        if (_this.gammaSpace || byteArray) {
          for (var i = 0; i < _this._size * _this._size; i++) {
            if (_this.gammaSpace) {
              dataFace[i * 3 + 0] = Math.pow(dataFace[i * 3 + 0], ToGammaSpace);
              dataFace[i * 3 + 1] = Math.pow(dataFace[i * 3 + 1], ToGammaSpace);
              dataFace[i * 3 + 2] = Math.pow(dataFace[i * 3 + 2], ToGammaSpace);
            }
            if (byteArray) {
              var r = Math.max(dataFace[i * 3 + 0] * 255, 0);
              var g = Math.max(dataFace[i * 3 + 1] * 255, 0);
              var b = Math.max(dataFace[i * 3 + 2] * 255, 0);
              var max = Math.max(Math.max(r, g), b);
              if (max > 255) {
                var scale = 255 / max;
                r *= scale;
                g *= scale;
                b *= scale;
              }
              byteArray[i * 3 + 0] = r;
              byteArray[i * 3 + 1] = g;
              byteArray[i * 3 + 2] = b;
            }
          }
        }
        if (byteArray) {
          results.push(byteArray);
        } else {
          results.push(dataFace);
        }
      }
      return results;
    };
    if (this._getEngine().webGLVersion >= 2 && this._prefilterOnLoad) {
      var previousOnLoad_1 = this._onLoad;
      var hdrFiltering_1 = new HDRFiltering(engine);
      this._onLoad = function() {
        hdrFiltering_1.prefilter(_this, previousOnLoad_1);
      };
    }
    this._texture = engine.createRawCubeTextureFromUrl(this.url, this.getScene(), this._size, 4, engine.getCaps().textureFloat ? 1 : 0, this._noMipmap, callback, null, this._onLoad, this._onError);
  };
  HDRCubeTexture2.prototype.clone = function() {
    var newTexture = new HDRCubeTexture2(this.url, this.getScene() || this._getEngine(), this._size, this._noMipmap, this._generateHarmonics, this.gammaSpace);
    newTexture.level = this.level;
    newTexture.wrapU = this.wrapU;
    newTexture.wrapV = this.wrapV;
    newTexture.coordinatesIndex = this.coordinatesIndex;
    newTexture.coordinatesMode = this.coordinatesMode;
    return newTexture;
  };
  HDRCubeTexture2.prototype.delayLoad = function() {
    if (this.delayLoadState !== 4) {
      return;
    }
    this.delayLoadState = 1;
    this._texture = this._getFromCache(this.url, this._noMipmap);
    if (!this._texture) {
      this.loadTexture();
    }
  };
  HDRCubeTexture2.prototype.getReflectionTextureMatrix = function() {
    return this._textureMatrix;
  };
  HDRCubeTexture2.prototype.setReflectionTextureMatrix = function(value) {
    var _this = this;
    var _a;
    this._textureMatrix = value;
    if (value.updateFlag === this._textureMatrix.updateFlag) {
      return;
    }
    if (value.isIdentity() !== this._textureMatrix.isIdentity()) {
      (_a = this.getScene()) === null || _a === void 0 ? void 0 : _a.markAllMaterialsAsDirty(1, function(mat) {
        return mat.getActiveTextures().indexOf(_this) !== -1;
      });
    }
  };
  HDRCubeTexture2.Parse = function(parsedTexture, scene, rootUrl) {
    var texture = null;
    if (parsedTexture.name && !parsedTexture.isRenderTarget) {
      texture = new HDRCubeTexture2(rootUrl + parsedTexture.name, scene, parsedTexture.size, parsedTexture.noMipmap, parsedTexture.generateHarmonics, parsedTexture.useInGammaSpace);
      texture.name = parsedTexture.name;
      texture.hasAlpha = parsedTexture.hasAlpha;
      texture.level = parsedTexture.level;
      texture.coordinatesMode = parsedTexture.coordinatesMode;
      texture.isBlocking = parsedTexture.isBlocking;
    }
    if (texture) {
      if (parsedTexture.boundingBoxPosition) {
        texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);
      }
      if (parsedTexture.boundingBoxSize) {
        texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);
      }
      if (parsedTexture.rotationY) {
        texture.rotationY = parsedTexture.rotationY;
      }
    }
    return texture;
  };
  HDRCubeTexture2.prototype.serialize = function() {
    if (!this.name) {
      return null;
    }
    var serializationObject = {};
    serializationObject.name = this.name;
    serializationObject.hasAlpha = this.hasAlpha;
    serializationObject.isCube = true;
    serializationObject.level = this.level;
    serializationObject.size = this._size;
    serializationObject.coordinatesMode = this.coordinatesMode;
    serializationObject.useInGammaSpace = this.gammaSpace;
    serializationObject.generateHarmonics = this._generateHarmonics;
    serializationObject.customType = "BABYLON.HDRCubeTexture";
    serializationObject.noMipmap = this._noMipmap;
    serializationObject.isBlocking = this._isBlocking;
    serializationObject.rotationY = this._rotationY;
    return serializationObject;
  };
  HDRCubeTexture2._facesMapping = [
    "right",
    "left",
    "up",
    "down",
    "front",
    "back"
  ];
  return HDRCubeTexture2;
}(BaseTexture);
_TypeStore.RegisteredTypes["BABYLON.HDRCubeTexture"] = HDRCubeTexture;

// node_modules/@babylonjs/core/Physics/physicsEngine.js
var PhysicsEngine = function() {
  function PhysicsEngine2(gravity, _physicsPlugin) {
    if (_physicsPlugin === void 0) {
      _physicsPlugin = PhysicsEngine2.DefaultPluginFactory();
    }
    this._physicsPlugin = _physicsPlugin;
    this._impostors = [];
    this._joints = [];
    this._subTimeStep = 0;
    if (!this._physicsPlugin.isSupported()) {
      throw new Error("Physics Engine " + this._physicsPlugin.name + " cannot be found. Please make sure it is included.");
    }
    gravity = gravity || new Vector3(0, -9.807, 0);
    this.setGravity(gravity);
    this.setTimeStep();
  }
  PhysicsEngine2.DefaultPluginFactory = function() {
    throw _DevTools.WarnImport("CannonJSPlugin");
  };
  PhysicsEngine2.prototype.setGravity = function(gravity) {
    this.gravity = gravity;
    this._physicsPlugin.setGravity(this.gravity);
  };
  PhysicsEngine2.prototype.setTimeStep = function(newTimeStep) {
    if (newTimeStep === void 0) {
      newTimeStep = 1 / 60;
    }
    this._physicsPlugin.setTimeStep(newTimeStep);
  };
  PhysicsEngine2.prototype.getTimeStep = function() {
    return this._physicsPlugin.getTimeStep();
  };
  PhysicsEngine2.prototype.setSubTimeStep = function(subTimeStep) {
    if (subTimeStep === void 0) {
      subTimeStep = 0;
    }
    this._subTimeStep = subTimeStep;
  };
  PhysicsEngine2.prototype.getSubTimeStep = function() {
    return this._subTimeStep;
  };
  PhysicsEngine2.prototype.dispose = function() {
    this._impostors.forEach(function(impostor) {
      impostor.dispose();
    });
    this._physicsPlugin.dispose();
  };
  PhysicsEngine2.prototype.getPhysicsPluginName = function() {
    return this._physicsPlugin.name;
  };
  PhysicsEngine2.prototype.addImpostor = function(impostor) {
    impostor.uniqueId = this._impostors.push(impostor);
    if (!impostor.parent) {
      this._physicsPlugin.generatePhysicsBody(impostor);
    }
  };
  PhysicsEngine2.prototype.removeImpostor = function(impostor) {
    var index = this._impostors.indexOf(impostor);
    if (index > -1) {
      var removed = this._impostors.splice(index, 1);
      if (removed.length) {
        this.getPhysicsPlugin().removePhysicsBody(impostor);
      }
    }
  };
  PhysicsEngine2.prototype.addJoint = function(mainImpostor, connectedImpostor, joint) {
    var impostorJoint = {
      mainImpostor,
      connectedImpostor,
      joint
    };
    joint.physicsPlugin = this._physicsPlugin;
    this._joints.push(impostorJoint);
    this._physicsPlugin.generateJoint(impostorJoint);
  };
  PhysicsEngine2.prototype.removeJoint = function(mainImpostor, connectedImpostor, joint) {
    var matchingJoints = this._joints.filter(function(impostorJoint) {
      return impostorJoint.connectedImpostor === connectedImpostor && impostorJoint.joint === joint && impostorJoint.mainImpostor === mainImpostor;
    });
    if (matchingJoints.length) {
      this._physicsPlugin.removeJoint(matchingJoints[0]);
    }
  };
  PhysicsEngine2.prototype._step = function(delta) {
    var _this = this;
    this._impostors.forEach(function(impostor) {
      if (impostor.isBodyInitRequired()) {
        _this._physicsPlugin.generatePhysicsBody(impostor);
      }
    });
    if (delta > 0.1) {
      delta = 0.1;
    } else if (delta <= 0) {
      delta = 1 / 60;
    }
    this._physicsPlugin.executeStep(delta, this._impostors);
  };
  PhysicsEngine2.prototype.getPhysicsPlugin = function() {
    return this._physicsPlugin;
  };
  PhysicsEngine2.prototype.getImpostors = function() {
    return this._impostors;
  };
  PhysicsEngine2.prototype.getImpostorForPhysicsObject = function(object) {
    for (var i = 0; i < this._impostors.length; ++i) {
      if (this._impostors[i].object === object) {
        return this._impostors[i];
      }
    }
    return null;
  };
  PhysicsEngine2.prototype.getImpostorWithPhysicsBody = function(body) {
    for (var i = 0; i < this._impostors.length; ++i) {
      if (this._impostors[i].physicsBody === body) {
        return this._impostors[i];
      }
    }
    return null;
  };
  PhysicsEngine2.prototype.raycast = function(from, to) {
    return this._physicsPlugin.raycast(from, to);
  };
  PhysicsEngine2.Epsilon = 1e-3;
  return PhysicsEngine2;
}();

// node_modules/@babylonjs/core/Physics/physicsRaycastResult.js
var PhysicsRaycastResult = function() {
  function PhysicsRaycastResult2() {
    this._hasHit = false;
    this._hitDistance = 0;
    this._hitNormalWorld = Vector3.Zero();
    this._hitPointWorld = Vector3.Zero();
    this._rayFromWorld = Vector3.Zero();
    this._rayToWorld = Vector3.Zero();
  }
  Object.defineProperty(PhysicsRaycastResult2.prototype, "hasHit", {
    get: function() {
      return this._hasHit;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PhysicsRaycastResult2.prototype, "hitDistance", {
    get: function() {
      return this._hitDistance;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PhysicsRaycastResult2.prototype, "hitNormalWorld", {
    get: function() {
      return this._hitNormalWorld;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PhysicsRaycastResult2.prototype, "hitPointWorld", {
    get: function() {
      return this._hitPointWorld;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PhysicsRaycastResult2.prototype, "rayFromWorld", {
    get: function() {
      return this._rayFromWorld;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PhysicsRaycastResult2.prototype, "rayToWorld", {
    get: function() {
      return this._rayToWorld;
    },
    enumerable: false,
    configurable: true
  });
  PhysicsRaycastResult2.prototype.setHitData = function(hitNormalWorld, hitPointWorld) {
    this._hasHit = true;
    this._hitNormalWorld = new Vector3(hitNormalWorld.x, hitNormalWorld.y, hitNormalWorld.z);
    this._hitPointWorld = new Vector3(hitPointWorld.x, hitPointWorld.y, hitPointWorld.z);
  };
  PhysicsRaycastResult2.prototype.setHitDistance = function(distance) {
    this._hitDistance = distance;
  };
  PhysicsRaycastResult2.prototype.calculateHitDistance = function() {
    this._hitDistance = Vector3.Distance(this._rayFromWorld, this._hitPointWorld);
  };
  PhysicsRaycastResult2.prototype.reset = function(from, to) {
    if (from === void 0) {
      from = Vector3.Zero();
    }
    if (to === void 0) {
      to = Vector3.Zero();
    }
    this._rayFromWorld = from;
    this._rayToWorld = to;
    this._hasHit = false;
    this._hitDistance = 0;
    this._hitNormalWorld = Vector3.Zero();
    this._hitPointWorld = Vector3.Zero();
  };
  return PhysicsRaycastResult2;
}();

// node_modules/@babylonjs/core/Physics/Plugins/cannonJSPlugin.js
var CannonJSPlugin = function() {
  function CannonJSPlugin2(_useDeltaForWorldStep, iterations, cannonInjection) {
    if (_useDeltaForWorldStep === void 0) {
      _useDeltaForWorldStep = true;
    }
    if (iterations === void 0) {
      iterations = 10;
    }
    if (cannonInjection === void 0) {
      cannonInjection = CANNON;
    }
    this._useDeltaForWorldStep = _useDeltaForWorldStep;
    this.name = "CannonJSPlugin";
    this._physicsMaterials = new Array();
    this._fixedTimeStep = 1 / 60;
    this._physicsBodysToRemoveAfterStep = new Array();
    this._firstFrame = true;
    this._minus90X = new Quaternion(-0.7071067811865475, 0, 0, 0.7071067811865475);
    this._plus90X = new Quaternion(0.7071067811865475, 0, 0, 0.7071067811865475);
    this._tmpPosition = Vector3.Zero();
    this._tmpDeltaPosition = Vector3.Zero();
    this._tmpUnityRotation = new Quaternion();
    this.BJSCANNON = cannonInjection;
    if (!this.isSupported()) {
      Logger.Error("CannonJS is not available. Please make sure you included the js file.");
      return;
    }
    this._extendNamespace();
    this.world = new this.BJSCANNON.World();
    this.world.broadphase = new this.BJSCANNON.NaiveBroadphase();
    this.world.solver.iterations = iterations;
    this._cannonRaycastResult = new this.BJSCANNON.RaycastResult();
    this._raycastResult = new PhysicsRaycastResult();
  }
  CannonJSPlugin2.prototype.setGravity = function(gravity) {
    var vec = gravity;
    this.world.gravity.set(vec.x, vec.y, vec.z);
  };
  CannonJSPlugin2.prototype.setTimeStep = function(timeStep) {
    this._fixedTimeStep = timeStep;
  };
  CannonJSPlugin2.prototype.getTimeStep = function() {
    return this._fixedTimeStep;
  };
  CannonJSPlugin2.prototype.executeStep = function(delta, impostors) {
    if (this._firstFrame) {
      this._firstFrame = false;
      for (var _i = 0, impostors_1 = impostors; _i < impostors_1.length; _i++) {
        var impostor = impostors_1[_i];
        if (!(impostor.type == PhysicsImpostor.HeightmapImpostor || impostor.type === PhysicsImpostor.PlaneImpostor)) {
          impostor.beforeStep();
        }
      }
    }
    this.world.step(this._useDeltaForWorldStep ? delta : this._fixedTimeStep);
    this._removeMarkedPhysicsBodiesFromWorld();
  };
  CannonJSPlugin2.prototype._removeMarkedPhysicsBodiesFromWorld = function() {
    var _this = this;
    if (this._physicsBodysToRemoveAfterStep.length > 0) {
      this._physicsBodysToRemoveAfterStep.forEach(function(physicsBody) {
        _this.world.remove(physicsBody);
      });
      this._physicsBodysToRemoveAfterStep = [];
    }
  };
  CannonJSPlugin2.prototype.applyImpulse = function(impostor, force, contactPoint) {
    var worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);
    var impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);
    impostor.physicsBody.applyImpulse(impulse, worldPoint);
  };
  CannonJSPlugin2.prototype.applyForce = function(impostor, force, contactPoint) {
    var worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);
    var impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);
    impostor.physicsBody.applyForce(impulse, worldPoint);
  };
  CannonJSPlugin2.prototype.generatePhysicsBody = function(impostor) {
    this._removeMarkedPhysicsBodiesFromWorld();
    if (impostor.parent) {
      if (impostor.physicsBody) {
        this.removePhysicsBody(impostor);
        impostor.forceUpdate();
      }
      return;
    }
    if (impostor.isBodyInitRequired()) {
      var shape = this._createShape(impostor);
      var oldBody = impostor.physicsBody;
      if (oldBody) {
        this.removePhysicsBody(impostor);
      }
      var material = this._addMaterial("mat-" + impostor.uniqueId, impostor.getParam("friction"), impostor.getParam("restitution"));
      var bodyCreationObject = {
        mass: impostor.getParam("mass"),
        material
      };
      var nativeOptions = impostor.getParam("nativeOptions");
      for (var key in nativeOptions) {
        if (nativeOptions.hasOwnProperty(key)) {
          bodyCreationObject[key] = nativeOptions[key];
        }
      }
      impostor.physicsBody = new this.BJSCANNON.Body(bodyCreationObject);
      impostor.physicsBody.addEventListener("collide", impostor.onCollide);
      this.world.addEventListener("preStep", impostor.beforeStep);
      this.world.addEventListener("postStep", impostor.afterStep);
      impostor.physicsBody.addShape(shape);
      this.world.add(impostor.physicsBody);
      if (oldBody) {
        ["force", "torque", "velocity", "angularVelocity"].forEach(function(param) {
          var vec = oldBody[param];
          impostor.physicsBody[param].set(vec.x, vec.y, vec.z);
        });
      }
      this._processChildMeshes(impostor);
    }
    this._updatePhysicsBodyTransformation(impostor);
  };
  CannonJSPlugin2.prototype._processChildMeshes = function(mainImpostor) {
    var _this = this;
    var meshChildren = mainImpostor.object.getChildMeshes ? mainImpostor.object.getChildMeshes(true) : [];
    var currentRotation = mainImpostor.object.rotationQuaternion;
    if (meshChildren.length) {
      var processMesh_1 = function(mesh) {
        if (!currentRotation || !mesh.rotationQuaternion) {
          return;
        }
        var childImpostor = mesh.getPhysicsImpostor();
        if (childImpostor) {
          var parent = childImpostor.parent;
          if (parent !== mainImpostor) {
            var pPosition = mesh.getAbsolutePosition().subtract(mesh.parent.getAbsolutePosition());
            var q = mesh.rotationQuaternion;
            if (childImpostor.physicsBody) {
              _this.removePhysicsBody(childImpostor);
              childImpostor.physicsBody = null;
            }
            childImpostor.parent = mainImpostor;
            childImpostor.resetUpdateFlags();
            mainImpostor.physicsBody.addShape(_this._createShape(childImpostor), new _this.BJSCANNON.Vec3(pPosition.x, pPosition.y, pPosition.z), new _this.BJSCANNON.Quaternion(q.x, q.y, q.z, q.w));
            mainImpostor.physicsBody.mass += childImpostor.getParam("mass");
          }
        }
        currentRotation.multiplyInPlace(mesh.rotationQuaternion);
        mesh.getChildMeshes(true).filter(function(m) {
          return !!m.physicsImpostor;
        }).forEach(processMesh_1);
      };
      meshChildren.filter(function(m) {
        return !!m.physicsImpostor;
      }).forEach(processMesh_1);
    }
  };
  CannonJSPlugin2.prototype.removePhysicsBody = function(impostor) {
    impostor.physicsBody.removeEventListener("collide", impostor.onCollide);
    this.world.removeEventListener("preStep", impostor.beforeStep);
    this.world.removeEventListener("postStep", impostor.afterStep);
    if (this._physicsBodysToRemoveAfterStep.indexOf(impostor.physicsBody) === -1) {
      this._physicsBodysToRemoveAfterStep.push(impostor.physicsBody);
    }
  };
  CannonJSPlugin2.prototype.generateJoint = function(impostorJoint) {
    var mainBody = impostorJoint.mainImpostor.physicsBody;
    var connectedBody = impostorJoint.connectedImpostor.physicsBody;
    if (!mainBody || !connectedBody) {
      return;
    }
    var constraint;
    var jointData = impostorJoint.joint.jointData;
    var constraintData = {
      pivotA: jointData.mainPivot ? new this.BJSCANNON.Vec3().set(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z) : null,
      pivotB: jointData.connectedPivot ? new this.BJSCANNON.Vec3().set(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z) : null,
      axisA: jointData.mainAxis ? new this.BJSCANNON.Vec3().set(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z) : null,
      axisB: jointData.connectedAxis ? new this.BJSCANNON.Vec3().set(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z) : null,
      maxForce: jointData.nativeParams.maxForce,
      collideConnected: !!jointData.collision
    };
    switch (impostorJoint.joint.type) {
      case PhysicsJoint.HingeJoint:
      case PhysicsJoint.Hinge2Joint:
        constraint = new this.BJSCANNON.HingeConstraint(mainBody, connectedBody, constraintData);
        break;
      case PhysicsJoint.DistanceJoint:
        constraint = new this.BJSCANNON.DistanceConstraint(mainBody, connectedBody, jointData.maxDistance || 2);
        break;
      case PhysicsJoint.SpringJoint:
        var springData = jointData;
        constraint = new this.BJSCANNON.Spring(mainBody, connectedBody, {
          restLength: springData.length,
          stiffness: springData.stiffness,
          damping: springData.damping,
          localAnchorA: constraintData.pivotA,
          localAnchorB: constraintData.pivotB
        });
        break;
      case PhysicsJoint.LockJoint:
        constraint = new this.BJSCANNON.LockConstraint(mainBody, connectedBody, constraintData);
        break;
      case PhysicsJoint.PointToPointJoint:
      case PhysicsJoint.BallAndSocketJoint:
      default:
        constraint = new this.BJSCANNON.PointToPointConstraint(mainBody, constraintData.pivotA, connectedBody, constraintData.pivotB, constraintData.maxForce);
        break;
    }
    constraint.collideConnected = !!jointData.collision;
    impostorJoint.joint.physicsJoint = constraint;
    if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {
      this.world.addConstraint(constraint);
    } else {
      impostorJoint.joint.jointData.forceApplicationCallback = impostorJoint.joint.jointData.forceApplicationCallback || function() {
        constraint.applyForce();
      };
      impostorJoint.mainImpostor.registerAfterPhysicsStep(impostorJoint.joint.jointData.forceApplicationCallback);
    }
  };
  CannonJSPlugin2.prototype.removeJoint = function(impostorJoint) {
    if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {
      this.world.removeConstraint(impostorJoint.joint.physicsJoint);
    } else {
      impostorJoint.mainImpostor.unregisterAfterPhysicsStep(impostorJoint.joint.jointData.forceApplicationCallback);
    }
  };
  CannonJSPlugin2.prototype._addMaterial = function(name98, friction, restitution) {
    var index;
    var mat;
    for (index = 0; index < this._physicsMaterials.length; index++) {
      mat = this._physicsMaterials[index];
      if (mat.friction === friction && mat.restitution === restitution) {
        return mat;
      }
    }
    var currentMat = new this.BJSCANNON.Material(name98);
    currentMat.friction = friction;
    currentMat.restitution = restitution;
    this._physicsMaterials.push(currentMat);
    return currentMat;
  };
  CannonJSPlugin2.prototype._checkWithEpsilon = function(value) {
    return value < PhysicsEngine.Epsilon ? PhysicsEngine.Epsilon : value;
  };
  CannonJSPlugin2.prototype._createShape = function(impostor) {
    var object = impostor.object;
    var returnValue;
    var extendSize = impostor.getObjectExtendSize();
    switch (impostor.type) {
      case PhysicsImpostor.SphereImpostor:
        var radiusX = extendSize.x;
        var radiusY = extendSize.y;
        var radiusZ = extendSize.z;
        returnValue = new this.BJSCANNON.Sphere(Math.max(this._checkWithEpsilon(radiusX), this._checkWithEpsilon(radiusY), this._checkWithEpsilon(radiusZ)) / 2);
        break;
      case PhysicsImpostor.CylinderImpostor:
        var nativeParams = impostor.getParam("nativeOptions");
        if (!nativeParams) {
          nativeParams = {};
        }
        var radiusTop = nativeParams.radiusTop !== void 0 ? nativeParams.radiusTop : this._checkWithEpsilon(extendSize.x) / 2;
        var radiusBottom = nativeParams.radiusBottom !== void 0 ? nativeParams.radiusBottom : this._checkWithEpsilon(extendSize.x) / 2;
        var height = nativeParams.height !== void 0 ? nativeParams.height : this._checkWithEpsilon(extendSize.y);
        var numSegments = nativeParams.numSegments !== void 0 ? nativeParams.numSegments : 16;
        returnValue = new this.BJSCANNON.Cylinder(radiusTop, radiusBottom, height, numSegments);
        var quat = new this.BJSCANNON.Quaternion();
        quat.setFromAxisAngle(new this.BJSCANNON.Vec3(1, 0, 0), -Math.PI / 2);
        var translation = new this.BJSCANNON.Vec3(0, 0, 0);
        returnValue.transformAllPoints(translation, quat);
        break;
      case PhysicsImpostor.BoxImpostor:
        var box = extendSize.scale(0.5);
        returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(this._checkWithEpsilon(box.x), this._checkWithEpsilon(box.y), this._checkWithEpsilon(box.z)));
        break;
      case PhysicsImpostor.PlaneImpostor:
        Logger.Warn("Attention, PlaneImposter might not behave as you expect. Consider using BoxImposter instead");
        returnValue = new this.BJSCANNON.Plane();
        break;
      case PhysicsImpostor.MeshImpostor:
        var rawVerts = object.getVerticesData ? object.getVerticesData(VertexBuffer.PositionKind) : [];
        var rawFaces = object.getIndices ? object.getIndices() : [];
        if (!rawVerts) {
          return;
        }
        var oldPosition = object.position.clone();
        var oldRotation = object.rotation && object.rotation.clone();
        var oldQuaternion = object.rotationQuaternion && object.rotationQuaternion.clone();
        object.position.copyFromFloats(0, 0, 0);
        object.rotation && object.rotation.copyFromFloats(0, 0, 0);
        object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());
        object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();
        var transform = object.computeWorldMatrix(true);
        var temp = new Array();
        var index;
        for (index = 0; index < rawVerts.length; index += 3) {
          Vector3.TransformCoordinates(Vector3.FromArray(rawVerts, index), transform).toArray(temp, index);
        }
        Logger.Warn("MeshImpostor only collides against spheres.");
        returnValue = new this.BJSCANNON.Trimesh(temp, rawFaces);
        object.position.copyFrom(oldPosition);
        oldRotation && object.rotation && object.rotation.copyFrom(oldRotation);
        oldQuaternion && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion);
        break;
      case PhysicsImpostor.HeightmapImpostor:
        var oldPosition2 = object.position.clone();
        var oldRotation2 = object.rotation && object.rotation.clone();
        var oldQuaternion2 = object.rotationQuaternion && object.rotationQuaternion.clone();
        object.position.copyFromFloats(0, 0, 0);
        object.rotation && object.rotation.copyFromFloats(0, 0, 0);
        object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());
        object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();
        object.rotationQuaternion && object.rotationQuaternion.multiplyInPlace(this._minus90X);
        returnValue = this._createHeightmap(object);
        object.position.copyFrom(oldPosition2);
        oldRotation2 && object.rotation && object.rotation.copyFrom(oldRotation2);
        oldQuaternion2 && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion2);
        object.computeWorldMatrix(true);
        break;
      case PhysicsImpostor.ParticleImpostor:
        returnValue = new this.BJSCANNON.Particle();
        break;
      case PhysicsImpostor.NoImpostor:
        returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(0, 0, 0));
        break;
    }
    return returnValue;
  };
  CannonJSPlugin2.prototype._createHeightmap = function(object, pointDepth) {
    var pos = object.getVerticesData(VertexBuffer.PositionKind);
    var transform = object.computeWorldMatrix(true);
    var temp = new Array();
    var index;
    for (index = 0; index < pos.length; index += 3) {
      Vector3.TransformCoordinates(Vector3.FromArray(pos, index), transform).toArray(temp, index);
    }
    pos = temp;
    var matrix = new Array();
    var arraySize = pointDepth || ~~(Math.sqrt(pos.length / 3) - 1);
    var boundingInfo = object.getBoundingInfo();
    var dim = Math.min(boundingInfo.boundingBox.extendSizeWorld.x, boundingInfo.boundingBox.extendSizeWorld.y);
    var minY = boundingInfo.boundingBox.extendSizeWorld.z;
    var elementSize = dim * 2 / arraySize;
    for (var i = 0; i < pos.length; i = i + 3) {
      var x = Math.round(pos[i + 0] / elementSize + arraySize / 2);
      var z = Math.round((pos[i + 1] / elementSize - arraySize / 2) * -1);
      var y = -pos[i + 2] + minY;
      if (!matrix[x]) {
        matrix[x] = [];
      }
      if (!matrix[x][z]) {
        matrix[x][z] = y;
      }
      matrix[x][z] = Math.max(y, matrix[x][z]);
    }
    for (var x = 0; x <= arraySize; ++x) {
      if (!matrix[x]) {
        var loc = 1;
        while (!matrix[(x + loc) % arraySize]) {
          loc++;
        }
        matrix[x] = matrix[(x + loc) % arraySize].slice();
      }
      for (var z = 0; z <= arraySize; ++z) {
        if (!matrix[x][z]) {
          var loc = 1;
          var newValue;
          while (newValue === void 0) {
            newValue = matrix[x][(z + loc++) % arraySize];
          }
          matrix[x][z] = newValue;
        }
      }
    }
    var shape = new this.BJSCANNON.Heightfield(matrix, {
      elementSize
    });
    shape.minY = minY;
    return shape;
  };
  CannonJSPlugin2.prototype._updatePhysicsBodyTransformation = function(impostor) {
    var object = impostor.object;
    object.computeWorldMatrix && object.computeWorldMatrix(true);
    if (!object.getBoundingInfo()) {
      return;
    }
    var center = impostor.getObjectCenter();
    this._tmpDeltaPosition.copyFrom(object.getAbsolutePivotPoint().subtract(center));
    this._tmpDeltaPosition.divideInPlace(impostor.object.scaling);
    this._tmpPosition.copyFrom(center);
    var quaternion = object.rotationQuaternion;
    if (!quaternion) {
      return;
    }
    if (impostor.type === PhysicsImpostor.PlaneImpostor || impostor.type === PhysicsImpostor.HeightmapImpostor) {
      quaternion = quaternion.multiply(this._minus90X);
      impostor.setDeltaRotation(this._plus90X);
    }
    if (impostor.type === PhysicsImpostor.HeightmapImpostor) {
      var mesh = object;
      var boundingInfo = mesh.getBoundingInfo();
      var rotationQuaternion = mesh.rotationQuaternion;
      mesh.rotationQuaternion = this._tmpUnityRotation;
      mesh.computeWorldMatrix(true);
      var c = center.clone();
      var oldPivot = mesh.getPivotMatrix();
      if (oldPivot) {
        oldPivot = oldPivot.clone();
      } else {
        oldPivot = Matrix.Identity();
      }
      var p = Matrix.Translation(boundingInfo.boundingBox.extendSizeWorld.x, 0, -boundingInfo.boundingBox.extendSizeWorld.z);
      mesh.setPreTransformMatrix(p);
      mesh.computeWorldMatrix(true);
      var translation = boundingInfo.boundingBox.centerWorld.subtract(center).subtract(mesh.position).negate();
      this._tmpPosition.copyFromFloats(translation.x, translation.y - boundingInfo.boundingBox.extendSizeWorld.y, translation.z);
      this._tmpDeltaPosition.copyFrom(boundingInfo.boundingBox.centerWorld.subtract(c));
      this._tmpDeltaPosition.y += boundingInfo.boundingBox.extendSizeWorld.y;
      mesh.rotationQuaternion = rotationQuaternion;
      mesh.setPreTransformMatrix(oldPivot);
      mesh.computeWorldMatrix(true);
    } else if (impostor.type === PhysicsImpostor.MeshImpostor) {
      this._tmpDeltaPosition.copyFromFloats(0, 0, 0);
    }
    impostor.setDeltaPosition(this._tmpDeltaPosition);
    impostor.physicsBody.position.set(this._tmpPosition.x, this._tmpPosition.y, this._tmpPosition.z);
    impostor.physicsBody.quaternion.set(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
  };
  CannonJSPlugin2.prototype.setTransformationFromPhysicsBody = function(impostor) {
    impostor.object.position.set(impostor.physicsBody.position.x, impostor.physicsBody.position.y, impostor.physicsBody.position.z);
    if (impostor.object.rotationQuaternion) {
      var q = impostor.physicsBody.quaternion;
      impostor.object.rotationQuaternion.set(q.x, q.y, q.z, q.w);
    }
  };
  CannonJSPlugin2.prototype.setPhysicsBodyTransformation = function(impostor, newPosition, newRotation) {
    impostor.physicsBody.position.set(newPosition.x, newPosition.y, newPosition.z);
    impostor.physicsBody.quaternion.set(newRotation.x, newRotation.y, newRotation.z, newRotation.w);
  };
  CannonJSPlugin2.prototype.isSupported = function() {
    return this.BJSCANNON !== void 0;
  };
  CannonJSPlugin2.prototype.setLinearVelocity = function(impostor, velocity) {
    impostor.physicsBody.velocity.set(velocity.x, velocity.y, velocity.z);
  };
  CannonJSPlugin2.prototype.setAngularVelocity = function(impostor, velocity) {
    impostor.physicsBody.angularVelocity.set(velocity.x, velocity.y, velocity.z);
  };
  CannonJSPlugin2.prototype.getLinearVelocity = function(impostor) {
    var v = impostor.physicsBody.velocity;
    if (!v) {
      return null;
    }
    return new Vector3(v.x, v.y, v.z);
  };
  CannonJSPlugin2.prototype.getAngularVelocity = function(impostor) {
    var v = impostor.physicsBody.angularVelocity;
    if (!v) {
      return null;
    }
    return new Vector3(v.x, v.y, v.z);
  };
  CannonJSPlugin2.prototype.setBodyMass = function(impostor, mass) {
    impostor.physicsBody.mass = mass;
    impostor.physicsBody.updateMassProperties();
  };
  CannonJSPlugin2.prototype.getBodyMass = function(impostor) {
    return impostor.physicsBody.mass;
  };
  CannonJSPlugin2.prototype.getBodyFriction = function(impostor) {
    return impostor.physicsBody.material.friction;
  };
  CannonJSPlugin2.prototype.setBodyFriction = function(impostor, friction) {
    impostor.physicsBody.material.friction = friction;
  };
  CannonJSPlugin2.prototype.getBodyRestitution = function(impostor) {
    return impostor.physicsBody.material.restitution;
  };
  CannonJSPlugin2.prototype.setBodyRestitution = function(impostor, restitution) {
    impostor.physicsBody.material.restitution = restitution;
  };
  CannonJSPlugin2.prototype.sleepBody = function(impostor) {
    impostor.physicsBody.sleep();
  };
  CannonJSPlugin2.prototype.wakeUpBody = function(impostor) {
    impostor.physicsBody.wakeUp();
  };
  CannonJSPlugin2.prototype.updateDistanceJoint = function(joint, maxDistance) {
    joint.physicsJoint.distance = maxDistance;
  };
  CannonJSPlugin2.prototype.setMotor = function(joint, speed, maxForce, motorIndex) {
    if (!motorIndex) {
      joint.physicsJoint.enableMotor();
      joint.physicsJoint.setMotorSpeed(speed);
      if (maxForce) {
        this.setLimit(joint, maxForce);
      }
    }
  };
  CannonJSPlugin2.prototype.setLimit = function(joint, upperLimit, lowerLimit) {
    joint.physicsJoint.motorEquation.maxForce = upperLimit;
    joint.physicsJoint.motorEquation.minForce = lowerLimit === void 0 ? -upperLimit : lowerLimit;
  };
  CannonJSPlugin2.prototype.syncMeshWithImpostor = function(mesh, impostor) {
    var body = impostor.physicsBody;
    mesh.position.x = body.position.x;
    mesh.position.y = body.position.y;
    mesh.position.z = body.position.z;
    if (mesh.rotationQuaternion) {
      mesh.rotationQuaternion.x = body.quaternion.x;
      mesh.rotationQuaternion.y = body.quaternion.y;
      mesh.rotationQuaternion.z = body.quaternion.z;
      mesh.rotationQuaternion.w = body.quaternion.w;
    }
  };
  CannonJSPlugin2.prototype.getRadius = function(impostor) {
    var shape = impostor.physicsBody.shapes[0];
    return shape.boundingSphereRadius;
  };
  CannonJSPlugin2.prototype.getBoxSizeToRef = function(impostor, result) {
    var shape = impostor.physicsBody.shapes[0];
    result.x = shape.halfExtents.x * 2;
    result.y = shape.halfExtents.y * 2;
    result.z = shape.halfExtents.z * 2;
  };
  CannonJSPlugin2.prototype.dispose = function() {
  };
  CannonJSPlugin2.prototype._extendNamespace = function() {
    var step_tmp1 = new this.BJSCANNON.Vec3();
    var Engine2 = this.BJSCANNON;
    this.BJSCANNON.World.prototype.step = function(dt, timeSinceLastCalled, maxSubSteps) {
      maxSubSteps = maxSubSteps || 10;
      timeSinceLastCalled = timeSinceLastCalled || 0;
      if (timeSinceLastCalled === 0) {
        this.internalStep(dt);
        this.time += dt;
      } else {
        var internalSteps = Math.floor((this.time + timeSinceLastCalled) / dt) - Math.floor(this.time / dt);
        internalSteps = Math.min(internalSteps, maxSubSteps) || 1;
        var t0 = performance.now();
        for (var i = 0; i !== internalSteps; i++) {
          this.internalStep(dt);
          if (performance.now() - t0 > dt * 1e3) {
            break;
          }
        }
        this.time += timeSinceLastCalled;
        var h = this.time % dt;
        var h_div_dt = h / dt;
        var interpvelo = step_tmp1;
        var bodies = this.bodies;
        for (var j = 0; j !== bodies.length; j++) {
          var b = bodies[j];
          if (b.type !== Engine2.Body.STATIC && b.sleepState !== Engine2.Body.SLEEPING) {
            b.position.vsub(b.previousPosition, interpvelo);
            interpvelo.scale(h_div_dt, interpvelo);
            b.position.vadd(interpvelo, b.interpolatedPosition);
          } else {
            b.interpolatedPosition.set(b.position.x, b.position.y, b.position.z);
            b.interpolatedQuaternion.set(b.quaternion.x, b.quaternion.y, b.quaternion.z, b.quaternion.w);
          }
        }
      }
    };
  };
  CannonJSPlugin2.prototype.raycast = function(from, to) {
    this._cannonRaycastResult.reset();
    this.world.raycastClosest(from, to, {}, this._cannonRaycastResult);
    this._raycastResult.reset(from, to);
    if (this._cannonRaycastResult.hasHit) {
      this._raycastResult.setHitData({
        x: this._cannonRaycastResult.hitNormalWorld.x,
        y: this._cannonRaycastResult.hitNormalWorld.y,
        z: this._cannonRaycastResult.hitNormalWorld.z
      }, {
        x: this._cannonRaycastResult.hitPointWorld.x,
        y: this._cannonRaycastResult.hitPointWorld.y,
        z: this._cannonRaycastResult.hitPointWorld.z
      });
      this._raycastResult.setHitDistance(this._cannonRaycastResult.distance);
    }
    return this._raycastResult;
  };
  return CannonJSPlugin2;
}();
PhysicsEngine.DefaultPluginFactory = function() {
  return new CannonJSPlugin();
};

// node_modules/@babylonjs/core/Physics/Plugins/oimoJSPlugin.js
var OimoJSPlugin = function() {
  function OimoJSPlugin2(_useDeltaForWorldStep, iterations, oimoInjection) {
    if (_useDeltaForWorldStep === void 0) {
      _useDeltaForWorldStep = true;
    }
    if (oimoInjection === void 0) {
      oimoInjection = OIMO;
    }
    this._useDeltaForWorldStep = _useDeltaForWorldStep;
    this.name = "OimoJSPlugin";
    this._fixedTimeStep = 1 / 60;
    this._tmpImpostorsArray = [];
    this._tmpPositionVector = Vector3.Zero();
    this.BJSOIMO = oimoInjection;
    this.world = new this.BJSOIMO.World({
      iterations
    });
    this.world.clear();
    this._raycastResult = new PhysicsRaycastResult();
  }
  OimoJSPlugin2.prototype.setGravity = function(gravity) {
    this.world.gravity.set(gravity.x, gravity.y, gravity.z);
  };
  OimoJSPlugin2.prototype.setTimeStep = function(timeStep) {
    this.world.timeStep = timeStep;
  };
  OimoJSPlugin2.prototype.getTimeStep = function() {
    return this.world.timeStep;
  };
  OimoJSPlugin2.prototype.executeStep = function(delta, impostors) {
    var _this = this;
    impostors.forEach(function(impostor) {
      impostor.beforeStep();
    });
    this.world.timeStep = this._useDeltaForWorldStep ? delta : this._fixedTimeStep;
    this.world.step();
    impostors.forEach(function(impostor) {
      impostor.afterStep();
      _this._tmpImpostorsArray[impostor.uniqueId] = impostor;
    });
    var contact = this.world.contacts;
    while (contact !== null) {
      if (contact.touching && !contact.body1.sleeping && !contact.body2.sleeping) {
        contact = contact.next;
        continue;
      }
      var mainImpostor = this._tmpImpostorsArray[+contact.body1.name];
      var collidingImpostor = this._tmpImpostorsArray[+contact.body2.name];
      if (!mainImpostor || !collidingImpostor) {
        contact = contact.next;
        continue;
      }
      mainImpostor.onCollide({ body: collidingImpostor.physicsBody, point: null });
      collidingImpostor.onCollide({ body: mainImpostor.physicsBody, point: null });
      contact = contact.next;
    }
  };
  OimoJSPlugin2.prototype.applyImpulse = function(impostor, force, contactPoint) {
    var mass = impostor.physicsBody.mass;
    impostor.physicsBody.applyImpulse(contactPoint.scale(this.world.invScale), force.scale(this.world.invScale * mass));
  };
  OimoJSPlugin2.prototype.applyForce = function(impostor, force, contactPoint) {
    Logger.Warn("Oimo doesn't support applying force. Using impule instead.");
    this.applyImpulse(impostor, force, contactPoint);
  };
  OimoJSPlugin2.prototype.generatePhysicsBody = function(impostor) {
    var _this = this;
    if (impostor.parent) {
      if (impostor.physicsBody) {
        this.removePhysicsBody(impostor);
        impostor.forceUpdate();
      }
      return;
    }
    if (impostor.isBodyInitRequired()) {
      var bodyConfig = {
        name: impostor.uniqueId,
        config: [impostor.getParam("mass") || 1e-3, impostor.getParam("friction"), impostor.getParam("restitution")],
        size: [],
        type: [],
        pos: [],
        posShape: [],
        rot: [],
        rotShape: [],
        move: impostor.getParam("mass") !== 0,
        density: impostor.getParam("mass"),
        friction: impostor.getParam("friction"),
        restitution: impostor.getParam("restitution"),
        world: this.world
      };
      var impostors = [impostor];
      var addToArray = function(parent) {
        if (!parent.getChildMeshes) {
          return;
        }
        parent.getChildMeshes().forEach(function(m) {
          if (m.physicsImpostor) {
            impostors.push(m.physicsImpostor);
          }
        });
      };
      addToArray(impostor.object);
      var checkWithEpsilon_1 = function(value) {
        return Math.max(value, PhysicsEngine.Epsilon);
      };
      var globalQuaternion_1 = new Quaternion();
      impostors.forEach(function(i) {
        if (!i.object.rotationQuaternion) {
          return;
        }
        var oldQuaternion = i.object.rotationQuaternion;
        globalQuaternion_1.copyFrom(oldQuaternion);
        i.object.rotationQuaternion.set(0, 0, 0, 1);
        i.object.computeWorldMatrix(true);
        var rot = globalQuaternion_1.toEulerAngles();
        var extendSize = i.getObjectExtendSize();
        var radToDeg = 57.29577951308232;
        if (i === impostor) {
          var center = impostor.getObjectCenter();
          impostor.object.getAbsolutePivotPoint().subtractToRef(center, _this._tmpPositionVector);
          _this._tmpPositionVector.divideInPlace(impostor.object.scaling);
          bodyConfig.pos.push(center.x);
          bodyConfig.pos.push(center.y);
          bodyConfig.pos.push(center.z);
          bodyConfig.posShape.push(0, 0, 0);
          bodyConfig.rotShape.push(0, 0, 0);
        } else {
          var localPosition = i.object.position.clone();
          bodyConfig.posShape.push(localPosition.x);
          bodyConfig.posShape.push(localPosition.y);
          bodyConfig.posShape.push(localPosition.z);
          bodyConfig.rotShape.push(rot.x * radToDeg, rot.y * radToDeg, rot.z * radToDeg);
        }
        i.object.rotationQuaternion.copyFrom(globalQuaternion_1);
        switch (i.type) {
          case PhysicsImpostor.ParticleImpostor:
            Logger.Warn("No Particle support in OIMO.js. using SphereImpostor instead");
          case PhysicsImpostor.SphereImpostor:
            var radiusX = extendSize.x;
            var radiusY = extendSize.y;
            var radiusZ = extendSize.z;
            var size = Math.max(checkWithEpsilon_1(radiusX), checkWithEpsilon_1(radiusY), checkWithEpsilon_1(radiusZ)) / 2;
            bodyConfig.type.push("sphere");
            bodyConfig.size.push(size);
            bodyConfig.size.push(size);
            bodyConfig.size.push(size);
            break;
          case PhysicsImpostor.CylinderImpostor:
            var sizeX = checkWithEpsilon_1(extendSize.x) / 2;
            var sizeY = checkWithEpsilon_1(extendSize.y);
            bodyConfig.type.push("cylinder");
            bodyConfig.size.push(sizeX);
            bodyConfig.size.push(sizeY);
            bodyConfig.size.push(sizeY);
            break;
          case PhysicsImpostor.PlaneImpostor:
          case PhysicsImpostor.BoxImpostor:
          default:
            var sizeX = checkWithEpsilon_1(extendSize.x);
            var sizeY = checkWithEpsilon_1(extendSize.y);
            var sizeZ = checkWithEpsilon_1(extendSize.z);
            bodyConfig.type.push("box");
            bodyConfig.size.push(sizeX);
            bodyConfig.size.push(sizeY);
            bodyConfig.size.push(sizeZ);
            break;
        }
        i.object.rotationQuaternion = oldQuaternion;
      });
      impostor.physicsBody = this.world.add(bodyConfig);
      impostor.physicsBody.resetQuaternion(globalQuaternion_1);
      impostor.physicsBody.updatePosition(0);
    } else {
      this._tmpPositionVector.copyFromFloats(0, 0, 0);
    }
    impostor.setDeltaPosition(this._tmpPositionVector);
  };
  OimoJSPlugin2.prototype.removePhysicsBody = function(impostor) {
    this.world.removeRigidBody(impostor.physicsBody);
  };
  OimoJSPlugin2.prototype.generateJoint = function(impostorJoint) {
    var mainBody = impostorJoint.mainImpostor.physicsBody;
    var connectedBody = impostorJoint.connectedImpostor.physicsBody;
    if (!mainBody || !connectedBody) {
      return;
    }
    var jointData = impostorJoint.joint.jointData;
    var options = jointData.nativeParams || {};
    var type;
    var nativeJointData = {
      body1: mainBody,
      body2: connectedBody,
      axe1: options.axe1 || (jointData.mainAxis ? jointData.mainAxis.asArray() : null),
      axe2: options.axe2 || (jointData.connectedAxis ? jointData.connectedAxis.asArray() : null),
      pos1: options.pos1 || (jointData.mainPivot ? jointData.mainPivot.asArray() : null),
      pos2: options.pos2 || (jointData.connectedPivot ? jointData.connectedPivot.asArray() : null),
      min: options.min,
      max: options.max,
      collision: options.collision || jointData.collision,
      spring: options.spring,
      world: this.world
    };
    switch (impostorJoint.joint.type) {
      case PhysicsJoint.BallAndSocketJoint:
        type = "jointBall";
        break;
      case PhysicsJoint.SpringJoint:
        Logger.Warn("OIMO.js doesn't support Spring Constraint. Simulating using DistanceJoint instead");
        var springData = jointData;
        nativeJointData.min = springData.length || nativeJointData.min;
        nativeJointData.max = Math.max(nativeJointData.min, nativeJointData.max);
      case PhysicsJoint.DistanceJoint:
        type = "jointDistance";
        nativeJointData.max = jointData.maxDistance;
        break;
      case PhysicsJoint.PrismaticJoint:
        type = "jointPrisme";
        break;
      case PhysicsJoint.SliderJoint:
        type = "jointSlide";
        break;
      case PhysicsJoint.WheelJoint:
        type = "jointWheel";
        break;
      case PhysicsJoint.HingeJoint:
      default:
        type = "jointHinge";
        break;
    }
    nativeJointData.type = type;
    impostorJoint.joint.physicsJoint = this.world.add(nativeJointData);
  };
  OimoJSPlugin2.prototype.removeJoint = function(impostorJoint) {
    try {
      this.world.removeJoint(impostorJoint.joint.physicsJoint);
    } catch (e) {
      Logger.Warn(e);
    }
  };
  OimoJSPlugin2.prototype.isSupported = function() {
    return this.BJSOIMO !== void 0;
  };
  OimoJSPlugin2.prototype.setTransformationFromPhysicsBody = function(impostor) {
    if (!impostor.physicsBody.sleeping) {
      if (impostor.physicsBody.shapes.next) {
        var parent_1 = impostor.physicsBody.shapes;
        while (parent_1.next) {
          parent_1 = parent_1.next;
        }
        impostor.object.position.set(parent_1.position.x, parent_1.position.y, parent_1.position.z);
      } else {
        var pos = impostor.physicsBody.getPosition();
        impostor.object.position.set(pos.x, pos.y, pos.z);
      }
      if (impostor.object.rotationQuaternion) {
        var quat = impostor.physicsBody.getQuaternion();
        impostor.object.rotationQuaternion.set(quat.x, quat.y, quat.z, quat.w);
      }
    }
  };
  OimoJSPlugin2.prototype.setPhysicsBodyTransformation = function(impostor, newPosition, newRotation) {
    var body = impostor.physicsBody;
    if (impostor.physicsBody.shapes.next) {
      return;
    }
    body.position.set(newPosition.x, newPosition.y, newPosition.z);
    body.orientation.set(newRotation.x, newRotation.y, newRotation.z, newRotation.w);
    body.syncShapes();
    body.awake();
  };
  OimoJSPlugin2.prototype.setLinearVelocity = function(impostor, velocity) {
    impostor.physicsBody.linearVelocity.set(velocity.x, velocity.y, velocity.z);
  };
  OimoJSPlugin2.prototype.setAngularVelocity = function(impostor, velocity) {
    impostor.physicsBody.angularVelocity.set(velocity.x, velocity.y, velocity.z);
  };
  OimoJSPlugin2.prototype.getLinearVelocity = function(impostor) {
    var v = impostor.physicsBody.linearVelocity;
    if (!v) {
      return null;
    }
    return new Vector3(v.x, v.y, v.z);
  };
  OimoJSPlugin2.prototype.getAngularVelocity = function(impostor) {
    var v = impostor.physicsBody.angularVelocity;
    if (!v) {
      return null;
    }
    return new Vector3(v.x, v.y, v.z);
  };
  OimoJSPlugin2.prototype.setBodyMass = function(impostor, mass) {
    var staticBody = mass === 0;
    impostor.physicsBody.shapes.density = staticBody ? 1 : mass;
    impostor.physicsBody.setupMass(staticBody ? 2 : 1);
  };
  OimoJSPlugin2.prototype.getBodyMass = function(impostor) {
    return impostor.physicsBody.shapes.density;
  };
  OimoJSPlugin2.prototype.getBodyFriction = function(impostor) {
    return impostor.physicsBody.shapes.friction;
  };
  OimoJSPlugin2.prototype.setBodyFriction = function(impostor, friction) {
    impostor.physicsBody.shapes.friction = friction;
  };
  OimoJSPlugin2.prototype.getBodyRestitution = function(impostor) {
    return impostor.physicsBody.shapes.restitution;
  };
  OimoJSPlugin2.prototype.setBodyRestitution = function(impostor, restitution) {
    impostor.physicsBody.shapes.restitution = restitution;
  };
  OimoJSPlugin2.prototype.sleepBody = function(impostor) {
    impostor.physicsBody.sleep();
  };
  OimoJSPlugin2.prototype.wakeUpBody = function(impostor) {
    impostor.physicsBody.awake();
  };
  OimoJSPlugin2.prototype.updateDistanceJoint = function(joint, maxDistance, minDistance) {
    joint.physicsJoint.limitMotor.upperLimit = maxDistance;
    if (minDistance !== void 0) {
      joint.physicsJoint.limitMotor.lowerLimit = minDistance;
    }
  };
  OimoJSPlugin2.prototype.setMotor = function(joint, speed, force, motorIndex) {
    if (force !== void 0) {
      Logger.Warn("OimoJS plugin currently has unexpected behavior when using setMotor with force parameter");
    } else {
      force = 1e6;
    }
    speed *= -1;
    var motor = motorIndex ? joint.physicsJoint.rotationalLimitMotor2 : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;
    if (motor) {
      motor.setMotor(speed, force);
    }
  };
  OimoJSPlugin2.prototype.setLimit = function(joint, upperLimit, lowerLimit, motorIndex) {
    var motor = motorIndex ? joint.physicsJoint.rotationalLimitMotor2 : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;
    if (motor) {
      motor.setLimit(upperLimit, lowerLimit === void 0 ? -upperLimit : lowerLimit);
    }
  };
  OimoJSPlugin2.prototype.syncMeshWithImpostor = function(mesh, impostor) {
    var body = impostor.physicsBody;
    mesh.position.x = body.position.x;
    mesh.position.y = body.position.y;
    mesh.position.z = body.position.z;
    if (mesh.rotationQuaternion) {
      mesh.rotationQuaternion.x = body.orientation.x;
      mesh.rotationQuaternion.y = body.orientation.y;
      mesh.rotationQuaternion.z = body.orientation.z;
      mesh.rotationQuaternion.w = body.orientation.s;
    }
  };
  OimoJSPlugin2.prototype.getRadius = function(impostor) {
    return impostor.physicsBody.shapes.radius;
  };
  OimoJSPlugin2.prototype.getBoxSizeToRef = function(impostor, result) {
    var shape = impostor.physicsBody.shapes;
    result.x = shape.halfWidth * 2;
    result.y = shape.halfHeight * 2;
    result.z = shape.halfDepth * 2;
  };
  OimoJSPlugin2.prototype.dispose = function() {
    this.world.clear();
  };
  OimoJSPlugin2.prototype.raycast = function(from, to) {
    Logger.Warn("raycast is not currently supported by the Oimo physics plugin");
    this._raycastResult.reset(from, to);
    return this._raycastResult;
  };
  return OimoJSPlugin2;
}();

// node_modules/@babylonjs/core/Physics/Plugins/ammoJSPlugin.js
var AmmoJSPlugin = function() {
  function AmmoJSPlugin2(_useDeltaForWorldStep, ammoInjection, overlappingPairCache) {
    var _this = this;
    if (_useDeltaForWorldStep === void 0) {
      _useDeltaForWorldStep = true;
    }
    if (ammoInjection === void 0) {
      ammoInjection = Ammo;
    }
    if (overlappingPairCache === void 0) {
      overlappingPairCache = null;
    }
    this._useDeltaForWorldStep = _useDeltaForWorldStep;
    this.bjsAMMO = {};
    this.name = "AmmoJSPlugin";
    this._timeStep = 1 / 60;
    this._fixedTimeStep = 1 / 60;
    this._maxSteps = 5;
    this._tmpQuaternion = new Quaternion();
    this._tmpContactCallbackResult = false;
    this._tmpContactPoint = new Vector3();
    this._tmpMatrix = new Matrix();
    if (typeof ammoInjection === "function") {
      ammoInjection(this.bjsAMMO);
    } else {
      this.bjsAMMO = ammoInjection;
    }
    if (!this.isSupported()) {
      Logger.Error("AmmoJS is not available. Please make sure you included the js file.");
      return;
    }
    this._collisionConfiguration = new this.bjsAMMO.btSoftBodyRigidBodyCollisionConfiguration();
    this._dispatcher = new this.bjsAMMO.btCollisionDispatcher(this._collisionConfiguration);
    this._overlappingPairCache = overlappingPairCache || new this.bjsAMMO.btDbvtBroadphase();
    this._solver = new this.bjsAMMO.btSequentialImpulseConstraintSolver();
    this._softBodySolver = new this.bjsAMMO.btDefaultSoftBodySolver();
    this.world = new this.bjsAMMO.btSoftRigidDynamicsWorld(this._dispatcher, this._overlappingPairCache, this._solver, this._collisionConfiguration, this._softBodySolver);
    this._tmpAmmoConcreteContactResultCallback = new this.bjsAMMO.ConcreteContactResultCallback();
    this._tmpAmmoConcreteContactResultCallback.addSingleResult = function(contactPoint, colObj0Wrap, partId0, index0) {
      contactPoint = _this.bjsAMMO.wrapPointer(contactPoint, Ammo.btManifoldPoint);
      var worldPoint = contactPoint.getPositionWorldOnA();
      _this._tmpContactPoint.x = worldPoint.x();
      _this._tmpContactPoint.y = worldPoint.y();
      _this._tmpContactPoint.z = worldPoint.z();
      _this._tmpContactCallbackResult = true;
    };
    this._raycastResult = new PhysicsRaycastResult();
    this._tmpAmmoTransform = new this.bjsAMMO.btTransform();
    this._tmpAmmoTransform.setIdentity();
    this._tmpAmmoQuaternion = new this.bjsAMMO.btQuaternion(0, 0, 0, 1);
    this._tmpAmmoVectorA = new this.bjsAMMO.btVector3(0, 0, 0);
    this._tmpAmmoVectorB = new this.bjsAMMO.btVector3(0, 0, 0);
    this._tmpAmmoVectorC = new this.bjsAMMO.btVector3(0, 0, 0);
    this._tmpAmmoVectorD = new this.bjsAMMO.btVector3(0, 0, 0);
  }
  AmmoJSPlugin2.prototype.setGravity = function(gravity) {
    this._tmpAmmoVectorA.setValue(gravity.x, gravity.y, gravity.z);
    this.world.setGravity(this._tmpAmmoVectorA);
    this.world.getWorldInfo().set_m_gravity(this._tmpAmmoVectorA);
  };
  AmmoJSPlugin2.prototype.setTimeStep = function(timeStep) {
    this._timeStep = timeStep;
  };
  AmmoJSPlugin2.prototype.setFixedTimeStep = function(fixedTimeStep) {
    this._fixedTimeStep = fixedTimeStep;
  };
  AmmoJSPlugin2.prototype.setMaxSteps = function(maxSteps) {
    this._maxSteps = maxSteps;
  };
  AmmoJSPlugin2.prototype.getTimeStep = function() {
    return this._timeStep;
  };
  AmmoJSPlugin2.prototype._isImpostorInContact = function(impostor) {
    this._tmpContactCallbackResult = false;
    this.world.contactTest(impostor.physicsBody, this._tmpAmmoConcreteContactResultCallback);
    return this._tmpContactCallbackResult;
  };
  AmmoJSPlugin2.prototype._isImpostorPairInContact = function(impostorA, impostorB) {
    this._tmpContactCallbackResult = false;
    this.world.contactPairTest(impostorA.physicsBody, impostorB.physicsBody, this._tmpAmmoConcreteContactResultCallback);
    return this._tmpContactCallbackResult;
  };
  AmmoJSPlugin2.prototype._stepSimulation = function(timeStep, maxSteps, fixedTimeStep) {
    if (timeStep === void 0) {
      timeStep = 1 / 60;
    }
    if (maxSteps === void 0) {
      maxSteps = 10;
    }
    if (fixedTimeStep === void 0) {
      fixedTimeStep = 1 / 60;
    }
    if (maxSteps == 0) {
      this.world.stepSimulation(timeStep, 0);
    } else {
      while (maxSteps > 0 && timeStep > 0) {
        if (timeStep - fixedTimeStep < fixedTimeStep) {
          this.world.stepSimulation(timeStep, 0);
          timeStep = 0;
        } else {
          timeStep -= fixedTimeStep;
          this.world.stepSimulation(fixedTimeStep, 0);
        }
        maxSteps--;
      }
    }
  };
  AmmoJSPlugin2.prototype.executeStep = function(delta, impostors) {
    for (var _i = 0, impostors_1 = impostors; _i < impostors_1.length; _i++) {
      var impostor = impostors_1[_i];
      if (!impostor.soft) {
        impostor.beforeStep();
      }
    }
    this._stepSimulation(this._useDeltaForWorldStep ? delta : this._timeStep, this._maxSteps, this._fixedTimeStep);
    for (var _a = 0, impostors_2 = impostors; _a < impostors_2.length; _a++) {
      var mainImpostor = impostors_2[_a];
      if (mainImpostor.soft) {
        this._afterSoftStep(mainImpostor);
      } else {
        mainImpostor.afterStep();
      }
      if (mainImpostor._onPhysicsCollideCallbacks.length > 0) {
        if (this._isImpostorInContact(mainImpostor)) {
          for (var _b = 0, _c = mainImpostor._onPhysicsCollideCallbacks; _b < _c.length; _b++) {
            var collideCallback = _c[_b];
            for (var _d = 0, _e = collideCallback.otherImpostors; _d < _e.length; _d++) {
              var otherImpostor = _e[_d];
              if (mainImpostor.physicsBody.isActive() || otherImpostor.physicsBody.isActive()) {
                if (this._isImpostorPairInContact(mainImpostor, otherImpostor)) {
                  mainImpostor.onCollide({ body: otherImpostor.physicsBody, point: this._tmpContactPoint });
                  otherImpostor.onCollide({ body: mainImpostor.physicsBody, point: this._tmpContactPoint });
                }
              }
            }
          }
        }
      }
    }
  };
  AmmoJSPlugin2.prototype._afterSoftStep = function(impostor) {
    if (impostor.type === PhysicsImpostor.RopeImpostor) {
      this._ropeStep(impostor);
    } else {
      this._softbodyOrClothStep(impostor);
    }
  };
  AmmoJSPlugin2.prototype._ropeStep = function(impostor) {
    var bodyVertices = impostor.physicsBody.get_m_nodes();
    var nbVertices = bodyVertices.size();
    var node;
    var nodePositions;
    var x, y, z;
    var path = new Array();
    for (var n = 0; n < nbVertices; n++) {
      node = bodyVertices.at(n);
      nodePositions = node.get_m_x();
      x = nodePositions.x();
      y = nodePositions.y();
      z = nodePositions.z();
      path.push(new Vector3(x, y, z));
    }
    var object = impostor.object;
    var shape = impostor.getParam("shape");
    if (impostor._isFromLine) {
      impostor.object = LinesBuilder.CreateLines("lines", { points: path, instance: object });
    } else {
      impostor.object = ShapeBuilder.ExtrudeShape("ext", { shape, path, instance: object });
    }
  };
  AmmoJSPlugin2.prototype._softbodyOrClothStep = function(impostor) {
    var normalDirection = impostor.type === PhysicsImpostor.ClothImpostor ? 1 : -1;
    var object = impostor.object;
    var vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);
    if (!vertexPositions) {
      vertexPositions = [];
    }
    var vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);
    if (!vertexNormals) {
      vertexNormals = [];
    }
    var nbVertices = vertexPositions.length / 3;
    var bodyVertices = impostor.physicsBody.get_m_nodes();
    var node;
    var nodePositions;
    var nodeNormals;
    var x, y, z;
    var nx, ny, nz;
    for (var n = 0; n < nbVertices; n++) {
      node = bodyVertices.at(n);
      nodePositions = node.get_m_x();
      x = nodePositions.x();
      y = nodePositions.y();
      z = nodePositions.z() * normalDirection;
      var nodeNormals = node.get_m_n();
      nx = nodeNormals.x();
      ny = nodeNormals.y();
      nz = nodeNormals.z() * normalDirection;
      vertexPositions[3 * n] = x;
      vertexPositions[3 * n + 1] = y;
      vertexPositions[3 * n + 2] = z;
      vertexNormals[3 * n] = nx;
      vertexNormals[3 * n + 1] = ny;
      vertexNormals[3 * n + 2] = nz;
    }
    var vertex_data = new VertexData();
    vertex_data.positions = vertexPositions;
    vertex_data.normals = vertexNormals;
    vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);
    vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);
    if (object && object.getIndices) {
      vertex_data.indices = object.getIndices();
    }
    vertex_data.applyToMesh(object);
  };
  AmmoJSPlugin2.prototype.applyImpulse = function(impostor, force, contactPoint) {
    if (!impostor.soft) {
      impostor.physicsBody.activate();
      var worldPoint = this._tmpAmmoVectorA;
      var impulse = this._tmpAmmoVectorB;
      if (impostor.object && impostor.object.getWorldMatrix) {
        contactPoint.subtractInPlace(impostor.object.getWorldMatrix().getTranslation());
      }
      worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);
      impulse.setValue(force.x, force.y, force.z);
      impostor.physicsBody.applyImpulse(impulse, worldPoint);
    } else {
      Logger.Warn("Cannot be applied to a soft body");
    }
  };
  AmmoJSPlugin2.prototype.applyForce = function(impostor, force, contactPoint) {
    if (!impostor.soft) {
      impostor.physicsBody.activate();
      var worldPoint = this._tmpAmmoVectorA;
      var impulse = this._tmpAmmoVectorB;
      if (impostor.object && impostor.object.getWorldMatrix) {
        contactPoint.subtractInPlace(impostor.object.getWorldMatrix().getTranslation());
      }
      worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);
      impulse.setValue(force.x, force.y, force.z);
      impostor.physicsBody.applyForce(impulse, worldPoint);
    } else {
      Logger.Warn("Cannot be applied to a soft body");
    }
  };
  AmmoJSPlugin2.prototype.generatePhysicsBody = function(impostor) {
    impostor._pluginData.toDispose = [];
    if (impostor.parent) {
      if (impostor.physicsBody) {
        this.removePhysicsBody(impostor);
        impostor.forceUpdate();
      }
      return;
    }
    if (impostor.isBodyInitRequired()) {
      var colShape = this._createShape(impostor);
      var mass = impostor.getParam("mass");
      impostor._pluginData.mass = mass;
      if (impostor.soft) {
        colShape.get_m_cfg().set_collisions(17);
        colShape.get_m_cfg().set_kDP(impostor.getParam("damping"));
        this.bjsAMMO.castObject(colShape, this.bjsAMMO.btCollisionObject).getCollisionShape().setMargin(impostor.getParam("margin"));
        colShape.setActivationState(AmmoJSPlugin2.DISABLE_DEACTIVATION_FLAG);
        this.world.addSoftBody(colShape, 1, -1);
        impostor.physicsBody = colShape;
        impostor._pluginData.toDispose.push(colShape);
        this.setBodyPressure(impostor, 0);
        if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {
          this.setBodyPressure(impostor, impostor.getParam("pressure"));
        }
        this.setBodyStiffness(impostor, impostor.getParam("stiffness"));
        this.setBodyVelocityIterations(impostor, impostor.getParam("velocityIterations"));
        this.setBodyPositionIterations(impostor, impostor.getParam("positionIterations"));
      } else {
        var localInertia = new this.bjsAMMO.btVector3(0, 0, 0);
        var startTransform = new this.bjsAMMO.btTransform();
        startTransform.setIdentity();
        if (mass !== 0) {
          colShape.calculateLocalInertia(mass, localInertia);
        }
        this._tmpAmmoVectorA.setValue(impostor.object.position.x, impostor.object.position.y, impostor.object.position.z);
        this._tmpAmmoQuaternion.setValue(impostor.object.rotationQuaternion.x, impostor.object.rotationQuaternion.y, impostor.object.rotationQuaternion.z, impostor.object.rotationQuaternion.w);
        startTransform.setOrigin(this._tmpAmmoVectorA);
        startTransform.setRotation(this._tmpAmmoQuaternion);
        var myMotionState = new this.bjsAMMO.btDefaultMotionState(startTransform);
        var rbInfo = new this.bjsAMMO.btRigidBodyConstructionInfo(mass, myMotionState, colShape, localInertia);
        var body = new this.bjsAMMO.btRigidBody(rbInfo);
        if (mass === 0) {
          body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin2.KINEMATIC_FLAG);
          body.setActivationState(AmmoJSPlugin2.DISABLE_DEACTIVATION_FLAG);
        }
        if (impostor.type == PhysicsImpostor.NoImpostor && !colShape.getChildShape) {
          body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin2.DISABLE_COLLISION_FLAG);
        }
        var group = impostor.getParam("group");
        var mask = impostor.getParam("mask");
        if (group && mask) {
          this.world.addRigidBody(body, group, mask);
        } else {
          this.world.addRigidBody(body);
        }
        impostor.physicsBody = body;
        impostor._pluginData.toDispose = impostor._pluginData.toDispose.concat([body, rbInfo, myMotionState, startTransform, localInertia, colShape]);
      }
      this.setBodyRestitution(impostor, impostor.getParam("restitution"));
      this.setBodyFriction(impostor, impostor.getParam("friction"));
    }
  };
  AmmoJSPlugin2.prototype.removePhysicsBody = function(impostor) {
    var _this = this;
    if (this.world) {
      if (impostor.soft) {
        this.world.removeSoftBody(impostor.physicsBody);
      } else {
        this.world.removeRigidBody(impostor.physicsBody);
      }
      if (impostor._pluginData) {
        impostor._pluginData.toDispose.forEach(function(d) {
          _this.bjsAMMO.destroy(d);
        });
        impostor._pluginData.toDispose = [];
      }
    }
  };
  AmmoJSPlugin2.prototype.generateJoint = function(impostorJoint) {
    var mainBody = impostorJoint.mainImpostor.physicsBody;
    var connectedBody = impostorJoint.connectedImpostor.physicsBody;
    if (!mainBody || !connectedBody) {
      return;
    }
    var jointData = impostorJoint.joint.jointData;
    if (!jointData.mainPivot) {
      jointData.mainPivot = new Vector3(0, 0, 0);
    }
    if (!jointData.connectedPivot) {
      jointData.connectedPivot = new Vector3(0, 0, 0);
    }
    var joint;
    switch (impostorJoint.joint.type) {
      case PhysicsJoint.DistanceJoint:
        var distance = jointData.maxDistance;
        if (distance) {
          jointData.mainPivot = new Vector3(0, -distance / 2, 0);
          jointData.connectedPivot = new Vector3(0, distance / 2, 0);
        }
        joint = new this.bjsAMMO.btPoint2PointConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));
        break;
      case PhysicsJoint.HingeJoint:
        if (!jointData.mainAxis) {
          jointData.mainAxis = new Vector3(0, 0, 0);
        }
        if (!jointData.connectedAxis) {
          jointData.connectedAxis = new Vector3(0, 0, 0);
        }
        var mainAxis = new this.bjsAMMO.btVector3(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z);
        var connectedAxis = new this.bjsAMMO.btVector3(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z);
        joint = new this.bjsAMMO.btHingeConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z), mainAxis, connectedAxis);
        break;
      case PhysicsJoint.BallAndSocketJoint:
        joint = new this.bjsAMMO.btPoint2PointConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));
        break;
      default:
        Logger.Warn("JointType not currently supported by the Ammo plugin, falling back to PhysicsJoint.BallAndSocketJoint");
        joint = new this.bjsAMMO.btPoint2PointConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));
        break;
    }
    this.world.addConstraint(joint, !impostorJoint.joint.jointData.collision);
    impostorJoint.joint.physicsJoint = joint;
  };
  AmmoJSPlugin2.prototype.removeJoint = function(impostorJoint) {
    if (this.world) {
      this.world.removeConstraint(impostorJoint.joint.physicsJoint);
    }
  };
  AmmoJSPlugin2.prototype._addMeshVerts = function(btTriangleMesh, topLevelObject, object) {
    var _this = this;
    var triangleCount = 0;
    if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {
      var indices = object.getIndices();
      if (!indices) {
        indices = [];
      }
      var vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);
      if (!vertexPositions) {
        vertexPositions = [];
      }
      object.computeWorldMatrix(false);
      var faceCount = indices.length / 3;
      for (var i = 0; i < faceCount; i++) {
        var triPoints = [];
        for (var point = 0; point < 3; point++) {
          var v = new Vector3(vertexPositions[indices[i * 3 + point] * 3 + 0], vertexPositions[indices[i * 3 + point] * 3 + 1], vertexPositions[indices[i * 3 + point] * 3 + 2]);
          Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);
          v = Vector3.TransformCoordinates(v, this._tmpMatrix);
          var vec;
          if (point == 0) {
            vec = this._tmpAmmoVectorA;
          } else if (point == 1) {
            vec = this._tmpAmmoVectorB;
          } else {
            vec = this._tmpAmmoVectorC;
          }
          vec.setValue(v.x, v.y, v.z);
          triPoints.push(vec);
        }
        btTriangleMesh.addTriangle(triPoints[0], triPoints[1], triPoints[2]);
        triangleCount++;
      }
      object.getChildMeshes().forEach(function(m) {
        triangleCount += _this._addMeshVerts(btTriangleMesh, topLevelObject, m);
      });
    }
    return triangleCount;
  };
  AmmoJSPlugin2.prototype._softVertexData = function(impostor) {
    var object = impostor.object;
    if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {
      var indices = object.getIndices();
      if (!indices) {
        indices = [];
      }
      var vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);
      if (!vertexPositions) {
        vertexPositions = [];
      }
      var vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);
      if (!vertexNormals) {
        vertexNormals = [];
      }
      object.computeWorldMatrix(false);
      var newPoints = [];
      var newNorms = [];
      for (var i = 0; i < vertexPositions.length; i += 3) {
        var v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);
        var n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);
        v = Vector3.TransformCoordinates(v, object.getWorldMatrix());
        n = Vector3.TransformNormal(n, object.getWorldMatrix());
        newPoints.push(v.x, v.y, v.z);
        newNorms.push(n.x, n.y, n.z);
      }
      var vertex_data = new VertexData();
      vertex_data.positions = newPoints;
      vertex_data.normals = newNorms;
      vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);
      vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);
      if (object && object.getIndices) {
        vertex_data.indices = object.getIndices();
      }
      vertex_data.applyToMesh(object);
      object.position = Vector3.Zero();
      object.rotationQuaternion = null;
      object.rotation = Vector3.Zero();
      object.computeWorldMatrix(true);
      return vertex_data;
    }
    return VertexData.ExtractFromMesh(object);
  };
  AmmoJSPlugin2.prototype._createSoftbody = function(impostor) {
    var object = impostor.object;
    if (object && object.getIndices) {
      var indices = object.getIndices();
      if (!indices) {
        indices = [];
      }
      var vertex_data = this._softVertexData(impostor);
      var vertexPositions = vertex_data.positions;
      var vertexNormals = vertex_data.normals;
      if (vertexPositions === null || vertexNormals === null) {
        return new this.bjsAMMO.btCompoundShape();
      } else {
        var triPoints = [];
        var triNorms = [];
        for (var i = 0; i < vertexPositions.length; i += 3) {
          var v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);
          var n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);
          triPoints.push(v.x, v.y, -v.z);
          triNorms.push(n.x, n.y, -n.z);
        }
        var softBody = new this.bjsAMMO.btSoftBodyHelpers().CreateFromTriMesh(this.world.getWorldInfo(), triPoints, object.getIndices(), indices.length / 3, true);
        var nbVertices = vertexPositions.length / 3;
        var bodyVertices = softBody.get_m_nodes();
        var node;
        var nodeNormals;
        for (var i = 0; i < nbVertices; i++) {
          node = bodyVertices.at(i);
          var nodeNormals = node.get_m_n();
          nodeNormals.setX(triNorms[3 * i]);
          nodeNormals.setY(triNorms[3 * i + 1]);
          nodeNormals.setZ(triNorms[3 * i + 2]);
        }
        return softBody;
      }
    }
  };
  AmmoJSPlugin2.prototype._createCloth = function(impostor) {
    var object = impostor.object;
    if (object && object.getIndices) {
      var indices = object.getIndices();
      if (!indices) {
        indices = [];
      }
      var vertex_data = this._softVertexData(impostor);
      var vertexPositions = vertex_data.positions;
      var vertexNormals = vertex_data.normals;
      if (vertexPositions === null || vertexNormals === null) {
        return new this.bjsAMMO.btCompoundShape();
      } else {
        var len = vertexPositions.length;
        var segments = Math.sqrt(len / 3);
        impostor.segments = segments;
        var segs = segments - 1;
        this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);
        this._tmpAmmoVectorB.setValue(vertexPositions[3 * segs], vertexPositions[3 * segs + 1], vertexPositions[3 * segs + 2]);
        this._tmpAmmoVectorD.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);
        this._tmpAmmoVectorC.setValue(vertexPositions[len - 3 - 3 * segs], vertexPositions[len - 2 - 3 * segs], vertexPositions[len - 1 - 3 * segs]);
        var clothBody = new this.bjsAMMO.btSoftBodyHelpers().CreatePatch(this.world.getWorldInfo(), this._tmpAmmoVectorA, this._tmpAmmoVectorB, this._tmpAmmoVectorC, this._tmpAmmoVectorD, segments, segments, impostor.getParam("fixedPoints"), true);
        return clothBody;
      }
    }
  };
  AmmoJSPlugin2.prototype._createRope = function(impostor) {
    var len;
    var segments;
    var vertex_data = this._softVertexData(impostor);
    var vertexPositions = vertex_data.positions;
    var vertexNormals = vertex_data.normals;
    if (vertexPositions === null || vertexNormals === null) {
      return new this.bjsAMMO.btCompoundShape();
    }
    vertex_data.applyToMesh(impostor.object, true);
    impostor._isFromLine = true;
    var vertexSquared = vertexNormals.map(function(x) {
      return x * x;
    });
    var reducer = function(accumulator, currentValue) {
      return accumulator + currentValue;
    };
    var reduced = vertexSquared.reduce(reducer);
    if (reduced === 0) {
      len = vertexPositions.length;
      segments = len / 3 - 1;
      this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);
      this._tmpAmmoVectorB.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);
    } else {
      impostor._isFromLine = false;
      var pathVectors = impostor.getParam("path");
      var shape = impostor.getParam("shape");
      if (shape === null) {
        Logger.Warn("No shape available for extruded mesh");
        return new this.bjsAMMO.btCompoundShape();
      }
      if (vertexPositions.length % (3 * pathVectors.length) !== 0) {
        Logger.Warn("Path does not match extrusion");
        return new this.bjsAMMO.btCompoundShape();
      }
      len = pathVectors.length;
      segments = len - 1;
      this._tmpAmmoVectorA.setValue(pathVectors[0].x, pathVectors[0].y, pathVectors[0].z);
      this._tmpAmmoVectorB.setValue(pathVectors[len - 1].x, pathVectors[len - 1].y, pathVectors[len - 1].z);
    }
    impostor.segments = segments;
    var fixedPoints = impostor.getParam("fixedPoints");
    fixedPoints = fixedPoints > 3 ? 3 : fixedPoints;
    var ropeBody = new this.bjsAMMO.btSoftBodyHelpers().CreateRope(this.world.getWorldInfo(), this._tmpAmmoVectorA, this._tmpAmmoVectorB, segments - 1, fixedPoints);
    ropeBody.get_m_cfg().set_collisions(17);
    return ropeBody;
  };
  AmmoJSPlugin2.prototype._createCustom = function(impostor) {
    var returnValue = null;
    if (this.onCreateCustomShape) {
      returnValue = this.onCreateCustomShape(impostor);
    }
    if (returnValue == null) {
      returnValue = new this.bjsAMMO.btCompoundShape();
    }
    return returnValue;
  };
  AmmoJSPlugin2.prototype._addHullVerts = function(btConvexHullShape, topLevelObject, object) {
    var _this = this;
    var triangleCount = 0;
    if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {
      var indices = object.getIndices();
      if (!indices) {
        indices = [];
      }
      var vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);
      if (!vertexPositions) {
        vertexPositions = [];
      }
      object.computeWorldMatrix(false);
      var faceCount = indices.length / 3;
      for (var i = 0; i < faceCount; i++) {
        var triPoints = [];
        for (var point = 0; point < 3; point++) {
          var v = new Vector3(vertexPositions[indices[i * 3 + point] * 3 + 0], vertexPositions[indices[i * 3 + point] * 3 + 1], vertexPositions[indices[i * 3 + point] * 3 + 2]);
          Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);
          v = Vector3.TransformCoordinates(v, this._tmpMatrix);
          var vec;
          if (point == 0) {
            vec = this._tmpAmmoVectorA;
          } else if (point == 1) {
            vec = this._tmpAmmoVectorB;
          } else {
            vec = this._tmpAmmoVectorC;
          }
          vec.setValue(v.x, v.y, v.z);
          triPoints.push(vec);
        }
        btConvexHullShape.addPoint(triPoints[0], true);
        btConvexHullShape.addPoint(triPoints[1], true);
        btConvexHullShape.addPoint(triPoints[2], true);
        triangleCount++;
      }
      object.getChildMeshes().forEach(function(m) {
        triangleCount += _this._addHullVerts(btConvexHullShape, topLevelObject, m);
      });
    }
    return triangleCount;
  };
  AmmoJSPlugin2.prototype._createShape = function(impostor, ignoreChildren) {
    var _this = this;
    if (ignoreChildren === void 0) {
      ignoreChildren = false;
    }
    var object = impostor.object;
    var returnValue;
    var extendSize = impostor.getObjectExtendSize();
    if (!ignoreChildren) {
      var meshChildren = impostor.object.getChildMeshes ? impostor.object.getChildMeshes(true) : [];
      returnValue = new this.bjsAMMO.btCompoundShape();
      var childrenAdded = 0;
      meshChildren.forEach(function(childMesh) {
        var childImpostor = childMesh.getPhysicsImpostor();
        if (childImpostor) {
          if (childImpostor.type == PhysicsImpostor.MeshImpostor) {
            throw "A child MeshImpostor is not supported. Only primitive impostors are supported as children (eg. box or sphere)";
          }
          var shape2 = _this._createShape(childImpostor);
          var parentMat = childMesh.parent.getWorldMatrix().clone();
          var s = new Vector3();
          parentMat.decompose(s);
          _this._tmpAmmoTransform.getOrigin().setValue(childMesh.position.x * s.x, childMesh.position.y * s.y, childMesh.position.z * s.z);
          _this._tmpAmmoQuaternion.setValue(childMesh.rotationQuaternion.x, childMesh.rotationQuaternion.y, childMesh.rotationQuaternion.z, childMesh.rotationQuaternion.w);
          _this._tmpAmmoTransform.setRotation(_this._tmpAmmoQuaternion);
          returnValue.addChildShape(_this._tmpAmmoTransform, shape2);
          childImpostor.dispose();
          childrenAdded++;
        }
      });
      if (childrenAdded > 0) {
        if (impostor.type != PhysicsImpostor.NoImpostor) {
          var shape = this._createShape(impostor, true);
          if (shape) {
            this._tmpAmmoTransform.getOrigin().setValue(0, 0, 0);
            this._tmpAmmoQuaternion.setValue(0, 0, 0, 1);
            this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion);
            returnValue.addChildShape(this._tmpAmmoTransform, shape);
          }
        }
        return returnValue;
      } else {
        this.bjsAMMO.destroy(returnValue);
        returnValue = null;
      }
    }
    switch (impostor.type) {
      case PhysicsImpostor.SphereImpostor:
        if (Scalar.WithinEpsilon(extendSize.x, extendSize.y, 1e-4) && Scalar.WithinEpsilon(extendSize.x, extendSize.z, 1e-4)) {
          returnValue = new this.bjsAMMO.btSphereShape(extendSize.x / 2);
        } else {
          var positions = [new this.bjsAMMO.btVector3(0, 0, 0)];
          var radii = [1];
          returnValue = new this.bjsAMMO.btMultiSphereShape(positions, radii, 1);
          returnValue.setLocalScaling(new this.bjsAMMO.btVector3(extendSize.x / 2, extendSize.y / 2, extendSize.z / 2));
        }
        break;
      case PhysicsImpostor.CapsuleImpostor:
        returnValue = new this.bjsAMMO.btCapsuleShape(extendSize.x / 2, extendSize.y / 2);
        break;
      case PhysicsImpostor.CylinderImpostor:
        this._tmpAmmoVectorA.setValue(extendSize.x / 2, extendSize.y / 2, extendSize.z / 2);
        returnValue = new this.bjsAMMO.btCylinderShape(this._tmpAmmoVectorA);
        break;
      case PhysicsImpostor.PlaneImpostor:
      case PhysicsImpostor.BoxImpostor:
        this._tmpAmmoVectorA.setValue(extendSize.x / 2, extendSize.y / 2, extendSize.z / 2);
        returnValue = new this.bjsAMMO.btBoxShape(this._tmpAmmoVectorA);
        break;
      case PhysicsImpostor.MeshImpostor:
        if (impostor.getParam("mass") == 0) {
          var tetraMesh = new this.bjsAMMO.btTriangleMesh();
          impostor._pluginData.toDispose.push(tetraMesh);
          var triangeCount = this._addMeshVerts(tetraMesh, object, object);
          if (triangeCount == 0) {
            returnValue = new this.bjsAMMO.btCompoundShape();
          } else {
            returnValue = new this.bjsAMMO.btBvhTriangleMeshShape(tetraMesh);
          }
          break;
        }
      case PhysicsImpostor.ConvexHullImpostor:
        var convexMesh = new this.bjsAMMO.btConvexHullShape();
        var triangeCount = this._addHullVerts(convexMesh, object, object);
        if (triangeCount == 0) {
          impostor._pluginData.toDispose.push(convexMesh);
          returnValue = new this.bjsAMMO.btCompoundShape();
        } else {
          returnValue = convexMesh;
        }
        break;
      case PhysicsImpostor.NoImpostor:
        returnValue = new this.bjsAMMO.btSphereShape(extendSize.x / 2);
        break;
      case PhysicsImpostor.CustomImpostor:
        returnValue = this._createCustom(impostor);
        break;
      case PhysicsImpostor.SoftbodyImpostor:
        returnValue = this._createSoftbody(impostor);
        break;
      case PhysicsImpostor.ClothImpostor:
        returnValue = this._createCloth(impostor);
        break;
      case PhysicsImpostor.RopeImpostor:
        returnValue = this._createRope(impostor);
        break;
      default:
        Logger.Warn("The impostor type is not currently supported by the ammo plugin.");
        break;
    }
    return returnValue;
  };
  AmmoJSPlugin2.prototype.setTransformationFromPhysicsBody = function(impostor) {
    impostor.physicsBody.getMotionState().getWorldTransform(this._tmpAmmoTransform);
    impostor.object.position.set(this._tmpAmmoTransform.getOrigin().x(), this._tmpAmmoTransform.getOrigin().y(), this._tmpAmmoTransform.getOrigin().z());
    if (!impostor.object.rotationQuaternion) {
      if (impostor.object.rotation) {
        this._tmpQuaternion.set(this._tmpAmmoTransform.getRotation().x(), this._tmpAmmoTransform.getRotation().y(), this._tmpAmmoTransform.getRotation().z(), this._tmpAmmoTransform.getRotation().w());
        this._tmpQuaternion.toEulerAnglesToRef(impostor.object.rotation);
      }
    } else {
      impostor.object.rotationQuaternion.set(this._tmpAmmoTransform.getRotation().x(), this._tmpAmmoTransform.getRotation().y(), this._tmpAmmoTransform.getRotation().z(), this._tmpAmmoTransform.getRotation().w());
    }
  };
  AmmoJSPlugin2.prototype.setPhysicsBodyTransformation = function(impostor, newPosition, newRotation) {
    var trans = impostor.physicsBody.getWorldTransform();
    if (Math.abs(trans.getOrigin().x() - newPosition.x) > Epsilon || Math.abs(trans.getOrigin().y() - newPosition.y) > Epsilon || Math.abs(trans.getOrigin().z() - newPosition.z) > Epsilon || Math.abs(trans.getRotation().x() - newRotation.x) > Epsilon || Math.abs(trans.getRotation().y() - newRotation.y) > Epsilon || Math.abs(trans.getRotation().z() - newRotation.z) > Epsilon || Math.abs(trans.getRotation().w() - newRotation.w) > Epsilon) {
      this._tmpAmmoVectorA.setValue(newPosition.x, newPosition.y, newPosition.z);
      trans.setOrigin(this._tmpAmmoVectorA);
      this._tmpAmmoQuaternion.setValue(newRotation.x, newRotation.y, newRotation.z, newRotation.w);
      trans.setRotation(this._tmpAmmoQuaternion);
      impostor.physicsBody.setWorldTransform(trans);
      if (impostor.mass == 0) {
        var motionState = impostor.physicsBody.getMotionState();
        if (motionState) {
          motionState.setWorldTransform(trans);
        }
      } else {
        impostor.physicsBody.activate();
      }
    }
  };
  AmmoJSPlugin2.prototype.isSupported = function() {
    return this.bjsAMMO !== void 0;
  };
  AmmoJSPlugin2.prototype.setLinearVelocity = function(impostor, velocity) {
    this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);
    if (impostor.soft) {
      impostor.physicsBody.linearVelocity(this._tmpAmmoVectorA);
    } else {
      impostor.physicsBody.setLinearVelocity(this._tmpAmmoVectorA);
    }
  };
  AmmoJSPlugin2.prototype.setAngularVelocity = function(impostor, velocity) {
    this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);
    if (impostor.soft) {
      impostor.physicsBody.angularVelocity(this._tmpAmmoVectorA);
    } else {
      impostor.physicsBody.setAngularVelocity(this._tmpAmmoVectorA);
    }
  };
  AmmoJSPlugin2.prototype.getLinearVelocity = function(impostor) {
    if (impostor.soft) {
      var v = impostor.physicsBody.linearVelocity();
    } else {
      var v = impostor.physicsBody.getLinearVelocity();
    }
    if (!v) {
      return null;
    }
    var result = new Vector3(v.x(), v.y(), v.z());
    this.bjsAMMO.destroy(v);
    return result;
  };
  AmmoJSPlugin2.prototype.getAngularVelocity = function(impostor) {
    if (impostor.soft) {
      var v = impostor.physicsBody.angularVelocity();
    } else {
      var v = impostor.physicsBody.getAngularVelocity();
    }
    if (!v) {
      return null;
    }
    var result = new Vector3(v.x(), v.y(), v.z());
    this.bjsAMMO.destroy(v);
    return result;
  };
  AmmoJSPlugin2.prototype.setBodyMass = function(impostor, mass) {
    if (impostor.soft) {
      impostor.physicsBody.setTotalMass(mass, false);
    } else {
      impostor.physicsBody.setMassProps(mass);
    }
    impostor._pluginData.mass = mass;
  };
  AmmoJSPlugin2.prototype.getBodyMass = function(impostor) {
    return impostor._pluginData.mass || 0;
  };
  AmmoJSPlugin2.prototype.getBodyFriction = function(impostor) {
    return impostor._pluginData.friction || 0;
  };
  AmmoJSPlugin2.prototype.setBodyFriction = function(impostor, friction) {
    if (impostor.soft) {
      impostor.physicsBody.get_m_cfg().set_kDF(friction);
    } else {
      impostor.physicsBody.setFriction(friction);
    }
    impostor._pluginData.friction = friction;
  };
  AmmoJSPlugin2.prototype.getBodyRestitution = function(impostor) {
    return impostor._pluginData.restitution || 0;
  };
  AmmoJSPlugin2.prototype.setBodyRestitution = function(impostor, restitution) {
    impostor.physicsBody.setRestitution(restitution);
    impostor._pluginData.restitution = restitution;
  };
  AmmoJSPlugin2.prototype.getBodyPressure = function(impostor) {
    if (!impostor.soft) {
      Logger.Warn("Pressure is not a property of a rigid body");
      return 0;
    }
    return impostor._pluginData.pressure || 0;
  };
  AmmoJSPlugin2.prototype.setBodyPressure = function(impostor, pressure) {
    if (impostor.soft) {
      if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {
        impostor.physicsBody.get_m_cfg().set_kPR(pressure);
        impostor._pluginData.pressure = pressure;
      } else {
        impostor.physicsBody.get_m_cfg().set_kPR(0);
        impostor._pluginData.pressure = 0;
      }
    } else {
      Logger.Warn("Pressure can only be applied to a softbody");
    }
  };
  AmmoJSPlugin2.prototype.getBodyStiffness = function(impostor) {
    if (!impostor.soft) {
      Logger.Warn("Stiffness is not a property of a rigid body");
      return 0;
    }
    return impostor._pluginData.stiffness || 0;
  };
  AmmoJSPlugin2.prototype.setBodyStiffness = function(impostor, stiffness) {
    if (impostor.soft) {
      stiffness = stiffness < 0 ? 0 : stiffness;
      stiffness = stiffness > 1 ? 1 : stiffness;
      impostor.physicsBody.get_m_materials().at(0).set_m_kLST(stiffness);
      impostor._pluginData.stiffness = stiffness;
    } else {
      Logger.Warn("Stiffness cannot be applied to a rigid body");
    }
  };
  AmmoJSPlugin2.prototype.getBodyVelocityIterations = function(impostor) {
    if (!impostor.soft) {
      Logger.Warn("Velocity iterations is not a property of a rigid body");
      return 0;
    }
    return impostor._pluginData.velocityIterations || 0;
  };
  AmmoJSPlugin2.prototype.setBodyVelocityIterations = function(impostor, velocityIterations) {
    if (impostor.soft) {
      velocityIterations = velocityIterations < 0 ? 0 : velocityIterations;
      impostor.physicsBody.get_m_cfg().set_viterations(velocityIterations);
      impostor._pluginData.velocityIterations = velocityIterations;
    } else {
      Logger.Warn("Velocity iterations cannot be applied to a rigid body");
    }
  };
  AmmoJSPlugin2.prototype.getBodyPositionIterations = function(impostor) {
    if (!impostor.soft) {
      Logger.Warn("Position iterations is not a property of a rigid body");
      return 0;
    }
    return impostor._pluginData.positionIterations || 0;
  };
  AmmoJSPlugin2.prototype.setBodyPositionIterations = function(impostor, positionIterations) {
    if (impostor.soft) {
      positionIterations = positionIterations < 0 ? 0 : positionIterations;
      impostor.physicsBody.get_m_cfg().set_piterations(positionIterations);
      impostor._pluginData.positionIterations = positionIterations;
    } else {
      Logger.Warn("Position iterations cannot be applied to a rigid body");
    }
  };
  AmmoJSPlugin2.prototype.appendAnchor = function(impostor, otherImpostor, width, height, influence, noCollisionBetweenLinkedBodies) {
    if (influence === void 0) {
      influence = 1;
    }
    if (noCollisionBetweenLinkedBodies === void 0) {
      noCollisionBetweenLinkedBodies = false;
    }
    var segs = impostor.segments;
    var nbAcross = Math.round((segs - 1) * width);
    var nbUp = Math.round((segs - 1) * height);
    var nbDown = segs - 1 - nbUp;
    var node = nbAcross + segs * nbDown;
    impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);
  };
  AmmoJSPlugin2.prototype.appendHook = function(impostor, otherImpostor, length, influence, noCollisionBetweenLinkedBodies) {
    if (influence === void 0) {
      influence = 1;
    }
    if (noCollisionBetweenLinkedBodies === void 0) {
      noCollisionBetweenLinkedBodies = false;
    }
    var node = Math.round(impostor.segments * length);
    impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);
  };
  AmmoJSPlugin2.prototype.sleepBody = function(impostor) {
    Logger.Warn("sleepBody is not currently supported by the Ammo physics plugin");
  };
  AmmoJSPlugin2.prototype.wakeUpBody = function(impostor) {
    impostor.physicsBody.activate();
  };
  AmmoJSPlugin2.prototype.updateDistanceJoint = function(joint, maxDistance, minDistance) {
    Logger.Warn("updateDistanceJoint is not currently supported by the Ammo physics plugin");
  };
  AmmoJSPlugin2.prototype.setMotor = function(joint, speed, maxForce, motorIndex) {
    joint.physicsJoint.enableAngularMotor(true, speed, maxForce);
  };
  AmmoJSPlugin2.prototype.setLimit = function(joint, upperLimit, lowerLimit) {
    Logger.Warn("setLimit is not currently supported by the Ammo physics plugin");
  };
  AmmoJSPlugin2.prototype.syncMeshWithImpostor = function(mesh, impostor) {
    var body = impostor.physicsBody;
    body.getMotionState().getWorldTransform(this._tmpAmmoTransform);
    mesh.position.x = this._tmpAmmoTransform.getOrigin().x();
    mesh.position.y = this._tmpAmmoTransform.getOrigin().y();
    mesh.position.z = this._tmpAmmoTransform.getOrigin().z();
    if (mesh.rotationQuaternion) {
      mesh.rotationQuaternion.x = this._tmpAmmoTransform.getRotation().x();
      mesh.rotationQuaternion.y = this._tmpAmmoTransform.getRotation().y();
      mesh.rotationQuaternion.z = this._tmpAmmoTransform.getRotation().z();
      mesh.rotationQuaternion.w = this._tmpAmmoTransform.getRotation().w();
    }
  };
  AmmoJSPlugin2.prototype.getRadius = function(impostor) {
    var exntend = impostor.getObjectExtendSize();
    return exntend.x / 2;
  };
  AmmoJSPlugin2.prototype.getBoxSizeToRef = function(impostor, result) {
    var exntend = impostor.getObjectExtendSize();
    result.x = exntend.x;
    result.y = exntend.y;
    result.z = exntend.z;
  };
  AmmoJSPlugin2.prototype.dispose = function() {
    this.bjsAMMO.destroy(this.world);
    this.bjsAMMO.destroy(this._solver);
    this.bjsAMMO.destroy(this._overlappingPairCache);
    this.bjsAMMO.destroy(this._dispatcher);
    this.bjsAMMO.destroy(this._collisionConfiguration);
    this.bjsAMMO.destroy(this._tmpAmmoVectorA);
    this.bjsAMMO.destroy(this._tmpAmmoVectorB);
    this.bjsAMMO.destroy(this._tmpAmmoVectorC);
    this.bjsAMMO.destroy(this._tmpAmmoTransform);
    this.bjsAMMO.destroy(this._tmpAmmoQuaternion);
    this.bjsAMMO.destroy(this._tmpAmmoConcreteContactResultCallback);
    this.world = null;
  };
  AmmoJSPlugin2.prototype.raycast = function(from, to) {
    this._tmpAmmoVectorRCA = new this.bjsAMMO.btVector3(from.x, from.y, from.z);
    this._tmpAmmoVectorRCB = new this.bjsAMMO.btVector3(to.x, to.y, to.z);
    var rayCallback = new this.bjsAMMO.ClosestRayResultCallback(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB);
    this.world.rayTest(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB, rayCallback);
    this._raycastResult.reset(from, to);
    if (rayCallback.hasHit()) {
      this._raycastResult.setHitData({
        x: rayCallback.get_m_hitNormalWorld().x(),
        y: rayCallback.get_m_hitNormalWorld().y(),
        z: rayCallback.get_m_hitNormalWorld().z()
      }, {
        x: rayCallback.get_m_hitPointWorld().x(),
        y: rayCallback.get_m_hitPointWorld().y(),
        z: rayCallback.get_m_hitPointWorld().z()
      });
      this._raycastResult.calculateHitDistance();
    }
    this.bjsAMMO.destroy(rayCallback);
    this.bjsAMMO.destroy(this._tmpAmmoVectorRCA);
    this.bjsAMMO.destroy(this._tmpAmmoVectorRCB);
    return this._raycastResult;
  };
  AmmoJSPlugin2.DISABLE_COLLISION_FLAG = 4;
  AmmoJSPlugin2.KINEMATIC_FLAG = 2;
  AmmoJSPlugin2.DISABLE_DEACTIVATION_FLAG = 4;
  return AmmoJSPlugin2;
}();

// node_modules/@babylonjs/core/Probes/reflectionProbe.js
AbstractScene.prototype.removeReflectionProbe = function(toRemove) {
  if (!this.reflectionProbes) {
    return -1;
  }
  var index = this.reflectionProbes.indexOf(toRemove);
  if (index !== -1) {
    this.reflectionProbes.splice(index, 1);
  }
  return index;
};
AbstractScene.prototype.addReflectionProbe = function(newReflectionProbe) {
  if (!this.reflectionProbes) {
    this.reflectionProbes = [];
  }
  this.reflectionProbes.push(newReflectionProbe);
};
var ReflectionProbe = function() {
  function ReflectionProbe2(name98, size, scene, generateMipMaps, useFloat) {
    var _this = this;
    if (generateMipMaps === void 0) {
      generateMipMaps = true;
    }
    if (useFloat === void 0) {
      useFloat = false;
    }
    this.name = name98;
    this._viewMatrix = Matrix.Identity();
    this._target = Vector3.Zero();
    this._add = Vector3.Zero();
    this._invertYAxis = false;
    this.position = Vector3.Zero();
    this._scene = scene;
    if (!this._scene.reflectionProbes) {
      this._scene.reflectionProbes = new Array();
    }
    this._scene.reflectionProbes.push(this);
    var textureType = 0;
    if (useFloat) {
      var caps = this._scene.getEngine().getCaps();
      if (caps.textureHalfFloatRender) {
        textureType = 2;
      } else if (caps.textureFloatRender) {
        textureType = 1;
      }
    }
    this._renderTargetTexture = new RenderTargetTexture(name98, size, scene, generateMipMaps, true, textureType, true);
    this._renderTargetTexture.onBeforeRenderObservable.add(function(faceIndex) {
      switch (faceIndex) {
        case 0:
          _this._add.copyFromFloats(1, 0, 0);
          break;
        case 1:
          _this._add.copyFromFloats(-1, 0, 0);
          break;
        case 2:
          _this._add.copyFromFloats(0, _this._invertYAxis ? 1 : -1, 0);
          break;
        case 3:
          _this._add.copyFromFloats(0, _this._invertYAxis ? -1 : 1, 0);
          break;
        case 4:
          _this._add.copyFromFloats(0, 0, 1);
          break;
        case 5:
          _this._add.copyFromFloats(0, 0, -1);
          break;
      }
      if (_this._attachedMesh) {
        _this.position.copyFrom(_this._attachedMesh.getAbsolutePosition());
      }
      _this.position.addToRef(_this._add, _this._target);
      Matrix.LookAtLHToRef(_this.position, _this._target, Vector3.Up(), _this._viewMatrix);
      if (scene.activeCamera) {
        _this._projectionMatrix = Matrix.PerspectiveFovLH(Math.PI / 2, 1, scene.activeCamera.minZ, scene.activeCamera.maxZ);
        scene.setTransformMatrix(_this._viewMatrix, _this._projectionMatrix);
      }
      scene._forcedViewPosition = _this.position;
    });
    this._renderTargetTexture.onAfterUnbindObservable.add(function() {
      scene._forcedViewPosition = null;
      scene.updateTransformMatrix(true);
    });
  }
  Object.defineProperty(ReflectionProbe2.prototype, "samples", {
    get: function() {
      return this._renderTargetTexture.samples;
    },
    set: function(value) {
      this._renderTargetTexture.samples = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReflectionProbe2.prototype, "refreshRate", {
    get: function() {
      return this._renderTargetTexture.refreshRate;
    },
    set: function(value) {
      this._renderTargetTexture.refreshRate = value;
    },
    enumerable: false,
    configurable: true
  });
  ReflectionProbe2.prototype.getScene = function() {
    return this._scene;
  };
  Object.defineProperty(ReflectionProbe2.prototype, "cubeTexture", {
    get: function() {
      return this._renderTargetTexture;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReflectionProbe2.prototype, "renderList", {
    get: function() {
      return this._renderTargetTexture.renderList;
    },
    enumerable: false,
    configurable: true
  });
  ReflectionProbe2.prototype.attachToMesh = function(mesh) {
    this._attachedMesh = mesh;
  };
  ReflectionProbe2.prototype.setRenderingAutoClearDepthStencil = function(renderingGroupId, autoClearDepthStencil) {
    this._renderTargetTexture.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);
  };
  ReflectionProbe2.prototype.dispose = function() {
    var index = this._scene.reflectionProbes.indexOf(this);
    if (index !== -1) {
      this._scene.reflectionProbes.splice(index, 1);
    }
    if (this._renderTargetTexture) {
      this._renderTargetTexture.dispose();
      this._renderTargetTexture = null;
    }
  };
  ReflectionProbe2.prototype.toString = function(fullDetails) {
    var ret = "Name: " + this.name;
    if (fullDetails) {
      ret += ", position: " + this.position.toString();
      if (this._attachedMesh) {
        ret += ", attached mesh: " + this._attachedMesh.name;
      }
    }
    return ret;
  };
  ReflectionProbe2.prototype.getClassName = function() {
    return "ReflectionProbe";
  };
  ReflectionProbe2.prototype.serialize = function() {
    var serializationObject = SerializationHelper.Serialize(this, this._renderTargetTexture.serialize());
    serializationObject.isReflectionProbe = true;
    return serializationObject;
  };
  ReflectionProbe2.Parse = function(parsedReflectionProbe, scene, rootUrl) {
    var reflectionProbe = null;
    if (scene.reflectionProbes) {
      for (var index = 0; index < scene.reflectionProbes.length; index++) {
        var rp = scene.reflectionProbes[index];
        if (rp.name === parsedReflectionProbe.name) {
          reflectionProbe = rp;
          break;
        }
      }
    }
    reflectionProbe = SerializationHelper.Parse(function() {
      return reflectionProbe || new ReflectionProbe2(parsedReflectionProbe.name, parsedReflectionProbe.renderTargetSize, scene, parsedReflectionProbe._generateMipMaps);
    }, parsedReflectionProbe, scene, rootUrl);
    reflectionProbe.cubeTexture._waitingRenderList = parsedReflectionProbe.renderList;
    if (parsedReflectionProbe._attachedMesh) {
      reflectionProbe.attachToMesh(scene.getMeshByID(parsedReflectionProbe._attachedMesh));
    }
    return reflectionProbe;
  };
  __decorate([
    serializeAsMeshReference()
  ], ReflectionProbe2.prototype, "_attachedMesh", void 0);
  __decorate([
    serializeAsVector3()
  ], ReflectionProbe2.prototype, "position", void 0);
  return ReflectionProbe2;
}();

// node_modules/@babylonjs/core/Loading/Plugins/babylonFileLoader.js
var _BabylonLoaderRegistered = true;
var BabylonFileLoaderConfiguration = function() {
  function BabylonFileLoaderConfiguration2() {
  }
  BabylonFileLoaderConfiguration2.LoaderInjectedPhysicsEngine = void 0;
  return BabylonFileLoaderConfiguration2;
}();
var parseMaterialById = function(id, parsedData, scene, rootUrl) {
  for (var index = 0, cache = parsedData.materials.length; index < cache; index++) {
    var parsedMaterial = parsedData.materials[index];
    if (parsedMaterial.id === id) {
      return Material.Parse(parsedMaterial, scene, rootUrl);
    }
  }
  return null;
};
var isDescendantOf = function(mesh, names, hierarchyIds) {
  for (var i in names) {
    if (mesh.name === names[i]) {
      hierarchyIds.push(mesh.id);
      return true;
    }
  }
  if (mesh.parentId && hierarchyIds.indexOf(mesh.parentId) !== -1) {
    hierarchyIds.push(mesh.id);
    return true;
  }
  return false;
};
var logOperation = function(operation, producer) {
  return operation + " of " + (producer ? producer.file + " from " + producer.name + " version: " + producer.version + ", exporter version: " + producer.exporter_version : "unknown");
};
var loadDetailLevels = function(scene, mesh) {
  var mastermesh = mesh;
  if (mesh._waitingData.lods) {
    if (mesh._waitingData.lods.ids && mesh._waitingData.lods.ids.length > 0) {
      var lodmeshes = mesh._waitingData.lods.ids;
      var wasenabled = mastermesh.isEnabled(false);
      if (mesh._waitingData.lods.distances) {
        var distances = mesh._waitingData.lods.distances;
        if (distances.length >= lodmeshes.length) {
          var culling = distances.length > lodmeshes.length ? distances[distances.length - 1] : 0;
          mastermesh.setEnabled(false);
          for (var index = 0; index < lodmeshes.length; index++) {
            var lodid = lodmeshes[index];
            var lodmesh = scene.getMeshByID(lodid);
            if (lodmesh != null) {
              mastermesh.addLODLevel(distances[index], lodmesh);
            }
          }
          if (culling > 0) {
            mastermesh.addLODLevel(culling, null);
          }
          if (wasenabled === true) {
            mastermesh.setEnabled(true);
          }
        } else {
          Tools.Warn("Invalid level of detail distances for " + mesh.name);
        }
      }
    }
    mesh._waitingData.lods = null;
  }
};
var loadAssetContainer = function(scene, data, rootUrl, onError, addToScene) {
  if (addToScene === void 0) {
    addToScene = false;
  }
  var container = new AssetContainer(scene);
  var log = "importScene has failed JSON parse";
  try {
    var parsedData = JSON.parse(data);
    log = "";
    var fullDetails = SceneLoader.loggingLevel === SceneLoader.DETAILED_LOGGING;
    var index;
    var cache;
    if (parsedData.environmentTexture !== void 0 && parsedData.environmentTexture !== null) {
      var isPBR = parsedData.isPBR !== void 0 ? parsedData.isPBR : true;
      if (parsedData.environmentTextureType && parsedData.environmentTextureType === "BABYLON.HDRCubeTexture") {
        var hdrSize = parsedData.environmentTextureSize ? parsedData.environmentTextureSize : 128;
        var hdrTexture = new HDRCubeTexture((parsedData.environmentTexture.match(/https?:\/\//g) ? "" : rootUrl) + parsedData.environmentTexture, scene, hdrSize, true, !isPBR);
        if (parsedData.environmentTextureRotationY) {
          hdrTexture.rotationY = parsedData.environmentTextureRotationY;
        }
        scene.environmentTexture = hdrTexture;
      } else {
        if (StringTools.EndsWith(parsedData.environmentTexture, ".env")) {
          var compressedTexture = new CubeTexture((parsedData.environmentTexture.match(/https?:\/\//g) ? "" : rootUrl) + parsedData.environmentTexture, scene);
          if (parsedData.environmentTextureRotationY) {
            compressedTexture.rotationY = parsedData.environmentTextureRotationY;
          }
          scene.environmentTexture = compressedTexture;
        } else {
          var cubeTexture = CubeTexture.CreateFromPrefilteredData((parsedData.environmentTexture.match(/https?:\/\//g) ? "" : rootUrl) + parsedData.environmentTexture, scene);
          if (parsedData.environmentTextureRotationY) {
            cubeTexture.rotationY = parsedData.environmentTextureRotationY;
          }
          scene.environmentTexture = cubeTexture;
        }
      }
      if (parsedData.createDefaultSkybox === true) {
        var skyboxScale = scene.activeCamera !== void 0 && scene.activeCamera !== null ? (scene.activeCamera.maxZ - scene.activeCamera.minZ) / 2 : 1e3;
        var skyboxBlurLevel = parsedData.skyboxBlurLevel || 0;
        scene.createDefaultSkybox(scene.environmentTexture, isPBR, skyboxScale, skyboxBlurLevel);
      }
      container.environmentTexture = scene.environmentTexture;
    }
    if (parsedData.environmentIntensity !== void 0 && parsedData.environmentIntensity !== null) {
      scene.environmentIntensity = parsedData.environmentIntensity;
    }
    if (parsedData.lights !== void 0 && parsedData.lights !== null) {
      for (index = 0, cache = parsedData.lights.length; index < cache; index++) {
        var parsedLight = parsedData.lights[index];
        var light = Light.Parse(parsedLight, scene);
        if (light) {
          container.lights.push(light);
          log += index === 0 ? "\n	Lights:" : "";
          log += "\n		" + light.toString(fullDetails);
        }
      }
    }
    if (parsedData.reflectionProbes !== void 0 && parsedData.reflectionProbes !== null) {
      for (index = 0, cache = parsedData.reflectionProbes.length; index < cache; index++) {
        var parsedReflectionProbe = parsedData.reflectionProbes[index];
        var reflectionProbe = ReflectionProbe.Parse(parsedReflectionProbe, scene, rootUrl);
        if (reflectionProbe) {
          container.reflectionProbes.push(reflectionProbe);
          log += index === 0 ? "\n	Reflection Probes:" : "";
          log += "\n		" + reflectionProbe.toString(fullDetails);
        }
      }
    }
    if (parsedData.animations !== void 0 && parsedData.animations !== null) {
      for (index = 0, cache = parsedData.animations.length; index < cache; index++) {
        var parsedAnimation = parsedData.animations[index];
        var internalClass = _TypeStore.GetClass("BABYLON.Animation");
        if (internalClass) {
          var animation = internalClass.Parse(parsedAnimation);
          scene.animations.push(animation);
          container.animations.push(animation);
          log += index === 0 ? "\n	Animations:" : "";
          log += "\n		" + animation.toString(fullDetails);
        }
      }
    }
    if (parsedData.materials !== void 0 && parsedData.materials !== null) {
      for (index = 0, cache = parsedData.materials.length; index < cache; index++) {
        var parsedMaterial = parsedData.materials[index];
        var mat = Material.Parse(parsedMaterial, scene, rootUrl);
        if (mat) {
          container.materials.push(mat);
          log += index === 0 ? "\n	Materials:" : "";
          log += "\n		" + mat.toString(fullDetails);
          var textures = mat.getActiveTextures();
          textures.forEach(function(t) {
            if (container.textures.indexOf(t) == -1) {
              container.textures.push(t);
            }
          });
        }
      }
    }
    if (parsedData.multiMaterials !== void 0 && parsedData.multiMaterials !== null) {
      for (index = 0, cache = parsedData.multiMaterials.length; index < cache; index++) {
        var parsedMultiMaterial = parsedData.multiMaterials[index];
        var mmat = MultiMaterial.ParseMultiMaterial(parsedMultiMaterial, scene);
        container.multiMaterials.push(mmat);
        log += index === 0 ? "\n	MultiMaterials:" : "";
        log += "\n		" + mmat.toString(fullDetails);
        var textures = mmat.getActiveTextures();
        textures.forEach(function(t) {
          if (container.textures.indexOf(t) == -1) {
            container.textures.push(t);
          }
        });
      }
    }
    if (parsedData.morphTargetManagers !== void 0 && parsedData.morphTargetManagers !== null) {
      for (var _i = 0, _a = parsedData.morphTargetManagers; _i < _a.length; _i++) {
        var managerData = _a[_i];
        container.morphTargetManagers.push(MorphTargetManager.Parse(managerData, scene));
      }
    }
    if (parsedData.skeletons !== void 0 && parsedData.skeletons !== null) {
      for (index = 0, cache = parsedData.skeletons.length; index < cache; index++) {
        var parsedSkeleton = parsedData.skeletons[index];
        var skeleton = Skeleton.Parse(parsedSkeleton, scene);
        container.skeletons.push(skeleton);
        log += index === 0 ? "\n	Skeletons:" : "";
        log += "\n		" + skeleton.toString(fullDetails);
      }
    }
    var geometries = parsedData.geometries;
    if (geometries !== void 0 && geometries !== null) {
      var addedGeometry = new Array();
      var vertexData = geometries.vertexData;
      if (vertexData !== void 0 && vertexData !== null) {
        for (index = 0, cache = vertexData.length; index < cache; index++) {
          var parsedVertexData = vertexData[index];
          addedGeometry.push(Geometry.Parse(parsedVertexData, scene, rootUrl));
        }
      }
      addedGeometry.forEach(function(g) {
        if (g) {
          container.geometries.push(g);
        }
      });
    }
    if (parsedData.transformNodes !== void 0 && parsedData.transformNodes !== null) {
      for (index = 0, cache = parsedData.transformNodes.length; index < cache; index++) {
        var parsedTransformNode = parsedData.transformNodes[index];
        var node = TransformNode.Parse(parsedTransformNode, scene, rootUrl);
        container.transformNodes.push(node);
      }
    }
    if (parsedData.meshes !== void 0 && parsedData.meshes !== null) {
      for (index = 0, cache = parsedData.meshes.length; index < cache; index++) {
        var parsedMesh = parsedData.meshes[index];
        var mesh = Mesh.Parse(parsedMesh, scene, rootUrl);
        container.meshes.push(mesh);
        if (mesh.hasInstances) {
          for (var _b = 0, _c = mesh.instances; _b < _c.length; _b++) {
            var instance = _c[_b];
            container.meshes.push(instance);
          }
        }
        log += index === 0 ? "\n	Meshes:" : "";
        log += "\n		" + mesh.toString(fullDetails);
      }
    }
    if (parsedData.cameras !== void 0 && parsedData.cameras !== null) {
      for (index = 0, cache = parsedData.cameras.length; index < cache; index++) {
        var parsedCamera = parsedData.cameras[index];
        var camera = Camera.Parse(parsedCamera, scene);
        container.cameras.push(camera);
        log += index === 0 ? "\n	Cameras:" : "";
        log += "\n		" + camera.toString(fullDetails);
      }
    }
    if (parsedData.postProcesses !== void 0 && parsedData.postProcesses !== null) {
      for (index = 0, cache = parsedData.postProcesses.length; index < cache; index++) {
        var parsedPostProcess = parsedData.postProcesses[index];
        var postProcess = PostProcess.Parse(parsedPostProcess, scene, rootUrl);
        if (postProcess) {
          container.postProcesses.push(postProcess);
          log += index === 0 ? "\nPostprocesses:" : "";
          log += "\n		" + postProcess.toString();
        }
      }
    }
    if (parsedData.animationGroups !== void 0 && parsedData.animationGroups !== null) {
      for (index = 0, cache = parsedData.animationGroups.length; index < cache; index++) {
        var parsedAnimationGroup = parsedData.animationGroups[index];
        var animationGroup = AnimationGroup.Parse(parsedAnimationGroup, scene);
        container.animationGroups.push(animationGroup);
        log += index === 0 ? "\n	AnimationGroups:" : "";
        log += "\n		" + animationGroup.toString(fullDetails);
      }
    }
    for (index = 0, cache = scene.cameras.length; index < cache; index++) {
      var camera = scene.cameras[index];
      if (camera._waitingParentId) {
        camera.parent = scene.getLastEntryByID(camera._waitingParentId);
        camera._waitingParentId = null;
      }
    }
    for (index = 0, cache = scene.lights.length; index < cache; index++) {
      var light_1 = scene.lights[index];
      if (light_1 && light_1._waitingParentId) {
        light_1.parent = scene.getLastEntryByID(light_1._waitingParentId);
        light_1._waitingParentId = null;
      }
    }
    for (index = 0, cache = scene.transformNodes.length; index < cache; index++) {
      var transformNode = scene.transformNodes[index];
      if (transformNode._waitingParentId) {
        transformNode.parent = scene.getLastEntryByID(transformNode._waitingParentId);
        transformNode._waitingParentId = null;
      }
    }
    for (index = 0, cache = scene.meshes.length; index < cache; index++) {
      var mesh = scene.meshes[index];
      if (mesh._waitingParentId) {
        mesh.parent = scene.getLastEntryByID(mesh._waitingParentId);
        mesh._waitingParentId = null;
      }
      if (mesh._waitingData.lods) {
        loadDetailLevels(scene, mesh);
      }
    }
    for (index = 0, cache = scene.skeletons.length; index < cache; index++) {
      var skeleton = scene.skeletons[index];
      if (skeleton._hasWaitingData) {
        if (skeleton.bones != null) {
          skeleton.bones.forEach(function(bone) {
            if (bone._waitingTransformNodeId) {
              var linkTransformNode = scene.getLastEntryByID(bone._waitingTransformNodeId);
              if (linkTransformNode) {
                bone.linkTransformNode(linkTransformNode);
              }
              bone._waitingTransformNodeId = null;
            }
          });
        }
        if (skeleton._waitingOverrideMeshId) {
          skeleton.overrideMesh = scene.getMeshByID(skeleton._waitingOverrideMeshId);
          skeleton._waitingOverrideMeshId = null;
        }
        skeleton._hasWaitingData = null;
      }
    }
    for (index = 0, cache = scene.meshes.length; index < cache; index++) {
      var currentMesh = scene.meshes[index];
      if (currentMesh._waitingData.freezeWorldMatrix) {
        currentMesh.freezeWorldMatrix();
        currentMesh._waitingData.freezeWorldMatrix = null;
      } else {
        currentMesh.computeWorldMatrix(true);
      }
    }
    for (index = 0, cache = scene.lights.length; index < cache; index++) {
      var light_2 = scene.lights[index];
      if (light_2._excludedMeshesIds.length > 0) {
        for (var excludedIndex = 0; excludedIndex < light_2._excludedMeshesIds.length; excludedIndex++) {
          var excludedMesh = scene.getMeshByID(light_2._excludedMeshesIds[excludedIndex]);
          if (excludedMesh) {
            light_2.excludedMeshes.push(excludedMesh);
          }
        }
        light_2._excludedMeshesIds = [];
      }
      if (light_2._includedOnlyMeshesIds.length > 0) {
        for (var includedOnlyIndex = 0; includedOnlyIndex < light_2._includedOnlyMeshesIds.length; includedOnlyIndex++) {
          var includedOnlyMesh = scene.getMeshByID(light_2._includedOnlyMeshesIds[includedOnlyIndex]);
          if (includedOnlyMesh) {
            light_2.includedOnlyMeshes.push(includedOnlyMesh);
          }
        }
        light_2._includedOnlyMeshesIds = [];
      }
    }
    AbstractScene.Parse(parsedData, scene, container, rootUrl);
    for (index = 0, cache = scene.meshes.length; index < cache; index++) {
      var mesh = scene.meshes[index];
      if (mesh._waitingData.actions) {
        ActionManager.Parse(mesh._waitingData.actions, mesh, scene);
        mesh._waitingData.actions = null;
      }
    }
    if (parsedData.actions !== void 0 && parsedData.actions !== null) {
      ActionManager.Parse(parsedData.actions, null, scene);
    }
  } catch (err) {
    var msg = logOperation("loadAssets", parsedData ? parsedData.producer : "Unknown") + log;
    if (onError) {
      onError(msg, err);
    } else {
      Logger.Log(msg);
      throw err;
    }
  } finally {
    if (!addToScene) {
      container.removeAllFromScene();
    }
    if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {
      Logger.Log(logOperation("loadAssets", parsedData ? parsedData.producer : "Unknown") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : ""));
    }
  }
  return container;
};
SceneLoader.RegisterPlugin({
  name: "babylon.js",
  extensions: ".babylon",
  canDirectLoad: function(data) {
    if (data.indexOf("babylon") !== -1) {
      return true;
    }
    return false;
  },
  importMesh: function(meshesNames, scene, data, rootUrl, meshes, particleSystems, skeletons, onError) {
    var log = "importMesh has failed JSON parse";
    try {
      var parsedData = JSON.parse(data);
      log = "";
      var fullDetails = SceneLoader.loggingLevel === SceneLoader.DETAILED_LOGGING;
      if (!meshesNames) {
        meshesNames = null;
      } else if (!Array.isArray(meshesNames)) {
        meshesNames = [meshesNames];
      }
      var hierarchyIds = new Array();
      if (parsedData.meshes !== void 0 && parsedData.meshes !== null) {
        var loadedSkeletonsIds = [];
        var loadedMaterialsIds = [];
        var index;
        var cache;
        for (index = 0, cache = parsedData.meshes.length; index < cache; index++) {
          var parsedMesh = parsedData.meshes[index];
          if (meshesNames === null || isDescendantOf(parsedMesh, meshesNames, hierarchyIds)) {
            if (meshesNames !== null) {
              delete meshesNames[meshesNames.indexOf(parsedMesh.name)];
            }
            if (parsedMesh.geometryId !== void 0 && parsedMesh.geometryId !== null) {
              if (parsedData.geometries !== void 0 && parsedData.geometries !== null) {
                var found = false;
                ["boxes", "spheres", "cylinders", "toruses", "grounds", "planes", "torusKnots", "vertexData"].forEach(function(geometryType) {
                  if (found === true || !parsedData.geometries[geometryType] || !Array.isArray(parsedData.geometries[geometryType])) {
                    return;
                  } else {
                    parsedData.geometries[geometryType].forEach(function(parsedGeometryData) {
                      if (parsedGeometryData.id === parsedMesh.geometryId) {
                        switch (geometryType) {
                          case "vertexData":
                            Geometry.Parse(parsedGeometryData, scene, rootUrl);
                            break;
                        }
                        found = true;
                      }
                    });
                  }
                });
                if (found === false) {
                  Logger.Warn("Geometry not found for mesh " + parsedMesh.id);
                }
              }
            }
            if (parsedMesh.materialId) {
              var materialFound = loadedMaterialsIds.indexOf(parsedMesh.materialId) !== -1;
              if (materialFound === false && parsedData.multiMaterials !== void 0 && parsedData.multiMaterials !== null) {
                for (var multimatIndex = 0, multimatCache = parsedData.multiMaterials.length; multimatIndex < multimatCache; multimatIndex++) {
                  var parsedMultiMaterial = parsedData.multiMaterials[multimatIndex];
                  if (parsedMultiMaterial.id === parsedMesh.materialId) {
                    for (var matIndex = 0, matCache = parsedMultiMaterial.materials.length; matIndex < matCache; matIndex++) {
                      var subMatId = parsedMultiMaterial.materials[matIndex];
                      loadedMaterialsIds.push(subMatId);
                      var mat = parseMaterialById(subMatId, parsedData, scene, rootUrl);
                      if (mat) {
                        log += "\n	Material " + mat.toString(fullDetails);
                      }
                    }
                    loadedMaterialsIds.push(parsedMultiMaterial.id);
                    var mmat = MultiMaterial.ParseMultiMaterial(parsedMultiMaterial, scene);
                    if (mmat) {
                      materialFound = true;
                      log += "\n	Multi-Material " + mmat.toString(fullDetails);
                    }
                    break;
                  }
                }
              }
              if (materialFound === false) {
                loadedMaterialsIds.push(parsedMesh.materialId);
                var mat = parseMaterialById(parsedMesh.materialId, parsedData, scene, rootUrl);
                if (!mat) {
                  Logger.Warn("Material not found for mesh " + parsedMesh.id);
                } else {
                  log += "\n	Material " + mat.toString(fullDetails);
                }
              }
            }
            if (parsedMesh.skeletonId > -1 && parsedData.skeletons !== void 0 && parsedData.skeletons !== null) {
              var skeletonAlreadyLoaded = loadedSkeletonsIds.indexOf(parsedMesh.skeletonId) > -1;
              if (skeletonAlreadyLoaded === false) {
                for (var skeletonIndex = 0, skeletonCache = parsedData.skeletons.length; skeletonIndex < skeletonCache; skeletonIndex++) {
                  var parsedSkeleton = parsedData.skeletons[skeletonIndex];
                  if (parsedSkeleton.id === parsedMesh.skeletonId) {
                    var skeleton = Skeleton.Parse(parsedSkeleton, scene);
                    skeletons.push(skeleton);
                    loadedSkeletonsIds.push(parsedSkeleton.id);
                    log += "\n	Skeleton " + skeleton.toString(fullDetails);
                  }
                }
              }
            }
            if (parsedData.morphTargetManagers !== void 0 && parsedData.morphTargetManagers !== null) {
              for (var _i = 0, _a = parsedData.morphTargetManagers; _i < _a.length; _i++) {
                var managerData = _a[_i];
                MorphTargetManager.Parse(managerData, scene);
              }
            }
            var mesh = Mesh.Parse(parsedMesh, scene, rootUrl);
            meshes.push(mesh);
            log += "\n	Mesh " + mesh.toString(fullDetails);
          }
        }
        var currentMesh;
        for (index = 0, cache = scene.meshes.length; index < cache; index++) {
          currentMesh = scene.meshes[index];
          if (currentMesh._waitingParentId) {
            currentMesh.parent = scene.getLastEntryByID(currentMesh._waitingParentId);
            currentMesh._waitingParentId = null;
          }
          if (currentMesh._waitingData.lods) {
            loadDetailLevels(scene, currentMesh);
          }
        }
        for (index = 0, cache = scene.skeletons.length; index < cache; index++) {
          var skeleton = scene.skeletons[index];
          if (skeleton._hasWaitingData) {
            if (skeleton.bones != null) {
              skeleton.bones.forEach(function(bone) {
                if (bone._waitingTransformNodeId) {
                  var linkTransformNode = scene.getLastEntryByID(bone._waitingTransformNodeId);
                  if (linkTransformNode) {
                    bone.linkTransformNode(linkTransformNode);
                  }
                  bone._waitingTransformNodeId = null;
                }
              });
            }
            if (skeleton._waitingOverrideMeshId) {
              skeleton.overrideMesh = scene.getMeshByID(skeleton._waitingOverrideMeshId);
              skeleton._waitingOverrideMeshId = null;
            }
            skeleton._hasWaitingData = null;
          }
        }
        for (index = 0, cache = scene.meshes.length; index < cache; index++) {
          currentMesh = scene.meshes[index];
          if (currentMesh._waitingData.freezeWorldMatrix) {
            currentMesh.freezeWorldMatrix();
            currentMesh._waitingData.freezeWorldMatrix = null;
          } else {
            currentMesh.computeWorldMatrix(true);
          }
        }
      }
      if (parsedData.particleSystems !== void 0 && parsedData.particleSystems !== null) {
        var parser = AbstractScene.GetIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM);
        if (parser) {
          for (index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {
            var parsedParticleSystem = parsedData.particleSystems[index];
            if (hierarchyIds.indexOf(parsedParticleSystem.emitterId) !== -1) {
              particleSystems.push(parser(parsedParticleSystem, scene, rootUrl));
            }
          }
        }
      }
      return true;
    } catch (err) {
      var msg = logOperation("importMesh", parsedData ? parsedData.producer : "Unknown") + log;
      if (onError) {
        onError(msg, err);
      } else {
        Logger.Log(msg);
        throw err;
      }
    } finally {
      if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {
        Logger.Log(logOperation("importMesh", parsedData ? parsedData.producer : "Unknown") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : ""));
      }
    }
    return false;
  },
  load: function(scene, data, rootUrl, onError) {
    var log = "importScene has failed JSON parse";
    try {
      var parsedData = JSON.parse(data);
      log = "";
      if (parsedData.useDelayedTextureLoading !== void 0 && parsedData.useDelayedTextureLoading !== null) {
        scene.useDelayedTextureLoading = parsedData.useDelayedTextureLoading && !SceneLoader.ForceFullSceneLoadingForIncremental;
      }
      if (parsedData.autoClear !== void 0 && parsedData.autoClear !== null) {
        scene.autoClear = parsedData.autoClear;
      }
      if (parsedData.clearColor !== void 0 && parsedData.clearColor !== null) {
        scene.clearColor = Color4.FromArray(parsedData.clearColor);
      }
      if (parsedData.ambientColor !== void 0 && parsedData.ambientColor !== null) {
        scene.ambientColor = Color3.FromArray(parsedData.ambientColor);
      }
      if (parsedData.gravity !== void 0 && parsedData.gravity !== null) {
        scene.gravity = Vector3.FromArray(parsedData.gravity);
      }
      if (parsedData.fogMode && parsedData.fogMode !== 0) {
        scene.fogMode = parsedData.fogMode;
        scene.fogColor = Color3.FromArray(parsedData.fogColor);
        scene.fogStart = parsedData.fogStart;
        scene.fogEnd = parsedData.fogEnd;
        scene.fogDensity = parsedData.fogDensity;
        log += "	Fog mode for scene:  ";
        switch (scene.fogMode) {
          case 1:
            log += "exp\n";
            break;
          case 2:
            log += "exp2\n";
            break;
          case 3:
            log += "linear\n";
            break;
        }
      }
      if (parsedData.physicsEnabled) {
        var physicsPlugin;
        if (parsedData.physicsEngine === "cannon") {
          physicsPlugin = new CannonJSPlugin(void 0, void 0, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine);
        } else if (parsedData.physicsEngine === "oimo") {
          physicsPlugin = new OimoJSPlugin(void 0, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine);
        } else if (parsedData.physicsEngine === "ammo") {
          physicsPlugin = new AmmoJSPlugin(void 0, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine, void 0);
        }
        log = "	Physics engine " + (parsedData.physicsEngine ? parsedData.physicsEngine : "oimo") + " enabled\n";
        var physicsGravity = parsedData.physicsGravity ? Vector3.FromArray(parsedData.physicsGravity) : null;
        scene.enablePhysics(physicsGravity, physicsPlugin);
      }
      if (parsedData.metadata !== void 0 && parsedData.metadata !== null) {
        scene.metadata = parsedData.metadata;
      }
      if (parsedData.collisionsEnabled !== void 0 && parsedData.collisionsEnabled !== null) {
        scene.collisionsEnabled = parsedData.collisionsEnabled;
      }
      var container = loadAssetContainer(scene, data, rootUrl, onError, true);
      if (!container) {
        return false;
      }
      if (parsedData.autoAnimate) {
        scene.beginAnimation(scene, parsedData.autoAnimateFrom, parsedData.autoAnimateTo, parsedData.autoAnimateLoop, parsedData.autoAnimateSpeed || 1);
      }
      if (parsedData.activeCameraID !== void 0 && parsedData.activeCameraID !== null) {
        scene.setActiveCameraByID(parsedData.activeCameraID);
      }
      return true;
    } catch (err) {
      var msg = logOperation("importScene", parsedData ? parsedData.producer : "Unknown") + log;
      if (onError) {
        onError(msg, err);
      } else {
        Logger.Log(msg);
        throw err;
      }
    } finally {
      if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {
        Logger.Log(logOperation("importScene", parsedData ? parsedData.producer : "Unknown") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : ""));
      }
    }
    return false;
  },
  loadAssetContainer: function(scene, data, rootUrl, onError) {
    var container = loadAssetContainer(scene, data, rootUrl, onError);
    return container;
  }
});

// node_modules/@babylonjs/core/Materials/fresnelParameters.js
var FresnelParameters = function() {
  function FresnelParameters2(options) {
    if (options === void 0) {
      options = {};
    }
    this._isEnabled = true;
    this.bias = options.bias === void 0 ? 0 : options.bias;
    this.power = options.power === void 0 ? 1 : options.power;
    this.leftColor = options.leftColor || Color3.White();
    this.rightColor = options.rightColor || Color3.Black();
    if (options.isEnabled === false) {
      this.isEnabled = false;
    }
  }
  Object.defineProperty(FresnelParameters2.prototype, "isEnabled", {
    get: function() {
      return this._isEnabled;
    },
    set: function(value) {
      if (this._isEnabled === value) {
        return;
      }
      this._isEnabled = value;
      Engine.MarkAllMaterialsAsDirty(4 | 16);
    },
    enumerable: false,
    configurable: true
  });
  FresnelParameters2.prototype.clone = function() {
    var newFresnelParameters = new FresnelParameters2();
    DeepCopier.DeepCopy(this, newFresnelParameters);
    return newFresnelParameters;
  };
  FresnelParameters2.prototype.equals = function(otherFresnelParameters) {
    return otherFresnelParameters && this.bias === otherFresnelParameters.bias && this.power === otherFresnelParameters.power && this.leftColor.equals(otherFresnelParameters.leftColor) && this.rightColor.equals(otherFresnelParameters.rightColor) && this.isEnabled === otherFresnelParameters.isEnabled;
  };
  FresnelParameters2.prototype.serialize = function() {
    return {
      isEnabled: this.isEnabled,
      leftColor: this.leftColor.asArray(),
      rightColor: this.rightColor.asArray(),
      bias: this.bias,
      power: this.power
    };
  };
  FresnelParameters2.Parse = function(parsedFresnelParameters) {
    return new FresnelParameters2({
      isEnabled: parsedFresnelParameters.isEnabled,
      leftColor: Color3.FromArray(parsedFresnelParameters.leftColor),
      rightColor: Color3.FromArray(parsedFresnelParameters.rightColor),
      bias: parsedFresnelParameters.bias,
      power: parsedFresnelParameters.power || 1
    });
  };
  return FresnelParameters2;
}();
SerializationHelper._FresnelParametersParser = FresnelParameters.Parse;

// node_modules/@babylonjs/core/Materials/PBR/pbrBaseSimpleMaterial.js
var PBRBaseSimpleMaterial = function(_super) {
  __extends(PBRBaseSimpleMaterial2, _super);
  function PBRBaseSimpleMaterial2(name98, scene) {
    var _this = _super.call(this, name98, scene) || this;
    _this.maxSimultaneousLights = 4;
    _this.disableLighting = false;
    _this.invertNormalMapX = false;
    _this.invertNormalMapY = false;
    _this.emissiveColor = new Color3(0, 0, 0);
    _this.occlusionStrength = 1;
    _this.useLightmapAsShadowmap = false;
    _this._useAlphaFromAlbedoTexture = true;
    _this._useAmbientInGrayScale = true;
    return _this;
  }
  Object.defineProperty(PBRBaseSimpleMaterial2.prototype, "doubleSided", {
    get: function() {
      return this._twoSidedLighting;
    },
    set: function(value) {
      if (this._twoSidedLighting === value) {
        return;
      }
      this._twoSidedLighting = value;
      this.backFaceCulling = !value;
      this._markAllSubMeshesAsTexturesDirty();
    },
    enumerable: false,
    configurable: true
  });
  PBRBaseSimpleMaterial2.prototype.getClassName = function() {
    return "PBRBaseSimpleMaterial";
  };
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsLightsDirty")
  ], PBRBaseSimpleMaterial2.prototype, "maxSimultaneousLights", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsLightsDirty")
  ], PBRBaseSimpleMaterial2.prototype, "disableLighting", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty", "_reflectionTexture")
  ], PBRBaseSimpleMaterial2.prototype, "environmentTexture", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRBaseSimpleMaterial2.prototype, "invertNormalMapX", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRBaseSimpleMaterial2.prototype, "invertNormalMapY", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty", "_bumpTexture")
  ], PBRBaseSimpleMaterial2.prototype, "normalTexture", void 0);
  __decorate([
    serializeAsColor3("emissive"),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRBaseSimpleMaterial2.prototype, "emissiveColor", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRBaseSimpleMaterial2.prototype, "emissiveTexture", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty", "_ambientTextureStrength")
  ], PBRBaseSimpleMaterial2.prototype, "occlusionStrength", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty", "_ambientTexture")
  ], PBRBaseSimpleMaterial2.prototype, "occlusionTexture", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty", "_alphaCutOff")
  ], PBRBaseSimpleMaterial2.prototype, "alphaCutOff", void 0);
  __decorate([
    serialize()
  ], PBRBaseSimpleMaterial2.prototype, "doubleSided", null);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty", null)
  ], PBRBaseSimpleMaterial2.prototype, "lightmapTexture", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRBaseSimpleMaterial2.prototype, "useLightmapAsShadowmap", void 0);
  return PBRBaseSimpleMaterial2;
}(PBRBaseMaterial);

// node_modules/@babylonjs/core/Materials/PBR/pbrMetallicRoughnessMaterial.js
var PBRMetallicRoughnessMaterial = function(_super) {
  __extends(PBRMetallicRoughnessMaterial2, _super);
  function PBRMetallicRoughnessMaterial2(name98, scene) {
    var _this = _super.call(this, name98, scene) || this;
    _this._useRoughnessFromMetallicTextureAlpha = false;
    _this._useRoughnessFromMetallicTextureGreen = true;
    _this._useMetallnessFromMetallicTextureBlue = true;
    _this.metallic = 1;
    _this.roughness = 1;
    return _this;
  }
  PBRMetallicRoughnessMaterial2.prototype.getClassName = function() {
    return "PBRMetallicRoughnessMaterial";
  };
  PBRMetallicRoughnessMaterial2.prototype.clone = function(name98) {
    var _this = this;
    var clone = SerializationHelper.Clone(function() {
      return new PBRMetallicRoughnessMaterial2(name98, _this.getScene());
    }, this);
    clone.id = name98;
    clone.name = name98;
    this.clearCoat.copyTo(clone.clearCoat);
    this.anisotropy.copyTo(clone.anisotropy);
    this.brdf.copyTo(clone.brdf);
    this.sheen.copyTo(clone.sheen);
    this.subSurface.copyTo(clone.subSurface);
    return clone;
  };
  PBRMetallicRoughnessMaterial2.prototype.serialize = function() {
    var serializationObject = SerializationHelper.Serialize(this);
    serializationObject.customType = "BABYLON.PBRMetallicRoughnessMaterial";
    serializationObject.clearCoat = this.clearCoat.serialize();
    serializationObject.anisotropy = this.anisotropy.serialize();
    serializationObject.brdf = this.brdf.serialize();
    serializationObject.sheen = this.sheen.serialize();
    serializationObject.subSurface = this.subSurface.serialize();
    return serializationObject;
  };
  PBRMetallicRoughnessMaterial2.Parse = function(source, scene, rootUrl) {
    var material = SerializationHelper.Parse(function() {
      return new PBRMetallicRoughnessMaterial2(source.name, scene);
    }, source, scene, rootUrl);
    if (source.clearCoat) {
      material.clearCoat.parse(source.clearCoat, scene, rootUrl);
    }
    if (source.anisotropy) {
      material.anisotropy.parse(source.anisotropy, scene, rootUrl);
    }
    if (source.brdf) {
      material.brdf.parse(source.brdf, scene, rootUrl);
    }
    if (source.sheen) {
      material.sheen.parse(source.sheen, scene, rootUrl);
    }
    if (source.subSurface) {
      material.subSurface.parse(source.subSurface, scene, rootUrl);
    }
    return material;
  };
  __decorate([
    serializeAsColor3(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty", "_albedoColor")
  ], PBRMetallicRoughnessMaterial2.prototype, "baseColor", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty", "_albedoTexture")
  ], PBRMetallicRoughnessMaterial2.prototype, "baseTexture", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMetallicRoughnessMaterial2.prototype, "metallic", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMetallicRoughnessMaterial2.prototype, "roughness", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty", "_metallicTexture")
  ], PBRMetallicRoughnessMaterial2.prototype, "metallicRoughnessTexture", void 0);
  return PBRMetallicRoughnessMaterial2;
}(PBRBaseSimpleMaterial);
_TypeStore.RegisteredTypes["BABYLON.PBRMetallicRoughnessMaterial"] = PBRMetallicRoughnessMaterial;

// node_modules/@babylonjs/core/Materials/PBR/pbrSpecularGlossinessMaterial.js
var PBRSpecularGlossinessMaterial = function(_super) {
  __extends(PBRSpecularGlossinessMaterial2, _super);
  function PBRSpecularGlossinessMaterial2(name98, scene) {
    var _this = _super.call(this, name98, scene) || this;
    _this._useMicroSurfaceFromReflectivityMapAlpha = true;
    return _this;
  }
  PBRSpecularGlossinessMaterial2.prototype.getClassName = function() {
    return "PBRSpecularGlossinessMaterial";
  };
  PBRSpecularGlossinessMaterial2.prototype.clone = function(name98) {
    var _this = this;
    var clone = SerializationHelper.Clone(function() {
      return new PBRSpecularGlossinessMaterial2(name98, _this.getScene());
    }, this);
    clone.id = name98;
    clone.name = name98;
    this.clearCoat.copyTo(clone.clearCoat);
    this.anisotropy.copyTo(clone.anisotropy);
    this.brdf.copyTo(clone.brdf);
    this.sheen.copyTo(clone.sheen);
    this.subSurface.copyTo(clone.subSurface);
    return clone;
  };
  PBRSpecularGlossinessMaterial2.prototype.serialize = function() {
    var serializationObject = SerializationHelper.Serialize(this);
    serializationObject.customType = "BABYLON.PBRSpecularGlossinessMaterial";
    serializationObject.clearCoat = this.clearCoat.serialize();
    serializationObject.anisotropy = this.anisotropy.serialize();
    serializationObject.brdf = this.brdf.serialize();
    serializationObject.sheen = this.sheen.serialize();
    serializationObject.subSurface = this.subSurface.serialize();
    return serializationObject;
  };
  PBRSpecularGlossinessMaterial2.Parse = function(source, scene, rootUrl) {
    var material = SerializationHelper.Parse(function() {
      return new PBRSpecularGlossinessMaterial2(source.name, scene);
    }, source, scene, rootUrl);
    if (source.clearCoat) {
      material.clearCoat.parse(source.clearCoat, scene, rootUrl);
    }
    if (source.anisotropy) {
      material.anisotropy.parse(source.anisotropy, scene, rootUrl);
    }
    if (source.brdf) {
      material.brdf.parse(source.brdf, scene, rootUrl);
    }
    if (source.sheen) {
      material.sheen.parse(source.sheen, scene, rootUrl);
    }
    if (source.subSurface) {
      material.subSurface.parse(source.subSurface, scene, rootUrl);
    }
    return material;
  };
  __decorate([
    serializeAsColor3("diffuse"),
    expandToProperty("_markAllSubMeshesAsTexturesDirty", "_albedoColor")
  ], PBRSpecularGlossinessMaterial2.prototype, "diffuseColor", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty", "_albedoTexture")
  ], PBRSpecularGlossinessMaterial2.prototype, "diffuseTexture", void 0);
  __decorate([
    serializeAsColor3("specular"),
    expandToProperty("_markAllSubMeshesAsTexturesDirty", "_reflectivityColor")
  ], PBRSpecularGlossinessMaterial2.prototype, "specularColor", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty", "_microSurface")
  ], PBRSpecularGlossinessMaterial2.prototype, "glossiness", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty", "_reflectivityTexture")
  ], PBRSpecularGlossinessMaterial2.prototype, "specularGlossinessTexture", void 0);
  return PBRSpecularGlossinessMaterial2;
}(PBRBaseSimpleMaterial);
_TypeStore.RegisteredTypes["BABYLON.PBRSpecularGlossinessMaterial"] = PBRSpecularGlossinessMaterial;

// node_modules/@babylonjs/core/Materials/Textures/colorGradingTexture.js
var ColorGradingTexture = function(_super) {
  __extends(ColorGradingTexture2, _super);
  function ColorGradingTexture2(url, sceneOrEngine, onLoad) {
    if (onLoad === void 0) {
      onLoad = null;
    }
    var _this = _super.call(this, sceneOrEngine) || this;
    if (!url) {
      return _this;
    }
    _this._textureMatrix = Matrix.Identity();
    _this.name = url;
    _this.url = url;
    _this._onLoad = onLoad;
    _this._texture = _this._getFromCache(url, true);
    if (!_this._texture) {
      var scene = _this.getScene();
      if (scene) {
        if (!scene.useDelayedTextureLoading) {
          _this.loadTexture();
        } else {
          _this.delayLoadState = 4;
        }
      } else {
        _this.loadTexture();
      }
    } else {
      _this._triggerOnLoad();
    }
    return _this;
  }
  ColorGradingTexture2.prototype._triggerOnLoad = function() {
    if (this._onLoad) {
      this._onLoad();
    }
  };
  ColorGradingTexture2.prototype.getTextureMatrix = function() {
    return this._textureMatrix;
  };
  ColorGradingTexture2.prototype.load3dlTexture = function() {
    var _this = this;
    var engine = this._getEngine();
    var texture;
    if (engine.webGLVersion === 1) {
      texture = engine.createRawTexture(null, 1, 1, 5, false, false, 2, null, 0);
    } else {
      texture = engine.createRawTexture3D(null, 1, 1, 1, 5, false, false, 2, null, 0);
    }
    this._texture = texture;
    this._texture.isReady = false;
    this.isCube = false;
    this.is3D = engine.webGLVersion > 1;
    this.wrapU = 0;
    this.wrapV = 0;
    this.wrapR = 0;
    this.anisotropicFilteringLevel = 1;
    var callback = function(text) {
      if (typeof text !== "string") {
        return;
      }
      var data = null;
      var tempData = null;
      var line;
      var lines = text.split("\n");
      var size = 0, pixelIndexW = 0, pixelIndexH = 0, pixelIndexSlice = 0;
      var maxColor = 0;
      for (var i = 0; i < lines.length; i++) {
        line = lines[i];
        if (!ColorGradingTexture2._noneEmptyLineRegex.test(line)) {
          continue;
        }
        if (line.indexOf("#") === 0) {
          continue;
        }
        var words = line.split(" ");
        if (size === 0) {
          size = words.length;
          data = new Uint8Array(size * size * size * 4);
          tempData = new Float32Array(size * size * size * 4);
          continue;
        }
        if (size != 0) {
          var r = Math.max(parseInt(words[0]), 0);
          var g = Math.max(parseInt(words[1]), 0);
          var b = Math.max(parseInt(words[2]), 0);
          maxColor = Math.max(r, maxColor);
          maxColor = Math.max(g, maxColor);
          maxColor = Math.max(b, maxColor);
          var pixelStorageIndex = (pixelIndexW + pixelIndexSlice * size + pixelIndexH * size * size) * 4;
          if (tempData) {
            tempData[pixelStorageIndex + 0] = r;
            tempData[pixelStorageIndex + 1] = g;
            tempData[pixelStorageIndex + 2] = b;
          }
          pixelIndexH++;
          if (pixelIndexH % size == 0) {
            pixelIndexSlice++;
            pixelIndexH = 0;
            if (pixelIndexSlice % size == 0) {
              pixelIndexW++;
              pixelIndexSlice = 0;
            }
          }
        }
      }
      if (tempData && data) {
        for (var i = 0; i < tempData.length; i++) {
          if (i > 0 && (i + 1) % 4 === 0) {
            data[i] = 255;
          } else {
            var value = tempData[i];
            data[i] = value / maxColor * 255;
          }
        }
      }
      if (texture.is3D) {
        texture.updateSize(size, size, size);
        engine.updateRawTexture3D(texture, data, 5, false);
      } else {
        texture.updateSize(size * size, size);
        engine.updateRawTexture(texture, data, 5, false);
      }
      texture.isReady = true;
      _this._triggerOnLoad();
    };
    var scene = this.getScene();
    if (scene) {
      scene._loadFile(this.url, callback);
    } else {
      engine._loadFile(this.url, callback);
    }
    return this._texture;
  };
  ColorGradingTexture2.prototype.loadTexture = function() {
    if (this.url && this.url.toLocaleLowerCase().indexOf(".3dl") == this.url.length - 4) {
      this.load3dlTexture();
    }
  };
  ColorGradingTexture2.prototype.clone = function() {
    var newTexture = new ColorGradingTexture2(this.url, this.getScene() || this._getEngine());
    newTexture.level = this.level;
    return newTexture;
  };
  ColorGradingTexture2.prototype.delayLoad = function() {
    if (this.delayLoadState !== 4) {
      return;
    }
    this.delayLoadState = 1;
    this._texture = this._getFromCache(this.url, true);
    if (!this._texture) {
      this.loadTexture();
    }
  };
  ColorGradingTexture2.Parse = function(parsedTexture, scene) {
    var texture = null;
    if (parsedTexture.name && !parsedTexture.isRenderTarget) {
      texture = new ColorGradingTexture2(parsedTexture.name, scene);
      texture.name = parsedTexture.name;
      texture.level = parsedTexture.level;
    }
    return texture;
  };
  ColorGradingTexture2.prototype.serialize = function() {
    if (!this.name) {
      return null;
    }
    var serializationObject = {};
    serializationObject.name = this.name;
    serializationObject.level = this.level;
    serializationObject.customType = "BABYLON.ColorGradingTexture";
    return serializationObject;
  };
  ColorGradingTexture2._noneEmptyLineRegex = /\S+/;
  return ColorGradingTexture2;
}(BaseTexture);
_TypeStore.RegisteredTypes["BABYLON.ColorGradingTexture"] = ColorGradingTexture;

// node_modules/@babylonjs/core/Materials/Textures/equiRectangularCubeTexture.js
var EquiRectangularCubeTexture = function(_super) {
  __extends(EquiRectangularCubeTexture2, _super);
  function EquiRectangularCubeTexture2(url, scene, size, noMipmap, gammaSpace, onLoad, onError) {
    if (noMipmap === void 0) {
      noMipmap = false;
    }
    if (gammaSpace === void 0) {
      gammaSpace = true;
    }
    if (onLoad === void 0) {
      onLoad = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    var _this = _super.call(this, scene) || this;
    _this._onLoad = null;
    _this._onError = null;
    if (!url) {
      throw new Error("Image url is not set");
    }
    _this._coordinatesMode = Texture.CUBIC_MODE;
    _this.name = url;
    _this.url = url;
    _this._size = size;
    _this._noMipmap = noMipmap;
    _this.gammaSpace = gammaSpace;
    _this._onLoad = onLoad;
    _this._onError = onError;
    _this.hasAlpha = false;
    _this.isCube = true;
    _this._texture = _this._getFromCache(url, _this._noMipmap);
    if (!_this._texture) {
      if (!scene.useDelayedTextureLoading) {
        _this.loadImage(_this.loadTexture.bind(_this), _this._onError);
      } else {
        _this.delayLoadState = 4;
      }
    } else if (onLoad) {
      if (_this._texture.isReady) {
        Tools.SetImmediate(function() {
          return onLoad();
        });
      } else {
        _this._texture.onLoadedObservable.add(onLoad);
      }
    }
    return _this;
  }
  EquiRectangularCubeTexture2.prototype.loadImage = function(loadTextureCallback, onError) {
    var _this = this;
    var canvas = document.createElement("canvas");
    var image = new Image();
    image.addEventListener("load", function() {
      _this._width = image.width;
      _this._height = image.height;
      canvas.width = _this._width;
      canvas.height = _this._height;
      var ctx = canvas.getContext("2d");
      ctx.drawImage(image, 0, 0);
      var imageData = ctx.getImageData(0, 0, image.width, image.height);
      _this._buffer = imageData.data.buffer;
      canvas.remove();
      loadTextureCallback();
    });
    image.addEventListener("error", function(error) {
      if (onError) {
        onError(_this.getClassName() + " could not be loaded", error);
      }
    });
    image.src = this.url;
  };
  EquiRectangularCubeTexture2.prototype.loadTexture = function() {
    var _this = this;
    var scene = this.getScene();
    var callback = function() {
      var imageData = _this.getFloat32ArrayFromArrayBuffer(_this._buffer);
      var data = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(imageData, _this._width, _this._height, _this._size);
      var results = [];
      for (var i = 0; i < 6; i++) {
        var dataFace = data[EquiRectangularCubeTexture2._FacesMapping[i]];
        results.push(dataFace);
      }
      return results;
    };
    if (!scene) {
      return;
    }
    this._texture = scene.getEngine().createRawCubeTextureFromUrl(this.url, scene, this._size, 4, scene.getEngine().getCaps().textureFloat ? 1 : 7, this._noMipmap, callback, null, this._onLoad, this._onError);
  };
  EquiRectangularCubeTexture2.prototype.getFloat32ArrayFromArrayBuffer = function(buffer) {
    var dataView = new DataView(buffer);
    var floatImageData = new Float32Array(buffer.byteLength * 3 / 4);
    var k = 0;
    for (var i = 0; i < buffer.byteLength; i++) {
      if ((i + 1) % 4 !== 0) {
        floatImageData[k++] = dataView.getUint8(i) / 255;
      }
    }
    return floatImageData;
  };
  EquiRectangularCubeTexture2.prototype.getClassName = function() {
    return "EquiRectangularCubeTexture";
  };
  EquiRectangularCubeTexture2.prototype.clone = function() {
    var scene = this.getScene();
    if (!scene) {
      return this;
    }
    var newTexture = new EquiRectangularCubeTexture2(this.url, scene, this._size, this._noMipmap, this.gammaSpace);
    newTexture.level = this.level;
    newTexture.wrapU = this.wrapU;
    newTexture.wrapV = this.wrapV;
    newTexture.coordinatesIndex = this.coordinatesIndex;
    newTexture.coordinatesMode = this.coordinatesMode;
    return newTexture;
  };
  EquiRectangularCubeTexture2._FacesMapping = ["right", "left", "up", "down", "front", "back"];
  return EquiRectangularCubeTexture2;
}(BaseTexture);

// node_modules/@babylonjs/core/Materials/Textures/htmlElementTexture.js
var HtmlElementTexture = function(_super) {
  __extends(HtmlElementTexture2, _super);
  function HtmlElementTexture2(name98, element, options) {
    var _this = _super.call(this, options.scene || options.engine) || this;
    if (!element || !options.engine && !options.scene) {
      return _this;
    }
    options = __assign(__assign({}, HtmlElementTexture2.DefaultOptions), options);
    _this._generateMipMaps = options.generateMipMaps;
    _this._samplingMode = options.samplingMode;
    _this._textureMatrix = Matrix.Identity();
    _this.name = name98;
    _this.element = element;
    _this._isVideo = element instanceof HTMLVideoElement;
    _this.anisotropicFilteringLevel = 1;
    _this._createInternalTexture();
    return _this;
  }
  HtmlElementTexture2.prototype._createInternalTexture = function() {
    var width = 0;
    var height = 0;
    if (this._isVideo) {
      width = this.element.videoWidth;
      height = this.element.videoHeight;
    } else {
      width = this.element.width;
      height = this.element.height;
    }
    var engine = this._getEngine();
    if (engine) {
      this._texture = engine.createDynamicTexture(width, height, this._generateMipMaps, this._samplingMode);
    }
    this.update();
  };
  HtmlElementTexture2.prototype.getTextureMatrix = function() {
    return this._textureMatrix;
  };
  HtmlElementTexture2.prototype.update = function(invertY) {
    if (invertY === void 0) {
      invertY = null;
    }
    var engine = this._getEngine();
    if (this._texture == null || engine == null) {
      return;
    }
    if (this._isVideo) {
      var videoElement = this.element;
      if (videoElement.readyState < videoElement.HAVE_CURRENT_DATA) {
        return;
      }
      engine.updateVideoTexture(this._texture, videoElement, invertY === null ? true : invertY);
    } else {
      var canvasElement = this.element;
      engine.updateDynamicTexture(this._texture, canvasElement, invertY === null ? true : invertY, false);
    }
  };
  HtmlElementTexture2.DefaultOptions = {
    generateMipMaps: false,
    samplingMode: 2,
    engine: null,
    scene: null
  };
  return HtmlElementTexture2;
}(BaseTexture);

// node_modules/@babylonjs/core/Misc/tga.js
var TGATools = function() {
  function TGATools2() {
  }
  TGATools2.GetTGAHeader = function(data) {
    var offset = 0;
    var header = {
      id_length: data[offset++],
      colormap_type: data[offset++],
      image_type: data[offset++],
      colormap_index: data[offset++] | data[offset++] << 8,
      colormap_length: data[offset++] | data[offset++] << 8,
      colormap_size: data[offset++],
      origin: [
        data[offset++] | data[offset++] << 8,
        data[offset++] | data[offset++] << 8
      ],
      width: data[offset++] | data[offset++] << 8,
      height: data[offset++] | data[offset++] << 8,
      pixel_size: data[offset++],
      flags: data[offset++]
    };
    return header;
  };
  TGATools2.UploadContent = function(texture, data) {
    if (data.length < 19) {
      Logger.Error("Unable to load TGA file - Not enough data to contain header");
      return;
    }
    var offset = 18;
    var header = TGATools2.GetTGAHeader(data);
    if (header.id_length + offset > data.length) {
      Logger.Error("Unable to load TGA file - Not enough data");
      return;
    }
    offset += header.id_length;
    var use_rle = false;
    var use_pal = false;
    var use_grey = false;
    switch (header.image_type) {
      case TGATools2._TYPE_RLE_INDEXED:
        use_rle = true;
      case TGATools2._TYPE_INDEXED:
        use_pal = true;
        break;
      case TGATools2._TYPE_RLE_RGB:
        use_rle = true;
      case TGATools2._TYPE_RGB:
        break;
      case TGATools2._TYPE_RLE_GREY:
        use_rle = true;
      case TGATools2._TYPE_GREY:
        use_grey = true;
        break;
    }
    var pixel_data;
    var pixel_size = header.pixel_size >> 3;
    var pixel_total = header.width * header.height * pixel_size;
    var palettes;
    if (use_pal) {
      palettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));
    }
    if (use_rle) {
      pixel_data = new Uint8Array(pixel_total);
      var c, count, i;
      var localOffset = 0;
      var pixels = new Uint8Array(pixel_size);
      while (offset < pixel_total && localOffset < pixel_total) {
        c = data[offset++];
        count = (c & 127) + 1;
        if (c & 128) {
          for (i = 0; i < pixel_size; ++i) {
            pixels[i] = data[offset++];
          }
          for (i = 0; i < count; ++i) {
            pixel_data.set(pixels, localOffset + i * pixel_size);
          }
          localOffset += pixel_size * count;
        } else {
          count *= pixel_size;
          for (i = 0; i < count; ++i) {
            pixel_data[localOffset + i] = data[offset++];
          }
          localOffset += count;
        }
      }
    } else {
      pixel_data = data.subarray(offset, offset += use_pal ? header.width * header.height : pixel_total);
    }
    var x_start, y_start, x_step, y_step, y_end, x_end;
    switch ((header.flags & TGATools2._ORIGIN_MASK) >> TGATools2._ORIGIN_SHIFT) {
      default:
      case TGATools2._ORIGIN_UL:
        x_start = 0;
        x_step = 1;
        x_end = header.width;
        y_start = 0;
        y_step = 1;
        y_end = header.height;
        break;
      case TGATools2._ORIGIN_BL:
        x_start = 0;
        x_step = 1;
        x_end = header.width;
        y_start = header.height - 1;
        y_step = -1;
        y_end = -1;
        break;
      case TGATools2._ORIGIN_UR:
        x_start = header.width - 1;
        x_step = -1;
        x_end = -1;
        y_start = 0;
        y_step = 1;
        y_end = header.height;
        break;
      case TGATools2._ORIGIN_BR:
        x_start = header.width - 1;
        x_step = -1;
        x_end = -1;
        y_start = header.height - 1;
        y_step = -1;
        y_end = -1;
        break;
    }
    var func = "_getImageData" + (use_grey ? "Grey" : "") + header.pixel_size + "bits";
    var imageData = TGATools2[func](header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end);
    var engine = texture.getEngine();
    engine._uploadDataToTextureDirectly(texture, imageData);
  };
  TGATools2._getImageData8bits = function(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
    var image = pixel_data, colormap = palettes;
    var width = header.width, height = header.height;
    var color, i = 0, x, y;
    var imageData = new Uint8Array(width * height * 4);
    for (y = y_start; y !== y_end; y += y_step) {
      for (x = x_start; x !== x_end; x += x_step, i++) {
        color = image[i];
        imageData[(x + width * y) * 4 + 3] = 255;
        imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];
        imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];
        imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];
      }
    }
    return imageData;
  };
  TGATools2._getImageData16bits = function(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
    var image = pixel_data;
    var width = header.width, height = header.height;
    var color, i = 0, x, y;
    var imageData = new Uint8Array(width * height * 4);
    for (y = y_start; y !== y_end; y += y_step) {
      for (x = x_start; x !== x_end; x += x_step, i += 2) {
        color = image[i + 0] + (image[i + 1] << 8);
        var r = ((color & 31744) >> 10) * 255 / 31 | 0;
        var g = ((color & 992) >> 5) * 255 / 31 | 0;
        var b = (color & 31) * 255 / 31 | 0;
        imageData[(x + width * y) * 4 + 0] = r;
        imageData[(x + width * y) * 4 + 1] = g;
        imageData[(x + width * y) * 4 + 2] = b;
        imageData[(x + width * y) * 4 + 3] = color & 32768 ? 0 : 255;
      }
    }
    return imageData;
  };
  TGATools2._getImageData24bits = function(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
    var image = pixel_data;
    var width = header.width, height = header.height;
    var i = 0, x, y;
    var imageData = new Uint8Array(width * height * 4);
    for (y = y_start; y !== y_end; y += y_step) {
      for (x = x_start; x !== x_end; x += x_step, i += 3) {
        imageData[(x + width * y) * 4 + 3] = 255;
        imageData[(x + width * y) * 4 + 2] = image[i + 0];
        imageData[(x + width * y) * 4 + 1] = image[i + 1];
        imageData[(x + width * y) * 4 + 0] = image[i + 2];
      }
    }
    return imageData;
  };
  TGATools2._getImageData32bits = function(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
    var image = pixel_data;
    var width = header.width, height = header.height;
    var i = 0, x, y;
    var imageData = new Uint8Array(width * height * 4);
    for (y = y_start; y !== y_end; y += y_step) {
      for (x = x_start; x !== x_end; x += x_step, i += 4) {
        imageData[(x + width * y) * 4 + 2] = image[i + 0];
        imageData[(x + width * y) * 4 + 1] = image[i + 1];
        imageData[(x + width * y) * 4 + 0] = image[i + 2];
        imageData[(x + width * y) * 4 + 3] = image[i + 3];
      }
    }
    return imageData;
  };
  TGATools2._getImageDataGrey8bits = function(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
    var image = pixel_data;
    var width = header.width, height = header.height;
    var color, i = 0, x, y;
    var imageData = new Uint8Array(width * height * 4);
    for (y = y_start; y !== y_end; y += y_step) {
      for (x = x_start; x !== x_end; x += x_step, i++) {
        color = image[i];
        imageData[(x + width * y) * 4 + 0] = color;
        imageData[(x + width * y) * 4 + 1] = color;
        imageData[(x + width * y) * 4 + 2] = color;
        imageData[(x + width * y) * 4 + 3] = 255;
      }
    }
    return imageData;
  };
  TGATools2._getImageDataGrey16bits = function(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
    var image = pixel_data;
    var width = header.width, height = header.height;
    var i = 0, x, y;
    var imageData = new Uint8Array(width * height * 4);
    for (y = y_start; y !== y_end; y += y_step) {
      for (x = x_start; x !== x_end; x += x_step, i += 2) {
        imageData[(x + width * y) * 4 + 0] = image[i + 0];
        imageData[(x + width * y) * 4 + 1] = image[i + 0];
        imageData[(x + width * y) * 4 + 2] = image[i + 0];
        imageData[(x + width * y) * 4 + 3] = image[i + 1];
      }
    }
    return imageData;
  };
  TGATools2._TYPE_INDEXED = 1;
  TGATools2._TYPE_RGB = 2;
  TGATools2._TYPE_GREY = 3;
  TGATools2._TYPE_RLE_INDEXED = 9;
  TGATools2._TYPE_RLE_RGB = 10;
  TGATools2._TYPE_RLE_GREY = 11;
  TGATools2._ORIGIN_MASK = 48;
  TGATools2._ORIGIN_SHIFT = 4;
  TGATools2._ORIGIN_BL = 0;
  TGATools2._ORIGIN_BR = 1;
  TGATools2._ORIGIN_UL = 2;
  TGATools2._ORIGIN_UR = 3;
  return TGATools2;
}();

// node_modules/@babylonjs/core/Materials/Textures/Loaders/tgaTextureLoader.js
var _TGATextureLoader = function() {
  function _TGATextureLoader2() {
    this.supportCascades = false;
  }
  _TGATextureLoader2.prototype.canLoad = function(extension) {
    return StringTools.EndsWith(extension, ".tga");
  };
  _TGATextureLoader2.prototype.loadCubeData = function(data, texture, createPolynomials, onLoad, onError) {
    throw ".env not supported in Cube.";
  };
  _TGATextureLoader2.prototype.loadData = function(data, texture, callback) {
    var bytes = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    var header = TGATools.GetTGAHeader(bytes);
    callback(header.width, header.height, texture.generateMipMaps, false, function() {
      TGATools.UploadContent(texture, bytes);
    });
  };
  return _TGATextureLoader2;
}();
Engine._TextureLoaders.push(new _TGATextureLoader());

// node_modules/@babylonjs/core/Misc/basis.js
var BasisFileInfo = function() {
  function BasisFileInfo2() {
  }
  return BasisFileInfo2;
}();
var TranscodeResult = function() {
  function TranscodeResult2() {
  }
  return TranscodeResult2;
}();
var BasisTranscodeConfiguration = function() {
  function BasisTranscodeConfiguration2() {
  }
  return BasisTranscodeConfiguration2;
}();
var BASIS_FORMATS;
(function(BASIS_FORMATS2) {
  BASIS_FORMATS2[BASIS_FORMATS2["cTFETC1"] = 0] = "cTFETC1";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFBC1"] = 1] = "cTFBC1";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFBC4"] = 2] = "cTFBC4";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFPVRTC1_4_OPAQUE_ONLY"] = 3] = "cTFPVRTC1_4_OPAQUE_ONLY";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFBC7_M6_OPAQUE_ONLY"] = 4] = "cTFBC7_M6_OPAQUE_ONLY";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFETC2"] = 5] = "cTFETC2";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFBC3"] = 6] = "cTFBC3";
  BASIS_FORMATS2[BASIS_FORMATS2["cTFBC5"] = 7] = "cTFBC5";
})(BASIS_FORMATS || (BASIS_FORMATS = {}));
var BasisTools = function() {
  function BasisTools2() {
  }
  BasisTools2.GetInternalFormatFromBasisFormat = function(basisFormat) {
    var COMPRESSED_RGB_S3TC_DXT1_EXT = 33776;
    var COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779;
    var RGB_ETC1_Format = 36196;
    if (basisFormat === BASIS_FORMATS.cTFETC1) {
      return RGB_ETC1_Format;
    } else if (basisFormat === BASIS_FORMATS.cTFBC1) {
      return COMPRESSED_RGB_S3TC_DXT1_EXT;
    } else if (basisFormat === BASIS_FORMATS.cTFBC3) {
      return COMPRESSED_RGBA_S3TC_DXT5_EXT;
    } else {
      throw "The chosen Basis transcoder format is not currently supported";
    }
  };
  BasisTools2._CreateWorkerAsync = function() {
    var _this = this;
    if (!this._WorkerPromise) {
      this._WorkerPromise = new Promise(function(res) {
        if (_this._Worker) {
          res(_this._Worker);
        } else {
          Tools.LoadFileAsync(BasisTools2.WasmModuleURL).then(function(wasmBinary) {
            var workerBlobUrl = URL.createObjectURL(new Blob(["(" + workerFunc2 + ")()"], { type: "application/javascript" }));
            _this._Worker = new Worker(workerBlobUrl);
            var initHandler = function(msg) {
              if (msg.data.action === "init") {
                _this._Worker.removeEventListener("message", initHandler);
                res(_this._Worker);
              }
            };
            _this._Worker.addEventListener("message", initHandler);
            _this._Worker.postMessage({ action: "init", url: BasisTools2.JSModuleURL, wasmBinary });
          });
        }
      });
    }
    return this._WorkerPromise;
  };
  BasisTools2.TranscodeAsync = function(data, config) {
    var _this = this;
    var dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;
    return new Promise(function(res, rej) {
      _this._CreateWorkerAsync().then(function() {
        var actionId = _this._actionId++;
        var messageHandler = function(msg) {
          if (msg.data.action === "transcode" && msg.data.id === actionId) {
            _this._Worker.removeEventListener("message", messageHandler);
            if (!msg.data.success) {
              rej("Transcode is not supported on this device");
            } else {
              res(msg.data);
            }
          }
        };
        _this._Worker.addEventListener("message", messageHandler);
        var dataViewCopy = new Uint8Array(dataView.byteLength);
        dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));
        _this._Worker.postMessage({ action: "transcode", id: actionId, imageData: dataViewCopy, config, ignoreSupportedFormats: _this._IgnoreSupportedFormats }, [dataViewCopy.buffer]);
      });
    });
  };
  BasisTools2.LoadTextureFromTranscodeResult = function(texture, transcodeResult) {
    var engine = texture.getEngine();
    var _loop_1 = function() {
      rootImage = transcodeResult.fileInfo.images[i].levels[0];
      texture._invertVScale = texture.invertY;
      if (transcodeResult.format === -1) {
        texture.type = 10;
        texture.format = 4;
        if (engine.webGLVersion < 2 && (Scalar.Log2(rootImage.width) % 1 !== 0 || Scalar.Log2(rootImage.height) % 1 !== 0)) {
          var source_1 = new InternalTexture(engine, InternalTextureSource.Temp);
          texture._invertVScale = texture.invertY;
          source_1.type = 10;
          source_1.format = 4;
          source_1.width = rootImage.width + 3 & ~3;
          source_1.height = rootImage.height + 3 & ~3;
          engine._bindTextureDirectly(engine._gl.TEXTURE_2D, source_1, true);
          engine._uploadDataToTextureDirectly(source_1, rootImage.transcodedPixels, i, 0, 4, true);
          engine._rescaleTexture(source_1, texture, engine.scenes[0], engine._getInternalFormat(4), function() {
            engine._releaseTexture(source_1);
            engine._bindTextureDirectly(engine._gl.TEXTURE_2D, texture, true);
          });
        } else {
          texture._invertVScale = !texture.invertY;
          texture.width = rootImage.width + 3 & ~3;
          texture.height = rootImage.height + 3 & ~3;
          engine._uploadDataToTextureDirectly(texture, rootImage.transcodedPixels, i, 0, 4, true);
        }
      } else {
        texture.width = rootImage.width;
        texture.height = rootImage.height;
        transcodeResult.fileInfo.images[i].levels.forEach(function(level, index) {
          engine._uploadCompressedDataToTextureDirectly(texture, BasisTools2.GetInternalFormatFromBasisFormat(transcodeResult.format), level.width, level.height, level.transcodedPixels, i, index);
        });
        if (engine.webGLVersion < 2 && (Scalar.Log2(texture.width) % 1 !== 0 || Scalar.Log2(texture.height) % 1 !== 0)) {
          Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1.");
          texture._cachedWrapU = Texture.CLAMP_ADDRESSMODE;
          texture._cachedWrapV = Texture.CLAMP_ADDRESSMODE;
        }
      }
    };
    var rootImage;
    for (var i = 0; i < transcodeResult.fileInfo.images.length; i++) {
      _loop_1();
    }
  };
  BasisTools2._IgnoreSupportedFormats = false;
  BasisTools2.JSModuleURL = "https://preview.babylonjs.com/basisTranscoder/basis_transcoder.js";
  BasisTools2.WasmModuleURL = "https://preview.babylonjs.com/basisTranscoder/basis_transcoder.wasm";
  BasisTools2._WorkerPromise = null;
  BasisTools2._Worker = null;
  BasisTools2._actionId = 0;
  return BasisTools2;
}();
function workerFunc2() {
  var _BASIS_FORMAT = {
    cTFETC1: 0,
    cTFBC1: 1,
    cTFBC4: 2,
    cTFPVRTC1_4_OPAQUE_ONLY: 3,
    cTFBC7_M6_OPAQUE_ONLY: 4,
    cTFETC2: 5,
    cTFBC3: 6,
    cTFBC5: 7
  };
  var transcoderModulePromise = null;
  onmessage = function(event) {
    if (event.data.action === "init") {
      if (!transcoderModulePromise) {
        Module = { wasmBinary: event.data.wasmBinary };
        importScripts(event.data.url);
        transcoderModulePromise = new Promise(function(res) {
          Module.onRuntimeInitialized = function() {
            Module.initializeBasis();
            res();
          };
        });
      }
      transcoderModulePromise.then(function() {
        postMessage({ action: "init" });
      });
    } else if (event.data.action === "transcode") {
      var config = event.data.config;
      var imgData = event.data.imageData;
      var loadedFile = new Module.BasisFile(imgData);
      var fileInfo = GetFileInfo(loadedFile);
      var format = event.data.ignoreSupportedFormats ? null : GetSupportedTranscodeFormat(event.data.config, fileInfo);
      var needsConversion = false;
      if (format === null) {
        needsConversion = true;
        format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;
      }
      var success = true;
      if (!loadedFile.startTranscoding()) {
        success = false;
      }
      var buffers = [];
      for (var imageIndex = 0; imageIndex < fileInfo.images.length; imageIndex++) {
        if (!success) {
          break;
        }
        var image = fileInfo.images[imageIndex];
        if (config.loadSingleImage === void 0 || config.loadSingleImage === imageIndex) {
          var mipCount = image.levels.length;
          if (config.loadMipmapLevels === false) {
            mipCount = 1;
          }
          for (var levelIndex = 0; levelIndex < mipCount; levelIndex++) {
            var levelInfo = image.levels[levelIndex];
            var pixels = TranscodeLevel(loadedFile, imageIndex, levelIndex, format, needsConversion);
            if (!pixels) {
              success = false;
              break;
            }
            levelInfo.transcodedPixels = pixels;
            buffers.push(levelInfo.transcodedPixels.buffer);
          }
        }
      }
      loadedFile.close();
      loadedFile.delete();
      if (needsConversion) {
        format = -1;
      }
      if (!success) {
        postMessage({ action: "transcode", success, id: event.data.id });
      } else {
        postMessage({ action: "transcode", success, id: event.data.id, fileInfo, format }, buffers);
      }
    }
  };
  function GetSupportedTranscodeFormat(config, fileInfo) {
    var format = null;
    if (config.supportedCompressionFormats) {
      if (config.supportedCompressionFormats.etc1) {
        format = _BASIS_FORMAT.cTFETC1;
      } else if (config.supportedCompressionFormats.s3tc) {
        format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;
      } else if (config.supportedCompressionFormats.pvrtc) {
      } else if (config.supportedCompressionFormats.etc2) {
        format = _BASIS_FORMAT.cTFETC2;
      }
    }
    return format;
  }
  function GetFileInfo(basisFile) {
    var hasAlpha = basisFile.getHasAlpha();
    var imageCount = basisFile.getNumImages();
    var images = [];
    for (var i = 0; i < imageCount; i++) {
      var imageInfo = {
        levels: []
      };
      var levelCount = basisFile.getNumLevels(i);
      for (var level = 0; level < levelCount; level++) {
        var levelInfo = {
          width: basisFile.getImageWidth(i, level),
          height: basisFile.getImageHeight(i, level)
        };
        imageInfo.levels.push(levelInfo);
      }
      images.push(imageInfo);
    }
    var info = { hasAlpha, images };
    return info;
  }
  function TranscodeLevel(loadedFile, imageIndex, levelIndex, format, convertToRgb565) {
    var dstSize = loadedFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, format);
    var dst = new Uint8Array(dstSize);
    if (!loadedFile.transcodeImage(dst, imageIndex, levelIndex, format, 1, 0)) {
      return null;
    }
    if (convertToRgb565) {
      var alignedWidth = loadedFile.getImageWidth(imageIndex, levelIndex) + 3 & ~3;
      var alignedHeight = loadedFile.getImageHeight(imageIndex, levelIndex) + 3 & ~3;
      dst = ConvertDxtToRgb565(dst, 0, alignedWidth, alignedHeight);
    }
    return dst;
  }
  function ConvertDxtToRgb565(src, srcByteOffset, width, height) {
    var c = new Uint16Array(4);
    var dst = new Uint16Array(width * height);
    var blockWidth = width / 4;
    var blockHeight = height / 4;
    for (var blockY = 0; blockY < blockHeight; blockY++) {
      for (var blockX = 0; blockX < blockWidth; blockX++) {
        var i = srcByteOffset + 8 * (blockY * blockWidth + blockX);
        c[0] = src[i] | src[i + 1] << 8;
        c[1] = src[i + 2] | src[i + 3] << 8;
        c[2] = (2 * (c[0] & 31) + 1 * (c[1] & 31)) / 3 | (2 * (c[0] & 2016) + 1 * (c[1] & 2016)) / 3 & 2016 | (2 * (c[0] & 63488) + 1 * (c[1] & 63488)) / 3 & 63488;
        c[3] = (2 * (c[1] & 31) + 1 * (c[0] & 31)) / 3 | (2 * (c[1] & 2016) + 1 * (c[0] & 2016)) / 3 & 2016 | (2 * (c[1] & 63488) + 1 * (c[0] & 63488)) / 3 & 63488;
        for (var row = 0; row < 4; row++) {
          var m = src[i + 4 + row];
          var dstI = (blockY * 4 + row) * width + blockX * 4;
          dst[dstI++] = c[m & 3];
          dst[dstI++] = c[m >> 2 & 3];
          dst[dstI++] = c[m >> 4 & 3];
          dst[dstI++] = c[m >> 6 & 3];
        }
      }
    }
    return dst;
  }
}

// node_modules/@babylonjs/core/Materials/Textures/Loaders/basisTextureLoader.js
var _BasisTextureLoader = function() {
  function _BasisTextureLoader2() {
    this.supportCascades = false;
  }
  _BasisTextureLoader2.prototype.canLoad = function(extension) {
    return StringTools.EndsWith(extension, ".basis");
  };
  _BasisTextureLoader2.prototype.loadCubeData = function(data, texture, createPolynomials, onLoad, onError) {
    if (Array.isArray(data)) {
      return;
    }
    var caps = texture.getEngine().getCaps();
    var transcodeConfig = {
      supportedCompressionFormats: {
        etc1: caps.etc1 ? true : false,
        s3tc: caps.s3tc ? true : false,
        pvrtc: caps.pvrtc ? true : false,
        etc2: caps.etc2 ? true : false
      }
    };
    BasisTools.TranscodeAsync(data, transcodeConfig).then(function(result) {
      var hasMipmap = result.fileInfo.images[0].levels.length > 1 && texture.generateMipMaps;
      BasisTools.LoadTextureFromTranscodeResult(texture, result);
      texture.getEngine()._setCubeMapTextureParams(texture, hasMipmap);
      texture.isReady = true;
      texture.onLoadedObservable.notifyObservers(texture);
      texture.onLoadedObservable.clear();
      if (onLoad) {
        onLoad();
      }
    }).catch(function(err) {
      Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device");
      texture.isReady = true;
    });
  };
  _BasisTextureLoader2.prototype.loadData = function(data, texture, callback) {
    var caps = texture.getEngine().getCaps();
    var transcodeConfig = {
      supportedCompressionFormats: {
        etc1: caps.etc1 ? true : false,
        s3tc: caps.s3tc ? true : false,
        pvrtc: caps.pvrtc ? true : false,
        etc2: caps.etc2 ? true : false
      }
    };
    BasisTools.TranscodeAsync(data, transcodeConfig).then(function(result) {
      var rootImage = result.fileInfo.images[0].levels[0];
      var hasMipmap = result.fileInfo.images[0].levels.length > 1 && texture.generateMipMaps;
      callback(rootImage.width, rootImage.height, hasMipmap, result.format !== -1, function() {
        BasisTools.LoadTextureFromTranscodeResult(texture, result);
      });
    }).catch(function(err) {
      Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device");
      callback(0, 0, false, false, function() {
      });
    });
  };
  return _BasisTextureLoader2;
}();
Engine._TextureLoaders.push(new _BasisTextureLoader());

// node_modules/@babylonjs/core/Materials/Textures/multiRenderTarget.js
var MultiRenderTarget = function(_super) {
  __extends(MultiRenderTarget2, _super);
  function MultiRenderTarget2(name98, size, count, scene, options) {
    var _this = this;
    var generateMipMaps = options && options.generateMipMaps ? options.generateMipMaps : false;
    var generateDepthTexture = options && options.generateDepthTexture ? options.generateDepthTexture : false;
    var doNotChangeAspectRatio = !options || options.doNotChangeAspectRatio === void 0 ? true : options.doNotChangeAspectRatio;
    _this = _super.call(this, name98, size, scene, generateMipMaps, doNotChangeAspectRatio) || this;
    if (!_this.isSupported) {
      _this.dispose();
      return;
    }
    var types = [];
    var samplingModes = [];
    _this._initTypes(count, types, samplingModes, options);
    var generateDepthBuffer = !options || options.generateDepthBuffer === void 0 ? true : options.generateDepthBuffer;
    var generateStencilBuffer = !options || options.generateStencilBuffer === void 0 ? false : options.generateStencilBuffer;
    _this._size = size;
    _this._multiRenderTargetOptions = {
      samplingModes,
      generateMipMaps,
      generateDepthBuffer,
      generateStencilBuffer,
      generateDepthTexture,
      types,
      textureCount: count
    };
    _this._count = count;
    _this._createInternalTextures();
    _this._createTextures();
    return _this;
  }
  Object.defineProperty(MultiRenderTarget2.prototype, "isSupported", {
    get: function() {
      return this._getEngine().webGLVersion > 1 || this._getEngine().getCaps().drawBuffersExtension;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MultiRenderTarget2.prototype, "textures", {
    get: function() {
      return this._textures;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MultiRenderTarget2.prototype, "count", {
    get: function() {
      return this._count;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MultiRenderTarget2.prototype, "depthTexture", {
    get: function() {
      return this._textures[this._textures.length - 1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MultiRenderTarget2.prototype, "wrapU", {
    set: function(wrap) {
      if (this._textures) {
        for (var i = 0; i < this._textures.length; i++) {
          this._textures[i].wrapU = wrap;
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MultiRenderTarget2.prototype, "wrapV", {
    set: function(wrap) {
      if (this._textures) {
        for (var i = 0; i < this._textures.length; i++) {
          this._textures[i].wrapV = wrap;
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  MultiRenderTarget2.prototype._initTypes = function(count, types, samplingModes, options) {
    for (var i = 0; i < count; i++) {
      if (options && options.types && options.types[i] !== void 0) {
        types.push(options.types[i]);
      } else {
        types.push(options && options.defaultType ? options.defaultType : 0);
      }
      if (options && options.samplingModes && options.samplingModes[i] !== void 0) {
        samplingModes.push(options.samplingModes[i]);
      } else {
        samplingModes.push(Texture.BILINEAR_SAMPLINGMODE);
      }
    }
  };
  MultiRenderTarget2.prototype._rebuild = function(forceFullRebuild) {
    if (forceFullRebuild === void 0) {
      forceFullRebuild = false;
    }
    this.releaseInternalTextures();
    this._createInternalTextures();
    if (forceFullRebuild) {
      this._createTextures();
    }
    for (var i = 0; i < this._internalTextures.length; i++) {
      var texture = this._textures[i];
      texture._texture = this._internalTextures[i];
    }
    this._texture = this._internalTextures[0];
    if (this.samples !== 1) {
      this._getEngine().updateMultipleRenderTargetTextureSampleCount(this._internalTextures, this.samples);
    }
  };
  MultiRenderTarget2.prototype._createInternalTextures = function() {
    this._internalTextures = this._getEngine().createMultipleRenderTarget(this._size, this._multiRenderTargetOptions);
  };
  MultiRenderTarget2.prototype._createTextures = function() {
    this._textures = [];
    for (var i = 0; i < this._internalTextures.length; i++) {
      var texture = new Texture(null, this.getScene());
      texture._texture = this._internalTextures[i];
      this._textures.push(texture);
    }
    this._texture = this._internalTextures[0];
  };
  MultiRenderTarget2.prototype.replaceTexture = function(texture, index) {
    if (texture._texture) {
      this._textures[index] = texture;
      this._internalTextures[index] = texture._texture;
    }
  };
  Object.defineProperty(MultiRenderTarget2.prototype, "samples", {
    get: function() {
      return this._samples;
    },
    set: function(value) {
      if (this._samples === value) {
        return;
      }
      this._samples = this._getEngine().updateMultipleRenderTargetTextureSampleCount(this._internalTextures, value);
    },
    enumerable: false,
    configurable: true
  });
  MultiRenderTarget2.prototype.resize = function(size) {
    this._size = size;
    this._rebuild();
  };
  MultiRenderTarget2.prototype.updateCount = function(count, options) {
    this._multiRenderTargetOptions.textureCount = count;
    this._count = count;
    var types = [];
    var samplingModes = [];
    this._initTypes(count, types, samplingModes, options);
    this._multiRenderTargetOptions.types = types;
    this._multiRenderTargetOptions.samplingModes = samplingModes;
    this._rebuild(true);
  };
  MultiRenderTarget2.prototype.unbindFrameBuffer = function(engine, faceIndex) {
    var _this = this;
    engine.unBindMultiColorAttachmentFramebuffer(this._internalTextures, this.isCube, function() {
      _this.onAfterRenderObservable.notifyObservers(faceIndex);
    });
  };
  MultiRenderTarget2.prototype.dispose = function() {
    this.releaseInternalTextures();
    _super.prototype.dispose.call(this);
  };
  MultiRenderTarget2.prototype.releaseInternalTextures = function() {
    if (!this._internalTextures) {
      return;
    }
    for (var i = this._internalTextures.length - 1; i >= 0; i--) {
      if (this._internalTextures[i] !== void 0) {
        this._internalTextures[i].dispose();
        this._internalTextures.splice(i, 1);
      }
    }
  };
  return MultiRenderTarget2;
}(RenderTargetTexture);

// node_modules/@babylonjs/core/Materials/Textures/Packer/frame.js
var TexturePackerFrame = function() {
  function TexturePackerFrame2(id, scale, offset) {
    this.id = id;
    this.scale = scale;
    this.offset = offset;
  }
  return TexturePackerFrame2;
}();

// node_modules/@babylonjs/core/Materials/Textures/Packer/packer.js
var TexturePacker = function() {
  function TexturePacker2(name98, meshes, options, scene) {
    var _b, _c, _d, _e, _g, _h, _j, _k, _l, _m, _o, _p, _q;
    this.name = name98;
    this.meshes = meshes;
    this.scene = scene;
    this.options = options;
    this.options.map = (_b = this.options.map) !== null && _b !== void 0 ? _b : [
      "ambientTexture",
      "bumpTexture",
      "diffuseTexture",
      "emissiveTexture",
      "lightmapTexture",
      "opacityTexture",
      "reflectionTexture",
      "refractionTexture",
      "specularTexture"
    ];
    this.options.uvsIn = (_c = this.options.uvsIn) !== null && _c !== void 0 ? _c : VertexBuffer.UVKind;
    this.options.uvsOut = (_d = this.options.uvsOut) !== null && _d !== void 0 ? _d : VertexBuffer.UVKind;
    this.options.layout = (_e = this.options.layout) !== null && _e !== void 0 ? _e : TexturePacker2.LAYOUT_STRIP;
    if (this.options.layout === TexturePacker2.LAYOUT_COLNUM) {
      this.options.colnum = (_g = this.options.colnum) !== null && _g !== void 0 ? _g : 8;
    }
    this.options.updateInputMeshes = (_h = this.options.updateInputMeshes) !== null && _h !== void 0 ? _h : true;
    this.options.disposeSources = (_j = this.options.disposeSources) !== null && _j !== void 0 ? _j : true;
    this._expecting = 0;
    this.options.fillBlanks = (_k = this.options.fillBlanks) !== null && _k !== void 0 ? _k : true;
    if (this.options.fillBlanks === true) {
      this.options.customFillColor = (_l = this.options.customFillColor) !== null && _l !== void 0 ? _l : "black";
    }
    this.options.frameSize = (_m = this.options.frameSize) !== null && _m !== void 0 ? _m : 256;
    this.options.paddingRatio = (_o = this.options.paddingRatio) !== null && _o !== void 0 ? _o : 0.0115;
    this._paddingValue = Math.ceil(this.options.frameSize * this.options.paddingRatio);
    if (this._paddingValue % 2 !== 0) {
      this._paddingValue++;
    }
    this.options.paddingMode = (_p = this.options.paddingMode) !== null && _p !== void 0 ? _p : TexturePacker2.SUBUV_WRAP;
    if (this.options.paddingMode === TexturePacker2.SUBUV_COLOR) {
      this.options.paddingColor = (_q = this.options.paddingColor) !== null && _q !== void 0 ? _q : new Color4(0, 0, 0, 1);
    }
    this.sets = {};
    this.frames = [];
    return this;
  }
  TexturePacker2.prototype._createFrames = function(resolve) {
    var _this = this;
    var dtSize = this._calculateSize();
    var dtUnits = new Vector2(1, 1).divide(dtSize);
    var doneCount = 0;
    var expecting = this._expecting;
    var meshLength = this.meshes.length;
    var sKeys = Object.keys(this.sets);
    for (var i = 0; i < sKeys.length; i++) {
      var setName = sKeys[i];
      var dt = new DynamicTexture(this.name + ".TexturePack." + setName + "Set", { width: dtSize.x, height: dtSize.y }, this.scene, true, Texture.TRILINEAR_SAMPLINGMODE, Engine.TEXTUREFORMAT_RGBA);
      var dtx = dt.getContext();
      dtx.fillStyle = "rgba(0,0,0,0)";
      dtx.fillRect(0, 0, dtSize.x, dtSize.y);
      dt.update(false);
      this.sets[setName] = dt;
    }
    var baseSize = this.options.frameSize || 256;
    var padding = this._paddingValue;
    var tcs = baseSize + 2 * padding;
    var done = function() {
      _this._calculateMeshUVFrames(baseSize, padding, dtSize, dtUnits, _this.options.updateInputMeshes || false);
    };
    for (var i = 0; i < meshLength; i++) {
      var m = this.meshes[i];
      var mat = m.material;
      var _loop_1 = function(j2) {
        var tempTexture = new DynamicTexture("temp", tcs, this_1.scene, true);
        var tcx = tempTexture.getContext();
        var offset = this_1._getFrameOffset(i);
        var updateDt = function() {
          doneCount++;
          tempTexture.update(false);
          var iDat = tcx.getImageData(0, 0, tcs, tcs);
          var dt2 = _this.sets[setName2];
          var dtx2 = dt2.getContext();
          dtx2.putImageData(iDat, dtSize.x * offset.x, dtSize.y * offset.y);
          tempTexture.dispose();
          dt2.update(false);
          if (doneCount == expecting) {
            done();
            resolve();
            return;
          }
        };
        var setName2 = sKeys[j2] || "_blank";
        if (!mat || mat[setName2] === null) {
          tcx.fillStyle = "rgba(0,0,0,0)";
          if (this_1.options.fillBlanks) {
            tcx.fillStyle = this_1.options.customFillColor;
          }
          tcx.fillRect(0, 0, tcs, tcs);
          updateDt();
        } else {
          var setTexture = mat[setName2];
          var img_1 = new Image();
          if (setTexture instanceof DynamicTexture) {
            img_1.src = setTexture.getContext().canvas.toDataURL("image/png");
          } else {
            img_1.src = setTexture.url;
          }
          Tools.SetCorsBehavior(img_1.src, img_1);
          img_1.onload = function() {
            tcx.fillStyle = "rgba(0,0,0,0)";
            tcx.fillRect(0, 0, tcs, tcs);
            tempTexture.update(false);
            tcx.setTransform(1, 0, 0, -1, 0, 0);
            var cellOffsets = [0, 0, 1, 0, 1, 1, 0, 1, -1, 1, -1, 0, -1 - 1, 0, -1, 1, -1];
            switch (_this.options.paddingMode) {
              case 0:
                for (var i_1 = 0; i_1 < 9; i_1++) {
                  tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding + baseSize * cellOffsets[i_1], padding + baseSize * cellOffsets[i_1 + 1] - tcs, baseSize, baseSize);
                }
                break;
              case 1:
                for (var i_2 = 0; i_2 < padding; i_2++) {
                  tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, i_2 + baseSize * cellOffsets[0], padding - tcs, baseSize, baseSize);
                  tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding * 2 - i_2, padding - tcs, baseSize, baseSize);
                  tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding, i_2 - tcs, baseSize, baseSize);
                  tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding, padding * 2 - i_2 - tcs, baseSize, baseSize);
                }
                tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding + baseSize * cellOffsets[0], padding + baseSize * cellOffsets[1] - tcs, baseSize, baseSize);
                break;
              case 2:
                tcx.fillStyle = (_this.options.paddingColor || Color3.Black()).toHexString();
                tcx.fillRect(0, 0, tcs, -tcs);
                tcx.clearRect(padding, padding, baseSize, baseSize);
                tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding + baseSize * cellOffsets[0], padding + baseSize * cellOffsets[1] - tcs, baseSize, baseSize);
                break;
            }
            tcx.setTransform(1, 0, 0, 1, 0, 0);
            updateDt();
          };
        }
      };
      var this_1 = this;
      for (var j = 0; j < sKeys.length; j++) {
        _loop_1(j);
      }
    }
  };
  TexturePacker2.prototype._calculateSize = function() {
    var meshLength = this.meshes.length || 0;
    var baseSize = this.options.frameSize || 0;
    var padding = this._paddingValue || 0;
    switch (this.options.layout) {
      case 0:
        return new Vector2(baseSize * meshLength + 2 * padding * meshLength, baseSize + 2 * padding);
        break;
      case 1:
        var sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));
        var size = baseSize * sqrtCount + 2 * padding * sqrtCount;
        return new Vector2(size, size);
        break;
      case 2:
        var cols = this.options.colnum || 1;
        var rowCnt = Math.max(1, Math.ceil(meshLength / cols));
        return new Vector2(baseSize * cols + 2 * padding * cols, baseSize * rowCnt + 2 * padding * rowCnt);
        break;
    }
    return Vector2.Zero();
  };
  TexturePacker2.prototype._calculateMeshUVFrames = function(baseSize, padding, dtSize, dtUnits, update) {
    var meshLength = this.meshes.length;
    for (var i = 0; i < meshLength; i++) {
      var m = this.meshes[i];
      var scale = new Vector2(baseSize / dtSize.x, baseSize / dtSize.y);
      var pOffset = dtUnits.clone().scale(padding);
      var frameOffset = this._getFrameOffset(i);
      var offset = frameOffset.add(pOffset);
      var frame = new TexturePackerFrame(i, scale, offset);
      this.frames.push(frame);
      if (update) {
        this._updateMeshUV(m, i);
        this._updateTextureReferences(m);
      }
    }
  };
  TexturePacker2.prototype._getFrameOffset = function(index) {
    var meshLength = this.meshes.length;
    var uvStep, yStep, xStep;
    switch (this.options.layout) {
      case 0:
        uvStep = 1 / meshLength;
        return new Vector2(index * uvStep, 0);
        break;
      case 1:
        var sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));
        yStep = Math.floor(index / sqrtCount);
        xStep = index - yStep * sqrtCount;
        uvStep = 1 / sqrtCount;
        return new Vector2(xStep * uvStep, yStep * uvStep);
        break;
      case 2:
        var cols = this.options.colnum || 1;
        var rowCnt = Math.max(1, Math.ceil(meshLength / cols));
        xStep = Math.floor(index / rowCnt);
        yStep = index - xStep * rowCnt;
        uvStep = new Vector2(1 / cols, 1 / rowCnt);
        return new Vector2(xStep * uvStep.x, yStep * uvStep.y);
        break;
    }
    return Vector2.Zero();
  };
  TexturePacker2.prototype._updateMeshUV = function(mesh, frameID) {
    var frame = this.frames[frameID];
    var uvIn = mesh.getVerticesData(this.options.uvsIn || VertexBuffer.UVKind);
    var uvOut = [];
    var toCount = 0;
    if (uvIn.length) {
      toCount = uvIn.length || 0;
    }
    for (var i = 0; i < toCount; i += 2) {
      uvOut.push(uvIn[i] * frame.scale.x + frame.offset.x, uvIn[i + 1] * frame.scale.y + frame.offset.y);
    }
    mesh.setVerticesData(this.options.uvsOut || VertexBuffer.UVKind, uvOut);
  };
  TexturePacker2.prototype._updateTextureReferences = function(m, force) {
    if (force === void 0) {
      force = false;
    }
    var mat = m.material;
    var sKeys = Object.keys(this.sets);
    var _dispose = function(_t) {
      if (_t.dispose) {
        _t.dispose();
      }
    };
    for (var i = 0; i < sKeys.length; i++) {
      var setName = sKeys[i];
      if (!force) {
        if (!mat) {
          return;
        }
        if (mat[setName] !== null) {
          _dispose(mat[setName]);
          mat[setName] = this.sets[setName];
        }
      } else {
        if (mat[setName] !== null) {
          _dispose(mat[setName]);
        }
        mat[setName] = this.sets[setName];
      }
    }
  };
  TexturePacker2.prototype.setMeshToFrame = function(m, frameID, updateMaterial) {
    if (updateMaterial === void 0) {
      updateMaterial = false;
    }
    this._updateMeshUV(m, frameID);
    if (updateMaterial) {
      this._updateTextureReferences(m, true);
    }
  };
  TexturePacker2.prototype.processAsync = function() {
    var _this = this;
    return new Promise(function(resolve, reject) {
      try {
        if (_this.meshes.length === 0) {
          resolve();
          return;
        }
        var done_1 = 0;
        var doneCheck_1 = function(mat) {
          done_1++;
          if (_this.options.map) {
            for (var j = 0; j < _this.options.map.length; j++) {
              var index = _this.options.map[j];
              var t = mat[index];
              if (t !== null) {
                if (!_this.sets[_this.options.map[j]]) {
                  _this.sets[_this.options.map[j]] = true;
                }
                _this._expecting++;
              }
            }
            if (done_1 === _this.meshes.length) {
              _this._createFrames(resolve);
            }
          }
        };
        var _loop_2 = function(i2) {
          var mesh = _this.meshes[i2];
          var material = mesh.material;
          if (!material) {
            done_1++;
            if (done_1 === _this.meshes.length) {
              return { value: _this._createFrames(resolve) };
            }
            return "continue";
          }
          material.forceCompilationAsync(mesh).then(function() {
            doneCheck_1(material);
          });
        };
        for (var i = 0; i < _this.meshes.length; i++) {
          var state_1 = _loop_2(i);
          if (typeof state_1 === "object")
            return state_1.value;
        }
      } catch (e) {
        return reject(e);
      }
    });
  };
  TexturePacker2.prototype.dispose = function() {
    var sKeys = Object.keys(this.sets);
    for (var i = 0; i < sKeys.length; i++) {
      var channel = sKeys[i];
      this.sets[channel].dispose();
    }
  };
  TexturePacker2.prototype.download = function(imageType, quality) {
    var _this = this;
    if (imageType === void 0) {
      imageType = "png";
    }
    if (quality === void 0) {
      quality = 1;
    }
    setTimeout(function() {
      var pack = {
        name: _this.name,
        sets: {},
        options: {},
        frames: []
      };
      var sKeys = Object.keys(_this.sets);
      var oKeys = Object.keys(_this.options);
      try {
        for (var i = 0; i < sKeys.length; i++) {
          var channel = sKeys[i];
          var dt = _this.sets[channel];
          pack.sets[channel] = dt.getContext().canvas.toDataURL("image/" + imageType, quality);
        }
        for (var i = 0; i < oKeys.length; i++) {
          var opt = oKeys[i];
          pack.options[opt] = _this.options[opt];
        }
        for (var i = 0; i < _this.frames.length; i++) {
          var _f = _this.frames[i];
          pack.frames.push(_f.scale.x, _f.scale.y, _f.offset.x, _f.offset.y);
        }
      } catch (err) {
        Logger.Warn("Unable to download: " + err);
        return;
      }
      var data = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(pack, null, 4));
      var _a = document.createElement("a");
      _a.setAttribute("href", data);
      _a.setAttribute("download", _this.name + "_texurePackage.json");
      document.body.appendChild(_a);
      _a.click();
      _a.remove();
    }, 0);
  };
  TexturePacker2.prototype.updateFromJSON = function(data) {
    try {
      var parsedData = JSON.parse(data);
      this.name = parsedData.name;
      var _options = Object.keys(parsedData.options);
      for (var i = 0; i < _options.length; i++) {
        this.options[_options[i]] = parsedData.options[_options[i]];
      }
      for (var i = 0; i < parsedData.frames.length; i += 4) {
        var frame = new TexturePackerFrame(i / 4, new Vector2(parsedData.frames[i], parsedData.frames[i + 1]), new Vector2(parsedData.frames[i + 2], parsedData.frames[i + 3]));
        this.frames.push(frame);
      }
      var channels = Object.keys(parsedData.sets);
      for (var i = 0; i < channels.length; i++) {
        var _t = new Texture(parsedData.sets[channels[i]], this.scene, false, false);
        this.sets[channels[i]] = _t;
      }
    } catch (err) {
      Logger.Warn("Unable to update from JSON: " + err);
    }
  };
  TexturePacker2.LAYOUT_STRIP = 0;
  TexturePacker2.LAYOUT_POWER2 = 1;
  TexturePacker2.LAYOUT_COLNUM = 2;
  TexturePacker2.SUBUV_WRAP = 0;
  TexturePacker2.SUBUV_EXTEND = 1;
  TexturePacker2.SUBUV_COLOR = 2;
  return TexturePacker2;
}();

// node_modules/@babylonjs/core/Materials/Textures/Procedurals/proceduralTextureSceneComponent.js
var ProceduralTextureSceneComponent = function() {
  function ProceduralTextureSceneComponent2(scene) {
    this.name = SceneComponentConstants.NAME_PROCEDURALTEXTURE;
    this.scene = scene;
    this.scene.proceduralTextures = new Array();
  }
  ProceduralTextureSceneComponent2.prototype.register = function() {
    this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEAR_PROCEDURALTEXTURE, this, this._beforeClear);
  };
  ProceduralTextureSceneComponent2.prototype.rebuild = function() {
  };
  ProceduralTextureSceneComponent2.prototype.dispose = function() {
  };
  ProceduralTextureSceneComponent2.prototype._beforeClear = function() {
    if (this.scene.proceduralTexturesEnabled) {
      Tools.StartPerformanceCounter("Procedural textures", this.scene.proceduralTextures.length > 0);
      for (var proceduralIndex = 0; proceduralIndex < this.scene.proceduralTextures.length; proceduralIndex++) {
        var proceduralTexture = this.scene.proceduralTextures[proceduralIndex];
        if (proceduralTexture._shouldRender()) {
          proceduralTexture.render();
        }
      }
      Tools.EndPerformanceCounter("Procedural textures", this.scene.proceduralTextures.length > 0);
    }
  };
  return ProceduralTextureSceneComponent2;
}();

// node_modules/@babylonjs/core/Shaders/procedural.vertex.js
var name43 = "proceduralVertexShader";
var shader43 = "\nattribute vec2 position;\n\nvarying vec2 vPosition;\nvarying vec2 vUV;\nconst vec2 madd=vec2(0.5,0.5);\nvoid main(void) {\nvPosition=position;\nvUV=position*madd+madd;\ngl_Position=vec4(position,0.0,1.0);\n}";
Effect.ShadersStore[name43] = shader43;

// node_modules/@babylonjs/core/Materials/Textures/Procedurals/proceduralTexture.js
var ProceduralTexture = function(_super) {
  __extends(ProceduralTexture2, _super);
  function ProceduralTexture2(name98, size, fragment, scene, fallbackTexture, generateMipMaps, isCube, textureType) {
    if (fallbackTexture === void 0) {
      fallbackTexture = null;
    }
    if (generateMipMaps === void 0) {
      generateMipMaps = true;
    }
    if (isCube === void 0) {
      isCube = false;
    }
    if (textureType === void 0) {
      textureType = 0;
    }
    var _this = _super.call(this, null, scene, !generateMipMaps) || this;
    _this.isEnabled = true;
    _this.autoClear = true;
    _this.onGeneratedObservable = new Observable();
    _this.onBeforeGenerationObservable = new Observable();
    _this.nodeMaterialSource = null;
    _this._textures = {};
    _this._currentRefreshId = -1;
    _this._frameId = -1;
    _this._refreshRate = 1;
    _this._vertexBuffers = {};
    _this._uniforms = new Array();
    _this._samplers = new Array();
    _this._floats = {};
    _this._ints = {};
    _this._floatsArrays = {};
    _this._colors3 = {};
    _this._colors4 = {};
    _this._vectors2 = {};
    _this._vectors3 = {};
    _this._matrices = {};
    _this._fallbackTextureUsed = false;
    _this._cachedDefines = "";
    _this._contentUpdateId = -1;
    scene = _this.getScene() || EngineStore.LastCreatedScene;
    var component = scene._getComponent(SceneComponentConstants.NAME_PROCEDURALTEXTURE);
    if (!component) {
      component = new ProceduralTextureSceneComponent(scene);
      scene._addComponent(component);
    }
    scene.proceduralTextures.push(_this);
    _this._fullEngine = scene.getEngine();
    _this.name = name98;
    _this.isRenderTarget = true;
    _this._size = size;
    _this._generateMipMaps = generateMipMaps;
    _this.setFragment(fragment);
    _this._fallbackTexture = fallbackTexture;
    if (isCube) {
      _this._texture = _this._fullEngine.createRenderTargetCubeTexture(size, { generateMipMaps, generateDepthBuffer: false, generateStencilBuffer: false, type: textureType });
      _this.setFloat("face", 0);
    } else {
      _this._texture = _this._fullEngine.createRenderTargetTexture(size, { generateMipMaps, generateDepthBuffer: false, generateStencilBuffer: false, type: textureType });
    }
    var vertices = [];
    vertices.push(1, 1);
    vertices.push(-1, 1);
    vertices.push(-1, -1);
    vertices.push(1, -1);
    _this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(_this._fullEngine, vertices, VertexBuffer.PositionKind, false, false, 2);
    _this._createIndexBuffer();
    return _this;
  }
  ProceduralTexture2.prototype.getEffect = function() {
    return this._effect;
  };
  ProceduralTexture2.prototype.getContent = function() {
    if (this._contentData && this._frameId === this._contentUpdateId) {
      return this._contentData;
    }
    this._contentData = this.readPixels(0, 0, this._contentData);
    this._contentUpdateId = this._frameId;
    return this._contentData;
  };
  ProceduralTexture2.prototype._createIndexBuffer = function() {
    var engine = this._fullEngine;
    var indices = [];
    indices.push(0);
    indices.push(1);
    indices.push(2);
    indices.push(0);
    indices.push(2);
    indices.push(3);
    this._indexBuffer = engine.createIndexBuffer(indices);
  };
  ProceduralTexture2.prototype._rebuild = function() {
    var vb = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vb) {
      vb._rebuild();
    }
    this._createIndexBuffer();
    if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {
      this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;
    }
  };
  ProceduralTexture2.prototype.reset = function() {
    if (this._effect === void 0) {
      return;
    }
    this._effect.dispose();
  };
  ProceduralTexture2.prototype._getDefines = function() {
    return "";
  };
  ProceduralTexture2.prototype.isReady = function() {
    var _this = this;
    var engine = this._fullEngine;
    var shaders;
    if (this.nodeMaterialSource) {
      return this._effect.isReady();
    }
    if (!this._fragment) {
      return false;
    }
    if (this._fallbackTextureUsed) {
      return true;
    }
    var defines = this._getDefines();
    if (this._effect && defines === this._cachedDefines && this._effect.isReady()) {
      return true;
    }
    if (this._fragment.fragmentElement !== void 0) {
      shaders = { vertex: "procedural", fragmentElement: this._fragment.fragmentElement };
    } else {
      shaders = { vertex: "procedural", fragment: this._fragment };
    }
    this._cachedDefines = defines;
    this._effect = engine.createEffect(shaders, [VertexBuffer.PositionKind], this._uniforms, this._samplers, defines, void 0, void 0, function() {
      _this.releaseInternalTexture();
      if (_this._fallbackTexture) {
        _this._texture = _this._fallbackTexture._texture;
        if (_this._texture) {
          _this._texture.incrementReferences();
        }
      }
      _this._fallbackTextureUsed = true;
    });
    return this._effect.isReady();
  };
  ProceduralTexture2.prototype.resetRefreshCounter = function() {
    this._currentRefreshId = -1;
  };
  ProceduralTexture2.prototype.setFragment = function(fragment) {
    this._fragment = fragment;
  };
  Object.defineProperty(ProceduralTexture2.prototype, "refreshRate", {
    get: function() {
      return this._refreshRate;
    },
    set: function(value) {
      this._refreshRate = value;
      this.resetRefreshCounter();
    },
    enumerable: false,
    configurable: true
  });
  ProceduralTexture2.prototype._shouldRender = function() {
    if (!this.isEnabled || !this.isReady() || !this._texture) {
      if (this._texture) {
        this._texture.isReady = false;
      }
      return false;
    }
    if (this._fallbackTextureUsed) {
      return false;
    }
    if (this._currentRefreshId === -1) {
      this._currentRefreshId = 1;
      this._frameId++;
      return true;
    }
    if (this.refreshRate === this._currentRefreshId) {
      this._currentRefreshId = 1;
      this._frameId++;
      return true;
    }
    this._currentRefreshId++;
    return false;
  };
  ProceduralTexture2.prototype.getRenderSize = function() {
    return this._size;
  };
  ProceduralTexture2.prototype.resize = function(size, generateMipMaps) {
    if (this._fallbackTextureUsed) {
      return;
    }
    this.releaseInternalTexture();
    this._texture = this._fullEngine.createRenderTargetTexture(size, generateMipMaps);
    this._size = size;
    this._generateMipMaps = generateMipMaps;
  };
  ProceduralTexture2.prototype._checkUniform = function(uniformName) {
    if (this._uniforms.indexOf(uniformName) === -1) {
      this._uniforms.push(uniformName);
    }
  };
  ProceduralTexture2.prototype.setTexture = function(name98, texture) {
    if (this._samplers.indexOf(name98) === -1) {
      this._samplers.push(name98);
    }
    this._textures[name98] = texture;
    return this;
  };
  ProceduralTexture2.prototype.setFloat = function(name98, value) {
    this._checkUniform(name98);
    this._floats[name98] = value;
    return this;
  };
  ProceduralTexture2.prototype.setInt = function(name98, value) {
    this._checkUniform(name98);
    this._ints[name98] = value;
    return this;
  };
  ProceduralTexture2.prototype.setFloats = function(name98, value) {
    this._checkUniform(name98);
    this._floatsArrays[name98] = value;
    return this;
  };
  ProceduralTexture2.prototype.setColor3 = function(name98, value) {
    this._checkUniform(name98);
    this._colors3[name98] = value;
    return this;
  };
  ProceduralTexture2.prototype.setColor4 = function(name98, value) {
    this._checkUniform(name98);
    this._colors4[name98] = value;
    return this;
  };
  ProceduralTexture2.prototype.setVector2 = function(name98, value) {
    this._checkUniform(name98);
    this._vectors2[name98] = value;
    return this;
  };
  ProceduralTexture2.prototype.setVector3 = function(name98, value) {
    this._checkUniform(name98);
    this._vectors3[name98] = value;
    return this;
  };
  ProceduralTexture2.prototype.setMatrix = function(name98, value) {
    this._checkUniform(name98);
    this._matrices[name98] = value;
    return this;
  };
  ProceduralTexture2.prototype.render = function(useCameraPostProcess) {
    var scene = this.getScene();
    if (!scene) {
      return;
    }
    var engine = this._fullEngine;
    engine.enableEffect(this._effect);
    this.onBeforeGenerationObservable.notifyObservers(this);
    engine.setState(false);
    if (!this.nodeMaterialSource) {
      for (var name98 in this._textures) {
        this._effect.setTexture(name98, this._textures[name98]);
      }
      for (name98 in this._ints) {
        this._effect.setInt(name98, this._ints[name98]);
      }
      for (name98 in this._floats) {
        this._effect.setFloat(name98, this._floats[name98]);
      }
      for (name98 in this._floatsArrays) {
        this._effect.setArray(name98, this._floatsArrays[name98]);
      }
      for (name98 in this._colors3) {
        this._effect.setColor3(name98, this._colors3[name98]);
      }
      for (name98 in this._colors4) {
        var color = this._colors4[name98];
        this._effect.setFloat4(name98, color.r, color.g, color.b, color.a);
      }
      for (name98 in this._vectors2) {
        this._effect.setVector2(name98, this._vectors2[name98]);
      }
      for (name98 in this._vectors3) {
        this._effect.setVector3(name98, this._vectors3[name98]);
      }
      for (name98 in this._matrices) {
        this._effect.setMatrix(name98, this._matrices[name98]);
      }
    }
    if (!this._texture) {
      return;
    }
    if (this.isCube) {
      for (var face = 0; face < 6; face++) {
        engine.bindFramebuffer(this._texture, face, void 0, void 0, true);
        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._effect);
        this._effect.setFloat("face", face);
        if (this.autoClear) {
          engine.clear(scene.clearColor, true, false, false);
        }
        engine.drawElementsType(Material.TriangleFillMode, 0, 6);
        if (face === 5) {
          engine.generateMipMapsForCubemap(this._texture);
        }
      }
    } else {
      engine.bindFramebuffer(this._texture, 0, void 0, void 0, true);
      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._effect);
      if (this.autoClear) {
        engine.clear(scene.clearColor, true, false, false);
      }
      engine.drawElementsType(Material.TriangleFillMode, 0, 6);
    }
    engine.unBindFramebuffer(this._texture, this.isCube);
    if (this.onGenerated) {
      this.onGenerated();
    }
    this.onGeneratedObservable.notifyObservers(this);
  };
  ProceduralTexture2.prototype.clone = function() {
    var textureSize = this.getSize();
    var newTexture = new ProceduralTexture2(this.name, textureSize.width, this._fragment, this.getScene(), this._fallbackTexture, this._generateMipMaps);
    newTexture.hasAlpha = this.hasAlpha;
    newTexture.level = this.level;
    newTexture.coordinatesMode = this.coordinatesMode;
    return newTexture;
  };
  ProceduralTexture2.prototype.dispose = function() {
    var scene = this.getScene();
    if (!scene) {
      return;
    }
    var index = scene.proceduralTextures.indexOf(this);
    if (index >= 0) {
      scene.proceduralTextures.splice(index, 1);
    }
    var vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vertexBuffer) {
      vertexBuffer.dispose();
      this._vertexBuffers[VertexBuffer.PositionKind] = null;
    }
    if (this._indexBuffer && this._fullEngine._releaseBuffer(this._indexBuffer)) {
      this._indexBuffer = null;
    }
    this.onGeneratedObservable.clear();
    this.onBeforeGenerationObservable.clear();
    _super.prototype.dispose.call(this);
  };
  __decorate([
    serialize()
  ], ProceduralTexture2.prototype, "isEnabled", void 0);
  __decorate([
    serialize()
  ], ProceduralTexture2.prototype, "autoClear", void 0);
  __decorate([
    serialize()
  ], ProceduralTexture2.prototype, "_generateMipMaps", void 0);
  __decorate([
    serialize()
  ], ProceduralTexture2.prototype, "_size", void 0);
  __decorate([
    serialize()
  ], ProceduralTexture2.prototype, "refreshRate", null);
  return ProceduralTexture2;
}(Texture);
_TypeStore.RegisteredTypes["BABYLON.ProceduralTexture"] = ProceduralTexture;

// node_modules/@babylonjs/core/Materials/Textures/Procedurals/customProceduralTexture.js
var CustomProceduralTexture = function(_super) {
  __extends(CustomProceduralTexture2, _super);
  function CustomProceduralTexture2(name98, texturePath, size, scene, fallbackTexture, generateMipMaps) {
    var _this = _super.call(this, name98, size, null, scene, fallbackTexture, generateMipMaps) || this;
    _this._animate = true;
    _this._time = 0;
    _this._texturePath = texturePath;
    _this._loadJson(texturePath);
    _this.refreshRate = 1;
    return _this;
  }
  CustomProceduralTexture2.prototype._loadJson = function(jsonUrl) {
    var _this = this;
    var noConfigFile = function() {
      try {
        _this.setFragment(_this._texturePath);
      } catch (ex) {
        Logger.Error("No json or ShaderStore or DOM element found for CustomProceduralTexture");
      }
    };
    var configFileUrl = jsonUrl + "/config.json";
    var xhr = new WebRequest();
    xhr.open("GET", configFileUrl);
    xhr.addEventListener("load", function() {
      if (xhr.status === 200 || xhr.responseText && xhr.responseText.length > 0) {
        try {
          _this._config = JSON.parse(xhr.response);
          _this.updateShaderUniforms();
          _this.updateTextures();
          _this.setFragment(_this._texturePath + "/custom");
          _this._animate = _this._config.animate;
          _this.refreshRate = _this._config.refreshrate;
        } catch (ex) {
          noConfigFile();
        }
      } else {
        noConfigFile();
      }
    }, false);
    xhr.addEventListener("error", function() {
      noConfigFile();
    }, false);
    try {
      xhr.send();
    } catch (ex) {
      Logger.Error("CustomProceduralTexture: Error on XHR send request.");
    }
  };
  CustomProceduralTexture2.prototype.isReady = function() {
    if (!_super.prototype.isReady.call(this)) {
      return false;
    }
    for (var name98 in this._textures) {
      var texture = this._textures[name98];
      if (!texture.isReady()) {
        return false;
      }
    }
    return true;
  };
  CustomProceduralTexture2.prototype.render = function(useCameraPostProcess) {
    var scene = this.getScene();
    if (this._animate && scene) {
      this._time += scene.getAnimationRatio() * 0.03;
      this.updateShaderUniforms();
    }
    _super.prototype.render.call(this, useCameraPostProcess);
  };
  CustomProceduralTexture2.prototype.updateTextures = function() {
    for (var i = 0; i < this._config.sampler2Ds.length; i++) {
      this.setTexture(this._config.sampler2Ds[i].sample2Dname, new Texture(this._texturePath + "/" + this._config.sampler2Ds[i].textureRelativeUrl, this.getScene()));
    }
  };
  CustomProceduralTexture2.prototype.updateShaderUniforms = function() {
    if (this._config) {
      for (var j = 0; j < this._config.uniforms.length; j++) {
        var uniform = this._config.uniforms[j];
        switch (uniform.type) {
          case "float":
            this.setFloat(uniform.name, uniform.value);
            break;
          case "color3":
            this.setColor3(uniform.name, new Color3(uniform.r, uniform.g, uniform.b));
            break;
          case "color4":
            this.setColor4(uniform.name, new Color4(uniform.r, uniform.g, uniform.b, uniform.a));
            break;
          case "vector2":
            this.setVector2(uniform.name, new Vector2(uniform.x, uniform.y));
            break;
          case "vector3":
            this.setVector3(uniform.name, new Vector3(uniform.x, uniform.y, uniform.z));
            break;
        }
      }
    }
    this.setFloat("time", this._time);
  };
  Object.defineProperty(CustomProceduralTexture2.prototype, "animate", {
    get: function() {
      return this._animate;
    },
    set: function(value) {
      this._animate = value;
    },
    enumerable: false,
    configurable: true
  });
  return CustomProceduralTexture2;
}(ProceduralTexture);

// node_modules/@babylonjs/core/Shaders/noise.fragment.js
var name44 = "noisePixelShader";
var shader44 = "\n\nuniform float brightness;\nuniform float persistence;\nuniform float timeScale;\n\nvarying vec2 vUV;\n\nvec2 hash22(vec2 p)\n{\np=p*mat2(127.1,311.7,269.5,183.3);\np=-1.0+2.0*fract(sin(p)*43758.5453123);\nreturn sin(p*6.283+timeScale);\n}\nfloat interpolationNoise(vec2 p)\n{\nvec2 pi=floor(p);\nvec2 pf=p-pi;\nvec2 w=pf*pf*(3.-2.*pf);\nfloat f00=dot(hash22(pi+vec2(.0,.0)),pf-vec2(.0,.0));\nfloat f01=dot(hash22(pi+vec2(.0,1.)),pf-vec2(.0,1.));\nfloat f10=dot(hash22(pi+vec2(1.0,0.)),pf-vec2(1.0,0.));\nfloat f11=dot(hash22(pi+vec2(1.0,1.)),pf-vec2(1.0,1.));\nfloat xm1=mix(f00,f10,w.x);\nfloat xm2=mix(f01,f11,w.x);\nfloat ym=mix(xm1,xm2,w.y);\nreturn ym;\n}\nfloat perlinNoise2D(float x,float y)\n{\nfloat sum=0.0;\nfloat frequency=0.0;\nfloat amplitude=0.0;\nfor(int i=0; i<OCTAVES; i++)\n{\nfrequency=pow(2.0,float(i));\namplitude=pow(persistence,float(i));\nsum=sum+interpolationNoise(vec2(x*frequency,y*frequency))*amplitude;\n}\nreturn sum;\n}\n\nvoid main(void)\n{\nfloat x=abs(vUV.x);\nfloat y=abs(vUV.y);\nfloat noise=brightness+(1.0-brightness)*perlinNoise2D(x,y);\ngl_FragColor=vec4(noise,noise,noise,1.0);\n}\n";
Effect.ShadersStore[name44] = shader44;

// node_modules/@babylonjs/core/Materials/Textures/Procedurals/noiseProceduralTexture.js
var NoiseProceduralTexture = function(_super) {
  __extends(NoiseProceduralTexture2, _super);
  function NoiseProceduralTexture2(name98, size, scene, fallbackTexture, generateMipMaps) {
    if (size === void 0) {
      size = 256;
    }
    if (scene === void 0) {
      scene = EngineStore.LastCreatedScene;
    }
    var _this = _super.call(this, name98, size, "noise", scene, fallbackTexture, generateMipMaps) || this;
    _this.time = 0;
    _this.brightness = 0.2;
    _this.octaves = 3;
    _this.persistence = 0.8;
    _this.animationSpeedFactor = 1;
    _this.autoClear = false;
    _this._updateShaderUniforms();
    return _this;
  }
  NoiseProceduralTexture2.prototype._updateShaderUniforms = function() {
    var scene = this.getScene();
    if (!scene) {
      return;
    }
    this.time += scene.getAnimationRatio() * this.animationSpeedFactor * 0.01;
    this.setFloat("brightness", this.brightness);
    this.setFloat("persistence", this.persistence);
    this.setFloat("timeScale", this.time);
  };
  NoiseProceduralTexture2.prototype._getDefines = function() {
    return "#define OCTAVES " + (this.octaves | 0);
  };
  NoiseProceduralTexture2.prototype.render = function(useCameraPostProcess) {
    this._updateShaderUniforms();
    _super.prototype.render.call(this, useCameraPostProcess);
  };
  NoiseProceduralTexture2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.customType = "BABYLON.NoiseProceduralTexture";
    serializationObject.brightness = this.brightness;
    serializationObject.octaves = this.octaves;
    serializationObject.persistence = this.persistence;
    serializationObject.animationSpeedFactor = this.animationSpeedFactor;
    serializationObject.size = this.getSize().width;
    serializationObject.generateMipMaps = this._generateMipMaps;
    serializationObject.time = this.time;
    return serializationObject;
  };
  NoiseProceduralTexture2.prototype.clone = function() {
    var textureSize = this.getSize();
    var newTexture = new NoiseProceduralTexture2(this.name, textureSize.width, this.getScene(), this._fallbackTexture ? this._fallbackTexture : void 0, this._generateMipMaps);
    newTexture.hasAlpha = this.hasAlpha;
    newTexture.level = this.level;
    newTexture.coordinatesMode = this.coordinatesMode;
    newTexture.brightness = this.brightness;
    newTexture.octaves = this.octaves;
    newTexture.persistence = this.persistence;
    newTexture.animationSpeedFactor = this.animationSpeedFactor;
    newTexture.time = this.time;
    return newTexture;
  };
  NoiseProceduralTexture2.Parse = function(parsedTexture, scene) {
    var _a;
    var texture = new NoiseProceduralTexture2(parsedTexture.name, parsedTexture.size, scene, void 0, parsedTexture.generateMipMaps);
    texture.brightness = parsedTexture.brightness;
    texture.octaves = parsedTexture.octaves;
    texture.persistence = parsedTexture.persistence;
    texture.animationSpeedFactor = parsedTexture.animationSpeedFactor;
    texture.time = (_a = parsedTexture.time) !== null && _a !== void 0 ? _a : 0;
    return texture;
  };
  return NoiseProceduralTexture2;
}(ProceduralTexture);
_TypeStore.RegisteredTypes["BABYLON.NoiseProceduralTexture"] = NoiseProceduralTexture;

// node_modules/@babylonjs/core/Materials/Textures/rawTexture2DArray.js
var RawTexture2DArray = function(_super) {
  __extends(RawTexture2DArray2, _super);
  function RawTexture2DArray2(data, width, height, depth, format, scene, generateMipMaps, invertY, samplingMode, textureType) {
    if (generateMipMaps === void 0) {
      generateMipMaps = true;
    }
    if (invertY === void 0) {
      invertY = false;
    }
    if (samplingMode === void 0) {
      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;
    }
    if (textureType === void 0) {
      textureType = 0;
    }
    var _this = _super.call(this, null, scene, !generateMipMaps, invertY) || this;
    _this.format = format;
    _this._texture = scene.getEngine().createRawTexture2DArray(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, null, textureType);
    _this.is2DArray = true;
    return _this;
  }
  RawTexture2DArray2.prototype.update = function(data) {
    if (!this._texture) {
      return;
    }
    this._getEngine().updateRawTexture2DArray(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type);
  };
  return RawTexture2DArray2;
}(Texture);

// node_modules/@babylonjs/core/Materials/Textures/rawTexture3D.js
var RawTexture3D = function(_super) {
  __extends(RawTexture3D2, _super);
  function RawTexture3D2(data, width, height, depth, format, scene, generateMipMaps, invertY, samplingMode, textureType) {
    if (generateMipMaps === void 0) {
      generateMipMaps = true;
    }
    if (invertY === void 0) {
      invertY = false;
    }
    if (samplingMode === void 0) {
      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;
    }
    if (textureType === void 0) {
      textureType = 0;
    }
    var _this = _super.call(this, null, scene, !generateMipMaps, invertY) || this;
    _this.format = format;
    _this._texture = scene.getEngine().createRawTexture3D(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, null, textureType);
    _this.is3D = true;
    return _this;
  }
  RawTexture3D2.prototype.update = function(data) {
    if (!this._texture) {
      return;
    }
    this._getEngine().updateRawTexture3D(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type);
  };
  return RawTexture3D2;
}(Texture);

// node_modules/@babylonjs/core/Materials/Textures/refractionTexture.js
var RefractionTexture = function(_super) {
  __extends(RefractionTexture2, _super);
  function RefractionTexture2(name98, size, scene, generateMipMaps) {
    var _this = _super.call(this, name98, size, scene, generateMipMaps, true) || this;
    _this.refractionPlane = new Plane(0, 1, 0, 1);
    _this.depth = 2;
    _this.onBeforeRenderObservable.add(function() {
      scene.clipPlane = _this.refractionPlane;
    });
    _this.onAfterRenderObservable.add(function() {
      scene.clipPlane = null;
    });
    return _this;
  }
  RefractionTexture2.prototype.clone = function() {
    var scene = this.getScene();
    if (!scene) {
      return this;
    }
    var textureSize = this.getSize();
    var newTexture = new RefractionTexture2(this.name, textureSize.width, scene, this._generateMipMaps);
    newTexture.hasAlpha = this.hasAlpha;
    newTexture.level = this.level;
    newTexture.refractionPlane = this.refractionPlane.clone();
    if (this.renderList) {
      newTexture.renderList = this.renderList.slice(0);
    }
    newTexture.depth = this.depth;
    return newTexture;
  };
  RefractionTexture2.prototype.serialize = function() {
    if (!this.name) {
      return null;
    }
    var serializationObject = _super.prototype.serialize.call(this);
    serializationObject.mirrorPlane = this.refractionPlane.asArray();
    serializationObject.depth = this.depth;
    return serializationObject;
  };
  return RefractionTexture2;
}(RenderTargetTexture);

// node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialBlockTargets.js
var NodeMaterialBlockTargets;
(function(NodeMaterialBlockTargets2) {
  NodeMaterialBlockTargets2[NodeMaterialBlockTargets2["Vertex"] = 1] = "Vertex";
  NodeMaterialBlockTargets2[NodeMaterialBlockTargets2["Fragment"] = 2] = "Fragment";
  NodeMaterialBlockTargets2[NodeMaterialBlockTargets2["Neutral"] = 4] = "Neutral";
  NodeMaterialBlockTargets2[NodeMaterialBlockTargets2["VertexAndFragment"] = 3] = "VertexAndFragment";
})(NodeMaterialBlockTargets || (NodeMaterialBlockTargets = {}));

// node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialBlockConnectionPointTypes.js
var NodeMaterialBlockConnectionPointTypes;
(function(NodeMaterialBlockConnectionPointTypes2) {
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Float"] = 1] = "Float";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Int"] = 2] = "Int";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Vector2"] = 4] = "Vector2";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Vector3"] = 8] = "Vector3";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Vector4"] = 16] = "Vector4";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Color3"] = 32] = "Color3";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Color4"] = 64] = "Color4";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Matrix"] = 128] = "Matrix";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Object"] = 256] = "Object";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["AutoDetect"] = 1024] = "AutoDetect";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["BasedOnInput"] = 2048] = "BasedOnInput";
})(NodeMaterialBlockConnectionPointTypes || (NodeMaterialBlockConnectionPointTypes = {}));

// node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialBlockConnectionPointMode.js
var NodeMaterialBlockConnectionPointMode;
(function(NodeMaterialBlockConnectionPointMode2) {
  NodeMaterialBlockConnectionPointMode2[NodeMaterialBlockConnectionPointMode2["Uniform"] = 0] = "Uniform";
  NodeMaterialBlockConnectionPointMode2[NodeMaterialBlockConnectionPointMode2["Attribute"] = 1] = "Attribute";
  NodeMaterialBlockConnectionPointMode2[NodeMaterialBlockConnectionPointMode2["Varying"] = 2] = "Varying";
  NodeMaterialBlockConnectionPointMode2[NodeMaterialBlockConnectionPointMode2["Undefined"] = 3] = "Undefined";
})(NodeMaterialBlockConnectionPointMode || (NodeMaterialBlockConnectionPointMode = {}));

// node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialSystemValues.js
var NodeMaterialSystemValues;
(function(NodeMaterialSystemValues2) {
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["World"] = 1] = "World";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["View"] = 2] = "View";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["Projection"] = 3] = "Projection";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["ViewProjection"] = 4] = "ViewProjection";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["WorldView"] = 5] = "WorldView";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["WorldViewProjection"] = 6] = "WorldViewProjection";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["CameraPosition"] = 7] = "CameraPosition";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["FogColor"] = 8] = "FogColor";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["DeltaTime"] = 9] = "DeltaTime";
})(NodeMaterialSystemValues || (NodeMaterialSystemValues = {}));

// node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialModes.js
var NodeMaterialModes;
(function(NodeMaterialModes2) {
  NodeMaterialModes2[NodeMaterialModes2["Material"] = 0] = "Material";
  NodeMaterialModes2[NodeMaterialModes2["PostProcess"] = 1] = "PostProcess";
  NodeMaterialModes2[NodeMaterialModes2["Particle"] = 2] = "Particle";
  NodeMaterialModes2[NodeMaterialModes2["ProceduralTexture"] = 3] = "ProceduralTexture";
})(NodeMaterialModes || (NodeMaterialModes = {}));

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialBlockConnectionPoint.js
var NodeMaterialConnectionPointCompatibilityStates;
(function(NodeMaterialConnectionPointCompatibilityStates2) {
  NodeMaterialConnectionPointCompatibilityStates2[NodeMaterialConnectionPointCompatibilityStates2["Compatible"] = 0] = "Compatible";
  NodeMaterialConnectionPointCompatibilityStates2[NodeMaterialConnectionPointCompatibilityStates2["TypeIncompatible"] = 1] = "TypeIncompatible";
  NodeMaterialConnectionPointCompatibilityStates2[NodeMaterialConnectionPointCompatibilityStates2["TargetIncompatible"] = 2] = "TargetIncompatible";
})(NodeMaterialConnectionPointCompatibilityStates || (NodeMaterialConnectionPointCompatibilityStates = {}));
var NodeMaterialConnectionPointDirection;
(function(NodeMaterialConnectionPointDirection2) {
  NodeMaterialConnectionPointDirection2[NodeMaterialConnectionPointDirection2["Input"] = 0] = "Input";
  NodeMaterialConnectionPointDirection2[NodeMaterialConnectionPointDirection2["Output"] = 1] = "Output";
})(NodeMaterialConnectionPointDirection || (NodeMaterialConnectionPointDirection = {}));
var NodeMaterialConnectionPoint = function() {
  function NodeMaterialConnectionPoint2(name98, ownerBlock, direction) {
    this._connectedPoint = null;
    this._endpoints = new Array();
    this._typeConnectionSource = null;
    this._linkedConnectionSource = null;
    this._acceptedConnectionPointType = null;
    this._type = NodeMaterialBlockConnectionPointTypes.Float;
    this._enforceAssociatedVariableName = false;
    this.needDualDirectionValidation = false;
    this.acceptedConnectionPointTypes = new Array();
    this.excludedConnectionPointTypes = new Array();
    this.onConnectionObservable = new Observable();
    this.isExposedOnFrame = false;
    this.exposedPortPosition = -1;
    this._prioritizeVertex = false;
    this._target = NodeMaterialBlockTargets.VertexAndFragment;
    this._ownerBlock = ownerBlock;
    this.name = name98;
    this._direction = direction;
  }
  NodeMaterialConnectionPoint2.AreEquivalentTypes = function(type1, type2) {
    switch (type1) {
      case NodeMaterialBlockConnectionPointTypes.Vector3: {
        if (type2 === NodeMaterialBlockConnectionPointTypes.Color3) {
          return true;
        }
        break;
      }
      case NodeMaterialBlockConnectionPointTypes.Vector4: {
        if (type2 === NodeMaterialBlockConnectionPointTypes.Color4) {
          return true;
        }
        break;
      }
      case NodeMaterialBlockConnectionPointTypes.Color3: {
        if (type2 === NodeMaterialBlockConnectionPointTypes.Vector3) {
          return true;
        }
        break;
      }
      case NodeMaterialBlockConnectionPointTypes.Color4: {
        if (type2 === NodeMaterialBlockConnectionPointTypes.Vector4) {
          return true;
        }
        break;
      }
    }
    return false;
  };
  Object.defineProperty(NodeMaterialConnectionPoint2.prototype, "direction", {
    get: function() {
      return this._direction;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeMaterialConnectionPoint2.prototype, "associatedVariableName", {
    get: function() {
      if (this._ownerBlock.isInput) {
        return this._ownerBlock.associatedVariableName;
      }
      if ((!this._enforceAssociatedVariableName || !this._associatedVariableName) && this._connectedPoint) {
        return this._connectedPoint.associatedVariableName;
      }
      return this._associatedVariableName;
    },
    set: function(value) {
      this._associatedVariableName = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeMaterialConnectionPoint2.prototype, "innerType", {
    get: function() {
      if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {
        return this.type;
      }
      return this._type;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeMaterialConnectionPoint2.prototype, "type", {
    get: function() {
      if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {
        if (this._ownerBlock.isInput) {
          return this._ownerBlock.type;
        }
        if (this._connectedPoint) {
          return this._connectedPoint.type;
        }
        if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {
          return this._linkedConnectionSource.type;
        }
      }
      if (this._type === NodeMaterialBlockConnectionPointTypes.BasedOnInput && this._typeConnectionSource) {
        return this._typeConnectionSource.type;
      }
      return this._type;
    },
    set: function(value) {
      this._type = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeMaterialConnectionPoint2.prototype, "target", {
    get: function() {
      if (!this._prioritizeVertex || !this._ownerBlock) {
        return this._target;
      }
      if (this._target !== NodeMaterialBlockTargets.VertexAndFragment) {
        return this._target;
      }
      if (this._ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
        return NodeMaterialBlockTargets.Fragment;
      }
      return NodeMaterialBlockTargets.Vertex;
    },
    set: function(value) {
      this._target = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeMaterialConnectionPoint2.prototype, "isConnected", {
    get: function() {
      return this.connectedPoint !== null || this.hasEndpoints;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeMaterialConnectionPoint2.prototype, "isConnectedToInputBlock", {
    get: function() {
      return this.connectedPoint !== null && this.connectedPoint.ownerBlock.isInput;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeMaterialConnectionPoint2.prototype, "connectInputBlock", {
    get: function() {
      if (!this.isConnectedToInputBlock) {
        return null;
      }
      return this.connectedPoint.ownerBlock;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeMaterialConnectionPoint2.prototype, "connectedPoint", {
    get: function() {
      return this._connectedPoint;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeMaterialConnectionPoint2.prototype, "ownerBlock", {
    get: function() {
      return this._ownerBlock;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeMaterialConnectionPoint2.prototype, "sourceBlock", {
    get: function() {
      if (!this._connectedPoint) {
        return null;
      }
      return this._connectedPoint.ownerBlock;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeMaterialConnectionPoint2.prototype, "connectedBlocks", {
    get: function() {
      if (this._endpoints.length === 0) {
        return [];
      }
      return this._endpoints.map(function(e) {
        return e.ownerBlock;
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeMaterialConnectionPoint2.prototype, "endpoints", {
    get: function() {
      return this._endpoints;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeMaterialConnectionPoint2.prototype, "hasEndpoints", {
    get: function() {
      return this._endpoints && this._endpoints.length > 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeMaterialConnectionPoint2.prototype, "isConnectedInVertexShader", {
    get: function() {
      if (this.target === NodeMaterialBlockTargets.Vertex) {
        return true;
      }
      if (!this.hasEndpoints) {
        return false;
      }
      for (var _i = 0, _a = this._endpoints; _i < _a.length; _i++) {
        var endpoint = _a[_i];
        if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {
          return true;
        }
        if (endpoint.target === NodeMaterialBlockTargets.Vertex) {
          return true;
        }
        if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {
          if (endpoint.ownerBlock.outputs.some(function(o) {
            return o.isConnectedInVertexShader;
          })) {
            return true;
          }
        }
      }
      return false;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeMaterialConnectionPoint2.prototype, "isConnectedInFragmentShader", {
    get: function() {
      if (this.target === NodeMaterialBlockTargets.Fragment) {
        return true;
      }
      if (!this.hasEndpoints) {
        return false;
      }
      for (var _i = 0, _a = this._endpoints; _i < _a.length; _i++) {
        var endpoint = _a[_i];
        if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
          return true;
        }
        if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {
          if (endpoint.ownerBlock.outputs.some(function(o) {
            return o.isConnectedInFragmentShader;
          })) {
            return true;
          }
        }
      }
      return false;
    },
    enumerable: false,
    configurable: true
  });
  NodeMaterialConnectionPoint2.prototype.createCustomInputBlock = function() {
    return null;
  };
  NodeMaterialConnectionPoint2.prototype.getClassName = function() {
    return "NodeMaterialConnectionPoint";
  };
  NodeMaterialConnectionPoint2.prototype.canConnectTo = function(connectionPoint) {
    return this.checkCompatibilityState(connectionPoint) === NodeMaterialConnectionPointCompatibilityStates.Compatible;
  };
  NodeMaterialConnectionPoint2.prototype.checkCompatibilityState = function(connectionPoint) {
    var ownerBlock = this._ownerBlock;
    if (ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      var otherBlock = connectionPoint.ownerBlock;
      if (otherBlock.target === NodeMaterialBlockTargets.Vertex) {
        return NodeMaterialConnectionPointCompatibilityStates.TargetIncompatible;
      }
      for (var _i = 0, _a = otherBlock.outputs; _i < _a.length; _i++) {
        var output = _a[_i];
        if (output.isConnectedInVertexShader) {
          return NodeMaterialConnectionPointCompatibilityStates.TargetIncompatible;
        }
      }
    }
    if (this.type !== connectionPoint.type && connectionPoint.innerType !== NodeMaterialBlockConnectionPointTypes.AutoDetect) {
      if (NodeMaterialConnectionPoint2.AreEquivalentTypes(this.type, connectionPoint.type)) {
        return NodeMaterialConnectionPointCompatibilityStates.Compatible;
      }
      if (connectionPoint.acceptedConnectionPointTypes && connectionPoint.acceptedConnectionPointTypes.indexOf(this.type) !== -1 || connectionPoint._acceptedConnectionPointType && NodeMaterialConnectionPoint2.AreEquivalentTypes(connectionPoint._acceptedConnectionPointType.type, this.type)) {
        return NodeMaterialConnectionPointCompatibilityStates.Compatible;
      } else {
        return NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;
      }
    }
    if (connectionPoint.excludedConnectionPointTypes && connectionPoint.excludedConnectionPointTypes.indexOf(this.type) !== -1) {
      return 1;
    }
    return NodeMaterialConnectionPointCompatibilityStates.Compatible;
  };
  NodeMaterialConnectionPoint2.prototype.connectTo = function(connectionPoint, ignoreConstraints) {
    if (ignoreConstraints === void 0) {
      ignoreConstraints = false;
    }
    if (!ignoreConstraints && !this.canConnectTo(connectionPoint)) {
      throw "Cannot connect these two connectors.";
    }
    this._endpoints.push(connectionPoint);
    connectionPoint._connectedPoint = this;
    this._enforceAssociatedVariableName = false;
    this.onConnectionObservable.notifyObservers(connectionPoint);
    connectionPoint.onConnectionObservable.notifyObservers(this);
    return this;
  };
  NodeMaterialConnectionPoint2.prototype.disconnectFrom = function(endpoint) {
    var index = this._endpoints.indexOf(endpoint);
    if (index === -1) {
      return this;
    }
    this._endpoints.splice(index, 1);
    endpoint._connectedPoint = null;
    this._enforceAssociatedVariableName = false;
    endpoint._enforceAssociatedVariableName = false;
    return this;
  };
  NodeMaterialConnectionPoint2.prototype.serialize = function(isInput) {
    if (isInput === void 0) {
      isInput = true;
    }
    var serializationObject = {};
    serializationObject.name = this.name;
    serializationObject.displayName = this.displayName;
    if (isInput && this.connectedPoint) {
      serializationObject.inputName = this.name;
      serializationObject.targetBlockId = this.connectedPoint.ownerBlock.uniqueId;
      serializationObject.targetConnectionName = this.connectedPoint.name;
      serializationObject.isExposedOnFrame = true;
      serializationObject.exposedPortPosition = this.exposedPortPosition;
    }
    if (this.isExposedOnFrame || this.exposedPortPosition >= 0) {
      serializationObject.isExposedOnFrame = true;
      serializationObject.exposedPortPosition = this.exposedPortPosition;
    }
    return serializationObject;
  };
  NodeMaterialConnectionPoint2.prototype.dispose = function() {
    this.onConnectionObservable.clear();
  };
  return NodeMaterialConnectionPoint2;
}();

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialBlock.js
var NodeMaterialBlock = function() {
  function NodeMaterialBlock2(name98, target, isFinalMerger, isInput) {
    if (target === void 0) {
      target = NodeMaterialBlockTargets.Vertex;
    }
    if (isFinalMerger === void 0) {
      isFinalMerger = false;
    }
    if (isInput === void 0) {
      isInput = false;
    }
    this._isFinalMerger = false;
    this._isInput = false;
    this._name = "";
    this._isUnique = false;
    this.inputsAreExclusive = false;
    this._codeVariableName = "";
    this._inputs = new Array();
    this._outputs = new Array();
    this.comments = "";
    this.visibleInInspector = false;
    this._target = target;
    this._isFinalMerger = isFinalMerger;
    this._isInput = isInput;
    this._name = name98;
    this.uniqueId = UniqueIdGenerator.UniqueId;
  }
  Object.defineProperty(NodeMaterialBlock2.prototype, "name", {
    get: function() {
      return this._name;
    },
    set: function(newName) {
      if (!this.validateBlockName(newName)) {
        return;
      }
      this._name = newName;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeMaterialBlock2.prototype, "isUnique", {
    get: function() {
      return this._isUnique;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeMaterialBlock2.prototype, "isFinalMerger", {
    get: function() {
      return this._isFinalMerger;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeMaterialBlock2.prototype, "isInput", {
    get: function() {
      return this._isInput;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeMaterialBlock2.prototype, "buildId", {
    get: function() {
      return this._buildId;
    },
    set: function(value) {
      this._buildId = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeMaterialBlock2.prototype, "target", {
    get: function() {
      return this._target;
    },
    set: function(value) {
      if ((this._target & value) !== 0) {
        return;
      }
      this._target = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeMaterialBlock2.prototype, "inputs", {
    get: function() {
      return this._inputs;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeMaterialBlock2.prototype, "outputs", {
    get: function() {
      return this._outputs;
    },
    enumerable: false,
    configurable: true
  });
  NodeMaterialBlock2.prototype.getInputByName = function(name98) {
    var filter = this._inputs.filter(function(e) {
      return e.name === name98;
    });
    if (filter.length) {
      return filter[0];
    }
    return null;
  };
  NodeMaterialBlock2.prototype.getOutputByName = function(name98) {
    var filter = this._outputs.filter(function(e) {
      return e.name === name98;
    });
    if (filter.length) {
      return filter[0];
    }
    return null;
  };
  NodeMaterialBlock2.prototype.initialize = function(state) {
  };
  NodeMaterialBlock2.prototype.bind = function(effect, nodeMaterial, mesh, subMesh) {
  };
  NodeMaterialBlock2.prototype._declareOutput = function(output, state) {
    return state._getGLType(output.type) + " " + output.associatedVariableName;
  };
  NodeMaterialBlock2.prototype._writeVariable = function(currentPoint) {
    var connectionPoint = currentPoint.connectedPoint;
    if (connectionPoint) {
      return "" + currentPoint.associatedVariableName;
    }
    return "0.";
  };
  NodeMaterialBlock2.prototype._writeFloat = function(value) {
    var stringVersion = value.toString();
    if (stringVersion.indexOf(".") === -1) {
      stringVersion += ".0";
    }
    return "" + stringVersion;
  };
  NodeMaterialBlock2.prototype.getClassName = function() {
    return "NodeMaterialBlock";
  };
  NodeMaterialBlock2.prototype.registerInput = function(name98, type, isOptional, target, point) {
    if (isOptional === void 0) {
      isOptional = false;
    }
    point = point !== null && point !== void 0 ? point : new NodeMaterialConnectionPoint(name98, this, NodeMaterialConnectionPointDirection.Input);
    point.type = type;
    point.isOptional = isOptional;
    if (target) {
      point.target = target;
    }
    this._inputs.push(point);
    return this;
  };
  NodeMaterialBlock2.prototype.registerOutput = function(name98, type, target, point) {
    point = point !== null && point !== void 0 ? point : new NodeMaterialConnectionPoint(name98, this, NodeMaterialConnectionPointDirection.Output);
    point.type = type;
    if (target) {
      point.target = target;
    }
    this._outputs.push(point);
    return this;
  };
  NodeMaterialBlock2.prototype.getFirstAvailableInput = function(forOutput) {
    if (forOutput === void 0) {
      forOutput = null;
    }
    for (var _i = 0, _a = this._inputs; _i < _a.length; _i++) {
      var input = _a[_i];
      if (!input.connectedPoint) {
        if (!forOutput || forOutput.type === input.type || input.type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {
          return input;
        }
      }
    }
    return null;
  };
  NodeMaterialBlock2.prototype.getFirstAvailableOutput = function(forBlock) {
    if (forBlock === void 0) {
      forBlock = null;
    }
    for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {
      var output = _a[_i];
      if (!forBlock || !forBlock.target || forBlock.target === NodeMaterialBlockTargets.Neutral || (forBlock.target & output.target) !== 0) {
        return output;
      }
    }
    return null;
  };
  NodeMaterialBlock2.prototype.getSiblingOutput = function(current) {
    var index = this._outputs.indexOf(current);
    if (index === -1 || index >= this._outputs.length) {
      return null;
    }
    return this._outputs[index + 1];
  };
  NodeMaterialBlock2.prototype.connectTo = function(other, options) {
    if (this._outputs.length === 0) {
      return;
    }
    var output = options && options.output ? this.getOutputByName(options.output) : this.getFirstAvailableOutput(other);
    var notFound = true;
    while (notFound) {
      var input = options && options.input ? other.getInputByName(options.input) : other.getFirstAvailableInput(output);
      if (output && input && output.canConnectTo(input)) {
        output.connectTo(input);
        notFound = false;
      } else if (!output) {
        throw "Unable to find a compatible match";
      } else {
        output = this.getSiblingOutput(output);
      }
    }
    return this;
  };
  NodeMaterialBlock2.prototype._buildBlock = function(state) {
  };
  NodeMaterialBlock2.prototype.updateUniformsAndSamples = function(state, nodeMaterial, defines, uniformBuffers) {
  };
  NodeMaterialBlock2.prototype.provideFallbacks = function(mesh, fallbacks) {
  };
  NodeMaterialBlock2.prototype.initializeDefines = function(mesh, nodeMaterial, defines, useInstances) {
    if (useInstances === void 0) {
      useInstances = false;
    }
  };
  NodeMaterialBlock2.prototype.prepareDefines = function(mesh, nodeMaterial, defines, useInstances, subMesh) {
    if (useInstances === void 0) {
      useInstances = false;
    }
  };
  NodeMaterialBlock2.prototype.autoConfigure = function(material) {
  };
  NodeMaterialBlock2.prototype.replaceRepeatableContent = function(vertexShaderState, fragmentShaderState, mesh, defines) {
  };
  NodeMaterialBlock2.prototype.isReady = function(mesh, nodeMaterial, defines, useInstances) {
    if (useInstances === void 0) {
      useInstances = false;
    }
    return true;
  };
  NodeMaterialBlock2.prototype._linkConnectionTypes = function(inputIndex0, inputIndex1, looseCoupling) {
    if (looseCoupling === void 0) {
      looseCoupling = false;
    }
    if (looseCoupling) {
      this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];
    } else {
      this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];
    }
    this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];
  };
  NodeMaterialBlock2.prototype._processBuild = function(block, state, input, activeBlocks) {
    block.build(state, activeBlocks);
    var localBlockIsFragment = state._vertexState != null;
    var otherBlockWasGeneratedInVertexShader = block._buildTarget === NodeMaterialBlockTargets.Vertex && block.target !== NodeMaterialBlockTargets.VertexAndFragment;
    if (localBlockIsFragment && ((block.target & block._buildTarget) === 0 || (block.target & input.target) === 0 || this.target !== NodeMaterialBlockTargets.VertexAndFragment && otherBlockWasGeneratedInVertexShader)) {
      if (!block.isInput && state.target !== block._buildTarget || block.isInput && block.isAttribute && !block._noContextSwitch) {
        var connectedPoint = input.connectedPoint;
        if (state._vertexState._emitVaryingFromString("v_" + connectedPoint.associatedVariableName, state._getGLType(connectedPoint.type))) {
          state._vertexState.compilationString += "v_" + connectedPoint.associatedVariableName + " = " + connectedPoint.associatedVariableName + ";\r\n";
        }
        input.associatedVariableName = "v_" + connectedPoint.associatedVariableName;
        input._enforceAssociatedVariableName = true;
      }
    }
  };
  NodeMaterialBlock2.prototype.validateBlockName = function(newName) {
    var reservedNames = [
      "position",
      "normal",
      "tangent",
      "particle_positionw",
      "uv",
      "uv2",
      "position2d",
      "particle_uv",
      "matricesIndices",
      "matricesWeights",
      "world0",
      "world1",
      "world2",
      "world3",
      "particle_color",
      "particle_texturemask"
    ];
    for (var _i = 0, reservedNames_1 = reservedNames; _i < reservedNames_1.length; _i++) {
      var reservedName = reservedNames_1[_i];
      if (newName === reservedName) {
        return false;
      }
    }
    return true;
  };
  NodeMaterialBlock2.prototype.build = function(state, activeBlocks) {
    if (this._buildId === state.sharedData.buildId) {
      return true;
    }
    if (!this.isInput) {
      for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {
        var output = _a[_i];
        if (!output.associatedVariableName) {
          output.associatedVariableName = state._getFreeVariableName(output.name);
        }
      }
    }
    for (var _b = 0, _c = this._inputs; _b < _c.length; _b++) {
      var input = _c[_b];
      if (!input.connectedPoint) {
        if (!input.isOptional) {
          state.sharedData.checks.notConnectedNonOptionalInputs.push(input);
        }
        continue;
      }
      if (this.target !== NodeMaterialBlockTargets.Neutral) {
        if ((input.target & this.target) === 0) {
          continue;
        }
        if ((input.target & state.target) === 0) {
          continue;
        }
      }
      var block = input.connectedPoint.ownerBlock;
      if (block && block !== this) {
        this._processBuild(block, state, input, activeBlocks);
      }
    }
    if (this._buildId === state.sharedData.buildId) {
      return true;
    }
    if (state.sharedData.verbose) {
      console.log((state.target === NodeMaterialBlockTargets.Vertex ? "Vertex shader" : "Fragment shader") + ": Building " + this.name + " [" + this.getClassName() + "]");
    }
    if (this.isFinalMerger) {
      switch (state.target) {
        case NodeMaterialBlockTargets.Vertex:
          state.sharedData.checks.emitVertex = true;
          break;
        case NodeMaterialBlockTargets.Fragment:
          state.sharedData.checks.emitFragment = true;
          break;
      }
    }
    if (!this.isInput && state.sharedData.emitComments) {
      state.compilationString += "\r\n//" + this.name + "\r\n";
    }
    this._buildBlock(state);
    this._buildId = state.sharedData.buildId;
    this._buildTarget = state.target;
    for (var _d = 0, _e = this._outputs; _d < _e.length; _d++) {
      var output = _e[_d];
      if ((output.target & state.target) === 0) {
        continue;
      }
      for (var _f = 0, _g = output.endpoints; _f < _g.length; _f++) {
        var endpoint = _g[_f];
        var block = endpoint.ownerBlock;
        if (block && (block.target & state.target) !== 0 && activeBlocks.indexOf(block) !== -1) {
          this._processBuild(block, state, endpoint, activeBlocks);
        }
      }
    }
    return false;
  };
  NodeMaterialBlock2.prototype._inputRename = function(name98) {
    return name98;
  };
  NodeMaterialBlock2.prototype._outputRename = function(name98) {
    return name98;
  };
  NodeMaterialBlock2.prototype._dumpPropertiesCode = function() {
    var variableName = this._codeVariableName;
    return variableName + ".visibleInInspector = " + this.visibleInInspector + ";\r\n";
  };
  NodeMaterialBlock2.prototype._dumpCode = function(uniqueNames, alreadyDumped) {
    alreadyDumped.push(this);
    var codeString;
    var nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, "");
    this._codeVariableName = nameAsVariableName || this.getClassName() + "_" + this.uniqueId;
    if (uniqueNames.indexOf(this._codeVariableName) !== -1) {
      var index = 0;
      do {
        index++;
        this._codeVariableName = nameAsVariableName + index;
      } while (uniqueNames.indexOf(this._codeVariableName) !== -1);
    }
    uniqueNames.push(this._codeVariableName);
    codeString = "\r\n// " + this.getClassName() + "\r\n";
    if (this.comments) {
      codeString += "// " + this.comments + "\r\n";
    }
    codeString += "var " + this._codeVariableName + " = new BABYLON." + this.getClassName() + '("' + this.name + '");\r\n';
    codeString += this._dumpPropertiesCode();
    for (var _i = 0, _a = this.inputs; _i < _a.length; _i++) {
      var input = _a[_i];
      if (!input.isConnected) {
        continue;
      }
      var connectedOutput = input.connectedPoint;
      var connectedBlock = connectedOutput.ownerBlock;
      if (alreadyDumped.indexOf(connectedBlock) === -1) {
        codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);
      }
    }
    for (var _b = 0, _c = this.outputs; _b < _c.length; _b++) {
      var output = _c[_b];
      if (!output.hasEndpoints) {
        continue;
      }
      for (var _d = 0, _e = output.endpoints; _d < _e.length; _d++) {
        var endpoint = _e[_d];
        var connectedBlock = endpoint.ownerBlock;
        if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {
          codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);
        }
      }
    }
    return codeString;
  };
  NodeMaterialBlock2.prototype._dumpCodeForOutputConnections = function(alreadyDumped) {
    var codeString = "";
    if (alreadyDumped.indexOf(this) !== -1) {
      return codeString;
    }
    alreadyDumped.push(this);
    for (var _i = 0, _a = this.inputs; _i < _a.length; _i++) {
      var input = _a[_i];
      if (!input.isConnected) {
        continue;
      }
      var connectedOutput = input.connectedPoint;
      var connectedBlock = connectedOutput.ownerBlock;
      codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);
      codeString += connectedBlock._codeVariableName + "." + connectedBlock._outputRename(connectedOutput.name) + ".connectTo(" + this._codeVariableName + "." + this._inputRename(input.name) + ");\r\n";
    }
    return codeString;
  };
  NodeMaterialBlock2.prototype.clone = function(scene, rootUrl) {
    if (rootUrl === void 0) {
      rootUrl = "";
    }
    var serializationObject = this.serialize();
    var blockType = _TypeStore.GetClass(serializationObject.customType);
    if (blockType) {
      var block = new blockType();
      block._deserialize(serializationObject, scene, rootUrl);
      return block;
    }
    return null;
  };
  NodeMaterialBlock2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.customType = "BABYLON." + this.getClassName();
    serializationObject.id = this.uniqueId;
    serializationObject.name = this.name;
    serializationObject.comments = this.comments;
    serializationObject.visibleInInspector = this.visibleInInspector;
    serializationObject.inputs = [];
    serializationObject.outputs = [];
    for (var _i = 0, _a = this.inputs; _i < _a.length; _i++) {
      var input = _a[_i];
      serializationObject.inputs.push(input.serialize());
    }
    for (var _b = 0, _c = this.outputs; _b < _c.length; _b++) {
      var output = _c[_b];
      serializationObject.outputs.push(output.serialize(false));
    }
    return serializationObject;
  };
  NodeMaterialBlock2.prototype._deserialize = function(serializationObject, scene, rootUrl) {
    this.name = serializationObject.name;
    this.comments = serializationObject.comments;
    this.visibleInInspector = !!serializationObject.visibleInInspector;
    this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);
  };
  NodeMaterialBlock2.prototype._deserializePortDisplayNamesAndExposedOnFrame = function(serializationObject) {
    var _this = this;
    var serializedInputs = serializationObject.inputs;
    var serializedOutputs = serializationObject.outputs;
    if (serializedInputs) {
      serializedInputs.forEach(function(port, i) {
        if (port.displayName) {
          _this.inputs[i].displayName = port.displayName;
        }
        if (port.isExposedOnFrame) {
          _this.inputs[i].isExposedOnFrame = port.isExposedOnFrame;
          _this.inputs[i].exposedPortPosition = port.exposedPortPosition;
        }
      });
    }
    if (serializedOutputs) {
      serializedOutputs.forEach(function(port, i) {
        if (port.displayName) {
          _this.outputs[i].displayName = port.displayName;
        }
        if (port.isExposedOnFrame) {
          _this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;
          _this.outputs[i].exposedPortPosition = port.exposedPortPosition;
        }
      });
    }
  };
  NodeMaterialBlock2.prototype.dispose = function() {
    for (var _i = 0, _a = this.inputs; _i < _a.length; _i++) {
      var input = _a[_i];
      input.dispose();
    }
    for (var _b = 0, _c = this.outputs; _b < _c.length; _b++) {
      var output = _c[_b];
      output.dispose();
    }
  };
  return NodeMaterialBlock2;
}();

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialBuildState.js
var NodeMaterialBuildState = function() {
  function NodeMaterialBuildState2() {
    this.supportUniformBuffers = false;
    this.attributes = new Array();
    this.uniforms = new Array();
    this.constants = new Array();
    this.samplers = new Array();
    this.functions = {};
    this.extensions = {};
    this.counters = {};
    this._attributeDeclaration = "";
    this._uniformDeclaration = "";
    this._constantDeclaration = "";
    this._samplerDeclaration = "";
    this._varyingTransfer = "";
    this._injectAtEnd = "";
    this._repeatableContentAnchorIndex = 0;
    this._builtCompilationString = "";
    this.compilationString = "";
  }
  NodeMaterialBuildState2.prototype.finalize = function(state) {
    var emitComments = state.sharedData.emitComments;
    var isFragmentMode = this.target === NodeMaterialBlockTargets.Fragment;
    this.compilationString = "\r\n" + (emitComments ? "//Entry point\r\n" : "") + "void main(void) {\r\n" + this.compilationString;
    if (this._constantDeclaration) {
      this.compilationString = "\r\n" + (emitComments ? "//Constants\r\n" : "") + this._constantDeclaration + "\r\n" + this.compilationString;
    }
    var functionCode = "";
    for (var functionName in this.functions) {
      functionCode += this.functions[functionName] + "\r\n";
    }
    this.compilationString = "\r\n" + functionCode + "\r\n" + this.compilationString;
    if (!isFragmentMode && this._varyingTransfer) {
      this.compilationString = this.compilationString + "\r\n" + this._varyingTransfer;
    }
    if (this._injectAtEnd) {
      this.compilationString = this.compilationString + "\r\n" + this._injectAtEnd;
    }
    this.compilationString = this.compilationString + "\r\n}";
    if (this.sharedData.varyingDeclaration) {
      this.compilationString = "\r\n" + (emitComments ? "//Varyings\r\n" : "") + this.sharedData.varyingDeclaration + "\r\n" + this.compilationString;
    }
    if (this._samplerDeclaration) {
      this.compilationString = "\r\n" + (emitComments ? "//Samplers\r\n" : "") + this._samplerDeclaration + "\r\n" + this.compilationString;
    }
    if (this._uniformDeclaration) {
      this.compilationString = "\r\n" + (emitComments ? "//Uniforms\r\n" : "") + this._uniformDeclaration + "\r\n" + this.compilationString;
    }
    if (this._attributeDeclaration && !isFragmentMode) {
      this.compilationString = "\r\n" + (emitComments ? "//Attributes\r\n" : "") + this._attributeDeclaration + "\r\n" + this.compilationString;
    }
    this.compilationString = "precision highp float;\r\n" + this.compilationString;
    for (var extensionName in this.extensions) {
      var extension = this.extensions[extensionName];
      this.compilationString = "\r\n" + extension + "\r\n" + this.compilationString;
    }
    this._builtCompilationString = this.compilationString;
  };
  Object.defineProperty(NodeMaterialBuildState2.prototype, "_repeatableContentAnchor", {
    get: function() {
      return "###___ANCHOR" + this._repeatableContentAnchorIndex++ + "___###";
    },
    enumerable: false,
    configurable: true
  });
  NodeMaterialBuildState2.prototype._getFreeVariableName = function(prefix) {
    prefix = prefix.replace(/[^a-zA-Z_]+/g, "");
    if (this.sharedData.variableNames[prefix] === void 0) {
      this.sharedData.variableNames[prefix] = 0;
      if (prefix === "output" || prefix === "texture") {
        return prefix + this.sharedData.variableNames[prefix];
      }
      return prefix;
    } else {
      this.sharedData.variableNames[prefix]++;
    }
    return prefix + this.sharedData.variableNames[prefix];
  };
  NodeMaterialBuildState2.prototype._getFreeDefineName = function(prefix) {
    if (this.sharedData.defineNames[prefix] === void 0) {
      this.sharedData.defineNames[prefix] = 0;
    } else {
      this.sharedData.defineNames[prefix]++;
    }
    return prefix + this.sharedData.defineNames[prefix];
  };
  NodeMaterialBuildState2.prototype._excludeVariableName = function(name98) {
    this.sharedData.variableNames[name98] = 0;
  };
  NodeMaterialBuildState2.prototype._emit2DSampler = function(name98) {
    if (this.samplers.indexOf(name98) < 0) {
      this._samplerDeclaration += "uniform sampler2D " + name98 + ";\r\n";
      this.samplers.push(name98);
    }
  };
  NodeMaterialBuildState2.prototype._getGLType = function(type) {
    switch (type) {
      case NodeMaterialBlockConnectionPointTypes.Float:
        return "float";
      case NodeMaterialBlockConnectionPointTypes.Int:
        return "int";
      case NodeMaterialBlockConnectionPointTypes.Vector2:
        return "vec2";
      case NodeMaterialBlockConnectionPointTypes.Color3:
      case NodeMaterialBlockConnectionPointTypes.Vector3:
        return "vec3";
      case NodeMaterialBlockConnectionPointTypes.Color4:
      case NodeMaterialBlockConnectionPointTypes.Vector4:
        return "vec4";
      case NodeMaterialBlockConnectionPointTypes.Matrix:
        return "mat4";
    }
    return "";
  };
  NodeMaterialBuildState2.prototype._emitExtension = function(name98, extension, define) {
    if (define === void 0) {
      define = "";
    }
    if (this.extensions[name98]) {
      return;
    }
    if (define) {
      extension = "#if " + define + "\r\n" + extension + "\r\n#endif";
    }
    this.extensions[name98] = extension;
  };
  NodeMaterialBuildState2.prototype._emitFunction = function(name98, code, comments) {
    if (this.functions[name98]) {
      return;
    }
    if (this.sharedData.emitComments) {
      code = comments + "\r\n" + code;
    }
    this.functions[name98] = code;
  };
  NodeMaterialBuildState2.prototype._emitCodeFromInclude = function(includeName, comments, options) {
    if (options && options.repeatKey) {
      return "#include<" + includeName + ">[0.." + options.repeatKey + "]\r\n";
    }
    var code = Effect.IncludesShadersStore[includeName] + "\r\n";
    if (this.sharedData.emitComments) {
      code = comments + "\r\n" + code;
    }
    if (!options) {
      return code;
    }
    if (options.replaceStrings) {
      for (var index = 0; index < options.replaceStrings.length; index++) {
        var replaceString = options.replaceStrings[index];
        code = code.replace(replaceString.search, replaceString.replace);
      }
    }
    return code;
  };
  NodeMaterialBuildState2.prototype._emitFunctionFromInclude = function(includeName, comments, options, storeKey) {
    if (storeKey === void 0) {
      storeKey = "";
    }
    var key = includeName + storeKey;
    if (this.functions[key]) {
      return;
    }
    if (!options || !options.removeAttributes && !options.removeUniforms && !options.removeVaryings && !options.removeIfDef && !options.replaceStrings) {
      if (options && options.repeatKey) {
        this.functions[key] = "#include<" + includeName + ">[0.." + options.repeatKey + "]\r\n";
      } else {
        this.functions[key] = "#include<" + includeName + ">\r\n";
      }
      if (this.sharedData.emitComments) {
        this.functions[key] = comments + "\r\n" + this.functions[key];
      }
      return;
    }
    this.functions[key] = Effect.IncludesShadersStore[includeName];
    if (this.sharedData.emitComments) {
      this.functions[key] = comments + "\r\n" + this.functions[key];
    }
    if (options.removeIfDef) {
      this.functions[key] = this.functions[key].replace(/^\s*?#ifdef.+$/gm, "");
      this.functions[key] = this.functions[key].replace(/^\s*?#endif.*$/gm, "");
      this.functions[key] = this.functions[key].replace(/^\s*?#else.*$/gm, "");
      this.functions[key] = this.functions[key].replace(/^\s*?#elif.*$/gm, "");
    }
    if (options.removeAttributes) {
      this.functions[key] = this.functions[key].replace(/^\s*?attribute.+$/gm, "");
    }
    if (options.removeUniforms) {
      this.functions[key] = this.functions[key].replace(/^\s*?uniform.+$/gm, "");
    }
    if (options.removeVaryings) {
      this.functions[key] = this.functions[key].replace(/^\s*?varying.+$/gm, "");
    }
    if (options.replaceStrings) {
      for (var index = 0; index < options.replaceStrings.length; index++) {
        var replaceString = options.replaceStrings[index];
        this.functions[key] = this.functions[key].replace(replaceString.search, replaceString.replace);
      }
    }
  };
  NodeMaterialBuildState2.prototype._registerTempVariable = function(name98) {
    if (this.sharedData.temps.indexOf(name98) !== -1) {
      return false;
    }
    this.sharedData.temps.push(name98);
    return true;
  };
  NodeMaterialBuildState2.prototype._emitVaryingFromString = function(name98, type, define, notDefine) {
    if (define === void 0) {
      define = "";
    }
    if (notDefine === void 0) {
      notDefine = false;
    }
    if (this.sharedData.varyings.indexOf(name98) !== -1) {
      return false;
    }
    this.sharedData.varyings.push(name98);
    if (define) {
      if (StringTools.StartsWith(define, "defined(")) {
        this.sharedData.varyingDeclaration += "#if " + define + "\r\n";
      } else {
        this.sharedData.varyingDeclaration += (notDefine ? "#ifndef" : "#ifdef") + " " + define + "\r\n";
      }
    }
    this.sharedData.varyingDeclaration += "varying " + type + " " + name98 + ";\r\n";
    if (define) {
      this.sharedData.varyingDeclaration += "#endif\r\n";
    }
    return true;
  };
  NodeMaterialBuildState2.prototype._emitUniformFromString = function(name98, type, define, notDefine) {
    if (define === void 0) {
      define = "";
    }
    if (notDefine === void 0) {
      notDefine = false;
    }
    if (this.uniforms.indexOf(name98) !== -1) {
      return;
    }
    this.uniforms.push(name98);
    if (define) {
      if (StringTools.StartsWith(define, "defined(")) {
        this._uniformDeclaration += "#if " + define + "\r\n";
      } else {
        this._uniformDeclaration += (notDefine ? "#ifndef" : "#ifdef") + " " + define + "\r\n";
      }
    }
    this._uniformDeclaration += "uniform " + type + " " + name98 + ";\r\n";
    if (define) {
      this._uniformDeclaration += "#endif\r\n";
    }
  };
  NodeMaterialBuildState2.prototype._emitFloat = function(value) {
    if (value.toString() === value.toFixed(0)) {
      return value + ".0";
    }
    return value.toString();
  };
  return NodeMaterialBuildState2;
}();

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialBuildStateSharedData.js
var NodeMaterialBuildStateSharedData = function() {
  function NodeMaterialBuildStateSharedData2() {
    this.temps = new Array();
    this.varyings = new Array();
    this.varyingDeclaration = "";
    this.inputBlocks = new Array();
    this.textureBlocks = new Array();
    this.bindableBlocks = new Array();
    this.blocksWithFallbacks = new Array();
    this.blocksWithDefines = new Array();
    this.repeatableContentBlocks = new Array();
    this.dynamicUniformBlocks = new Array();
    this.blockingBlocks = new Array();
    this.animatedInputs = new Array();
    this.variableNames = {};
    this.defineNames = {};
    this.hints = {
      needWorldViewMatrix: false,
      needWorldViewProjectionMatrix: false,
      needAlphaBlending: false,
      needAlphaTesting: false
    };
    this.checks = {
      emitVertex: false,
      emitFragment: false,
      notConnectedNonOptionalInputs: new Array()
    };
    this.allowEmptyVertexProgram = false;
    this.variableNames["position"] = 0;
    this.variableNames["normal"] = 0;
    this.variableNames["tangent"] = 0;
    this.variableNames["uv"] = 0;
    this.variableNames["uv2"] = 0;
    this.variableNames["uv3"] = 0;
    this.variableNames["uv4"] = 0;
    this.variableNames["uv4"] = 0;
    this.variableNames["uv5"] = 0;
    this.variableNames["uv6"] = 0;
    this.variableNames["color"] = 0;
    this.variableNames["matricesIndices"] = 0;
    this.variableNames["matricesWeights"] = 0;
    this.variableNames["matricesIndicesExtra"] = 0;
    this.variableNames["matricesWeightsExtra"] = 0;
    this.variableNames["diffuseBase"] = 0;
    this.variableNames["specularBase"] = 0;
    this.variableNames["worldPos"] = 0;
    this.variableNames["shadow"] = 0;
    this.variableNames["view"] = 0;
    this.variableNames["vTBN"] = 0;
    this.defineNames["MAINUV0"] = 0;
    this.defineNames["MAINUV1"] = 0;
    this.defineNames["MAINUV2"] = 0;
    this.defineNames["MAINUV3"] = 0;
    this.defineNames["MAINUV4"] = 0;
    this.defineNames["MAINUV5"] = 0;
    this.defineNames["MAINUV6"] = 0;
    this.defineNames["MAINUV7"] = 0;
  }
  NodeMaterialBuildStateSharedData2.prototype.emitErrors = function() {
    var errorMessage = "";
    if (!this.checks.emitVertex && !this.allowEmptyVertexProgram) {
      errorMessage += "NodeMaterial does not have a vertex output. You need to at least add a block that generates a glPosition value.\r\n";
    }
    if (!this.checks.emitFragment) {
      errorMessage += "NodeMaterial does not have a fragment output. You need to at least add a block that generates a glFragColor value.\r\n";
    }
    for (var _i = 0, _a = this.checks.notConnectedNonOptionalInputs; _i < _a.length; _i++) {
      var notConnectedInput = _a[_i];
      errorMessage += "input " + notConnectedInput.name + " from block " + notConnectedInput.ownerBlock.name + "[" + notConnectedInput.ownerBlock.getClassName() + "] is not connected and is not optional.\r\n";
    }
    if (errorMessage) {
      throw "Build of NodeMaterial failed:\r\n" + errorMessage;
    }
  };
  return NodeMaterialBuildStateSharedData2;
}();

// node_modules/@babylonjs/core/Materials/Node/Blocks/transformBlock.js
var TransformBlock = function(_super) {
  __extends(TransformBlock2, _super);
  function TransformBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Vertex) || this;
    _this.complementW = 1;
    _this.complementZ = 0;
    _this.registerInput("vector", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerInput("transform", NodeMaterialBlockConnectionPointTypes.Matrix);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector4);
    _this.registerOutput("xyz", NodeMaterialBlockConnectionPointTypes.Vector3);
    _this._inputs[0].onConnectionObservable.add(function(other) {
      if (other.ownerBlock.isInput) {
        var otherAsInput = other.ownerBlock;
        if (otherAsInput.name === "normal" || otherAsInput.name === "tangent") {
          _this.complementW = 0;
        }
      }
    });
    return _this;
  }
  TransformBlock2.prototype.getClassName = function() {
    return "TransformBlock";
  };
  Object.defineProperty(TransformBlock2.prototype, "vector", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformBlock2.prototype, "xyz", {
    get: function() {
      return this._outputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformBlock2.prototype, "transform", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  TransformBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var vector = this.vector;
    var transform = this.transform;
    if (vector.connectedPoint) {
      if (this.complementW === 0) {
        var comments = "//" + this.name;
        state._emitFunctionFromInclude("helperFunctions", comments);
        state.sharedData.blocksWithDefines.push(this);
        var transformName = state._getFreeVariableName(transform.associatedVariableName + "_NUS");
        state.compilationString += "mat3 " + transformName + " = mat3(" + transform.associatedVariableName + ");\r\n";
        state.compilationString += "#ifdef NONUNIFORMSCALING\r\n";
        state.compilationString += transformName + " = transposeMat3(inverseMat3(" + transformName + "));\r\n";
        state.compilationString += "#endif\r\n";
        switch (vector.connectedPoint.type) {
          case NodeMaterialBlockConnectionPointTypes.Vector2:
            state.compilationString += this._declareOutput(this.output, state) + (" = vec4(" + transformName + " * vec3(" + vector.associatedVariableName + ", " + this._writeFloat(this.complementZ) + "), " + this._writeFloat(this.complementW) + ");\r\n");
            break;
          case NodeMaterialBlockConnectionPointTypes.Vector3:
          case NodeMaterialBlockConnectionPointTypes.Color3:
            state.compilationString += this._declareOutput(this.output, state) + (" = vec4(" + transformName + " * " + vector.associatedVariableName + ", " + this._writeFloat(this.complementW) + ");\r\n");
            break;
          default:
            state.compilationString += this._declareOutput(this.output, state) + (" = vec4(" + transformName + " * " + vector.associatedVariableName + ".xyz, " + this._writeFloat(this.complementW) + ");\r\n");
            break;
        }
      } else {
        var transformName = transform.associatedVariableName;
        switch (vector.connectedPoint.type) {
          case NodeMaterialBlockConnectionPointTypes.Vector2:
            state.compilationString += this._declareOutput(this.output, state) + (" = " + transformName + " * vec4(" + vector.associatedVariableName + ", " + this._writeFloat(this.complementZ) + ", " + this._writeFloat(this.complementW) + ");\r\n");
            break;
          case NodeMaterialBlockConnectionPointTypes.Vector3:
          case NodeMaterialBlockConnectionPointTypes.Color3:
            state.compilationString += this._declareOutput(this.output, state) + (" = " + transformName + " * vec4(" + vector.associatedVariableName + ", " + this._writeFloat(this.complementW) + ");\r\n");
            break;
          default:
            state.compilationString += this._declareOutput(this.output, state) + (" = " + transformName + " * " + vector.associatedVariableName + ";\r\n");
            break;
        }
      }
      if (this.xyz.hasEndpoints) {
        state.compilationString += this._declareOutput(this.xyz, state) + (" = " + this.output.associatedVariableName + ".xyz;\r\n");
      }
    }
    return this;
  };
  TransformBlock2.prototype.prepareDefines = function(mesh, nodeMaterial, defines, useInstances, subMesh) {
    if (useInstances === void 0) {
      useInstances = false;
    }
    if (mesh.nonUniformScaling) {
      defines.setValue("NONUNIFORMSCALING", true);
    }
  };
  TransformBlock2.prototype.serialize = function() {
    var serializationObject = _super.prototype.serialize.call(this);
    serializationObject.complementZ = this.complementZ;
    serializationObject.complementW = this.complementW;
    return serializationObject;
  };
  TransformBlock2.prototype._deserialize = function(serializationObject, scene, rootUrl) {
    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);
    this.complementZ = serializationObject.complementZ !== void 0 ? serializationObject.complementZ : 0;
    this.complementW = serializationObject.complementW !== void 0 ? serializationObject.complementW : 1;
  };
  TransformBlock2.prototype._dumpPropertiesCode = function() {
    var codeString = this._codeVariableName + ".complementZ = " + this.complementZ + ";\r\n";
    codeString += this._codeVariableName + ".complementW = " + this.complementW + ";\r\n";
    return codeString;
  };
  return TransformBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.TransformBlock"] = TransformBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/Vertex/vertexOutputBlock.js
var VertexOutputBlock = function(_super) {
  __extends(VertexOutputBlock2, _super);
  function VertexOutputBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Vertex, true) || this;
    _this.registerInput("vector", NodeMaterialBlockConnectionPointTypes.Vector4);
    return _this;
  }
  VertexOutputBlock2.prototype.getClassName = function() {
    return "VertexOutputBlock";
  };
  Object.defineProperty(VertexOutputBlock2.prototype, "vector", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  VertexOutputBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var input = this.vector;
    state.compilationString += "gl_Position = " + input.associatedVariableName + ";\r\n";
    return this;
  };
  return VertexOutputBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.VertexOutputBlock"] = VertexOutputBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/fragmentOutputBlock.js
var FragmentOutputBlock = function(_super) {
  __extends(FragmentOutputBlock2, _super);
  function FragmentOutputBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Fragment, true) || this;
    _this.registerInput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, true);
    _this.registerInput("rgb", NodeMaterialBlockConnectionPointTypes.Color3, true);
    _this.registerInput("a", NodeMaterialBlockConnectionPointTypes.Float, true);
    _this.rgb.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    return _this;
  }
  FragmentOutputBlock2.prototype.getClassName = function() {
    return "FragmentOutputBlock";
  };
  Object.defineProperty(FragmentOutputBlock2.prototype, "rgba", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FragmentOutputBlock2.prototype, "rgb", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FragmentOutputBlock2.prototype, "a", {
    get: function() {
      return this._inputs[2];
    },
    enumerable: false,
    configurable: true
  });
  FragmentOutputBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var rgba = this.rgba;
    var rgb = this.rgb;
    var a = this.a;
    state.sharedData.hints.needAlphaBlending = rgba.isConnected || a.isConnected;
    if (rgba.connectedPoint) {
      if (a.isConnected) {
        state.compilationString += "gl_FragColor = vec4(" + rgba.associatedVariableName + ".rgb, " + a.associatedVariableName + ");\r\n";
      } else {
        state.compilationString += "gl_FragColor = " + rgba.associatedVariableName + ";\r\n";
      }
    } else if (rgb.connectedPoint) {
      var aValue = "1.0";
      if (a.connectedPoint) {
        aValue = a.associatedVariableName;
      }
      if (rgb.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Float) {
        state.compilationString += "gl_FragColor = vec4(" + rgb.associatedVariableName + ", " + rgb.associatedVariableName + ", " + rgb.associatedVariableName + ", " + aValue + ");\r\n";
      } else {
        state.compilationString += "gl_FragColor = vec4(" + rgb.associatedVariableName + ", " + aValue + ");\r\n";
      }
    } else {
      state.sharedData.checks.notConnectedNonOptionalInputs.push(rgba);
    }
    return this;
  };
  return FragmentOutputBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.FragmentOutputBlock"] = FragmentOutputBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/Input/animatedInputBlockTypes.js
var AnimatedInputBlockTypes;
(function(AnimatedInputBlockTypes2) {
  AnimatedInputBlockTypes2[AnimatedInputBlockTypes2["None"] = 0] = "None";
  AnimatedInputBlockTypes2[AnimatedInputBlockTypes2["Time"] = 1] = "Time";
})(AnimatedInputBlockTypes || (AnimatedInputBlockTypes = {}));

// node_modules/@babylonjs/core/Materials/Node/Blocks/Input/inputBlock.js
var remapAttributeName = {
  "position2d": "position",
  "particle_uv": "vUV",
  "particle_color": "vColor",
  "particle_texturemask": "textureMask",
  "particle_positionw": "vPositionW"
};
var attributeInFragmentOnly = {
  "particle_uv": true,
  "particle_color": true,
  "particle_texturemask": true,
  "particle_positionw": true
};
var attributeAsUniform = {
  "particle_texturemask": true
};
var InputBlock = function(_super) {
  __extends(InputBlock2, _super);
  function InputBlock2(name98, target, type) {
    if (target === void 0) {
      target = NodeMaterialBlockTargets.Vertex;
    }
    if (type === void 0) {
      type = NodeMaterialBlockConnectionPointTypes.AutoDetect;
    }
    var _this = _super.call(this, name98, target, false, true) || this;
    _this._mode = NodeMaterialBlockConnectionPointMode.Undefined;
    _this._animationType = AnimatedInputBlockTypes.None;
    _this.min = 0;
    _this.max = 0;
    _this.isBoolean = false;
    _this.matrixMode = 0;
    _this._systemValue = null;
    _this.isConstant = false;
    _this.groupInInspector = "";
    _this.onValueChangedObservable = new Observable();
    _this.convertToGammaSpace = false;
    _this.convertToLinearSpace = false;
    _this._type = type;
    _this.setDefaultValue();
    _this.registerOutput("output", type);
    return _this;
  }
  Object.defineProperty(InputBlock2.prototype, "type", {
    get: function() {
      if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {
        if (this.isUniform && this.value != null) {
          if (!isNaN(this.value)) {
            this._type = NodeMaterialBlockConnectionPointTypes.Float;
            return this._type;
          }
          switch (this.value.getClassName()) {
            case "Vector2":
              this._type = NodeMaterialBlockConnectionPointTypes.Vector2;
              return this._type;
            case "Vector3":
              this._type = NodeMaterialBlockConnectionPointTypes.Vector3;
              return this._type;
            case "Vector4":
              this._type = NodeMaterialBlockConnectionPointTypes.Vector4;
              return this._type;
            case "Color3":
              this._type = NodeMaterialBlockConnectionPointTypes.Color3;
              return this._type;
            case "Color4":
              this._type = NodeMaterialBlockConnectionPointTypes.Color4;
              return this._type;
            case "Matrix":
              this._type = NodeMaterialBlockConnectionPointTypes.Matrix;
              return this._type;
          }
        }
        if (this.isAttribute) {
          switch (this.name) {
            case "position":
            case "normal":
            case "tangent":
            case "particle_positionw":
              this._type = NodeMaterialBlockConnectionPointTypes.Vector3;
              return this._type;
            case "uv":
            case "uv2":
            case "position2d":
            case "particle_uv":
              this._type = NodeMaterialBlockConnectionPointTypes.Vector2;
              return this._type;
            case "matricesIndices":
            case "matricesWeights":
            case "world0":
            case "world1":
            case "world2":
            case "world3":
              this._type = NodeMaterialBlockConnectionPointTypes.Vector4;
              return this._type;
            case "color":
            case "particle_color":
            case "particle_texturemask":
              this._type = NodeMaterialBlockConnectionPointTypes.Color4;
              return this._type;
          }
        }
        if (this.isSystemValue) {
          switch (this._systemValue) {
            case NodeMaterialSystemValues.World:
            case NodeMaterialSystemValues.WorldView:
            case NodeMaterialSystemValues.WorldViewProjection:
            case NodeMaterialSystemValues.View:
            case NodeMaterialSystemValues.ViewProjection:
            case NodeMaterialSystemValues.Projection:
              this._type = NodeMaterialBlockConnectionPointTypes.Matrix;
              return this._type;
            case NodeMaterialSystemValues.CameraPosition:
              this._type = NodeMaterialBlockConnectionPointTypes.Vector3;
              return this._type;
            case NodeMaterialSystemValues.FogColor:
              this._type = NodeMaterialBlockConnectionPointTypes.Color3;
              return this._type;
            case NodeMaterialSystemValues.DeltaTime:
              this._type = NodeMaterialBlockConnectionPointTypes.Float;
              return this._type;
          }
        }
      }
      return this._type;
    },
    enumerable: false,
    configurable: true
  });
  InputBlock2.prototype.validateBlockName = function(newName) {
    if (!this.isAttribute) {
      return _super.prototype.validateBlockName.call(this, newName);
    }
    return true;
  };
  Object.defineProperty(InputBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  InputBlock2.prototype.setAsAttribute = function(attributeName) {
    this._mode = NodeMaterialBlockConnectionPointMode.Attribute;
    if (attributeName) {
      this.name = attributeName;
    }
    return this;
  };
  InputBlock2.prototype.setAsSystemValue = function(value) {
    this.systemValue = value;
    return this;
  };
  Object.defineProperty(InputBlock2.prototype, "value", {
    get: function() {
      return this._storedValue;
    },
    set: function(value) {
      if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {
        if (this.isBoolean) {
          value = value ? 1 : 0;
        } else if (this.min !== this.max) {
          value = Math.max(this.min, value);
          value = Math.min(this.max, value);
        }
      }
      this._storedValue = value;
      this._mode = NodeMaterialBlockConnectionPointMode.Uniform;
      this.onValueChangedObservable.notifyObservers(this);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputBlock2.prototype, "valueCallback", {
    get: function() {
      return this._valueCallback;
    },
    set: function(value) {
      this._valueCallback = value;
      this._mode = NodeMaterialBlockConnectionPointMode.Uniform;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputBlock2.prototype, "associatedVariableName", {
    get: function() {
      return this._associatedVariableName;
    },
    set: function(value) {
      this._associatedVariableName = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputBlock2.prototype, "animationType", {
    get: function() {
      return this._animationType;
    },
    set: function(value) {
      this._animationType = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputBlock2.prototype, "isUndefined", {
    get: function() {
      return this._mode === NodeMaterialBlockConnectionPointMode.Undefined;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputBlock2.prototype, "isUniform", {
    get: function() {
      return this._mode === NodeMaterialBlockConnectionPointMode.Uniform;
    },
    set: function(value) {
      this._mode = value ? NodeMaterialBlockConnectionPointMode.Uniform : NodeMaterialBlockConnectionPointMode.Undefined;
      this.associatedVariableName = "";
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputBlock2.prototype, "isAttribute", {
    get: function() {
      return this._mode === NodeMaterialBlockConnectionPointMode.Attribute;
    },
    set: function(value) {
      this._mode = value ? NodeMaterialBlockConnectionPointMode.Attribute : NodeMaterialBlockConnectionPointMode.Undefined;
      this.associatedVariableName = "";
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputBlock2.prototype, "isVarying", {
    get: function() {
      return this._mode === NodeMaterialBlockConnectionPointMode.Varying;
    },
    set: function(value) {
      this._mode = value ? NodeMaterialBlockConnectionPointMode.Varying : NodeMaterialBlockConnectionPointMode.Undefined;
      this.associatedVariableName = "";
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputBlock2.prototype, "isSystemValue", {
    get: function() {
      return this._systemValue != null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputBlock2.prototype, "systemValue", {
    get: function() {
      return this._systemValue;
    },
    set: function(value) {
      this._mode = NodeMaterialBlockConnectionPointMode.Uniform;
      this.associatedVariableName = "";
      this._systemValue = value;
    },
    enumerable: false,
    configurable: true
  });
  InputBlock2.prototype.getClassName = function() {
    return "InputBlock";
  };
  InputBlock2.prototype.animate = function(scene) {
    switch (this._animationType) {
      case AnimatedInputBlockTypes.Time: {
        if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {
          this.value += scene.getAnimationRatio() * 0.01;
        }
        break;
      }
    }
  };
  InputBlock2.prototype._emitDefine = function(define) {
    if (define[0] === "!") {
      return "#ifndef " + define.substring(1) + "\r\n";
    }
    return "#ifdef " + define + "\r\n";
  };
  InputBlock2.prototype.initialize = function(state) {
    this.associatedVariableName = "";
  };
  InputBlock2.prototype.setDefaultValue = function() {
    switch (this.type) {
      case NodeMaterialBlockConnectionPointTypes.Float:
        this.value = 0;
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector2:
        this.value = Vector2.Zero();
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector3:
        this.value = Vector3.Zero();
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector4:
        this.value = Vector4.Zero();
        break;
      case NodeMaterialBlockConnectionPointTypes.Color3:
        this.value = Color3.White();
        break;
      case NodeMaterialBlockConnectionPointTypes.Color4:
        this.value = new Color4(1, 1, 1, 1);
        break;
      case NodeMaterialBlockConnectionPointTypes.Matrix:
        this.value = Matrix.Identity();
        break;
    }
  };
  InputBlock2.prototype._emitConstant = function(state) {
    switch (this.type) {
      case NodeMaterialBlockConnectionPointTypes.Float:
        return "" + state._emitFloat(this.value);
      case NodeMaterialBlockConnectionPointTypes.Vector2:
        return "vec2(" + this.value.x + ", " + this.value.y + ")";
      case NodeMaterialBlockConnectionPointTypes.Vector3:
        return "vec3(" + this.value.x + ", " + this.value.y + ", " + this.value.z + ")";
      case NodeMaterialBlockConnectionPointTypes.Vector4:
        return "vec4(" + this.value.x + ", " + this.value.y + ", " + this.value.z + ", " + this.value.w + ")";
      case NodeMaterialBlockConnectionPointTypes.Color3:
        TmpColors.Color3[0].set(this.value.r, this.value.g, this.value.b);
        if (this.convertToGammaSpace) {
          TmpColors.Color3[0].toGammaSpaceToRef(TmpColors.Color3[0]);
        }
        if (this.convertToLinearSpace) {
          TmpColors.Color3[0].toLinearSpaceToRef(TmpColors.Color3[0]);
        }
        return "vec3(" + TmpColors.Color3[0].r + ", " + TmpColors.Color3[0].g + ", " + TmpColors.Color3[0].b + ")";
      case NodeMaterialBlockConnectionPointTypes.Color4:
        TmpColors.Color4[0].set(this.value.r, this.value.g, this.value.b, this.value.a);
        if (this.convertToGammaSpace) {
          TmpColors.Color4[0].toGammaSpaceToRef(TmpColors.Color4[0]);
        }
        if (this.convertToLinearSpace) {
          TmpColors.Color4[0].toLinearSpaceToRef(TmpColors.Color4[0]);
        }
        return "vec4(" + TmpColors.Color4[0].r + ", " + TmpColors.Color4[0].g + ", " + TmpColors.Color4[0].b + ", " + TmpColors.Color4[0].a + ")";
    }
    return "";
  };
  Object.defineProperty(InputBlock2.prototype, "_noContextSwitch", {
    get: function() {
      return attributeInFragmentOnly[this.name];
    },
    enumerable: false,
    configurable: true
  });
  InputBlock2.prototype._emit = function(state, define) {
    var _a;
    if (this.isUniform) {
      if (!this.associatedVariableName) {
        this.associatedVariableName = state._getFreeVariableName("u_" + this.name);
      }
      if (this.isConstant) {
        if (state.constants.indexOf(this.associatedVariableName) !== -1) {
          return;
        }
        state.constants.push(this.associatedVariableName);
        state._constantDeclaration += this._declareOutput(this.output, state) + (" = " + this._emitConstant(state) + ";\r\n");
        return;
      }
      if (state.uniforms.indexOf(this.associatedVariableName) !== -1) {
        return;
      }
      state.uniforms.push(this.associatedVariableName);
      if (define) {
        state._uniformDeclaration += this._emitDefine(define);
      }
      state._uniformDeclaration += "uniform " + state._getGLType(this.type) + " " + this.associatedVariableName + ";\r\n";
      if (define) {
        state._uniformDeclaration += "#endif\r\n";
      }
      var hints = state.sharedData.hints;
      if (this._systemValue !== null && this._systemValue !== void 0) {
        switch (this._systemValue) {
          case NodeMaterialSystemValues.WorldView:
            hints.needWorldViewMatrix = true;
            break;
          case NodeMaterialSystemValues.WorldViewProjection:
            hints.needWorldViewProjectionMatrix = true;
            break;
        }
      } else {
        if (this._animationType !== AnimatedInputBlockTypes.None) {
          state.sharedData.animatedInputs.push(this);
        }
      }
      return;
    }
    if (this.isAttribute) {
      this.associatedVariableName = (_a = remapAttributeName[this.name]) !== null && _a !== void 0 ? _a : this.name;
      if (this.target === NodeMaterialBlockTargets.Vertex && state._vertexState) {
        if (attributeInFragmentOnly[this.name]) {
          if (attributeAsUniform[this.name]) {
            state._emitUniformFromString(this.associatedVariableName, state._getGLType(this.type), define);
          } else {
            state._emitVaryingFromString(this.associatedVariableName, state._getGLType(this.type), define);
          }
        } else {
          this._emit(state._vertexState, define);
        }
        return;
      }
      if (state.attributes.indexOf(this.associatedVariableName) !== -1) {
        return;
      }
      state.attributes.push(this.associatedVariableName);
      if (attributeInFragmentOnly[this.name]) {
        if (attributeAsUniform[this.name]) {
          state._emitUniformFromString(this.associatedVariableName, state._getGLType(this.type), define);
        } else {
          state._emitVaryingFromString(this.associatedVariableName, state._getGLType(this.type), define);
        }
      } else {
        if (define) {
          state._attributeDeclaration += this._emitDefine(define);
        }
        state._attributeDeclaration += "attribute " + state._getGLType(this.type) + " " + this.associatedVariableName + ";\r\n";
        if (define) {
          state._attributeDeclaration += "#endif\r\n";
        }
      }
    }
  };
  InputBlock2.prototype._transmitWorld = function(effect, world, worldView, worldViewProjection) {
    if (!this._systemValue) {
      return;
    }
    var variableName = this.associatedVariableName;
    switch (this._systemValue) {
      case NodeMaterialSystemValues.World:
        effect.setMatrix(variableName, world);
        break;
      case NodeMaterialSystemValues.WorldView:
        effect.setMatrix(variableName, worldView);
        break;
      case NodeMaterialSystemValues.WorldViewProjection:
        effect.setMatrix(variableName, worldViewProjection);
        break;
    }
  };
  InputBlock2.prototype._transmit = function(effect, scene) {
    if (this.isAttribute) {
      return;
    }
    var variableName = this.associatedVariableName;
    if (this._systemValue) {
      switch (this._systemValue) {
        case NodeMaterialSystemValues.World:
        case NodeMaterialSystemValues.WorldView:
        case NodeMaterialSystemValues.WorldViewProjection:
          return;
        case NodeMaterialSystemValues.View:
          effect.setMatrix(variableName, scene.getViewMatrix());
          break;
        case NodeMaterialSystemValues.Projection:
          effect.setMatrix(variableName, scene.getProjectionMatrix());
          break;
        case NodeMaterialSystemValues.ViewProjection:
          effect.setMatrix(variableName, scene.getTransformMatrix());
          break;
        case NodeMaterialSystemValues.CameraPosition:
          MaterialHelper.BindEyePosition(effect, scene, variableName);
          break;
        case NodeMaterialSystemValues.FogColor:
          effect.setColor3(variableName, scene.fogColor);
          break;
        case NodeMaterialSystemValues.DeltaTime:
          effect.setFloat(variableName, scene.deltaTime / 1e3);
      }
      return;
    }
    var value = this._valueCallback ? this._valueCallback() : this._storedValue;
    if (value === null) {
      return;
    }
    switch (this.type) {
      case NodeMaterialBlockConnectionPointTypes.Float:
        effect.setFloat(variableName, value);
        break;
      case NodeMaterialBlockConnectionPointTypes.Int:
        effect.setInt(variableName, value);
        break;
      case NodeMaterialBlockConnectionPointTypes.Color3:
        TmpColors.Color3[0].set(this.value.r, this.value.g, this.value.b);
        if (this.convertToGammaSpace) {
          TmpColors.Color3[0].toGammaSpaceToRef(TmpColors.Color3[0]);
        }
        if (this.convertToLinearSpace) {
          TmpColors.Color3[0].toLinearSpaceToRef(TmpColors.Color3[0]);
        }
        effect.setColor3(variableName, TmpColors.Color3[0]);
        break;
      case NodeMaterialBlockConnectionPointTypes.Color4:
        TmpColors.Color4[0].set(this.value.r, this.value.g, this.value.b, this.value.a);
        if (this.convertToGammaSpace) {
          TmpColors.Color4[0].toGammaSpaceToRef(TmpColors.Color4[0]);
        }
        if (this.convertToLinearSpace) {
          TmpColors.Color4[0].toLinearSpaceToRef(TmpColors.Color4[0]);
        }
        effect.setDirectColor4(variableName, TmpColors.Color4[0]);
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector2:
        effect.setVector2(variableName, value);
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector3:
        effect.setVector3(variableName, value);
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector4:
        effect.setVector4(variableName, value);
        break;
      case NodeMaterialBlockConnectionPointTypes.Matrix:
        effect.setMatrix(variableName, value);
        break;
    }
  };
  InputBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    if (this.isUniform || this.isSystemValue) {
      state.sharedData.inputBlocks.push(this);
    }
    this._emit(state);
  };
  InputBlock2.prototype._dumpPropertiesCode = function() {
    var variableName = this._codeVariableName;
    if (this.isAttribute) {
      return variableName + '.setAsAttribute("' + this.name + '");\r\n';
    }
    if (this.isSystemValue) {
      return variableName + ".setAsSystemValue(BABYLON.NodeMaterialSystemValues." + NodeMaterialSystemValues[this._systemValue] + ");\r\n";
    }
    if (this.isUniform) {
      var codes = [];
      var valueString = "";
      switch (this.type) {
        case NodeMaterialBlockConnectionPointTypes.Float:
          valueString = "" + this.value;
          break;
        case NodeMaterialBlockConnectionPointTypes.Vector2:
          valueString = "new BABYLON.Vector2(" + this.value.x + ", " + this.value.y + ")";
          break;
        case NodeMaterialBlockConnectionPointTypes.Vector3:
          valueString = "new BABYLON.Vector3(" + this.value.x + ", " + this.value.y + ", " + this.value.z + ")";
          break;
        case NodeMaterialBlockConnectionPointTypes.Vector4:
          valueString = "new BABYLON.Vector4(" + this.value.x + ", " + this.value.y + ", " + this.value.z + ", " + this.value.w + ")";
          break;
        case NodeMaterialBlockConnectionPointTypes.Color3:
          valueString = "new BABYLON.Color3(" + this.value.r + ", " + this.value.g + ", " + this.value.b + ")";
          if (this.convertToGammaSpace) {
            valueString += ".toGammaSpace()";
          }
          if (this.convertToLinearSpace) {
            valueString += ".toLinearSpace()";
          }
          break;
        case NodeMaterialBlockConnectionPointTypes.Color4:
          valueString = "new BABYLON.Color4(" + this.value.r + ", " + this.value.g + ", " + this.value.b + ", " + this.value.a + ")";
          if (this.convertToGammaSpace) {
            valueString += ".toGammaSpace()";
          }
          if (this.convertToLinearSpace) {
            valueString += ".toLinearSpace()";
          }
          break;
        case NodeMaterialBlockConnectionPointTypes.Matrix:
          valueString = "BABYLON.Matrix.FromArray([" + this.value.m + "])";
          break;
      }
      codes.push(variableName + ".value = " + valueString);
      if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {
        codes.push(variableName + ".min = " + this.min, variableName + ".max = " + this.max, variableName + ".isBoolean = " + this.isBoolean, variableName + ".matrixMode = " + this.matrixMode, variableName + ".animationType = BABYLON.AnimatedInputBlockTypes." + AnimatedInputBlockTypes[this.animationType]);
      }
      codes.push(variableName + ".isConstant = " + this.isConstant);
      codes.push("");
      return codes.join(";\r\n");
    }
    return "";
  };
  InputBlock2.prototype.dispose = function() {
    this.onValueChangedObservable.clear();
    _super.prototype.dispose.call(this);
  };
  InputBlock2.prototype.serialize = function() {
    var serializationObject = _super.prototype.serialize.call(this);
    serializationObject.type = this.type;
    serializationObject.mode = this._mode;
    serializationObject.systemValue = this._systemValue;
    serializationObject.animationType = this._animationType;
    serializationObject.min = this.min;
    serializationObject.max = this.max;
    serializationObject.isBoolean = this.isBoolean;
    serializationObject.matrixMode = this.matrixMode;
    serializationObject.isConstant = this.isConstant;
    serializationObject.groupInInspector = this.groupInInspector;
    serializationObject.convertToGammaSpace = this.convertToGammaSpace;
    serializationObject.convertToLinearSpace = this.convertToLinearSpace;
    if (this._storedValue != null && this._mode === NodeMaterialBlockConnectionPointMode.Uniform) {
      if (this._storedValue.asArray) {
        serializationObject.valueType = "BABYLON." + this._storedValue.getClassName();
        serializationObject.value = this._storedValue.asArray();
      } else {
        serializationObject.valueType = "number";
        serializationObject.value = this._storedValue;
      }
    }
    return serializationObject;
  };
  InputBlock2.prototype._deserialize = function(serializationObject, scene, rootUrl) {
    this._mode = serializationObject.mode;
    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);
    this._type = serializationObject.type;
    this._systemValue = serializationObject.systemValue || serializationObject.wellKnownValue;
    this._animationType = serializationObject.animationType;
    this.min = serializationObject.min || 0;
    this.max = serializationObject.max || 0;
    this.isBoolean = !!serializationObject.isBoolean;
    this.matrixMode = serializationObject.matrixMode || 0;
    this.isConstant = !!serializationObject.isConstant;
    this.groupInInspector = serializationObject.groupInInspector || "";
    this.convertToGammaSpace = !!serializationObject.convertToGammaSpace;
    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;
    if (!serializationObject.valueType) {
      return;
    }
    if (serializationObject.valueType === "number") {
      this._storedValue = serializationObject.value;
    } else {
      var valueType = _TypeStore.GetClass(serializationObject.valueType);
      if (valueType) {
        this._storedValue = valueType.FromArray(serializationObject.value);
      }
    }
  };
  return InputBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.InputBlock"] = InputBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/currentScreenBlock.js
var CurrentScreenBlock = function(_super) {
  __extends(CurrentScreenBlock2, _super);
  function CurrentScreenBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.VertexAndFragment) || this;
    _this._samplerName = "textureSampler";
    _this.convertToGammaSpace = false;
    _this.convertToLinearSpace = false;
    _this._isUnique = false;
    _this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.Vector2, false, NodeMaterialBlockTargets.VertexAndFragment);
    _this.registerOutput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);
    _this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);
    _this.registerOutput("r", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    _this.registerOutput("g", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    _this.registerOutput("b", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    _this.registerOutput("a", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);
    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector4);
    _this._inputs[0]._prioritizeVertex = false;
    return _this;
  }
  CurrentScreenBlock2.prototype.getClassName = function() {
    return "CurrentScreenBlock";
  };
  Object.defineProperty(CurrentScreenBlock2.prototype, "uv", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CurrentScreenBlock2.prototype, "rgba", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CurrentScreenBlock2.prototype, "rgb", {
    get: function() {
      return this._outputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CurrentScreenBlock2.prototype, "r", {
    get: function() {
      return this._outputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CurrentScreenBlock2.prototype, "g", {
    get: function() {
      return this._outputs[3];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CurrentScreenBlock2.prototype, "b", {
    get: function() {
      return this._outputs[4];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CurrentScreenBlock2.prototype, "a", {
    get: function() {
      return this._outputs[5];
    },
    enumerable: false,
    configurable: true
  });
  CurrentScreenBlock2.prototype.initialize = function(state) {
    state._excludeVariableName("textureSampler");
  };
  Object.defineProperty(CurrentScreenBlock2.prototype, "target", {
    get: function() {
      if (!this.uv.isConnected) {
        return NodeMaterialBlockTargets.VertexAndFragment;
      }
      if (this.uv.sourceBlock.isInput) {
        return NodeMaterialBlockTargets.VertexAndFragment;
      }
      return NodeMaterialBlockTargets.Fragment;
    },
    enumerable: false,
    configurable: true
  });
  CurrentScreenBlock2.prototype.prepareDefines = function(mesh, nodeMaterial, defines) {
    defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);
    defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);
  };
  CurrentScreenBlock2.prototype.isReady = function() {
    if (this.texture && !this.texture.isReadyOrNotBlocking()) {
      return false;
    }
    return true;
  };
  CurrentScreenBlock2.prototype._injectVertexCode = function(state) {
    var uvInput = this.uv;
    if (uvInput.connectedPoint.ownerBlock.isInput) {
      var uvInputOwnerBlock = uvInput.connectedPoint.ownerBlock;
      if (!uvInputOwnerBlock.isAttribute) {
        state._emitUniformFromString(uvInput.associatedVariableName, "vec2");
      }
    }
    this._mainUVName = "vMain" + uvInput.associatedVariableName;
    state._emitVaryingFromString(this._mainUVName, "vec2");
    state.compilationString += this._mainUVName + " = " + uvInput.associatedVariableName + ".xy;\r\n";
    if (!this._outputs.some(function(o) {
      return o.isConnectedInVertexShader;
    })) {
      return;
    }
    this._writeTextureRead(state, true);
    for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {
      var output = _a[_i];
      if (output.hasEndpoints) {
        this._writeOutput(state, output, output.name, true);
      }
    }
  };
  CurrentScreenBlock2.prototype._writeTextureRead = function(state, vertexMode) {
    if (vertexMode === void 0) {
      vertexMode = false;
    }
    var uvInput = this.uv;
    if (vertexMode) {
      if (state.target === NodeMaterialBlockTargets.Fragment) {
        return;
      }
      state.compilationString += "vec4 " + this._tempTextureRead + " = texture2D(" + this._samplerName + ", " + uvInput.associatedVariableName + ");\r\n";
      return;
    }
    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      state.compilationString += "vec4 " + this._tempTextureRead + " = texture2D(" + this._samplerName + ", " + uvInput.associatedVariableName + ");\r\n";
      return;
    }
    state.compilationString += "vec4 " + this._tempTextureRead + " = texture2D(" + this._samplerName + ", " + this._mainUVName + ");\r\n";
  };
  CurrentScreenBlock2.prototype._writeOutput = function(state, output, swizzle, vertexMode) {
    if (vertexMode === void 0) {
      vertexMode = false;
    }
    if (vertexMode) {
      if (state.target === NodeMaterialBlockTargets.Fragment) {
        return;
      }
      state.compilationString += this._declareOutput(output, state) + " = " + this._tempTextureRead + "." + swizzle + ";\r\n";
      return;
    }
    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      state.compilationString += this._declareOutput(output, state) + " = " + this._tempTextureRead + "." + swizzle + ";\r\n";
      return;
    }
    state.compilationString += this._declareOutput(output, state) + " = " + this._tempTextureRead + "." + swizzle + ";\r\n";
    state.compilationString += "#ifdef " + this._linearDefineName + "\r\n";
    state.compilationString += output.associatedVariableName + " = toGammaSpace(" + output.associatedVariableName + ");\r\n";
    state.compilationString += "#endif\r\n";
    state.compilationString += "#ifdef " + this._gammaDefineName + "\r\n";
    state.compilationString += output.associatedVariableName + " = toLinearSpace(" + output.associatedVariableName + ");\r\n";
    state.compilationString += "#endif\r\n";
  };
  CurrentScreenBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    this._tempTextureRead = state._getFreeVariableName("tempTextureRead");
    if (state.sharedData.blockingBlocks.indexOf(this) < 0) {
      state.sharedData.blockingBlocks.push(this);
    }
    if (state.sharedData.textureBlocks.indexOf(this) < 0) {
      state.sharedData.textureBlocks.push(this);
    }
    if (state.sharedData.blocksWithDefines.indexOf(this) < 0) {
      state.sharedData.blocksWithDefines.push(this);
    }
    if (state.target !== NodeMaterialBlockTargets.Fragment) {
      state._emit2DSampler(this._samplerName);
      this._injectVertexCode(state);
      return;
    }
    if (!this._outputs.some(function(o) {
      return o.isConnectedInFragmentShader;
    })) {
      return;
    }
    state._emit2DSampler(this._samplerName);
    this._linearDefineName = state._getFreeDefineName("ISLINEAR");
    this._gammaDefineName = state._getFreeDefineName("ISGAMMA");
    var comments = "//" + this.name;
    state._emitFunctionFromInclude("helperFunctions", comments);
    this._writeTextureRead(state);
    for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {
      var output = _a[_i];
      if (output.hasEndpoints) {
        this._writeOutput(state, output, output.name);
      }
    }
    return this;
  };
  CurrentScreenBlock2.prototype.serialize = function() {
    var serializationObject = _super.prototype.serialize.call(this);
    serializationObject.convertToGammaSpace = this.convertToGammaSpace;
    serializationObject.convertToLinearSpace = this.convertToLinearSpace;
    if (this.texture) {
      serializationObject.texture = this.texture.serialize();
    }
    return serializationObject;
  };
  CurrentScreenBlock2.prototype._deserialize = function(serializationObject, scene, rootUrl) {
    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);
    this.convertToGammaSpace = serializationObject.convertToGammaSpace;
    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;
    if (serializationObject.texture) {
      rootUrl = serializationObject.texture.url.indexOf("data:") === 0 ? "" : rootUrl;
      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);
    }
  };
  return CurrentScreenBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.CurrentScreenBlock"] = CurrentScreenBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/Particle/particleTextureBlock.js
var ParticleTextureBlock = function(_super) {
  __extends(ParticleTextureBlock2, _super);
  function ParticleTextureBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Fragment) || this;
    _this._samplerName = "diffuseSampler";
    _this.convertToGammaSpace = false;
    _this.convertToLinearSpace = false;
    _this._isUnique = false;
    _this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.Vector2, false, NodeMaterialBlockTargets.VertexAndFragment);
    _this.registerOutput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);
    _this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);
    _this.registerOutput("r", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    _this.registerOutput("g", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    _this.registerOutput("b", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    _this.registerOutput("a", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);
    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector4);
    return _this;
  }
  ParticleTextureBlock2.prototype.getClassName = function() {
    return "ParticleTextureBlock";
  };
  Object.defineProperty(ParticleTextureBlock2.prototype, "uv", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ParticleTextureBlock2.prototype, "rgba", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ParticleTextureBlock2.prototype, "rgb", {
    get: function() {
      return this._outputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ParticleTextureBlock2.prototype, "r", {
    get: function() {
      return this._outputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ParticleTextureBlock2.prototype, "g", {
    get: function() {
      return this._outputs[3];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ParticleTextureBlock2.prototype, "b", {
    get: function() {
      return this._outputs[4];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ParticleTextureBlock2.prototype, "a", {
    get: function() {
      return this._outputs[5];
    },
    enumerable: false,
    configurable: true
  });
  ParticleTextureBlock2.prototype.initialize = function(state) {
    state._excludeVariableName("diffuseSampler");
  };
  ParticleTextureBlock2.prototype.autoConfigure = function(material) {
    if (!this.uv.isConnected) {
      var uvInput = material.getInputBlockByPredicate(function(b) {
        return b.isAttribute && b.name === "particle_uv";
      });
      if (!uvInput) {
        uvInput = new InputBlock("uv");
        uvInput.setAsAttribute("particle_uv");
      }
      uvInput.output.connectTo(this.uv);
    }
  };
  ParticleTextureBlock2.prototype.prepareDefines = function(mesh, nodeMaterial, defines) {
    defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);
    defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);
  };
  ParticleTextureBlock2.prototype.isReady = function() {
    if (this.texture && !this.texture.isReadyOrNotBlocking()) {
      return false;
    }
    return true;
  };
  ParticleTextureBlock2.prototype._writeOutput = function(state, output, swizzle) {
    state.compilationString += this._declareOutput(output, state) + " = " + this._tempTextureRead + "." + swizzle + ";\r\n";
    state.compilationString += "#ifdef " + this._linearDefineName + "\r\n";
    state.compilationString += output.associatedVariableName + " = toGammaSpace(" + output.associatedVariableName + ");\r\n";
    state.compilationString += "#endif\r\n";
    state.compilationString += "#ifdef " + this._gammaDefineName + "\r\n";
    state.compilationString += output.associatedVariableName + " = toLinearSpace(" + output.associatedVariableName + ");\r\n";
    state.compilationString += "#endif\r\n";
  };
  ParticleTextureBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      return;
    }
    this._tempTextureRead = state._getFreeVariableName("tempTextureRead");
    state._emit2DSampler(this._samplerName);
    state.sharedData.blockingBlocks.push(this);
    state.sharedData.textureBlocks.push(this);
    state.sharedData.blocksWithDefines.push(this);
    this._linearDefineName = state._getFreeDefineName("ISLINEAR");
    this._gammaDefineName = state._getFreeDefineName("ISGAMMA");
    var comments = "//" + this.name;
    state._emitFunctionFromInclude("helperFunctions", comments);
    state.compilationString += "vec4 " + this._tempTextureRead + " = texture2D(" + this._samplerName + ", " + this.uv.associatedVariableName + ");\r\n";
    for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {
      var output = _a[_i];
      if (output.hasEndpoints) {
        this._writeOutput(state, output, output.name);
      }
    }
    return this;
  };
  ParticleTextureBlock2.prototype.serialize = function() {
    var serializationObject = _super.prototype.serialize.call(this);
    serializationObject.convertToGammaSpace = this.convertToGammaSpace;
    serializationObject.convertToLinearSpace = this.convertToLinearSpace;
    if (this.texture) {
      serializationObject.texture = this.texture.serialize();
    }
    return serializationObject;
  };
  ParticleTextureBlock2.prototype._deserialize = function(serializationObject, scene, rootUrl) {
    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);
    this.convertToGammaSpace = serializationObject.convertToGammaSpace;
    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;
    if (serializationObject.texture) {
      rootUrl = serializationObject.texture.url.indexOf("data:") === 0 ? "" : rootUrl;
      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);
    }
  };
  return ParticleTextureBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.ParticleTextureBlock"] = ParticleTextureBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/Particle/particleRampGradientBlock.js
var ParticleRampGradientBlock = function(_super) {
  __extends(ParticleRampGradientBlock2, _super);
  function ParticleRampGradientBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Fragment) || this;
    _this._isUnique = true;
    _this.registerInput("color", NodeMaterialBlockConnectionPointTypes.Color4, false, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("rampColor", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);
    return _this;
  }
  ParticleRampGradientBlock2.prototype.getClassName = function() {
    return "ParticleRampGradientBlock";
  };
  Object.defineProperty(ParticleRampGradientBlock2.prototype, "color", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ParticleRampGradientBlock2.prototype, "rampColor", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  ParticleRampGradientBlock2.prototype.initialize = function(state) {
    state._excludeVariableName("remapRanges");
    state._excludeVariableName("rampSampler");
    state._excludeVariableName("baseColor");
    state._excludeVariableName("alpha");
    state._excludeVariableName("remappedColorIndex");
    state._excludeVariableName("rampColor");
    state._excludeVariableName("finalAlpha");
  };
  ParticleRampGradientBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      return;
    }
    state._emit2DSampler("rampSampler");
    state._emitVaryingFromString("remapRanges", "vec4", "RAMPGRADIENT");
    state.compilationString += "\n            #ifdef RAMPGRADIENT\n                vec4 baseColor = " + this.color.associatedVariableName + ";\n                float alpha = " + this.color.associatedVariableName + ".a;\n\n                float remappedColorIndex = clamp((alpha - remapRanges.x) / remapRanges.y, 0.0, 1.0);\n\n                vec4 rampColor = texture2D(rampSampler, vec2(1.0 - remappedColorIndex, 0.));\n                baseColor.rgb *= rampColor.rgb;\n\n                // Remapped alpha\n                float finalAlpha = baseColor.a;\n                baseColor.a = clamp((alpha * rampColor.a - remapRanges.z) / remapRanges.w, 0.0, 1.0);\n\n                " + this._declareOutput(this.rampColor, state) + " = baseColor;\n            #else\n                " + this._declareOutput(this.rampColor, state) + " = " + this.color.associatedVariableName + ";\n            #endif\n        ";
    return this;
  };
  return ParticleRampGradientBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.ParticleRampGradientBlock"] = ParticleRampGradientBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/Particle/particleBlendMultiplyBlock.js
var ParticleBlendMultiplyBlock = function(_super) {
  __extends(ParticleBlendMultiplyBlock2, _super);
  function ParticleBlendMultiplyBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Fragment) || this;
    _this._isUnique = true;
    _this.registerInput("color", NodeMaterialBlockConnectionPointTypes.Color4, false, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("alphaTexture", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("alphaColor", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("blendColor", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);
    return _this;
  }
  ParticleBlendMultiplyBlock2.prototype.getClassName = function() {
    return "ParticleBlendMultiplyBlock";
  };
  Object.defineProperty(ParticleBlendMultiplyBlock2.prototype, "color", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ParticleBlendMultiplyBlock2.prototype, "alphaTexture", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ParticleBlendMultiplyBlock2.prototype, "alphaColor", {
    get: function() {
      return this._inputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ParticleBlendMultiplyBlock2.prototype, "blendColor", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  ParticleBlendMultiplyBlock2.prototype.initialize = function(state) {
    state._excludeVariableName("sourceAlpha");
  };
  ParticleBlendMultiplyBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      return;
    }
    state.compilationString += "\n            #ifdef BLENDMULTIPLYMODE\n                " + this._declareOutput(this.blendColor, state) + ";\n                float sourceAlpha = " + this.alphaColor.associatedVariableName + " * " + this.alphaTexture.associatedVariableName + ";\n                " + this.blendColor.associatedVariableName + ".rgb = " + this.color.associatedVariableName + ".rgb * sourceAlpha + vec3(1.0) * (1.0 - sourceAlpha);\n                " + this.blendColor.associatedVariableName + ".a = " + this.color.associatedVariableName + ".a;\n            #else\n                " + this._declareOutput(this.blendColor, state) + " = " + this.color.associatedVariableName + ";\n            #endif\n        ";
    return this;
  };
  return ParticleBlendMultiplyBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.ParticleBlendMultiplyBlock"] = ParticleBlendMultiplyBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/vectorMergerBlock.js
var VectorMergerBlock = function(_super) {
  __extends(VectorMergerBlock2, _super);
  function VectorMergerBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("xyz ", NodeMaterialBlockConnectionPointTypes.Vector3, true);
    _this.registerInput("xy ", NodeMaterialBlockConnectionPointTypes.Vector2, true);
    _this.registerInput("x", NodeMaterialBlockConnectionPointTypes.Float, true);
    _this.registerInput("y", NodeMaterialBlockConnectionPointTypes.Float, true);
    _this.registerInput("z", NodeMaterialBlockConnectionPointTypes.Float, true);
    _this.registerInput("w", NodeMaterialBlockConnectionPointTypes.Float, true);
    _this.registerOutput("xyzw", NodeMaterialBlockConnectionPointTypes.Vector4);
    _this.registerOutput("xyz", NodeMaterialBlockConnectionPointTypes.Vector3);
    _this.registerOutput("xy", NodeMaterialBlockConnectionPointTypes.Vector2);
    return _this;
  }
  VectorMergerBlock2.prototype.getClassName = function() {
    return "VectorMergerBlock";
  };
  Object.defineProperty(VectorMergerBlock2.prototype, "xyzIn", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VectorMergerBlock2.prototype, "xyIn", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VectorMergerBlock2.prototype, "x", {
    get: function() {
      return this._inputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VectorMergerBlock2.prototype, "y", {
    get: function() {
      return this._inputs[3];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VectorMergerBlock2.prototype, "z", {
    get: function() {
      return this._inputs[4];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VectorMergerBlock2.prototype, "w", {
    get: function() {
      return this._inputs[5];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VectorMergerBlock2.prototype, "xyzw", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VectorMergerBlock2.prototype, "xyzOut", {
    get: function() {
      return this._outputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VectorMergerBlock2.prototype, "xyOut", {
    get: function() {
      return this._outputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VectorMergerBlock2.prototype, "xy", {
    get: function() {
      return this.xyOut;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VectorMergerBlock2.prototype, "xyz", {
    get: function() {
      return this.xyzOut;
    },
    enumerable: false,
    configurable: true
  });
  VectorMergerBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var xInput = this.x;
    var yInput = this.y;
    var zInput = this.z;
    var wInput = this.w;
    var xyInput = this.xyIn;
    var xyzInput = this.xyzIn;
    var v4Output = this._outputs[0];
    var v3Output = this._outputs[1];
    var v2Output = this._outputs[2];
    if (xyzInput.isConnected) {
      if (v4Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v4Output, state) + (" = vec4(" + xyzInput.associatedVariableName + ", " + (wInput.isConnected ? this._writeVariable(wInput) : "0.0") + ");\r\n");
      } else if (v3Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v3Output, state) + (" = " + xyzInput.associatedVariableName + ";\r\n");
      } else if (v2Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v2Output, state) + (" = " + xyzInput.associatedVariableName + ".xy;\r\n");
      }
    } else if (xyInput.isConnected) {
      if (v4Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v4Output, state) + (" = vec4(" + xyInput.associatedVariableName + ", " + (zInput.isConnected ? this._writeVariable(zInput) : "0.0") + ", " + (wInput.isConnected ? this._writeVariable(wInput) : "0.0") + ");\r\n");
      } else if (v3Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v3Output, state) + (" = vec3(" + xyInput.associatedVariableName + ", " + (zInput.isConnected ? this._writeVariable(zInput) : "0.0") + ");\r\n");
      } else if (v2Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v2Output, state) + (" = " + xyInput.associatedVariableName + ";\r\n");
      }
    } else {
      if (v4Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v4Output, state) + (" = vec4(" + (xInput.isConnected ? this._writeVariable(xInput) : "0.0") + ", " + (yInput.isConnected ? this._writeVariable(yInput) : "0.0") + ", " + (zInput.isConnected ? this._writeVariable(zInput) : "0.0") + ", " + (wInput.isConnected ? this._writeVariable(wInput) : "0.0") + ");\r\n");
      } else if (v3Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v3Output, state) + (" = vec3(" + (xInput.isConnected ? this._writeVariable(xInput) : "0.0") + ", " + (yInput.isConnected ? this._writeVariable(yInput) : "0.0") + ", " + (zInput.isConnected ? this._writeVariable(zInput) : "0.0") + ");\r\n");
      } else if (v2Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v2Output, state) + (" = vec2(" + (xInput.isConnected ? this._writeVariable(xInput) : "0.0") + ", " + (yInput.isConnected ? this._writeVariable(yInput) : "0.0") + ");\r\n");
      }
    }
    return this;
  };
  return VectorMergerBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.VectorMergerBlock"] = VectorMergerBlock;

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialDecorator.js
var PropertyTypeForEdition;
(function(PropertyTypeForEdition2) {
  PropertyTypeForEdition2[PropertyTypeForEdition2["Boolean"] = 0] = "Boolean";
  PropertyTypeForEdition2[PropertyTypeForEdition2["Float"] = 1] = "Float";
  PropertyTypeForEdition2[PropertyTypeForEdition2["Vector2"] = 2] = "Vector2";
  PropertyTypeForEdition2[PropertyTypeForEdition2["List"] = 3] = "List";
})(PropertyTypeForEdition || (PropertyTypeForEdition = {}));
function editableInPropertyPage(displayName, propertyType, groupName, options) {
  if (propertyType === void 0) {
    propertyType = PropertyTypeForEdition.Boolean;
  }
  if (groupName === void 0) {
    groupName = "PROPERTIES";
  }
  return function(target, propertyKey) {
    var propStore = target._propStore;
    if (!propStore) {
      propStore = [];
      target._propStore = propStore;
    }
    propStore.push({
      "propertyName": propertyKey,
      "displayName": displayName,
      "type": propertyType,
      "groupName": groupName,
      "options": options !== null && options !== void 0 ? options : {}
    });
  };
}

// node_modules/@babylonjs/core/Materials/Node/Blocks/remapBlock.js
var RemapBlock = function(_super) {
  __extends(RemapBlock2, _super);
  function RemapBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.sourceRange = new Vector2(-1, 1);
    _this.targetRange = new Vector2(0, 1);
    _this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerInput("sourceMin", NodeMaterialBlockConnectionPointTypes.Float, true);
    _this.registerInput("sourceMax", NodeMaterialBlockConnectionPointTypes.Float, true);
    _this.registerInput("targetMin", NodeMaterialBlockConnectionPointTypes.Float, true);
    _this.registerInput("targetMax", NodeMaterialBlockConnectionPointTypes.Float, true);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    _this._outputs[0]._typeConnectionSource = _this._inputs[0];
    return _this;
  }
  RemapBlock2.prototype.getClassName = function() {
    return "RemapBlock";
  };
  Object.defineProperty(RemapBlock2.prototype, "input", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RemapBlock2.prototype, "sourceMin", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RemapBlock2.prototype, "sourceMax", {
    get: function() {
      return this._inputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RemapBlock2.prototype, "targetMin", {
    get: function() {
      return this._inputs[3];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RemapBlock2.prototype, "targetMax", {
    get: function() {
      return this._inputs[4];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RemapBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  RemapBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    var sourceMin = this.sourceMin.isConnected ? this.sourceMin.associatedVariableName : this._writeFloat(this.sourceRange.x);
    var sourceMax = this.sourceMax.isConnected ? this.sourceMax.associatedVariableName : this._writeFloat(this.sourceRange.y);
    var targetMin = this.targetMin.isConnected ? this.targetMin.associatedVariableName : this._writeFloat(this.targetRange.x);
    var targetMax = this.targetMax.isConnected ? this.targetMax.associatedVariableName : this._writeFloat(this.targetRange.y);
    state.compilationString += this._declareOutput(output, state) + (" = " + targetMin + " + (" + this._inputs[0].associatedVariableName + " - " + sourceMin + ") * (" + targetMax + " - " + targetMin + ") / (" + sourceMax + " - " + sourceMin + ");\r\n");
    return this;
  };
  RemapBlock2.prototype._dumpPropertiesCode = function() {
    var codeString = this._codeVariableName + ".sourceRange = new BABYLON.Vector2(" + this.sourceRange.x + ", " + this.sourceRange.y + ");\r\n";
    codeString += this._codeVariableName + ".targetRange = new BABYLON.Vector2(" + this.targetRange.x + ", " + this.targetRange.y + ");\r\n";
    return codeString;
  };
  RemapBlock2.prototype.serialize = function() {
    var serializationObject = _super.prototype.serialize.call(this);
    serializationObject.sourceRange = this.sourceRange.asArray();
    serializationObject.targetRange = this.targetRange.asArray();
    return serializationObject;
  };
  RemapBlock2.prototype._deserialize = function(serializationObject, scene, rootUrl) {
    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);
    this.sourceRange = Vector2.FromArray(serializationObject.sourceRange);
    this.targetRange = Vector2.FromArray(serializationObject.targetRange);
  };
  __decorate([
    editableInPropertyPage("From", PropertyTypeForEdition.Vector2)
  ], RemapBlock2.prototype, "sourceRange", void 0);
  __decorate([
    editableInPropertyPage("To", PropertyTypeForEdition.Vector2)
  ], RemapBlock2.prototype, "targetRange", void 0);
  return RemapBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.RemapBlock"] = RemapBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/multiplyBlock.js
var MultiplyBlock = function(_super) {
  __extends(MultiplyBlock2, _super);
  function MultiplyBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    _this._outputs[0]._typeConnectionSource = _this._inputs[0];
    _this._linkConnectionTypes(0, 1);
    return _this;
  }
  MultiplyBlock2.prototype.getClassName = function() {
    return "MultiplyBlock";
  };
  Object.defineProperty(MultiplyBlock2.prototype, "left", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MultiplyBlock2.prototype, "right", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MultiplyBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  MultiplyBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + (" = " + this.left.associatedVariableName + " * " + this.right.associatedVariableName + ";\r\n");
    return this;
  };
  return MultiplyBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.MultiplyBlock"] = MultiplyBlock;

// node_modules/@babylonjs/core/Particles/EmitterTypes/boxParticleEmitter.js
var BoxParticleEmitter = function() {
  function BoxParticleEmitter2() {
    this.direction1 = new Vector3(0, 1, 0);
    this.direction2 = new Vector3(0, 1, 0);
    this.minEmitBox = new Vector3(-0.5, -0.5, -0.5);
    this.maxEmitBox = new Vector3(0.5, 0.5, 0.5);
  }
  BoxParticleEmitter2.prototype.startDirectionFunction = function(worldMatrix, directionToUpdate, particle, isLocal) {
    var randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);
    var randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);
    var randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);
    if (isLocal) {
      directionToUpdate.x = randX;
      directionToUpdate.y = randY;
      directionToUpdate.z = randZ;
      return;
    }
    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
  };
  BoxParticleEmitter2.prototype.startPositionFunction = function(worldMatrix, positionToUpdate, particle, isLocal) {
    var randX = Scalar.RandomRange(this.minEmitBox.x, this.maxEmitBox.x);
    var randY = Scalar.RandomRange(this.minEmitBox.y, this.maxEmitBox.y);
    var randZ = Scalar.RandomRange(this.minEmitBox.z, this.maxEmitBox.z);
    if (isLocal) {
      positionToUpdate.x = randX;
      positionToUpdate.y = randY;
      positionToUpdate.z = randZ;
      return;
    }
    Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);
  };
  BoxParticleEmitter2.prototype.clone = function() {
    var newOne = new BoxParticleEmitter2();
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  };
  BoxParticleEmitter2.prototype.applyToShader = function(effect) {
    effect.setVector3("direction1", this.direction1);
    effect.setVector3("direction2", this.direction2);
    effect.setVector3("minEmitBox", this.minEmitBox);
    effect.setVector3("maxEmitBox", this.maxEmitBox);
  };
  BoxParticleEmitter2.prototype.getEffectDefines = function() {
    return "#define BOXEMITTER";
  };
  BoxParticleEmitter2.prototype.getClassName = function() {
    return "BoxParticleEmitter";
  };
  BoxParticleEmitter2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.type = this.getClassName();
    serializationObject.direction1 = this.direction1.asArray();
    serializationObject.direction2 = this.direction2.asArray();
    serializationObject.minEmitBox = this.minEmitBox.asArray();
    serializationObject.maxEmitBox = this.maxEmitBox.asArray();
    return serializationObject;
  };
  BoxParticleEmitter2.prototype.parse = function(serializationObject) {
    Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);
    Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);
    Vector3.FromArrayToRef(serializationObject.minEmitBox, 0, this.minEmitBox);
    Vector3.FromArrayToRef(serializationObject.maxEmitBox, 0, this.maxEmitBox);
  };
  return BoxParticleEmitter2;
}();

// node_modules/@babylonjs/core/Particles/EmitterTypes/coneParticleEmitter.js
var ConeParticleEmitter = function() {
  function ConeParticleEmitter2(radius, angle, directionRandomizer) {
    if (radius === void 0) {
      radius = 1;
    }
    if (angle === void 0) {
      angle = Math.PI;
    }
    if (directionRandomizer === void 0) {
      directionRandomizer = 0;
    }
    this.directionRandomizer = directionRandomizer;
    this.radiusRange = 1;
    this.heightRange = 1;
    this.emitFromSpawnPointOnly = false;
    this.angle = angle;
    this.radius = radius;
  }
  Object.defineProperty(ConeParticleEmitter2.prototype, "radius", {
    get: function() {
      return this._radius;
    },
    set: function(value) {
      this._radius = value;
      this._buildHeight();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ConeParticleEmitter2.prototype, "angle", {
    get: function() {
      return this._angle;
    },
    set: function(value) {
      this._angle = value;
      this._buildHeight();
    },
    enumerable: false,
    configurable: true
  });
  ConeParticleEmitter2.prototype._buildHeight = function() {
    if (this._angle !== 0) {
      this._height = this._radius / Math.tan(this._angle / 2);
    } else {
      this._height = 1;
    }
  };
  ConeParticleEmitter2.prototype.startDirectionFunction = function(worldMatrix, directionToUpdate, particle, isLocal) {
    if (isLocal) {
      TmpVectors.Vector3[0].copyFrom(particle._localPosition).normalize();
    } else {
      particle.position.subtractToRef(worldMatrix.getTranslation(), TmpVectors.Vector3[0]).normalize();
    }
    var randX = Scalar.RandomRange(0, this.directionRandomizer);
    var randY = Scalar.RandomRange(0, this.directionRandomizer);
    var randZ = Scalar.RandomRange(0, this.directionRandomizer);
    directionToUpdate.x = TmpVectors.Vector3[0].x + randX;
    directionToUpdate.y = TmpVectors.Vector3[0].y + randY;
    directionToUpdate.z = TmpVectors.Vector3[0].z + randZ;
    directionToUpdate.normalize();
  };
  ConeParticleEmitter2.prototype.startPositionFunction = function(worldMatrix, positionToUpdate, particle, isLocal) {
    var s = Scalar.RandomRange(0, Math.PI * 2);
    var h;
    if (!this.emitFromSpawnPointOnly) {
      h = Scalar.RandomRange(0, this.heightRange);
      h = 1 - h * h;
    } else {
      h = 1e-4;
    }
    var radius = this._radius - Scalar.RandomRange(0, this._radius * this.radiusRange);
    radius = radius * h;
    var randX = radius * Math.sin(s);
    var randZ = radius * Math.cos(s);
    var randY = h * this._height;
    if (isLocal) {
      positionToUpdate.x = randX;
      positionToUpdate.y = randY;
      positionToUpdate.z = randZ;
      return;
    }
    Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);
  };
  ConeParticleEmitter2.prototype.clone = function() {
    var newOne = new ConeParticleEmitter2(this._radius, this._angle, this.directionRandomizer);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  };
  ConeParticleEmitter2.prototype.applyToShader = function(effect) {
    effect.setFloat2("radius", this._radius, this.radiusRange);
    effect.setFloat("coneAngle", this._angle);
    effect.setFloat2("height", this._height, this.heightRange);
    effect.setFloat("directionRandomizer", this.directionRandomizer);
  };
  ConeParticleEmitter2.prototype.getEffectDefines = function() {
    var defines = "#define CONEEMITTER";
    if (this.emitFromSpawnPointOnly) {
      defines += "\n#define CONEEMITTERSPAWNPOINT";
    }
    return defines;
  };
  ConeParticleEmitter2.prototype.getClassName = function() {
    return "ConeParticleEmitter";
  };
  ConeParticleEmitter2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.type = this.getClassName();
    serializationObject.radius = this._radius;
    serializationObject.angle = this._angle;
    serializationObject.directionRandomizer = this.directionRandomizer;
    serializationObject.radiusRange = this.radiusRange;
    serializationObject.heightRange = this.heightRange;
    serializationObject.emitFromSpawnPointOnly = this.emitFromSpawnPointOnly;
    return serializationObject;
  };
  ConeParticleEmitter2.prototype.parse = function(serializationObject) {
    this.radius = serializationObject.radius;
    this.angle = serializationObject.angle;
    this.directionRandomizer = serializationObject.directionRandomizer;
    this.radiusRange = serializationObject.radiusRange !== void 0 ? serializationObject.radiusRange : 1;
    this.heightRange = serializationObject.radiusRange !== void 0 ? serializationObject.heightRange : 1;
    this.emitFromSpawnPointOnly = serializationObject.emitFromSpawnPointOnly !== void 0 ? serializationObject.emitFromSpawnPointOnly : false;
  };
  return ConeParticleEmitter2;
}();

// node_modules/@babylonjs/core/Particles/EmitterTypes/cylinderParticleEmitter.js
var CylinderParticleEmitter = function() {
  function CylinderParticleEmitter2(radius, height, radiusRange, directionRandomizer) {
    if (radius === void 0) {
      radius = 1;
    }
    if (height === void 0) {
      height = 1;
    }
    if (radiusRange === void 0) {
      radiusRange = 1;
    }
    if (directionRandomizer === void 0) {
      directionRandomizer = 0;
    }
    this.radius = radius;
    this.height = height;
    this.radiusRange = radiusRange;
    this.directionRandomizer = directionRandomizer;
  }
  CylinderParticleEmitter2.prototype.startDirectionFunction = function(worldMatrix, directionToUpdate, particle, isLocal) {
    var direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();
    var randY = Scalar.RandomRange(-this.directionRandomizer / 2, this.directionRandomizer / 2);
    var angle = Math.atan2(direction.x, direction.z);
    angle += Scalar.RandomRange(-Math.PI / 2, Math.PI / 2) * this.directionRandomizer;
    direction.y = randY;
    direction.x = Math.sin(angle);
    direction.z = Math.cos(angle);
    direction.normalize();
    if (isLocal) {
      directionToUpdate.copyFrom(direction);
      return;
    }
    Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);
  };
  CylinderParticleEmitter2.prototype.startPositionFunction = function(worldMatrix, positionToUpdate, particle, isLocal) {
    var yPos = Scalar.RandomRange(-this.height / 2, this.height / 2);
    var angle = Scalar.RandomRange(0, 2 * Math.PI);
    var radiusDistribution = Scalar.RandomRange((1 - this.radiusRange) * (1 - this.radiusRange), 1);
    var positionRadius = Math.sqrt(radiusDistribution) * this.radius;
    var xPos = positionRadius * Math.cos(angle);
    var zPos = positionRadius * Math.sin(angle);
    if (isLocal) {
      positionToUpdate.copyFromFloats(xPos, yPos, zPos);
      return;
    }
    Vector3.TransformCoordinatesFromFloatsToRef(xPos, yPos, zPos, worldMatrix, positionToUpdate);
  };
  CylinderParticleEmitter2.prototype.clone = function() {
    var newOne = new CylinderParticleEmitter2(this.radius, this.directionRandomizer);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  };
  CylinderParticleEmitter2.prototype.applyToShader = function(effect) {
    effect.setFloat("radius", this.radius);
    effect.setFloat("height", this.height);
    effect.setFloat("radiusRange", this.radiusRange);
    effect.setFloat("directionRandomizer", this.directionRandomizer);
  };
  CylinderParticleEmitter2.prototype.getEffectDefines = function() {
    return "#define CYLINDEREMITTER";
  };
  CylinderParticleEmitter2.prototype.getClassName = function() {
    return "CylinderParticleEmitter";
  };
  CylinderParticleEmitter2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.type = this.getClassName();
    serializationObject.radius = this.radius;
    serializationObject.height = this.height;
    serializationObject.radiusRange = this.radiusRange;
    serializationObject.directionRandomizer = this.directionRandomizer;
    return serializationObject;
  };
  CylinderParticleEmitter2.prototype.parse = function(serializationObject) {
    this.radius = serializationObject.radius;
    this.height = serializationObject.height;
    this.radiusRange = serializationObject.radiusRange;
    this.directionRandomizer = serializationObject.directionRandomizer;
  };
  return CylinderParticleEmitter2;
}();
var CylinderDirectedParticleEmitter = function(_super) {
  __extends(CylinderDirectedParticleEmitter2, _super);
  function CylinderDirectedParticleEmitter2(radius, height, radiusRange, direction1, direction2) {
    if (radius === void 0) {
      radius = 1;
    }
    if (height === void 0) {
      height = 1;
    }
    if (radiusRange === void 0) {
      radiusRange = 1;
    }
    if (direction1 === void 0) {
      direction1 = new Vector3(0, 1, 0);
    }
    if (direction2 === void 0) {
      direction2 = new Vector3(0, 1, 0);
    }
    var _this = _super.call(this, radius, height, radiusRange) || this;
    _this.direction1 = direction1;
    _this.direction2 = direction2;
    return _this;
  }
  CylinderDirectedParticleEmitter2.prototype.startDirectionFunction = function(worldMatrix, directionToUpdate, particle) {
    var randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);
    var randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);
    var randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);
    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
  };
  CylinderDirectedParticleEmitter2.prototype.clone = function() {
    var newOne = new CylinderDirectedParticleEmitter2(this.radius, this.height, this.radiusRange, this.direction1, this.direction2);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  };
  CylinderDirectedParticleEmitter2.prototype.applyToShader = function(effect) {
    effect.setFloat("radius", this.radius);
    effect.setFloat("height", this.height);
    effect.setFloat("radiusRange", this.radiusRange);
    effect.setVector3("direction1", this.direction1);
    effect.setVector3("direction2", this.direction2);
  };
  CylinderDirectedParticleEmitter2.prototype.getEffectDefines = function() {
    return "#define CYLINDEREMITTER\n#define DIRECTEDCYLINDEREMITTER";
  };
  CylinderDirectedParticleEmitter2.prototype.getClassName = function() {
    return "CylinderDirectedParticleEmitter";
  };
  CylinderDirectedParticleEmitter2.prototype.serialize = function() {
    var serializationObject = _super.prototype.serialize.call(this);
    serializationObject.direction1 = this.direction1.asArray();
    serializationObject.direction2 = this.direction2.asArray();
    return serializationObject;
  };
  CylinderDirectedParticleEmitter2.prototype.parse = function(serializationObject) {
    _super.prototype.parse.call(this, serializationObject);
    this.direction1.copyFrom(serializationObject.direction1);
    this.direction2.copyFrom(serializationObject.direction2);
  };
  return CylinderDirectedParticleEmitter2;
}(CylinderParticleEmitter);

// node_modules/@babylonjs/core/Particles/EmitterTypes/hemisphericParticleEmitter.js
var HemisphericParticleEmitter = function() {
  function HemisphericParticleEmitter2(radius, radiusRange, directionRandomizer) {
    if (radius === void 0) {
      radius = 1;
    }
    if (radiusRange === void 0) {
      radiusRange = 1;
    }
    if (directionRandomizer === void 0) {
      directionRandomizer = 0;
    }
    this.radius = radius;
    this.radiusRange = radiusRange;
    this.directionRandomizer = directionRandomizer;
  }
  HemisphericParticleEmitter2.prototype.startDirectionFunction = function(worldMatrix, directionToUpdate, particle, isLocal) {
    var direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();
    var randX = Scalar.RandomRange(0, this.directionRandomizer);
    var randY = Scalar.RandomRange(0, this.directionRandomizer);
    var randZ = Scalar.RandomRange(0, this.directionRandomizer);
    direction.x += randX;
    direction.y += randY;
    direction.z += randZ;
    direction.normalize();
    if (isLocal) {
      directionToUpdate.copyFrom(direction);
      return;
    }
    Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);
  };
  HemisphericParticleEmitter2.prototype.startPositionFunction = function(worldMatrix, positionToUpdate, particle, isLocal) {
    var randRadius = this.radius - Scalar.RandomRange(0, this.radius * this.radiusRange);
    var v = Scalar.RandomRange(0, 1);
    var phi = Scalar.RandomRange(0, 2 * Math.PI);
    var theta = Math.acos(2 * v - 1);
    var randX = randRadius * Math.cos(phi) * Math.sin(theta);
    var randY = randRadius * Math.cos(theta);
    var randZ = randRadius * Math.sin(phi) * Math.sin(theta);
    if (isLocal) {
      positionToUpdate.copyFromFloats(randX, Math.abs(randY), randZ);
      return;
    }
    Vector3.TransformCoordinatesFromFloatsToRef(randX, Math.abs(randY), randZ, worldMatrix, positionToUpdate);
  };
  HemisphericParticleEmitter2.prototype.clone = function() {
    var newOne = new HemisphericParticleEmitter2(this.radius, this.directionRandomizer);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  };
  HemisphericParticleEmitter2.prototype.applyToShader = function(effect) {
    effect.setFloat("radius", this.radius);
    effect.setFloat("radiusRange", this.radiusRange);
    effect.setFloat("directionRandomizer", this.directionRandomizer);
  };
  HemisphericParticleEmitter2.prototype.getEffectDefines = function() {
    return "#define HEMISPHERICEMITTER";
  };
  HemisphericParticleEmitter2.prototype.getClassName = function() {
    return "HemisphericParticleEmitter";
  };
  HemisphericParticleEmitter2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.type = this.getClassName();
    serializationObject.radius = this.radius;
    serializationObject.radiusRange = this.radiusRange;
    serializationObject.directionRandomizer = this.directionRandomizer;
    return serializationObject;
  };
  HemisphericParticleEmitter2.prototype.parse = function(serializationObject) {
    this.radius = serializationObject.radius;
    this.radiusRange = serializationObject.radiusRange;
    this.directionRandomizer = serializationObject.directionRandomizer;
  };
  return HemisphericParticleEmitter2;
}();

// node_modules/@babylonjs/core/Particles/EmitterTypes/pointParticleEmitter.js
var PointParticleEmitter = function() {
  function PointParticleEmitter2() {
    this.direction1 = new Vector3(0, 1, 0);
    this.direction2 = new Vector3(0, 1, 0);
  }
  PointParticleEmitter2.prototype.startDirectionFunction = function(worldMatrix, directionToUpdate, particle, isLocal) {
    var randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);
    var randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);
    var randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);
    if (isLocal) {
      directionToUpdate.copyFromFloats(randX, randY, randZ);
      return;
    }
    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
  };
  PointParticleEmitter2.prototype.startPositionFunction = function(worldMatrix, positionToUpdate, particle, isLocal) {
    if (isLocal) {
      positionToUpdate.copyFromFloats(0, 0, 0);
      return;
    }
    Vector3.TransformCoordinatesFromFloatsToRef(0, 0, 0, worldMatrix, positionToUpdate);
  };
  PointParticleEmitter2.prototype.clone = function() {
    var newOne = new PointParticleEmitter2();
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  };
  PointParticleEmitter2.prototype.applyToShader = function(effect) {
    effect.setVector3("direction1", this.direction1);
    effect.setVector3("direction2", this.direction2);
  };
  PointParticleEmitter2.prototype.getEffectDefines = function() {
    return "#define POINTEMITTER";
  };
  PointParticleEmitter2.prototype.getClassName = function() {
    return "PointParticleEmitter";
  };
  PointParticleEmitter2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.type = this.getClassName();
    serializationObject.direction1 = this.direction1.asArray();
    serializationObject.direction2 = this.direction2.asArray();
    return serializationObject;
  };
  PointParticleEmitter2.prototype.parse = function(serializationObject) {
    Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);
    Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);
  };
  return PointParticleEmitter2;
}();

// node_modules/@babylonjs/core/Particles/EmitterTypes/sphereParticleEmitter.js
var SphereParticleEmitter = function() {
  function SphereParticleEmitter2(radius, radiusRange, directionRandomizer) {
    if (radius === void 0) {
      radius = 1;
    }
    if (radiusRange === void 0) {
      radiusRange = 1;
    }
    if (directionRandomizer === void 0) {
      directionRandomizer = 0;
    }
    this.radius = radius;
    this.radiusRange = radiusRange;
    this.directionRandomizer = directionRandomizer;
  }
  SphereParticleEmitter2.prototype.startDirectionFunction = function(worldMatrix, directionToUpdate, particle, isLocal) {
    var direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();
    var randX = Scalar.RandomRange(0, this.directionRandomizer);
    var randY = Scalar.RandomRange(0, this.directionRandomizer);
    var randZ = Scalar.RandomRange(0, this.directionRandomizer);
    direction.x += randX;
    direction.y += randY;
    direction.z += randZ;
    direction.normalize();
    if (isLocal) {
      directionToUpdate.copyFrom(direction);
      return;
    }
    Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);
  };
  SphereParticleEmitter2.prototype.startPositionFunction = function(worldMatrix, positionToUpdate, particle, isLocal) {
    var randRadius = this.radius - Scalar.RandomRange(0, this.radius * this.radiusRange);
    var v = Scalar.RandomRange(0, 1);
    var phi = Scalar.RandomRange(0, 2 * Math.PI);
    var theta = Math.acos(2 * v - 1);
    var randX = randRadius * Math.cos(phi) * Math.sin(theta);
    var randY = randRadius * Math.cos(theta);
    var randZ = randRadius * Math.sin(phi) * Math.sin(theta);
    if (isLocal) {
      positionToUpdate.copyFromFloats(randX, randY, randZ);
      return;
    }
    Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);
  };
  SphereParticleEmitter2.prototype.clone = function() {
    var newOne = new SphereParticleEmitter2(this.radius, this.directionRandomizer);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  };
  SphereParticleEmitter2.prototype.applyToShader = function(effect) {
    effect.setFloat("radius", this.radius);
    effect.setFloat("radiusRange", this.radiusRange);
    effect.setFloat("directionRandomizer", this.directionRandomizer);
  };
  SphereParticleEmitter2.prototype.getEffectDefines = function() {
    return "#define SPHEREEMITTER";
  };
  SphereParticleEmitter2.prototype.getClassName = function() {
    return "SphereParticleEmitter";
  };
  SphereParticleEmitter2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.type = this.getClassName();
    serializationObject.radius = this.radius;
    serializationObject.radiusRange = this.radiusRange;
    serializationObject.directionRandomizer = this.directionRandomizer;
    return serializationObject;
  };
  SphereParticleEmitter2.prototype.parse = function(serializationObject) {
    this.radius = serializationObject.radius;
    this.radiusRange = serializationObject.radiusRange;
    this.directionRandomizer = serializationObject.directionRandomizer;
  };
  return SphereParticleEmitter2;
}();
var SphereDirectedParticleEmitter = function(_super) {
  __extends(SphereDirectedParticleEmitter2, _super);
  function SphereDirectedParticleEmitter2(radius, direction1, direction2) {
    if (radius === void 0) {
      radius = 1;
    }
    if (direction1 === void 0) {
      direction1 = new Vector3(0, 1, 0);
    }
    if (direction2 === void 0) {
      direction2 = new Vector3(0, 1, 0);
    }
    var _this = _super.call(this, radius) || this;
    _this.direction1 = direction1;
    _this.direction2 = direction2;
    return _this;
  }
  SphereDirectedParticleEmitter2.prototype.startDirectionFunction = function(worldMatrix, directionToUpdate, particle) {
    var randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);
    var randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);
    var randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);
    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
  };
  SphereDirectedParticleEmitter2.prototype.clone = function() {
    var newOne = new SphereDirectedParticleEmitter2(this.radius, this.direction1, this.direction2);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  };
  SphereDirectedParticleEmitter2.prototype.applyToShader = function(effect) {
    effect.setFloat("radius", this.radius);
    effect.setFloat("radiusRange", this.radiusRange);
    effect.setVector3("direction1", this.direction1);
    effect.setVector3("direction2", this.direction2);
  };
  SphereDirectedParticleEmitter2.prototype.getEffectDefines = function() {
    return "#define SPHEREEMITTER\n#define DIRECTEDSPHEREEMITTER";
  };
  SphereDirectedParticleEmitter2.prototype.getClassName = function() {
    return "SphereDirectedParticleEmitter";
  };
  SphereDirectedParticleEmitter2.prototype.serialize = function() {
    var serializationObject = _super.prototype.serialize.call(this);
    serializationObject.direction1 = this.direction1.asArray();
    serializationObject.direction2 = this.direction2.asArray();
    return serializationObject;
  };
  SphereDirectedParticleEmitter2.prototype.parse = function(serializationObject) {
    _super.prototype.parse.call(this, serializationObject);
    this.direction1.copyFrom(serializationObject.direction1);
    this.direction2.copyFrom(serializationObject.direction2);
  };
  return SphereDirectedParticleEmitter2;
}(SphereParticleEmitter);

// node_modules/@babylonjs/core/Particles/EmitterTypes/customParticleEmitter.js
var CustomParticleEmitter = function() {
  function CustomParticleEmitter2() {
    this.particlePositionGenerator = function() {
    };
    this.particleDestinationGenerator = function() {
    };
  }
  CustomParticleEmitter2.prototype.startDirectionFunction = function(worldMatrix, directionToUpdate, particle, isLocal) {
    var tmpVector = TmpVectors.Vector3[0];
    if (this.particleDestinationGenerator) {
      this.particleDestinationGenerator(-1, particle, tmpVector);
      var diffVector = TmpVectors.Vector3[1];
      tmpVector.subtractToRef(particle.position, diffVector);
      diffVector.scaleToRef(1 / particle.lifeTime, tmpVector);
    } else {
      tmpVector.set(0, 0, 0);
    }
    if (isLocal) {
      directionToUpdate.copyFrom(tmpVector);
      return;
    }
    Vector3.TransformNormalToRef(tmpVector, worldMatrix, directionToUpdate);
  };
  CustomParticleEmitter2.prototype.startPositionFunction = function(worldMatrix, positionToUpdate, particle, isLocal) {
    var tmpVector = TmpVectors.Vector3[0];
    if (this.particlePositionGenerator) {
      this.particlePositionGenerator(-1, particle, tmpVector);
    } else {
      tmpVector.set(0, 0, 0);
    }
    if (isLocal) {
      positionToUpdate.copyFrom(tmpVector);
      return;
    }
    Vector3.TransformCoordinatesToRef(tmpVector, worldMatrix, positionToUpdate);
  };
  CustomParticleEmitter2.prototype.clone = function() {
    var newOne = new CustomParticleEmitter2();
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  };
  CustomParticleEmitter2.prototype.applyToShader = function(effect) {
  };
  CustomParticleEmitter2.prototype.getEffectDefines = function() {
    return "#define CUSTOMEMITTER";
  };
  CustomParticleEmitter2.prototype.getClassName = function() {
    return "CustomParticleEmitter";
  };
  CustomParticleEmitter2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.type = this.getClassName();
    return serializationObject;
  };
  CustomParticleEmitter2.prototype.parse = function(serializationObject) {
  };
  return CustomParticleEmitter2;
}();

// node_modules/@babylonjs/core/Particles/EmitterTypes/meshParticleEmitter.js
var MeshParticleEmitter = function() {
  function MeshParticleEmitter2(mesh) {
    if (mesh === void 0) {
      mesh = null;
    }
    this._indices = null;
    this._positions = null;
    this._normals = null;
    this._storedNormal = Vector3.Zero();
    this._mesh = null;
    this.direction1 = new Vector3(0, 1, 0);
    this.direction2 = new Vector3(0, 1, 0);
    this.useMeshNormalsForDirection = true;
    this.mesh = mesh;
  }
  Object.defineProperty(MeshParticleEmitter2.prototype, "mesh", {
    get: function() {
      return this._mesh;
    },
    set: function(value) {
      if (this._mesh === value) {
        return;
      }
      this._mesh = value;
      if (value) {
        this._indices = value.getIndices();
        this._positions = value.getVerticesData(VertexBuffer.PositionKind);
        this._normals = value.getVerticesData(VertexBuffer.NormalKind);
      } else {
        this._indices = null;
        this._positions = null;
        this._normals = null;
      }
    },
    enumerable: false,
    configurable: true
  });
  MeshParticleEmitter2.prototype.startDirectionFunction = function(worldMatrix, directionToUpdate, particle, isLocal) {
    if (this.useMeshNormalsForDirection && this._normals) {
      Vector3.TransformNormalToRef(this._storedNormal, worldMatrix, directionToUpdate);
      return;
    }
    var randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);
    var randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);
    var randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);
    if (isLocal) {
      directionToUpdate.copyFromFloats(randX, randY, randZ);
      return;
    }
    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
  };
  MeshParticleEmitter2.prototype.startPositionFunction = function(worldMatrix, positionToUpdate, particle, isLocal) {
    if (!this._indices || !this._positions) {
      return;
    }
    var randomFaceIndex = 3 * Math.random() * (this._indices.length / 3) | 0;
    var bu = Math.random();
    var bv = Math.random() * (1 - bu);
    var bw = 1 - bu - bv;
    var faceIndexA = this._indices[randomFaceIndex];
    var faceIndexB = this._indices[randomFaceIndex + 1];
    var faceIndexC = this._indices[randomFaceIndex + 2];
    var vertexA = TmpVectors.Vector3[0];
    var vertexB = TmpVectors.Vector3[1];
    var vertexC = TmpVectors.Vector3[2];
    var randomVertex = TmpVectors.Vector3[3];
    Vector3.FromArrayToRef(this._positions, faceIndexA * 3, vertexA);
    Vector3.FromArrayToRef(this._positions, faceIndexB * 3, vertexB);
    Vector3.FromArrayToRef(this._positions, faceIndexC * 3, vertexC);
    randomVertex.x = bu * vertexA.x + bv * vertexB.x + bw * vertexC.x;
    randomVertex.y = bu * vertexA.y + bv * vertexB.y + bw * vertexC.y;
    randomVertex.z = bu * vertexA.z + bv * vertexB.z + bw * vertexC.z;
    if (isLocal) {
      positionToUpdate.copyFromFloats(randomVertex.x, randomVertex.y, randomVertex.z);
    } else {
      Vector3.TransformCoordinatesFromFloatsToRef(randomVertex.x, randomVertex.y, randomVertex.z, worldMatrix, positionToUpdate);
    }
    if (this.useMeshNormalsForDirection && this._normals) {
      Vector3.FromArrayToRef(this._normals, faceIndexA * 3, vertexA);
      Vector3.FromArrayToRef(this._normals, faceIndexB * 3, vertexB);
      Vector3.FromArrayToRef(this._normals, faceIndexC * 3, vertexC);
      this._storedNormal.x = bu * vertexA.x + bv * vertexB.x + bw * vertexC.x;
      this._storedNormal.y = bu * vertexA.y + bv * vertexB.y + bw * vertexC.y;
      this._storedNormal.z = bu * vertexA.z + bv * vertexB.z + bw * vertexC.z;
    }
  };
  MeshParticleEmitter2.prototype.clone = function() {
    var newOne = new MeshParticleEmitter2(this.mesh);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  };
  MeshParticleEmitter2.prototype.applyToShader = function(effect) {
    effect.setVector3("direction1", this.direction1);
    effect.setVector3("direction2", this.direction2);
  };
  MeshParticleEmitter2.prototype.getEffectDefines = function() {
    return "";
  };
  MeshParticleEmitter2.prototype.getClassName = function() {
    return "MeshParticleEmitter";
  };
  MeshParticleEmitter2.prototype.serialize = function() {
    var _a;
    var serializationObject = {};
    serializationObject.type = this.getClassName();
    serializationObject.direction1 = this.direction1.asArray();
    serializationObject.direction2 = this.direction2.asArray();
    serializationObject.meshId = (_a = this.mesh) === null || _a === void 0 ? void 0 : _a.id;
    serializationObject.useMeshNormalsForDirection = this.useMeshNormalsForDirection;
    return serializationObject;
  };
  MeshParticleEmitter2.prototype.parse = function(serializationObject, scene) {
    Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);
    Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);
    if (serializationObject.meshId && scene) {
      this.mesh = scene.getLastMeshByID(serializationObject.meshId);
    }
    this.useMeshNormalsForDirection = serializationObject.useMeshNormalsForDirection;
  };
  return MeshParticleEmitter2;
}();

// node_modules/@babylonjs/core/Particles/baseParticleSystem.js
var BaseParticleSystem = function() {
  function BaseParticleSystem2(name98) {
    this.animations = [];
    this.renderingGroupId = 0;
    this.emitter = Vector3.Zero();
    this.emitRate = 10;
    this.manualEmitCount = -1;
    this.updateSpeed = 0.01;
    this.targetStopDuration = 0;
    this.disposeOnStop = false;
    this.minEmitPower = 1;
    this.maxEmitPower = 1;
    this.minLifeTime = 1;
    this.maxLifeTime = 1;
    this.minSize = 1;
    this.maxSize = 1;
    this.minScaleX = 1;
    this.maxScaleX = 1;
    this.minScaleY = 1;
    this.maxScaleY = 1;
    this.minInitialRotation = 0;
    this.maxInitialRotation = 0;
    this.minAngularSpeed = 0;
    this.maxAngularSpeed = 0;
    this.layerMask = 268435455;
    this.customShader = null;
    this.preventAutoStart = false;
    this.noiseStrength = new Vector3(10, 10, 10);
    this.onAnimationEnd = null;
    this.blendMode = BaseParticleSystem2.BLENDMODE_ONEONE;
    this.forceDepthWrite = false;
    this.preWarmCycles = 0;
    this.preWarmStepOffset = 1;
    this.spriteCellChangeSpeed = 1;
    this.startSpriteCellID = 0;
    this.endSpriteCellID = 0;
    this.spriteCellWidth = 0;
    this.spriteCellHeight = 0;
    this.spriteRandomStartCell = false;
    this.translationPivot = new Vector2(0, 0);
    this.beginAnimationOnStart = false;
    this.beginAnimationFrom = 0;
    this.beginAnimationTo = 60;
    this.beginAnimationLoop = false;
    this.worldOffset = new Vector3(0, 0, 0);
    this.gravity = Vector3.Zero();
    this._colorGradients = null;
    this._sizeGradients = null;
    this._lifeTimeGradients = null;
    this._angularSpeedGradients = null;
    this._velocityGradients = null;
    this._limitVelocityGradients = null;
    this._dragGradients = null;
    this._emitRateGradients = null;
    this._startSizeGradients = null;
    this._rampGradients = null;
    this._colorRemapGradients = null;
    this._alphaRemapGradients = null;
    this.startDelay = 0;
    this.limitVelocityDamping = 0.4;
    this.color1 = new Color4(1, 1, 1, 1);
    this.color2 = new Color4(1, 1, 1, 1);
    this.colorDead = new Color4(0, 0, 0, 1);
    this.textureMask = new Color4(1, 1, 1, 1);
    this._isSubEmitter = false;
    this.billboardMode = 7;
    this._isBillboardBased = true;
    this._imageProcessingConfigurationDefines = new ImageProcessingConfigurationDefines();
    this.id = name98;
    this.name = name98;
  }
  Object.defineProperty(BaseParticleSystem2.prototype, "noiseTexture", {
    get: function() {
      return this._noiseTexture;
    },
    set: function(value) {
      if (this._noiseTexture === value) {
        return;
      }
      this._noiseTexture = value;
      this._reset();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseParticleSystem2.prototype, "isAnimationSheetEnabled", {
    get: function() {
      return this._isAnimationSheetEnabled;
    },
    set: function(value) {
      if (this._isAnimationSheetEnabled == value) {
        return;
      }
      this._isAnimationSheetEnabled = value;
      this._reset();
    },
    enumerable: false,
    configurable: true
  });
  BaseParticleSystem2.prototype.getScene = function() {
    return this._scene;
  };
  BaseParticleSystem2.prototype._hasTargetStopDurationDependantGradient = function() {
    return this._startSizeGradients && this._startSizeGradients.length > 0 || this._emitRateGradients && this._emitRateGradients.length > 0 || this._lifeTimeGradients && this._lifeTimeGradients.length > 0;
  };
  BaseParticleSystem2.prototype.getDragGradients = function() {
    return this._dragGradients;
  };
  BaseParticleSystem2.prototype.getLimitVelocityGradients = function() {
    return this._limitVelocityGradients;
  };
  BaseParticleSystem2.prototype.getColorGradients = function() {
    return this._colorGradients;
  };
  BaseParticleSystem2.prototype.getSizeGradients = function() {
    return this._sizeGradients;
  };
  BaseParticleSystem2.prototype.getColorRemapGradients = function() {
    return this._colorRemapGradients;
  };
  BaseParticleSystem2.prototype.getAlphaRemapGradients = function() {
    return this._alphaRemapGradients;
  };
  BaseParticleSystem2.prototype.getLifeTimeGradients = function() {
    return this._lifeTimeGradients;
  };
  BaseParticleSystem2.prototype.getAngularSpeedGradients = function() {
    return this._angularSpeedGradients;
  };
  BaseParticleSystem2.prototype.getVelocityGradients = function() {
    return this._velocityGradients;
  };
  BaseParticleSystem2.prototype.getStartSizeGradients = function() {
    return this._startSizeGradients;
  };
  BaseParticleSystem2.prototype.getEmitRateGradients = function() {
    return this._emitRateGradients;
  };
  Object.defineProperty(BaseParticleSystem2.prototype, "direction1", {
    get: function() {
      if (this.particleEmitterType.direction1) {
        return this.particleEmitterType.direction1;
      }
      return Vector3.Zero();
    },
    set: function(value) {
      if (this.particleEmitterType.direction1) {
        this.particleEmitterType.direction1 = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseParticleSystem2.prototype, "direction2", {
    get: function() {
      if (this.particleEmitterType.direction2) {
        return this.particleEmitterType.direction2;
      }
      return Vector3.Zero();
    },
    set: function(value) {
      if (this.particleEmitterType.direction2) {
        this.particleEmitterType.direction2 = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseParticleSystem2.prototype, "minEmitBox", {
    get: function() {
      if (this.particleEmitterType.minEmitBox) {
        return this.particleEmitterType.minEmitBox;
      }
      return Vector3.Zero();
    },
    set: function(value) {
      if (this.particleEmitterType.minEmitBox) {
        this.particleEmitterType.minEmitBox = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseParticleSystem2.prototype, "maxEmitBox", {
    get: function() {
      if (this.particleEmitterType.maxEmitBox) {
        return this.particleEmitterType.maxEmitBox;
      }
      return Vector3.Zero();
    },
    set: function(value) {
      if (this.particleEmitterType.maxEmitBox) {
        this.particleEmitterType.maxEmitBox = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseParticleSystem2.prototype, "isBillboardBased", {
    get: function() {
      return this._isBillboardBased;
    },
    set: function(value) {
      if (this._isBillboardBased === value) {
        return;
      }
      this._isBillboardBased = value;
      this._reset();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseParticleSystem2.prototype, "imageProcessingConfiguration", {
    get: function() {
      return this._imageProcessingConfiguration;
    },
    set: function(value) {
      this._attachImageProcessingConfiguration(value);
    },
    enumerable: false,
    configurable: true
  });
  BaseParticleSystem2.prototype._attachImageProcessingConfiguration = function(configuration) {
    if (configuration === this._imageProcessingConfiguration) {
      return;
    }
    if (!configuration && this._scene) {
      this._imageProcessingConfiguration = this._scene.imageProcessingConfiguration;
    } else {
      this._imageProcessingConfiguration = configuration;
    }
  };
  BaseParticleSystem2.prototype._reset = function() {
  };
  BaseParticleSystem2.prototype._removeGradientAndTexture = function(gradient, gradients, texture) {
    if (!gradients) {
      return this;
    }
    var index = 0;
    for (var _i = 0, gradients_1 = gradients; _i < gradients_1.length; _i++) {
      var valueGradient = gradients_1[_i];
      if (valueGradient.gradient === gradient) {
        gradients.splice(index, 1);
        break;
      }
      index++;
    }
    if (texture) {
      texture.dispose();
    }
    return this;
  };
  BaseParticleSystem2.prototype.createPointEmitter = function(direction1, direction2) {
    var particleEmitter = new PointParticleEmitter();
    particleEmitter.direction1 = direction1;
    particleEmitter.direction2 = direction2;
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  };
  BaseParticleSystem2.prototype.createHemisphericEmitter = function(radius, radiusRange) {
    if (radius === void 0) {
      radius = 1;
    }
    if (radiusRange === void 0) {
      radiusRange = 1;
    }
    var particleEmitter = new HemisphericParticleEmitter(radius, radiusRange);
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  };
  BaseParticleSystem2.prototype.createSphereEmitter = function(radius, radiusRange) {
    if (radius === void 0) {
      radius = 1;
    }
    if (radiusRange === void 0) {
      radiusRange = 1;
    }
    var particleEmitter = new SphereParticleEmitter(radius, radiusRange);
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  };
  BaseParticleSystem2.prototype.createDirectedSphereEmitter = function(radius, direction1, direction2) {
    if (radius === void 0) {
      radius = 1;
    }
    if (direction1 === void 0) {
      direction1 = new Vector3(0, 1, 0);
    }
    if (direction2 === void 0) {
      direction2 = new Vector3(0, 1, 0);
    }
    var particleEmitter = new SphereDirectedParticleEmitter(radius, direction1, direction2);
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  };
  BaseParticleSystem2.prototype.createCylinderEmitter = function(radius, height, radiusRange, directionRandomizer) {
    if (radius === void 0) {
      radius = 1;
    }
    if (height === void 0) {
      height = 1;
    }
    if (radiusRange === void 0) {
      radiusRange = 1;
    }
    if (directionRandomizer === void 0) {
      directionRandomizer = 0;
    }
    var particleEmitter = new CylinderParticleEmitter(radius, height, radiusRange, directionRandomizer);
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  };
  BaseParticleSystem2.prototype.createDirectedCylinderEmitter = function(radius, height, radiusRange, direction1, direction2) {
    if (radius === void 0) {
      radius = 1;
    }
    if (height === void 0) {
      height = 1;
    }
    if (radiusRange === void 0) {
      radiusRange = 1;
    }
    if (direction1 === void 0) {
      direction1 = new Vector3(0, 1, 0);
    }
    if (direction2 === void 0) {
      direction2 = new Vector3(0, 1, 0);
    }
    var particleEmitter = new CylinderDirectedParticleEmitter(radius, height, radiusRange, direction1, direction2);
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  };
  BaseParticleSystem2.prototype.createConeEmitter = function(radius, angle) {
    if (radius === void 0) {
      radius = 1;
    }
    if (angle === void 0) {
      angle = Math.PI / 4;
    }
    var particleEmitter = new ConeParticleEmitter(radius, angle);
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  };
  BaseParticleSystem2.prototype.createBoxEmitter = function(direction1, direction2, minEmitBox, maxEmitBox) {
    var particleEmitter = new BoxParticleEmitter();
    this.particleEmitterType = particleEmitter;
    this.direction1 = direction1;
    this.direction2 = direction2;
    this.minEmitBox = minEmitBox;
    this.maxEmitBox = maxEmitBox;
    return particleEmitter;
  };
  BaseParticleSystem2.BLENDMODE_ONEONE = 0;
  BaseParticleSystem2.BLENDMODE_STANDARD = 1;
  BaseParticleSystem2.BLENDMODE_ADD = 2;
  BaseParticleSystem2.BLENDMODE_MULTIPLY = 3;
  BaseParticleSystem2.BLENDMODE_MULTIPLYADD = 4;
  return BaseParticleSystem2;
}();

// node_modules/@babylonjs/core/Materials/Node/Blocks/colorSplitterBlock.js
var ColorSplitterBlock = function(_super) {
  __extends(ColorSplitterBlock2, _super);
  function ColorSplitterBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, true);
    _this.registerInput("rgb ", NodeMaterialBlockConnectionPointTypes.Color3, true);
    _this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3);
    _this.registerOutput("r", NodeMaterialBlockConnectionPointTypes.Float);
    _this.registerOutput("g", NodeMaterialBlockConnectionPointTypes.Float);
    _this.registerOutput("b", NodeMaterialBlockConnectionPointTypes.Float);
    _this.registerOutput("a", NodeMaterialBlockConnectionPointTypes.Float);
    _this.inputsAreExclusive = true;
    return _this;
  }
  ColorSplitterBlock2.prototype.getClassName = function() {
    return "ColorSplitterBlock";
  };
  Object.defineProperty(ColorSplitterBlock2.prototype, "rgba", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorSplitterBlock2.prototype, "rgbIn", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorSplitterBlock2.prototype, "rgbOut", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorSplitterBlock2.prototype, "r", {
    get: function() {
      return this._outputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorSplitterBlock2.prototype, "g", {
    get: function() {
      return this._outputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorSplitterBlock2.prototype, "b", {
    get: function() {
      return this._outputs[3];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorSplitterBlock2.prototype, "a", {
    get: function() {
      return this._outputs[4];
    },
    enumerable: false,
    configurable: true
  });
  ColorSplitterBlock2.prototype._inputRename = function(name98) {
    if (name98 === "rgb ") {
      return "rgbIn";
    }
    return name98;
  };
  ColorSplitterBlock2.prototype._outputRename = function(name98) {
    if (name98 === "rgb") {
      return "rgbOut";
    }
    return name98;
  };
  ColorSplitterBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var input = this.rgba.isConnected ? this.rgba : this.rgbIn;
    if (!input.isConnected) {
      return;
    }
    var rgbOutput = this._outputs[0];
    var rOutput = this._outputs[1];
    var gOutput = this._outputs[2];
    var bOutput = this._outputs[3];
    var aOutput = this._outputs[4];
    if (rgbOutput.hasEndpoints) {
      state.compilationString += this._declareOutput(rgbOutput, state) + (" = " + input.associatedVariableName + ".rgb;\r\n");
    }
    if (rOutput.hasEndpoints) {
      state.compilationString += this._declareOutput(rOutput, state) + (" = " + input.associatedVariableName + ".r;\r\n");
    }
    if (gOutput.hasEndpoints) {
      state.compilationString += this._declareOutput(gOutput, state) + (" = " + input.associatedVariableName + ".g;\r\n");
    }
    if (bOutput.hasEndpoints) {
      state.compilationString += this._declareOutput(bOutput, state) + (" = " + input.associatedVariableName + ".b;\r\n");
    }
    if (aOutput.hasEndpoints) {
      state.compilationString += this._declareOutput(aOutput, state) + (" = " + input.associatedVariableName + ".a;\r\n");
    }
    return this;
  };
  return ColorSplitterBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.ColorSplitterBlock"] = ColorSplitterBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/trigonometryBlock.js
var TrigonometryBlockOperations;
(function(TrigonometryBlockOperations2) {
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Cos"] = 0] = "Cos";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Sin"] = 1] = "Sin";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Abs"] = 2] = "Abs";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Exp"] = 3] = "Exp";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Exp2"] = 4] = "Exp2";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Round"] = 5] = "Round";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Floor"] = 6] = "Floor";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Ceiling"] = 7] = "Ceiling";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Sqrt"] = 8] = "Sqrt";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Log"] = 9] = "Log";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Tan"] = 10] = "Tan";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["ArcTan"] = 11] = "ArcTan";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["ArcCos"] = 12] = "ArcCos";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["ArcSin"] = 13] = "ArcSin";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Fract"] = 14] = "Fract";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Sign"] = 15] = "Sign";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Radians"] = 16] = "Radians";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Degrees"] = 17] = "Degrees";
})(TrigonometryBlockOperations || (TrigonometryBlockOperations = {}));
var TrigonometryBlock = function(_super) {
  __extends(TrigonometryBlock2, _super);
  function TrigonometryBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.operation = TrigonometryBlockOperations.Cos;
    _this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    _this._outputs[0]._typeConnectionSource = _this._inputs[0];
    return _this;
  }
  TrigonometryBlock2.prototype.getClassName = function() {
    return "TrigonometryBlock";
  };
  Object.defineProperty(TrigonometryBlock2.prototype, "input", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TrigonometryBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  TrigonometryBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    var operation = "";
    switch (this.operation) {
      case TrigonometryBlockOperations.Cos: {
        operation = "cos";
        break;
      }
      case TrigonometryBlockOperations.Sin: {
        operation = "sin";
        break;
      }
      case TrigonometryBlockOperations.Abs: {
        operation = "abs";
        break;
      }
      case TrigonometryBlockOperations.Exp: {
        operation = "exp";
        break;
      }
      case TrigonometryBlockOperations.Exp2: {
        operation = "exp2";
        break;
      }
      case TrigonometryBlockOperations.Round: {
        operation = "round";
        break;
      }
      case TrigonometryBlockOperations.Floor: {
        operation = "floor";
        break;
      }
      case TrigonometryBlockOperations.Ceiling: {
        operation = "ceil";
        break;
      }
      case TrigonometryBlockOperations.Sqrt: {
        operation = "sqrt";
        break;
      }
      case TrigonometryBlockOperations.Log: {
        operation = "log";
        break;
      }
      case TrigonometryBlockOperations.Tan: {
        operation = "tan";
        break;
      }
      case TrigonometryBlockOperations.ArcTan: {
        operation = "atan";
        break;
      }
      case TrigonometryBlockOperations.ArcCos: {
        operation = "acos";
        break;
      }
      case TrigonometryBlockOperations.ArcSin: {
        operation = "asin";
        break;
      }
      case TrigonometryBlockOperations.Fract: {
        operation = "fract";
        break;
      }
      case TrigonometryBlockOperations.Sign: {
        operation = "sign";
        break;
      }
      case TrigonometryBlockOperations.Radians: {
        operation = "radians";
        break;
      }
      case TrigonometryBlockOperations.Degrees: {
        operation = "degrees";
        break;
      }
    }
    state.compilationString += this._declareOutput(output, state) + (" = " + operation + "(" + this.input.associatedVariableName + ");\r\n");
    return this;
  };
  TrigonometryBlock2.prototype.serialize = function() {
    var serializationObject = _super.prototype.serialize.call(this);
    serializationObject.operation = this.operation;
    return serializationObject;
  };
  TrigonometryBlock2.prototype._deserialize = function(serializationObject, scene, rootUrl) {
    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);
    this.operation = serializationObject.operation;
  };
  TrigonometryBlock2.prototype._dumpPropertiesCode = function() {
    var codeString = this._codeVariableName + ".operation = BABYLON.TrigonometryBlockOperations." + TrigonometryBlockOperations[this.operation] + ";\r\n";
    return codeString;
  };
  return TrigonometryBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.TrigonometryBlock"] = TrigonometryBlock;

// node_modules/@babylonjs/core/Materials/Node/nodeMaterial.js
var onCreatedEffectParameters = { effect: null, subMesh: null };
var NodeMaterialDefines = function(_super) {
  __extends(NodeMaterialDefines2, _super);
  function NodeMaterialDefines2() {
    var _this = _super.call(this) || this;
    _this.NORMAL = false;
    _this.TANGENT = false;
    _this.UV1 = false;
    _this.NUM_BONE_INFLUENCERS = 0;
    _this.BonesPerMesh = 0;
    _this.BONETEXTURE = false;
    _this.MORPHTARGETS = false;
    _this.MORPHTARGETS_NORMAL = false;
    _this.MORPHTARGETS_TANGENT = false;
    _this.MORPHTARGETS_UV = false;
    _this.NUM_MORPH_INFLUENCERS = 0;
    _this.IMAGEPROCESSING = false;
    _this.VIGNETTE = false;
    _this.VIGNETTEBLENDMODEMULTIPLY = false;
    _this.VIGNETTEBLENDMODEOPAQUE = false;
    _this.TONEMAPPING = false;
    _this.TONEMAPPING_ACES = false;
    _this.CONTRAST = false;
    _this.EXPOSURE = false;
    _this.COLORCURVES = false;
    _this.COLORGRADING = false;
    _this.COLORGRADING3D = false;
    _this.SAMPLER3DGREENDEPTH = false;
    _this.SAMPLER3DBGRMAP = false;
    _this.IMAGEPROCESSINGPOSTPROCESS = false;
    _this.BUMPDIRECTUV = 0;
    _this.rebuild();
    return _this;
  }
  NodeMaterialDefines2.prototype.setValue = function(name98, value, markAsUnprocessedIfDirty) {
    if (markAsUnprocessedIfDirty === void 0) {
      markAsUnprocessedIfDirty = false;
    }
    if (this[name98] === void 0) {
      this._keys.push(name98);
    }
    if (markAsUnprocessedIfDirty && this[name98] !== value) {
      this.markAsUnprocessed();
    }
    this[name98] = value;
  };
  return NodeMaterialDefines2;
}(MaterialDefines);
var NodeMaterial = function(_super) {
  __extends(NodeMaterial2, _super);
  function NodeMaterial2(name98, scene, options) {
    if (options === void 0) {
      options = {};
    }
    var _this = _super.call(this, name98, scene || Engine.LastCreatedScene) || this;
    _this._buildId = NodeMaterial2._BuildIdGenerator++;
    _this._buildWasSuccessful = false;
    _this._cachedWorldViewMatrix = new Matrix();
    _this._cachedWorldViewProjectionMatrix = new Matrix();
    _this._optimizers = new Array();
    _this._animationFrame = -1;
    _this.BJSNODEMATERIALEDITOR = _this._getGlobalNodeMaterialEditor();
    _this.editorData = null;
    _this.ignoreAlpha = false;
    _this.maxSimultaneousLights = 4;
    _this.onBuildObservable = new Observable();
    _this._vertexOutputNodes = new Array();
    _this._fragmentOutputNodes = new Array();
    _this.attachedBlocks = new Array();
    _this._mode = NodeMaterialModes.Material;
    _this._options = __assign({ emitComments: false }, options);
    _this._attachImageProcessingConfiguration(null);
    return _this;
  }
  NodeMaterial2.prototype._getGlobalNodeMaterialEditor = function() {
    if (typeof NODEEDITOR !== "undefined") {
      return NODEEDITOR;
    }
    if (typeof BABYLON !== "undefined" && typeof BABYLON.NodeEditor !== "undefined") {
      return BABYLON;
    }
    return void 0;
  };
  Object.defineProperty(NodeMaterial2.prototype, "options", {
    get: function() {
      return this._options;
    },
    set: function(options) {
      this._options = options;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeMaterial2.prototype, "imageProcessingConfiguration", {
    get: function() {
      return this._imageProcessingConfiguration;
    },
    set: function(value) {
      this._attachImageProcessingConfiguration(value);
      this._markAllSubMeshesAsTexturesDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeMaterial2.prototype, "mode", {
    get: function() {
      return this._mode;
    },
    enumerable: false,
    configurable: true
  });
  NodeMaterial2.prototype.getClassName = function() {
    return "NodeMaterial";
  };
  NodeMaterial2.prototype._attachImageProcessingConfiguration = function(configuration) {
    var _this = this;
    if (configuration === this._imageProcessingConfiguration) {
      return;
    }
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    if (!configuration) {
      this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;
    } else {
      this._imageProcessingConfiguration = configuration;
    }
    if (this._imageProcessingConfiguration) {
      this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(function() {
        _this._markAllSubMeshesAsImageProcessingDirty();
      });
    }
  };
  NodeMaterial2.prototype.getBlockByName = function(name98) {
    var result = null;
    for (var _i = 0, _a = this.attachedBlocks; _i < _a.length; _i++) {
      var block = _a[_i];
      if (block.name === name98) {
        if (!result) {
          result = block;
        } else {
          Tools.Warn("More than one block was found with the name `" + name98 + "`");
          return result;
        }
      }
    }
    return result;
  };
  NodeMaterial2.prototype.getBlockByPredicate = function(predicate) {
    for (var _i = 0, _a = this.attachedBlocks; _i < _a.length; _i++) {
      var block = _a[_i];
      if (predicate(block)) {
        return block;
      }
    }
    return null;
  };
  NodeMaterial2.prototype.getInputBlockByPredicate = function(predicate) {
    for (var _i = 0, _a = this.attachedBlocks; _i < _a.length; _i++) {
      var block = _a[_i];
      if (block.isInput && predicate(block)) {
        return block;
      }
    }
    return null;
  };
  NodeMaterial2.prototype.getInputBlocks = function() {
    var blocks = [];
    for (var _i = 0, _a = this.attachedBlocks; _i < _a.length; _i++) {
      var block = _a[_i];
      if (block.isInput) {
        blocks.push(block);
      }
    }
    return blocks;
  };
  NodeMaterial2.prototype.registerOptimizer = function(optimizer) {
    var index = this._optimizers.indexOf(optimizer);
    if (index > -1) {
      return;
    }
    this._optimizers.push(optimizer);
    return this;
  };
  NodeMaterial2.prototype.unregisterOptimizer = function(optimizer) {
    var index = this._optimizers.indexOf(optimizer);
    if (index === -1) {
      return;
    }
    this._optimizers.splice(index, 1);
    return this;
  };
  NodeMaterial2.prototype.addOutputNode = function(node) {
    if (node.target === null) {
      throw "This node is not meant to be an output node. You may want to explicitly set its target value.";
    }
    if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {
      this._addVertexOutputNode(node);
    }
    if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {
      this._addFragmentOutputNode(node);
    }
    return this;
  };
  NodeMaterial2.prototype.removeOutputNode = function(node) {
    if (node.target === null) {
      return this;
    }
    if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {
      this._removeVertexOutputNode(node);
    }
    if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {
      this._removeFragmentOutputNode(node);
    }
    return this;
  };
  NodeMaterial2.prototype._addVertexOutputNode = function(node) {
    if (this._vertexOutputNodes.indexOf(node) !== -1) {
      return;
    }
    node.target = NodeMaterialBlockTargets.Vertex;
    this._vertexOutputNodes.push(node);
    return this;
  };
  NodeMaterial2.prototype._removeVertexOutputNode = function(node) {
    var index = this._vertexOutputNodes.indexOf(node);
    if (index === -1) {
      return;
    }
    this._vertexOutputNodes.splice(index, 1);
    return this;
  };
  NodeMaterial2.prototype._addFragmentOutputNode = function(node) {
    if (this._fragmentOutputNodes.indexOf(node) !== -1) {
      return;
    }
    node.target = NodeMaterialBlockTargets.Fragment;
    this._fragmentOutputNodes.push(node);
    return this;
  };
  NodeMaterial2.prototype._removeFragmentOutputNode = function(node) {
    var index = this._fragmentOutputNodes.indexOf(node);
    if (index === -1) {
      return;
    }
    this._fragmentOutputNodes.splice(index, 1);
    return this;
  };
  NodeMaterial2.prototype.needAlphaBlending = function() {
    if (this.ignoreAlpha) {
      return false;
    }
    return this.alpha < 1 || this._sharedData && this._sharedData.hints.needAlphaBlending;
  };
  NodeMaterial2.prototype.needAlphaTesting = function() {
    return this._sharedData && this._sharedData.hints.needAlphaTesting;
  };
  NodeMaterial2.prototype._initializeBlock = function(node, state, nodesToProcessForOtherBuildState) {
    node.initialize(state);
    node.autoConfigure(this);
    node._preparationId = this._buildId;
    if (this.attachedBlocks.indexOf(node) === -1) {
      if (node.isUnique) {
        var className2 = node.getClassName();
        for (var _i = 0, _a = this.attachedBlocks; _i < _a.length; _i++) {
          var other = _a[_i];
          if (other.getClassName() === className2) {
            throw "Cannot have multiple blocks of type " + className2 + " in the same NodeMaterial";
          }
        }
      }
      this.attachedBlocks.push(node);
    }
    for (var _b = 0, _c = node.inputs; _b < _c.length; _b++) {
      var input = _c[_b];
      input.associatedVariableName = "";
      var connectedPoint = input.connectedPoint;
      if (connectedPoint) {
        var block = connectedPoint.ownerBlock;
        if (block !== node) {
          if (block.target === NodeMaterialBlockTargets.VertexAndFragment) {
            nodesToProcessForOtherBuildState.push(block);
          } else if (state.target === NodeMaterialBlockTargets.Fragment && block.target === NodeMaterialBlockTargets.Vertex && block._preparationId !== this._buildId) {
            nodesToProcessForOtherBuildState.push(block);
          }
          this._initializeBlock(block, state, nodesToProcessForOtherBuildState);
        }
      }
    }
    for (var _d = 0, _e = node.outputs; _d < _e.length; _d++) {
      var output = _e[_d];
      output.associatedVariableName = "";
    }
  };
  NodeMaterial2.prototype._resetDualBlocks = function(node, id) {
    if (node.target === NodeMaterialBlockTargets.VertexAndFragment) {
      node.buildId = id;
    }
    for (var _i = 0, _a = node.inputs; _i < _a.length; _i++) {
      var inputs = _a[_i];
      var connectedPoint = inputs.connectedPoint;
      if (connectedPoint) {
        var block = connectedPoint.ownerBlock;
        if (block !== node) {
          this._resetDualBlocks(block, id);
        }
      }
    }
  };
  NodeMaterial2.prototype.removeBlock = function(block) {
    var attachedBlockIndex = this.attachedBlocks.indexOf(block);
    if (attachedBlockIndex > -1) {
      this.attachedBlocks.splice(attachedBlockIndex, 1);
    }
    if (block.isFinalMerger) {
      this.removeOutputNode(block);
    }
  };
  NodeMaterial2.prototype.build = function(verbose) {
    if (verbose === void 0) {
      verbose = false;
    }
    this._buildWasSuccessful = false;
    var engine = this.getScene().getEngine();
    var allowEmptyVertexProgram = this._mode === NodeMaterialModes.Particle;
    if (this._vertexOutputNodes.length === 0 && !allowEmptyVertexProgram) {
      throw "You must define at least one vertexOutputNode";
    }
    if (this._fragmentOutputNodes.length === 0) {
      throw "You must define at least one fragmentOutputNode";
    }
    this._vertexCompilationState = new NodeMaterialBuildState();
    this._vertexCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;
    this._vertexCompilationState.target = NodeMaterialBlockTargets.Vertex;
    this._fragmentCompilationState = new NodeMaterialBuildState();
    this._fragmentCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;
    this._fragmentCompilationState.target = NodeMaterialBlockTargets.Fragment;
    this._sharedData = new NodeMaterialBuildStateSharedData();
    this._vertexCompilationState.sharedData = this._sharedData;
    this._fragmentCompilationState.sharedData = this._sharedData;
    this._sharedData.buildId = this._buildId;
    this._sharedData.emitComments = this._options.emitComments;
    this._sharedData.verbose = verbose;
    this._sharedData.scene = this.getScene();
    this._sharedData.allowEmptyVertexProgram = allowEmptyVertexProgram;
    var vertexNodes = [];
    var fragmentNodes = [];
    for (var _i = 0, _a = this._vertexOutputNodes; _i < _a.length; _i++) {
      var vertexOutputNode = _a[_i];
      vertexNodes.push(vertexOutputNode);
      this._initializeBlock(vertexOutputNode, this._vertexCompilationState, fragmentNodes);
    }
    for (var _b = 0, _c = this._fragmentOutputNodes; _b < _c.length; _b++) {
      var fragmentOutputNode = _c[_b];
      fragmentNodes.push(fragmentOutputNode);
      this._initializeBlock(fragmentOutputNode, this._fragmentCompilationState, vertexNodes);
    }
    this.optimize();
    for (var _d = 0, vertexNodes_1 = vertexNodes; _d < vertexNodes_1.length; _d++) {
      var vertexOutputNode = vertexNodes_1[_d];
      vertexOutputNode.build(this._vertexCompilationState, vertexNodes);
    }
    this._fragmentCompilationState.uniforms = this._vertexCompilationState.uniforms.slice(0);
    this._fragmentCompilationState._uniformDeclaration = this._vertexCompilationState._uniformDeclaration;
    this._fragmentCompilationState._constantDeclaration = this._vertexCompilationState._constantDeclaration;
    this._fragmentCompilationState._vertexState = this._vertexCompilationState;
    for (var _e = 0, fragmentNodes_1 = fragmentNodes; _e < fragmentNodes_1.length; _e++) {
      var fragmentOutputNode = fragmentNodes_1[_e];
      this._resetDualBlocks(fragmentOutputNode, this._buildId - 1);
    }
    for (var _f = 0, fragmentNodes_2 = fragmentNodes; _f < fragmentNodes_2.length; _f++) {
      var fragmentOutputNode = fragmentNodes_2[_f];
      fragmentOutputNode.build(this._fragmentCompilationState, fragmentNodes);
    }
    this._vertexCompilationState.finalize(this._vertexCompilationState);
    this._fragmentCompilationState.finalize(this._fragmentCompilationState);
    this._buildId = NodeMaterial2._BuildIdGenerator++;
    this._sharedData.emitErrors();
    if (verbose) {
      console.log("Vertex shader:");
      console.log(this._vertexCompilationState.compilationString);
      console.log("Fragment shader:");
      console.log(this._fragmentCompilationState.compilationString);
    }
    this._buildWasSuccessful = true;
    this.onBuildObservable.notifyObservers(this);
    var meshes = this.getScene().meshes;
    for (var _g = 0, meshes_1 = meshes; _g < meshes_1.length; _g++) {
      var mesh = meshes_1[_g];
      if (!mesh.subMeshes) {
        continue;
      }
      for (var _h = 0, _j = mesh.subMeshes; _h < _j.length; _h++) {
        var subMesh = _j[_h];
        if (subMesh.getMaterial() !== this) {
          continue;
        }
        if (!subMesh._materialDefines) {
          continue;
        }
        var defines = subMesh._materialDefines;
        defines.markAllAsDirty();
        defines.reset();
      }
    }
  };
  NodeMaterial2.prototype.optimize = function() {
    for (var _i = 0, _a = this._optimizers; _i < _a.length; _i++) {
      var optimizer = _a[_i];
      optimizer.optimize(this._vertexOutputNodes, this._fragmentOutputNodes);
    }
  };
  NodeMaterial2.prototype._prepareDefinesForAttributes = function(mesh, defines) {
    var oldNormal = defines["NORMAL"];
    var oldTangent = defines["TANGENT"];
    var oldUV1 = defines["UV1"];
    defines["NORMAL"] = mesh.isVerticesDataPresent(VertexBuffer.NormalKind);
    defines["TANGENT"] = mesh.isVerticesDataPresent(VertexBuffer.TangentKind);
    defines["UV1"] = mesh.isVerticesDataPresent(VertexBuffer.UVKind);
    if (oldNormal !== defines["NORMAL"] || oldTangent !== defines["TANGENT"] || oldUV1 !== defines["UV1"]) {
      defines.markAsAttributesDirty();
    }
  };
  NodeMaterial2.prototype.createPostProcess = function(camera, options, samplingMode, engine, reusable, textureType, textureFormat) {
    if (options === void 0) {
      options = 1;
    }
    if (samplingMode === void 0) {
      samplingMode = 1;
    }
    if (textureType === void 0) {
      textureType = 0;
    }
    if (textureFormat === void 0) {
      textureFormat = 5;
    }
    if (this.mode !== NodeMaterialModes.PostProcess) {
      console.log("Incompatible material mode");
      return null;
    }
    return this._createEffectForPostProcess(null, camera, options, samplingMode, engine, reusable, textureType, textureFormat);
  };
  NodeMaterial2.prototype.createEffectForPostProcess = function(postProcess) {
    this._createEffectForPostProcess(postProcess);
  };
  NodeMaterial2.prototype._createEffectForPostProcess = function(postProcess, camera, options, samplingMode, engine, reusable, textureType, textureFormat) {
    var _this = this;
    if (options === void 0) {
      options = 1;
    }
    if (samplingMode === void 0) {
      samplingMode = 1;
    }
    if (textureType === void 0) {
      textureType = 0;
    }
    if (textureFormat === void 0) {
      textureFormat = 5;
    }
    var tempName = this.name + this._buildId;
    var defines = new NodeMaterialDefines();
    var dummyMesh = new AbstractMesh(tempName + "PostProcess", this.getScene());
    var buildId = this._buildId;
    this._processDefines(dummyMesh, defines);
    Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);
    if (!postProcess) {
      postProcess = new PostProcess(this.name + "PostProcess", tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, options, camera, samplingMode, engine, reusable, defines.toString(), textureType, tempName, { maxSimultaneousLights: this.maxSimultaneousLights }, false, textureFormat);
    } else {
      postProcess.updateEffect(defines.toString(), this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, { maxSimultaneousLights: this.maxSimultaneousLights }, void 0, void 0, tempName, tempName);
    }
    postProcess.nodeMaterialSource = this;
    postProcess.onApplyObservable.add(function(effect) {
      if (buildId !== _this._buildId) {
        delete Effect.ShadersStore[tempName + "VertexShader"];
        delete Effect.ShadersStore[tempName + "PixelShader"];
        tempName = _this.name + _this._buildId;
        defines.markAsUnprocessed();
        buildId = _this._buildId;
      }
      var result = _this._processDefines(dummyMesh, defines);
      if (result) {
        Effect.RegisterShader(tempName, _this._fragmentCompilationState._builtCompilationString, _this._vertexCompilationState._builtCompilationString);
        TimingTools.SetImmediate(function() {
          return postProcess.updateEffect(defines.toString(), _this._fragmentCompilationState.uniforms, _this._fragmentCompilationState.samplers, { maxSimultaneousLights: _this.maxSimultaneousLights }, void 0, void 0, tempName, tempName);
        });
      }
      _this._checkInternals(effect);
    });
    return postProcess;
  };
  NodeMaterial2.prototype.createProceduralTexture = function(size, scene) {
    var _this = this;
    if (this.mode !== NodeMaterialModes.ProceduralTexture) {
      console.log("Incompatible material mode");
      return null;
    }
    var tempName = this.name + this._buildId;
    var proceduralTexture = new ProceduralTexture(tempName, size, null, scene);
    var dummyMesh = new AbstractMesh(tempName + "Procedural", this.getScene());
    dummyMesh.reservedDataStore = {
      hidden: true
    };
    var defines = new NodeMaterialDefines();
    var result = this._processDefines(dummyMesh, defines);
    Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);
    var effect = this.getScene().getEngine().createEffect({
      vertexElement: tempName,
      fragmentElement: tempName
    }, [VertexBuffer.PositionKind], this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString(), result === null || result === void 0 ? void 0 : result.fallbacks, void 0);
    proceduralTexture.nodeMaterialSource = this;
    proceduralTexture._effect = effect;
    var buildId = this._buildId;
    proceduralTexture.onBeforeGenerationObservable.add(function() {
      if (buildId !== _this._buildId) {
        delete Effect.ShadersStore[tempName + "VertexShader"];
        delete Effect.ShadersStore[tempName + "PixelShader"];
        tempName = _this.name + _this._buildId;
        defines.markAsUnprocessed();
        buildId = _this._buildId;
      }
      var result2 = _this._processDefines(dummyMesh, defines);
      if (result2) {
        Effect.RegisterShader(tempName, _this._fragmentCompilationState._builtCompilationString, _this._vertexCompilationState._builtCompilationString);
        TimingTools.SetImmediate(function() {
          effect = _this.getScene().getEngine().createEffect({
            vertexElement: tempName,
            fragmentElement: tempName
          }, [VertexBuffer.PositionKind], _this._fragmentCompilationState.uniforms, _this._fragmentCompilationState.samplers, defines.toString(), result2 === null || result2 === void 0 ? void 0 : result2.fallbacks, void 0);
          proceduralTexture._effect = effect;
        });
      }
      _this._checkInternals(effect);
    });
    return proceduralTexture;
  };
  NodeMaterial2.prototype._createEffectForParticles = function(particleSystem, blendMode, onCompiled, onError, effect, defines, dummyMesh, particleSystemDefinesJoined_) {
    var _this = this;
    if (particleSystemDefinesJoined_ === void 0) {
      particleSystemDefinesJoined_ = "";
    }
    var tempName = this.name + this._buildId + "_" + blendMode;
    if (!defines) {
      defines = new NodeMaterialDefines();
    }
    if (!dummyMesh) {
      dummyMesh = this.getScene().getMeshByName(this.name + "Particle");
      if (!dummyMesh) {
        dummyMesh = new AbstractMesh(this.name + "Particle", this.getScene());
        dummyMesh.reservedDataStore = {
          hidden: true
        };
      }
    }
    var buildId = this._buildId;
    var particleSystemDefines = [];
    var particleSystemDefinesJoined = particleSystemDefinesJoined_;
    if (!effect) {
      var result = this._processDefines(dummyMesh, defines);
      Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString);
      particleSystem.fillDefines(particleSystemDefines, blendMode);
      particleSystemDefinesJoined = particleSystemDefines.join("\n");
      effect = this.getScene().getEngine().createEffectForParticles(tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString() + "\n" + particleSystemDefinesJoined, result === null || result === void 0 ? void 0 : result.fallbacks, onCompiled, onError, particleSystem);
      particleSystem.setCustomEffect(effect, blendMode);
    }
    effect.onBindObservable.add(function(effect2) {
      if (buildId !== _this._buildId) {
        delete Effect.ShadersStore[tempName + "PixelShader"];
        tempName = _this.name + _this._buildId + "_" + blendMode;
        defines.markAsUnprocessed();
        buildId = _this._buildId;
      }
      particleSystemDefines.length = 0;
      particleSystem.fillDefines(particleSystemDefines, blendMode);
      var particleSystemDefinesJoinedCurrent = particleSystemDefines.join("\n");
      if (particleSystemDefinesJoinedCurrent !== particleSystemDefinesJoined) {
        defines.markAsUnprocessed();
        particleSystemDefinesJoined = particleSystemDefinesJoinedCurrent;
      }
      var result2 = _this._processDefines(dummyMesh, defines);
      if (result2) {
        Effect.RegisterShader(tempName, _this._fragmentCompilationState._builtCompilationString);
        effect2 = _this.getScene().getEngine().createEffectForParticles(tempName, _this._fragmentCompilationState.uniforms, _this._fragmentCompilationState.samplers, defines.toString() + "\n" + particleSystemDefinesJoined, result2 === null || result2 === void 0 ? void 0 : result2.fallbacks, onCompiled, onError, particleSystem);
        particleSystem.setCustomEffect(effect2, blendMode);
        _this._createEffectForParticles(particleSystem, blendMode, onCompiled, onError, effect2, defines, dummyMesh, particleSystemDefinesJoined);
        return;
      }
      _this._checkInternals(effect2);
    });
  };
  NodeMaterial2.prototype._checkInternals = function(effect) {
    if (this._sharedData.animatedInputs) {
      var scene = this.getScene();
      var frameId = scene.getFrameId();
      if (this._animationFrame !== frameId) {
        for (var _i = 0, _a = this._sharedData.animatedInputs; _i < _a.length; _i++) {
          var input = _a[_i];
          input.animate(scene);
        }
        this._animationFrame = frameId;
      }
    }
    for (var _b = 0, _c = this._sharedData.bindableBlocks; _b < _c.length; _b++) {
      var block = _c[_b];
      block.bind(effect, this);
    }
    for (var _d = 0, _e = this._sharedData.inputBlocks; _d < _e.length; _d++) {
      var inputBlock = _e[_d];
      inputBlock._transmit(effect, this.getScene());
    }
  };
  NodeMaterial2.prototype.createEffectForParticles = function(particleSystem, onCompiled, onError) {
    if (this.mode !== NodeMaterialModes.Particle) {
      console.log("Incompatible material mode");
      return;
    }
    this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_ONEONE, onCompiled, onError);
    this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_MULTIPLY, onCompiled, onError);
  };
  NodeMaterial2.prototype._processDefines = function(mesh, defines, useInstances, subMesh) {
    var _this = this;
    if (useInstances === void 0) {
      useInstances = false;
    }
    var result = null;
    this._sharedData.blocksWithDefines.forEach(function(b) {
      b.initializeDefines(mesh, _this, defines, useInstances);
    });
    this._sharedData.blocksWithDefines.forEach(function(b) {
      b.prepareDefines(mesh, _this, defines, useInstances, subMesh);
    });
    if (defines.isDirty) {
      var lightDisposed = defines._areLightsDisposed;
      defines.markAsProcessed();
      this._vertexCompilationState.compilationString = this._vertexCompilationState._builtCompilationString;
      this._fragmentCompilationState.compilationString = this._fragmentCompilationState._builtCompilationString;
      this._sharedData.repeatableContentBlocks.forEach(function(b) {
        b.replaceRepeatableContent(_this._vertexCompilationState, _this._fragmentCompilationState, mesh, defines);
      });
      var uniformBuffers_1 = [];
      this._sharedData.dynamicUniformBlocks.forEach(function(b) {
        b.updateUniformsAndSamples(_this._vertexCompilationState, _this, defines, uniformBuffers_1);
      });
      var mergedUniforms_1 = this._vertexCompilationState.uniforms;
      this._fragmentCompilationState.uniforms.forEach(function(u) {
        var index = mergedUniforms_1.indexOf(u);
        if (index === -1) {
          mergedUniforms_1.push(u);
        }
      });
      var mergedSamplers_1 = this._vertexCompilationState.samplers;
      this._fragmentCompilationState.samplers.forEach(function(s) {
        var index = mergedSamplers_1.indexOf(s);
        if (index === -1) {
          mergedSamplers_1.push(s);
        }
      });
      var fallbacks = new EffectFallbacks();
      this._sharedData.blocksWithFallbacks.forEach(function(b) {
        b.provideFallbacks(mesh, fallbacks);
      });
      result = {
        lightDisposed,
        uniformBuffers: uniformBuffers_1,
        mergedUniforms: mergedUniforms_1,
        mergedSamplers: mergedSamplers_1,
        fallbacks
      };
    }
    return result;
  };
  NodeMaterial2.prototype.isReadyForSubMesh = function(mesh, subMesh, useInstances) {
    var _this = this;
    if (useInstances === void 0) {
      useInstances = false;
    }
    if (!this._buildWasSuccessful) {
      return false;
    }
    var scene = this.getScene();
    if (this._sharedData.animatedInputs) {
      var frameId = scene.getFrameId();
      if (this._animationFrame !== frameId) {
        for (var _i = 0, _a = this._sharedData.animatedInputs; _i < _a.length; _i++) {
          var input = _a[_i];
          input.animate(scene);
        }
        this._animationFrame = frameId;
      }
    }
    if (subMesh.effect && this.isFrozen) {
      if (subMesh.effect._wasPreviouslyReady) {
        return true;
      }
    }
    if (!subMesh._materialDefines) {
      subMesh._materialDefines = new NodeMaterialDefines();
    }
    var defines = subMesh._materialDefines;
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    var engine = scene.getEngine();
    this._prepareDefinesForAttributes(mesh, defines);
    if (this._sharedData.blockingBlocks.some(function(b) {
      return !b.isReady(mesh, _this, defines, useInstances);
    })) {
      return false;
    }
    var result = this._processDefines(mesh, defines, useInstances, subMesh);
    if (result) {
      var previousEffect = subMesh.effect;
      var join = defines.toString();
      var effect = engine.createEffect({
        vertex: "nodeMaterial" + this._buildId,
        fragment: "nodeMaterial" + this._buildId,
        vertexSource: this._vertexCompilationState.compilationString,
        fragmentSource: this._fragmentCompilationState.compilationString
      }, {
        attributes: this._vertexCompilationState.attributes,
        uniformsNames: result.mergedUniforms,
        uniformBuffersNames: result.uniformBuffers,
        samplers: result.mergedSamplers,
        defines: join,
        fallbacks: result.fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS }
      }, engine);
      if (effect) {
        if (this._onEffectCreatedObservable) {
          onCreatedEffectParameters.effect = effect;
          onCreatedEffectParameters.subMesh = subMesh;
          this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);
        }
        if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {
          effect = previousEffect;
          defines.markAsUnprocessed();
          if (result.lightDisposed) {
            defines._areLightsDisposed = true;
            return false;
          }
        } else {
          scene.resetCachedMaterial();
          subMesh.setEffect(effect, defines);
        }
      }
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    subMesh.effect._wasPreviouslyReady = true;
    return true;
  };
  Object.defineProperty(NodeMaterial2.prototype, "compiledShaders", {
    get: function() {
      return "// Vertex shader\r\n" + this._vertexCompilationState.compilationString + "\r\n\r\n// Fragment shader\r\n" + this._fragmentCompilationState.compilationString;
    },
    enumerable: false,
    configurable: true
  });
  NodeMaterial2.prototype.bindOnlyWorldMatrix = function(world) {
    var scene = this.getScene();
    if (!this._activeEffect) {
      return;
    }
    var hints = this._sharedData.hints;
    if (hints.needWorldViewMatrix) {
      world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);
    }
    if (hints.needWorldViewProjectionMatrix) {
      world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);
    }
    for (var _i = 0, _a = this._sharedData.inputBlocks; _i < _a.length; _i++) {
      var inputBlock = _a[_i];
      inputBlock._transmitWorld(this._activeEffect, world, this._cachedWorldViewMatrix, this._cachedWorldViewProjectionMatrix);
    }
  };
  NodeMaterial2.prototype.bindForSubMesh = function(world, mesh, subMesh) {
    var scene = this.getScene();
    var effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    var mustRebind = this._mustRebind(scene, effect, mesh.visibility);
    if (mustRebind) {
      var sharedData = this._sharedData;
      if (effect && scene.getCachedEffect() !== effect) {
        for (var _i = 0, _a = sharedData.bindableBlocks; _i < _a.length; _i++) {
          var block = _a[_i];
          block.bind(effect, this, mesh, subMesh);
        }
        for (var _b = 0, _c = sharedData.inputBlocks; _b < _c.length; _b++) {
          var inputBlock = _c[_b];
          inputBlock._transmit(effect, scene);
        }
      }
    }
    this._afterBind(mesh, this._activeEffect);
  };
  NodeMaterial2.prototype.getActiveTextures = function() {
    var activeTextures = _super.prototype.getActiveTextures.call(this);
    if (this._sharedData) {
      activeTextures.push.apply(activeTextures, this._sharedData.textureBlocks.filter(function(tb) {
        return tb.texture;
      }).map(function(tb) {
        return tb.texture;
      }));
    }
    return activeTextures;
  };
  NodeMaterial2.prototype.getTextureBlocks = function() {
    if (!this._sharedData) {
      return [];
    }
    return this._sharedData.textureBlocks;
  };
  NodeMaterial2.prototype.hasTexture = function(texture) {
    if (_super.prototype.hasTexture.call(this, texture)) {
      return true;
    }
    if (!this._sharedData) {
      return false;
    }
    for (var _i = 0, _a = this._sharedData.textureBlocks; _i < _a.length; _i++) {
      var t = _a[_i];
      if (t.texture === texture) {
        return true;
      }
    }
    return false;
  };
  NodeMaterial2.prototype.dispose = function(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {
    if (forceDisposeTextures) {
      for (var _i = 0, _a = this._sharedData.textureBlocks.filter(function(tb) {
        return tb.texture;
      }).map(function(tb) {
        return tb.texture;
      }); _i < _a.length; _i++) {
        var texture = _a[_i];
        texture.dispose();
      }
    }
    for (var _b = 0, _c = this.attachedBlocks; _b < _c.length; _b++) {
      var block = _c[_b];
      block.dispose();
    }
    this.onBuildObservable.clear();
    _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures, notBoundToMesh);
  };
  NodeMaterial2.prototype._createNodeEditor = function() {
    this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();
    this.BJSNODEMATERIALEDITOR.NodeEditor.Show({
      nodeMaterial: this
    });
  };
  NodeMaterial2.prototype.edit = function(config) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      if (typeof _this.BJSNODEMATERIALEDITOR == "undefined") {
        var editorUrl = config && config.editorURL ? config.editorURL : NodeMaterial2.EditorURL;
        Tools.LoadScript(editorUrl, function() {
          _this._createNodeEditor();
          resolve();
        });
      } else {
        _this._createNodeEditor();
        resolve();
      }
    });
  };
  NodeMaterial2.prototype.clear = function() {
    this._vertexOutputNodes = [];
    this._fragmentOutputNodes = [];
    this.attachedBlocks = [];
  };
  NodeMaterial2.prototype.setToDefault = function() {
    this.clear();
    this.editorData = null;
    var positionInput = new InputBlock("Position");
    positionInput.setAsAttribute("position");
    var worldInput = new InputBlock("World");
    worldInput.setAsSystemValue(BABYLON.NodeMaterialSystemValues.World);
    var worldPos = new TransformBlock("WorldPos");
    positionInput.connectTo(worldPos);
    worldInput.connectTo(worldPos);
    var viewProjectionInput = new InputBlock("ViewProjection");
    viewProjectionInput.setAsSystemValue(BABYLON.NodeMaterialSystemValues.ViewProjection);
    var worldPosdMultipliedByViewProjection = new TransformBlock("WorldPos * ViewProjectionTransform");
    worldPos.connectTo(worldPosdMultipliedByViewProjection);
    viewProjectionInput.connectTo(worldPosdMultipliedByViewProjection);
    var vertexOutput = new VertexOutputBlock("VertexOutput");
    worldPosdMultipliedByViewProjection.connectTo(vertexOutput);
    var pixelColor = new InputBlock("color");
    pixelColor.value = new Color4(0.8, 0.8, 0.8, 1);
    var fragmentOutput = new FragmentOutputBlock("FragmentOutput");
    pixelColor.connectTo(fragmentOutput);
    this.addOutputNode(vertexOutput);
    this.addOutputNode(fragmentOutput);
    this._mode = NodeMaterialModes.Material;
  };
  NodeMaterial2.prototype.setToDefaultPostProcess = function() {
    this.clear();
    this.editorData = null;
    var position = new InputBlock("Position");
    position.setAsAttribute("position2d");
    var const1 = new InputBlock("Constant1");
    const1.isConstant = true;
    const1.value = 1;
    var vmerger = new VectorMergerBlock("Position3D");
    position.connectTo(vmerger);
    const1.connectTo(vmerger, { input: "w" });
    var vertexOutput = new VertexOutputBlock("VertexOutput");
    vmerger.connectTo(vertexOutput);
    var scale = new InputBlock("Scale");
    scale.visibleInInspector = true;
    scale.value = new Vector2(1, 1);
    var uv0 = new RemapBlock("uv0");
    position.connectTo(uv0);
    var uv = new MultiplyBlock("UV scale");
    uv0.connectTo(uv);
    scale.connectTo(uv);
    var currentScreen = new CurrentScreenBlock("CurrentScreen");
    uv.connectTo(currentScreen);
    currentScreen.texture = new Texture("https://assets.babylonjs.com/nme/currentScreenPostProcess.png", this.getScene());
    var fragmentOutput = new FragmentOutputBlock("FragmentOutput");
    currentScreen.connectTo(fragmentOutput, { output: "rgba" });
    this.addOutputNode(vertexOutput);
    this.addOutputNode(fragmentOutput);
    this._mode = NodeMaterialModes.PostProcess;
  };
  NodeMaterial2.prototype.setToDefaultProceduralTexture = function() {
    this.clear();
    this.editorData = null;
    var position = new InputBlock("Position");
    position.setAsAttribute("position2d");
    var const1 = new InputBlock("Constant1");
    const1.isConstant = true;
    const1.value = 1;
    var vmerger = new VectorMergerBlock("Position3D");
    position.connectTo(vmerger);
    const1.connectTo(vmerger, { input: "w" });
    var vertexOutput = new VertexOutputBlock("VertexOutput");
    vmerger.connectTo(vertexOutput);
    var time = new InputBlock("Time");
    time.value = 0;
    time.min = 0;
    time.max = 0;
    time.isBoolean = false;
    time.matrixMode = 0;
    time.animationType = AnimatedInputBlockTypes.Time;
    time.isConstant = false;
    var color = new InputBlock("Color3");
    color.value = new Color3(1, 1, 1);
    color.isConstant = false;
    var fragmentOutput = new FragmentOutputBlock("FragmentOutput");
    var vectorMerger = new VectorMergerBlock("VectorMerger");
    vectorMerger.visibleInInspector = false;
    var cos = new TrigonometryBlock("Cos");
    cos.operation = TrigonometryBlockOperations.Cos;
    position.connectTo(vectorMerger);
    time.output.connectTo(cos.input);
    cos.output.connectTo(vectorMerger.z);
    vectorMerger.xyzOut.connectTo(fragmentOutput.rgb);
    this.addOutputNode(vertexOutput);
    this.addOutputNode(fragmentOutput);
    this._mode = NodeMaterialModes.ProceduralTexture;
  };
  NodeMaterial2.prototype.setToDefaultParticle = function() {
    this.clear();
    this.editorData = null;
    var uv = new InputBlock("uv");
    uv.setAsAttribute("particle_uv");
    var texture = new ParticleTextureBlock("ParticleTexture");
    uv.connectTo(texture);
    var color = new InputBlock("Color");
    color.setAsAttribute("particle_color");
    var multiply = new MultiplyBlock("Texture * Color");
    texture.connectTo(multiply);
    color.connectTo(multiply);
    var rampGradient = new ParticleRampGradientBlock("ParticleRampGradient");
    multiply.connectTo(rampGradient);
    var cSplitter = new ColorSplitterBlock("ColorSplitter");
    color.connectTo(cSplitter);
    var blendMultiply = new ParticleBlendMultiplyBlock("ParticleBlendMultiply");
    rampGradient.connectTo(blendMultiply);
    texture.connectTo(blendMultiply, { "output": "a" });
    cSplitter.connectTo(blendMultiply, { "output": "a" });
    var fragmentOutput = new FragmentOutputBlock("FragmentOutput");
    blendMultiply.connectTo(fragmentOutput);
    this.addOutputNode(fragmentOutput);
    this._mode = NodeMaterialModes.Particle;
  };
  NodeMaterial2.prototype.loadAsync = function(url) {
    var _this = this;
    return this.getScene()._loadFileAsync(url).then(function(data) {
      var serializationObject = JSON.parse(data);
      _this.loadFromSerialization(serializationObject, "");
    });
  };
  NodeMaterial2.prototype._gatherBlocks = function(rootNode, list) {
    if (list.indexOf(rootNode) !== -1) {
      return;
    }
    list.push(rootNode);
    for (var _i = 0, _a = rootNode.inputs; _i < _a.length; _i++) {
      var input = _a[_i];
      var connectedPoint = input.connectedPoint;
      if (connectedPoint) {
        var block = connectedPoint.ownerBlock;
        if (block !== rootNode) {
          this._gatherBlocks(block, list);
        }
      }
    }
  };
  NodeMaterial2.prototype.generateCode = function() {
    var alreadyDumped = [];
    var vertexBlocks = [];
    var uniqueNames = [];
    for (var _i = 0, _a = this._vertexOutputNodes; _i < _a.length; _i++) {
      var outputNode = _a[_i];
      this._gatherBlocks(outputNode, vertexBlocks);
    }
    var fragmentBlocks = [];
    for (var _b = 0, _c = this._fragmentOutputNodes; _b < _c.length; _b++) {
      var outputNode = _c[_b];
      this._gatherBlocks(outputNode, fragmentBlocks);
    }
    var codeString = 'var nodeMaterial = new BABYLON.NodeMaterial("' + (this.name || "node material") + '");\r\n';
    for (var _d = 0, vertexBlocks_1 = vertexBlocks; _d < vertexBlocks_1.length; _d++) {
      var node = vertexBlocks_1[_d];
      if (node.isInput && alreadyDumped.indexOf(node) === -1) {
        codeString += node._dumpCode(uniqueNames, alreadyDumped);
      }
    }
    for (var _e = 0, fragmentBlocks_1 = fragmentBlocks; _e < fragmentBlocks_1.length; _e++) {
      var node = fragmentBlocks_1[_e];
      if (node.isInput && alreadyDumped.indexOf(node) === -1) {
        codeString += node._dumpCode(uniqueNames, alreadyDumped);
      }
    }
    alreadyDumped = [];
    codeString += "\r\n// Connections\r\n";
    for (var _f = 0, _g = this._vertexOutputNodes; _f < _g.length; _f++) {
      var node = _g[_f];
      codeString += node._dumpCodeForOutputConnections(alreadyDumped);
    }
    for (var _h = 0, _j = this._fragmentOutputNodes; _h < _j.length; _h++) {
      var node = _j[_h];
      codeString += node._dumpCodeForOutputConnections(alreadyDumped);
    }
    codeString += "\r\n// Output nodes\r\n";
    for (var _k = 0, _l = this._vertexOutputNodes; _k < _l.length; _k++) {
      var node = _l[_k];
      codeString += "nodeMaterial.addOutputNode(" + node._codeVariableName + ");\r\n";
    }
    for (var _m = 0, _o = this._fragmentOutputNodes; _m < _o.length; _m++) {
      var node = _o[_m];
      codeString += "nodeMaterial.addOutputNode(" + node._codeVariableName + ");\r\n";
    }
    codeString += "nodeMaterial.build();\r\n";
    return codeString;
  };
  NodeMaterial2.prototype.serialize = function(selectedBlocks) {
    var serializationObject = selectedBlocks ? {} : SerializationHelper.Serialize(this);
    serializationObject.editorData = JSON.parse(JSON.stringify(this.editorData));
    var blocks = [];
    if (selectedBlocks) {
      blocks = selectedBlocks;
    } else {
      serializationObject.customType = "BABYLON.NodeMaterial";
      serializationObject.outputNodes = [];
      for (var _i = 0, _a = this._vertexOutputNodes; _i < _a.length; _i++) {
        var outputNode = _a[_i];
        this._gatherBlocks(outputNode, blocks);
        serializationObject.outputNodes.push(outputNode.uniqueId);
      }
      for (var _b = 0, _c = this._fragmentOutputNodes; _b < _c.length; _b++) {
        var outputNode = _c[_b];
        this._gatherBlocks(outputNode, blocks);
        if (serializationObject.outputNodes.indexOf(outputNode.uniqueId) === -1) {
          serializationObject.outputNodes.push(outputNode.uniqueId);
        }
      }
    }
    serializationObject.blocks = [];
    for (var _d = 0, blocks_1 = blocks; _d < blocks_1.length; _d++) {
      var block = blocks_1[_d];
      serializationObject.blocks.push(block.serialize());
    }
    if (!selectedBlocks) {
      for (var _e = 0, _f = this.attachedBlocks; _e < _f.length; _e++) {
        var block = _f[_e];
        if (blocks.indexOf(block) !== -1) {
          continue;
        }
        serializationObject.blocks.push(block.serialize());
      }
    }
    return serializationObject;
  };
  NodeMaterial2.prototype._restoreConnections = function(block, source, map) {
    for (var _i = 0, _a = block.outputs; _i < _a.length; _i++) {
      var outputPoint = _a[_i];
      for (var _b = 0, _c = source.blocks; _b < _c.length; _b++) {
        var candidate = _c[_b];
        var target = map[candidate.id];
        if (!target) {
          continue;
        }
        for (var _d = 0, _e = candidate.inputs; _d < _e.length; _d++) {
          var input = _e[_d];
          if (map[input.targetBlockId] === block && input.targetConnectionName === outputPoint.name) {
            var inputPoint = target.getInputByName(input.inputName);
            if (!inputPoint || inputPoint.isConnected) {
              continue;
            }
            outputPoint.connectTo(inputPoint, true);
            this._restoreConnections(target, source, map);
            continue;
          }
        }
      }
    }
  };
  NodeMaterial2.prototype.loadFromSerialization = function(source, rootUrl, merge) {
    var _a;
    if (rootUrl === void 0) {
      rootUrl = "";
    }
    if (merge === void 0) {
      merge = false;
    }
    if (!merge) {
      this.clear();
    }
    var map = {};
    for (var _i = 0, _b = source.blocks; _i < _b.length; _i++) {
      var parsedBlock = _b[_i];
      var blockType = _TypeStore.GetClass(parsedBlock.customType);
      if (blockType) {
        var block = new blockType();
        block._deserialize(parsedBlock, this.getScene(), rootUrl);
        map[parsedBlock.id] = block;
        this.attachedBlocks.push(block);
      }
    }
    for (var blockIndex = 0; blockIndex < source.blocks.length; blockIndex++) {
      var parsedBlock_1 = source.blocks[blockIndex];
      var block = map[parsedBlock_1.id];
      if (!block) {
        continue;
      }
      if (block.inputs.length && !merge) {
        continue;
      }
      this._restoreConnections(block, source, map);
    }
    if (source.outputNodes) {
      for (var _c = 0, _d = source.outputNodes; _c < _d.length; _c++) {
        var outputNodeId = _d[_c];
        this.addOutputNode(map[outputNodeId]);
      }
    }
    if (source.locations || source.editorData && source.editorData.locations) {
      var locations = source.locations || source.editorData.locations;
      for (var _e = 0, locations_1 = locations; _e < locations_1.length; _e++) {
        var location = locations_1[_e];
        if (map[location.blockId]) {
          location.blockId = map[location.blockId].uniqueId;
        }
      }
      if (merge && this.editorData && this.editorData.locations) {
        locations.concat(this.editorData.locations);
      }
      if (source.locations) {
        this.editorData = {
          locations
        };
      } else {
        this.editorData = source.editorData;
        this.editorData.locations = locations;
      }
      var blockMap = [];
      for (var key in map) {
        blockMap[key] = map[key].uniqueId;
      }
      this.editorData.map = blockMap;
    }
    this.comment = source.comment;
    if (!merge) {
      this._mode = (_a = source.mode) !== null && _a !== void 0 ? _a : NodeMaterialModes.Material;
    }
  };
  NodeMaterial2.prototype.clone = function(name98) {
    var _this = this;
    var serializationObject = this.serialize();
    var clone = SerializationHelper.Clone(function() {
      return new NodeMaterial2(name98, _this.getScene(), _this.options);
    }, this);
    clone.id = name98;
    clone.name = name98;
    clone.loadFromSerialization(serializationObject);
    clone.build();
    return clone;
  };
  NodeMaterial2.Parse = function(source, scene, rootUrl) {
    if (rootUrl === void 0) {
      rootUrl = "";
    }
    var nodeMaterial = SerializationHelper.Parse(function() {
      return new NodeMaterial2(source.name, scene);
    }, source, scene, rootUrl);
    nodeMaterial.loadFromSerialization(source, rootUrl);
    nodeMaterial.build();
    return nodeMaterial;
  };
  NodeMaterial2.ParseFromFileAsync = function(name98, url, scene) {
    var material = new NodeMaterial2(name98, scene);
    return new Promise(function(resolve, reject) {
      return material.loadAsync(url).then(function() {
        material.build();
        resolve(material);
      }).catch(reject);
    });
  };
  NodeMaterial2.ParseFromSnippetAsync = function(snippetId, scene, rootUrl, nodeMaterial) {
    var _this = this;
    if (rootUrl === void 0) {
      rootUrl = "";
    }
    if (snippetId === "_BLANK") {
      return Promise.resolve(this.CreateDefault("blank", scene));
    }
    return new Promise(function(resolve, reject) {
      var request = new WebRequest();
      request.addEventListener("readystatechange", function() {
        if (request.readyState == 4) {
          if (request.status == 200) {
            var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
            var serializationObject = JSON.parse(snippet.nodeMaterial);
            if (!nodeMaterial) {
              nodeMaterial = SerializationHelper.Parse(function() {
                return new NodeMaterial2(snippetId, scene);
              }, serializationObject, scene, rootUrl);
              nodeMaterial.uniqueId = scene.getUniqueId();
            }
            nodeMaterial.loadFromSerialization(serializationObject);
            nodeMaterial.snippetId = snippetId;
            try {
              nodeMaterial.build();
              resolve(nodeMaterial);
            } catch (err) {
              reject(err);
            }
          } else {
            reject("Unable to load the snippet " + snippetId);
          }
        }
      });
      request.open("GET", _this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
      request.send();
    });
  };
  NodeMaterial2.CreateDefault = function(name98, scene) {
    var newMaterial = new NodeMaterial2(name98, scene);
    newMaterial.setToDefault();
    newMaterial.build();
    return newMaterial;
  };
  NodeMaterial2._BuildIdGenerator = 0;
  NodeMaterial2.EditorURL = "https://unpkg.com/babylonjs-node-editor@" + Engine.Version + "/babylon.nodeEditor.js";
  NodeMaterial2.SnippetUrl = "https://snippet.babylonjs.com";
  NodeMaterial2.IgnoreTexturesAtLoadTime = false;
  __decorate([
    serialize("mode")
  ], NodeMaterial2.prototype, "_mode", void 0);
  __decorate([
    serialize("comment")
  ], NodeMaterial2.prototype, "comment", void 0);
  return NodeMaterial2;
}(PushMaterial);
_TypeStore.RegisteredTypes["BABYLON.NodeMaterial"] = NodeMaterial;

// node_modules/@babylonjs/core/Materials/Node/Blocks/Vertex/bonesBlock.js
var BonesBlock = function(_super) {
  __extends(BonesBlock2, _super);
  function BonesBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Vertex) || this;
    _this.registerInput("matricesIndices", NodeMaterialBlockConnectionPointTypes.Vector4);
    _this.registerInput("matricesWeights", NodeMaterialBlockConnectionPointTypes.Vector4);
    _this.registerInput("matricesIndicesExtra", NodeMaterialBlockConnectionPointTypes.Vector4, true);
    _this.registerInput("matricesWeightsExtra", NodeMaterialBlockConnectionPointTypes.Vector4, true);
    _this.registerInput("world", NodeMaterialBlockConnectionPointTypes.Matrix);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Matrix);
    return _this;
  }
  BonesBlock2.prototype.initialize = function(state) {
    state._excludeVariableName("boneSampler");
    state._excludeVariableName("boneTextureWidth");
    state._excludeVariableName("mBones");
    state._excludeVariableName("BonesPerMesh");
  };
  BonesBlock2.prototype.getClassName = function() {
    return "BonesBlock";
  };
  Object.defineProperty(BonesBlock2.prototype, "matricesIndices", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BonesBlock2.prototype, "matricesWeights", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BonesBlock2.prototype, "matricesIndicesExtra", {
    get: function() {
      return this._inputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BonesBlock2.prototype, "matricesWeightsExtra", {
    get: function() {
      return this._inputs[3];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BonesBlock2.prototype, "world", {
    get: function() {
      return this._inputs[4];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BonesBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  BonesBlock2.prototype.autoConfigure = function(material) {
    if (!this.matricesIndices.isConnected) {
      var matricesIndicesInput = material.getInputBlockByPredicate(function(b) {
        return b.isAttribute && b.name === "matricesIndices";
      });
      if (!matricesIndicesInput) {
        matricesIndicesInput = new InputBlock("matricesIndices");
        matricesIndicesInput.setAsAttribute("matricesIndices");
      }
      matricesIndicesInput.output.connectTo(this.matricesIndices);
    }
    if (!this.matricesWeights.isConnected) {
      var matricesWeightsInput = material.getInputBlockByPredicate(function(b) {
        return b.isAttribute && b.name === "matricesWeights";
      });
      if (!matricesWeightsInput) {
        matricesWeightsInput = new InputBlock("matricesWeights");
        matricesWeightsInput.setAsAttribute("matricesWeights");
      }
      matricesWeightsInput.output.connectTo(this.matricesWeights);
    }
    if (!this.world.isConnected) {
      var worldInput = material.getInputBlockByPredicate(function(b) {
        return b.systemValue === NodeMaterialSystemValues.World;
      });
      if (!worldInput) {
        worldInput = new InputBlock("world");
        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);
      }
      worldInput.output.connectTo(this.world);
    }
  };
  BonesBlock2.prototype.provideFallbacks = function(mesh, fallbacks) {
    if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
      fallbacks.addCPUSkinningFallback(0, mesh);
    }
  };
  BonesBlock2.prototype.bind = function(effect, nodeMaterial, mesh) {
    MaterialHelper.BindBonesParameters(mesh, effect);
  };
  BonesBlock2.prototype.prepareDefines = function(mesh, nodeMaterial, defines) {
    if (!defines._areAttributesDirty) {
      return;
    }
    MaterialHelper.PrepareDefinesForBones(mesh, defines);
  };
  BonesBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    state.sharedData.blocksWithFallbacks.push(this);
    state.sharedData.bindableBlocks.push(this);
    state.sharedData.blocksWithDefines.push(this);
    state.uniforms.push("boneTextureWidth");
    state.uniforms.push("mBones");
    state.samplers.push("boneSampler");
    var comments = "//" + this.name;
    state._emitFunctionFromInclude("bonesDeclaration", comments, {
      removeAttributes: true,
      removeUniforms: false,
      removeVaryings: true,
      removeIfDef: false
    });
    var influenceVariablename = state._getFreeVariableName("influence");
    state.compilationString += state._emitCodeFromInclude("bonesVertex", comments, {
      replaceStrings: [
        {
          search: /finalWorld=finalWorld\*influence;/,
          replace: ""
        },
        {
          search: /influence/gm,
          replace: influenceVariablename
        }
      ]
    });
    var output = this._outputs[0];
    var worldInput = this.world;
    state.compilationString += "#if NUM_BONE_INFLUENCERS>0\r\n";
    state.compilationString += this._declareOutput(output, state) + (" = " + worldInput.associatedVariableName + " * " + influenceVariablename + ";\r\n");
    state.compilationString += "#else\r\n";
    state.compilationString += this._declareOutput(output, state) + (" = " + worldInput.associatedVariableName + ";\r\n");
    state.compilationString += "#endif\r\n";
    return this;
  };
  return BonesBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.BonesBlock"] = BonesBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/Vertex/instancesBlock.js
var InstancesBlock = function(_super) {
  __extends(InstancesBlock2, _super);
  function InstancesBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Vertex) || this;
    _this.registerInput("world0", NodeMaterialBlockConnectionPointTypes.Vector4);
    _this.registerInput("world1", NodeMaterialBlockConnectionPointTypes.Vector4);
    _this.registerInput("world2", NodeMaterialBlockConnectionPointTypes.Vector4);
    _this.registerInput("world3", NodeMaterialBlockConnectionPointTypes.Vector4);
    _this.registerInput("world", NodeMaterialBlockConnectionPointTypes.Matrix, true);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Matrix);
    _this.registerOutput("instanceID", NodeMaterialBlockConnectionPointTypes.Float);
    return _this;
  }
  InstancesBlock2.prototype.getClassName = function() {
    return "InstancesBlock";
  };
  Object.defineProperty(InstancesBlock2.prototype, "world0", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InstancesBlock2.prototype, "world1", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InstancesBlock2.prototype, "world2", {
    get: function() {
      return this._inputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InstancesBlock2.prototype, "world3", {
    get: function() {
      return this._inputs[3];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InstancesBlock2.prototype, "world", {
    get: function() {
      return this._inputs[4];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InstancesBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InstancesBlock2.prototype, "instanceID", {
    get: function() {
      return this._outputs[1];
    },
    enumerable: false,
    configurable: true
  });
  InstancesBlock2.prototype.autoConfigure = function(material) {
    if (!this.world0.connectedPoint) {
      var world0Input = material.getInputBlockByPredicate(function(b) {
        return b.isAttribute && b.name === "world0";
      });
      if (!world0Input) {
        world0Input = new InputBlock("world0");
        world0Input.setAsAttribute("world0");
      }
      world0Input.output.connectTo(this.world0);
    }
    if (!this.world1.connectedPoint) {
      var world1Input = material.getInputBlockByPredicate(function(b) {
        return b.isAttribute && b.name === "world1";
      });
      if (!world1Input) {
        world1Input = new InputBlock("world1");
        world1Input.setAsAttribute("world1");
      }
      world1Input.output.connectTo(this.world1);
    }
    if (!this.world2.connectedPoint) {
      var world2Input = material.getInputBlockByPredicate(function(b) {
        return b.isAttribute && b.name === "world2";
      });
      if (!world2Input) {
        world2Input = new InputBlock("world2");
        world2Input.setAsAttribute("world2");
      }
      world2Input.output.connectTo(this.world2);
    }
    if (!this.world3.connectedPoint) {
      var world3Input = material.getInputBlockByPredicate(function(b) {
        return b.isAttribute && b.name === "world3";
      });
      if (!world3Input) {
        world3Input = new InputBlock("world3");
        world3Input.setAsAttribute("world3");
      }
      world3Input.output.connectTo(this.world3);
    }
    if (!this.world.connectedPoint) {
      var worldInput = material.getInputBlockByPredicate(function(b) {
        return b.isAttribute && b.name === "world";
      });
      if (!worldInput) {
        worldInput = new InputBlock("world");
        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);
      }
      worldInput.output.connectTo(this.world);
    }
    this.world.define = "!INSTANCES || THIN_INSTANCES";
  };
  InstancesBlock2.prototype.prepareDefines = function(mesh, nodeMaterial, defines, useInstances, subMesh) {
    if (useInstances === void 0) {
      useInstances = false;
    }
    var changed = false;
    if (defines["INSTANCES"] !== useInstances) {
      defines.setValue("INSTANCES", useInstances);
      changed = true;
    }
    if (subMesh && defines["THIN_INSTANCES"] !== !!(subMesh === null || subMesh === void 0 ? void 0 : subMesh.getRenderingMesh().hasThinInstances)) {
      defines.setValue("THIN_INSTANCES", !!(subMesh === null || subMesh === void 0 ? void 0 : subMesh.getRenderingMesh().hasThinInstances));
      changed = true;
    }
    if (changed) {
      defines.markAsUnprocessed();
    }
  };
  InstancesBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    state.sharedData.blocksWithDefines.push(this);
    var output = this._outputs[0];
    var instanceID = this._outputs[1];
    var world0 = this.world0;
    var world1 = this.world1;
    var world2 = this.world2;
    var world3 = this.world3;
    state.compilationString += "#ifdef INSTANCES\r\n";
    state.compilationString += this._declareOutput(output, state) + (" = mat4(" + world0.associatedVariableName + ", " + world1.associatedVariableName + ", " + world2.associatedVariableName + ", " + world3.associatedVariableName + ");\r\n");
    state.compilationString += "#ifdef THIN_INSTANCES\r\n";
    state.compilationString += output.associatedVariableName + " = " + this.world.associatedVariableName + " * " + output.associatedVariableName + ";\r\n";
    state.compilationString += "#endif\r\n";
    state.compilationString += this._declareOutput(instanceID, state) + " = float(gl_InstanceID);\r\n";
    state.compilationString += "#else\r\n";
    state.compilationString += this._declareOutput(output, state) + (" = " + this.world.associatedVariableName + ";\r\n");
    state.compilationString += this._declareOutput(instanceID, state) + " = 0.0;\r\n";
    state.compilationString += "#endif\r\n";
    return this;
  };
  return InstancesBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.InstancesBlock"] = InstancesBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/Vertex/morphTargetsBlock.js
var MorphTargetsBlock = function(_super) {
  __extends(MorphTargetsBlock2, _super);
  function MorphTargetsBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Vertex) || this;
    _this.registerInput("position", NodeMaterialBlockConnectionPointTypes.Vector3);
    _this.registerInput("normal", NodeMaterialBlockConnectionPointTypes.Vector3);
    _this.registerInput("tangent", NodeMaterialBlockConnectionPointTypes.Vector3);
    _this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.Vector2);
    _this.registerOutput("positionOutput", NodeMaterialBlockConnectionPointTypes.Vector3);
    _this.registerOutput("normalOutput", NodeMaterialBlockConnectionPointTypes.Vector3);
    _this.registerOutput("tangentOutput", NodeMaterialBlockConnectionPointTypes.Vector3);
    _this.registerOutput("uvOutput", NodeMaterialBlockConnectionPointTypes.Vector2);
    return _this;
  }
  MorphTargetsBlock2.prototype.getClassName = function() {
    return "MorphTargetsBlock";
  };
  Object.defineProperty(MorphTargetsBlock2.prototype, "position", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MorphTargetsBlock2.prototype, "normal", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MorphTargetsBlock2.prototype, "tangent", {
    get: function() {
      return this._inputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MorphTargetsBlock2.prototype, "uv", {
    get: function() {
      return this._inputs[3];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MorphTargetsBlock2.prototype, "positionOutput", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MorphTargetsBlock2.prototype, "normalOutput", {
    get: function() {
      return this._outputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MorphTargetsBlock2.prototype, "tangentOutput", {
    get: function() {
      return this._outputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MorphTargetsBlock2.prototype, "uvOutput", {
    get: function() {
      return this._outputs[3];
    },
    enumerable: false,
    configurable: true
  });
  MorphTargetsBlock2.prototype.initialize = function(state) {
    state._excludeVariableName("morphTargetInfluences");
  };
  MorphTargetsBlock2.prototype.autoConfigure = function(material) {
    if (!this.position.isConnected) {
      var positionInput = material.getInputBlockByPredicate(function(b) {
        return b.isAttribute && b.name === "position";
      });
      if (!positionInput) {
        positionInput = new InputBlock("position");
        positionInput.setAsAttribute();
      }
      positionInput.output.connectTo(this.position);
    }
    if (!this.normal.isConnected) {
      var normalInput = material.getInputBlockByPredicate(function(b) {
        return b.isAttribute && b.name === "normal";
      });
      if (!normalInput) {
        normalInput = new InputBlock("normal");
        normalInput.setAsAttribute("normal");
      }
      normalInput.output.connectTo(this.normal);
    }
    if (!this.tangent.isConnected) {
      var tangentInput = material.getInputBlockByPredicate(function(b) {
        return b.isAttribute && b.name === "tangent";
      });
      if (!tangentInput) {
        tangentInput = new InputBlock("tangent");
        tangentInput.setAsAttribute("tangent");
      }
      tangentInput.output.connectTo(this.tangent);
    }
    if (!this.uv.isConnected) {
      var uvInput = material.getInputBlockByPredicate(function(b) {
        return b.isAttribute && b.name === "uv";
      });
      if (!uvInput) {
        uvInput = new InputBlock("uv");
        uvInput.setAsAttribute("uv");
      }
      uvInput.output.connectTo(this.uv);
    }
  };
  MorphTargetsBlock2.prototype.prepareDefines = function(mesh, nodeMaterial, defines) {
    if (!defines._areAttributesDirty) {
      return;
    }
    MaterialHelper.PrepareDefinesForMorphTargets(mesh, defines);
  };
  MorphTargetsBlock2.prototype.bind = function(effect, nodeMaterial, mesh) {
    if (mesh && mesh.morphTargetManager && mesh.morphTargetManager.numInfluencers > 0) {
      MaterialHelper.BindMorphTargetParameters(mesh, effect);
    }
  };
  MorphTargetsBlock2.prototype.replaceRepeatableContent = function(vertexShaderState, fragmentShaderState, mesh, defines) {
    var position = this.position;
    var normal = this.normal;
    var tangent = this.tangent;
    var uv = this.uv;
    var positionOutput = this.positionOutput;
    var normalOutput = this.normalOutput;
    var tangentOutput = this.tangentOutput;
    var uvOutput = this.uvOutput;
    var state = vertexShaderState;
    var repeatCount = defines.NUM_MORPH_INFLUENCERS;
    var manager = mesh.morphTargetManager;
    var hasNormals = manager && manager.supportsNormals && defines["NORMAL"];
    var hasTangents = manager && manager.supportsTangents && defines["TANGENT"];
    var hasUVs = manager && manager.supportsUVs && defines["UV1"];
    var injectionCode = "";
    for (var index = 0; index < repeatCount; index++) {
      injectionCode += "#ifdef MORPHTARGETS\r\n";
      injectionCode += positionOutput.associatedVariableName + " += (position" + index + " - " + position.associatedVariableName + ") * morphTargetInfluences[" + index + "];\r\n";
      if (hasNormals) {
        injectionCode += "#ifdef MORPHTARGETS_NORMAL\r\n";
        injectionCode += normalOutput.associatedVariableName + " += (normal" + index + " - " + normal.associatedVariableName + ") * morphTargetInfluences[" + index + "];\r\n";
        injectionCode += "#endif\r\n";
      }
      if (hasTangents) {
        injectionCode += "#ifdef MORPHTARGETS_TANGENT\r\n";
        injectionCode += tangentOutput.associatedVariableName + ".xyz += (tangent" + index + " - " + tangent.associatedVariableName + ".xyz) * morphTargetInfluences[" + index + "];\r\n";
        injectionCode += "#endif\r\n";
      }
      if (hasUVs) {
        injectionCode += "#ifdef MORPHTARGETS_UV\r\n";
        injectionCode += uvOutput.associatedVariableName + ".xy += (uv_" + index + " - " + uv.associatedVariableName + ".xy) * morphTargetInfluences[" + index + "];\r\n";
        injectionCode += "#endif\r\n";
      }
      injectionCode += "#endif\r\n";
    }
    state.compilationString = state.compilationString.replace(this._repeatableContentAnchor, injectionCode);
    if (repeatCount > 0) {
      for (var index = 0; index < repeatCount; index++) {
        state.attributes.push(VertexBuffer.PositionKind + index);
        if (hasNormals) {
          state.attributes.push(VertexBuffer.NormalKind + index);
        }
        if (hasTangents) {
          state.attributes.push(VertexBuffer.TangentKind + index);
        }
        if (hasUVs) {
          state.attributes.push(VertexBuffer.UVKind + "_" + index);
        }
      }
    }
  };
  MorphTargetsBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    state.sharedData.blocksWithDefines.push(this);
    state.sharedData.bindableBlocks.push(this);
    state.sharedData.repeatableContentBlocks.push(this);
    var position = this.position;
    var normal = this.normal;
    var tangent = this.tangent;
    var uv = this.uv;
    var positionOutput = this.positionOutput;
    var normalOutput = this.normalOutput;
    var tangentOutput = this.tangentOutput;
    var uvOutput = this.uvOutput;
    var comments = "//" + this.name;
    state.uniforms.push("morphTargetInfluences");
    state._emitFunctionFromInclude("morphTargetsVertexGlobalDeclaration", comments);
    state._emitFunctionFromInclude("morphTargetsVertexDeclaration", comments, {
      repeatKey: "maxSimultaneousMorphTargets"
    });
    state.compilationString += this._declareOutput(positionOutput, state) + " = " + position.associatedVariableName + ";\r\n";
    state.compilationString += "#ifdef NORMAL\r\n";
    state.compilationString += this._declareOutput(normalOutput, state) + " = " + normal.associatedVariableName + ";\r\n";
    state.compilationString += "#else\r\n";
    state.compilationString += this._declareOutput(normalOutput, state) + " = vec3(0., 0., 0.);\r\n";
    state.compilationString += "#endif\r\n";
    state.compilationString += "#ifdef TANGENT\r\n";
    state.compilationString += this._declareOutput(tangentOutput, state) + " = " + tangent.associatedVariableName + ";\r\n";
    state.compilationString += "#else\r\n";
    state.compilationString += this._declareOutput(tangentOutput, state) + " = vec3(0., 0., 0.);\r\n";
    state.compilationString += "#endif\r\n";
    state.compilationString += "#ifdef UV1\r\n";
    state.compilationString += this._declareOutput(uvOutput, state) + " = " + uv.associatedVariableName + ";\r\n";
    state.compilationString += "#else\r\n";
    state.compilationString += this._declareOutput(uvOutput, state) + " = vec2(0., 0.);\r\n";
    state.compilationString += "#endif\r\n";
    this._repeatableContentAnchor = state._repeatableContentAnchor;
    state.compilationString += this._repeatableContentAnchor;
    return this;
  };
  return MorphTargetsBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.MorphTargetsBlock"] = MorphTargetsBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/Vertex/lightInformationBlock.js
var LightInformationBlock = function(_super) {
  __extends(LightInformationBlock2, _super);
  function LightInformationBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Vertex) || this;
    _this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);
    _this.registerOutput("direction", NodeMaterialBlockConnectionPointTypes.Vector3);
    _this.registerOutput("color", NodeMaterialBlockConnectionPointTypes.Color3);
    _this.registerOutput("intensity", NodeMaterialBlockConnectionPointTypes.Float);
    return _this;
  }
  LightInformationBlock2.prototype.getClassName = function() {
    return "LightInformationBlock";
  };
  Object.defineProperty(LightInformationBlock2.prototype, "worldPosition", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LightInformationBlock2.prototype, "direction", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LightInformationBlock2.prototype, "color", {
    get: function() {
      return this._outputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LightInformationBlock2.prototype, "intensity", {
    get: function() {
      return this._outputs[2];
    },
    enumerable: false,
    configurable: true
  });
  LightInformationBlock2.prototype.bind = function(effect, nodeMaterial, mesh) {
    if (!mesh) {
      return;
    }
    if (this.light && this.light.isDisposed) {
      this.light = null;
    }
    var light = this.light;
    var scene = nodeMaterial.getScene();
    if (!light && scene.lights.length) {
      light = scene.lights[0];
    }
    if (!light || !light.isEnabled) {
      effect.setFloat3(this._lightDataUniformName, 0, 0, 0);
      effect.setFloat4(this._lightColorUniformName, 0, 0, 0, 0);
      return;
    }
    light.transferToNodeMaterialEffect(effect, this._lightDataUniformName);
    effect.setColor4(this._lightColorUniformName, light.diffuse, light.intensity);
  };
  LightInformationBlock2.prototype.prepareDefines = function(mesh, nodeMaterial, defines) {
    if (!defines._areLightsDirty) {
      return;
    }
    var light = this.light;
    defines.setValue(this._lightTypeDefineName, light && light instanceof PointLight ? true : false);
  };
  LightInformationBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    state.sharedData.bindableBlocks.push(this);
    state.sharedData.blocksWithDefines.push(this);
    var direction = this.direction;
    var color = this.color;
    var intensity = this.intensity;
    this._lightDataUniformName = state._getFreeVariableName("lightData");
    this._lightColorUniformName = state._getFreeVariableName("lightColor");
    this._lightTypeDefineName = state._getFreeDefineName("LIGHTPOINTTYPE");
    state._emitUniformFromString(this._lightDataUniformName, "vec3");
    state._emitUniformFromString(this._lightColorUniformName, "vec4");
    state.compilationString += "#ifdef " + this._lightTypeDefineName + "\r\n";
    state.compilationString += this._declareOutput(direction, state) + (" = normalize(" + this.worldPosition.associatedVariableName + ".xyz - " + this._lightDataUniformName + ");\r\n");
    state.compilationString += "#else\r\n";
    state.compilationString += this._declareOutput(direction, state) + (" = " + this._lightDataUniformName + ";\r\n");
    state.compilationString += "#endif\r\n";
    state.compilationString += this._declareOutput(color, state) + (" = " + this._lightColorUniformName + ".rgb;\r\n");
    state.compilationString += this._declareOutput(intensity, state) + (" = " + this._lightColorUniformName + ".a;\r\n");
    return this;
  };
  LightInformationBlock2.prototype.serialize = function() {
    var serializationObject = _super.prototype.serialize.call(this);
    if (this.light) {
      serializationObject.lightId = this.light.id;
    }
    return serializationObject;
  };
  LightInformationBlock2.prototype._deserialize = function(serializationObject, scene, rootUrl) {
    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);
    if (serializationObject.lightId) {
      this.light = scene.getLightByID(serializationObject.lightId);
    }
  };
  return LightInformationBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.LightInformationBlock"] = LightInformationBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/imageProcessingBlock.js
var ImageProcessingBlock = function(_super) {
  __extends(ImageProcessingBlock2, _super);
  function ImageProcessingBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Fragment) || this;
    _this.registerInput("color", NodeMaterialBlockConnectionPointTypes.Color4);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Color4);
    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Color3);
    return _this;
  }
  ImageProcessingBlock2.prototype.getClassName = function() {
    return "ImageProcessingBlock";
  };
  Object.defineProperty(ImageProcessingBlock2.prototype, "color", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  ImageProcessingBlock2.prototype.initialize = function(state) {
    state._excludeVariableName("exposureLinear");
    state._excludeVariableName("contrast");
    state._excludeVariableName("vInverseScreenSize");
    state._excludeVariableName("vignetteSettings1");
    state._excludeVariableName("vignetteSettings2");
    state._excludeVariableName("vCameraColorCurveNegative");
    state._excludeVariableName("vCameraColorCurveNeutral");
    state._excludeVariableName("vCameraColorCurvePositive");
    state._excludeVariableName("txColorTransform");
    state._excludeVariableName("colorTransformSettings");
  };
  ImageProcessingBlock2.prototype.isReady = function(mesh, nodeMaterial, defines) {
    if (defines._areImageProcessingDirty && nodeMaterial.imageProcessingConfiguration) {
      if (!nodeMaterial.imageProcessingConfiguration.isReady()) {
        return false;
      }
    }
    return true;
  };
  ImageProcessingBlock2.prototype.prepareDefines = function(mesh, nodeMaterial, defines) {
    if (defines._areImageProcessingDirty && nodeMaterial.imageProcessingConfiguration) {
      nodeMaterial.imageProcessingConfiguration.prepareDefines(defines);
    }
  };
  ImageProcessingBlock2.prototype.bind = function(effect, nodeMaterial, mesh) {
    if (!mesh) {
      return;
    }
    if (!nodeMaterial.imageProcessingConfiguration) {
      return;
    }
    nodeMaterial.imageProcessingConfiguration.bind(effect);
  };
  ImageProcessingBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    state.sharedData.blocksWithDefines.push(this);
    state.sharedData.blockingBlocks.push(this);
    state.sharedData.bindableBlocks.push(this);
    state.uniforms.push("exposureLinear");
    state.uniforms.push("contrast");
    state.uniforms.push("vInverseScreenSize");
    state.uniforms.push("vignetteSettings1");
    state.uniforms.push("vignetteSettings2");
    state.uniforms.push("vCameraColorCurveNegative");
    state.uniforms.push("vCameraColorCurveNeutral");
    state.uniforms.push("vCameraColorCurvePositive");
    state.uniforms.push("txColorTransform");
    state.uniforms.push("colorTransformSettings");
    var color = this.color;
    var output = this._outputs[0];
    var comments = "//" + this.name;
    state._emitFunctionFromInclude("helperFunctions", comments);
    state._emitFunctionFromInclude("imageProcessingDeclaration", comments);
    state._emitFunctionFromInclude("imageProcessingFunctions", comments);
    if (color.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Color4 || color.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Vector4) {
      state.compilationString += this._declareOutput(output, state) + " = " + color.associatedVariableName + ";\r\n";
    } else {
      state.compilationString += this._declareOutput(output, state) + " = vec4(" + color.associatedVariableName + ", 1.0);\r\n";
    }
    state.compilationString += "#ifdef IMAGEPROCESSINGPOSTPROCESS\r\n";
    state.compilationString += output.associatedVariableName + ".rgb = toLinearSpace(" + color.associatedVariableName + ".rgb);\r\n";
    state.compilationString += "#else\r\n";
    state.compilationString += "#ifdef IMAGEPROCESSING\r\n";
    state.compilationString += output.associatedVariableName + ".rgb = toLinearSpace(" + color.associatedVariableName + ".rgb);\r\n";
    state.compilationString += output.associatedVariableName + " = applyImageProcessing(" + output.associatedVariableName + ");\r\n";
    state.compilationString += "#endif\r\n";
    state.compilationString += "#endif\r\n";
    return this;
  };
  return ImageProcessingBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.ImageProcessingBlock"] = ImageProcessingBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/perturbNormalBlock.js
var PerturbNormalBlock = function(_super) {
  __extends(PerturbNormalBlock2, _super);
  function PerturbNormalBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Fragment) || this;
    _this._tangentSpaceParameterName = "";
    _this.invertX = false;
    _this.invertY = false;
    _this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.Vector4, false);
    _this.registerInput("worldNormal", NodeMaterialBlockConnectionPointTypes.Vector4, false);
    _this.registerInput("worldTangent", NodeMaterialBlockConnectionPointTypes.Vector4, true);
    _this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.Vector2, false);
    _this.registerInput("normalMapColor", NodeMaterialBlockConnectionPointTypes.Color3, false);
    _this.registerInput("strength", NodeMaterialBlockConnectionPointTypes.Float, false);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector4);
    return _this;
  }
  PerturbNormalBlock2.prototype.getClassName = function() {
    return "PerturbNormalBlock";
  };
  Object.defineProperty(PerturbNormalBlock2.prototype, "worldPosition", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerturbNormalBlock2.prototype, "worldNormal", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerturbNormalBlock2.prototype, "worldTangent", {
    get: function() {
      return this._inputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerturbNormalBlock2.prototype, "uv", {
    get: function() {
      return this._inputs[3];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerturbNormalBlock2.prototype, "normalMapColor", {
    get: function() {
      return this._inputs[4];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerturbNormalBlock2.prototype, "strength", {
    get: function() {
      return this._inputs[5];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerturbNormalBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  PerturbNormalBlock2.prototype.prepareDefines = function(mesh, nodeMaterial, defines) {
    defines.setValue("BUMP", true);
  };
  PerturbNormalBlock2.prototype.bind = function(effect, nodeMaterial, mesh) {
    if (nodeMaterial.getScene()._mirroredCameraPosition) {
      effect.setFloat2(this._tangentSpaceParameterName, this.invertX ? 1 : -1, this.invertY ? 1 : -1);
    } else {
      effect.setFloat2(this._tangentSpaceParameterName, this.invertX ? -1 : 1, this.invertY ? -1 : 1);
    }
  };
  PerturbNormalBlock2.prototype.autoConfigure = function(material) {
    if (!this.uv.isConnected) {
      var uvInput = material.getInputBlockByPredicate(function(b) {
        return b.isAttribute && b.name === "uv";
      });
      if (!uvInput) {
        uvInput = new InputBlock("uv");
        uvInput.setAsAttribute();
      }
      uvInput.output.connectTo(this.uv);
    }
    if (!this.strength.isConnected) {
      var strengthInput = new InputBlock("strength");
      strengthInput.value = 1;
      strengthInput.output.connectTo(this.strength);
    }
  };
  PerturbNormalBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var comments = "//" + this.name;
    var uv = this.uv;
    var worldPosition = this.worldPosition;
    var worldNormal = this.worldNormal;
    var worldTangent = this.worldTangent;
    state.sharedData.blocksWithDefines.push(this);
    state.sharedData.bindableBlocks.push(this);
    this._tangentSpaceParameterName = state._getFreeDefineName("tangentSpaceParameter");
    state._emitUniformFromString(this._tangentSpaceParameterName, "vec2");
    var replaceForBumpInfos = this.strength.isConnectedToInputBlock && this.strength.connectInputBlock.isConstant ? "" + state._emitFloat(1 / this.strength.connectInputBlock.value) : "1.0 / " + this.strength.associatedVariableName;
    state._emitExtension("derivatives", "#extension GL_OES_standard_derivatives : enable");
    var tangentReplaceString = { search: /defined\(TANGENT\)/g, replace: worldTangent.isConnected ? "defined(TANGENT)" : "defined(IGNORE)" };
    if (worldTangent.isConnected) {
      state.compilationString += "vec3 tbnNormal = normalize(" + worldNormal.associatedVariableName + ".xyz);\r\n";
      state.compilationString += "vec3 tbnTangent = normalize(" + worldTangent.associatedVariableName + ".xyz);\r\n";
      state.compilationString += "vec3 tbnBitangent = cross(tbnNormal, tbnTangent);\r\n";
      state.compilationString += "mat3 vTBN = mat3(tbnTangent, tbnBitangent, tbnNormal);\r\n";
    }
    state._emitFunctionFromInclude("bumpFragmentMainFunctions", comments, {
      replaceStrings: [
        tangentReplaceString
      ]
    });
    state._emitFunctionFromInclude("bumpFragmentFunctions", comments, {
      replaceStrings: [
        { search: /vBumpInfos.y/g, replace: replaceForBumpInfos },
        { search: /vTangentSpaceParams/g, replace: this._tangentSpaceParameterName },
        { search: /vPositionW/g, replace: worldPosition.associatedVariableName + ".xyz" }
      ]
    });
    state.compilationString += this._declareOutput(this.output, state) + " = vec4(0.);\r\n";
    state.compilationString += state._emitCodeFromInclude("bumpFragment", comments, {
      replaceStrings: [
        { search: /perturbNormal\(TBN,vBumpUV\+uvOffset\)/g, replace: "perturbNormal(TBN, " + this.normalMapColor.associatedVariableName + ")" },
        { search: /vBumpInfos.y/g, replace: replaceForBumpInfos },
        { search: /vBumpUV/g, replace: uv.associatedVariableName },
        { search: /vPositionW/g, replace: worldPosition.associatedVariableName + ".xyz" },
        { search: /normalW=/g, replace: this.output.associatedVariableName + ".xyz = " },
        { search: /mat3\(normalMatrix\)\*normalW/g, replace: "mat3(normalMatrix) * " + this.output.associatedVariableName + ".xyz" },
        { search: /normalW/g, replace: worldNormal.associatedVariableName + ".xyz" },
        tangentReplaceString
      ]
    });
    return this;
  };
  PerturbNormalBlock2.prototype._dumpPropertiesCode = function() {
    var codeString = this._codeVariableName + ".invertX = " + this.invertX + ";\r\n";
    codeString += this._codeVariableName + ".invertY = " + this.invertY + ";\r\n";
    return codeString;
  };
  PerturbNormalBlock2.prototype.serialize = function() {
    var serializationObject = _super.prototype.serialize.call(this);
    serializationObject.invertX = this.invertX;
    serializationObject.invertY = this.invertY;
    return serializationObject;
  };
  PerturbNormalBlock2.prototype._deserialize = function(serializationObject, scene, rootUrl) {
    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);
    this.invertX = serializationObject.invertX;
    this.invertY = serializationObject.invertY;
  };
  __decorate([
    editableInPropertyPage("Invert X axis", PropertyTypeForEdition.Boolean, "PROPERTIES", { "notifiers": { "update": false } })
  ], PerturbNormalBlock2.prototype, "invertX", void 0);
  __decorate([
    editableInPropertyPage("Invert Y axis", PropertyTypeForEdition.Boolean, "PROPERTIES", { "notifiers": { "update": false } })
  ], PerturbNormalBlock2.prototype, "invertY", void 0);
  return PerturbNormalBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.PerturbNormalBlock"] = PerturbNormalBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/discardBlock.js
var DiscardBlock = function(_super) {
  __extends(DiscardBlock2, _super);
  function DiscardBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Fragment, true) || this;
    _this.registerInput("value", NodeMaterialBlockConnectionPointTypes.Float, true);
    _this.registerInput("cutoff", NodeMaterialBlockConnectionPointTypes.Float, true);
    return _this;
  }
  DiscardBlock2.prototype.getClassName = function() {
    return "DiscardBlock";
  };
  Object.defineProperty(DiscardBlock2.prototype, "value", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DiscardBlock2.prototype, "cutoff", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  DiscardBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    state.sharedData.hints.needAlphaTesting = true;
    if (!this.cutoff.isConnected || !this.value.isConnected) {
      return;
    }
    state.compilationString += "if (" + this.value.associatedVariableName + " < " + this.cutoff.associatedVariableName + ") discard;\r\n";
    return this;
  };
  return DiscardBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.DiscardBlock"] = DiscardBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/frontFacingBlock.js
var FrontFacingBlock = function(_super) {
  __extends(FrontFacingBlock2, _super);
  function FrontFacingBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Fragment) || this;
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    return _this;
  }
  FrontFacingBlock2.prototype.getClassName = function() {
    return "FrontFacingBlock";
  };
  Object.defineProperty(FrontFacingBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  FrontFacingBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      throw "FrontFacingBlock must only be used in a fragment shader";
    }
    var output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + " = gl_FrontFacing ? 1.0 : 0.0;\r\n";
    return this;
  };
  return FrontFacingBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.FrontFacingBlock"] = FrontFacingBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/derivativeBlock.js
var DerivativeBlock = function(_super) {
  __extends(DerivativeBlock2, _super);
  function DerivativeBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Fragment) || this;
    _this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);
    _this.registerOutput("dx", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    _this.registerOutput("dy", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    _this._outputs[0]._typeConnectionSource = _this._inputs[0];
    _this._outputs[1]._typeConnectionSource = _this._inputs[0];
    return _this;
  }
  DerivativeBlock2.prototype.getClassName = function() {
    return "DerivativeBlock";
  };
  Object.defineProperty(DerivativeBlock2.prototype, "input", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DerivativeBlock2.prototype, "dx", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DerivativeBlock2.prototype, "dy", {
    get: function() {
      return this._outputs[1];
    },
    enumerable: false,
    configurable: true
  });
  DerivativeBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var dx = this._outputs[0];
    var dy = this._outputs[1];
    state._emitExtension("derivatives", "#extension GL_OES_standard_derivatives : enable");
    if (dx.hasEndpoints) {
      state.compilationString += this._declareOutput(dx, state) + (" = dFdx(" + this.input.associatedVariableName + ");\r\n");
    }
    if (dy.hasEndpoints) {
      state.compilationString += this._declareOutput(dy, state) + (" = dFdy(" + this.input.associatedVariableName + ");\r\n");
    }
    return this;
  };
  return DerivativeBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.DerivativeBlock"] = DerivativeBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/fragCoordBlock.js
var FragCoordBlock = function(_super) {
  __extends(FragCoordBlock2, _super);
  function FragCoordBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Fragment) || this;
    _this.registerOutput("xy", NodeMaterialBlockConnectionPointTypes.Vector2, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("xyz", NodeMaterialBlockConnectionPointTypes.Vector3, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("xyzw", NodeMaterialBlockConnectionPointTypes.Vector4, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("x", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("y", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("z", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("w", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    return _this;
  }
  FragCoordBlock2.prototype.getClassName = function() {
    return "FragCoordBlock";
  };
  Object.defineProperty(FragCoordBlock2.prototype, "xy", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FragCoordBlock2.prototype, "xyz", {
    get: function() {
      return this._outputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FragCoordBlock2.prototype, "xyzw", {
    get: function() {
      return this._outputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FragCoordBlock2.prototype, "x", {
    get: function() {
      return this._outputs[3];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FragCoordBlock2.prototype, "y", {
    get: function() {
      return this._outputs[4];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FragCoordBlock2.prototype, "z", {
    get: function() {
      return this._outputs[5];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FragCoordBlock2.prototype, "output", {
    get: function() {
      return this._outputs[6];
    },
    enumerable: false,
    configurable: true
  });
  FragCoordBlock2.prototype.writeOutputs = function(state) {
    var code = "";
    for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {
      var output = _a[_i];
      if (output.hasEndpoints) {
        code += this._declareOutput(output, state) + " = gl_FragCoord." + output.name + ";\r\n";
      }
    }
    return code;
  };
  FragCoordBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      throw "FragCoordBlock must only be used in a fragment shader";
    }
    state.compilationString += this.writeOutputs(state);
    return this;
  };
  return FragCoordBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.FragCoordBlock"] = FragCoordBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/screenSizeBlock.js
var ScreenSizeBlock = function(_super) {
  __extends(ScreenSizeBlock2, _super);
  function ScreenSizeBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Fragment) || this;
    _this.registerOutput("xy", NodeMaterialBlockConnectionPointTypes.Vector2, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("x", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("y", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    return _this;
  }
  ScreenSizeBlock2.prototype.getClassName = function() {
    return "ScreenSizeBlock";
  };
  Object.defineProperty(ScreenSizeBlock2.prototype, "xy", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScreenSizeBlock2.prototype, "x", {
    get: function() {
      return this._outputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScreenSizeBlock2.prototype, "y", {
    get: function() {
      return this._outputs[2];
    },
    enumerable: false,
    configurable: true
  });
  ScreenSizeBlock2.prototype.bind = function(effect, nodeMaterial, mesh) {
    var engine = this._scene.getEngine();
    effect.setFloat2(this._varName, engine.getRenderWidth(), engine.getRenderWidth());
  };
  ScreenSizeBlock2.prototype.writeOutputs = function(state, varName) {
    var code = "";
    for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {
      var output = _a[_i];
      if (output.hasEndpoints) {
        code += this._declareOutput(output, state) + " = " + varName + "." + output.name + ";\r\n";
      }
    }
    return code;
  };
  ScreenSizeBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    this._scene = state.sharedData.scene;
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      throw "ScreenSizeBlock must only be used in a fragment shader";
    }
    state.sharedData.bindableBlocks.push(this);
    this._varName = state._getFreeVariableName("screenSize");
    state._emitUniformFromString(this._varName, "vec2");
    state.compilationString += this.writeOutputs(state, this._varName);
    return this;
  };
  return ScreenSizeBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.ScreenSizeBlock"] = ScreenSizeBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/fogBlock.js
var FogBlock = function(_super) {
  __extends(FogBlock2, _super);
  function FogBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.VertexAndFragment, true) || this;
    _this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);
    _this.registerInput("view", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Vertex);
    _this.registerInput("input", NodeMaterialBlockConnectionPointTypes.Color3, false, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("fogColor", NodeMaterialBlockConnectionPointTypes.Color3, false, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    _this.input.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Color4);
    _this.fogColor.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Color4);
    return _this;
  }
  FogBlock2.prototype.getClassName = function() {
    return "FogBlock";
  };
  Object.defineProperty(FogBlock2.prototype, "worldPosition", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FogBlock2.prototype, "view", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FogBlock2.prototype, "input", {
    get: function() {
      return this._inputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FogBlock2.prototype, "fogColor", {
    get: function() {
      return this._inputs[3];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FogBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  FogBlock2.prototype.autoConfigure = function(material) {
    if (!this.view.isConnected) {
      var viewInput = material.getInputBlockByPredicate(function(b) {
        return b.systemValue === NodeMaterialSystemValues.View;
      });
      if (!viewInput) {
        viewInput = new InputBlock("view");
        viewInput.setAsSystemValue(NodeMaterialSystemValues.View);
      }
      viewInput.output.connectTo(this.view);
    }
    if (!this.fogColor.isConnected) {
      var fogColorInput = material.getInputBlockByPredicate(function(b) {
        return b.systemValue === NodeMaterialSystemValues.FogColor;
      });
      if (!fogColorInput) {
        fogColorInput = new InputBlock("fogColor", void 0, NodeMaterialBlockConnectionPointTypes.Color3);
        fogColorInput.setAsSystemValue(NodeMaterialSystemValues.FogColor);
      }
      fogColorInput.output.connectTo(this.fogColor);
    }
  };
  FogBlock2.prototype.prepareDefines = function(mesh, nodeMaterial, defines) {
    var scene = mesh.getScene();
    defines.setValue("FOG", nodeMaterial.fogEnabled && MaterialHelper.GetFogState(mesh, scene));
  };
  FogBlock2.prototype.bind = function(effect, nodeMaterial, mesh) {
    if (!mesh) {
      return;
    }
    var scene = mesh.getScene();
    effect.setFloat4(this._fogParameters, scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);
  };
  FogBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    if (state.target === NodeMaterialBlockTargets.Fragment) {
      state.sharedData.blocksWithDefines.push(this);
      state.sharedData.bindableBlocks.push(this);
      state._emitFunctionFromInclude("fogFragmentDeclaration", "//" + this.name, {
        removeUniforms: true,
        removeVaryings: true,
        removeIfDef: false,
        replaceStrings: [{ search: /float CalcFogFactor\(\)/, replace: "float CalcFogFactor(vec3 vFogDistance, vec4 vFogInfos)" }]
      });
      var tempFogVariablename = state._getFreeVariableName("fog");
      var color = this.input;
      var fogColor = this.fogColor;
      this._fogParameters = state._getFreeVariableName("fogParameters");
      var output = this._outputs[0];
      state._emitUniformFromString(this._fogParameters, "vec4");
      state.compilationString += "#ifdef FOG\r\n";
      state.compilationString += "float " + tempFogVariablename + " = CalcFogFactor(" + this._fogDistanceName + ", " + this._fogParameters + ");\r\n";
      state.compilationString += this._declareOutput(output, state) + (" = " + tempFogVariablename + " * " + color.associatedVariableName + ".rgb + (1.0 - " + tempFogVariablename + ") * " + fogColor.associatedVariableName + ".rgb;\r\n");
      state.compilationString += "#else\r\n" + this._declareOutput(output, state) + " =  " + color.associatedVariableName + ".rgb;\r\n";
      state.compilationString += "#endif\r\n";
    } else {
      var worldPos = this.worldPosition;
      var view = this.view;
      this._fogDistanceName = state._getFreeVariableName("vFogDistance");
      state._emitVaryingFromString(this._fogDistanceName, "vec3");
      state.compilationString += this._fogDistanceName + " = (" + view.associatedVariableName + " * " + worldPos.associatedVariableName + ").xyz;\r\n";
    }
    return this;
  };
  return FogBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.FogBlock"] = FogBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/lightBlock.js
var LightBlock = function(_super) {
  __extends(LightBlock2, _super);
  function LightBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.VertexAndFragment) || this;
    _this._isUnique = true;
    _this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);
    _this.registerInput("worldNormal", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("cameraPosition", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("glossiness", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("glossPower", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("diffuseColor", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("specularColor", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("view", NodeMaterialBlockConnectionPointTypes.Matrix, true);
    _this.registerOutput("diffuseOutput", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("specularOutput", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("shadow", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    return _this;
  }
  LightBlock2.prototype.getClassName = function() {
    return "LightBlock";
  };
  Object.defineProperty(LightBlock2.prototype, "worldPosition", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LightBlock2.prototype, "worldNormal", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LightBlock2.prototype, "cameraPosition", {
    get: function() {
      return this._inputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LightBlock2.prototype, "glossiness", {
    get: function() {
      return this._inputs[3];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LightBlock2.prototype, "glossPower", {
    get: function() {
      return this._inputs[4];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LightBlock2.prototype, "diffuseColor", {
    get: function() {
      return this._inputs[5];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LightBlock2.prototype, "specularColor", {
    get: function() {
      return this._inputs[6];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LightBlock2.prototype, "view", {
    get: function() {
      return this._inputs[7];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LightBlock2.prototype, "diffuseOutput", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LightBlock2.prototype, "specularOutput", {
    get: function() {
      return this._outputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LightBlock2.prototype, "shadow", {
    get: function() {
      return this._outputs[2];
    },
    enumerable: false,
    configurable: true
  });
  LightBlock2.prototype.autoConfigure = function(material) {
    if (!this.cameraPosition.isConnected) {
      var cameraPositionInput = material.getInputBlockByPredicate(function(b) {
        return b.systemValue === NodeMaterialSystemValues.CameraPosition;
      });
      if (!cameraPositionInput) {
        cameraPositionInput = new InputBlock("cameraPosition");
        cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);
      }
      cameraPositionInput.output.connectTo(this.cameraPosition);
    }
  };
  LightBlock2.prototype.prepareDefines = function(mesh, nodeMaterial, defines) {
    if (!defines._areLightsDirty) {
      return;
    }
    var scene = mesh.getScene();
    if (!this.light) {
      MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, nodeMaterial.maxSimultaneousLights);
    } else {
      var state = {
        needNormals: false,
        needRebuild: false,
        lightmapMode: false,
        shadowEnabled: false,
        specularEnabled: false
      };
      MaterialHelper.PrepareDefinesForLight(scene, mesh, this.light, this._lightId, defines, true, state);
      if (state.needRebuild) {
        defines.rebuild();
      }
    }
  };
  LightBlock2.prototype.updateUniformsAndSamples = function(state, nodeMaterial, defines, uniformBuffers) {
    for (var lightIndex = 0; lightIndex < nodeMaterial.maxSimultaneousLights; lightIndex++) {
      if (!defines["LIGHT" + lightIndex]) {
        break;
      }
      var onlyUpdateBuffersList = state.uniforms.indexOf("vLightData" + lightIndex) >= 0;
      MaterialHelper.PrepareUniformsAndSamplersForLight(lightIndex, state.uniforms, state.samplers, defines["PROJECTEDLIGHTTEXTURE" + lightIndex], uniformBuffers, onlyUpdateBuffersList);
    }
  };
  LightBlock2.prototype.bind = function(effect, nodeMaterial, mesh) {
    if (!mesh) {
      return;
    }
    var scene = mesh.getScene();
    if (!this.light) {
      MaterialHelper.BindLights(scene, mesh, effect, true, nodeMaterial.maxSimultaneousLights);
    } else {
      MaterialHelper.BindLight(this.light, this._lightId, scene, effect, true);
    }
  };
  LightBlock2.prototype._injectVertexCode = function(state) {
    var worldPos = this.worldPosition;
    var comments = "//" + this.name;
    if (!this.light) {
      state._emitFunctionFromInclude(state.supportUniformBuffers ? "lightUboDeclaration" : "lightFragmentDeclaration", comments, {
        repeatKey: "maxSimultaneousLights"
      });
      this._lightId = 0;
      state.sharedData.dynamicUniformBlocks.push(this);
    } else {
      this._lightId = (state.counters["lightCounter"] !== void 0 ? state.counters["lightCounter"] : -1) + 1;
      state.counters["lightCounter"] = this._lightId;
      state._emitFunctionFromInclude(state.supportUniformBuffers ? "lightUboDeclaration" : "lightFragmentDeclaration", comments, {
        replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }]
      }, this._lightId.toString());
    }
    var worldPosVaryingName = "v_" + worldPos.associatedVariableName;
    if (state._emitVaryingFromString(worldPosVaryingName, "vec4")) {
      state.compilationString += worldPosVaryingName + " = " + worldPos.associatedVariableName + ";\r\n";
    }
    if (this.light) {
      state.compilationString += state._emitCodeFromInclude("shadowsVertex", comments, {
        replaceStrings: [
          { search: /{X}/g, replace: this._lightId.toString() },
          { search: /worldPos/g, replace: worldPos.associatedVariableName }
        ]
      });
    } else {
      state.compilationString += "vec4 worldPos = " + worldPos.associatedVariableName + ";\r\n";
      if (this.view.isConnected) {
        state.compilationString += "mat4 view = " + this.view.associatedVariableName + ";\r\n";
      }
      state.compilationString += state._emitCodeFromInclude("shadowsVertex", comments, {
        repeatKey: "maxSimultaneousLights"
      });
    }
  };
  LightBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    if (state.target !== NodeMaterialBlockTargets.Fragment) {
      this._injectVertexCode(state);
      return;
    }
    state.sharedData.bindableBlocks.push(this);
    state.sharedData.blocksWithDefines.push(this);
    var comments = "//" + this.name;
    var worldPos = this.worldPosition;
    state._emitFunctionFromInclude("helperFunctions", comments);
    state._emitFunctionFromInclude("lightsFragmentFunctions", comments, {
      replaceStrings: [
        { search: /vPositionW/g, replace: "v_" + worldPos.associatedVariableName + ".xyz" }
      ]
    });
    state._emitFunctionFromInclude("shadowsFragmentFunctions", comments, {
      replaceStrings: [
        { search: /vPositionW/g, replace: "v_" + worldPos.associatedVariableName + ".xyz" }
      ]
    });
    if (!this.light) {
      state._emitFunctionFromInclude(state.supportUniformBuffers ? "lightUboDeclaration" : "lightFragmentDeclaration", comments, {
        repeatKey: "maxSimultaneousLights"
      });
    } else {
      state._emitFunctionFromInclude(state.supportUniformBuffers ? "lightUboDeclaration" : "lightFragmentDeclaration", comments, {
        replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }]
      }, this._lightId.toString());
    }
    if (this._lightId === 0) {
      if (state._registerTempVariable("viewDirectionW")) {
        state.compilationString += "vec3 viewDirectionW = normalize(" + this.cameraPosition.associatedVariableName + " - " + ("v_" + worldPos.associatedVariableName) + ".xyz);\r\n";
      }
      state.compilationString += "lightingInfo info;\r\n";
      state.compilationString += "float shadow = 1.;\r\n";
      state.compilationString += "float glossiness = " + (this.glossiness.isConnected ? this.glossiness.associatedVariableName : "1.0") + " * " + (this.glossPower.isConnected ? this.glossPower.associatedVariableName : "1024.0") + ";\r\n";
      state.compilationString += "vec3 diffuseBase = vec3(0., 0., 0.);\r\n";
      state.compilationString += "vec3 specularBase = vec3(0., 0., 0.);\r\n";
      state.compilationString += "vec3 normalW = " + this.worldNormal.associatedVariableName + ".xyz;\r\n";
    }
    if (this.light) {
      state.compilationString += state._emitCodeFromInclude("lightFragment", comments, {
        replaceStrings: [
          { search: /{X}/g, replace: this._lightId.toString() }
        ]
      });
    } else {
      state.compilationString += state._emitCodeFromInclude("lightFragment", comments, {
        repeatKey: "maxSimultaneousLights"
      });
    }
    var diffuseOutput = this.diffuseOutput;
    var specularOutput = this.specularOutput;
    state.compilationString += this._declareOutput(diffuseOutput, state) + (" = diffuseBase" + (this.diffuseColor.isConnected ? " * " + this.diffuseColor.associatedVariableName : "") + ";\r\n");
    if (specularOutput.hasEndpoints) {
      state.compilationString += this._declareOutput(specularOutput, state) + (" = specularBase" + (this.specularColor.isConnected ? " * " + this.specularColor.associatedVariableName : "") + ";\r\n");
    }
    if (this.shadow.hasEndpoints) {
      state.compilationString += this._declareOutput(this.shadow, state) + " = shadow;\r\n";
    }
    return this;
  };
  LightBlock2.prototype.serialize = function() {
    var serializationObject = _super.prototype.serialize.call(this);
    if (this.light) {
      serializationObject.lightId = this.light.id;
    }
    return serializationObject;
  };
  LightBlock2.prototype._deserialize = function(serializationObject, scene, rootUrl) {
    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);
    if (serializationObject.lightId) {
      this.light = scene.getLightByID(serializationObject.lightId);
    }
  };
  return LightBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.LightBlock"] = LightBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/textureBlock.js
var TextureBlock = function(_super) {
  __extends(TextureBlock2, _super);
  function TextureBlock2(name98, fragmentOnly) {
    if (fragmentOnly === void 0) {
      fragmentOnly = false;
    }
    var _this = _super.call(this, name98, fragmentOnly ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment) || this;
    _this.convertToGammaSpace = false;
    _this.convertToLinearSpace = false;
    _this._fragmentOnly = fragmentOnly;
    _this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.Vector2, false, NodeMaterialBlockTargets.VertexAndFragment);
    _this.registerOutput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);
    _this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);
    _this.registerOutput("r", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    _this.registerOutput("g", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    _this.registerOutput("b", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    _this.registerOutput("a", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);
    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector4);
    _this._inputs[0]._prioritizeVertex = !fragmentOnly;
    return _this;
  }
  TextureBlock2.prototype.getClassName = function() {
    return "TextureBlock";
  };
  Object.defineProperty(TextureBlock2.prototype, "uv", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextureBlock2.prototype, "rgba", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextureBlock2.prototype, "rgb", {
    get: function() {
      return this._outputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextureBlock2.prototype, "r", {
    get: function() {
      return this._outputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextureBlock2.prototype, "g", {
    get: function() {
      return this._outputs[3];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextureBlock2.prototype, "b", {
    get: function() {
      return this._outputs[4];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextureBlock2.prototype, "a", {
    get: function() {
      return this._outputs[5];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextureBlock2.prototype, "target", {
    get: function() {
      if (this._fragmentOnly) {
        return NodeMaterialBlockTargets.Fragment;
      }
      if (!this.uv.isConnected) {
        return NodeMaterialBlockTargets.VertexAndFragment;
      }
      if (this.uv.sourceBlock.isInput) {
        return NodeMaterialBlockTargets.VertexAndFragment;
      }
      var parent = this.uv.connectedPoint;
      while (parent) {
        if (parent.target === NodeMaterialBlockTargets.Fragment) {
          return NodeMaterialBlockTargets.Fragment;
        }
        if (parent.target === NodeMaterialBlockTargets.Vertex) {
          return NodeMaterialBlockTargets.VertexAndFragment;
        }
        if (parent.target === NodeMaterialBlockTargets.Neutral || parent.target === NodeMaterialBlockTargets.VertexAndFragment) {
          var parentBlock = parent.ownerBlock;
          parent = null;
          for (var _i = 0, _a = parentBlock.inputs; _i < _a.length; _i++) {
            var input = _a[_i];
            if (input.connectedPoint) {
              parent = input.connectedPoint;
              break;
            }
          }
        }
      }
      return NodeMaterialBlockTargets.VertexAndFragment;
    },
    enumerable: false,
    configurable: true
  });
  TextureBlock2.prototype.autoConfigure = function(material) {
    if (!this.uv.isConnected) {
      if (material.mode === NodeMaterialModes.PostProcess) {
        var uvInput = material.getBlockByPredicate(function(b) {
          return b.name === "uv";
        });
        if (uvInput) {
          uvInput.connectTo(this);
        }
      } else {
        var attributeName_1 = material.mode === NodeMaterialModes.Particle ? "particle_uv" : "uv";
        var uvInput = material.getInputBlockByPredicate(function(b) {
          return b.isAttribute && b.name === attributeName_1;
        });
        if (!uvInput) {
          uvInput = new InputBlock("uv");
          uvInput.setAsAttribute(attributeName_1);
        }
        uvInput.output.connectTo(this.uv);
      }
    }
  };
  TextureBlock2.prototype.initializeDefines = function(mesh, nodeMaterial, defines, useInstances) {
    if (useInstances === void 0) {
      useInstances = false;
    }
    if (!defines._areTexturesDirty) {
      return;
    }
    defines.setValue(this._mainUVDefineName, false);
  };
  TextureBlock2.prototype.prepareDefines = function(mesh, nodeMaterial, defines) {
    if (!defines._areTexturesDirty) {
      return;
    }
    if (!this.texture || !this.texture.getTextureMatrix) {
      defines.setValue(this._defineName, false);
      defines.setValue(this._mainUVDefineName, true);
      return;
    }
    defines.setValue(this._linearDefineName, this.convertToGammaSpace);
    defines.setValue(this._gammaDefineName, this.convertToLinearSpace);
    if (this._isMixed) {
      if (!this.texture.getTextureMatrix().isIdentityAs3x2()) {
        defines.setValue(this._defineName, true);
      } else {
        defines.setValue(this._defineName, false);
        defines.setValue(this._mainUVDefineName, true);
      }
    }
  };
  TextureBlock2.prototype.isReady = function() {
    if (this.texture && !this.texture.isReadyOrNotBlocking()) {
      return false;
    }
    return true;
  };
  TextureBlock2.prototype.bind = function(effect, nodeMaterial, mesh) {
    if (!this.texture) {
      return;
    }
    if (this._isMixed) {
      effect.setFloat(this._textureInfoName, this.texture.level);
      effect.setMatrix(this._textureTransformName, this.texture.getTextureMatrix());
    }
    effect.setTexture(this._samplerName, this.texture);
  };
  Object.defineProperty(TextureBlock2.prototype, "_isMixed", {
    get: function() {
      return this.target !== NodeMaterialBlockTargets.Fragment;
    },
    enumerable: false,
    configurable: true
  });
  TextureBlock2.prototype._injectVertexCode = function(state) {
    var uvInput = this.uv;
    this._defineName = state._getFreeDefineName("UVTRANSFORM");
    this._mainUVDefineName = "VMAIN" + uvInput.associatedVariableName.toUpperCase();
    if (uvInput.connectedPoint.ownerBlock.isInput) {
      var uvInputOwnerBlock = uvInput.connectedPoint.ownerBlock;
      if (!uvInputOwnerBlock.isAttribute) {
        state._emitUniformFromString(uvInput.associatedVariableName, "vec2");
      }
    }
    this._mainUVName = "vMain" + uvInput.associatedVariableName;
    this._transformedUVName = state._getFreeVariableName("transformedUV");
    this._textureTransformName = state._getFreeVariableName("textureTransform");
    this._textureInfoName = state._getFreeVariableName("textureInfoName");
    state._emitVaryingFromString(this._transformedUVName, "vec2", this._defineName);
    state._emitVaryingFromString(this._mainUVName, "vec2", this._mainUVDefineName);
    state._emitUniformFromString(this._textureTransformName, "mat4", this._defineName);
    state.compilationString += "#ifdef " + this._defineName + "\r\n";
    state.compilationString += this._transformedUVName + " = vec2(" + this._textureTransformName + " * vec4(" + uvInput.associatedVariableName + ".xy, 1.0, 0.0));\r\n";
    state.compilationString += "#elif defined(" + this._mainUVDefineName + ")\r\n";
    state.compilationString += this._mainUVName + " = " + uvInput.associatedVariableName + ".xy;\r\n";
    state.compilationString += "#endif\r\n";
    if (!this._outputs.some(function(o) {
      return o.isConnectedInVertexShader;
    })) {
      return;
    }
    this._writeTextureRead(state, true);
    for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {
      var output = _a[_i];
      if (output.hasEndpoints) {
        this._writeOutput(state, output, output.name, true);
      }
    }
  };
  TextureBlock2.prototype._writeTextureRead = function(state, vertexMode) {
    if (vertexMode === void 0) {
      vertexMode = false;
    }
    var uvInput = this.uv;
    if (vertexMode) {
      if (state.target === NodeMaterialBlockTargets.Fragment) {
        return;
      }
      state.compilationString += "vec4 " + this._tempTextureRead + " = texture2D(" + this._samplerName + ", " + uvInput.associatedVariableName + ");\r\n";
      return;
    }
    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      state.compilationString += "vec4 " + this._tempTextureRead + " = texture2D(" + this._samplerName + ", " + uvInput.associatedVariableName + ");\r\n";
      return;
    }
    state.compilationString += "#ifdef " + this._defineName + "\r\n";
    state.compilationString += "vec4 " + this._tempTextureRead + " = texture2D(" + this._samplerName + ", " + this._transformedUVName + ");\r\n";
    state.compilationString += "#elif defined(" + this._mainUVDefineName + ")\r\n";
    state.compilationString += "vec4 " + this._tempTextureRead + " = texture2D(" + this._samplerName + ", " + this._mainUVName + ");\r\n";
    state.compilationString += "#endif\r\n";
  };
  TextureBlock2.prototype._writeOutput = function(state, output, swizzle, vertexMode) {
    if (vertexMode === void 0) {
      vertexMode = false;
    }
    if (vertexMode) {
      if (state.target === NodeMaterialBlockTargets.Fragment) {
        return;
      }
      state.compilationString += this._declareOutput(output, state) + " = " + this._tempTextureRead + "." + swizzle + ";\r\n";
      return;
    }
    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      state.compilationString += this._declareOutput(output, state) + " = " + this._tempTextureRead + "." + swizzle + ";\r\n";
      return;
    }
    var complement = " * " + this._textureInfoName;
    state.compilationString += this._declareOutput(output, state) + " = " + this._tempTextureRead + "." + swizzle + complement + ";\r\n";
    if (swizzle !== "a") {
      state.compilationString += "#ifdef " + this._linearDefineName + "\r\n";
      state.compilationString += output.associatedVariableName + " = toGammaSpace(" + output.associatedVariableName + ");\r\n";
      state.compilationString += "#endif\r\n";
      state.compilationString += "#ifdef " + this._gammaDefineName + "\r\n";
      state.compilationString += output.associatedVariableName + " = toLinearSpace(" + output.associatedVariableName + ");\r\n";
      state.compilationString += "#endif\r\n";
    }
  };
  TextureBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    if (state.target === NodeMaterialBlockTargets.Vertex || this._fragmentOnly) {
      this._tempTextureRead = state._getFreeVariableName("tempTextureRead");
    }
    if (!this._isMixed && state.target === NodeMaterialBlockTargets.Fragment || this._isMixed && state.target === NodeMaterialBlockTargets.Vertex) {
      this._samplerName = state._getFreeVariableName(this.name + "Sampler");
      state._emit2DSampler(this._samplerName);
      state.sharedData.blockingBlocks.push(this);
      state.sharedData.textureBlocks.push(this);
      state.sharedData.blocksWithDefines.push(this);
      state.sharedData.bindableBlocks.push(this);
    }
    if (state.target !== NodeMaterialBlockTargets.Fragment) {
      this._injectVertexCode(state);
      return;
    }
    if (!this._outputs.some(function(o) {
      return o.isConnectedInFragmentShader;
    })) {
      return;
    }
    if (this._isMixed) {
      state._emit2DSampler(this._samplerName);
    }
    this._linearDefineName = state._getFreeDefineName("ISLINEAR");
    this._gammaDefineName = state._getFreeDefineName("ISGAMMA");
    var comments = "//" + this.name;
    state._emitFunctionFromInclude("helperFunctions", comments);
    if (this._isMixed) {
      state._emitUniformFromString(this._textureInfoName, "float");
    }
    this._writeTextureRead(state);
    for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {
      var output = _a[_i];
      if (output.hasEndpoints) {
        this._writeOutput(state, output, output.name);
      }
    }
    return this;
  };
  TextureBlock2.prototype._dumpPropertiesCode = function() {
    if (!this.texture) {
      return "";
    }
    var codeString = this._codeVariableName + '.texture = new BABYLON.Texture("' + this.texture.name + '", null);\r\n';
    codeString += this._codeVariableName + ".texture.wrapU = " + this.texture.wrapU + ";\r\n";
    codeString += this._codeVariableName + ".texture.wrapV = " + this.texture.wrapV + ";\r\n";
    codeString += this._codeVariableName + ".texture.uAng = " + this.texture.uAng + ";\r\n";
    codeString += this._codeVariableName + ".texture.vAng = " + this.texture.vAng + ";\r\n";
    codeString += this._codeVariableName + ".texture.wAng = " + this.texture.wAng + ";\r\n";
    codeString += this._codeVariableName + ".texture.uOffset = " + this.texture.uOffset + ";\r\n";
    codeString += this._codeVariableName + ".texture.vOffset = " + this.texture.vOffset + ";\r\n";
    codeString += this._codeVariableName + ".texture.uScale = " + this.texture.uScale + ";\r\n";
    codeString += this._codeVariableName + ".texture.vScale = " + this.texture.vScale + ";\r\n";
    codeString += this._codeVariableName + ".convertToGammaSpace = " + this.convertToGammaSpace + ";\r\n";
    codeString += this._codeVariableName + ".convertToLinearSpace = " + this.convertToLinearSpace + ";\r\n";
    return codeString;
  };
  TextureBlock2.prototype.serialize = function() {
    var serializationObject = _super.prototype.serialize.call(this);
    serializationObject.convertToGammaSpace = this.convertToGammaSpace;
    serializationObject.convertToLinearSpace = this.convertToLinearSpace;
    serializationObject.fragmentOnly = this._fragmentOnly;
    if (this.texture && !this.texture.isRenderTarget) {
      serializationObject.texture = this.texture.serialize();
    }
    return serializationObject;
  };
  TextureBlock2.prototype._deserialize = function(serializationObject, scene, rootUrl) {
    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);
    this.convertToGammaSpace = serializationObject.convertToGammaSpace;
    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;
    this._fragmentOnly = !!serializationObject.fragmentOnly;
    if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime) {
      rootUrl = serializationObject.texture.url.indexOf("data:") === 0 ? "" : rootUrl;
      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);
    }
  };
  return TextureBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.TextureBlock"] = TextureBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/reflectionTextureBaseBlock.js
var ReflectionTextureBaseBlock = function(_super) {
  __extends(ReflectionTextureBaseBlock2, _super);
  function ReflectionTextureBaseBlock2(name98) {
    return _super.call(this, name98, NodeMaterialBlockTargets.VertexAndFragment) || this;
  }
  ReflectionTextureBaseBlock2.prototype.getClassName = function() {
    return "ReflectionTextureBaseBlock";
  };
  ReflectionTextureBaseBlock2.prototype._getTexture = function() {
    return this.texture;
  };
  ReflectionTextureBaseBlock2.prototype.autoConfigure = function(material) {
    if (!this.position.isConnected) {
      var positionInput = material.getInputBlockByPredicate(function(b) {
        return b.isAttribute && b.name === "position";
      });
      if (!positionInput) {
        positionInput = new InputBlock("position");
        positionInput.setAsAttribute();
      }
      positionInput.output.connectTo(this.position);
    }
    if (!this.world.isConnected) {
      var worldInput = material.getInputBlockByPredicate(function(b) {
        return b.systemValue === NodeMaterialSystemValues.World;
      });
      if (!worldInput) {
        worldInput = new InputBlock("world");
        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);
      }
      worldInput.output.connectTo(this.world);
    }
    if (this.view && !this.view.isConnected) {
      var viewInput = material.getInputBlockByPredicate(function(b) {
        return b.systemValue === NodeMaterialSystemValues.View;
      });
      if (!viewInput) {
        viewInput = new InputBlock("view");
        viewInput.setAsSystemValue(NodeMaterialSystemValues.View);
      }
      viewInput.output.connectTo(this.view);
    }
  };
  ReflectionTextureBaseBlock2.prototype.prepareDefines = function(mesh, nodeMaterial, defines) {
    if (!defines._areTexturesDirty) {
      return;
    }
    var texture = this._getTexture();
    if (!texture || !texture.getTextureMatrix) {
      return;
    }
    defines.setValue(this._define3DName, texture.isCube, true);
    defines.setValue(this._defineLocalCubicName, texture.boundingBoxSize ? true : false, true);
    defines.setValue(this._defineExplicitName, texture.coordinatesMode === 0, true);
    defines.setValue(this._defineSkyboxName, texture.coordinatesMode === 5, true);
    defines.setValue(this._defineCubicName, texture.coordinatesMode === 3 || texture.coordinatesMode === 6, true);
    defines.setValue("INVERTCUBICMAP", texture.coordinatesMode === 6, true);
    defines.setValue(this._defineSphericalName, texture.coordinatesMode === 1, true);
    defines.setValue(this._definePlanarName, texture.coordinatesMode === 2, true);
    defines.setValue(this._defineProjectionName, texture.coordinatesMode === 4, true);
    defines.setValue(this._defineEquirectangularName, texture.coordinatesMode === 7, true);
    defines.setValue(this._defineEquirectangularFixedName, texture.coordinatesMode === 8, true);
    defines.setValue(this._defineMirroredEquirectangularFixedName, texture.coordinatesMode === 9, true);
  };
  ReflectionTextureBaseBlock2.prototype.isReady = function() {
    var texture = this._getTexture();
    if (texture && !texture.isReadyOrNotBlocking()) {
      return false;
    }
    return true;
  };
  ReflectionTextureBaseBlock2.prototype.bind = function(effect, nodeMaterial, mesh) {
    var texture = this._getTexture();
    if (!mesh || !texture) {
      return;
    }
    effect.setMatrix(this._reflectionMatrixName, texture.getReflectionTextureMatrix());
    if (texture.isCube) {
      effect.setTexture(this._cubeSamplerName, texture);
    } else {
      effect.setTexture(this._2DSamplerName, texture);
    }
  };
  ReflectionTextureBaseBlock2.prototype.handleVertexSide = function(state) {
    this._define3DName = state._getFreeDefineName("REFLECTIONMAP_3D");
    this._defineCubicName = state._getFreeDefineName("REFLECTIONMAP_CUBIC");
    this._defineSphericalName = state._getFreeDefineName("REFLECTIONMAP_SPHERICAL");
    this._definePlanarName = state._getFreeDefineName("REFLECTIONMAP_PLANAR");
    this._defineProjectionName = state._getFreeDefineName("REFLECTIONMAP_PROJECTION");
    this._defineExplicitName = state._getFreeDefineName("REFLECTIONMAP_EXPLICIT");
    this._defineEquirectangularName = state._getFreeDefineName("REFLECTIONMAP_EQUIRECTANGULAR");
    this._defineLocalCubicName = state._getFreeDefineName("USE_LOCAL_REFLECTIONMAP_CUBIC");
    this._defineMirroredEquirectangularFixedName = state._getFreeDefineName("REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED");
    this._defineEquirectangularFixedName = state._getFreeDefineName("REFLECTIONMAP_EQUIRECTANGULAR_FIXED");
    this._defineSkyboxName = state._getFreeDefineName("REFLECTIONMAP_SKYBOX");
    this._defineOppositeZ = state._getFreeDefineName("REFLECTIONMAP_OPPOSITEZ");
    this._reflectionMatrixName = state._getFreeVariableName("reflectionMatrix");
    state._emitUniformFromString(this._reflectionMatrixName, "mat4");
    var code = "";
    var worldPosVaryingName = "v_" + this.worldPosition.associatedVariableName;
    if (state._emitVaryingFromString(worldPosVaryingName, "vec4")) {
      code += worldPosVaryingName + " = " + this.worldPosition.associatedVariableName + ";\r\n";
    }
    this._positionUVWName = state._getFreeVariableName("positionUVW");
    this._directionWName = state._getFreeVariableName("directionW");
    if (state._emitVaryingFromString(this._positionUVWName, "vec3", this._defineSkyboxName)) {
      code += "#ifdef " + this._defineSkyboxName + "\r\n";
      code += this._positionUVWName + " = " + this.position.associatedVariableName + ".xyz;\r\n";
      code += "#endif\r\n";
    }
    if (state._emitVaryingFromString(this._directionWName, "vec3", "defined(" + this._defineEquirectangularFixedName + ") || defined(" + this._defineMirroredEquirectangularFixedName + ")")) {
      code += "#if defined(" + this._defineEquirectangularFixedName + ") || defined(" + this._defineMirroredEquirectangularFixedName + ")\r\n";
      code += this._directionWName + " = normalize(vec3(" + this.world.associatedVariableName + " * vec4(" + this.position.associatedVariableName + ".xyz, 0.0)));\r\n";
      code += "#endif\r\n";
    }
    return code;
  };
  ReflectionTextureBaseBlock2.prototype.handleFragmentSideInits = function(state) {
    state.sharedData.blockingBlocks.push(this);
    state.sharedData.textureBlocks.push(this);
    this._cubeSamplerName = state._getFreeVariableName(this.name + "CubeSampler");
    state.samplers.push(this._cubeSamplerName);
    this._2DSamplerName = state._getFreeVariableName(this.name + "2DSampler");
    state.samplers.push(this._2DSamplerName);
    state._samplerDeclaration += "#ifdef " + this._define3DName + "\r\n";
    state._samplerDeclaration += "uniform samplerCube " + this._cubeSamplerName + ";\r\n";
    state._samplerDeclaration += "#else\r\n";
    state._samplerDeclaration += "uniform sampler2D " + this._2DSamplerName + ";\r\n";
    state._samplerDeclaration += "#endif\r\n";
    state.sharedData.blocksWithDefines.push(this);
    state.sharedData.bindableBlocks.push(this);
    var comments = "//" + this.name;
    state._emitFunction("ReciprocalPI", "#define RECIPROCAL_PI2 0.15915494", "");
    state._emitFunctionFromInclude("reflectionFunction", comments, {
      replaceStrings: [
        { search: /vec3 computeReflectionCoords/g, replace: "void DUMMYFUNC" }
      ]
    });
    this._reflectionColorName = state._getFreeVariableName("reflectionColor");
    this._reflectionVectorName = state._getFreeVariableName("reflectionUVW");
    this._reflectionCoordsName = state._getFreeVariableName("reflectionCoords");
  };
  ReflectionTextureBaseBlock2.prototype.handleFragmentSideCodeReflectionCoords = function(worldNormalVarName, worldPos, onlyReflectionVector) {
    if (onlyReflectionVector === void 0) {
      onlyReflectionVector = false;
    }
    if (!worldPos) {
      worldPos = "v_" + this.worldPosition.associatedVariableName;
    }
    var reflectionMatrix = this._reflectionMatrixName;
    var direction = "normalize(" + this._directionWName + ")";
    var positionUVW = "" + this._positionUVWName;
    var vEyePosition = "" + this.cameraPosition.associatedVariableName;
    var view = "" + this.view.associatedVariableName;
    worldNormalVarName += ".xyz";
    var code = "\n            #ifdef " + this._defineMirroredEquirectangularFixedName + "\n                vec3 " + this._reflectionVectorName + " = computeMirroredFixedEquirectangularCoords(" + worldPos + ", " + worldNormalVarName + ", " + direction + ");\n            #endif\n\n            #ifdef " + this._defineEquirectangularFixedName + "\n                vec3 " + this._reflectionVectorName + " = computeFixedEquirectangularCoords(" + worldPos + ", " + worldNormalVarName + ", " + direction + ");\n            #endif\n\n            #ifdef " + this._defineEquirectangularName + "\n                vec3 " + this._reflectionVectorName + " = computeEquirectangularCoords(" + worldPos + ", " + worldNormalVarName + ", " + vEyePosition + ".xyz, " + reflectionMatrix + ");\n            #endif\n\n            #ifdef " + this._defineSphericalName + "\n                vec3 " + this._reflectionVectorName + " = computeSphericalCoords(" + worldPos + ", " + worldNormalVarName + ", " + view + ", " + reflectionMatrix + ");\n            #endif\n\n            #ifdef " + this._definePlanarName + "\n                vec3 " + this._reflectionVectorName + " = computePlanarCoords(" + worldPos + ", " + worldNormalVarName + ", " + vEyePosition + ".xyz, " + reflectionMatrix + ");\n            #endif\n\n            #ifdef " + this._defineCubicName + "\n                #ifdef " + this._defineLocalCubicName + "\n                    vec3 " + this._reflectionVectorName + " = computeCubicLocalCoords(" + worldPos + ", " + worldNormalVarName + ", " + vEyePosition + ".xyz, " + reflectionMatrix + ", vReflectionSize, vReflectionPosition);\n                #else\n                vec3 " + this._reflectionVectorName + " = computeCubicCoords(" + worldPos + ", " + worldNormalVarName + ", " + vEyePosition + ".xyz, " + reflectionMatrix + ");\n                #endif\n            #endif\n\n            #ifdef " + this._defineProjectionName + "\n                vec3 " + this._reflectionVectorName + " = computeProjectionCoords(" + worldPos + ", " + view + ", " + reflectionMatrix + ");\n            #endif\n\n            #ifdef " + this._defineSkyboxName + "\n                vec3 " + this._reflectionVectorName + " = computeSkyBoxCoords(" + positionUVW + ", " + reflectionMatrix + ");\n            #endif\n\n            #ifdef " + this._defineExplicitName + "\n                vec3 " + this._reflectionVectorName + " = vec3(0, 0, 0);\n            #endif\n\n            #ifdef " + this._defineOppositeZ + "\n                " + this._reflectionVectorName + ".z *= -1.0;\n            #endif\r\n";
    if (!onlyReflectionVector) {
      code += "\n                #ifdef " + this._define3DName + "\n                    vec3 " + this._reflectionCoordsName + " = " + this._reflectionVectorName + ";\n                #else\n                    vec2 " + this._reflectionCoordsName + " = " + this._reflectionVectorName + ".xy;\n                    #ifdef " + this._defineProjectionName + "\n                        " + this._reflectionCoordsName + " /= " + this._reflectionVectorName + ".z;\n                    #endif\n                    " + this._reflectionCoordsName + ".y = 1.0 - " + this._reflectionCoordsName + ".y;\n                #endif\r\n";
    }
    return code;
  };
  ReflectionTextureBaseBlock2.prototype.handleFragmentSideCodeReflectionColor = function(lodVarName, swizzleLookupTexture) {
    if (swizzleLookupTexture === void 0) {
      swizzleLookupTexture = ".rgb";
    }
    var colorType = "vec" + (swizzleLookupTexture.length === 0 ? "4" : swizzleLookupTexture.length - 1);
    var code = colorType + " " + this._reflectionColorName + ";\n            #ifdef " + this._define3DName + "\r\n";
    if (lodVarName) {
      code += this._reflectionColorName + " = textureCubeLodEXT(" + this._cubeSamplerName + ", " + this._reflectionVectorName + ", " + lodVarName + ")" + swizzleLookupTexture + ";\r\n";
    } else {
      code += this._reflectionColorName + " = textureCube(" + this._cubeSamplerName + ", " + this._reflectionVectorName + ")" + swizzleLookupTexture + ";\r\n";
    }
    code += "\n            #else\r\n";
    if (lodVarName) {
      code += this._reflectionColorName + " = texture2DLodEXT(" + this._2DSamplerName + ", " + this._reflectionCoordsName + ", " + lodVarName + ")" + swizzleLookupTexture + ";\r\n";
    } else {
      code += this._reflectionColorName + " = texture2D(" + this._2DSamplerName + ", " + this._reflectionCoordsName + ")" + swizzleLookupTexture + ";\r\n";
    }
    code += "#endif\r\n";
    return code;
  };
  ReflectionTextureBaseBlock2.prototype.writeOutputs = function(state, varName) {
    var code = "";
    if (state.target === NodeMaterialBlockTargets.Fragment) {
      for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {
        var output = _a[_i];
        if (output.hasEndpoints) {
          code += this._declareOutput(output, state) + " = " + varName + "." + output.name + ";\r\n";
        }
      }
    }
    return code;
  };
  ReflectionTextureBaseBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    return this;
  };
  ReflectionTextureBaseBlock2.prototype._dumpPropertiesCode = function() {
    if (!this.texture) {
      return "";
    }
    var codeString;
    if (this.texture.isCube) {
      codeString = this._codeVariableName + '.texture = new BABYLON.CubeTexture("' + this.texture.name + '");\r\n';
    } else {
      codeString = this._codeVariableName + '.texture = new BABYLON.Texture("' + this.texture.name + '");\r\n';
    }
    codeString += this._codeVariableName + ".texture.coordinatesMode = " + this.texture.coordinatesMode + ";\r\n";
    return codeString;
  };
  ReflectionTextureBaseBlock2.prototype.serialize = function() {
    var serializationObject = _super.prototype.serialize.call(this);
    if (this.texture) {
      serializationObject.texture = this.texture.serialize();
    }
    return serializationObject;
  };
  ReflectionTextureBaseBlock2.prototype._deserialize = function(serializationObject, scene, rootUrl) {
    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);
    if (serializationObject.texture) {
      rootUrl = serializationObject.texture.url.indexOf("data:") === 0 ? "" : rootUrl;
      if (serializationObject.texture.isCube) {
        this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);
      } else {
        this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);
      }
    }
  };
  return ReflectionTextureBaseBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.ReflectionTextureBaseBlock"] = ReflectionTextureBaseBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/reflectionTextureBlock.js
var ReflectionTextureBlock = function(_super) {
  __extends(ReflectionTextureBlock2, _super);
  function ReflectionTextureBlock2(name98) {
    var _this = _super.call(this, name98) || this;
    _this.registerInput("position", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Vertex);
    _this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);
    _this.registerInput("worldNormal", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("world", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Vertex);
    _this.registerInput("cameraPosition", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("view", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("r", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("g", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("b", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("a", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector4);
    return _this;
  }
  ReflectionTextureBlock2.prototype.getClassName = function() {
    return "ReflectionTextureBlock";
  };
  Object.defineProperty(ReflectionTextureBlock2.prototype, "position", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReflectionTextureBlock2.prototype, "worldPosition", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReflectionTextureBlock2.prototype, "worldNormal", {
    get: function() {
      return this._inputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReflectionTextureBlock2.prototype, "world", {
    get: function() {
      return this._inputs[3];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReflectionTextureBlock2.prototype, "cameraPosition", {
    get: function() {
      return this._inputs[4];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReflectionTextureBlock2.prototype, "view", {
    get: function() {
      return this._inputs[5];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReflectionTextureBlock2.prototype, "rgb", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReflectionTextureBlock2.prototype, "rgba", {
    get: function() {
      return this._outputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReflectionTextureBlock2.prototype, "r", {
    get: function() {
      return this._outputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReflectionTextureBlock2.prototype, "g", {
    get: function() {
      return this._outputs[3];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReflectionTextureBlock2.prototype, "b", {
    get: function() {
      return this._outputs[4];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReflectionTextureBlock2.prototype, "a", {
    get: function() {
      return this._outputs[5];
    },
    enumerable: false,
    configurable: true
  });
  ReflectionTextureBlock2.prototype.autoConfigure = function(material) {
    _super.prototype.autoConfigure.call(this, material);
    if (!this.cameraPosition.isConnected) {
      var cameraPositionInput = material.getInputBlockByPredicate(function(b) {
        return b.systemValue === NodeMaterialSystemValues.CameraPosition;
      });
      if (!cameraPositionInput) {
        cameraPositionInput = new InputBlock("cameraPosition");
        cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);
      }
      cameraPositionInput.output.connectTo(this.cameraPosition);
    }
  };
  ReflectionTextureBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    if (!this.texture) {
      state.compilationString += this.writeOutputs(state, "vec3(0.)");
      return this;
    }
    if (state.target !== NodeMaterialBlockTargets.Fragment) {
      state.compilationString += this.handleVertexSide(state);
      return this;
    }
    this.handleFragmentSideInits(state);
    var normalWUnit = state._getFreeVariableName("normalWUnit");
    state.compilationString += "vec4 " + normalWUnit + " = normalize(" + this.worldNormal.associatedVariableName + ");\r\n";
    state.compilationString += this.handleFragmentSideCodeReflectionCoords(normalWUnit);
    state.compilationString += this.handleFragmentSideCodeReflectionColor(void 0, "");
    state.compilationString += this.writeOutputs(state, this._reflectionColorName);
    return this;
  };
  return ReflectionTextureBlock2;
}(ReflectionTextureBaseBlock);
_TypeStore.RegisteredTypes["BABYLON.ReflectionTextureBlock"] = ReflectionTextureBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/addBlock.js
var AddBlock = function(_super) {
  __extends(AddBlock2, _super);
  function AddBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    _this._outputs[0]._typeConnectionSource = _this._inputs[0];
    _this._linkConnectionTypes(0, 1);
    return _this;
  }
  AddBlock2.prototype.getClassName = function() {
    return "AddBlock";
  };
  Object.defineProperty(AddBlock2.prototype, "left", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AddBlock2.prototype, "right", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AddBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  AddBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + (" = " + this.left.associatedVariableName + " + " + this.right.associatedVariableName + ";\r\n");
    return this;
  };
  return AddBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.AddBlock"] = AddBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/scaleBlock.js
var ScaleBlock = function(_super) {
  __extends(ScaleBlock2, _super);
  function ScaleBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerInput("factor", NodeMaterialBlockConnectionPointTypes.Float);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    _this._outputs[0]._typeConnectionSource = _this._inputs[0];
    return _this;
  }
  ScaleBlock2.prototype.getClassName = function() {
    return "ScaleBlock";
  };
  Object.defineProperty(ScaleBlock2.prototype, "input", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScaleBlock2.prototype, "factor", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScaleBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  ScaleBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + (" = " + this.input.associatedVariableName + " * " + this.factor.associatedVariableName + ";\r\n");
    return this;
  };
  return ScaleBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.ScaleBlock"] = ScaleBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/clampBlock.js
var ClampBlock = function(_super) {
  __extends(ClampBlock2, _super);
  function ClampBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.minimum = 0;
    _this.maximum = 1;
    _this.registerInput("value", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    _this._outputs[0]._typeConnectionSource = _this._inputs[0];
    return _this;
  }
  ClampBlock2.prototype.getClassName = function() {
    return "ClampBlock";
  };
  Object.defineProperty(ClampBlock2.prototype, "value", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ClampBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  ClampBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + (" = clamp(" + this.value.associatedVariableName + ", " + this._writeFloat(this.minimum) + ", " + this._writeFloat(this.maximum) + ");\r\n");
    return this;
  };
  ClampBlock2.prototype._dumpPropertiesCode = function() {
    var codeString = this._codeVariableName + ".minimum = " + this.minimum + ";\r\n";
    codeString += this._codeVariableName + ".maximum = " + this.maximum + ";\r\n";
    return codeString;
  };
  ClampBlock2.prototype.serialize = function() {
    var serializationObject = _super.prototype.serialize.call(this);
    serializationObject.minimum = this.minimum;
    serializationObject.maximum = this.maximum;
    return serializationObject;
  };
  ClampBlock2.prototype._deserialize = function(serializationObject, scene, rootUrl) {
    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);
    this.minimum = serializationObject.minimum;
    this.maximum = serializationObject.maximum;
  };
  __decorate([
    editableInPropertyPage("Minimum", PropertyTypeForEdition.Float)
  ], ClampBlock2.prototype, "minimum", void 0);
  __decorate([
    editableInPropertyPage("Maximum", PropertyTypeForEdition.Float)
  ], ClampBlock2.prototype, "maximum", void 0);
  return ClampBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.ClampBlock"] = ClampBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/crossBlock.js
var CrossBlock = function(_super) {
  __extends(CrossBlock2, _super);
  function CrossBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector3);
    _this._linkConnectionTypes(0, 1);
    _this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    _this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    _this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector2);
    _this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    _this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    _this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector2);
    return _this;
  }
  CrossBlock2.prototype.getClassName = function() {
    return "CrossBlock";
  };
  Object.defineProperty(CrossBlock2.prototype, "left", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CrossBlock2.prototype, "right", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CrossBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  CrossBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + (" = cross(" + this.left.associatedVariableName + ".xyz, " + this.right.associatedVariableName + ".xyz);\r\n");
    return this;
  };
  return CrossBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.CrossBlock"] = CrossBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/dotBlock.js
var DotBlock = function(_super) {
  __extends(DotBlock2, _super);
  function DotBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float);
    _this._linkConnectionTypes(0, 1);
    _this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    _this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    _this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    _this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    return _this;
  }
  DotBlock2.prototype.getClassName = function() {
    return "DotBlock";
  };
  Object.defineProperty(DotBlock2.prototype, "left", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DotBlock2.prototype, "right", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DotBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  DotBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + (" = dot(" + this.left.associatedVariableName + ", " + this.right.associatedVariableName + ");\r\n");
    return this;
  };
  return DotBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.DotBlock"] = DotBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/normalizeBlock.js
var NormalizeBlock = function(_super) {
  __extends(NormalizeBlock2, _super);
  function NormalizeBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    _this._outputs[0]._typeConnectionSource = _this._inputs[0];
    _this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    _this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    return _this;
  }
  NormalizeBlock2.prototype.getClassName = function() {
    return "NormalizeBlock";
  };
  Object.defineProperty(NormalizeBlock2.prototype, "input", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NormalizeBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  NormalizeBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    var input = this._inputs[0];
    state.compilationString += this._declareOutput(output, state) + (" = normalize(" + input.associatedVariableName + ");\r\n");
    return this;
  };
  return NormalizeBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.NormalizeBlock"] = NormalizeBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/colorMergerBlock.js
var ColorMergerBlock = function(_super) {
  __extends(ColorMergerBlock2, _super);
  function ColorMergerBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("rgb ", NodeMaterialBlockConnectionPointTypes.Color3, true);
    _this.registerInput("r", NodeMaterialBlockConnectionPointTypes.Float, true);
    _this.registerInput("g", NodeMaterialBlockConnectionPointTypes.Float, true);
    _this.registerInput("b", NodeMaterialBlockConnectionPointTypes.Float, true);
    _this.registerInput("a", NodeMaterialBlockConnectionPointTypes.Float, true);
    _this.registerOutput("rgba", NodeMaterialBlockConnectionPointTypes.Color4);
    _this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3);
    return _this;
  }
  ColorMergerBlock2.prototype.getClassName = function() {
    return "ColorMergerBlock";
  };
  Object.defineProperty(ColorMergerBlock2.prototype, "rgbIn", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorMergerBlock2.prototype, "r", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorMergerBlock2.prototype, "g", {
    get: function() {
      return this._inputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorMergerBlock2.prototype, "b", {
    get: function() {
      return this._inputs[3];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorMergerBlock2.prototype, "a", {
    get: function() {
      return this._inputs[4];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorMergerBlock2.prototype, "rgba", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorMergerBlock2.prototype, "rgbOut", {
    get: function() {
      return this._outputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorMergerBlock2.prototype, "rgb", {
    get: function() {
      return this.rgbOut;
    },
    enumerable: false,
    configurable: true
  });
  ColorMergerBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var rInput = this.r;
    var gInput = this.g;
    var bInput = this.b;
    var aInput = this.a;
    var rgbInput = this.rgbIn;
    var color4Output = this._outputs[0];
    var color3Output = this._outputs[1];
    if (rgbInput.isConnected) {
      if (color4Output.hasEndpoints) {
        state.compilationString += this._declareOutput(color4Output, state) + (" = vec4(" + rgbInput.associatedVariableName + ", " + (aInput.isConnected ? this._writeVariable(aInput) : "0.0") + ");\r\n");
      } else if (color3Output.hasEndpoints) {
        state.compilationString += this._declareOutput(color3Output, state) + (" = " + rgbInput.associatedVariableName + ";\r\n");
      }
    } else {
      if (color4Output.hasEndpoints) {
        state.compilationString += this._declareOutput(color4Output, state) + (" = vec4(" + (rInput.isConnected ? this._writeVariable(rInput) : "0.0") + ", " + (gInput.isConnected ? this._writeVariable(gInput) : "0.0") + ", " + (bInput.isConnected ? this._writeVariable(bInput) : "0.0") + ", " + (aInput.isConnected ? this._writeVariable(aInput) : "0.0") + ");\r\n");
      } else if (color3Output.hasEndpoints) {
        state.compilationString += this._declareOutput(color3Output, state) + (" = vec3(" + (rInput.isConnected ? this._writeVariable(rInput) : "0.0") + ", " + (gInput.isConnected ? this._writeVariable(gInput) : "0.0") + ", " + (bInput.isConnected ? this._writeVariable(bInput) : "0.0") + ");\r\n");
      }
    }
    return this;
  };
  return ColorMergerBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.ColorMergerBlock"] = ColorMergerBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/vectorSplitterBlock.js
var VectorSplitterBlock = function(_super) {
  __extends(VectorSplitterBlock2, _super);
  function VectorSplitterBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("xyzw", NodeMaterialBlockConnectionPointTypes.Vector4, true);
    _this.registerInput("xyz ", NodeMaterialBlockConnectionPointTypes.Vector3, true);
    _this.registerInput("xy ", NodeMaterialBlockConnectionPointTypes.Vector2, true);
    _this.registerOutput("xyz", NodeMaterialBlockConnectionPointTypes.Vector3);
    _this.registerOutput("xy", NodeMaterialBlockConnectionPointTypes.Vector2);
    _this.registerOutput("x", NodeMaterialBlockConnectionPointTypes.Float);
    _this.registerOutput("y", NodeMaterialBlockConnectionPointTypes.Float);
    _this.registerOutput("z", NodeMaterialBlockConnectionPointTypes.Float);
    _this.registerOutput("w", NodeMaterialBlockConnectionPointTypes.Float);
    _this.inputsAreExclusive = true;
    return _this;
  }
  VectorSplitterBlock2.prototype.getClassName = function() {
    return "VectorSplitterBlock";
  };
  Object.defineProperty(VectorSplitterBlock2.prototype, "xyzw", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VectorSplitterBlock2.prototype, "xyzIn", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VectorSplitterBlock2.prototype, "xyIn", {
    get: function() {
      return this._inputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VectorSplitterBlock2.prototype, "xyzOut", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VectorSplitterBlock2.prototype, "xyOut", {
    get: function() {
      return this._outputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VectorSplitterBlock2.prototype, "x", {
    get: function() {
      return this._outputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VectorSplitterBlock2.prototype, "y", {
    get: function() {
      return this._outputs[3];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VectorSplitterBlock2.prototype, "z", {
    get: function() {
      return this._outputs[4];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VectorSplitterBlock2.prototype, "w", {
    get: function() {
      return this._outputs[5];
    },
    enumerable: false,
    configurable: true
  });
  VectorSplitterBlock2.prototype._inputRename = function(name98) {
    switch (name98) {
      case "xy ":
        return "xyIn";
      case "xyz ":
        return "xyzIn";
      default:
        return name98;
    }
  };
  VectorSplitterBlock2.prototype._outputRename = function(name98) {
    switch (name98) {
      case "xy":
        return "xyOut";
      case "xyz":
        return "xyzOut";
      default:
        return name98;
    }
  };
  VectorSplitterBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var input = this.xyzw.isConnected ? this.xyzw : this.xyzIn.isConnected ? this.xyzIn : this.xyIn;
    var xyzOutput = this._outputs[0];
    var xyOutput = this._outputs[1];
    var xOutput = this._outputs[2];
    var yOutput = this._outputs[3];
    var zOutput = this._outputs[4];
    var wOutput = this._outputs[5];
    if (xyzOutput.hasEndpoints) {
      if (input === this.xyIn) {
        state.compilationString += this._declareOutput(xyzOutput, state) + (" = vec3(" + input.associatedVariableName + ", 0.0);\r\n");
      } else {
        state.compilationString += this._declareOutput(xyzOutput, state) + (" = " + input.associatedVariableName + ".xyz;\r\n");
      }
    }
    if (xyOutput.hasEndpoints) {
      state.compilationString += this._declareOutput(xyOutput, state) + (" = " + input.associatedVariableName + ".xy;\r\n");
    }
    if (xOutput.hasEndpoints) {
      state.compilationString += this._declareOutput(xOutput, state) + (" = " + input.associatedVariableName + ".x;\r\n");
    }
    if (yOutput.hasEndpoints) {
      state.compilationString += this._declareOutput(yOutput, state) + (" = " + input.associatedVariableName + ".y;\r\n");
    }
    if (zOutput.hasEndpoints) {
      state.compilationString += this._declareOutput(zOutput, state) + (" = " + input.associatedVariableName + ".z;\r\n");
    }
    if (wOutput.hasEndpoints) {
      state.compilationString += this._declareOutput(wOutput, state) + (" = " + input.associatedVariableName + ".w;\r\n");
    }
    return this;
  };
  return VectorSplitterBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.VectorSplitterBlock"] = VectorSplitterBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/lerpBlock.js
var LerpBlock = function(_super) {
  __extends(LerpBlock2, _super);
  function LerpBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerInput("gradient", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    _this._outputs[0]._typeConnectionSource = _this._inputs[0];
    _this._linkConnectionTypes(0, 1);
    _this._linkConnectionTypes(1, 2, true);
    _this._inputs[2].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    return _this;
  }
  LerpBlock2.prototype.getClassName = function() {
    return "LerpBlock";
  };
  Object.defineProperty(LerpBlock2.prototype, "left", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LerpBlock2.prototype, "right", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LerpBlock2.prototype, "gradient", {
    get: function() {
      return this._inputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LerpBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  LerpBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + (" = mix(" + this.left.associatedVariableName + " , " + this.right.associatedVariableName + ", " + this.gradient.associatedVariableName + ");\r\n");
    return this;
  };
  return LerpBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.LerpBlock"] = LerpBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/divideBlock.js
var DivideBlock = function(_super) {
  __extends(DivideBlock2, _super);
  function DivideBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    _this._outputs[0]._typeConnectionSource = _this._inputs[0];
    _this._linkConnectionTypes(0, 1);
    return _this;
  }
  DivideBlock2.prototype.getClassName = function() {
    return "DivideBlock";
  };
  Object.defineProperty(DivideBlock2.prototype, "left", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DivideBlock2.prototype, "right", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DivideBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  DivideBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + (" = " + this.left.associatedVariableName + " / " + this.right.associatedVariableName + ";\r\n");
    return this;
  };
  return DivideBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.DivideBlock"] = DivideBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/subtractBlock.js
var SubtractBlock = function(_super) {
  __extends(SubtractBlock2, _super);
  function SubtractBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    _this._outputs[0]._typeConnectionSource = _this._inputs[0];
    _this._linkConnectionTypes(0, 1);
    return _this;
  }
  SubtractBlock2.prototype.getClassName = function() {
    return "SubtractBlock";
  };
  Object.defineProperty(SubtractBlock2.prototype, "left", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SubtractBlock2.prototype, "right", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SubtractBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  SubtractBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + (" = " + this.left.associatedVariableName + " - " + this.right.associatedVariableName + ";\r\n");
    return this;
  };
  return SubtractBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.SubtractBlock"] = SubtractBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/stepBlock.js
var StepBlock = function(_super) {
  __extends(StepBlock2, _super);
  function StepBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("value", NodeMaterialBlockConnectionPointTypes.Float);
    _this.registerInput("edge", NodeMaterialBlockConnectionPointTypes.Float);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float);
    return _this;
  }
  StepBlock2.prototype.getClassName = function() {
    return "StepBlock";
  };
  Object.defineProperty(StepBlock2.prototype, "value", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StepBlock2.prototype, "edge", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StepBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  StepBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + (" = step(" + this.edge.associatedVariableName + ", " + this.value.associatedVariableName + ");\r\n");
    return this;
  };
  return StepBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.StepBlock"] = StepBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/oneMinusBlock.js
var OneMinusBlock = function(_super) {
  __extends(OneMinusBlock2, _super);
  function OneMinusBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    _this._outputs[0]._typeConnectionSource = _this._inputs[0];
    _this._outputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    return _this;
  }
  OneMinusBlock2.prototype.getClassName = function() {
    return "OneMinusBlock";
  };
  Object.defineProperty(OneMinusBlock2.prototype, "input", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(OneMinusBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  OneMinusBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + (" = 1. - " + this.input.associatedVariableName + ";\r\n");
    return this;
  };
  return OneMinusBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.OneMinusBlock"] = OneMinusBlock;
_TypeStore.RegisteredTypes["BABYLON.OppositeBlock"] = OneMinusBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/viewDirectionBlock.js
var ViewDirectionBlock = function(_super) {
  __extends(ViewDirectionBlock2, _super);
  function ViewDirectionBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.Vector4);
    _this.registerInput("cameraPosition", NodeMaterialBlockConnectionPointTypes.Vector3);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector3);
    return _this;
  }
  ViewDirectionBlock2.prototype.getClassName = function() {
    return "ViewDirectionBlock";
  };
  Object.defineProperty(ViewDirectionBlock2.prototype, "worldPosition", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ViewDirectionBlock2.prototype, "cameraPosition", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ViewDirectionBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  ViewDirectionBlock2.prototype.autoConfigure = function(material) {
    if (!this.cameraPosition.isConnected) {
      var cameraPositionInput = material.getInputBlockByPredicate(function(b) {
        return b.systemValue === NodeMaterialSystemValues.CameraPosition;
      });
      if (!cameraPositionInput) {
        cameraPositionInput = new InputBlock("cameraPosition");
        cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);
      }
      cameraPositionInput.output.connectTo(this.cameraPosition);
    }
  };
  ViewDirectionBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + (" = normalize(" + this.cameraPosition.associatedVariableName + " - " + this.worldPosition.associatedVariableName + ".xyz);\r\n");
    return this;
  };
  return ViewDirectionBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.ViewDirectionBlock"] = ViewDirectionBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/fresnelBlock.js
var FresnelBlock = function(_super) {
  __extends(FresnelBlock2, _super);
  function FresnelBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("worldNormal", NodeMaterialBlockConnectionPointTypes.Vector4);
    _this.registerInput("viewDirection", NodeMaterialBlockConnectionPointTypes.Vector3);
    _this.registerInput("bias", NodeMaterialBlockConnectionPointTypes.Float);
    _this.registerInput("power", NodeMaterialBlockConnectionPointTypes.Float);
    _this.registerOutput("fresnel", NodeMaterialBlockConnectionPointTypes.Float);
    return _this;
  }
  FresnelBlock2.prototype.getClassName = function() {
    return "FresnelBlock";
  };
  Object.defineProperty(FresnelBlock2.prototype, "worldNormal", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FresnelBlock2.prototype, "viewDirection", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FresnelBlock2.prototype, "bias", {
    get: function() {
      return this._inputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FresnelBlock2.prototype, "power", {
    get: function() {
      return this._inputs[3];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FresnelBlock2.prototype, "fresnel", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  FresnelBlock2.prototype.autoConfigure = function(material) {
    if (!this.viewDirection.isConnected) {
      var viewDirectionInput = new ViewDirectionBlock("View direction");
      viewDirectionInput.output.connectTo(this.viewDirection);
      viewDirectionInput.autoConfigure(material);
    }
    if (!this.bias.isConnected) {
      var biasInput = new InputBlock("bias");
      biasInput.value = 0;
      biasInput.output.connectTo(this.bias);
    }
    if (!this.power.isConnected) {
      var powerInput = new InputBlock("power");
      powerInput.value = 1;
      powerInput.output.connectTo(this.power);
    }
  };
  FresnelBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var comments = "//" + this.name;
    state._emitFunctionFromInclude("fresnelFunction", comments, { removeIfDef: true });
    state.compilationString += this._declareOutput(this.fresnel, state) + (" = computeFresnelTerm(" + this.viewDirection.associatedVariableName + ".xyz, " + this.worldNormal.associatedVariableName + ".xyz, " + this.bias.associatedVariableName + ", " + this.power.associatedVariableName + ");\r\n");
    return this;
  };
  return FresnelBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.FresnelBlock"] = FresnelBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/maxBlock.js
var MaxBlock = function(_super) {
  __extends(MaxBlock2, _super);
  function MaxBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    _this._outputs[0]._typeConnectionSource = _this._inputs[0];
    _this._linkConnectionTypes(0, 1);
    return _this;
  }
  MaxBlock2.prototype.getClassName = function() {
    return "MaxBlock";
  };
  Object.defineProperty(MaxBlock2.prototype, "left", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaxBlock2.prototype, "right", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaxBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  MaxBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + (" = max(" + this.left.associatedVariableName + ", " + this.right.associatedVariableName + ");\r\n");
    return this;
  };
  return MaxBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.MaxBlock"] = MaxBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/minBlock.js
var MinBlock = function(_super) {
  __extends(MinBlock2, _super);
  function MinBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    _this._outputs[0]._typeConnectionSource = _this._inputs[0];
    _this._linkConnectionTypes(0, 1);
    return _this;
  }
  MinBlock2.prototype.getClassName = function() {
    return "MinBlock";
  };
  Object.defineProperty(MinBlock2.prototype, "left", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MinBlock2.prototype, "right", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MinBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  MinBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + (" = min(" + this.left.associatedVariableName + ", " + this.right.associatedVariableName + ");\r\n");
    return this;
  };
  return MinBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.MinBlock"] = MinBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/distanceBlock.js
var DistanceBlock = function(_super) {
  __extends(DistanceBlock2, _super);
  function DistanceBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float);
    _this._linkConnectionTypes(0, 1);
    _this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    _this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    _this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    _this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    return _this;
  }
  DistanceBlock2.prototype.getClassName = function() {
    return "DistanceBlock";
  };
  Object.defineProperty(DistanceBlock2.prototype, "left", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DistanceBlock2.prototype, "right", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DistanceBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  DistanceBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + (" = length(" + this.left.associatedVariableName + " - " + this.right.associatedVariableName + ");\r\n");
    return this;
  };
  return DistanceBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.DistanceBlock"] = DistanceBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/lengthBlock.js
var LengthBlock = function(_super) {
  __extends(LengthBlock2, _super);
  function LengthBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("value", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float);
    _this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    _this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    return _this;
  }
  LengthBlock2.prototype.getClassName = function() {
    return "LengthBlock";
  };
  Object.defineProperty(LengthBlock2.prototype, "value", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LengthBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  LengthBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + (" = length(" + this.value.associatedVariableName + ");\r\n");
    return this;
  };
  return LengthBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.LengthBlock"] = LengthBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/negateBlock.js
var NegateBlock = function(_super) {
  __extends(NegateBlock2, _super);
  function NegateBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("value", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    _this._outputs[0]._typeConnectionSource = _this._inputs[0];
    return _this;
  }
  NegateBlock2.prototype.getClassName = function() {
    return "NegateBlock";
  };
  Object.defineProperty(NegateBlock2.prototype, "value", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NegateBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  NegateBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + (" = -1.0 * " + this.value.associatedVariableName + ";\r\n");
    return this;
  };
  return NegateBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.NegateBlock"] = NegateBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/powBlock.js
var PowBlock = function(_super) {
  __extends(PowBlock2, _super);
  function PowBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("value", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerInput("power", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    _this._outputs[0]._typeConnectionSource = _this._inputs[0];
    _this._linkConnectionTypes(0, 1);
    return _this;
  }
  PowBlock2.prototype.getClassName = function() {
    return "PowBlock";
  };
  Object.defineProperty(PowBlock2.prototype, "value", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PowBlock2.prototype, "power", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PowBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  PowBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + (" = pow(" + this.value.associatedVariableName + ", " + this.power.associatedVariableName + ");\r\n");
    return this;
  };
  return PowBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.PowBlock"] = PowBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/randomNumberBlock.js
var RandomNumberBlock = function(_super) {
  __extends(RandomNumberBlock2, _super);
  function RandomNumberBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("seed", NodeMaterialBlockConnectionPointTypes.Vector2);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float);
    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);
    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector4);
    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Color3);
    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Color4);
    return _this;
  }
  RandomNumberBlock2.prototype.getClassName = function() {
    return "RandomNumberBlock";
  };
  Object.defineProperty(RandomNumberBlock2.prototype, "seed", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RandomNumberBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  RandomNumberBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    var comments = "//" + this.name;
    state._emitFunctionFromInclude("helperFunctions", comments);
    state.compilationString += this._declareOutput(output, state) + (" = getRand(" + this.seed.associatedVariableName + ".xy);\r\n");
    return this;
  };
  return RandomNumberBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.RandomNumberBlock"] = RandomNumberBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/arcTan2Block.js
var ArcTan2Block = function(_super) {
  __extends(ArcTan2Block2, _super);
  function ArcTan2Block2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("x", NodeMaterialBlockConnectionPointTypes.Float);
    _this.registerInput("y", NodeMaterialBlockConnectionPointTypes.Float);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float);
    return _this;
  }
  ArcTan2Block2.prototype.getClassName = function() {
    return "ArcTan2Block";
  };
  Object.defineProperty(ArcTan2Block2.prototype, "x", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ArcTan2Block2.prototype, "y", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ArcTan2Block2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  ArcTan2Block2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + (" = atan(" + this.x.associatedVariableName + ", " + this.y.associatedVariableName + ");\r\n");
    return this;
  };
  return ArcTan2Block2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.ArcTan2Block"] = ArcTan2Block;

// node_modules/@babylonjs/core/Materials/Node/Blocks/smoothStepBlock.js
var SmoothStepBlock = function(_super) {
  __extends(SmoothStepBlock2, _super);
  function SmoothStepBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("value", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerInput("edge0", NodeMaterialBlockConnectionPointTypes.Float);
    _this.registerInput("edge1", NodeMaterialBlockConnectionPointTypes.Float);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    _this._outputs[0]._typeConnectionSource = _this._inputs[0];
    return _this;
  }
  SmoothStepBlock2.prototype.getClassName = function() {
    return "SmoothStepBlock";
  };
  Object.defineProperty(SmoothStepBlock2.prototype, "value", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SmoothStepBlock2.prototype, "edge0", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SmoothStepBlock2.prototype, "edge1", {
    get: function() {
      return this._inputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SmoothStepBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  SmoothStepBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + (" = smoothstep(" + this.edge0.associatedVariableName + ", " + this.edge1.associatedVariableName + ", " + this.value.associatedVariableName + ");\r\n");
    return this;
  };
  return SmoothStepBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.SmoothStepBlock"] = SmoothStepBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/reciprocalBlock.js
var ReciprocalBlock = function(_super) {
  __extends(ReciprocalBlock2, _super);
  function ReciprocalBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    _this._outputs[0]._typeConnectionSource = _this._inputs[0];
    _this._outputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    return _this;
  }
  ReciprocalBlock2.prototype.getClassName = function() {
    return "ReciprocalBlock";
  };
  Object.defineProperty(ReciprocalBlock2.prototype, "input", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReciprocalBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  ReciprocalBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + (" = 1. / " + this.input.associatedVariableName + ";\r\n");
    return this;
  };
  return ReciprocalBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.ReciprocalBlock"] = ReciprocalBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/replaceColorBlock.js
var ReplaceColorBlock = function(_super) {
  __extends(ReplaceColorBlock2, _super);
  function ReplaceColorBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("value", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerInput("reference", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerInput("distance", NodeMaterialBlockConnectionPointTypes.Float);
    _this.registerInput("replacement", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    _this._outputs[0]._typeConnectionSource = _this._inputs[0];
    _this._linkConnectionTypes(0, 1);
    _this._linkConnectionTypes(0, 3);
    _this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    _this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    _this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    _this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    _this._inputs[3].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    _this._inputs[3].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    return _this;
  }
  ReplaceColorBlock2.prototype.getClassName = function() {
    return "ReplaceColorBlock";
  };
  Object.defineProperty(ReplaceColorBlock2.prototype, "value", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReplaceColorBlock2.prototype, "reference", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReplaceColorBlock2.prototype, "distance", {
    get: function() {
      return this._inputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReplaceColorBlock2.prototype, "replacement", {
    get: function() {
      return this._inputs[3];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReplaceColorBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  ReplaceColorBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + ";\r\n";
    state.compilationString += "if (length(" + this.value.associatedVariableName + " - " + this.reference.associatedVariableName + ") < " + this.distance.associatedVariableName + ") {\r\n";
    state.compilationString += output.associatedVariableName + " = " + this.replacement.associatedVariableName + ";\r\n";
    state.compilationString += "} else {\r\n";
    state.compilationString += output.associatedVariableName + " = " + this.value.associatedVariableName + ";\r\n";
    state.compilationString += "}\r\n";
    return this;
  };
  return ReplaceColorBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.ReplaceColorBlock"] = ReplaceColorBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/posterizeBlock.js
var PosterizeBlock = function(_super) {
  __extends(PosterizeBlock2, _super);
  function PosterizeBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("value", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerInput("steps", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    _this._outputs[0]._typeConnectionSource = _this._inputs[0];
    _this._linkConnectionTypes(0, 1);
    _this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    _this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    return _this;
  }
  PosterizeBlock2.prototype.getClassName = function() {
    return "PosterizeBlock";
  };
  Object.defineProperty(PosterizeBlock2.prototype, "value", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PosterizeBlock2.prototype, "steps", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PosterizeBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  PosterizeBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + (" = floor(" + this.value.associatedVariableName + " / (1.0 / " + this.steps.associatedVariableName + ")) * (1.0 / " + this.steps.associatedVariableName + ");\r\n");
    return this;
  };
  return PosterizeBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.PosterizeBlock"] = PosterizeBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/waveBlock.js
var WaveBlockKind;
(function(WaveBlockKind2) {
  WaveBlockKind2[WaveBlockKind2["SawTooth"] = 0] = "SawTooth";
  WaveBlockKind2[WaveBlockKind2["Square"] = 1] = "Square";
  WaveBlockKind2[WaveBlockKind2["Triangle"] = 2] = "Triangle";
})(WaveBlockKind || (WaveBlockKind = {}));
var WaveBlock = function(_super) {
  __extends(WaveBlock2, _super);
  function WaveBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.kind = WaveBlockKind.SawTooth;
    _this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    _this._outputs[0]._typeConnectionSource = _this._inputs[0];
    _this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    return _this;
  }
  WaveBlock2.prototype.getClassName = function() {
    return "WaveBlock";
  };
  Object.defineProperty(WaveBlock2.prototype, "input", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WaveBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  WaveBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    switch (this.kind) {
      case WaveBlockKind.SawTooth: {
        state.compilationString += this._declareOutput(output, state) + (" = " + this.input.associatedVariableName + " - floor(0.5 + " + this.input.associatedVariableName + ");\r\n");
        break;
      }
      case WaveBlockKind.Square: {
        state.compilationString += this._declareOutput(output, state) + (" = 1.0 - 2.0 * round(fract(" + this.input.associatedVariableName + "));\r\n");
        break;
      }
      case WaveBlockKind.Triangle: {
        state.compilationString += this._declareOutput(output, state) + (" = 2.0 * abs(2.0 * (" + this.input.associatedVariableName + " - floor(0.5 + " + this.input.associatedVariableName + "))) - 1.0;\r\n");
        break;
      }
    }
    return this;
  };
  WaveBlock2.prototype.serialize = function() {
    var serializationObject = _super.prototype.serialize.call(this);
    serializationObject.kind = this.kind;
    return serializationObject;
  };
  WaveBlock2.prototype._deserialize = function(serializationObject, scene, rootUrl) {
    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);
    this.kind = serializationObject.kind;
  };
  return WaveBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.WaveBlock"] = WaveBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/gradientBlock.js
var GradientBlockColorStep = function() {
  function GradientBlockColorStep2(step, color) {
    this.step = step;
    this.color = color;
  }
  Object.defineProperty(GradientBlockColorStep2.prototype, "step", {
    get: function() {
      return this._step;
    },
    set: function(val) {
      this._step = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GradientBlockColorStep2.prototype, "color", {
    get: function() {
      return this._color;
    },
    set: function(val) {
      this._color = val;
    },
    enumerable: false,
    configurable: true
  });
  return GradientBlockColorStep2;
}();
var GradientBlock = function(_super) {
  __extends(GradientBlock2, _super);
  function GradientBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.colorSteps = [
      new GradientBlockColorStep(0, Color3.Black()),
      new GradientBlockColorStep(1, Color3.White())
    ];
    _this.onValueChangedObservable = new Observable();
    _this.registerInput("gradient", NodeMaterialBlockConnectionPointTypes.Float);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Color3);
    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector2);
    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);
    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector4);
    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Color3);
    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Color4);
    return _this;
  }
  GradientBlock2.prototype.colorStepsUpdated = function() {
    this.onValueChangedObservable.notifyObservers(this);
  };
  GradientBlock2.prototype.getClassName = function() {
    return "GradientBlock";
  };
  Object.defineProperty(GradientBlock2.prototype, "gradient", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GradientBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  GradientBlock2.prototype._writeColorConstant = function(index) {
    var step = this.colorSteps[index];
    return "vec3(" + step.color.r + ", " + step.color.g + ", " + step.color.b + ")";
  };
  GradientBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    if (!this.colorSteps.length || !this.gradient.connectedPoint) {
      state.compilationString += this._declareOutput(output, state) + " = vec3(0., 0., 0.);\r\n";
      return;
    }
    var tempColor = state._getFreeVariableName("gradientTempColor");
    var tempPosition = state._getFreeVariableName("gradientTempPosition");
    state.compilationString += "vec3 " + tempColor + " = " + this._writeColorConstant(0) + ";\r\n";
    state.compilationString += "float " + tempPosition + ";\r\n";
    var gradientSource = this.gradient.associatedVariableName;
    if (this.gradient.connectedPoint.type !== NodeMaterialBlockConnectionPointTypes.Float) {
      gradientSource += ".x";
    }
    for (var index = 1; index < this.colorSteps.length; index++) {
      var step = this.colorSteps[index];
      var previousStep = this.colorSteps[index - 1];
      state.compilationString += tempPosition + " = clamp((" + gradientSource + " - " + state._emitFloat(previousStep.step) + ") / (" + state._emitFloat(step.step) + " -  " + state._emitFloat(previousStep.step) + "), 0.0, 1.0) * step(" + state._emitFloat(index) + ", " + state._emitFloat(this.colorSteps.length - 1) + ");\r\n";
      state.compilationString += tempColor + " = mix(" + tempColor + ", " + this._writeColorConstant(index) + ", " + tempPosition + ");\r\n";
    }
    state.compilationString += this._declareOutput(output, state) + (" = " + tempColor + ";\r\n");
    return this;
  };
  GradientBlock2.prototype.serialize = function() {
    var serializationObject = _super.prototype.serialize.call(this);
    serializationObject.colorSteps = [];
    for (var _i = 0, _a = this.colorSteps; _i < _a.length; _i++) {
      var step = _a[_i];
      serializationObject.colorSteps.push({
        step: step.step,
        color: {
          r: step.color.r,
          g: step.color.g,
          b: step.color.b
        }
      });
    }
    return serializationObject;
  };
  GradientBlock2.prototype._deserialize = function(serializationObject, scene, rootUrl) {
    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);
    this.colorSteps = [];
    for (var _i = 0, _a = serializationObject.colorSteps; _i < _a.length; _i++) {
      var step = _a[_i];
      this.colorSteps.push(new GradientBlockColorStep(step.step, new Color3(step.color.r, step.color.g, step.color.b)));
    }
  };
  GradientBlock2.prototype._dumpPropertiesCode = function() {
    var codeString = "";
    for (var _i = 0, _a = this.colorSteps; _i < _a.length; _i++) {
      var colorStep = _a[_i];
      codeString += this._codeVariableName + ".colorSteps.push(new BABYLON.GradientBlockColorStep(" + colorStep.step + ", new BABYLON.Color3(" + colorStep.color.r + ", " + colorStep.color.g + ", " + colorStep.color.b + ")));\r\n";
    }
    return codeString;
  };
  return GradientBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.GradientBlock"] = GradientBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/nLerpBlock.js
var NLerpBlock = function(_super) {
  __extends(NLerpBlock2, _super);
  function NLerpBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerInput("gradient", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    _this._outputs[0]._typeConnectionSource = _this._inputs[0];
    _this._linkConnectionTypes(0, 1);
    _this._linkConnectionTypes(1, 2, true);
    _this._inputs[2].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    return _this;
  }
  NLerpBlock2.prototype.getClassName = function() {
    return "NLerpBlock";
  };
  Object.defineProperty(NLerpBlock2.prototype, "left", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NLerpBlock2.prototype, "right", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NLerpBlock2.prototype, "gradient", {
    get: function() {
      return this._inputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NLerpBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  NLerpBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + (" = normalize(mix(" + this.left.associatedVariableName + " , " + this.right.associatedVariableName + ", " + this.gradient.associatedVariableName + "));\r\n");
    return this;
  };
  return NLerpBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.NLerpBlock"] = NLerpBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/worleyNoise3DBlock.js
var WorleyNoise3DBlock = function(_super) {
  __extends(WorleyNoise3DBlock2, _super);
  function WorleyNoise3DBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.manhattanDistance = false;
    _this.registerInput("seed", NodeMaterialBlockConnectionPointTypes.Vector3);
    _this.registerInput("jitter", NodeMaterialBlockConnectionPointTypes.Float);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector2);
    return _this;
  }
  WorleyNoise3DBlock2.prototype.getClassName = function() {
    return "WorleyNoise3DBlock";
  };
  Object.defineProperty(WorleyNoise3DBlock2.prototype, "seed", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WorleyNoise3DBlock2.prototype, "jitter", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WorleyNoise3DBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  WorleyNoise3DBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    if (!this.seed.isConnected) {
      return;
    }
    if (!this._outputs[0].hasEndpoints) {
      return;
    }
    var functionString = "vec3 permute(vec3 x){\r\n";
    functionString += "    return mod((34.0 * x + 1.0) * x, 289.0);\r\n";
    functionString += "}\r\n\r\n";
    functionString += "vec3 dist(vec3 x, vec3 y, vec3 z,  bool manhattanDistance){\r\n";
    functionString += "    return manhattanDistance ?  abs(x) + abs(y) + abs(z) :  (x * x + y * y + z * z);\r\n";
    functionString += "}\r\n\r\n";
    functionString += "vec2 worley(vec3 P, float jitter, bool manhattanDistance){\r\n";
    functionString += "    float K = 0.142857142857; // 1/7\r\n";
    functionString += "    float Ko = 0.428571428571; // 1/2-K/2\r\n";
    functionString += "    float  K2 = 0.020408163265306; // 1/(7*7)\r\n";
    functionString += "    float Kz = 0.166666666667; // 1/6\r\n";
    functionString += "    float Kzo = 0.416666666667; // 1/2-1/6*2\r\n";
    functionString += "\r\n";
    functionString += "    vec3 Pi = mod(floor(P), 289.0);\r\n";
    functionString += "    vec3 Pf = fract(P) - 0.5;\r\n";
    functionString += "\r\n";
    functionString += "    vec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\r\n";
    functionString += "    vec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\r\n";
    functionString += "    vec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\r\n";
    functionString += "\r\n";
    functionString += "    vec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\r\n";
    functionString += "    vec3 p1 = permute(p + Pi.y - 1.0);\r\n";
    functionString += "    vec3 p2 = permute(p + Pi.y);\r\n";
    functionString += "    vec3 p3 = permute(p + Pi.y + 1.0);\r\n";
    functionString += "\r\n";
    functionString += "    vec3 p11 = permute(p1 + Pi.z - 1.0);\r\n";
    functionString += "    vec3 p12 = permute(p1 + Pi.z);\r\n";
    functionString += "    vec3 p13 = permute(p1 + Pi.z + 1.0);\r\n";
    functionString += "\r\n";
    functionString += "    vec3 p21 = permute(p2 + Pi.z - 1.0);\r\n";
    functionString += "    vec3 p22 = permute(p2 + Pi.z);\r\n";
    functionString += "    vec3 p23 = permute(p2 + Pi.z + 1.0);\r\n";
    functionString += "\r\n";
    functionString += "    vec3 p31 = permute(p3 + Pi.z - 1.0);\r\n";
    functionString += "    vec3 p32 = permute(p3 + Pi.z);\r\n";
    functionString += "    vec3 p33 = permute(p3 + Pi.z + 1.0);\r\n";
    functionString += "\r\n";
    functionString += "    vec3 ox11 = fract(p11*K) - Ko;\r\n";
    functionString += "    vec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;\r\n";
    functionString += "    vec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\r\n";
    functionString += "\r\n";
    functionString += "    vec3 ox12 = fract(p12*K) - Ko;\r\n";
    functionString += "    vec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;\r\n";
    functionString += "    vec3 oz12 = floor(p12*K2)*Kz - Kzo;\r\n";
    functionString += "\r\n";
    functionString += "    vec3 ox13 = fract(p13*K) - Ko;\r\n";
    functionString += "    vec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;\r\n";
    functionString += "    vec3 oz13 = floor(p13*K2)*Kz - Kzo;\r\n";
    functionString += "\r\n";
    functionString += "    vec3 ox21 = fract(p21*K) - Ko;\r\n";
    functionString += "    vec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;\r\n";
    functionString += "    vec3 oz21 = floor(p21*K2)*Kz - Kzo;\r\n";
    functionString += "\r\n";
    functionString += "    vec3 ox22 = fract(p22*K) - Ko;\r\n";
    functionString += "    vec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;\r\n";
    functionString += "    vec3 oz22 = floor(p22*K2)*Kz - Kzo;\r\n";
    functionString += "\r\n";
    functionString += "    vec3 ox23 = fract(p23*K) - Ko;\r\n";
    functionString += "    vec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;\r\n";
    functionString += "    vec3 oz23 = floor(p23*K2)*Kz - Kzo;\r\n";
    functionString += "\r\n";
    functionString += "    vec3 ox31 = fract(p31*K) - Ko;\r\n";
    functionString += "    vec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;\r\n";
    functionString += "    vec3 oz31 = floor(p31*K2)*Kz - Kzo;\r\n";
    functionString += "\r\n";
    functionString += "    vec3 ox32 = fract(p32*K) - Ko;\r\n";
    functionString += "    vec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;\r\n";
    functionString += "    vec3 oz32 = floor(p32*K2)*Kz - Kzo;\r\n";
    functionString += "\r\n";
    functionString += "    vec3 ox33 = fract(p33*K) - Ko;\r\n";
    functionString += "    vec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;\r\n";
    functionString += "    vec3 oz33 = floor(p33*K2)*Kz - Kzo;\r\n";
    functionString += "\r\n";
    functionString += "    vec3 dx11 = Pfx + jitter*ox11;\r\n";
    functionString += "    vec3 dy11 = Pfy.x + jitter*oy11;\r\n";
    functionString += "    vec3 dz11 = Pfz.x + jitter*oz11;\r\n";
    functionString += "\r\n";
    functionString += "    vec3 dx12 = Pfx + jitter*ox12;\r\n";
    functionString += "    vec3 dy12 = Pfy.x + jitter*oy12;\r\n";
    functionString += "    vec3 dz12 = Pfz.y + jitter*oz12;\r\n";
    functionString += "\r\n";
    functionString += "    vec3 dx13 = Pfx + jitter*ox13;\r\n";
    functionString += "    vec3 dy13 = Pfy.x + jitter*oy13;\r\n";
    functionString += "    vec3 dz13 = Pfz.z + jitter*oz13;\r\n";
    functionString += "\r\n";
    functionString += "    vec3 dx21 = Pfx + jitter*ox21;\r\n";
    functionString += "    vec3 dy21 = Pfy.y + jitter*oy21;\r\n";
    functionString += "    vec3 dz21 = Pfz.x + jitter*oz21;\r\n";
    functionString += "\r\n";
    functionString += "    vec3 dx22 = Pfx + jitter*ox22;\r\n";
    functionString += "    vec3 dy22 = Pfy.y + jitter*oy22;\r\n";
    functionString += "    vec3 dz22 = Pfz.y + jitter*oz22;\r\n";
    functionString += "\r\n";
    functionString += "    vec3 dx23 = Pfx + jitter*ox23;\r\n";
    functionString += "    vec3 dy23 = Pfy.y + jitter*oy23;\r\n";
    functionString += "    vec3 dz23 = Pfz.z + jitter*oz23;\r\n";
    functionString += "\r\n";
    functionString += "    vec3 dx31 = Pfx + jitter*ox31;\r\n";
    functionString += "    vec3 dy31 = Pfy.z + jitter*oy31;\r\n";
    functionString += "    vec3 dz31 = Pfz.x + jitter*oz31;\r\n";
    functionString += "\r\n";
    functionString += "    vec3 dx32 = Pfx + jitter*ox32;\r\n";
    functionString += "    vec3 dy32 = Pfy.z + jitter*oy32;\r\n";
    functionString += "    vec3 dz32 = Pfz.y + jitter*oz32;\r\n";
    functionString += "\r\n";
    functionString += "    vec3 dx33 = Pfx + jitter*ox33;\r\n";
    functionString += "    vec3 dy33 = Pfy.z + jitter*oy33;\r\n";
    functionString += "    vec3 dz33 = Pfz.z + jitter*oz33;\r\n";
    functionString += "\r\n";
    functionString += "    vec3 d11 = dist(dx11, dy11, dz11, manhattanDistance);\r\n";
    functionString += "    vec3 d12 =dist(dx12, dy12, dz12, manhattanDistance);\r\n";
    functionString += "    vec3 d13 = dist(dx13, dy13, dz13, manhattanDistance);\r\n";
    functionString += "    vec3 d21 = dist(dx21, dy21, dz21, manhattanDistance);\r\n";
    functionString += "    vec3 d22 = dist(dx22, dy22, dz22, manhattanDistance);\r\n";
    functionString += "    vec3 d23 = dist(dx23, dy23, dz23, manhattanDistance);\r\n";
    functionString += "    vec3 d31 = dist(dx31, dy31, dz31, manhattanDistance);\r\n";
    functionString += "    vec3 d32 = dist(dx32, dy32, dz32, manhattanDistance);\r\n";
    functionString += "    vec3 d33 = dist(dx33, dy33, dz33, manhattanDistance);\r\n";
    functionString += "\r\n";
    functionString += "    vec3 d1a = min(d11, d12);\r\n";
    functionString += "    d12 = max(d11, d12);\r\n";
    functionString += "    d11 = min(d1a, d13); // Smallest now not in d12 or d13\r\n";
    functionString += "    d13 = max(d1a, d13);\r\n";
    functionString += "    d12 = min(d12, d13); // 2nd smallest now not in d13\r\n";
    functionString += "    vec3 d2a = min(d21, d22);\r\n";
    functionString += "    d22 = max(d21, d22);\r\n";
    functionString += "    d21 = min(d2a, d23); // Smallest now not in d22 or d23\r\n";
    functionString += "    d23 = max(d2a, d23);\r\n";
    functionString += "    d22 = min(d22, d23); // 2nd smallest now not in d23\r\n";
    functionString += "    vec3 d3a = min(d31, d32);\r\n";
    functionString += "    d32 = max(d31, d32);\r\n";
    functionString += "    d31 = min(d3a, d33); // Smallest now not in d32 or d33\r\n";
    functionString += "    d33 = max(d3a, d33);\r\n";
    functionString += "    d32 = min(d32, d33); // 2nd smallest now not in d33\r\n";
    functionString += "    vec3 da = min(d11, d21);\r\n";
    functionString += "    d21 = max(d11, d21);\r\n";
    functionString += "    d11 = min(da, d31); // Smallest now in d11\r\n";
    functionString += "    d31 = max(da, d31); // 2nd smallest now not in d31\r\n";
    functionString += "    d11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\r\n";
    functionString += "    d11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\r\n";
    functionString += "    d12 = min(d12, d21); // 2nd smallest now not in d21\r\n";
    functionString += "    d12 = min(d12, d22); // nor in d22\r\n";
    functionString += "    d12 = min(d12, d31); // nor in d31\r\n";
    functionString += "    d12 = min(d12, d32); // nor in d32\r\n";
    functionString += "    d11.yz = min(d11.yz,d12.xy); // nor in d12.yz\r\n";
    functionString += "    d11.y = min(d11.y,d12.z); // Only two more to go\r\n";
    functionString += "    d11.y = min(d11.y,d11.z); // Done! (Phew!)\r\n";
    functionString += "    return sqrt(d11.xy); // F1, F2\r\n";
    functionString += "}\r\n\r\n";
    state._emitFunction("worley3D", functionString, "// Worley3D");
    state.compilationString += this._declareOutput(this._outputs[0], state) + (" = worley(" + this.seed.associatedVariableName + ", " + this.jitter.associatedVariableName + ", " + this.manhattanDistance + ");\r\n");
    return this;
  };
  WorleyNoise3DBlock2.prototype._dumpPropertiesCode = function() {
    var codeString = this._codeVariableName + ".manhattanDistance = " + this.manhattanDistance + ";\r\n";
    return codeString;
  };
  WorleyNoise3DBlock2.prototype.serialize = function() {
    var serializationObject = _super.prototype.serialize.call(this);
    serializationObject.manhattanDistance = this.manhattanDistance;
    return serializationObject;
  };
  WorleyNoise3DBlock2.prototype._deserialize = function(serializationObject, scene, rootUrl) {
    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);
    this.manhattanDistance = serializationObject.manhattanDistance;
  };
  __decorate([
    editableInPropertyPage("Use Manhattan Distance", PropertyTypeForEdition.Boolean, "PROPERTIES", { "notifiers": { "update": false } })
  ], WorleyNoise3DBlock2.prototype, "manhattanDistance", void 0);
  return WorleyNoise3DBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.WorleyNoise3DBlock"] = WorleyNoise3DBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/simplexPerlin3DBlock.js
var SimplexPerlin3DBlock = function(_super) {
  __extends(SimplexPerlin3DBlock2, _super);
  function SimplexPerlin3DBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("seed", NodeMaterialBlockConnectionPointTypes.Vector3);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float);
    return _this;
  }
  SimplexPerlin3DBlock2.prototype.getClassName = function() {
    return "SimplexPerlin3DBlock";
  };
  Object.defineProperty(SimplexPerlin3DBlock2.prototype, "seed", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SimplexPerlin3DBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  SimplexPerlin3DBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    if (!this.seed.isConnected) {
      return;
    }
    if (!this._outputs[0].hasEndpoints) {
      return;
    }
    var functionString = "const float SKEWFACTOR = 1.0/3.0;\r\n";
    functionString += "const float UNSKEWFACTOR = 1.0/6.0;\r\n";
    functionString += "const float SIMPLEX_CORNER_POS = 0.5;\r\n";
    functionString += "const float SIMPLEX_TETRAHADRON_HEIGHT = 0.70710678118654752440084436210485;\r\n";
    functionString += "float SimplexPerlin3D( vec3 P ){\r\n";
    functionString += "    P *= SIMPLEX_TETRAHADRON_HEIGHT;\r\n";
    functionString += "    vec3 Pi = floor( P + dot( P, vec3( SKEWFACTOR) ) );";
    functionString += "    vec3 x0 = P - Pi + dot(Pi, vec3( UNSKEWFACTOR ) );\r\n";
    functionString += "    vec3 g = step(x0.yzx, x0.xyz);\r\n";
    functionString += "    vec3 l = 1.0 - g;\r\n";
    functionString += "    vec3 Pi_1 = min( g.xyz, l.zxy );\r\n";
    functionString += "    vec3 Pi_2 = max( g.xyz, l.zxy );\r\n";
    functionString += "    vec3 x1 = x0 - Pi_1 + UNSKEWFACTOR;\r\n";
    functionString += "    vec3 x2 = x0 - Pi_2 + SKEWFACTOR;\r\n";
    functionString += "    vec3 x3 = x0 - SIMPLEX_CORNER_POS;\r\n";
    functionString += "    vec4 v1234_x = vec4( x0.x, x1.x, x2.x, x3.x );\r\n";
    functionString += "    vec4 v1234_y = vec4( x0.y, x1.y, x2.y, x3.y );\r\n";
    functionString += "    vec4 v1234_z = vec4( x0.z, x1.z, x2.z, x3.z );\r\n";
    functionString += "    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\r\n";
    functionString += "    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\r\n";
    functionString += "    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\r\n";
    functionString += "    Pt *= Pt;\r\n";
    functionString += "    vec4 V1xy_V2xy = mix( Pt.xyxy, Pt.zwzw, vec4( Pi_1.xy, Pi_2.xy ) );\r\n";
    functionString += "    Pt = vec4( Pt.x, V1xy_V2xy.xz, Pt.z ) * vec4( Pt.y, V1xy_V2xy.yw, Pt.w );\r\n";
    functionString += "    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\r\n";
    functionString += "    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\r\n";
    functionString += "    vec3 lowz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + Pi.zzz * ZINC.xyz ) );\r\n";
    functionString += "    vec3 highz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + Pi_inc1.zzz * ZINC.xyz ) );\r\n";
    functionString += "    Pi_1 = ( Pi_1.z < 0.5 ) ? lowz_mods : highz_mods;\r\n";
    functionString += "    Pi_2 = ( Pi_2.z < 0.5 ) ? lowz_mods : highz_mods;\r\n";
    functionString += "    vec4 hash_0 = fract( Pt * vec4( lowz_mods.x, Pi_1.x, Pi_2.x, highz_mods.x ) ) - 0.49999;\r\n";
    functionString += "    vec4 hash_1 = fract( Pt * vec4( lowz_mods.y, Pi_1.y, Pi_2.y, highz_mods.y ) ) - 0.49999;\r\n";
    functionString += "    vec4 hash_2 = fract( Pt * vec4( lowz_mods.z, Pi_1.z, Pi_2.z, highz_mods.z ) ) - 0.49999;\r\n";
    functionString += "    vec4 grad_results = inversesqrt( hash_0 * hash_0 + hash_1 * hash_1 + hash_2 * hash_2 ) * ( hash_0 * v1234_x + hash_1 * v1234_y + hash_2 * v1234_z );\r\n";
    functionString += "    const float FINAL_NORMALIZATION = 37.837227241611314102871574478976;\r\n";
    functionString += "    vec4 kernel_weights = v1234_x * v1234_x + v1234_y * v1234_y + v1234_z * v1234_z;\r\n";
    functionString += "    kernel_weights = max(0.5 - kernel_weights, 0.0);\r\n";
    functionString += "    kernel_weights = kernel_weights*kernel_weights*kernel_weights;\r\n";
    functionString += "    return dot( kernel_weights, grad_results ) * FINAL_NORMALIZATION;\r\n";
    functionString += "}\r\n";
    state._emitFunction("SimplexPerlin3D", functionString, "// SimplexPerlin3D");
    state.compilationString += this._declareOutput(this._outputs[0], state) + (" = SimplexPerlin3D(" + this.seed.associatedVariableName + ");\r\n");
    return this;
  };
  return SimplexPerlin3DBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.SimplexPerlin3DBlock"] = SimplexPerlin3DBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/normalBlendBlock.js
var NormalBlendBlock = function(_super) {
  __extends(NormalBlendBlock2, _super);
  function NormalBlendBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("normalMap0", NodeMaterialBlockConnectionPointTypes.Vector3);
    _this.registerInput("normalMap1", NodeMaterialBlockConnectionPointTypes.Vector3);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector3);
    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Color3);
    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Color4);
    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector4);
    _this._inputs[1].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Color3);
    _this._inputs[1].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Color4);
    _this._inputs[1].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector4);
    return _this;
  }
  NormalBlendBlock2.prototype.getClassName = function() {
    return "NormalBlendBlock";
  };
  Object.defineProperty(NormalBlendBlock2.prototype, "normalMap0", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NormalBlendBlock2.prototype, "normalMap1", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NormalBlendBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  NormalBlendBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    var input0 = this._inputs[0];
    var input1 = this._inputs[1];
    var stepR = state._getFreeVariableName("stepR");
    var stepG = state._getFreeVariableName("stepG");
    state.compilationString += "float " + stepR + " = step(0.5, " + input0.associatedVariableName + ".r);\r\n";
    state.compilationString += "float " + stepG + " = step(0.5, " + input0.associatedVariableName + ".g);\r\n";
    state.compilationString += this._declareOutput(output, state) + ";\r\n";
    state.compilationString += output.associatedVariableName + ".r = (1.0 - " + stepR + ") * " + input0.associatedVariableName + ".r * " + input1.associatedVariableName + ".r * 2.0 + " + stepR + " * (1.0 - " + input0.associatedVariableName + ".r) * (1.0 - " + input1.associatedVariableName + ".r) * 2.0;\r\n";
    state.compilationString += output.associatedVariableName + ".g = (1.0 - " + stepG + ") * " + input0.associatedVariableName + ".g * " + input1.associatedVariableName + ".g * 2.0 + " + stepG + " * (1.0 - " + input0.associatedVariableName + ".g) * (1.0 - " + input1.associatedVariableName + ".g) * 2.0;\r\n";
    state.compilationString += output.associatedVariableName + ".b = " + input0.associatedVariableName + ".b * " + input1.associatedVariableName + ".b;\r\n";
    return this;
  };
  return NormalBlendBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.NormalBlendBlock"] = NormalBlendBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/rotate2dBlock.js
var Rotate2dBlock = function(_super) {
  __extends(Rotate2dBlock2, _super);
  function Rotate2dBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("input", NodeMaterialBlockConnectionPointTypes.Vector2);
    _this.registerInput("angle", NodeMaterialBlockConnectionPointTypes.Float);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector2);
    return _this;
  }
  Rotate2dBlock2.prototype.getClassName = function() {
    return "Rotate2dBlock";
  };
  Object.defineProperty(Rotate2dBlock2.prototype, "input", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Rotate2dBlock2.prototype, "angle", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Rotate2dBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Rotate2dBlock2.prototype.autoConfigure = function(material) {
    if (!this.angle.isConnected) {
      var angleInput = new InputBlock("angle");
      angleInput.value = 0;
      angleInput.output.connectTo(this.angle);
    }
  };
  Rotate2dBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    var angle = this.angle;
    var input = this.input;
    state.compilationString += this._declareOutput(output, state) + (" = vec2(cos(" + angle.associatedVariableName + ") * " + input.associatedVariableName + ".x - sin(" + angle.associatedVariableName + ") * " + input.associatedVariableName + ".y, sin(" + angle.associatedVariableName + ") * " + input.associatedVariableName + ".x + cos(" + angle.associatedVariableName + ") * " + input.associatedVariableName + ".y);\r\n");
    return this;
  };
  return Rotate2dBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.Rotate2dBlock"] = Rotate2dBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/reflectBlock.js
var ReflectBlock = function(_super) {
  __extends(ReflectBlock2, _super);
  function ReflectBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("incident", NodeMaterialBlockConnectionPointTypes.Vector3);
    _this.registerInput("normal", NodeMaterialBlockConnectionPointTypes.Vector3);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector3);
    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector4);
    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Color3);
    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Color4);
    _this._inputs[1].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector4);
    _this._inputs[1].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Color3);
    _this._inputs[1].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Color4);
    return _this;
  }
  ReflectBlock2.prototype.getClassName = function() {
    return "ReflectBlock";
  };
  Object.defineProperty(ReflectBlock2.prototype, "incident", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReflectBlock2.prototype, "normal", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReflectBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  ReflectBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + (" = reflect(" + this.incident.associatedVariableName + ".xyz, " + this.normal.associatedVariableName + ".xyz);\r\n");
    return this;
  };
  return ReflectBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.ReflectBlock"] = ReflectBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/refractBlock.js
var RefractBlock = function(_super) {
  __extends(RefractBlock2, _super);
  function RefractBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("incident", NodeMaterialBlockConnectionPointTypes.Vector3);
    _this.registerInput("normal", NodeMaterialBlockConnectionPointTypes.Vector3);
    _this.registerInput("ior", NodeMaterialBlockConnectionPointTypes.Float);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector3);
    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector4);
    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Color3);
    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Color4);
    _this._inputs[1].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector4);
    _this._inputs[1].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Color3);
    _this._inputs[1].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Color4);
    return _this;
  }
  RefractBlock2.prototype.getClassName = function() {
    return "RefractBlock";
  };
  Object.defineProperty(RefractBlock2.prototype, "incident", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RefractBlock2.prototype, "normal", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RefractBlock2.prototype, "ior", {
    get: function() {
      return this._inputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RefractBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  RefractBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + (" = refract(" + this.incident.associatedVariableName + ".xyz, " + this.normal.associatedVariableName + ".xyz, " + this.ior.associatedVariableName + ");\r\n");
    return this;
  };
  return RefractBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.RefractBlock"] = RefractBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/desaturateBlock.js
var DesaturateBlock = function(_super) {
  __extends(DesaturateBlock2, _super);
  function DesaturateBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("color", NodeMaterialBlockConnectionPointTypes.Color3);
    _this.registerInput("level", NodeMaterialBlockConnectionPointTypes.Float);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Color3);
    return _this;
  }
  DesaturateBlock2.prototype.getClassName = function() {
    return "DesaturateBlock";
  };
  Object.defineProperty(DesaturateBlock2.prototype, "color", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DesaturateBlock2.prototype, "level", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DesaturateBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  DesaturateBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    var color = this.color;
    var colorName = color.associatedVariableName;
    var tempMin = state._getFreeVariableName("colorMin");
    var tempMax = state._getFreeVariableName("colorMax");
    var tempMerge = state._getFreeVariableName("colorMerge");
    state.compilationString += "float " + tempMin + " = min(min(" + colorName + ".x, " + colorName + ".y), " + colorName + ".z);\r\n";
    state.compilationString += "float " + tempMax + " = max(max(" + colorName + ".x, " + colorName + ".y), " + colorName + ".z);\r\n";
    state.compilationString += "float " + tempMerge + " = 0.5 * (" + tempMin + " + " + tempMax + ");\r\n";
    state.compilationString += this._declareOutput(output, state) + (" = mix(" + colorName + ", vec3(" + tempMerge + ", " + tempMerge + ", " + tempMerge + "), " + this.level.associatedVariableName + ");\r\n");
    return this;
  };
  return DesaturateBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.DesaturateBlock"] = DesaturateBlock;

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialConnectionPointCustomObject.js
var NodeMaterialConnectionPointCustomObject = function(_super) {
  __extends(NodeMaterialConnectionPointCustomObject2, _super);
  function NodeMaterialConnectionPointCustomObject2(name98, ownerBlock, direction, _blockType, _blockName, _nameForCheking) {
    var _this = _super.call(this, name98, ownerBlock, direction) || this;
    _this._blockType = _blockType;
    _this._blockName = _blockName;
    _this._nameForCheking = _nameForCheking;
    if (!_this._nameForCheking) {
      _this._nameForCheking = name98;
    }
    _this.needDualDirectionValidation = true;
    return _this;
  }
  NodeMaterialConnectionPointCustomObject2.prototype.checkCompatibilityState = function(connectionPoint) {
    return connectionPoint instanceof NodeMaterialConnectionPointCustomObject2 && connectionPoint.name === this._nameForCheking ? NodeMaterialConnectionPointCompatibilityStates.Compatible : NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;
  };
  NodeMaterialConnectionPointCustomObject2.prototype.createCustomInputBlock = function() {
    return [new this._blockType(this._blockName), this.name];
  };
  return NodeMaterialConnectionPointCustomObject2;
}(NodeMaterialConnectionPoint);

// node_modules/@babylonjs/core/Materials/Node/Blocks/PBR/sheenBlock.js
var SheenBlock = function(_super) {
  __extends(SheenBlock2, _super);
  function SheenBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Fragment) || this;
    _this.albedoScaling = false;
    _this.linkSheenWithAlbedo = false;
    _this._isUnique = true;
    _this.registerInput("intensity", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("color", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("roughness", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("sheen", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("sheen", _this, NodeMaterialConnectionPointDirection.Output, SheenBlock2, "SheenBlock"));
    return _this;
  }
  SheenBlock2.prototype.initialize = function(state) {
    state._excludeVariableName("sheenOut");
    state._excludeVariableName("sheenMapData");
    state._excludeVariableName("vSheenColor");
    state._excludeVariableName("vSheenRoughness");
  };
  SheenBlock2.prototype.getClassName = function() {
    return "SheenBlock";
  };
  Object.defineProperty(SheenBlock2.prototype, "intensity", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SheenBlock2.prototype, "color", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SheenBlock2.prototype, "roughness", {
    get: function() {
      return this._inputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SheenBlock2.prototype, "sheen", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  SheenBlock2.prototype.prepareDefines = function(mesh, nodeMaterial, defines) {
    _super.prototype.prepareDefines.call(this, mesh, nodeMaterial, defines);
    defines.setValue("SHEEN", true);
    defines.setValue("SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE", true, true);
    defines.setValue("SHEEN_LINKWITHALBEDO", this.linkSheenWithAlbedo, true);
    defines.setValue("SHEEN_ROUGHNESS", this.roughness.isConnected, true);
    defines.setValue("SHEEN_ALBEDOSCALING", this.albedoScaling, true);
  };
  SheenBlock2.prototype.getCode = function(reflectionBlock) {
    var code = "";
    var color = this.color.isConnected ? this.color.associatedVariableName : "vec3(1.)";
    var intensity = this.intensity.isConnected ? this.intensity.associatedVariableName : "1.";
    var roughness = this.roughness.isConnected ? this.roughness.associatedVariableName : "0.";
    var texture = "vec4(0.)";
    code = "#ifdef SHEEN\n            sheenOutParams sheenOut;\n\n            vec4 vSheenColor = vec4(" + color + ", " + intensity + ");\n\n            sheenBlock(\n                vSheenColor,\n            #ifdef SHEEN_ROUGHNESS\n                " + roughness + ",\n            #endif\n                roughness,\n            #ifdef SHEEN_TEXTURE\n                " + texture + ",\n            #endif\n                reflectance,\n            #ifdef SHEEN_LINKWITHALBEDO\n                baseColor,\n                surfaceAlbedo,\n            #endif\n            #ifdef ENVIRONMENTBRDF\n                NdotV,\n                environmentBrdf,\n            #endif\n            #if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\n                AARoughnessFactors,\n                " + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._vReflectionMicrosurfaceInfosName) + ",\n                " + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._vReflectionInfosName) + ",\n                " + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock.reflectionColor) + ",\n                vLightingIntensity,\n                #ifdef " + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._define3DName) + "\n                    " + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._cubeSamplerName) + ",\n                #else\n                    " + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._2DSamplerName) + ",\n                #endif\n                reflectionOut.reflectionCoords,\n                NdotVUnclamped,\n                #ifndef LODBASEDMICROSFURACE\n                    #ifdef " + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._define3DName) + "\n                        " + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._cubeSamplerName) + ",\n                        " + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._cubeSamplerName) + ",\n                    #else\n                        " + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._2DSamplerName) + ",\n                        " + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._2DSamplerName) + ",\n                    #endif\n                #endif\n                #if !defined(" + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineSkyboxName) + ") && defined(RADIANCEOCCLUSION)\n                    seo,\n                #endif\n                #if !defined(" + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineSkyboxName) + ") && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(" + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._define3DName) + ")\n                    eho,\n                #endif\n            #endif\n                sheenOut\n            );\n\n            #ifdef SHEEN_LINKWITHALBEDO\n                surfaceAlbedo = sheenOut.surfaceAlbedo;\n            #endif\n        #endif\r\n";
    return code;
  };
  SheenBlock2.prototype._buildBlock = function(state) {
    if (state.target === NodeMaterialBlockTargets.Fragment) {
      state.sharedData.blocksWithDefines.push(this);
    }
    return this;
  };
  SheenBlock2.prototype._dumpPropertiesCode = function() {
    var codeString = _super.prototype._dumpPropertiesCode.call(this);
    codeString += this._codeVariableName + ".albedoScaling = " + this.albedoScaling + ";\r\n";
    codeString += this._codeVariableName + ".linkSheenWithAlbedo = " + this.linkSheenWithAlbedo + ";\r\n";
    return codeString;
  };
  SheenBlock2.prototype.serialize = function() {
    var serializationObject = _super.prototype.serialize.call(this);
    serializationObject.albedoScaling = this.albedoScaling;
    serializationObject.linkSheenWithAlbedo = this.linkSheenWithAlbedo;
    return serializationObject;
  };
  SheenBlock2.prototype._deserialize = function(serializationObject, scene, rootUrl) {
    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);
    this.albedoScaling = serializationObject.albedoScaling;
    this.linkSheenWithAlbedo = serializationObject.linkSheenWithAlbedo;
  };
  __decorate([
    editableInPropertyPage("Albedo scaling", PropertyTypeForEdition.Boolean, "PROPERTIES", { "notifiers": { "update": true } })
  ], SheenBlock2.prototype, "albedoScaling", void 0);
  __decorate([
    editableInPropertyPage("Link sheen with albedo", PropertyTypeForEdition.Boolean, "PROPERTIES", { "notifiers": { "update": true } })
  ], SheenBlock2.prototype, "linkSheenWithAlbedo", void 0);
  return SheenBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.SheenBlock"] = SheenBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/PBR/anisotropyBlock.js
var AnisotropyBlock = function(_super) {
  __extends(AnisotropyBlock2, _super);
  function AnisotropyBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Fragment) || this;
    _this._isUnique = true;
    _this.registerInput("intensity", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("direction", NodeMaterialBlockConnectionPointTypes.Vector2, true, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.Vector2, true);
    _this.registerInput("worldTangent", NodeMaterialBlockConnectionPointTypes.Vector4, true);
    _this.registerOutput("anisotropy", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("anisotropy", _this, NodeMaterialConnectionPointDirection.Output, AnisotropyBlock2, "AnisotropyBlock"));
    return _this;
  }
  AnisotropyBlock2.prototype.initialize = function(state) {
    state._excludeVariableName("anisotropicOut");
    state._excludeVariableName("TBN");
  };
  AnisotropyBlock2.prototype.getClassName = function() {
    return "AnisotropyBlock";
  };
  Object.defineProperty(AnisotropyBlock2.prototype, "intensity", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnisotropyBlock2.prototype, "direction", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnisotropyBlock2.prototype, "uv", {
    get: function() {
      return this._inputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnisotropyBlock2.prototype, "worldTangent", {
    get: function() {
      return this._inputs[3];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnisotropyBlock2.prototype, "anisotropy", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  AnisotropyBlock2.prototype._generateTBNSpace = function(state) {
    var code = "";
    var comments = "//" + this.name;
    var uv = this.uv;
    var worldPosition = this.worldPositionConnectionPoint;
    var worldNormal = this.worldNormalConnectionPoint;
    var worldTangent = this.worldTangent;
    if (!uv.isConnected) {
      console.error("You must connect the 'uv' input of the Anisotropy block!");
    }
    state._emitExtension("derivatives", "#extension GL_OES_standard_derivatives : enable");
    var tangentReplaceString = { search: /defined\(TANGENT\)/g, replace: worldTangent.isConnected ? "defined(TANGENT)" : "defined(IGNORE)" };
    if (worldTangent.isConnected) {
      code += "vec3 tbnNormal = normalize(" + worldNormal.associatedVariableName + ".xyz);\r\n";
      code += "vec3 tbnTangent = normalize(" + worldTangent.associatedVariableName + ".xyz);\r\n";
      code += "vec3 tbnBitangent = cross(tbnNormal, tbnTangent);\r\n";
      code += "mat3 vTBN = mat3(tbnTangent, tbnBitangent, tbnNormal);\r\n";
    }
    code += "\n            #if defined(" + (worldTangent.isConnected ? "TANGENT" : "IGNORE") + ") && defined(NORMAL)\n                mat3 TBN = vTBN;\n            #else\n                mat3 TBN = cotangent_frame(" + (worldNormal.associatedVariableName + ".xyz") + ", " + ("v_" + worldPosition.associatedVariableName + ".xyz") + ", " + (uv.isConnected ? uv.associatedVariableName : "vec2(0.)") + ", vec2(1., 1.));\n            #endif\r\n";
    state._emitFunctionFromInclude("bumpFragmentMainFunctions", comments, {
      replaceStrings: [
        tangentReplaceString
      ]
    });
    return code;
  };
  AnisotropyBlock2.prototype.getCode = function(state, generateTBNSpace) {
    if (generateTBNSpace === void 0) {
      generateTBNSpace = false;
    }
    var code = "";
    if (generateTBNSpace) {
      code += this._generateTBNSpace(state);
    }
    var intensity = this.intensity.isConnected ? this.intensity.associatedVariableName : "1.0";
    var direction = this.direction.isConnected ? this.direction.associatedVariableName : "vec2(1., 0.)";
    code += "anisotropicOutParams anisotropicOut;\n            anisotropicBlock(\n                vec3(" + direction + ", " + intensity + "),\n            #ifdef ANISOTROPIC_TEXTURE\n                vec3(0.),\n            #endif\n                TBN,\n                normalW,\n                viewDirectionW,\n                anisotropicOut\n            );\r\n";
    return code;
  };
  AnisotropyBlock2.prototype.prepareDefines = function(mesh, nodeMaterial, defines) {
    _super.prototype.prepareDefines.call(this, mesh, nodeMaterial, defines);
    defines.setValue("ANISOTROPIC", true);
    defines.setValue("ANISOTROPIC_TEXTURE", false, true);
  };
  AnisotropyBlock2.prototype._buildBlock = function(state) {
    if (state.target === NodeMaterialBlockTargets.Fragment) {
      state.sharedData.blocksWithDefines.push(this);
    }
    return this;
  };
  return AnisotropyBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.AnisotropyBlock"] = AnisotropyBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/PBR/reflectionBlock.js
var ReflectionBlock = function(_super) {
  __extends(ReflectionBlock2, _super);
  function ReflectionBlock2(name98) {
    var _this = _super.call(this, name98) || this;
    _this.useSphericalHarmonics = true;
    _this.forceIrradianceInFragment = false;
    _this._isUnique = true;
    _this.registerInput("position", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Vertex);
    _this.registerInput("world", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Vertex);
    _this.registerInput("color", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("reflection", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("reflection", _this, NodeMaterialConnectionPointDirection.Output, ReflectionBlock2, "ReflectionBlock"));
    return _this;
  }
  ReflectionBlock2.prototype.getClassName = function() {
    return "ReflectionBlock";
  };
  Object.defineProperty(ReflectionBlock2.prototype, "position", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReflectionBlock2.prototype, "worldPosition", {
    get: function() {
      return this.worldPositionConnectionPoint;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReflectionBlock2.prototype, "worldNormal", {
    get: function() {
      return this.worldNormalConnectionPoint;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReflectionBlock2.prototype, "world", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReflectionBlock2.prototype, "cameraPosition", {
    get: function() {
      return this.cameraPositionConnectionPoint;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReflectionBlock2.prototype, "view", {
    get: function() {
      return this.viewConnectionPoint;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReflectionBlock2.prototype, "color", {
    get: function() {
      return this._inputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReflectionBlock2.prototype, "reflection", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReflectionBlock2.prototype, "hasTexture", {
    get: function() {
      return !!this._getTexture();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ReflectionBlock2.prototype, "reflectionColor", {
    get: function() {
      return this.color.isConnected ? this.color.associatedVariableName : "vec3(1., 1., 1.)";
    },
    enumerable: false,
    configurable: true
  });
  ReflectionBlock2.prototype._getTexture = function() {
    if (this.texture) {
      return this.texture;
    }
    return this._scene.environmentTexture;
  };
  ReflectionBlock2.prototype.prepareDefines = function(mesh, nodeMaterial, defines) {
    _super.prototype.prepareDefines.call(this, mesh, nodeMaterial, defines);
    var reflectionTexture = this._getTexture();
    var reflection = reflectionTexture && reflectionTexture.getTextureMatrix;
    defines.setValue("REFLECTION", reflection, true);
    if (!reflection) {
      return;
    }
    defines.setValue(this._defineLODReflectionAlpha, reflectionTexture.lodLevelInAlpha, true);
    defines.setValue(this._defineLinearSpecularReflection, reflectionTexture.linearSpecularLOD, true);
    defines.setValue(this._defineOppositeZ, this._scene.useRightHandedSystem ? !reflectionTexture.invertZ : reflectionTexture.invertZ, true);
    defines.setValue("SPHERICAL_HARMONICS", this.useSphericalHarmonics, true);
    defines.setValue("GAMMAREFLECTION", reflectionTexture.gammaSpace, true);
    defines.setValue("RGBDREFLECTION", reflectionTexture.isRGBD, true);
    if (reflectionTexture && reflectionTexture.coordinatesMode !== Texture.SKYBOX_MODE) {
      if (reflectionTexture.isCube) {
        defines.setValue("USESPHERICALFROMREFLECTIONMAP", true);
        defines.setValue("USEIRRADIANCEMAP", false);
        if (this.forceIrradianceInFragment || this._scene.getEngine().getCaps().maxVaryingVectors <= 8) {
          defines.setValue("USESPHERICALINVERTEX", false);
        } else {
          defines.setValue("USESPHERICALINVERTEX", true);
        }
      }
    }
  };
  ReflectionBlock2.prototype.bind = function(effect, nodeMaterial, mesh, subMesh) {
    _super.prototype.bind.call(this, effect, nodeMaterial, mesh);
    var reflectionTexture = this._getTexture();
    if (!reflectionTexture || !subMesh) {
      return;
    }
    if (reflectionTexture.isCube) {
      effect.setTexture(this._cubeSamplerName, reflectionTexture);
    } else {
      effect.setTexture(this._2DSamplerName, reflectionTexture);
    }
    var width = reflectionTexture.getSize().width;
    effect.setFloat3(this._vReflectionMicrosurfaceInfosName, width, reflectionTexture.lodGenerationScale, reflectionTexture.lodGenerationOffset);
    effect.setFloat2(this._vReflectionFilteringInfoName, width, Scalar.Log2(width));
    var defines = subMesh._materialDefines;
    var polynomials = reflectionTexture.sphericalPolynomial;
    if (defines.USESPHERICALFROMREFLECTIONMAP && polynomials) {
      if (defines.SPHERICAL_HARMONICS) {
        var preScaledHarmonics = polynomials.preScaledHarmonics;
        effect.setVector3("vSphericalL00", preScaledHarmonics.l00);
        effect.setVector3("vSphericalL1_1", preScaledHarmonics.l1_1);
        effect.setVector3("vSphericalL10", preScaledHarmonics.l10);
        effect.setVector3("vSphericalL11", preScaledHarmonics.l11);
        effect.setVector3("vSphericalL2_2", preScaledHarmonics.l2_2);
        effect.setVector3("vSphericalL2_1", preScaledHarmonics.l2_1);
        effect.setVector3("vSphericalL20", preScaledHarmonics.l20);
        effect.setVector3("vSphericalL21", preScaledHarmonics.l21);
        effect.setVector3("vSphericalL22", preScaledHarmonics.l22);
      } else {
        effect.setFloat3("vSphericalX", polynomials.x.x, polynomials.x.y, polynomials.x.z);
        effect.setFloat3("vSphericalY", polynomials.y.x, polynomials.y.y, polynomials.y.z);
        effect.setFloat3("vSphericalZ", polynomials.z.x, polynomials.z.y, polynomials.z.z);
        effect.setFloat3("vSphericalXX_ZZ", polynomials.xx.x - polynomials.zz.x, polynomials.xx.y - polynomials.zz.y, polynomials.xx.z - polynomials.zz.z);
        effect.setFloat3("vSphericalYY_ZZ", polynomials.yy.x - polynomials.zz.x, polynomials.yy.y - polynomials.zz.y, polynomials.yy.z - polynomials.zz.z);
        effect.setFloat3("vSphericalZZ", polynomials.zz.x, polynomials.zz.y, polynomials.zz.z);
        effect.setFloat3("vSphericalXY", polynomials.xy.x, polynomials.xy.y, polynomials.xy.z);
        effect.setFloat3("vSphericalYZ", polynomials.yz.x, polynomials.yz.y, polynomials.yz.z);
        effect.setFloat3("vSphericalZX", polynomials.zx.x, polynomials.zx.y, polynomials.zx.z);
      }
    }
  };
  ReflectionBlock2.prototype.handleVertexSide = function(state) {
    var code = _super.prototype.handleVertexSide.call(this, state);
    state._emitFunctionFromInclude("harmonicsFunctions", "//" + this.name, {
      replaceStrings: [
        { search: /uniform vec3 vSphericalL00;[\s\S]*?uniform vec3 vSphericalL22;/g, replace: "" },
        { search: /uniform vec3 vSphericalX;[\s\S]*?uniform vec3 vSphericalZX;/g, replace: "" }
      ]
    });
    var reflectionVectorName = state._getFreeVariableName("reflectionVector");
    this._vEnvironmentIrradianceName = state._getFreeVariableName("vEnvironmentIrradiance");
    state._emitVaryingFromString(this._vEnvironmentIrradianceName, "vec3", "defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)");
    state._emitUniformFromString("vSphericalL00", "vec3", "SPHERICAL_HARMONICS");
    state._emitUniformFromString("vSphericalL1_1", "vec3", "SPHERICAL_HARMONICS");
    state._emitUniformFromString("vSphericalL10", "vec3", "SPHERICAL_HARMONICS");
    state._emitUniformFromString("vSphericalL11", "vec3", "SPHERICAL_HARMONICS");
    state._emitUniformFromString("vSphericalL2_2", "vec3", "SPHERICAL_HARMONICS");
    state._emitUniformFromString("vSphericalL2_1", "vec3", "SPHERICAL_HARMONICS");
    state._emitUniformFromString("vSphericalL20", "vec3", "SPHERICAL_HARMONICS");
    state._emitUniformFromString("vSphericalL21", "vec3", "SPHERICAL_HARMONICS");
    state._emitUniformFromString("vSphericalL22", "vec3", "SPHERICAL_HARMONICS");
    state._emitUniformFromString("vSphericalX", "vec3", "SPHERICAL_HARMONICS", true);
    state._emitUniformFromString("vSphericalY", "vec3", "SPHERICAL_HARMONICS", true);
    state._emitUniformFromString("vSphericalZ", "vec3", "SPHERICAL_HARMONICS", true);
    state._emitUniformFromString("vSphericalXX_ZZ", "vec3", "SPHERICAL_HARMONICS", true);
    state._emitUniformFromString("vSphericalYY_ZZ", "vec3", "SPHERICAL_HARMONICS", true);
    state._emitUniformFromString("vSphericalZZ", "vec3", "SPHERICAL_HARMONICS", true);
    state._emitUniformFromString("vSphericalXY", "vec3", "SPHERICAL_HARMONICS", true);
    state._emitUniformFromString("vSphericalYZ", "vec3", "SPHERICAL_HARMONICS", true);
    state._emitUniformFromString("vSphericalZX", "vec3", "SPHERICAL_HARMONICS", true);
    code += "#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\n                vec3 " + reflectionVectorName + " = vec3(" + this._reflectionMatrixName + " * vec4(normalize(" + this.worldNormal.associatedVariableName + ").xyz, 0)).xyz;\n                #ifdef " + this._defineOppositeZ + "\n                    " + reflectionVectorName + ".z *= -1.0;\n                #endif\n                " + this._vEnvironmentIrradianceName + " = computeEnvironmentIrradiance(" + reflectionVectorName + ");\n            #endif\r\n";
    return code;
  };
  ReflectionBlock2.prototype.getCode = function(state, normalVarName) {
    var code = "";
    this.handleFragmentSideInits(state);
    state._emitFunctionFromInclude("harmonicsFunctions", "//" + this.name, {
      replaceStrings: [
        { search: /uniform vec3 vSphericalL00;[\s\S]*?uniform vec3 vSphericalL22;/g, replace: "" },
        { search: /uniform vec3 vSphericalX;[\s\S]*?uniform vec3 vSphericalZX;/g, replace: "" }
      ]
    });
    state._emitFunction("sampleReflection", "\n            #ifdef " + this._define3DName + "\n                #define sampleReflection(s, c) textureCube(s, c)\n            #else\n                #define sampleReflection(s, c) texture2D(s, c)\n            #endif\r\n", "//" + this.name);
    state._emitFunction("sampleReflectionLod", "\n            #ifdef " + this._define3DName + "\n                #define sampleReflectionLod(s, c, l) textureCubeLodEXT(s, c, l)\n            #else\n                #define sampleReflectionLod(s, c, l) texture2DLodEXT(s, c, l)\n            #endif\r\n", "//" + this.name);
    var computeReflectionCoordsFunc = "\n            vec3 computeReflectionCoordsPBR(vec4 worldPos, vec3 worldNormal) {\n                " + this.handleFragmentSideCodeReflectionCoords("worldNormal", "worldPos", true) + "\n                return " + this._reflectionVectorName + ";\n            }\r\n";
    state._emitFunction("computeReflectionCoordsPBR", computeReflectionCoordsFunc, "//" + this.name);
    this._vReflectionMicrosurfaceInfosName = state._getFreeVariableName("vReflectionMicrosurfaceInfos");
    state._emitUniformFromString(this._vReflectionMicrosurfaceInfosName, "vec3");
    this._vReflectionInfosName = state._getFreeVariableName("vReflectionInfos");
    this._vReflectionFilteringInfoName = state._getFreeVariableName("vReflectionFilteringInfo");
    state._emitUniformFromString(this._vReflectionFilteringInfoName, "vec2");
    code += "#ifdef REFLECTION\n            vec2 " + this._vReflectionInfosName + " = vec2(1., 0.);\n\n            reflectionOutParams reflectionOut;\n\n            reflectionBlock(\n                " + ("v_" + this.worldPosition.associatedVariableName + ".xyz") + ",\n                " + normalVarName + ",\n                alphaG,\n                " + this._vReflectionMicrosurfaceInfosName + ",\n                " + this._vReflectionInfosName + ",\n                " + this.reflectionColor + ",\n            #ifdef ANISOTROPIC\n                anisotropicOut,\n            #endif\n            #if defined(" + this._defineLODReflectionAlpha + ") && !defined(" + this._defineSkyboxName + ")\n                NdotVUnclamped,\n            #endif\n            #ifdef " + this._defineLinearSpecularReflection + "\n                roughness,\n            #endif\n            #ifdef " + this._define3DName + "\n                " + this._cubeSamplerName + ",\n            #else\n                " + this._2DSamplerName + ",\n            #endif\n            #if defined(NORMAL) && defined(USESPHERICALINVERTEX)\n                " + this._vEnvironmentIrradianceName + ",\n            #endif\n            #ifdef USESPHERICALFROMREFLECTIONMAP\n                #if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\n                    " + this._reflectionMatrixName + ",\n                #endif\n            #endif\n            #ifdef USEIRRADIANCEMAP\n                irradianceSampler, // ** not handled **\n            #endif\n            #ifndef LODBASEDMICROSFURACE\n                #ifdef " + this._define3DName + "\n                    " + this._cubeSamplerName + ",\n                    " + this._cubeSamplerName + ",\n                #else\n                    " + this._2DSamplerName + ",\n                    " + this._2DSamplerName + ",\n                #endif\n            #endif\n            #ifdef REALTIME_FILTERING\n                " + this._vReflectionFilteringInfoName + ",\n            #endif\n                reflectionOut\n            );\n        #endif\r\n";
    return code;
  };
  ReflectionBlock2.prototype._buildBlock = function(state) {
    this._scene = state.sharedData.scene;
    if (state.target !== NodeMaterialBlockTargets.Fragment) {
      this._defineLODReflectionAlpha = state._getFreeDefineName("LODINREFLECTIONALPHA");
      this._defineLinearSpecularReflection = state._getFreeDefineName("LINEARSPECULARREFLECTION");
    }
    return this;
  };
  ReflectionBlock2.prototype._dumpPropertiesCode = function() {
    var codeString = _super.prototype._dumpPropertiesCode.call(this);
    if (this.texture) {
      codeString += this._codeVariableName + ".texture.gammaSpace = " + this.texture.gammaSpace + ");\r\n";
    }
    codeString += this._codeVariableName + ".useSphericalHarmonics = " + this.useSphericalHarmonics + ";\r\n";
    codeString += this._codeVariableName + ".forceIrradianceInFragment = " + this.forceIrradianceInFragment + ";\r\n";
    return codeString;
  };
  ReflectionBlock2.prototype.serialize = function() {
    var _a, _b;
    var serializationObject = _super.prototype.serialize.call(this);
    serializationObject.useSphericalHarmonics = this.useSphericalHarmonics;
    serializationObject.forceIrradianceInFragment = this.forceIrradianceInFragment;
    serializationObject.gammaSpace = (_b = (_a = this.texture) === null || _a === void 0 ? void 0 : _a.gammaSpace) !== null && _b !== void 0 ? _b : true;
    return serializationObject;
  };
  ReflectionBlock2.prototype._deserialize = function(serializationObject, scene, rootUrl) {
    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);
    this.useSphericalHarmonics = serializationObject.useSphericalHarmonics;
    this.forceIrradianceInFragment = serializationObject.forceIrradianceInFragment;
    if (this.texture) {
      this.texture.gammaSpace = serializationObject.gammaSpace;
    }
  };
  __decorate([
    editableInPropertyPage("Spherical Harmonics", PropertyTypeForEdition.Boolean, "ADVANCED", { "notifiers": { "update": true } })
  ], ReflectionBlock2.prototype, "useSphericalHarmonics", void 0);
  __decorate([
    editableInPropertyPage("Force irradiance in fragment", PropertyTypeForEdition.Boolean, "ADVANCED", { "notifiers": { "update": true } })
  ], ReflectionBlock2.prototype, "forceIrradianceInFragment", void 0);
  return ReflectionBlock2;
}(ReflectionTextureBaseBlock);
_TypeStore.RegisteredTypes["BABYLON.ReflectionBlock"] = ReflectionBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/PBR/clearCoatBlock.js
var ClearCoatBlock = function(_super) {
  __extends(ClearCoatBlock2, _super);
  function ClearCoatBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Fragment) || this;
    _this.remapF0OnInterfaceChange = true;
    _this._isUnique = true;
    _this.registerInput("intensity", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("roughness", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("indexOfRefraction", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("normalMapColor", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.Vector2, true, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("tintColor", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("tintAtDistance", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("tintThickness", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("worldTangent", NodeMaterialBlockConnectionPointTypes.Vector4, true);
    _this.registerOutput("clearcoat", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("clearcoat", _this, NodeMaterialConnectionPointDirection.Output, ClearCoatBlock2, "ClearCoatBlock"));
    return _this;
  }
  ClearCoatBlock2.prototype.initialize = function(state) {
    state._excludeVariableName("clearcoatOut");
    state._excludeVariableName("vClearCoatParams");
    state._excludeVariableName("vClearCoatTintParams");
    state._excludeVariableName("vClearCoatRefractionParams");
    state._excludeVariableName("vClearCoatTangentSpaceParams");
  };
  ClearCoatBlock2.prototype.getClassName = function() {
    return "ClearCoatBlock";
  };
  Object.defineProperty(ClearCoatBlock2.prototype, "intensity", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ClearCoatBlock2.prototype, "roughness", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ClearCoatBlock2.prototype, "indexOfRefraction", {
    get: function() {
      return this._inputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ClearCoatBlock2.prototype, "normalMapColor", {
    get: function() {
      return this._inputs[3];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ClearCoatBlock2.prototype, "uv", {
    get: function() {
      return this._inputs[4];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ClearCoatBlock2.prototype, "tintColor", {
    get: function() {
      return this._inputs[5];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ClearCoatBlock2.prototype, "tintAtDistance", {
    get: function() {
      return this._inputs[6];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ClearCoatBlock2.prototype, "tintThickness", {
    get: function() {
      return this._inputs[7];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ClearCoatBlock2.prototype, "worldTangent", {
    get: function() {
      return this._inputs[8];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ClearCoatBlock2.prototype, "clearcoat", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  ClearCoatBlock2.prototype.autoConfigure = function(material) {
    if (!this.intensity.isConnected) {
      var intensityInput = new InputBlock("ClearCoat intensity", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);
      intensityInput.value = 1;
      intensityInput.output.connectTo(this.intensity);
    }
  };
  ClearCoatBlock2.prototype.prepareDefines = function(mesh, nodeMaterial, defines) {
    _super.prototype.prepareDefines.call(this, mesh, nodeMaterial, defines);
    defines.setValue("CLEARCOAT", true);
    defines.setValue("CLEARCOAT_TEXTURE", false, true);
    defines.setValue("CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE", true, true);
    defines.setValue("CLEARCOAT_TINT", this.tintColor.isConnected || this.tintThickness.isConnected || this.tintAtDistance.isConnected, true);
    defines.setValue("CLEARCOAT_BUMP", this.normalMapColor.isConnected, true);
    defines.setValue("CLEARCOAT_DEFAULTIOR", this.indexOfRefraction.isConnected ? this.indexOfRefraction.connectInputBlock.value === PBRClearCoatConfiguration._DefaultIndexOfRefraction : true, true);
    defines.setValue("CLEARCOAT_REMAP_F0", this.remapF0OnInterfaceChange, true);
  };
  ClearCoatBlock2.prototype.bind = function(effect, nodeMaterial, mesh, subMesh) {
    var _a, _b;
    _super.prototype.bind.call(this, effect, nodeMaterial, mesh);
    var indexOfRefraction = (_b = (_a = this.indexOfRefraction.connectInputBlock) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : PBRClearCoatConfiguration._DefaultIndexOfRefraction;
    var a = 1 - indexOfRefraction;
    var b = 1 + indexOfRefraction;
    var f0 = Math.pow(-a / b, 2);
    var eta = 1 / indexOfRefraction;
    effect.setFloat4("vClearCoatRefractionParams", f0, eta, a, b);
    var mainPBRBlock = this.clearcoat.hasEndpoints ? this.clearcoat.endpoints[0].ownerBlock : null;
    var perturbedNormalBlock = (mainPBRBlock === null || mainPBRBlock === void 0 ? void 0 : mainPBRBlock.perturbedNormal.isConnected) ? mainPBRBlock.perturbedNormal.connectedPoint.ownerBlock : null;
    if (this._scene._mirroredCameraPosition) {
      effect.setFloat2("vClearCoatTangentSpaceParams", (perturbedNormalBlock === null || perturbedNormalBlock === void 0 ? void 0 : perturbedNormalBlock.invertX) ? 1 : -1, (perturbedNormalBlock === null || perturbedNormalBlock === void 0 ? void 0 : perturbedNormalBlock.invertY) ? 1 : -1);
    } else {
      effect.setFloat2("vClearCoatTangentSpaceParams", (perturbedNormalBlock === null || perturbedNormalBlock === void 0 ? void 0 : perturbedNormalBlock.invertX) ? -1 : 1, (perturbedNormalBlock === null || perturbedNormalBlock === void 0 ? void 0 : perturbedNormalBlock.invertY) ? -1 : 1);
    }
  };
  ClearCoatBlock2.prototype._generateTBNSpace = function(state, worldPositionVarName, worldNormalVarName) {
    var code = "";
    var comments = "//" + this.name;
    var worldTangent = this.worldTangent;
    state._emitExtension("derivatives", "#extension GL_OES_standard_derivatives : enable");
    var tangentReplaceString = { search: /defined\(TANGENT\)/g, replace: worldTangent.isConnected ? "defined(TANGENT)" : "defined(IGNORE)" };
    if (worldTangent.isConnected) {
      code += "vec3 tbnNormal = normalize(" + worldNormalVarName + ".xyz);\r\n";
      code += "vec3 tbnTangent = normalize(" + worldTangent.associatedVariableName + ".xyz);\r\n";
      code += "vec3 tbnBitangent = cross(tbnNormal, tbnTangent);\r\n";
      code += "mat3 vTBN = mat3(tbnTangent, tbnBitangent, tbnNormal);\r\n";
    }
    state._emitFunctionFromInclude("bumpFragmentMainFunctions", comments, {
      replaceStrings: [
        tangentReplaceString
      ]
    });
    return code;
  };
  ClearCoatBlock2.GetCode = function(state, ccBlock, reflectionBlock, worldPosVarName, generateTBNSpace, vTBNAvailable, worldNormalVarName) {
    var code = "";
    var intensity = (ccBlock === null || ccBlock === void 0 ? void 0 : ccBlock.intensity.isConnected) ? ccBlock.intensity.associatedVariableName : "1.";
    var roughness = (ccBlock === null || ccBlock === void 0 ? void 0 : ccBlock.roughness.isConnected) ? ccBlock.roughness.associatedVariableName : "0.";
    var normalMapColor = (ccBlock === null || ccBlock === void 0 ? void 0 : ccBlock.normalMapColor.isConnected) ? ccBlock.normalMapColor.associatedVariableName : "vec3(0.)";
    var uv = (ccBlock === null || ccBlock === void 0 ? void 0 : ccBlock.uv.isConnected) ? ccBlock.uv.associatedVariableName : "vec2(0.)";
    var tintColor = (ccBlock === null || ccBlock === void 0 ? void 0 : ccBlock.tintColor.isConnected) ? ccBlock.tintColor.associatedVariableName : "vec3(1.)";
    var tintThickness = (ccBlock === null || ccBlock === void 0 ? void 0 : ccBlock.tintThickness.isConnected) ? ccBlock.tintThickness.associatedVariableName : "1.";
    var tintAtDistance = (ccBlock === null || ccBlock === void 0 ? void 0 : ccBlock.tintAtDistance.isConnected) ? ccBlock.tintAtDistance.associatedVariableName : "1.";
    var tintTexture = "vec4(0.)";
    if (ccBlock) {
      state._emitUniformFromString("vClearCoatRefractionParams", "vec4");
      state._emitUniformFromString("vClearCoatTangentSpaceParams", "vec2");
    }
    if (generateTBNSpace && ccBlock) {
      code += ccBlock._generateTBNSpace(state, worldPosVarName, worldNormalVarName);
      vTBNAvailable = ccBlock.worldTangent.isConnected;
    }
    code += "clearcoatOutParams clearcoatOut;\n\n        #ifdef CLEARCOAT\n            vec2 vClearCoatParams = vec2(" + intensity + ", " + roughness + ");\n            vec4 vClearCoatTintParams = vec4(" + tintColor + ", " + tintThickness + ");\n\n            clearcoatBlock(\n                " + worldPosVarName + ".xyz,\n                geometricNormalW,\n                viewDirectionW,\n                vClearCoatParams,\n                specularEnvironmentR0,\n            #ifdef CLEARCOAT_TEXTURE\n                vec2(0.),\n            #endif\n            #ifdef CLEARCOAT_TINT\n                vClearCoatTintParams,\n                " + tintAtDistance + ",\n                vClearCoatRefractionParams,\n                #ifdef CLEARCOAT_TINT_TEXTURE\n                    " + tintTexture + ",\n                #endif\n            #endif\n            #ifdef CLEARCOAT_BUMP\n                vec2(0., 1.),\n                vec4(" + normalMapColor + ", 0.),\n                " + uv + ",\n                #if defined(" + (vTBNAvailable ? "TANGENT" : "IGNORE") + ") && defined(NORMAL)\n                    vTBN,\n                #else\n                    vClearCoatTangentSpaceParams,\n                #endif\n                #ifdef OBJECTSPACE_NORMALMAP\n                    normalMatrix,\n                #endif\n            #endif\n            #if defined(FORCENORMALFORWARD) && defined(NORMAL)\n                faceNormal,\n            #endif\n            #ifdef REFLECTION\n                " + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._vReflectionMicrosurfaceInfosName) + ",\n                " + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._vReflectionInfosName) + ",\n                " + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock.reflectionColor) + ",\n                vLightingIntensity,\n                #ifdef " + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._define3DName) + "\n                    " + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._cubeSamplerName) + ",\n                #else\n                    " + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._2DSamplerName) + ",\n                #endif\n                #ifndef LODBASEDMICROSFURACE\n                    #ifdef " + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._define3DName) + "\n                        " + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._cubeSamplerName) + ",\n                        " + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._cubeSamplerName) + ",\n                    #else\n                        " + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._2DSamplerName) + ",\n                        " + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._2DSamplerName) + ",\n                    #endif\n                #endif\n            #endif\n            #if defined(ENVIRONMENTBRDF) && !defined(" + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineSkyboxName) + ")\n                #ifdef RADIANCEOCCLUSION\n                    ambientMonochrome,\n                #endif\n            #endif\n                clearcoatOut\n            );\n        #else\n            clearcoatOut.specularEnvironmentR0 = specularEnvironmentR0;\n        #endif\r\n";
    return code;
  };
  ClearCoatBlock2.prototype._buildBlock = function(state) {
    this._scene = state.sharedData.scene;
    if (state.target === NodeMaterialBlockTargets.Fragment) {
      state.sharedData.bindableBlocks.push(this);
      state.sharedData.blocksWithDefines.push(this);
    }
    return this;
  };
  ClearCoatBlock2.prototype._dumpPropertiesCode = function() {
    var codeString = "";
    codeString += this._codeVariableName + ".remapF0OnInterfaceChange = " + this.remapF0OnInterfaceChange + ";\r\n";
    return codeString;
  };
  ClearCoatBlock2.prototype.serialize = function() {
    var serializationObject = _super.prototype.serialize.call(this);
    serializationObject.remapF0OnInterfaceChange = this.remapF0OnInterfaceChange;
    return serializationObject;
  };
  ClearCoatBlock2.prototype._deserialize = function(serializationObject, scene, rootUrl) {
    var _a;
    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);
    this.remapF0OnInterfaceChange = (_a = serializationObject.remapF0OnInterfaceChange) !== null && _a !== void 0 ? _a : true;
  };
  __decorate([
    editableInPropertyPage("Remap F0 on interface change", PropertyTypeForEdition.Boolean, "ADVANCED")
  ], ClearCoatBlock2.prototype, "remapF0OnInterfaceChange", void 0);
  return ClearCoatBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.ClearCoatBlock"] = ClearCoatBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/PBR/refractionBlock.js
var RefractionBlock = function(_super) {
  __extends(RefractionBlock2, _super);
  function RefractionBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Fragment) || this;
    _this.linkRefractionWithTransparency = false;
    _this.invertRefractionY = false;
    _this._isUnique = true;
    _this.registerInput("intensity", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("tintAtDistance", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("refraction", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("refraction", _this, NodeMaterialConnectionPointDirection.Output, RefractionBlock2, "RefractionBlock"));
    return _this;
  }
  RefractionBlock2.prototype.getClassName = function() {
    return "RefractionBlock";
  };
  Object.defineProperty(RefractionBlock2.prototype, "intensity", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RefractionBlock2.prototype, "tintAtDistance", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RefractionBlock2.prototype, "view", {
    get: function() {
      return this.viewConnectionPoint;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RefractionBlock2.prototype, "refraction", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RefractionBlock2.prototype, "hasTexture", {
    get: function() {
      return !!this._getTexture();
    },
    enumerable: false,
    configurable: true
  });
  RefractionBlock2.prototype._getTexture = function() {
    if (this.texture) {
      return this.texture;
    }
    return this._scene.environmentTexture;
  };
  RefractionBlock2.prototype.autoConfigure = function(material) {
    if (!this.intensity.isConnected) {
      var intensityInput = new InputBlock("Refraction intensity", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);
      intensityInput.value = 1;
      intensityInput.output.connectTo(this.intensity);
    }
    if (this.view && !this.view.isConnected) {
      var viewInput = material.getInputBlockByPredicate(function(b) {
        return b.systemValue === NodeMaterialSystemValues.View;
      });
      if (!viewInput) {
        viewInput = new InputBlock("view");
        viewInput.setAsSystemValue(NodeMaterialSystemValues.View);
      }
      viewInput.output.connectTo(this.view);
    }
  };
  RefractionBlock2.prototype.prepareDefines = function(mesh, nodeMaterial, defines) {
    _super.prototype.prepareDefines.call(this, mesh, nodeMaterial, defines);
    var refractionTexture = this._getTexture();
    var refraction = refractionTexture && refractionTexture.getTextureMatrix;
    defines.setValue("SS_REFRACTION", refraction, true);
    if (!refraction) {
      return;
    }
    defines.setValue(this._define3DName, refractionTexture.isCube, true);
    defines.setValue(this._defineLODRefractionAlpha, refractionTexture.lodLevelInAlpha, true);
    defines.setValue(this._defineLinearSpecularRefraction, refractionTexture.linearSpecularLOD, true);
    defines.setValue(this._defineOppositeZ, this._scene.useRightHandedSystem ? !refractionTexture.invertZ : refractionTexture.invertZ, true);
    defines.setValue("SS_LINKREFRACTIONTOTRANSPARENCY", this.linkRefractionWithTransparency, true);
    defines.setValue("SS_GAMMAREFRACTION", refractionTexture.gammaSpace, true);
    defines.setValue("SS_RGBDREFRACTION", refractionTexture.isRGBD, true);
  };
  RefractionBlock2.prototype.isReady = function() {
    var texture = this._getTexture();
    if (texture && !texture.isReadyOrNotBlocking()) {
      return false;
    }
    return true;
  };
  RefractionBlock2.prototype.bind = function(effect, nodeMaterial, mesh, subMesh) {
    var _a, _b;
    _super.prototype.bind.call(this, effect, nodeMaterial, mesh);
    var refractionTexture = this._getTexture();
    if (!refractionTexture) {
      return;
    }
    if (refractionTexture.isCube) {
      effect.setTexture(this._cubeSamplerName, refractionTexture);
    } else {
      effect.setTexture(this._2DSamplerName, refractionTexture);
    }
    effect.setMatrix(this._refractionMatrixName, refractionTexture.getReflectionTextureMatrix());
    var depth = 1;
    if (!refractionTexture.isCube) {
      if (refractionTexture.depth) {
        depth = refractionTexture.depth;
      }
    }
    var indexOfRefraction = (_b = (_a = this.indexOfRefractionConnectionPoint.connectInputBlock) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : 1.5;
    effect.setFloat4(this._vRefractionInfosName, refractionTexture.level, 1 / indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);
    effect.setFloat3(this._vRefractionMicrosurfaceInfosName, refractionTexture.getSize().width, refractionTexture.lodGenerationScale, refractionTexture.lodGenerationOffset);
    var width = refractionTexture.getSize().width;
    effect.setFloat2(this._vRefractionFilteringInfoName, width, Scalar.Log2(width));
  };
  RefractionBlock2.prototype.getCode = function(state) {
    var code = "";
    state.sharedData.blockingBlocks.push(this);
    state.sharedData.textureBlocks.push(this);
    this._cubeSamplerName = state._getFreeVariableName(this.name + "CubeSampler");
    state.samplers.push(this._cubeSamplerName);
    this._2DSamplerName = state._getFreeVariableName(this.name + "2DSampler");
    state.samplers.push(this._2DSamplerName);
    this._define3DName = state._getFreeDefineName("SS_REFRACTIONMAP_3D");
    state._samplerDeclaration += "#ifdef " + this._define3DName + "\r\n";
    state._samplerDeclaration += "uniform samplerCube " + this._cubeSamplerName + ";\r\n";
    state._samplerDeclaration += "#else\r\n";
    state._samplerDeclaration += "uniform sampler2D " + this._2DSamplerName + ";\r\n";
    state._samplerDeclaration += "#endif\r\n";
    state.sharedData.blocksWithDefines.push(this);
    state.sharedData.bindableBlocks.push(this);
    this._defineLODRefractionAlpha = state._getFreeDefineName("SS_LODINREFRACTIONALPHA");
    this._defineLinearSpecularRefraction = state._getFreeDefineName("SS_LINEARSPECULARREFRACTION");
    this._defineOppositeZ = state._getFreeDefineName("SS_REFRACTIONMAP_OPPOSITEZ");
    this._refractionMatrixName = state._getFreeVariableName("refractionMatrix");
    state._emitUniformFromString(this._refractionMatrixName, "mat4");
    state._emitFunction("sampleRefraction", "\n            #ifdef " + this._define3DName + "\n                #define sampleRefraction(s, c) textureCube(s, c)\n            #else\n                #define sampleRefraction(s, c) texture2D(s, c)\n            #endif\r\n", "//" + this.name);
    state._emitFunction("sampleRefractionLod", "\n            #ifdef " + this._define3DName + "\n                #define sampleRefractionLod(s, c, l) textureCubeLodEXT(s, c, l)\n            #else\n                #define sampleRefractionLod(s, c, l) texture2DLodEXT(s, c, l)\n            #endif\r\n", "//" + this.name);
    this._vRefractionMicrosurfaceInfosName = state._getFreeVariableName("vRefractionMicrosurfaceInfos");
    state._emitUniformFromString(this._vRefractionMicrosurfaceInfosName, "vec3");
    this._vRefractionInfosName = state._getFreeVariableName("vRefractionInfos");
    state._emitUniformFromString(this._vRefractionInfosName, "vec4");
    this._vRefractionFilteringInfoName = state._getFreeVariableName("vRefractionFilteringInfo");
    state._emitUniformFromString(this._vRefractionFilteringInfoName, "vec2");
    return code;
  };
  RefractionBlock2.prototype._buildBlock = function(state) {
    this._scene = state.sharedData.scene;
    return this;
  };
  RefractionBlock2.prototype._dumpPropertiesCode = function() {
    var codeString = _super.prototype._dumpPropertiesCode.call(this);
    if (this.texture) {
      if (this.texture.isCube) {
        codeString = this._codeVariableName + '.texture = new BABYLON.CubeTexture("' + this.texture.name + '");\r\n';
      } else {
        codeString = this._codeVariableName + '.texture = new BABYLON.Texture("' + this.texture.name + '");\r\n';
      }
      codeString += this._codeVariableName + ".texture.coordinatesMode = " + this.texture.coordinatesMode + ";\r\n";
    }
    codeString += this._codeVariableName + ".linkRefractionWithTransparency = " + this.linkRefractionWithTransparency + ";\r\n";
    codeString += this._codeVariableName + ".invertRefractionY = " + this.invertRefractionY + ";\r\n";
    return codeString;
  };
  RefractionBlock2.prototype.serialize = function() {
    var serializationObject = _super.prototype.serialize.call(this);
    if (this.texture) {
      serializationObject.texture = this.texture.serialize();
    }
    serializationObject.linkRefractionWithTransparency = this.linkRefractionWithTransparency;
    serializationObject.invertRefractionY = this.invertRefractionY;
    return serializationObject;
  };
  RefractionBlock2.prototype._deserialize = function(serializationObject, scene, rootUrl) {
    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);
    if (serializationObject.texture) {
      rootUrl = serializationObject.texture.url.indexOf("data:") === 0 ? "" : rootUrl;
      if (serializationObject.texture.isCube) {
        this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);
      } else {
        this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);
      }
    }
    this.linkRefractionWithTransparency = serializationObject.linkRefractionWithTransparency;
    this.invertRefractionY = serializationObject.invertRefractionY;
  };
  __decorate([
    editableInPropertyPage("Link refraction to transparency", PropertyTypeForEdition.Boolean, "ADVANCED", { "notifiers": { "update": true } })
  ], RefractionBlock2.prototype, "linkRefractionWithTransparency", void 0);
  __decorate([
    editableInPropertyPage("Invert refraction Y", PropertyTypeForEdition.Boolean, "ADVANCED", { "notifiers": { "update": true } })
  ], RefractionBlock2.prototype, "invertRefractionY", void 0);
  return RefractionBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.RefractionBlock"] = RefractionBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/PBR/subSurfaceBlock.js
var SubSurfaceBlock = function(_super) {
  __extends(SubSurfaceBlock2, _super);
  function SubSurfaceBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Fragment) || this;
    _this._isUnique = true;
    _this.registerInput("thickness", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("tintColor", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("translucencyIntensity", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("translucencyDiffusionDist", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("refraction", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("refraction", _this, NodeMaterialConnectionPointDirection.Input, RefractionBlock, "RefractionBlock"));
    _this.registerOutput("subsurface", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("subsurface", _this, NodeMaterialConnectionPointDirection.Output, SubSurfaceBlock2, "SubSurfaceBlock"));
    return _this;
  }
  SubSurfaceBlock2.prototype.initialize = function(state) {
    state._excludeVariableName("subSurfaceOut");
    state._excludeVariableName("vThicknessParam");
    state._excludeVariableName("vTintColor");
    state._excludeVariableName("vSubSurfaceIntensity");
  };
  SubSurfaceBlock2.prototype.getClassName = function() {
    return "SubSurfaceBlock";
  };
  Object.defineProperty(SubSurfaceBlock2.prototype, "thickness", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SubSurfaceBlock2.prototype, "tintColor", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SubSurfaceBlock2.prototype, "translucencyIntensity", {
    get: function() {
      return this._inputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SubSurfaceBlock2.prototype, "translucencyDiffusionDist", {
    get: function() {
      return this._inputs[3];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SubSurfaceBlock2.prototype, "refraction", {
    get: function() {
      return this._inputs[4];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SubSurfaceBlock2.prototype, "subsurface", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  SubSurfaceBlock2.prototype.autoConfigure = function(material) {
    if (!this.thickness.isConnected) {
      var thicknessInput = new InputBlock("SubSurface thickness", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);
      thicknessInput.value = 0;
      thicknessInput.output.connectTo(this.thickness);
    }
  };
  SubSurfaceBlock2.prototype.prepareDefines = function(mesh, nodeMaterial, defines) {
    _super.prototype.prepareDefines.call(this, mesh, nodeMaterial, defines);
    var translucencyEnabled = this.translucencyDiffusionDist.isConnected || this.translucencyIntensity.isConnected;
    defines.setValue("SUBSURFACE", translucencyEnabled || this.refraction.isConnected, true);
    defines.setValue("SS_TRANSLUCENCY", translucencyEnabled, true);
    defines.setValue("SS_THICKNESSANDMASK_TEXTURE", false, true);
    defines.setValue("SS_MASK_FROM_THICKNESS_TEXTURE", false, true);
    defines.setValue("SS_MASK_FROM_THICKNESS_TEXTURE_GLTF", false, true);
  };
  SubSurfaceBlock2.GetCode = function(state, ssBlock, reflectionBlock, worldPosVarName) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
    var code = "";
    var thickness = (ssBlock === null || ssBlock === void 0 ? void 0 : ssBlock.thickness.isConnected) ? ssBlock.thickness.associatedVariableName : "0.";
    var tintColor = (ssBlock === null || ssBlock === void 0 ? void 0 : ssBlock.tintColor.isConnected) ? ssBlock.tintColor.associatedVariableName : "vec3(1.)";
    var translucencyIntensity = (ssBlock === null || ssBlock === void 0 ? void 0 : ssBlock.translucencyIntensity.isConnected) ? ssBlock === null || ssBlock === void 0 ? void 0 : ssBlock.translucencyIntensity.associatedVariableName : "1.";
    var translucencyDiffusionDistance = (ssBlock === null || ssBlock === void 0 ? void 0 : ssBlock.translucencyDiffusionDist.isConnected) ? ssBlock === null || ssBlock === void 0 ? void 0 : ssBlock.translucencyDiffusionDist.associatedVariableName : "vec3(1.)";
    var refractionBlock = (ssBlock === null || ssBlock === void 0 ? void 0 : ssBlock.refraction.isConnected) ? (_a = ssBlock === null || ssBlock === void 0 ? void 0 : ssBlock.refraction.connectedPoint) === null || _a === void 0 ? void 0 : _a.ownerBlock : null;
    var refractionTintAtDistance = (refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock.tintAtDistance.isConnected) ? refractionBlock.tintAtDistance.associatedVariableName : "1.";
    var refractionIntensity = (refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock.intensity.isConnected) ? refractionBlock.intensity.associatedVariableName : "1.";
    var refractionView = (refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock.view.isConnected) ? refractionBlock.view.associatedVariableName : "";
    code += (_b = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock.getCode(state)) !== null && _b !== void 0 ? _b : "";
    code += "subSurfaceOutParams subSurfaceOut;\n\n        #ifdef SUBSURFACE\n            vec2 vThicknessParam = vec2(0., " + thickness + ");\n            vec4 vTintColor = vec4(" + tintColor + ", " + refractionTintAtDistance + ");\n            vec3 vSubSurfaceIntensity = vec3(" + refractionIntensity + ", " + translucencyIntensity + ", 0.);\n\n            subSurfaceBlock(\n                vSubSurfaceIntensity,\n                vThicknessParam,\n                vTintColor,\n                normalW,\n                specularEnvironmentReflectance,\n            #ifdef SS_THICKNESSANDMASK_TEXTURE\n                vec4(0.),\n            #endif\n            #ifdef REFLECTION\n                #ifdef SS_TRANSLUCENCY\n                    " + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._reflectionMatrixName) + ",\n                    #ifdef USESPHERICALFROMREFLECTIONMAP\n                        #if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\n                            reflectionOut.irradianceVector,\n                        #endif\n                        #if defined(REALTIME_FILTERING)\n                            " + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._cubeSamplerName) + ",\n                            " + (reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._vReflectionFilteringInfoName) + ",\n                        #endif\n                        #endif\n                    #ifdef USEIRRADIANCEMAP\n                        irradianceSampler,\n                    #endif\n                #endif\n            #endif\n            #ifdef SS_REFRACTION\n                " + worldPosVarName + ".xyz,\n                viewDirectionW,\n                " + refractionView + ",\n                surfaceAlbedo,\n                " + ((_c = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._vRefractionInfosName) !== null && _c !== void 0 ? _c : "") + ",\n                " + ((_d = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._refractionMatrixName) !== null && _d !== void 0 ? _d : "") + ",\n                " + ((_e = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._vRefractionMicrosurfaceInfosName) !== null && _e !== void 0 ? _e : "") + ",\n                vLightingIntensity,\n                #ifdef SS_LINKREFRACTIONTOTRANSPARENCY\n                    alpha,\n                #endif\n                #ifdef " + ((_f = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._defineLODRefractionAlpha) !== null && _f !== void 0 ? _f : "IGNORE") + "\n                    NdotVUnclamped,\n                #endif\n                #ifdef " + ((_g = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._defineLinearSpecularRefraction) !== null && _g !== void 0 ? _g : "IGNORE") + "\n                    roughness,\n                #else\n                    alphaG,\n                #endif\n                #ifdef " + ((_h = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._define3DName) !== null && _h !== void 0 ? _h : "IGNORE") + "\n                    " + ((_j = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._cubeSamplerName) !== null && _j !== void 0 ? _j : "") + ",\n                #else\n                    " + ((_k = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._2DSamplerName) !== null && _k !== void 0 ? _k : "") + ",\n                #endif\n                #ifndef LODBASEDMICROSFURACE\n                    #ifdef " + ((_l = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._define3DName) !== null && _l !== void 0 ? _l : "IGNORE") + "\n                        " + ((_m = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._cubeSamplerName) !== null && _m !== void 0 ? _m : "") + ",\n                        " + ((_o = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._cubeSamplerName) !== null && _o !== void 0 ? _o : "") + ",\n                    #else\n                        " + ((_p = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._2DSamplerName) !== null && _p !== void 0 ? _p : "") + ",\n                        " + ((_q = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._2DSamplerName) !== null && _q !== void 0 ? _q : "") + ",\n                    #endif\n                #endif\n                #ifdef ANISOTROPIC\n                    anisotropicOut,\n                #endif\n                #ifdef REALTIME_FILTERING\n                    " + ((_r = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._vRefractionFilteringInfoName) !== null && _r !== void 0 ? _r : "") + ",\n                #endif\n            #endif\n            #ifdef SS_TRANSLUCENCY\n                " + translucencyDiffusionDistance + ",\n            #endif\n                subSurfaceOut\n            );\n\n            #ifdef SS_REFRACTION\n                surfaceAlbedo = subSurfaceOut.surfaceAlbedo;\n                #ifdef SS_LINKREFRACTIONTOTRANSPARENCY\n                    alpha = subSurfaceOut.alpha;\n                #endif\n            #endif\n        #else\n            subSurfaceOut.specularEnvironmentReflectance = specularEnvironmentReflectance;\n        #endif\r\n";
    return code;
  };
  SubSurfaceBlock2.prototype._buildBlock = function(state) {
    if (state.target === NodeMaterialBlockTargets.Fragment) {
      state.sharedData.blocksWithDefines.push(this);
    }
    return this;
  };
  return SubSurfaceBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.SubSurfaceBlock"] = SubSurfaceBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/PBR/pbrMetallicRoughnessBlock.js
var mapOutputToVariable = {
  "ambientClr": ["finalAmbient", ""],
  "diffuseDir": ["finalDiffuse", ""],
  "specularDir": ["finalSpecularScaled", "!defined(UNLIT) && defined(SPECULARTERM)"],
  "clearcoatDir": ["finalClearCoatScaled", "!defined(UNLIT) && defined(CLEARCOAT)"],
  "sheenDir": ["finalSheenScaled", "!defined(UNLIT) && defined(SHEEN)"],
  "diffuseInd": ["finalIrradiance", "!defined(UNLIT) && defined(REFLECTION)"],
  "specularInd": ["finalRadianceScaled", "!defined(UNLIT) && defined(REFLECTION)"],
  "clearcoatInd": ["clearcoatOut.finalClearCoatRadianceScaled", "!defined(UNLIT) && defined(REFLECTION) && defined(CLEARCOAT)"],
  "sheenInd": ["sheenOut.finalSheenRadianceScaled", "!defined(UNLIT) && defined(REFLECTION) && defined(SHEEN) && defined(ENVIRONMENTBRDF)"],
  "refraction": ["subSurfaceOut.finalRefraction", "!defined(UNLIT) && defined(SS_REFRACTION)"],
  "lighting": ["finalColor.rgb", ""],
  "shadow": ["shadow", ""],
  "alpha": ["alpha", ""]
};
var PBRMetallicRoughnessBlock = function(_super) {
  __extends(PBRMetallicRoughnessBlock2, _super);
  function PBRMetallicRoughnessBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.VertexAndFragment) || this;
    _this._environmentBRDFTexture = null;
    _this._metallicReflectanceColor = Color3.White();
    _this._metallicF0Factor = 1;
    _this.directIntensity = 1;
    _this.environmentIntensity = 1;
    _this.specularIntensity = 1;
    _this.lightFalloff = 0;
    _this.useAlphaTest = false;
    _this.alphaTestCutoff = 0.5;
    _this.useAlphaBlending = false;
    _this.useRadianceOverAlpha = true;
    _this.useSpecularOverAlpha = true;
    _this.enableSpecularAntiAliasing = false;
    _this.realTimeFiltering = false;
    _this.realTimeFilteringQuality = 8;
    _this.useEnergyConservation = true;
    _this.useRadianceOcclusion = true;
    _this.useHorizonOcclusion = true;
    _this.unlit = false;
    _this.forceNormalForward = false;
    _this.debugMode = 0;
    _this.debugLimit = 0;
    _this.debugFactor = 1;
    _this._isUnique = true;
    _this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);
    _this.registerInput("worldNormal", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("view", NodeMaterialBlockConnectionPointTypes.Matrix, false);
    _this.registerInput("cameraPosition", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("perturbedNormal", NodeMaterialBlockConnectionPointTypes.Vector4, true, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("baseColor", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("metallic", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("roughness", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("ambientOcc", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("opacity", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("indexOfRefraction", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("ambientColor", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    _this.registerInput("reflection", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("reflection", _this, NodeMaterialConnectionPointDirection.Input, ReflectionBlock, "ReflectionBlock"));
    _this.registerInput("clearcoat", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("clearcoat", _this, NodeMaterialConnectionPointDirection.Input, ClearCoatBlock, "ClearCoatBlock"));
    _this.registerInput("sheen", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("sheen", _this, NodeMaterialConnectionPointDirection.Input, SheenBlock, "SheenBlock"));
    _this.registerInput("subsurface", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("subsurface", _this, NodeMaterialConnectionPointDirection.Input, SubSurfaceBlock, "SubSurfaceBlock"));
    _this.registerInput("anisotropy", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("anisotropy", _this, NodeMaterialConnectionPointDirection.Input, AnisotropyBlock, "AnisotropyBlock"));
    _this.registerOutput("ambientClr", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("diffuseDir", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("specularDir", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("clearcoatDir", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("sheenDir", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("diffuseInd", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("specularInd", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("clearcoatInd", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("sheenInd", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("refraction", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("lighting", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("shadow", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    _this.registerOutput("alpha", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    return _this;
  }
  PBRMetallicRoughnessBlock2.prototype.initialize = function(state) {
    state._excludeVariableName("vLightingIntensity");
    state._excludeVariableName("geometricNormalW");
    state._excludeVariableName("normalW");
    state._excludeVariableName("faceNormal");
    state._excludeVariableName("albedoOpacityOut");
    state._excludeVariableName("surfaceAlbedo");
    state._excludeVariableName("alpha");
    state._excludeVariableName("aoOut");
    state._excludeVariableName("baseColor");
    state._excludeVariableName("reflectivityOut");
    state._excludeVariableName("microSurface");
    state._excludeVariableName("roughness");
    state._excludeVariableName("NdotVUnclamped");
    state._excludeVariableName("NdotV");
    state._excludeVariableName("alphaG");
    state._excludeVariableName("AARoughnessFactors");
    state._excludeVariableName("environmentBrdf");
    state._excludeVariableName("ambientMonochrome");
    state._excludeVariableName("seo");
    state._excludeVariableName("eho");
    state._excludeVariableName("environmentRadiance");
    state._excludeVariableName("irradianceVector");
    state._excludeVariableName("environmentIrradiance");
    state._excludeVariableName("diffuseBase");
    state._excludeVariableName("specularBase");
    state._excludeVariableName("preInfo");
    state._excludeVariableName("info");
    state._excludeVariableName("shadow");
    state._excludeVariableName("finalDiffuse");
    state._excludeVariableName("finalAmbient");
    state._excludeVariableName("ambientOcclusionForDirectDiffuse");
    state._excludeVariableName("finalColor");
    state._excludeVariableName("vClipSpacePosition");
    state._excludeVariableName("vDebugMode");
  };
  PBRMetallicRoughnessBlock2.prototype.getClassName = function() {
    return "PBRMetallicRoughnessBlock";
  };
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "worldPosition", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "worldNormal", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "view", {
    get: function() {
      return this._inputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "cameraPosition", {
    get: function() {
      return this._inputs[3];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "perturbedNormal", {
    get: function() {
      return this._inputs[4];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "baseColor", {
    get: function() {
      return this._inputs[5];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "metallic", {
    get: function() {
      return this._inputs[6];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "roughness", {
    get: function() {
      return this._inputs[7];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "ambientOcc", {
    get: function() {
      return this._inputs[8];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "opacity", {
    get: function() {
      return this._inputs[9];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "indexOfRefraction", {
    get: function() {
      return this._inputs[10];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "ambientColor", {
    get: function() {
      return this._inputs[11];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "reflection", {
    get: function() {
      return this._inputs[12];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "clearcoat", {
    get: function() {
      return this._inputs[13];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "sheen", {
    get: function() {
      return this._inputs[14];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "subsurface", {
    get: function() {
      return this._inputs[15];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "anisotropy", {
    get: function() {
      return this._inputs[16];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "ambientClr", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "diffuseDir", {
    get: function() {
      return this._outputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "specularDir", {
    get: function() {
      return this._outputs[2];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "clearcoatDir", {
    get: function() {
      return this._outputs[3];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "sheenDir", {
    get: function() {
      return this._outputs[4];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "diffuseIndirect", {
    get: function() {
      return this._outputs[5];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "specularIndirect", {
    get: function() {
      return this._outputs[6];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "clearcoatIndirect", {
    get: function() {
      return this._outputs[7];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "sheenIndirect", {
    get: function() {
      return this._outputs[8];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "refraction", {
    get: function() {
      return this._outputs[9];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "lighting", {
    get: function() {
      return this._outputs[10];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "shadow", {
    get: function() {
      return this._outputs[11];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMetallicRoughnessBlock2.prototype, "alpha", {
    get: function() {
      return this._outputs[12];
    },
    enumerable: false,
    configurable: true
  });
  PBRMetallicRoughnessBlock2.prototype.autoConfigure = function(material) {
    if (!this.cameraPosition.isConnected) {
      var cameraPositionInput = material.getInputBlockByPredicate(function(b) {
        return b.systemValue === NodeMaterialSystemValues.CameraPosition;
      });
      if (!cameraPositionInput) {
        cameraPositionInput = new InputBlock("cameraPosition");
        cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);
      }
      cameraPositionInput.output.connectTo(this.cameraPosition);
    }
    if (!this.view.isConnected) {
      var viewInput = material.getInputBlockByPredicate(function(b) {
        return b.systemValue === NodeMaterialSystemValues.View;
      });
      if (!viewInput) {
        viewInput = new InputBlock("view");
        viewInput.setAsSystemValue(NodeMaterialSystemValues.View);
      }
      viewInput.output.connectTo(this.view);
    }
  };
  PBRMetallicRoughnessBlock2.prototype.prepareDefines = function(mesh, nodeMaterial, defines) {
    defines.setValue("PBR", true);
    defines.setValue("METALLICWORKFLOW", true);
    defines.setValue("DEBUGMODE", this.debugMode, true);
    defines.setValue("NORMALXYSCALE", true);
    defines.setValue("BUMP", this.perturbedNormal.isConnected, true);
    defines.setValue("LODBASEDMICROSFURACE", this._scene.getEngine().getCaps().textureLOD);
    defines.setValue("ALBEDO", false, true);
    defines.setValue("OPACITY", this.opacity.isConnected, true);
    defines.setValue("AMBIENT", true, true);
    defines.setValue("AMBIENTINGRAYSCALE", false, true);
    defines.setValue("REFLECTIVITY", false, true);
    defines.setValue("AOSTOREINMETALMAPRED", false, true);
    defines.setValue("METALLNESSSTOREINMETALMAPBLUE", false, true);
    defines.setValue("ROUGHNESSSTOREINMETALMAPALPHA", false, true);
    defines.setValue("ROUGHNESSSTOREINMETALMAPGREEN", false, true);
    if (this.lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_STANDARD) {
      defines.setValue("USEPHYSICALLIGHTFALLOFF", false);
      defines.setValue("USEGLTFLIGHTFALLOFF", false);
    } else if (this.lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_GLTF) {
      defines.setValue("USEPHYSICALLIGHTFALLOFF", false);
      defines.setValue("USEGLTFLIGHTFALLOFF", true);
    } else {
      defines.setValue("USEPHYSICALLIGHTFALLOFF", true);
      defines.setValue("USEGLTFLIGHTFALLOFF", false);
    }
    var alphaTestCutOffString = this.alphaTestCutoff.toString();
    defines.setValue("ALPHABLEND", this.useAlphaBlending, true);
    defines.setValue("ALPHAFROMALBEDO", false, true);
    defines.setValue("ALPHATEST", this.useAlphaTest, true);
    defines.setValue("ALPHATESTVALUE", alphaTestCutOffString.indexOf(".") < 0 ? alphaTestCutOffString + "." : alphaTestCutOffString, true);
    defines.setValue("OPACITYRGB", false, true);
    defines.setValue("RADIANCEOVERALPHA", this.useRadianceOverAlpha, true);
    defines.setValue("SPECULAROVERALPHA", this.useSpecularOverAlpha, true);
    defines.setValue("SPECULARAA", this._scene.getEngine().getCaps().standardDerivatives && this.enableSpecularAntiAliasing, true);
    defines.setValue("REALTIME_FILTERING", this.realTimeFiltering, true);
    if (this._scene.getEngine().webGLVersion > 1) {
      defines.setValue("NUM_SAMPLES", this.realTimeFilteringQuality + "u", true);
    } else {
      defines.setValue("NUM_SAMPLES", "" + this.realTimeFilteringQuality, true);
    }
    defines.setValue("BRDF_V_HEIGHT_CORRELATED", true);
    defines.setValue("MS_BRDF_ENERGY_CONSERVATION", this.useEnergyConservation, true);
    defines.setValue("RADIANCEOCCLUSION", this.useRadianceOcclusion, true);
    defines.setValue("HORIZONOCCLUSION", this.useHorizonOcclusion, true);
    defines.setValue("UNLIT", this.unlit, true);
    defines.setValue("FORCENORMALFORWARD", this.forceNormalForward, true);
    if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {
      defines.setValue("ENVIRONMENTBRDF", true);
      defines.setValue("ENVIRONMENTBRDF_RGBD", this._environmentBRDFTexture.isRGBD, true);
    } else {
      defines.setValue("ENVIRONMENTBRDF", false);
      defines.setValue("ENVIRONMENTBRDF_RGBD", false);
    }
    if (!defines._areLightsDirty) {
      return;
    }
    var scene = mesh.getScene();
    if (!this.light) {
      MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, nodeMaterial.maxSimultaneousLights);
      defines._needNormals = true;
      MaterialHelper.PrepareDefinesForMultiview(scene, defines);
    } else {
      var state = {
        needNormals: false,
        needRebuild: false,
        lightmapMode: false,
        shadowEnabled: false,
        specularEnabled: false
      };
      MaterialHelper.PrepareDefinesForLight(scene, mesh, this.light, this._lightId, defines, true, state);
      if (state.needRebuild) {
        defines.rebuild();
      }
    }
  };
  PBRMetallicRoughnessBlock2.prototype.updateUniformsAndSamples = function(state, nodeMaterial, defines, uniformBuffers) {
    for (var lightIndex = 0; lightIndex < nodeMaterial.maxSimultaneousLights; lightIndex++) {
      if (!defines["LIGHT" + lightIndex]) {
        break;
      }
      var onlyUpdateBuffersList = state.uniforms.indexOf("vLightData" + lightIndex) >= 0;
      MaterialHelper.PrepareUniformsAndSamplersForLight(lightIndex, state.uniforms, state.samplers, defines["PROJECTEDLIGHTTEXTURE" + lightIndex], uniformBuffers, onlyUpdateBuffersList);
    }
  };
  PBRMetallicRoughnessBlock2.prototype.bind = function(effect, nodeMaterial, mesh) {
    var _a, _b;
    if (!mesh) {
      return;
    }
    var scene = mesh.getScene();
    if (!this.light) {
      MaterialHelper.BindLights(scene, mesh, effect, true, nodeMaterial.maxSimultaneousLights);
    } else {
      MaterialHelper.BindLight(this.light, this._lightId, scene, effect, true);
    }
    effect.setTexture(this._environmentBrdfSamplerName, this._environmentBRDFTexture);
    effect.setFloat2("vDebugMode", this.debugLimit, this.debugFactor);
    var ambientScene = this._scene.ambientColor;
    if (ambientScene) {
      effect.setColor3("ambientFromScene", ambientScene);
    }
    var invertNormal = scene.useRightHandedSystem === (scene._mirroredCameraPosition != null);
    effect.setFloat(this._invertNormalName, invertNormal ? -1 : 1);
    effect.setFloat4("vLightingIntensity", this.directIntensity, 1, this.environmentIntensity * this._scene.environmentIntensity, this.specularIntensity);
    var outside_ior = 1;
    var ior = (_b = (_a = this.indexOfRefraction.connectInputBlock) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : 1.5;
    var f0 = Math.pow((ior - outside_ior) / (ior + outside_ior), 2);
    this._metallicReflectanceColor.scaleToRef(f0 * this._metallicF0Factor, TmpColors.Color3[0]);
    var metallicF90 = this._metallicF0Factor;
    effect.setColor4(this._vMetallicReflectanceFactorsName, TmpColors.Color3[0], metallicF90);
  };
  PBRMetallicRoughnessBlock2.prototype._injectVertexCode = function(state) {
    var _a, _b;
    var worldPos = this.worldPosition;
    var comments = "//" + this.name;
    if (!this.light) {
      state._emitFunctionFromInclude(state.supportUniformBuffers ? "lightUboDeclaration" : "lightFragmentDeclaration", comments, {
        repeatKey: "maxSimultaneousLights"
      });
      this._lightId = 0;
      state.sharedData.dynamicUniformBlocks.push(this);
    } else {
      this._lightId = (state.counters["lightCounter"] !== void 0 ? state.counters["lightCounter"] : -1) + 1;
      state.counters["lightCounter"] = this._lightId;
      state._emitFunctionFromInclude(state.supportUniformBuffers ? "lightUboDeclaration" : "lightFragmentDeclaration", comments, {
        replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }]
      }, this._lightId.toString());
    }
    var worldPosVaryingName = "v_" + worldPos.associatedVariableName;
    if (state._emitVaryingFromString(worldPosVaryingName, "vec4")) {
      state.compilationString += worldPosVaryingName + " = " + worldPos.associatedVariableName + ";\r\n";
    }
    var reflectionBlock = this.reflection.isConnected ? (_a = this.reflection.connectedPoint) === null || _a === void 0 ? void 0 : _a.ownerBlock : null;
    if (reflectionBlock) {
      reflectionBlock.viewConnectionPoint = this.view;
    }
    state.compilationString += (_b = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock.handleVertexSide(state)) !== null && _b !== void 0 ? _b : "";
    state._emitUniformFromString("vDebugMode", "vec2", "defined(IGNORE) || DEBUGMODE > 0");
    state._emitUniformFromString("ambientFromScene", "vec3");
    if (state._emitVaryingFromString("vClipSpacePosition", "vec4", "defined(IGNORE) || DEBUGMODE > 0")) {
      state._injectAtEnd += "#if DEBUGMODE > 0\r\n";
      state._injectAtEnd += "vClipSpacePosition = gl_Position;\r\n";
      state._injectAtEnd += "#endif\r\n";
    }
    if (this.light) {
      state.compilationString += state._emitCodeFromInclude("shadowsVertex", comments, {
        replaceStrings: [
          { search: /{X}/g, replace: this._lightId.toString() },
          { search: /worldPos/g, replace: worldPos.associatedVariableName }
        ]
      });
    } else {
      state.compilationString += "vec4 worldPos = " + worldPos.associatedVariableName + ";\r\n";
      if (this.view.isConnected) {
        state.compilationString += "mat4 view = " + this.view.associatedVariableName + ";\r\n";
      }
      state.compilationString += state._emitCodeFromInclude("shadowsVertex", comments, {
        repeatKey: "maxSimultaneousLights"
      });
    }
  };
  PBRMetallicRoughnessBlock2.prototype._getAlbedoOpacityCode = function() {
    var code = "albedoOpacityOutParams albedoOpacityOut;\r\n";
    var albedoColor = this.baseColor.isConnected ? this.baseColor.associatedVariableName : "vec3(1.)";
    var opacity = this.opacity.isConnected ? this.opacity.associatedVariableName : "1.";
    code += "albedoOpacityBlock(\n                vec4(" + albedoColor + ", 1.),\n            #ifdef ALBEDO\n                vec4(1.),\n                vec2(1., 1.),\n            #endif\n            #ifdef OPACITY\n                vec4(" + opacity + "),\n                vec2(1., 1.),\n            #endif\n                albedoOpacityOut\n            );\n\n            vec3 surfaceAlbedo = albedoOpacityOut.surfaceAlbedo;\n            float alpha = albedoOpacityOut.alpha;\r\n";
    return code;
  };
  PBRMetallicRoughnessBlock2.prototype._getAmbientOcclusionCode = function() {
    var code = "ambientOcclusionOutParams aoOut;\r\n";
    var ao = this.ambientOcc.isConnected ? this.ambientOcc.associatedVariableName : "1.";
    code += "ambientOcclusionBlock(\n            #ifdef AMBIENT\n                vec3(" + ao + "),\n                vec4(0., 1.0, 1.0, 0.),\n            #endif\n                aoOut\n            );\r\n";
    return code;
  };
  PBRMetallicRoughnessBlock2.prototype._getReflectivityCode = function(state) {
    var code = "reflectivityOutParams reflectivityOut;\r\n";
    var aoIntensity = "1.";
    this._vMetallicReflectanceFactorsName = state._getFreeVariableName("vMetallicReflectanceFactors");
    state._emitUniformFromString(this._vMetallicReflectanceFactorsName, "vec4");
    code += "vec3 baseColor = surfaceAlbedo;\n\n            reflectivityBlock(\n                vec4(" + this.metallic.associatedVariableName + ", " + this.roughness.associatedVariableName + ", 0., 0.),\n            #ifdef METALLICWORKFLOW\n                surfaceAlbedo,\n                " + this._vMetallicReflectanceFactorsName + ",\n            #endif\n            #ifdef REFLECTIVITY\n                vec3(0., 0., " + aoIntensity + "),\n                vec4(1.),\n            #endif\n            #if defined(METALLICWORKFLOW) && defined(REFLECTIVITY)  && defined(AOSTOREINMETALMAPRED)\n                aoOut.ambientOcclusionColor,\n            #endif\n            #ifdef MICROSURFACEMAP\n                microSurfaceTexel, <== not handled!\n            #endif\n                reflectivityOut\n            );\n\n            float microSurface = reflectivityOut.microSurface;\n            float roughness = reflectivityOut.roughness;\n\n            #ifdef METALLICWORKFLOW\n                surfaceAlbedo = reflectivityOut.surfaceAlbedo;\n            #endif\n            #if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\n                aoOut.ambientOcclusionColor = reflectivityOut.ambientOcclusionColor;\n            #endif\r\n";
    return code;
  };
  PBRMetallicRoughnessBlock2.prototype._buildBlock = function(state) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14;
    _super.prototype._buildBlock.call(this, state);
    this._scene = state.sharedData.scene;
    if (!this._environmentBRDFTexture) {
      this._environmentBRDFTexture = BRDFTextureTools.GetEnvironmentBRDFTexture(this._scene);
    }
    var reflectionBlock = this.reflection.isConnected ? (_a = this.reflection.connectedPoint) === null || _a === void 0 ? void 0 : _a.ownerBlock : null;
    if (reflectionBlock) {
      reflectionBlock.worldPositionConnectionPoint = this.worldPosition;
      reflectionBlock.cameraPositionConnectionPoint = this.cameraPosition;
      reflectionBlock.worldNormalConnectionPoint = this.worldNormal;
    }
    if (state.target !== NodeMaterialBlockTargets.Fragment) {
      this._injectVertexCode(state);
      return this;
    }
    state.sharedData.bindableBlocks.push(this);
    state.sharedData.blocksWithDefines.push(this);
    var comments = "//" + this.name;
    var worldPosVarName = "v_" + this.worldPosition.associatedVariableName;
    var normalShading = this.perturbedNormal;
    this._environmentBrdfSamplerName = state._getFreeVariableName("environmentBrdfSampler");
    state._emit2DSampler(this._environmentBrdfSamplerName);
    state.sharedData.hints.needAlphaBlending = state.sharedData.hints.needAlphaBlending || this.useAlphaBlending;
    state.sharedData.hints.needAlphaTesting = state.sharedData.hints.needAlphaTesting || this.useAlphaTest;
    state._emitExtension("lod", "#extension GL_EXT_shader_texture_lod : enable", "defined(LODBASEDMICROSFURACE)");
    state._emitExtension("derivatives", "#extension GL_OES_standard_derivatives : enable");
    if (!this.light) {
      state._emitFunctionFromInclude(state.supportUniformBuffers ? "lightUboDeclaration" : "lightFragmentDeclaration", comments, {
        repeatKey: "maxSimultaneousLights"
      });
    } else {
      state._emitFunctionFromInclude(state.supportUniformBuffers ? "lightUboDeclaration" : "lightFragmentDeclaration", comments, {
        replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }]
      }, this._lightId.toString());
    }
    state._emitFunctionFromInclude("helperFunctions", comments);
    state._emitFunctionFromInclude("importanceSampling", comments);
    state._emitFunctionFromInclude("pbrHelperFunctions", comments);
    state._emitFunctionFromInclude("imageProcessingFunctions", comments);
    state._emitFunctionFromInclude("shadowsFragmentFunctions", comments, {
      replaceStrings: [
        { search: /vPositionW/g, replace: worldPosVarName + ".xyz" }
      ]
    });
    state._emitFunctionFromInclude("pbrDirectLightingSetupFunctions", comments, {
      replaceStrings: [
        { search: /vPositionW/g, replace: worldPosVarName + ".xyz" }
      ]
    });
    state._emitFunctionFromInclude("pbrDirectLightingFalloffFunctions", comments);
    state._emitFunctionFromInclude("pbrBRDFFunctions", comments, {
      replaceStrings: [
        { search: /REFLECTIONMAP_SKYBOX/g, replace: (_b = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineSkyboxName) !== null && _b !== void 0 ? _b : "REFLECTIONMAP_SKYBOX" }
      ]
    });
    state._emitFunctionFromInclude("hdrFilteringFunctions", comments);
    state._emitFunctionFromInclude("pbrDirectLightingFunctions", comments, {
      replaceStrings: [
        { search: /vPositionW/g, replace: worldPosVarName + ".xyz" }
      ]
    });
    state._emitFunctionFromInclude("pbrIBLFunctions", comments);
    state._emitFunctionFromInclude("pbrBlockAlbedoOpacity", comments);
    state._emitFunctionFromInclude("pbrBlockReflectivity", comments);
    state._emitFunctionFromInclude("pbrBlockAmbientOcclusion", comments);
    state._emitFunctionFromInclude("pbrBlockAlphaFresnel", comments);
    state._emitFunctionFromInclude("pbrBlockAnisotropic", comments);
    state._emitUniformFromString("vLightingIntensity", "vec4");
    this._vNormalWName = state._getFreeVariableName("vNormalW");
    state.compilationString += "vec4 " + this._vNormalWName + " = normalize(" + this.worldNormal.associatedVariableName + ");\r\n";
    if (state._registerTempVariable("viewDirectionW")) {
      state.compilationString += "vec3 viewDirectionW = normalize(" + this.cameraPosition.associatedVariableName + " - " + worldPosVarName + ".xyz);\r\n";
    }
    state.compilationString += "vec3 geometricNormalW = " + this._vNormalWName + ".xyz;\r\n";
    state.compilationString += "vec3 normalW = " + (normalShading.isConnected ? "normalize(" + normalShading.associatedVariableName + ".xyz)" : "geometricNormalW") + ";\r\n";
    this._invertNormalName = state._getFreeVariableName("invertNormal");
    state._emitUniformFromString(this._invertNormalName, "float");
    state.compilationString += state._emitCodeFromInclude("pbrBlockNormalFinal", comments, {
      replaceStrings: [
        { search: /vPositionW/g, replace: worldPosVarName + ".xyz" },
        { search: /vEyePosition.w/g, replace: this._invertNormalName }
      ]
    });
    state.compilationString += this._getAlbedoOpacityCode();
    state.compilationString += state._emitCodeFromInclude("depthPrePass", comments);
    state.compilationString += this._getAmbientOcclusionCode();
    state.compilationString += state._emitCodeFromInclude("pbrBlockLightmapInit", comments);
    state.compilationString += "#ifdef UNLIT\n                vec3 diffuseBase = vec3(1., 1., 1.);\n            #else\r\n";
    state.compilationString += this._getReflectivityCode(state);
    state.compilationString += state._emitCodeFromInclude("pbrBlockGeometryInfo", comments, {
      replaceStrings: [
        { search: /REFLECTIONMAP_SKYBOX/g, replace: (_c = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineSkyboxName) !== null && _c !== void 0 ? _c : "REFLECTIONMAP_SKYBOX" },
        { search: /REFLECTIONMAP_3D/g, replace: (_d = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._define3DName) !== null && _d !== void 0 ? _d : "REFLECTIONMAP_3D" }
      ]
    });
    var anisotropyBlock = this.anisotropy.isConnected ? (_e = this.anisotropy.connectedPoint) === null || _e === void 0 ? void 0 : _e.ownerBlock : null;
    if (anisotropyBlock) {
      anisotropyBlock.worldPositionConnectionPoint = this.worldPosition;
      anisotropyBlock.worldNormalConnectionPoint = this.worldNormal;
      state.compilationString += anisotropyBlock.getCode(state, !this.perturbedNormal.isConnected);
    }
    if (reflectionBlock && reflectionBlock.hasTexture) {
      state.compilationString += reflectionBlock.getCode(state, anisotropyBlock ? "anisotropicOut.anisotropicNormal" : "normalW");
    }
    state._emitFunctionFromInclude("pbrBlockReflection", comments, {
      replaceStrings: [
        { search: /computeReflectionCoords/g, replace: "computeReflectionCoordsPBR" },
        { search: /REFLECTIONMAP_3D/g, replace: (_f = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._define3DName) !== null && _f !== void 0 ? _f : "REFLECTIONMAP_3D" },
        { search: /REFLECTIONMAP_OPPOSITEZ/g, replace: (_g = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineOppositeZ) !== null && _g !== void 0 ? _g : "REFLECTIONMAP_OPPOSITEZ" },
        { search: /REFLECTIONMAP_PROJECTION/g, replace: (_h = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineProjectionName) !== null && _h !== void 0 ? _h : "REFLECTIONMAP_PROJECTION" },
        { search: /REFLECTIONMAP_SKYBOX/g, replace: (_j = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineSkyboxName) !== null && _j !== void 0 ? _j : "REFLECTIONMAP_SKYBOX" },
        { search: /LODINREFLECTIONALPHA/g, replace: (_k = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineLODReflectionAlpha) !== null && _k !== void 0 ? _k : "LODINREFLECTIONALPHA" },
        { search: /LINEARSPECULARREFLECTION/g, replace: (_l = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineLinearSpecularReflection) !== null && _l !== void 0 ? _l : "LINEARSPECULARREFLECTION" },
        { search: /vReflectionFilteringInfo/g, replace: (_m = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._vReflectionFilteringInfoName) !== null && _m !== void 0 ? _m : "vReflectionFilteringInfo" }
      ]
    });
    state.compilationString += state._emitCodeFromInclude("pbrBlockReflectance0", comments, {
      replaceStrings: [
        { search: /metallicReflectanceFactors/g, replace: this._vMetallicReflectanceFactorsName }
      ]
    });
    var sheenBlock = this.sheen.isConnected ? (_o = this.sheen.connectedPoint) === null || _o === void 0 ? void 0 : _o.ownerBlock : null;
    if (sheenBlock) {
      state.compilationString += sheenBlock.getCode(reflectionBlock);
    }
    state._emitFunctionFromInclude("pbrBlockSheen", comments, {
      replaceStrings: [
        { search: /REFLECTIONMAP_3D/g, replace: (_p = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._define3DName) !== null && _p !== void 0 ? _p : "REFLECTIONMAP_3D" },
        { search: /REFLECTIONMAP_SKYBOX/g, replace: (_q = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineSkyboxName) !== null && _q !== void 0 ? _q : "REFLECTIONMAP_SKYBOX" },
        { search: /LODINREFLECTIONALPHA/g, replace: (_r = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineLODReflectionAlpha) !== null && _r !== void 0 ? _r : "LODINREFLECTIONALPHA" },
        { search: /LINEARSPECULARREFLECTION/g, replace: (_s = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineLinearSpecularReflection) !== null && _s !== void 0 ? _s : "LINEARSPECULARREFLECTION" }
      ]
    });
    var clearcoatBlock = this.clearcoat.isConnected ? (_t = this.clearcoat.connectedPoint) === null || _t === void 0 ? void 0 : _t.ownerBlock : null;
    var generateTBNSpace = !this.perturbedNormal.isConnected && !this.anisotropy.isConnected;
    var isTangentConnectedToPerturbNormal = this.perturbedNormal.isConnected && ((_u = this.perturbedNormal.connectedPoint) === null || _u === void 0 ? void 0 : _u.ownerBlock).worldTangent.isConnected;
    var isTangentConnectedToAnisotropy = this.anisotropy.isConnected && ((_v = this.anisotropy.connectedPoint) === null || _v === void 0 ? void 0 : _v.ownerBlock).worldTangent.isConnected;
    var vTBNAvailable = isTangentConnectedToPerturbNormal || !this.perturbedNormal.isConnected && isTangentConnectedToAnisotropy;
    state.compilationString += ClearCoatBlock.GetCode(state, clearcoatBlock, reflectionBlock, worldPosVarName, generateTBNSpace, vTBNAvailable, this.worldNormal.associatedVariableName);
    if (generateTBNSpace) {
      vTBNAvailable = (_w = clearcoatBlock === null || clearcoatBlock === void 0 ? void 0 : clearcoatBlock.worldTangent.isConnected) !== null && _w !== void 0 ? _w : false;
    }
    state._emitFunctionFromInclude("pbrBlockClearcoat", comments, {
      replaceStrings: [
        { search: /computeReflectionCoords/g, replace: "computeReflectionCoordsPBR" },
        { search: /REFLECTIONMAP_3D/g, replace: (_x = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._define3DName) !== null && _x !== void 0 ? _x : "REFLECTIONMAP_3D" },
        { search: /REFLECTIONMAP_OPPOSITEZ/g, replace: (_y = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineOppositeZ) !== null && _y !== void 0 ? _y : "REFLECTIONMAP_OPPOSITEZ" },
        { search: /REFLECTIONMAP_PROJECTION/g, replace: (_z = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineProjectionName) !== null && _z !== void 0 ? _z : "REFLECTIONMAP_PROJECTION" },
        { search: /REFLECTIONMAP_SKYBOX/g, replace: (_0 = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineSkyboxName) !== null && _0 !== void 0 ? _0 : "REFLECTIONMAP_SKYBOX" },
        { search: /LODINREFLECTIONALPHA/g, replace: (_1 = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineLODReflectionAlpha) !== null && _1 !== void 0 ? _1 : "LODINREFLECTIONALPHA" },
        { search: /LINEARSPECULARREFLECTION/g, replace: (_2 = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineLinearSpecularReflection) !== null && _2 !== void 0 ? _2 : "LINEARSPECULARREFLECTION" },
        { search: /defined\(TANGENT\)/g, replace: vTBNAvailable ? "defined(TANGENT)" : "defined(IGNORE)" }
      ]
    });
    state.compilationString += state._emitCodeFromInclude("pbrBlockReflectance", comments, {
      replaceStrings: [
        { search: /REFLECTIONMAP_SKYBOX/g, replace: (_3 = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineSkyboxName) !== null && _3 !== void 0 ? _3 : "REFLECTIONMAP_SKYBOX" },
        { search: /REFLECTIONMAP_3D/g, replace: (_4 = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._define3DName) !== null && _4 !== void 0 ? _4 : "REFLECTIONMAP_3D" }
      ]
    });
    var subsurfaceBlock = this.subsurface.isConnected ? (_5 = this.subsurface.connectedPoint) === null || _5 === void 0 ? void 0 : _5.ownerBlock : null;
    var refractionBlock = this.subsurface.isConnected ? (_7 = ((_6 = this.subsurface.connectedPoint) === null || _6 === void 0 ? void 0 : _6.ownerBlock).refraction.connectedPoint) === null || _7 === void 0 ? void 0 : _7.ownerBlock : null;
    if (refractionBlock) {
      refractionBlock.viewConnectionPoint = this.view;
      refractionBlock.indexOfRefractionConnectionPoint = this.indexOfRefraction;
    }
    state.compilationString += SubSurfaceBlock.GetCode(state, subsurfaceBlock, reflectionBlock, worldPosVarName);
    state._emitFunctionFromInclude("pbrBlockSubSurface", comments, {
      replaceStrings: [
        { search: /REFLECTIONMAP_3D/g, replace: (_8 = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._define3DName) !== null && _8 !== void 0 ? _8 : "REFLECTIONMAP_3D" },
        { search: /REFLECTIONMAP_OPPOSITEZ/g, replace: (_9 = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineOppositeZ) !== null && _9 !== void 0 ? _9 : "REFLECTIONMAP_OPPOSITEZ" },
        { search: /REFLECTIONMAP_PROJECTION/g, replace: (_10 = reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineProjectionName) !== null && _10 !== void 0 ? _10 : "REFLECTIONMAP_PROJECTION" },
        { search: /SS_REFRACTIONMAP_3D/g, replace: (_11 = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._define3DName) !== null && _11 !== void 0 ? _11 : "SS_REFRACTIONMAP_3D" },
        { search: /SS_LODINREFRACTIONALPHA/g, replace: (_12 = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._defineLODRefractionAlpha) !== null && _12 !== void 0 ? _12 : "SS_LODINREFRACTIONALPHA" },
        { search: /SS_LINEARSPECULARREFRACTION/g, replace: (_13 = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._defineLinearSpecularRefraction) !== null && _13 !== void 0 ? _13 : "SS_LINEARSPECULARREFRACTION" },
        { search: /SS_REFRACTIONMAP_OPPOSITEZ/g, replace: (_14 = refractionBlock === null || refractionBlock === void 0 ? void 0 : refractionBlock._defineOppositeZ) !== null && _14 !== void 0 ? _14 : "SS_REFRACTIONMAP_OPPOSITEZ" }
      ]
    });
    state.compilationString += state._emitCodeFromInclude("pbrBlockDirectLighting", comments);
    if (this.light) {
      state.compilationString += state._emitCodeFromInclude("lightFragment", comments, {
        replaceStrings: [
          { search: /{X}/g, replace: this._lightId.toString() }
        ]
      });
    } else {
      state.compilationString += state._emitCodeFromInclude("lightFragment", comments, {
        repeatKey: "maxSimultaneousLights"
      });
    }
    state.compilationString += state._emitCodeFromInclude("pbrBlockFinalLitComponents", comments);
    state.compilationString += "#endif\r\n";
    var aoColor = this.ambientColor.isConnected ? this.ambientColor.associatedVariableName : "vec3(0., 0., 0.)";
    var aoDirectLightIntensity = PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS.toString();
    if (aoDirectLightIntensity.indexOf(".") === -1) {
      aoDirectLightIntensity += ".";
    }
    state.compilationString += state._emitCodeFromInclude("pbrBlockFinalUnlitComponents", comments, {
      replaceStrings: [
        { search: /vec3 finalEmissive[\s\S]*?finalEmissive\*=vLightingIntensity\.y;/g, replace: "" },
        { search: /vAmbientColor/g, replace: aoColor + " * ambientFromScene" },
        { search: /vAmbientInfos\.w/g, replace: aoDirectLightIntensity }
      ]
    });
    state.compilationString += state._emitCodeFromInclude("pbrBlockFinalColorComposition", comments, {
      replaceStrings: [
        { search: /finalEmissive/g, replace: "vec3(0.)" }
      ]
    });
    state.compilationString += state._emitCodeFromInclude("pbrBlockImageProcessing", comments, {
      replaceStrings: [
        { search: /visibility/g, replace: "1." }
      ]
    });
    state.compilationString += state._emitCodeFromInclude("pbrDebug", comments, {
      replaceStrings: [
        { search: /vNormalW/g, replace: this._vNormalWName },
        { search: /vPositionW/g, replace: worldPosVarName },
        { search: /albedoTexture\.rgb;/g, replace: "vec3(1.);\r\ngl_FragColor.rgb = toGammaSpace(gl_FragColor.rgb);\r\n" }
      ]
    });
    for (var _i = 0, _15 = this._outputs; _i < _15.length; _i++) {
      var output = _15[_i];
      if (output.hasEndpoints) {
        var remap = mapOutputToVariable[output.name];
        if (remap) {
          var varName = remap[0], conditions = remap[1];
          if (conditions) {
            state.compilationString += "#if " + conditions + "\r\n";
          }
          state.compilationString += this._declareOutput(output, state) + " = " + varName + ";\r\n";
          if (conditions) {
            state.compilationString += "#else\r\n";
            state.compilationString += this._declareOutput(output, state) + " = vec3(0.);\r\n";
            state.compilationString += "#endif\r\n";
          }
        } else {
          console.error("There's no remapping for the " + output.name + " end point! No code generated");
        }
      }
    }
    return this;
  };
  PBRMetallicRoughnessBlock2.prototype._dumpPropertiesCode = function() {
    var codeString = "";
    codeString += this._codeVariableName + ".lightFalloff = " + this.lightFalloff + ";\r\n";
    codeString += this._codeVariableName + ".useAlphaTest = " + this.useAlphaTest + ";\r\n";
    codeString += this._codeVariableName + ".alphaTestCutoff = " + this.alphaTestCutoff + ";\r\n";
    codeString += this._codeVariableName + ".useAlphaBlending = " + this.useAlphaBlending + ";\r\n";
    codeString += this._codeVariableName + ".useRadianceOverAlpha = " + this.useRadianceOverAlpha + ";\r\n";
    codeString += this._codeVariableName + ".useSpecularOverAlpha = " + this.useSpecularOverAlpha + ";\r\n";
    codeString += this._codeVariableName + ".enableSpecularAntiAliasing = " + this.enableSpecularAntiAliasing + ";\r\n";
    codeString += this._codeVariableName + ".realTimeFiltering = " + this.realTimeFiltering + ";\r\n";
    codeString += this._codeVariableName + ".realTimeFilteringQuality = " + this.realTimeFilteringQuality + ";\r\n";
    codeString += this._codeVariableName + ".useEnergyConservation = " + this.useEnergyConservation + ";\r\n";
    codeString += this._codeVariableName + ".useRadianceOcclusion = " + this.useRadianceOcclusion + ";\r\n";
    codeString += this._codeVariableName + ".useHorizonOcclusion = " + this.useHorizonOcclusion + ";\r\n";
    codeString += this._codeVariableName + ".unlit = " + this.unlit + ";\r\n";
    codeString += this._codeVariableName + ".forceNormalForward = " + this.forceNormalForward + ";\r\n";
    codeString += this._codeVariableName + ".debugMode = " + this.debugMode + ";\r\n";
    codeString += this._codeVariableName + ".debugLimit = " + this.debugLimit + ";\r\n";
    codeString += this._codeVariableName + ".debugFactor = " + this.debugFactor + ";\r\n";
    return codeString;
  };
  PBRMetallicRoughnessBlock2.prototype.serialize = function() {
    var serializationObject = _super.prototype.serialize.call(this);
    if (this.light) {
      serializationObject.lightId = this.light.id;
    }
    serializationObject.lightFalloff = this.lightFalloff;
    serializationObject.useAlphaTest = this.useAlphaTest;
    serializationObject.alphaTestCutoff = this.alphaTestCutoff;
    serializationObject.useAlphaBlending = this.useAlphaBlending;
    serializationObject.useRadianceOverAlpha = this.useRadianceOverAlpha;
    serializationObject.useSpecularOverAlpha = this.useSpecularOverAlpha;
    serializationObject.enableSpecularAntiAliasing = this.enableSpecularAntiAliasing;
    serializationObject.realTimeFiltering = this.realTimeFiltering;
    serializationObject.realTimeFilteringQuality = this.realTimeFilteringQuality;
    serializationObject.useEnergyConservation = this.useEnergyConservation;
    serializationObject.useRadianceOcclusion = this.useRadianceOcclusion;
    serializationObject.useHorizonOcclusion = this.useHorizonOcclusion;
    serializationObject.unlit = this.unlit;
    serializationObject.forceNormalForward = this.forceNormalForward;
    serializationObject.debugMode = this.debugMode;
    serializationObject.debugLimit = this.debugLimit;
    serializationObject.debugFactor = this.debugFactor;
    return serializationObject;
  };
  PBRMetallicRoughnessBlock2.prototype._deserialize = function(serializationObject, scene, rootUrl) {
    var _a, _b;
    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);
    if (serializationObject.lightId) {
      this.light = scene.getLightByID(serializationObject.lightId);
    }
    this.lightFalloff = (_a = serializationObject.lightFalloff) !== null && _a !== void 0 ? _a : 0;
    this.useAlphaTest = serializationObject.useAlphaTest;
    this.alphaTestCutoff = serializationObject.alphaTestCutoff;
    this.useAlphaBlending = serializationObject.useAlphaBlending;
    this.useRadianceOverAlpha = serializationObject.useRadianceOverAlpha;
    this.useSpecularOverAlpha = serializationObject.useSpecularOverAlpha;
    this.enableSpecularAntiAliasing = serializationObject.enableSpecularAntiAliasing;
    this.realTimeFiltering = !!serializationObject.realTimeFiltering;
    this.realTimeFilteringQuality = (_b = serializationObject.realTimeFilteringQuality) !== null && _b !== void 0 ? _b : 8;
    this.useEnergyConservation = serializationObject.useEnergyConservation;
    this.useRadianceOcclusion = serializationObject.useRadianceOcclusion;
    this.useHorizonOcclusion = serializationObject.useHorizonOcclusion;
    this.unlit = serializationObject.unlit;
    this.forceNormalForward = !!serializationObject.forceNormalForward;
    this.debugMode = serializationObject.debugMode;
    this.debugLimit = serializationObject.debugLimit;
    this.debugFactor = serializationObject.debugFactor;
  };
  __decorate([
    editableInPropertyPage("Direct lights", PropertyTypeForEdition.Float, "INTENSITY", { min: 0, max: 1, "notifiers": { "update": true } })
  ], PBRMetallicRoughnessBlock2.prototype, "directIntensity", void 0);
  __decorate([
    editableInPropertyPage("Environment lights", PropertyTypeForEdition.Float, "INTENSITY", { min: 0, max: 1, "notifiers": { "update": true } })
  ], PBRMetallicRoughnessBlock2.prototype, "environmentIntensity", void 0);
  __decorate([
    editableInPropertyPage("Specular highlights", PropertyTypeForEdition.Float, "INTENSITY", { min: 0, max: 1, "notifiers": { "update": true } })
  ], PBRMetallicRoughnessBlock2.prototype, "specularIntensity", void 0);
  __decorate([
    editableInPropertyPage("Light falloff", PropertyTypeForEdition.List, "LIGHTING & COLORS", { "notifiers": { "update": true }, "options": [
      { label: "Physical", value: PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL },
      { label: "GLTF", value: PBRBaseMaterial.LIGHTFALLOFF_GLTF },
      { label: "Standard", value: PBRBaseMaterial.LIGHTFALLOFF_STANDARD }
    ] })
  ], PBRMetallicRoughnessBlock2.prototype, "lightFalloff", void 0);
  __decorate([
    editableInPropertyPage("Alpha Testing", PropertyTypeForEdition.Boolean, "OPACITY")
  ], PBRMetallicRoughnessBlock2.prototype, "useAlphaTest", void 0);
  __decorate([
    editableInPropertyPage("Alpha CutOff", PropertyTypeForEdition.Float, "OPACITY", { min: 0, max: 1, "notifiers": { "update": true } })
  ], PBRMetallicRoughnessBlock2.prototype, "alphaTestCutoff", void 0);
  __decorate([
    editableInPropertyPage("Alpha blending", PropertyTypeForEdition.Boolean, "OPACITY")
  ], PBRMetallicRoughnessBlock2.prototype, "useAlphaBlending", void 0);
  __decorate([
    editableInPropertyPage("Radiance over alpha", PropertyTypeForEdition.Boolean, "RENDERING", { "notifiers": { "update": true } })
  ], PBRMetallicRoughnessBlock2.prototype, "useRadianceOverAlpha", void 0);
  __decorate([
    editableInPropertyPage("Specular over alpha", PropertyTypeForEdition.Boolean, "RENDERING", { "notifiers": { "update": true } })
  ], PBRMetallicRoughnessBlock2.prototype, "useSpecularOverAlpha", void 0);
  __decorate([
    editableInPropertyPage("Specular anti-aliasing", PropertyTypeForEdition.Boolean, "RENDERING", { "notifiers": { "update": true } })
  ], PBRMetallicRoughnessBlock2.prototype, "enableSpecularAntiAliasing", void 0);
  __decorate([
    editableInPropertyPage("Realtime filtering", PropertyTypeForEdition.Boolean, "RENDERING", { "notifiers": { "update": true } })
  ], PBRMetallicRoughnessBlock2.prototype, "realTimeFiltering", void 0);
  __decorate([
    editableInPropertyPage("Realtime filtering quality", PropertyTypeForEdition.List, "RENDERING", { "notifiers": { "update": true }, "options": [
      { label: "Low", value: 8 },
      { label: "Medium", value: 16 },
      { label: "High", value: 64 }
    ] })
  ], PBRMetallicRoughnessBlock2.prototype, "realTimeFilteringQuality", void 0);
  __decorate([
    editableInPropertyPage("Energy Conservation", PropertyTypeForEdition.Boolean, "ADVANCED", { "notifiers": { "update": true } })
  ], PBRMetallicRoughnessBlock2.prototype, "useEnergyConservation", void 0);
  __decorate([
    editableInPropertyPage("Radiance occlusion", PropertyTypeForEdition.Boolean, "ADVANCED", { "notifiers": { "update": true } })
  ], PBRMetallicRoughnessBlock2.prototype, "useRadianceOcclusion", void 0);
  __decorate([
    editableInPropertyPage("Horizon occlusion", PropertyTypeForEdition.Boolean, "ADVANCED", { "notifiers": { "update": true } })
  ], PBRMetallicRoughnessBlock2.prototype, "useHorizonOcclusion", void 0);
  __decorate([
    editableInPropertyPage("Unlit", PropertyTypeForEdition.Boolean, "ADVANCED", { "notifiers": { "update": true } })
  ], PBRMetallicRoughnessBlock2.prototype, "unlit", void 0);
  __decorate([
    editableInPropertyPage("Force normal forward", PropertyTypeForEdition.Boolean, "ADVANCED", { "notifiers": { "update": true } })
  ], PBRMetallicRoughnessBlock2.prototype, "forceNormalForward", void 0);
  __decorate([
    editableInPropertyPage("Debug mode", PropertyTypeForEdition.List, "DEBUG", { "notifiers": { "update": true }, "options": [
      { label: "None", value: 0 },
      { label: "Normalized position", value: 1 },
      { label: "Normals", value: 2 },
      { label: "Tangents", value: 3 },
      { label: "Bitangents", value: 4 },
      { label: "Bump Normals", value: 5 },
      { label: "ClearCoat Normals", value: 8 },
      { label: "ClearCoat Tangents", value: 9 },
      { label: "ClearCoat Bitangents", value: 10 },
      { label: "Anisotropic Normals", value: 11 },
      { label: "Anisotropic Tangents", value: 12 },
      { label: "Anisotropic Bitangents", value: 13 },
      { label: "Env Refraction", value: 40 },
      { label: "Env Reflection", value: 41 },
      { label: "Env Clear Coat", value: 42 },
      { label: "Direct Diffuse", value: 50 },
      { label: "Direct Specular", value: 51 },
      { label: "Direct Clear Coat", value: 52 },
      { label: "Direct Sheen", value: 53 },
      { label: "Env Irradiance", value: 54 },
      { label: "Surface Albedo", value: 60 },
      { label: "Reflectance 0", value: 61 },
      { label: "Metallic", value: 62 },
      { label: "Metallic F0", value: 71 },
      { label: "Roughness", value: 63 },
      { label: "AlphaG", value: 64 },
      { label: "NdotV", value: 65 },
      { label: "ClearCoat Color", value: 66 },
      { label: "ClearCoat Roughness", value: 67 },
      { label: "ClearCoat NdotV", value: 68 },
      { label: "Transmittance", value: 69 },
      { label: "Refraction Transmittance", value: 70 },
      { label: "SEO", value: 80 },
      { label: "EHO", value: 81 },
      { label: "Energy Factor", value: 82 },
      { label: "Specular Reflectance", value: 83 },
      { label: "Clear Coat Reflectance", value: 84 },
      { label: "Sheen Reflectance", value: 85 },
      { label: "Luminance Over Alpha", value: 86 },
      { label: "Alpha", value: 87 }
    ] })
  ], PBRMetallicRoughnessBlock2.prototype, "debugMode", void 0);
  __decorate([
    editableInPropertyPage("Split position", PropertyTypeForEdition.Float, "DEBUG", { min: -1, max: 1, "notifiers": { "update": true } })
  ], PBRMetallicRoughnessBlock2.prototype, "debugLimit", void 0);
  __decorate([
    editableInPropertyPage("Output factor", PropertyTypeForEdition.Float, "DEBUG", { min: 0, max: 5, "notifiers": { "update": true } })
  ], PBRMetallicRoughnessBlock2.prototype, "debugFactor", void 0);
  return PBRMetallicRoughnessBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.PBRMetallicRoughnessBlock"] = PBRMetallicRoughnessBlock;

// node_modules/@babylonjs/core/Materials/Node/Blocks/modBlock.js
var ModBlock = function(_super) {
  __extends(ModBlock2, _super);
  function ModBlock2(name98) {
    var _this = _super.call(this, name98, NodeMaterialBlockTargets.Neutral) || this;
    _this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    _this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    _this._outputs[0]._typeConnectionSource = _this._inputs[0];
    _this._linkConnectionTypes(0, 1);
    return _this;
  }
  ModBlock2.prototype.getClassName = function() {
    return "ModBlock";
  };
  Object.defineProperty(ModBlock2.prototype, "left", {
    get: function() {
      return this._inputs[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ModBlock2.prototype, "right", {
    get: function() {
      return this._inputs[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ModBlock2.prototype, "output", {
    get: function() {
      return this._outputs[0];
    },
    enumerable: false,
    configurable: true
  });
  ModBlock2.prototype._buildBlock = function(state) {
    _super.prototype._buildBlock.call(this, state);
    var output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + (" = mod(" + this.left.associatedVariableName + ", " + this.right.associatedVariableName + ");\r\n");
    return this;
  };
  return ModBlock2;
}(NodeMaterialBlock);
_TypeStore.RegisteredTypes["BABYLON.ModBlock"] = ModBlock;

// node_modules/@babylonjs/core/Materials/Node/Optimizers/nodeMaterialOptimizer.js
var NodeMaterialOptimizer = function() {
  function NodeMaterialOptimizer2() {
  }
  NodeMaterialOptimizer2.prototype.optimize = function(vertexOutputNodes, fragmentOutputNodes) {
  };
  return NodeMaterialOptimizer2;
}();

// node_modules/@babylonjs/core/Materials/shadowDepthWrapper.js
var MapMap = function() {
  function MapMap2() {
    this.mm = /* @__PURE__ */ new Map();
  }
  MapMap2.prototype.get = function(a, b) {
    var m = this.mm.get(a);
    if (m !== void 0) {
      return m.get(b);
    }
    return void 0;
  };
  MapMap2.prototype.set = function(a, b, v) {
    var m = this.mm.get(a);
    if (m === void 0) {
      this.mm.set(a, m = /* @__PURE__ */ new Map());
    }
    m.set(b, v);
  };
  return MapMap2;
}();
var ShadowDepthWrapper = function() {
  function ShadowDepthWrapper2(baseMaterial, scene, options) {
    var _this = this;
    this._baseMaterial = baseMaterial;
    this._scene = scene;
    this._options = options;
    this._subMeshToEffect = /* @__PURE__ */ new Map();
    this._subMeshToDepthEffect = new MapMap();
    this._meshes = /* @__PURE__ */ new Map();
    var prefix = baseMaterial.getClassName() === "NodeMaterial" ? "u_" : "";
    if (prefix) {
      this._matriceNames = {
        "world": prefix + "World",
        "view": prefix + "View",
        "projection": prefix + "Projection",
        "viewProjection": prefix + "ViewProjection",
        "worldView": prefix + "WorldxView",
        "worldViewProjection": prefix + "WorldxViewxProjection"
      };
      var nodeMat = baseMaterial;
      var inputBlocks = nodeMat.getInputBlocks();
      for (var i = 0; i < inputBlocks.length; ++i) {
        switch (inputBlocks[i]._systemValue) {
          case NodeMaterialSystemValues.World:
            this._matriceNames["world"] = inputBlocks[i].associatedVariableName;
            break;
          case NodeMaterialSystemValues.View:
            this._matriceNames["view"] = inputBlocks[i].associatedVariableName;
            break;
          case NodeMaterialSystemValues.Projection:
            this._matriceNames["projection"] = inputBlocks[i].associatedVariableName;
            break;
          case NodeMaterialSystemValues.ViewProjection:
            this._matriceNames["viewProjection"] = inputBlocks[i].associatedVariableName;
            break;
          case NodeMaterialSystemValues.WorldView:
            this._matriceNames["worldView"] = inputBlocks[i].associatedVariableName;
            break;
          case NodeMaterialSystemValues.WorldViewProjection:
            this._matriceNames["worldViewProjection"] = inputBlocks[i].associatedVariableName;
            break;
        }
      }
    } else {
      this._matriceNames = {
        "world": prefix + "world",
        "view": prefix + "view",
        "projection": prefix + "projection",
        "viewProjection": prefix + "viewProjection",
        "worldView": prefix + "worldView",
        "worldViewProjection": prefix + "worldViewProjection"
      };
    }
    this._onEffectCreatedObserver = this._baseMaterial.onEffectCreatedObservable.add(function(params) {
      var _a;
      var mesh = (_a = params.subMesh) === null || _a === void 0 ? void 0 : _a.getMesh();
      if (mesh && !_this._meshes.has(mesh)) {
        _this._meshes.set(mesh, mesh.onDisposeObservable.add(function(mesh2) {
          var iterator = _this._subMeshToEffect.keys();
          for (var key = iterator.next(); key.done !== true; key = iterator.next()) {
            var subMesh = key.value;
            if ((subMesh === null || subMesh === void 0 ? void 0 : subMesh.getMesh()) === mesh2) {
              _this._subMeshToEffect.delete(subMesh);
              _this._subMeshToDepthEffect.mm.delete(subMesh);
            }
          }
        }));
      }
      _this._subMeshToEffect.set(params.subMesh, params.effect);
      _this._subMeshToDepthEffect.mm.delete(params.subMesh);
    });
  }
  Object.defineProperty(ShadowDepthWrapper2.prototype, "standalone", {
    get: function() {
      var _a, _b;
      return (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.standalone) !== null && _b !== void 0 ? _b : false;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowDepthWrapper2.prototype, "baseMaterial", {
    get: function() {
      return this._baseMaterial;
    },
    enumerable: false,
    configurable: true
  });
  ShadowDepthWrapper2.prototype.getEffect = function(subMesh, shadowGenerator) {
    var _a, _b, _c, _d, _e, _f;
    return (_f = (_c = (_b = (_a = this._subMeshToDepthEffect.mm.get(subMesh)) === null || _a === void 0 ? void 0 : _a.get(shadowGenerator)) === null || _b === void 0 ? void 0 : _b.depthEffect) !== null && _c !== void 0 ? _c : (_e = (_d = this._subMeshToDepthEffect.mm.get(null)) === null || _d === void 0 ? void 0 : _d.get(shadowGenerator)) === null || _e === void 0 ? void 0 : _e.depthEffect) !== null && _f !== void 0 ? _f : null;
  };
  ShadowDepthWrapper2.prototype.isReadyForSubMesh = function(subMesh, defines, shadowGenerator, useInstances) {
    var _a, _b;
    if (this.standalone) {
      this._baseMaterial.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances);
    }
    return (_b = (_a = this._makeEffect(subMesh, defines, shadowGenerator)) === null || _a === void 0 ? void 0 : _a.isReady()) !== null && _b !== void 0 ? _b : false;
  };
  ShadowDepthWrapper2.prototype.dispose = function() {
    this._baseMaterial.onEffectCreatedObservable.remove(this._onEffectCreatedObserver);
    this._onEffectCreatedObserver = null;
    var iterator = this._meshes.entries();
    for (var entry = iterator.next(); entry.done !== true; entry = iterator.next()) {
      var _a = entry.value, mesh = _a[0], observer = _a[1];
      mesh.onDisposeObservable.remove(observer);
    }
  };
  ShadowDepthWrapper2.prototype._makeEffect = function(subMesh, defines, shadowGenerator) {
    var _a;
    var origEffect = (_a = this._subMeshToEffect.get(subMesh)) !== null && _a !== void 0 ? _a : this._subMeshToEffect.get(null);
    if (!origEffect) {
      return null;
    }
    var params = this._subMeshToDepthEffect.get(subMesh, shadowGenerator);
    if (!params) {
      params = {
        depthEffect: null,
        depthDefines: "",
        token: GUID.RandomId()
      };
      this._subMeshToDepthEffect.set(subMesh, shadowGenerator, params);
    }
    var join = defines.join("\n");
    if (params.depthEffect) {
      if (join === params.depthDefines) {
        return params.depthEffect;
      }
    }
    params.depthDefines = join;
    var vertexCode = origEffect.rawVertexSourceCode, fragmentCode = origEffect.rawFragmentSourceCode;
    var vertexNormalBiasCode = this._options && this._options.remappedVariables ? "#include<shadowMapVertexNormalBias>(" + this._options.remappedVariables.join(",") + ")" : Effect.IncludesShadersStore["shadowMapVertexNormalBias"], vertexMetricCode = this._options && this._options.remappedVariables ? "#include<shadowMapVertexMetric>(" + this._options.remappedVariables.join(",") + ")" : Effect.IncludesShadersStore["shadowMapVertexMetric"], fragmentSoftTransparentShadow = this._options && this._options.remappedVariables ? "#include<shadowMapFragmentSoftTransparentShadow>(" + this._options.remappedVariables.join(",") + ")" : Effect.IncludesShadersStore["shadowMapFragmentSoftTransparentShadow"], fragmentBlockCode = Effect.IncludesShadersStore["shadowMapFragment"];
    vertexCode = vertexCode.replace(/void\s+?main/g, Effect.IncludesShadersStore["shadowMapVertexDeclaration"] + "\r\nvoid main");
    vertexCode = vertexCode.replace(/#define SHADOWDEPTH_NORMALBIAS|#define CUSTOM_VERTEX_UPDATE_WORLDPOS/g, vertexNormalBiasCode);
    if (vertexCode.indexOf("#define SHADOWDEPTH_METRIC") !== -1) {
      vertexCode = vertexCode.replace(/#define SHADOWDEPTH_METRIC/g, vertexMetricCode);
    } else {
      vertexCode = vertexCode.replace(/}\s*$/g, vertexMetricCode + "\r\n}");
    }
    vertexCode = vertexCode.replace(/#define SHADER_NAME.*?\n|out vec4 glFragColor;\n/g, "");
    var hasLocationForSoftTransparentShadow = fragmentCode.indexOf("#define SHADOWDEPTH_SOFTTRANSPARENTSHADOW") >= 0 || fragmentCode.indexOf("#define CUSTOM_FRAGMENT_BEFORE_FOG") >= 0;
    var hasLocationForFragment = fragmentCode.indexOf("#define SHADOWDEPTH_FRAGMENT") !== -1;
    var fragmentCodeToInjectAtEnd = "";
    if (!hasLocationForSoftTransparentShadow) {
      fragmentCodeToInjectAtEnd = fragmentSoftTransparentShadow + "\r\n";
    } else {
      fragmentCode = fragmentCode.replace(/#define SHADOWDEPTH_SOFTTRANSPARENTSHADOW|#define CUSTOM_FRAGMENT_BEFORE_FOG/g, fragmentSoftTransparentShadow);
    }
    fragmentCode = fragmentCode.replace(/void\s+?main/g, Effect.IncludesShadersStore["shadowMapFragmentDeclaration"] + "\r\nvoid main");
    if (hasLocationForFragment) {
      fragmentCode = fragmentCode.replace(/#define SHADOWDEPTH_FRAGMENT/g, fragmentBlockCode);
    } else {
      fragmentCodeToInjectAtEnd += fragmentBlockCode + "\r\n";
    }
    if (fragmentCodeToInjectAtEnd) {
      fragmentCode = fragmentCode.replace(/}\s*$/g, fragmentCodeToInjectAtEnd + "}");
    }
    fragmentCode = fragmentCode.replace(/#define SHADER_NAME.*?\n|out vec4 glFragColor;\n/g, "");
    var uniforms = origEffect.getUniformNames().slice();
    uniforms.push("biasAndScaleSM", "depthValuesSM", "lightDataSM", "softTransparentShadowSM");
    params.depthEffect = this._scene.getEngine().createEffect({
      vertexSource: vertexCode,
      fragmentSource: fragmentCode,
      vertexToken: params.token,
      fragmentToken: params.token
    }, {
      attributes: origEffect.getAttributesNames(),
      uniformsNames: uniforms,
      uniformBuffersNames: origEffect.getUniformBuffersNames(),
      samplers: origEffect.getSamplers(),
      defines: join + "\n" + origEffect.defines.replace("#define SHADOWS", "").replace(/#define SHADOW\d/g, ""),
      indexParameters: origEffect.getIndexParameters()
    }, this._scene.getEngine());
    return params.depthEffect;
  };
  return ShadowDepthWrapper2;
}();

// node_modules/@babylonjs/core/Meshes/csg.js
var currentCSGMeshId = 0;
var Vertex = function() {
  function Vertex2(pos, normal, uv, vertColor) {
    this.pos = pos;
    this.normal = normal;
    this.uv = uv;
    this.vertColor = vertColor;
  }
  Vertex2.prototype.clone = function() {
    var _a, _b;
    return new Vertex2(this.pos.clone(), this.normal.clone(), (_a = this.uv) === null || _a === void 0 ? void 0 : _a.clone(), (_b = this.vertColor) === null || _b === void 0 ? void 0 : _b.clone());
  };
  Vertex2.prototype.flip = function() {
    this.normal = this.normal.scale(-1);
  };
  Vertex2.prototype.interpolate = function(other, t) {
    return new Vertex2(Vector3.Lerp(this.pos, other.pos, t), Vector3.Lerp(this.normal, other.normal, t), this.uv && other.uv ? Vector2.Lerp(this.uv, other.uv, t) : void 0, this.vertColor && other.vertColor ? Color4.Lerp(this.vertColor, other.vertColor, t) : void 0);
  };
  return Vertex2;
}();
var Plane2 = function() {
  function Plane3(normal, w) {
    this.normal = normal;
    this.w = w;
  }
  Plane3.FromPoints = function(a, b, c) {
    var v0 = c.subtract(a);
    var v1 = b.subtract(a);
    if (v0.lengthSquared() === 0 || v1.lengthSquared() === 0) {
      return null;
    }
    var n = Vector3.Normalize(Vector3.Cross(v0, v1));
    return new Plane3(n, Vector3.Dot(n, a));
  };
  Plane3.prototype.clone = function() {
    return new Plane3(this.normal.clone(), this.w);
  };
  Plane3.prototype.flip = function() {
    this.normal.scaleInPlace(-1);
    this.w = -this.w;
  };
  Plane3.prototype.splitPolygon = function(polygon, coplanarFront, coplanarBack, front, back) {
    var COPLANAR = 0;
    var FRONT = 1;
    var BACK = 2;
    var SPANNING = 3;
    var polygonType = 0;
    var types = [];
    var i;
    var t;
    for (i = 0; i < polygon.vertices.length; i++) {
      t = Vector3.Dot(this.normal, polygon.vertices[i].pos) - this.w;
      var type = t < -Plane3.EPSILON ? BACK : t > Plane3.EPSILON ? FRONT : COPLANAR;
      polygonType |= type;
      types.push(type);
    }
    switch (polygonType) {
      case COPLANAR:
        (Vector3.Dot(this.normal, polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);
        break;
      case FRONT:
        front.push(polygon);
        break;
      case BACK:
        back.push(polygon);
        break;
      case SPANNING:
        var f = [], b = [];
        for (i = 0; i < polygon.vertices.length; i++) {
          var j = (i + 1) % polygon.vertices.length;
          var ti = types[i], tj = types[j];
          var vi = polygon.vertices[i], vj = polygon.vertices[j];
          if (ti !== BACK) {
            f.push(vi);
          }
          if (ti !== FRONT) {
            b.push(ti !== BACK ? vi.clone() : vi);
          }
          if ((ti | tj) === SPANNING) {
            t = (this.w - Vector3.Dot(this.normal, vi.pos)) / Vector3.Dot(this.normal, vj.pos.subtract(vi.pos));
            var v = vi.interpolate(vj, t);
            f.push(v);
            b.push(v.clone());
          }
        }
        var poly;
        if (f.length >= 3) {
          poly = new Polygon(f, polygon.shared);
          if (poly.plane) {
            front.push(poly);
          }
        }
        if (b.length >= 3) {
          poly = new Polygon(b, polygon.shared);
          if (poly.plane) {
            back.push(poly);
          }
        }
        break;
    }
  };
  Plane3.EPSILON = 1e-5;
  return Plane3;
}();
var Polygon = function() {
  function Polygon3(vertices, shared) {
    this.vertices = vertices;
    this.shared = shared;
    this.plane = Plane2.FromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);
  }
  Polygon3.prototype.clone = function() {
    var vertices = this.vertices.map(function(v) {
      return v.clone();
    });
    return new Polygon3(vertices, this.shared);
  };
  Polygon3.prototype.flip = function() {
    this.vertices.reverse().map(function(v) {
      v.flip();
    });
    this.plane.flip();
  };
  return Polygon3;
}();
var Node3 = function() {
  function Node4(polygons) {
    this.plane = null;
    this.front = null;
    this.back = null;
    this.polygons = new Array();
    if (polygons) {
      this.build(polygons);
    }
  }
  Node4.prototype.clone = function() {
    var node = new Node4();
    node.plane = this.plane && this.plane.clone();
    node.front = this.front && this.front.clone();
    node.back = this.back && this.back.clone();
    node.polygons = this.polygons.map(function(p) {
      return p.clone();
    });
    return node;
  };
  Node4.prototype.invert = function() {
    for (var i = 0; i < this.polygons.length; i++) {
      this.polygons[i].flip();
    }
    if (this.plane) {
      this.plane.flip();
    }
    if (this.front) {
      this.front.invert();
    }
    if (this.back) {
      this.back.invert();
    }
    var temp = this.front;
    this.front = this.back;
    this.back = temp;
  };
  Node4.prototype.clipPolygons = function(polygons) {
    if (!this.plane) {
      return polygons.slice();
    }
    var front = new Array(), back = new Array();
    for (var i = 0; i < polygons.length; i++) {
      this.plane.splitPolygon(polygons[i], front, back, front, back);
    }
    if (this.front) {
      front = this.front.clipPolygons(front);
    }
    if (this.back) {
      back = this.back.clipPolygons(back);
    } else {
      back = [];
    }
    return front.concat(back);
  };
  Node4.prototype.clipTo = function(bsp) {
    this.polygons = bsp.clipPolygons(this.polygons);
    if (this.front) {
      this.front.clipTo(bsp);
    }
    if (this.back) {
      this.back.clipTo(bsp);
    }
  };
  Node4.prototype.allPolygons = function() {
    var polygons = this.polygons.slice();
    if (this.front) {
      polygons = polygons.concat(this.front.allPolygons());
    }
    if (this.back) {
      polygons = polygons.concat(this.back.allPolygons());
    }
    return polygons;
  };
  Node4.prototype.build = function(polygons) {
    if (!polygons.length) {
      return;
    }
    if (!this.plane) {
      this.plane = polygons[0].plane.clone();
    }
    var front = new Array(), back = new Array();
    for (var i = 0; i < polygons.length; i++) {
      this.plane.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);
    }
    if (front.length) {
      if (!this.front) {
        this.front = new Node4();
      }
      this.front.build(front);
    }
    if (back.length) {
      if (!this.back) {
        this.back = new Node4();
      }
      this.back.build(back);
    }
  };
  return Node4;
}();
var CSG = function() {
  function CSG2() {
    this.polygons = new Array();
  }
  CSG2.FromMesh = function(mesh) {
    var vertex, normal, uv = void 0, position, vertColor = void 0, polygon, polygons = new Array(), vertices;
    var matrix, meshPosition, meshRotation, meshRotationQuaternion = null, meshScaling;
    if (mesh instanceof Mesh) {
      mesh.computeWorldMatrix(true);
      matrix = mesh.getWorldMatrix();
      meshPosition = mesh.position.clone();
      meshRotation = mesh.rotation.clone();
      if (mesh.rotationQuaternion) {
        meshRotationQuaternion = mesh.rotationQuaternion.clone();
      }
      meshScaling = mesh.scaling.clone();
    } else {
      throw "BABYLON.CSG: Wrong Mesh type, must be BABYLON.Mesh";
    }
    var indices = mesh.getIndices(), positions = mesh.getVerticesData(VertexBuffer.PositionKind), normals = mesh.getVerticesData(VertexBuffer.NormalKind), uvs = mesh.getVerticesData(VertexBuffer.UVKind), vertColors = mesh.getVerticesData(VertexBuffer.ColorKind);
    var subMeshes = mesh.subMeshes;
    for (var sm = 0, sml = subMeshes.length; sm < sml; sm++) {
      for (var i = subMeshes[sm].indexStart, il = subMeshes[sm].indexCount + subMeshes[sm].indexStart; i < il; i += 3) {
        vertices = [];
        for (var j = 0; j < 3; j++) {
          var sourceNormal = new Vector3(normals[indices[i + j] * 3], normals[indices[i + j] * 3 + 1], normals[indices[i + j] * 3 + 2]);
          if (uvs) {
            uv = new Vector2(uvs[indices[i + j] * 2], uvs[indices[i + j] * 2 + 1]);
          }
          if (vertColors) {
            vertColor = new Color4(vertColors[indices[i + j] * 4], vertColors[indices[i + j] * 4 + 1], vertColors[indices[i + j] * 4 + 2], vertColors[indices[i + j] * 4 + 3]);
          }
          var sourcePosition = new Vector3(positions[indices[i + j] * 3], positions[indices[i + j] * 3 + 1], positions[indices[i + j] * 3 + 2]);
          position = Vector3.TransformCoordinates(sourcePosition, matrix);
          normal = Vector3.TransformNormal(sourceNormal, matrix);
          vertex = new Vertex(position, normal, uv, vertColor);
          vertices.push(vertex);
        }
        polygon = new Polygon(vertices, { subMeshId: sm, meshId: currentCSGMeshId, materialIndex: subMeshes[sm].materialIndex });
        if (polygon.plane) {
          polygons.push(polygon);
        }
      }
    }
    var csg = CSG2.FromPolygons(polygons);
    csg.matrix = matrix;
    csg.position = meshPosition;
    csg.rotation = meshRotation;
    csg.scaling = meshScaling;
    csg.rotationQuaternion = meshRotationQuaternion;
    currentCSGMeshId++;
    return csg;
  };
  CSG2.FromPolygons = function(polygons) {
    var csg = new CSG2();
    csg.polygons = polygons;
    return csg;
  };
  CSG2.prototype.clone = function() {
    var csg = new CSG2();
    csg.polygons = this.polygons.map(function(p) {
      return p.clone();
    });
    csg.copyTransformAttributes(this);
    return csg;
  };
  CSG2.prototype.union = function(csg) {
    var a = new Node3(this.clone().polygons);
    var b = new Node3(csg.clone().polygons);
    a.clipTo(b);
    b.clipTo(a);
    b.invert();
    b.clipTo(a);
    b.invert();
    a.build(b.allPolygons());
    return CSG2.FromPolygons(a.allPolygons()).copyTransformAttributes(this);
  };
  CSG2.prototype.unionInPlace = function(csg) {
    var a = new Node3(this.polygons);
    var b = new Node3(csg.polygons);
    a.clipTo(b);
    b.clipTo(a);
    b.invert();
    b.clipTo(a);
    b.invert();
    a.build(b.allPolygons());
    this.polygons = a.allPolygons();
  };
  CSG2.prototype.subtract = function(csg) {
    var a = new Node3(this.clone().polygons);
    var b = new Node3(csg.clone().polygons);
    a.invert();
    a.clipTo(b);
    b.clipTo(a);
    b.invert();
    b.clipTo(a);
    b.invert();
    a.build(b.allPolygons());
    a.invert();
    return CSG2.FromPolygons(a.allPolygons()).copyTransformAttributes(this);
  };
  CSG2.prototype.subtractInPlace = function(csg) {
    var a = new Node3(this.polygons);
    var b = new Node3(csg.polygons);
    a.invert();
    a.clipTo(b);
    b.clipTo(a);
    b.invert();
    b.clipTo(a);
    b.invert();
    a.build(b.allPolygons());
    a.invert();
    this.polygons = a.allPolygons();
  };
  CSG2.prototype.intersect = function(csg) {
    var a = new Node3(this.clone().polygons);
    var b = new Node3(csg.clone().polygons);
    a.invert();
    b.clipTo(a);
    b.invert();
    a.clipTo(b);
    b.clipTo(a);
    a.build(b.allPolygons());
    a.invert();
    return CSG2.FromPolygons(a.allPolygons()).copyTransformAttributes(this);
  };
  CSG2.prototype.intersectInPlace = function(csg) {
    var a = new Node3(this.polygons);
    var b = new Node3(csg.polygons);
    a.invert();
    b.clipTo(a);
    b.invert();
    a.clipTo(b);
    b.clipTo(a);
    a.build(b.allPolygons());
    a.invert();
    this.polygons = a.allPolygons();
  };
  CSG2.prototype.inverse = function() {
    var csg = this.clone();
    csg.inverseInPlace();
    return csg;
  };
  CSG2.prototype.inverseInPlace = function() {
    this.polygons.map(function(p) {
      p.flip();
    });
  };
  CSG2.prototype.copyTransformAttributes = function(csg) {
    this.matrix = csg.matrix;
    this.position = csg.position;
    this.rotation = csg.rotation;
    this.scaling = csg.scaling;
    this.rotationQuaternion = csg.rotationQuaternion;
    return this;
  };
  CSG2.prototype.buildMeshGeometry = function(name98, scene, keepSubMeshes) {
    var matrix = this.matrix.clone();
    matrix.invert();
    var mesh = new Mesh(name98, scene);
    var vertices = [];
    var indices = [];
    var normals = [];
    var uvs = null;
    var vertColors = null;
    var vertex = Vector3.Zero();
    var normal = Vector3.Zero();
    var uv = Vector2.Zero();
    var vertColor = new Color4(0, 0, 0, 0);
    var polygons = this.polygons;
    var polygonIndices = [0, 0, 0], polygon;
    var vertice_dict = {};
    var vertex_idx;
    var currentIndex = 0;
    var subMesh_dict = {};
    var subMesh_obj;
    if (keepSubMeshes) {
      polygons.sort(function(a, b) {
        if (a.shared.meshId === b.shared.meshId) {
          return a.shared.subMeshId - b.shared.subMeshId;
        } else {
          return a.shared.meshId - b.shared.meshId;
        }
      });
    }
    for (var i = 0, il = polygons.length; i < il; i++) {
      polygon = polygons[i];
      if (!subMesh_dict[polygon.shared.meshId]) {
        subMesh_dict[polygon.shared.meshId] = {};
      }
      if (!subMesh_dict[polygon.shared.meshId][polygon.shared.subMeshId]) {
        subMesh_dict[polygon.shared.meshId][polygon.shared.subMeshId] = {
          indexStart: Infinity,
          indexEnd: -Infinity,
          materialIndex: polygon.shared.materialIndex
        };
      }
      subMesh_obj = subMesh_dict[polygon.shared.meshId][polygon.shared.subMeshId];
      for (var j = 2, jl = polygon.vertices.length; j < jl; j++) {
        polygonIndices[0] = 0;
        polygonIndices[1] = j - 1;
        polygonIndices[2] = j;
        for (var k = 0; k < 3; k++) {
          vertex.copyFrom(polygon.vertices[polygonIndices[k]].pos);
          normal.copyFrom(polygon.vertices[polygonIndices[k]].normal);
          if (polygon.vertices[polygonIndices[k]].uv) {
            if (!uvs) {
              uvs = [];
            }
            uv.copyFrom(polygon.vertices[polygonIndices[k]].uv);
          }
          if (polygon.vertices[polygonIndices[k]].vertColor) {
            if (!vertColors) {
              vertColors = [];
            }
            vertColor.copyFrom(polygon.vertices[polygonIndices[k]].vertColor);
          }
          var localVertex = Vector3.TransformCoordinates(vertex, matrix);
          var localNormal = Vector3.TransformNormal(normal, matrix);
          vertex_idx = vertice_dict[localVertex.x + "," + localVertex.y + "," + localVertex.z];
          var areUvsDifferent = false;
          if (uvs && !(uvs[vertex_idx * 2] === uv.x || uvs[vertex_idx * 2 + 1] === uv.y)) {
            areUvsDifferent = true;
          }
          var areColorsDifferent = false;
          if (vertColors && !(vertColors[vertex_idx * 4] === vertColor.r || vertColors[vertex_idx * 4 + 1] === vertColor.g || vertColors[vertex_idx * 4 + 2] === vertColor.b || vertColors[vertex_idx * 4 + 3] === vertColor.a)) {
            areColorsDifferent = true;
          }
          if (!(typeof vertex_idx !== "undefined" && normals[vertex_idx * 3] === localNormal.x && normals[vertex_idx * 3 + 1] === localNormal.y && normals[vertex_idx * 3 + 2] === localNormal.z) || areUvsDifferent || areColorsDifferent) {
            vertices.push(localVertex.x, localVertex.y, localVertex.z);
            if (uvs) {
              uvs.push(uv.x, uv.y);
            }
            normals.push(normal.x, normal.y, normal.z);
            if (vertColors) {
              vertColors.push(vertColor.r, vertColor.g, vertColor.b, vertColor.a);
            }
            vertex_idx = vertice_dict[localVertex.x + "," + localVertex.y + "," + localVertex.z] = vertices.length / 3 - 1;
          }
          indices.push(vertex_idx);
          subMesh_obj.indexStart = Math.min(currentIndex, subMesh_obj.indexStart);
          subMesh_obj.indexEnd = Math.max(currentIndex, subMesh_obj.indexEnd);
          currentIndex++;
        }
      }
    }
    mesh.setVerticesData(VertexBuffer.PositionKind, vertices);
    mesh.setVerticesData(VertexBuffer.NormalKind, normals);
    if (uvs) {
      mesh.setVerticesData(VertexBuffer.UVKind, uvs);
    }
    if (vertColors) {
      mesh.setVerticesData(VertexBuffer.ColorKind, vertColors);
    }
    mesh.setIndices(indices, null);
    if (keepSubMeshes) {
      var materialIndexOffset = 0, materialMaxIndex;
      mesh.subMeshes = new Array();
      for (var m in subMesh_dict) {
        materialMaxIndex = -1;
        for (var sm in subMesh_dict[m]) {
          subMesh_obj = subMesh_dict[m][sm];
          SubMesh.CreateFromIndices(subMesh_obj.materialIndex + materialIndexOffset, subMesh_obj.indexStart, subMesh_obj.indexEnd - subMesh_obj.indexStart + 1, mesh);
          materialMaxIndex = Math.max(subMesh_obj.materialIndex, materialMaxIndex);
        }
        materialIndexOffset += ++materialMaxIndex;
      }
    }
    return mesh;
  };
  CSG2.prototype.toMesh = function(name98, material, scene, keepSubMeshes) {
    if (material === void 0) {
      material = null;
    }
    var mesh = this.buildMeshGeometry(name98, scene, keepSubMeshes);
    mesh.material = material;
    mesh.position.copyFrom(this.position);
    mesh.rotation.copyFrom(this.rotation);
    if (this.rotationQuaternion) {
      mesh.rotationQuaternion = this.rotationQuaternion.clone();
    }
    mesh.scaling.copyFrom(this.scaling);
    mesh.computeWorldMatrix(true);
    return mesh;
  };
  return CSG2;
}();

// node_modules/@babylonjs/core/Meshes/trailMesh.js
var TrailMesh = function(_super) {
  __extends(TrailMesh2, _super);
  function TrailMesh2(name98, generator, scene, diameter, length, autoStart) {
    if (diameter === void 0) {
      diameter = 1;
    }
    if (length === void 0) {
      length = 60;
    }
    if (autoStart === void 0) {
      autoStart = true;
    }
    var _this = _super.call(this, name98, scene) || this;
    _this._sectionPolygonPointsCount = 4;
    _this._running = false;
    _this._autoStart = autoStart;
    _this._generator = generator;
    _this._diameter = diameter;
    _this._length = length;
    _this._sectionVectors = [];
    _this._sectionNormalVectors = [];
    for (var i = 0; i < _this._sectionPolygonPointsCount; i++) {
      _this._sectionVectors[i] = Vector3.Zero();
      _this._sectionNormalVectors[i] = Vector3.Zero();
    }
    _this._createMesh();
    return _this;
  }
  TrailMesh2.prototype.getClassName = function() {
    return "TrailMesh";
  };
  TrailMesh2.prototype._createMesh = function() {
    var data = new VertexData();
    var positions = [];
    var normals = [];
    var indices = [];
    var meshCenter = Vector3.Zero();
    if (this._generator instanceof AbstractMesh && this._generator._boundingInfo) {
      meshCenter = this._generator._boundingInfo.boundingBox.centerWorld;
    } else {
      meshCenter = this._generator.position;
    }
    var alpha = 2 * Math.PI / this._sectionPolygonPointsCount;
    for (var i = 0; i < this._sectionPolygonPointsCount; i++) {
      positions.push(meshCenter.x + Math.cos(i * alpha) * this._diameter, meshCenter.y + Math.sin(i * alpha) * this._diameter, meshCenter.z);
    }
    for (var i = 1; i <= this._length; i++) {
      for (var j = 0; j < this._sectionPolygonPointsCount; j++) {
        positions.push(meshCenter.x + Math.cos(j * alpha) * this._diameter, meshCenter.y + Math.sin(j * alpha) * this._diameter, meshCenter.z);
      }
      var l = positions.length / 3 - 2 * this._sectionPolygonPointsCount;
      for (var j = 0; j < this._sectionPolygonPointsCount - 1; j++) {
        indices.push(l + j, l + j + this._sectionPolygonPointsCount, l + j + this._sectionPolygonPointsCount + 1);
        indices.push(l + j, l + j + this._sectionPolygonPointsCount + 1, l + j + 1);
      }
      indices.push(l + this._sectionPolygonPointsCount - 1, l + this._sectionPolygonPointsCount - 1 + this._sectionPolygonPointsCount, l + this._sectionPolygonPointsCount);
      indices.push(l + this._sectionPolygonPointsCount - 1, l + this._sectionPolygonPointsCount, l);
    }
    VertexData.ComputeNormals(positions, indices, normals);
    data.positions = positions;
    data.normals = normals;
    data.indices = indices;
    data.applyToMesh(this, true);
    if (this._autoStart) {
      this.start();
    }
  };
  TrailMesh2.prototype.start = function() {
    var _this = this;
    if (!this._running) {
      this._running = true;
      this._beforeRenderObserver = this.getScene().onBeforeRenderObservable.add(function() {
        _this.update();
      });
    }
  };
  TrailMesh2.prototype.stop = function() {
    if (this._beforeRenderObserver && this._running) {
      this._running = false;
      this.getScene().onBeforeRenderObservable.remove(this._beforeRenderObserver);
    }
  };
  TrailMesh2.prototype.update = function() {
    var positions = this.getVerticesData(VertexBuffer.PositionKind);
    var normals = this.getVerticesData(VertexBuffer.NormalKind);
    var wm = this._generator.getWorldMatrix();
    if (positions && normals) {
      for (var i = 3 * this._sectionPolygonPointsCount; i < positions.length; i++) {
        positions[i - 3 * this._sectionPolygonPointsCount] = positions[i] - normals[i] / this._length * this._diameter;
      }
      for (var i = 3 * this._sectionPolygonPointsCount; i < normals.length; i++) {
        normals[i - 3 * this._sectionPolygonPointsCount] = normals[i];
      }
      var l = positions.length - 3 * this._sectionPolygonPointsCount;
      var alpha = 2 * Math.PI / this._sectionPolygonPointsCount;
      for (var i = 0; i < this._sectionPolygonPointsCount; i++) {
        this._sectionVectors[i].copyFromFloats(Math.cos(i * alpha) * this._diameter, Math.sin(i * alpha) * this._diameter, 0);
        this._sectionNormalVectors[i].copyFromFloats(Math.cos(i * alpha), Math.sin(i * alpha), 0);
        Vector3.TransformCoordinatesToRef(this._sectionVectors[i], wm, this._sectionVectors[i]);
        Vector3.TransformNormalToRef(this._sectionNormalVectors[i], wm, this._sectionNormalVectors[i]);
      }
      for (var i = 0; i < this._sectionPolygonPointsCount; i++) {
        positions[l + 3 * i] = this._sectionVectors[i].x;
        positions[l + 3 * i + 1] = this._sectionVectors[i].y;
        positions[l + 3 * i + 2] = this._sectionVectors[i].z;
        normals[l + 3 * i] = this._sectionNormalVectors[i].x;
        normals[l + 3 * i + 1] = this._sectionNormalVectors[i].y;
        normals[l + 3 * i + 2] = this._sectionNormalVectors[i].z;
      }
      this.updateVerticesData(VertexBuffer.PositionKind, positions, true, false);
      this.updateVerticesData(VertexBuffer.NormalKind, normals, true, false);
    }
  };
  TrailMesh2.prototype.clone = function(name98, newGenerator) {
    if (name98 === void 0) {
      name98 = "";
    }
    return new TrailMesh2(name98, newGenerator === void 0 ? this._generator : newGenerator, this.getScene(), this._diameter, this._length, this._autoStart);
  };
  TrailMesh2.prototype.serialize = function(serializationObject) {
    _super.prototype.serialize.call(this, serializationObject);
  };
  TrailMesh2.Parse = function(parsedMesh, scene) {
    return new TrailMesh2(parsedMesh.name, parsedMesh._generator, scene, parsedMesh._diameter, parsedMesh._length, parsedMesh._autoStart);
  };
  return TrailMesh2;
}(Mesh);

// node_modules/@babylonjs/core/Meshes/Builders/discBuilder.js
VertexData.CreateDisc = function(options) {
  var positions = new Array();
  var indices = new Array();
  var normals = new Array();
  var uvs = new Array();
  var radius = options.radius || 0.5;
  var tessellation = options.tessellation || 64;
  var arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1 : options.arc || 1;
  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  positions.push(0, 0, 0);
  uvs.push(0.5, 0.5);
  var theta = Math.PI * 2 * arc;
  var step = arc === 1 ? theta / tessellation : theta / (tessellation - 1);
  var a = 0;
  for (var t = 0; t < tessellation; t++) {
    var x = Math.cos(a);
    var y = Math.sin(a);
    var u = (x + 1) / 2;
    var v = (1 - y) / 2;
    positions.push(radius * x, radius * y, 0);
    uvs.push(u, v);
    a += step;
  }
  if (arc === 1) {
    positions.push(positions[3], positions[4], positions[5]);
    uvs.push(uvs[2], uvs[3]);
  }
  var vertexNb = positions.length / 3;
  for (var i = 1; i < vertexNb - 1; i++) {
    indices.push(i + 1, 0, i);
  }
  VertexData.ComputeNormals(positions, indices, normals);
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  var vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
};
Mesh.CreateDisc = function(name98, radius, tessellation, scene, updatable, sideOrientation) {
  if (scene === void 0) {
    scene = null;
  }
  var options = {
    radius,
    tessellation,
    sideOrientation,
    updatable
  };
  return DiscBuilder.CreateDisc(name98, options, scene);
};
var DiscBuilder = function() {
  function DiscBuilder2() {
  }
  DiscBuilder2.CreateDisc = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    var disc = new Mesh(name98, scene);
    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
    disc._originalBuilderSideOrientation = options.sideOrientation;
    var vertexData = VertexData.CreateDisc(options);
    vertexData.applyToMesh(disc, options.updatable);
    return disc;
  };
  return DiscBuilder2;
}();

// node_modules/@babylonjs/core/Meshes/Builders/tiledBoxBuilder.js
VertexData.CreateTiledBox = function(options) {
  var nbFaces = 6;
  var faceUV = options.faceUV || new Array(6);
  var faceColors = options.faceColors;
  var flipTile = options.pattern || Mesh.NO_FLIP;
  var width = options.width || options.size || 1;
  var height = options.height || options.size || 1;
  var depth = options.depth || options.size || 1;
  var tileWidth = options.tileWidth || options.tileSize || 1;
  var tileHeight = options.tileHeight || options.tileSize || 1;
  var alignH = options.alignHorizontal || 0;
  var alignV = options.alignVertical || 0;
  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  for (var f = 0; f < nbFaces; f++) {
    if (faceUV[f] === void 0) {
      faceUV[f] = new Vector4(0, 0, 1, 1);
    }
    if (faceColors && faceColors[f] === void 0) {
      faceColors[f] = new Color4(1, 1, 1, 1);
    }
  }
  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var halfDepth = depth / 2;
  var faceVertexData = [];
  for (var f = 0; f < 2; f++) {
    faceVertexData[f] = VertexData.CreateTiledPlane({
      pattern: flipTile,
      tileWidth,
      tileHeight,
      width,
      height,
      alignVertical: alignV,
      alignHorizontal: alignH,
      sideOrientation
    });
  }
  for (var f = 2; f < 4; f++) {
    faceVertexData[f] = VertexData.CreateTiledPlane({
      pattern: flipTile,
      tileWidth,
      tileHeight,
      width: depth,
      height,
      alignVertical: alignV,
      alignHorizontal: alignH,
      sideOrientation
    });
  }
  var baseAlignV = alignV;
  if (alignV === Mesh.BOTTOM) {
    baseAlignV = Mesh.TOP;
  } else if (alignV === Mesh.TOP) {
    baseAlignV = Mesh.BOTTOM;
  }
  for (var f = 4; f < 6; f++) {
    faceVertexData[f] = VertexData.CreateTiledPlane({
      pattern: flipTile,
      tileWidth,
      tileHeight,
      width,
      height: depth,
      alignVertical: baseAlignV,
      alignHorizontal: alignH,
      sideOrientation
    });
  }
  var positions = [];
  var normals = [];
  var uvs = [];
  var indices = [];
  var colors = [];
  var facePositions = [];
  var faceNormals = [];
  var newFaceUV = [];
  var len = 0;
  var lu = 0;
  var li = 0;
  for (var f = 0; f < nbFaces; f++) {
    var len = faceVertexData[f].positions.length;
    facePositions[f] = [];
    faceNormals[f] = [];
    for (var p = 0; p < len / 3; p++) {
      facePositions[f].push(new Vector3(faceVertexData[f].positions[3 * p], faceVertexData[f].positions[3 * p + 1], faceVertexData[f].positions[3 * p + 2]));
      faceNormals[f].push(new Vector3(faceVertexData[f].normals[3 * p], faceVertexData[f].normals[3 * p + 1], faceVertexData[f].normals[3 * p + 2]));
    }
    lu = faceVertexData[f].uvs.length;
    newFaceUV[f] = [];
    for (var i = 0; i < lu; i += 2) {
      newFaceUV[f][i] = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * faceVertexData[f].uvs[i];
      newFaceUV[f][i + 1] = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * faceVertexData[f].uvs[i + 1];
    }
    uvs = uvs.concat(newFaceUV[f]);
    indices = indices.concat(faceVertexData[f].indices.map(function(x) {
      return x + li;
    }));
    li += facePositions[f].length;
    if (faceColors) {
      for (var c = 0; c < 4; c++) {
        colors.push(faceColors[f].r, faceColors[f].g, faceColors[f].b, faceColors[f].a);
      }
    }
  }
  var vec0 = new Vector3(0, 0, halfDepth);
  var mtrx0 = Matrix.RotationY(Math.PI);
  positions = facePositions[0].map(function(entry) {
    return Vector3.TransformNormal(entry, mtrx0).add(vec0);
  }).map(function(entry) {
    return [entry.x, entry.y, entry.z];
  }).reduce(function(accumulator, currentValue) {
    return accumulator.concat(currentValue);
  }, []);
  normals = faceNormals[0].map(function(entry) {
    return Vector3.TransformNormal(entry, mtrx0);
  }).map(function(entry) {
    return [entry.x, entry.y, entry.z];
  }).reduce(function(accumulator, currentValue) {
    return accumulator.concat(currentValue);
  }, []);
  positions = positions.concat(facePositions[1].map(function(entry) {
    return entry.subtract(vec0);
  }).map(function(entry) {
    return [entry.x, entry.y, entry.z];
  }).reduce(function(accumulator, currentValue) {
    return accumulator.concat(currentValue);
  }, []));
  normals = normals.concat(faceNormals[1].map(function(entry) {
    return [entry.x, entry.y, entry.z];
  }).reduce(function(accumulator, currentValue) {
    return accumulator.concat(currentValue);
  }, []));
  var vec2 = new Vector3(halfWidth, 0, 0);
  var mtrx2 = Matrix.RotationY(-Math.PI / 2);
  positions = positions.concat(facePositions[2].map(function(entry) {
    return Vector3.TransformNormal(entry, mtrx2).add(vec2);
  }).map(function(entry) {
    return [entry.x, entry.y, entry.z];
  }).reduce(function(accumulator, currentValue) {
    return accumulator.concat(currentValue);
  }, []));
  normals = normals.concat(faceNormals[2].map(function(entry) {
    return Vector3.TransformNormal(entry, mtrx2);
  }).map(function(entry) {
    return [entry.x, entry.y, entry.z];
  }).reduce(function(accumulator, currentValue) {
    return accumulator.concat(currentValue);
  }, []));
  var mtrx3 = Matrix.RotationY(Math.PI / 2);
  positions = positions.concat(facePositions[3].map(function(entry) {
    return Vector3.TransformNormal(entry, mtrx3).subtract(vec2);
  }).map(function(entry) {
    return [entry.x, entry.y, entry.z];
  }).reduce(function(accumulator, currentValue) {
    return accumulator.concat(currentValue);
  }, []));
  normals = normals.concat(faceNormals[3].map(function(entry) {
    return Vector3.TransformNormal(entry, mtrx3);
  }).map(function(entry) {
    return [entry.x, entry.y, entry.z];
  }).reduce(function(accumulator, currentValue) {
    return accumulator.concat(currentValue);
  }, []));
  var vec4 = new Vector3(0, halfHeight, 0);
  var mtrx4 = Matrix.RotationX(Math.PI / 2);
  positions = positions.concat(facePositions[4].map(function(entry) {
    return Vector3.TransformNormal(entry, mtrx4).add(vec4);
  }).map(function(entry) {
    return [entry.x, entry.y, entry.z];
  }).reduce(function(accumulator, currentValue) {
    return accumulator.concat(currentValue);
  }, []));
  normals = normals.concat(faceNormals[4].map(function(entry) {
    return Vector3.TransformNormal(entry, mtrx4);
  }).map(function(entry) {
    return [entry.x, entry.y, entry.z];
  }).reduce(function(accumulator, currentValue) {
    return accumulator.concat(currentValue);
  }, []));
  var mtrx5 = Matrix.RotationX(-Math.PI / 2);
  positions = positions.concat(facePositions[5].map(function(entry) {
    return Vector3.TransformNormal(entry, mtrx5).subtract(vec4);
  }).map(function(entry) {
    return [entry.x, entry.y, entry.z];
  }).reduce(function(accumulator, currentValue) {
    return accumulator.concat(currentValue);
  }, []));
  normals = normals.concat(faceNormals[5].map(function(entry) {
    return Vector3.TransformNormal(entry, mtrx5);
  }).map(function(entry) {
    return [entry.x, entry.y, entry.z];
  }).reduce(function(accumulator, currentValue) {
    return accumulator.concat(currentValue);
  }, []));
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs);
  var vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  if (faceColors) {
    var totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;
    vertexData.colors = totalColors;
  }
  return vertexData;
};
var TiledBoxBuilder = function() {
  function TiledBoxBuilder2() {
  }
  TiledBoxBuilder2.CreateTiledBox = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    var box = new Mesh(name98, scene);
    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
    box._originalBuilderSideOrientation = options.sideOrientation;
    var vertexData = VertexData.CreateTiledBox(options);
    vertexData.applyToMesh(box, options.updatable);
    return box;
  };
  return TiledBoxBuilder2;
}();

// node_modules/@babylonjs/core/Meshes/Builders/torusKnotBuilder.js
VertexData.CreateTorusKnot = function(options) {
  var indices = new Array();
  var positions = new Array();
  var normals = new Array();
  var uvs = new Array();
  var radius = options.radius || 2;
  var tube = options.tube || 0.5;
  var radialSegments = options.radialSegments || 32;
  var tubularSegments = options.tubularSegments || 32;
  var p = options.p || 2;
  var q = options.q || 3;
  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  var getPos = function(angle) {
    var cu = Math.cos(angle);
    var su = Math.sin(angle);
    var quOverP = q / p * angle;
    var cs = Math.cos(quOverP);
    var tx = radius * (2 + cs) * 0.5 * cu;
    var ty = radius * (2 + cs) * su * 0.5;
    var tz = radius * Math.sin(quOverP) * 0.5;
    return new Vector3(tx, ty, tz);
  };
  var i;
  var j;
  for (i = 0; i <= radialSegments; i++) {
    var modI = i % radialSegments;
    var u = modI / radialSegments * 2 * p * Math.PI;
    var p1 = getPos(u);
    var p2 = getPos(u + 0.01);
    var tang = p2.subtract(p1);
    var n = p2.add(p1);
    var bitan = Vector3.Cross(tang, n);
    n = Vector3.Cross(bitan, tang);
    bitan.normalize();
    n.normalize();
    for (j = 0; j < tubularSegments; j++) {
      var modJ = j % tubularSegments;
      var v = modJ / tubularSegments * 2 * Math.PI;
      var cx = -tube * Math.cos(v);
      var cy = tube * Math.sin(v);
      positions.push(p1.x + cx * n.x + cy * bitan.x);
      positions.push(p1.y + cx * n.y + cy * bitan.y);
      positions.push(p1.z + cx * n.z + cy * bitan.z);
      uvs.push(i / radialSegments);
      uvs.push(j / tubularSegments);
    }
  }
  for (i = 0; i < radialSegments; i++) {
    for (j = 0; j < tubularSegments; j++) {
      var jNext = (j + 1) % tubularSegments;
      var a = i * tubularSegments + j;
      var b = (i + 1) * tubularSegments + j;
      var c = (i + 1) * tubularSegments + jNext;
      var d = i * tubularSegments + jNext;
      indices.push(d);
      indices.push(b);
      indices.push(a);
      indices.push(d);
      indices.push(c);
      indices.push(b);
    }
  }
  VertexData.ComputeNormals(positions, indices, normals);
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  var vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
};
Mesh.CreateTorusKnot = function(name98, radius, tube, radialSegments, tubularSegments, p, q, scene, updatable, sideOrientation) {
  var options = {
    radius,
    tube,
    radialSegments,
    tubularSegments,
    p,
    q,
    sideOrientation,
    updatable
  };
  return TorusKnotBuilder.CreateTorusKnot(name98, options, scene);
};
var TorusKnotBuilder = function() {
  function TorusKnotBuilder2() {
  }
  TorusKnotBuilder2.CreateTorusKnot = function(name98, options, scene) {
    var torusKnot = new Mesh(name98, scene);
    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
    torusKnot._originalBuilderSideOrientation = options.sideOrientation;
    var vertexData = VertexData.CreateTorusKnot(options);
    vertexData.applyToMesh(torusKnot, options.updatable);
    return torusKnot;
  };
  return TorusKnotBuilder2;
}();

// node_modules/@babylonjs/core/Meshes/polygonMesh.js
var IndexedVector2 = function(_super) {
  __extends(IndexedVector22, _super);
  function IndexedVector22(original, index) {
    var _this = _super.call(this, original.x, original.y) || this;
    _this.index = index;
    return _this;
  }
  return IndexedVector22;
}(Vector2);
var PolygonPoints = function() {
  function PolygonPoints2() {
    this.elements = new Array();
  }
  PolygonPoints2.prototype.add = function(originalPoints) {
    var _this = this;
    var result = new Array();
    originalPoints.forEach(function(point) {
      var newPoint = new IndexedVector2(point, _this.elements.length);
      result.push(newPoint);
      _this.elements.push(newPoint);
    });
    return result;
  };
  PolygonPoints2.prototype.computeBounds = function() {
    var lmin = new Vector2(this.elements[0].x, this.elements[0].y);
    var lmax = new Vector2(this.elements[0].x, this.elements[0].y);
    this.elements.forEach(function(point) {
      if (point.x < lmin.x) {
        lmin.x = point.x;
      } else if (point.x > lmax.x) {
        lmax.x = point.x;
      }
      if (point.y < lmin.y) {
        lmin.y = point.y;
      } else if (point.y > lmax.y) {
        lmax.y = point.y;
      }
    });
    return {
      min: lmin,
      max: lmax,
      width: lmax.x - lmin.x,
      height: lmax.y - lmin.y
    };
  };
  return PolygonPoints2;
}();
var Polygon2 = function() {
  function Polygon3() {
  }
  Polygon3.Rectangle = function(xmin, ymin, xmax, ymax) {
    return [
      new Vector2(xmin, ymin),
      new Vector2(xmax, ymin),
      new Vector2(xmax, ymax),
      new Vector2(xmin, ymax)
    ];
  };
  Polygon3.Circle = function(radius, cx, cy, numberOfSides) {
    if (cx === void 0) {
      cx = 0;
    }
    if (cy === void 0) {
      cy = 0;
    }
    if (numberOfSides === void 0) {
      numberOfSides = 32;
    }
    var result = new Array();
    var angle = 0;
    var increment = Math.PI * 2 / numberOfSides;
    for (var i = 0; i < numberOfSides; i++) {
      result.push(new Vector2(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius));
      angle -= increment;
    }
    return result;
  };
  Polygon3.Parse = function(input) {
    var floats = input.split(/[^-+eE\.\d]+/).map(parseFloat).filter(function(val) {
      return !isNaN(val);
    });
    var i, result = [];
    for (i = 0; i < (floats.length & 2147483646); i += 2) {
      result.push(new Vector2(floats[i], floats[i + 1]));
    }
    return result;
  };
  Polygon3.StartingAt = function(x, y) {
    return Path2.StartingAt(x, y);
  };
  return Polygon3;
}();
var PolygonMeshBuilder = function() {
  function PolygonMeshBuilder2(name98, contours, scene, earcutInjection) {
    if (earcutInjection === void 0) {
      earcutInjection = earcut;
    }
    this._points = new PolygonPoints();
    this._outlinepoints = new PolygonPoints();
    this._holes = new Array();
    this._epoints = new Array();
    this._eholes = new Array();
    this.bjsEarcut = earcutInjection;
    this._name = name98;
    this._scene = scene || Engine.LastCreatedScene;
    var points;
    if (contours instanceof Path2) {
      points = contours.getPoints();
    } else {
      points = contours;
    }
    this._addToepoint(points);
    this._points.add(points);
    this._outlinepoints.add(points);
    if (typeof this.bjsEarcut === "undefined") {
      Logger.Warn("Earcut was not found, the polygon will not be built.");
    }
  }
  PolygonMeshBuilder2.prototype._addToepoint = function(points) {
    for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
      var p = points_1[_i];
      this._epoints.push(p.x, p.y);
    }
  };
  PolygonMeshBuilder2.prototype.addHole = function(hole) {
    this._points.add(hole);
    var holepoints = new PolygonPoints();
    holepoints.add(hole);
    this._holes.push(holepoints);
    this._eholes.push(this._epoints.length / 2);
    this._addToepoint(hole);
    return this;
  };
  PolygonMeshBuilder2.prototype.build = function(updatable, depth) {
    if (updatable === void 0) {
      updatable = false;
    }
    if (depth === void 0) {
      depth = 0;
    }
    var result = new Mesh(this._name, this._scene);
    var vertexData = this.buildVertexData(depth);
    result.setVerticesData(VertexBuffer.PositionKind, vertexData.positions, updatable);
    result.setVerticesData(VertexBuffer.NormalKind, vertexData.normals, updatable);
    result.setVerticesData(VertexBuffer.UVKind, vertexData.uvs, updatable);
    result.setIndices(vertexData.indices);
    return result;
  };
  PolygonMeshBuilder2.prototype.buildVertexData = function(depth) {
    var _this = this;
    if (depth === void 0) {
      depth = 0;
    }
    var result = new VertexData();
    var normals = new Array();
    var positions = new Array();
    var uvs = new Array();
    var bounds = this._points.computeBounds();
    this._points.elements.forEach(function(p) {
      normals.push(0, 1, 0);
      positions.push(p.x, 0, p.y);
      uvs.push((p.x - bounds.min.x) / bounds.width, (p.y - bounds.min.y) / bounds.height);
    });
    var indices = new Array();
    var res = this.bjsEarcut(this._epoints, this._eholes, 2);
    for (var i = 0; i < res.length; i++) {
      indices.push(res[i]);
    }
    if (depth > 0) {
      var positionscount = positions.length / 3;
      this._points.elements.forEach(function(p) {
        normals.push(0, -1, 0);
        positions.push(p.x, -depth, p.y);
        uvs.push(1 - (p.x - bounds.min.x) / bounds.width, 1 - (p.y - bounds.min.y) / bounds.height);
      });
      var totalCount = indices.length;
      for (var i = 0; i < totalCount; i += 3) {
        var i0 = indices[i + 0];
        var i1 = indices[i + 1];
        var i2 = indices[i + 2];
        indices.push(i2 + positionscount);
        indices.push(i1 + positionscount);
        indices.push(i0 + positionscount);
      }
      this.addSide(positions, normals, uvs, indices, bounds, this._outlinepoints, depth, false);
      this._holes.forEach(function(hole) {
        _this.addSide(positions, normals, uvs, indices, bounds, hole, depth, true);
      });
    }
    result.indices = indices;
    result.positions = positions;
    result.normals = normals;
    result.uvs = uvs;
    return result;
  };
  PolygonMeshBuilder2.prototype.addSide = function(positions, normals, uvs, indices, bounds, points, depth, flip) {
    var StartIndex = positions.length / 3;
    var ulength = 0;
    for (var i = 0; i < points.elements.length; i++) {
      var p = points.elements[i];
      var p1;
      if (i + 1 > points.elements.length - 1) {
        p1 = points.elements[0];
      } else {
        p1 = points.elements[i + 1];
      }
      positions.push(p.x, 0, p.y);
      positions.push(p.x, -depth, p.y);
      positions.push(p1.x, 0, p1.y);
      positions.push(p1.x, -depth, p1.y);
      var v1 = new Vector3(p.x, 0, p.y);
      var v2 = new Vector3(p1.x, 0, p1.y);
      var v3 = v2.subtract(v1);
      var v4 = new Vector3(0, 1, 0);
      var vn = Vector3.Cross(v3, v4);
      vn = vn.normalize();
      uvs.push(ulength / bounds.width, 0);
      uvs.push(ulength / bounds.width, 1);
      ulength += v3.length();
      uvs.push(ulength / bounds.width, 0);
      uvs.push(ulength / bounds.width, 1);
      if (!flip) {
        normals.push(-vn.x, -vn.y, -vn.z);
        normals.push(-vn.x, -vn.y, -vn.z);
        normals.push(-vn.x, -vn.y, -vn.z);
        normals.push(-vn.x, -vn.y, -vn.z);
        indices.push(StartIndex);
        indices.push(StartIndex + 1);
        indices.push(StartIndex + 2);
        indices.push(StartIndex + 1);
        indices.push(StartIndex + 3);
        indices.push(StartIndex + 2);
      } else {
        normals.push(vn.x, vn.y, vn.z);
        normals.push(vn.x, vn.y, vn.z);
        normals.push(vn.x, vn.y, vn.z);
        normals.push(vn.x, vn.y, vn.z);
        indices.push(StartIndex);
        indices.push(StartIndex + 2);
        indices.push(StartIndex + 1);
        indices.push(StartIndex + 1);
        indices.push(StartIndex + 2);
        indices.push(StartIndex + 3);
      }
      StartIndex += 4;
    }
  };
  return PolygonMeshBuilder2;
}();

// node_modules/@babylonjs/core/Meshes/Builders/polygonBuilder.js
VertexData.CreatePolygon = function(polygon, sideOrientation, fUV, fColors, frontUVs, backUVs, wrp) {
  var faceUV = fUV || new Array(3);
  var faceColors = fColors;
  var colors = [];
  var wrap = wrp || false;
  for (var f = 0; f < 3; f++) {
    if (faceUV[f] === void 0) {
      faceUV[f] = new Vector4(0, 0, 1, 1);
    }
    if (faceColors && faceColors[f] === void 0) {
      faceColors[f] = new Color4(1, 1, 1, 1);
    }
  }
  var positions = polygon.getVerticesData(VertexBuffer.PositionKind);
  var normals = polygon.getVerticesData(VertexBuffer.NormalKind);
  var uvs = polygon.getVerticesData(VertexBuffer.UVKind);
  var indices = polygon.getIndices();
  var startIndex = positions.length / 9;
  var disp = 0;
  var distX = 0;
  var distZ = 0;
  var dist = 0;
  var totalLen = 0;
  var cumulate = [0];
  if (wrap) {
    for (var idx = startIndex; idx < positions.length / 3; idx += 4) {
      distX = positions[3 * (idx + 2)] - positions[3 * idx];
      distZ = positions[3 * (idx + 2) + 2] - positions[3 * idx + 2];
      dist = Math.sqrt(distX * distX + distZ * distZ);
      totalLen += dist;
      cumulate.push(totalLen);
    }
  }
  var idx = 0;
  var face = 0;
  for (var index = 0; index < normals.length; index += 3) {
    if (Math.abs(normals[index + 1]) < 1e-3) {
      face = 1;
    }
    if (Math.abs(normals[index + 1] - 1) < 1e-3) {
      face = 0;
    }
    if (Math.abs(normals[index + 1] + 1) < 1e-3) {
      face = 2;
    }
    idx = index / 3;
    if (face === 1) {
      disp = idx - startIndex;
      if (disp % 4 < 1.5) {
        if (wrap) {
          uvs[2 * idx] = faceUV[face].x + (faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4)] / totalLen;
        } else {
          uvs[2 * idx] = faceUV[face].x;
        }
      } else {
        if (wrap) {
          uvs[2 * idx] = faceUV[face].x + (faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4) + 1] / totalLen;
        } else {
          uvs[2 * idx] = faceUV[face].z;
        }
      }
      if (disp % 2 === 0) {
        uvs[2 * idx + 1] = faceUV[face].w;
      } else {
        uvs[2 * idx + 1] = faceUV[face].y;
      }
    } else {
      uvs[2 * idx] = (1 - uvs[2 * idx]) * faceUV[face].x + uvs[2 * idx] * faceUV[face].z;
      uvs[2 * idx + 1] = (1 - uvs[2 * idx + 1]) * faceUV[face].y + uvs[2 * idx + 1] * faceUV[face].w;
    }
    if (faceColors) {
      colors.push(faceColors[face].r, faceColors[face].g, faceColors[face].b, faceColors[face].a);
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs);
  var vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  if (faceColors) {
    var totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;
    vertexData.colors = totalColors;
  }
  return vertexData;
};
Mesh.CreatePolygon = function(name98, shape, scene, holes, updatable, sideOrientation, earcutInjection) {
  if (earcutInjection === void 0) {
    earcutInjection = earcut;
  }
  var options = {
    shape,
    holes,
    updatable,
    sideOrientation
  };
  return PolygonBuilder.CreatePolygon(name98, options, scene, earcutInjection);
};
Mesh.ExtrudePolygon = function(name98, shape, depth, scene, holes, updatable, sideOrientation, earcutInjection) {
  if (earcutInjection === void 0) {
    earcutInjection = earcut;
  }
  var options = {
    shape,
    holes,
    depth,
    updatable,
    sideOrientation
  };
  return PolygonBuilder.ExtrudePolygon(name98, options, scene, earcutInjection);
};
var PolygonBuilder = function() {
  function PolygonBuilder2() {
  }
  PolygonBuilder2.CreatePolygon = function(name98, options, scene, earcutInjection) {
    if (scene === void 0) {
      scene = null;
    }
    if (earcutInjection === void 0) {
      earcutInjection = earcut;
    }
    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
    var shape = options.shape;
    var holes = options.holes || [];
    var depth = options.depth || 0;
    var contours = [];
    var hole = [];
    for (var i = 0; i < shape.length; i++) {
      contours[i] = new Vector2(shape[i].x, shape[i].z);
    }
    var epsilon = 1e-8;
    if (contours[0].equalsWithEpsilon(contours[contours.length - 1], epsilon)) {
      contours.pop();
    }
    var polygonTriangulation = new PolygonMeshBuilder(name98, contours, scene || EngineStore.LastCreatedScene, earcutInjection);
    for (var hNb = 0; hNb < holes.length; hNb++) {
      hole = [];
      for (var hPoint = 0; hPoint < holes[hNb].length; hPoint++) {
        hole.push(new Vector2(holes[hNb][hPoint].x, holes[hNb][hPoint].z));
      }
      polygonTriangulation.addHole(hole);
    }
    var polygon = polygonTriangulation.build(options.updatable, depth);
    polygon._originalBuilderSideOrientation = options.sideOrientation;
    var vertexData = VertexData.CreatePolygon(polygon, options.sideOrientation, options.faceUV, options.faceColors, options.frontUVs, options.backUVs, options.wrap);
    vertexData.applyToMesh(polygon, options.updatable);
    return polygon;
  };
  PolygonBuilder2.ExtrudePolygon = function(name98, options, scene, earcutInjection) {
    if (scene === void 0) {
      scene = null;
    }
    if (earcutInjection === void 0) {
      earcutInjection = earcut;
    }
    return PolygonBuilder2.CreatePolygon(name98, options, scene, earcutInjection);
  };
  return PolygonBuilder2;
}();

// node_modules/@babylonjs/core/Meshes/Builders/latheBuilder.js
Mesh.CreateLathe = function(name98, shape, radius, tessellation, scene, updatable, sideOrientation) {
  var options = {
    shape,
    radius,
    tessellation,
    sideOrientation,
    updatable
  };
  return LatheBuilder.CreateLathe(name98, options, scene);
};
var LatheBuilder = function() {
  function LatheBuilder2() {
  }
  LatheBuilder2.CreateLathe = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    var arc = options.arc ? options.arc <= 0 || options.arc > 1 ? 1 : options.arc : 1;
    var closed = options.closed === void 0 ? true : options.closed;
    var shape = options.shape;
    var radius = options.radius || 1;
    var tessellation = options.tessellation || 64;
    var clip = options.clip || 0;
    var updatable = options.updatable;
    var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
    var cap = options.cap || Mesh.NO_CAP;
    var pi2 = Math.PI * 2;
    var paths = new Array();
    var invertUV = options.invertUV || false;
    var i = 0;
    var p = 0;
    var step = pi2 / tessellation * arc;
    var rotated;
    var path = new Array();
    for (i = 0; i <= tessellation - clip; i++) {
      var path = [];
      if (cap == Mesh.CAP_START || cap == Mesh.CAP_ALL) {
        path.push(new Vector3(0, shape[0].y, 0));
        path.push(new Vector3(Math.cos(i * step) * shape[0].x * radius, shape[0].y, Math.sin(i * step) * shape[0].x * radius));
      }
      for (p = 0; p < shape.length; p++) {
        rotated = new Vector3(Math.cos(i * step) * shape[p].x * radius, shape[p].y, Math.sin(i * step) * shape[p].x * radius);
        path.push(rotated);
      }
      if (cap == Mesh.CAP_END || cap == Mesh.CAP_ALL) {
        path.push(new Vector3(Math.cos(i * step) * shape[shape.length - 1].x * radius, shape[shape.length - 1].y, Math.sin(i * step) * shape[shape.length - 1].x * radius));
        path.push(new Vector3(0, shape[shape.length - 1].y, 0));
      }
      paths.push(path);
    }
    var lathe = RibbonBuilder.CreateRibbon(name98, { pathArray: paths, closeArray: closed, sideOrientation, updatable, invertUV, frontUVs: options.frontUVs, backUVs: options.backUVs }, scene);
    return lathe;
  };
  return LatheBuilder2;
}();

// node_modules/@babylonjs/core/Meshes/Builders/tiledPlaneBuilder.js
VertexData.CreateTiledPlane = function(options) {
  var flipTile = options.pattern || Mesh.NO_FLIP;
  var tileWidth = options.tileWidth || options.tileSize || 1;
  var tileHeight = options.tileHeight || options.tileSize || 1;
  var alignH = options.alignHorizontal || 0;
  var alignV = options.alignVertical || 0;
  var width = options.width || options.size || 1;
  var tilesX = Math.floor(width / tileWidth);
  var offsetX = width - tilesX * tileWidth;
  var height = options.height || options.size || 1;
  var tilesY = Math.floor(height / tileHeight);
  var offsetY = height - tilesY * tileHeight;
  var halfWidth = tileWidth * tilesX / 2;
  var halfHeight = tileHeight * tilesY / 2;
  var adjustX = 0;
  var adjustY = 0;
  var startX = 0;
  var startY = 0;
  var endX = 0;
  var endY = 0;
  if (offsetX > 0 || offsetY > 0) {
    startX = -halfWidth;
    startY = -halfHeight;
    var endX = halfWidth;
    var endY = halfHeight;
    switch (alignH) {
      case Mesh.CENTER:
        offsetX /= 2;
        startX -= offsetX;
        endX += offsetX;
        break;
      case Mesh.LEFT:
        endX += offsetX;
        adjustX = -offsetX / 2;
        break;
      case Mesh.RIGHT:
        startX -= offsetX;
        adjustX = offsetX / 2;
        break;
    }
    switch (alignV) {
      case Mesh.CENTER:
        offsetY /= 2;
        startY -= offsetY;
        endY += offsetY;
        break;
      case Mesh.BOTTOM:
        endY += offsetY;
        adjustY = -offsetY / 2;
        break;
      case Mesh.TOP:
        startY -= offsetY;
        adjustY = offsetY / 2;
        break;
    }
  }
  var positions = [];
  var normals = [];
  var uvBase = [];
  uvBase[0] = [0, 0, 1, 0, 1, 1, 0, 1];
  uvBase[1] = [0, 0, 1, 0, 1, 1, 0, 1];
  if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {
    uvBase[1] = [1, 1, 0, 1, 0, 0, 1, 0];
  }
  if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {
    uvBase[1] = [1, 0, 0, 0, 0, 1, 1, 1];
  }
  if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
    uvBase[1] = [0, 1, 1, 1, 1, 0, 0, 0];
  }
  var uvs = [];
  var colors = [];
  var indices = [];
  var index = 0;
  for (var y = 0; y < tilesY; y++) {
    for (var x = 0; x < tilesX; x++) {
      positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);
      positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);
      positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);
      positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);
      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {
        uvs = uvs.concat(uvBase[(x % 2 + y % 2) % 2]);
      } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
        uvs = uvs.concat(uvBase[y % 2]);
      } else {
        uvs = uvs.concat(uvBase[0]);
      }
      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
      index += 4;
    }
  }
  if (offsetX > 0 || offsetY > 0) {
    var partialBottomRow = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.TOP);
    var partialTopRow = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.BOTTOM);
    var partialLeftCol = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.RIGHT);
    var partialRightCol = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.LEFT);
    var uvPart = [];
    var a, b, c, d;
    if (partialBottomRow && partialLeftCol) {
      positions.push(startX + adjustX, startY + adjustY, 0);
      positions.push(-halfWidth + adjustX, startY + adjustY, 0);
      positions.push(-halfWidth + adjustX, startY + offsetY + adjustY, 0);
      positions.push(startX + adjustX, startY + offsetY + adjustY, 0);
      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
      index += 4;
      a = 1 - offsetX / tileWidth;
      b = 1 - offsetY / tileHeight;
      c = 1;
      d = 1;
      uvPart = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_ROW) {
        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_ROW) {
        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_ROW) {
        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      uvs = uvs.concat(uvPart);
      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
    }
    if (partialBottomRow && partialRightCol) {
      positions.push(halfWidth + adjustX, startY + adjustY, 0);
      positions.push(endX + adjustX, startY + adjustY, 0);
      positions.push(endX + adjustX, startY + offsetY + adjustY, 0);
      positions.push(halfWidth + adjustX, startY + offsetY + adjustY, 0);
      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
      index += 4;
      a = 0;
      b = 1 - offsetY / tileHeight;
      c = offsetX / tileWidth;
      d = 1;
      uvPart = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.ROTATE_TILE && tilesX % 2 === 0) {
        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.FLIP_TILE && tilesX % 2 === 0) {
        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesX % 2 === 0) {
        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      uvs = uvs.concat(uvPart);
      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
    }
    if (partialTopRow && partialLeftCol) {
      positions.push(startX + adjustX, halfHeight + adjustY, 0);
      positions.push(-halfWidth + adjustX, halfHeight + adjustY, 0);
      positions.push(-halfWidth + adjustX, endY + adjustY, 0);
      positions.push(startX + adjustX, endY + adjustY, 0);
      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
      index += 4;
      a = 1 - offsetX / tileWidth;
      b = 0;
      c = 1;
      d = offsetY / tileHeight;
      uvPart = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.ROTATE_TILE && tilesY % 1 === 0) {
        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_TILE && tilesY % 2 === 0) {
        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesY % 2 === 0) {
        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      uvs = uvs.concat(uvPart);
      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
    }
    if (partialTopRow && partialRightCol) {
      positions.push(halfWidth + adjustX, halfHeight + adjustY, 0);
      positions.push(endX + adjustX, halfHeight + adjustY, 0);
      positions.push(endX + adjustX, endY + adjustY, 0);
      positions.push(halfWidth + adjustX, endY + adjustY, 0);
      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
      index += 4;
      a = 0;
      b = 0;
      c = offsetX / tileWidth;
      d = offsetY / tileHeight;
      uvPart = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.ROTATE_TILE && (tilesY + tilesX) % 2 === 1) {
        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_TILE && (tilesY + tilesX) % 2 === 1) {
        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_N_ROTATE_TILE && (tilesY + tilesX) % 2 === 1) {
        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      uvs = uvs.concat(uvPart);
      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
    }
    if (partialBottomRow) {
      var uvBaseBR = [];
      a = 0;
      b = 1 - offsetY / tileHeight;
      c = 1;
      d = 1;
      uvBaseBR[0] = [a, b, c, b, c, d, a, d];
      uvBaseBR[1] = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {
        uvBaseBR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {
        uvBaseBR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
        uvBaseBR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      for (var x = 0; x < tilesX; x++) {
        positions.push(-halfWidth + x * tileWidth + adjustX, startY + adjustY, 0);
        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + adjustY, 0);
        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + offsetY + adjustY, 0);
        positions.push(-halfWidth + x * tileWidth + adjustX, startY + offsetY + adjustY, 0);
        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
        index += 4;
        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {
          uvs = uvs.concat(uvBaseBR[(x + 1) % 2]);
        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
          uvs = uvs.concat(uvBaseBR[1]);
        } else {
          uvs = uvs.concat(uvBaseBR[0]);
        }
        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
      }
    }
    if (partialTopRow) {
      var uvBaseTR = [];
      a = 0;
      b = 0;
      c = 1;
      d = offsetY / tileHeight;
      uvBaseTR[0] = [a, b, c, b, c, d, a, d];
      uvBaseTR[1] = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {
        uvBaseTR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {
        uvBaseTR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
        uvBaseTR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      for (var x = 0; x < tilesX; x++) {
        positions.push(-halfWidth + x * tileWidth + adjustX, endY - offsetY + adjustY, 0);
        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY - offsetY + adjustY, 0);
        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY + adjustY, 0);
        positions.push(-halfWidth + x * tileWidth + adjustX, endY + adjustY, 0);
        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
        index += 4;
        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {
          uvs = uvs.concat(uvBaseTR[(x + tilesY) % 2]);
        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
          uvs = uvs.concat(uvBaseTR[tilesY % 2]);
        } else {
          uvs = uvs.concat(uvBaseTR[0]);
        }
        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
      }
    }
    if (partialLeftCol) {
      var uvBaseLC = [];
      a = 1 - offsetX / tileWidth;
      b = 0;
      c = 1;
      d = 1;
      uvBaseLC[0] = [a, b, c, b, c, d, a, d];
      uvBaseLC[1] = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {
        uvBaseLC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {
        uvBaseLC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
        uvBaseLC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      for (var y = 0; y < tilesY; y++) {
        positions.push(startX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);
        positions.push(startX + offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);
        positions.push(startX + offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);
        positions.push(startX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);
        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
        index += 4;
        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {
          uvs = uvs.concat(uvBaseLC[(y + 1) % 2]);
        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
          uvs = uvs.concat(uvBaseLC[y % 2]);
        } else {
          uvs = uvs.concat(uvBaseLC[0]);
        }
        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
      }
    }
    if (partialRightCol) {
      var uvBaseRC = [];
      a = 0;
      b = 0;
      c = offsetX / tileHeight;
      d = 1;
      uvBaseRC[0] = [a, b, c, b, c, d, a, d];
      uvBaseRC[1] = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {
        uvBaseRC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {
        uvBaseRC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
        uvBaseRC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      for (var y = 0; y < tilesY; y++) {
        positions.push(endX - offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);
        positions.push(endX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);
        positions.push(endX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);
        positions.push(endX - offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);
        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
        index += 4;
        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {
          uvs = uvs.concat(uvBaseRC[(y + tilesX) % 2]);
        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
          uvs = uvs.concat(uvBaseRC[y % 2]);
        } else {
          uvs = uvs.concat(uvBaseRC[0]);
        }
        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
      }
    }
  }
  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  var vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  var totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;
  vertexData.colors = totalColors;
  return vertexData;
};
var TiledPlaneBuilder = function() {
  function TiledPlaneBuilder2() {
  }
  TiledPlaneBuilder2.CreateTiledPlane = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    var plane = new Mesh(name98, scene);
    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
    plane._originalBuilderSideOrientation = options.sideOrientation;
    var vertexData = VertexData.CreateTiledPlane(options);
    vertexData.applyToMesh(plane, options.updatable);
    return plane;
  };
  return TiledPlaneBuilder2;
}();

// node_modules/@babylonjs/core/Meshes/Builders/tubeBuilder.js
Mesh.CreateTube = function(name98, path, radius, tessellation, radiusFunction, cap, scene, updatable, sideOrientation, instance) {
  var options = {
    path,
    radius,
    tessellation,
    radiusFunction,
    arc: 1,
    cap,
    updatable,
    sideOrientation,
    instance
  };
  return TubeBuilder.CreateTube(name98, options, scene);
};
var TubeBuilder = function() {
  function TubeBuilder2() {
  }
  TubeBuilder2.CreateTube = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    var path = options.path;
    var instance = options.instance;
    var radius = 1;
    if (options.radius !== void 0) {
      radius = options.radius;
    } else if (instance) {
      radius = instance._creationDataStorage.radius;
    }
    var tessellation = options.tessellation || 64 | 0;
    var radiusFunction = options.radiusFunction || null;
    var cap = options.cap || Mesh.NO_CAP;
    var invertUV = options.invertUV || false;
    var updatable = options.updatable;
    var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
    options.arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1 : options.arc || 1;
    var tubePathArray = function(path2, path3D2, circlePaths, radius2, tessellation2, radiusFunction2, cap2, arc2) {
      var tangents = path3D2.getTangents();
      var normals = path3D2.getNormals();
      var distances = path3D2.getDistances();
      var pi2 = Math.PI * 2;
      var step = pi2 / tessellation2 * arc2;
      var returnRadius = function() {
        return radius2;
      };
      var radiusFunctionFinal = radiusFunction2 || returnRadius;
      var circlePath;
      var rad;
      var normal;
      var rotated;
      var rotationMatrix = TmpVectors.Matrix[0];
      var index = cap2 === Mesh.NO_CAP || cap2 === Mesh.CAP_END ? 0 : 2;
      for (var i = 0; i < path2.length; i++) {
        rad = radiusFunctionFinal(i, distances[i]);
        circlePath = Array();
        normal = normals[i];
        for (var t = 0; t < tessellation2; t++) {
          Matrix.RotationAxisToRef(tangents[i], step * t, rotationMatrix);
          rotated = circlePath[t] ? circlePath[t] : Vector3.Zero();
          Vector3.TransformCoordinatesToRef(normal, rotationMatrix, rotated);
          rotated.scaleInPlace(rad).addInPlace(path2[i]);
          circlePath[t] = rotated;
        }
        circlePaths[index] = circlePath;
        index++;
      }
      var capPath = function(nbPoints, pathIndex) {
        var pointCap = Array();
        for (var i2 = 0; i2 < nbPoints; i2++) {
          pointCap.push(path2[pathIndex]);
        }
        return pointCap;
      };
      switch (cap2) {
        case Mesh.NO_CAP:
          break;
        case Mesh.CAP_START:
          circlePaths[0] = capPath(tessellation2, 0);
          circlePaths[1] = circlePaths[2].slice(0);
          break;
        case Mesh.CAP_END:
          circlePaths[index] = circlePaths[index - 1].slice(0);
          circlePaths[index + 1] = capPath(tessellation2, path2.length - 1);
          break;
        case Mesh.CAP_ALL:
          circlePaths[0] = capPath(tessellation2, 0);
          circlePaths[1] = circlePaths[2].slice(0);
          circlePaths[index] = circlePaths[index - 1].slice(0);
          circlePaths[index + 1] = capPath(tessellation2, path2.length - 1);
          break;
        default:
          break;
      }
      return circlePaths;
    };
    var path3D;
    var pathArray;
    if (instance) {
      var storage = instance._creationDataStorage;
      var arc = options.arc || storage.arc;
      path3D = storage.path3D.update(path);
      pathArray = tubePathArray(path, path3D, storage.pathArray, radius, storage.tessellation, radiusFunction, storage.cap, arc);
      instance = RibbonBuilder.CreateRibbon("", { pathArray, instance });
      storage.path3D = path3D;
      storage.pathArray = pathArray;
      storage.arc = arc;
      storage.radius = radius;
      return instance;
    }
    path3D = new Path3D(path);
    var newPathArray = new Array();
    cap = cap < 0 || cap > 3 ? 0 : cap;
    pathArray = tubePathArray(path, path3D, newPathArray, radius, tessellation, radiusFunction, cap, options.arc);
    var tube = RibbonBuilder.CreateRibbon(name98, { pathArray, closePath: true, closeArray: false, updatable, sideOrientation, invertUV, frontUVs: options.frontUVs, backUVs: options.backUVs }, scene);
    tube._creationDataStorage.pathArray = pathArray;
    tube._creationDataStorage.path3D = path3D;
    tube._creationDataStorage.tessellation = tessellation;
    tube._creationDataStorage.cap = cap;
    tube._creationDataStorage.arc = options.arc;
    tube._creationDataStorage.radius = radius;
    return tube;
  };
  return TubeBuilder2;
}();

// node_modules/@babylonjs/core/Meshes/Builders/icoSphereBuilder.js
VertexData.CreateIcoSphere = function(options) {
  var sideOrientation = options.sideOrientation || VertexData.DEFAULTSIDE;
  var radius = options.radius || 1;
  var flat = options.flat === void 0 ? true : options.flat;
  var subdivisions = options.subdivisions || 4;
  var radiusX = options.radiusX || radius;
  var radiusY = options.radiusY || radius;
  var radiusZ = options.radiusZ || radius;
  var t = (1 + Math.sqrt(5)) / 2;
  var ico_vertices = [
    -1,
    t,
    -0,
    1,
    t,
    0,
    -1,
    -t,
    0,
    1,
    -t,
    0,
    0,
    -1,
    -t,
    0,
    1,
    -t,
    0,
    -1,
    t,
    0,
    1,
    t,
    t,
    0,
    1,
    t,
    0,
    -1,
    -t,
    0,
    1,
    -t,
    0,
    -1
  ];
  var ico_indices = [
    0,
    11,
    5,
    0,
    5,
    1,
    0,
    1,
    7,
    0,
    7,
    10,
    12,
    22,
    23,
    1,
    5,
    20,
    5,
    11,
    4,
    23,
    22,
    13,
    22,
    18,
    6,
    7,
    1,
    8,
    14,
    21,
    4,
    14,
    4,
    2,
    16,
    13,
    6,
    15,
    6,
    19,
    3,
    8,
    9,
    4,
    21,
    5,
    13,
    17,
    23,
    6,
    13,
    22,
    19,
    6,
    18,
    9,
    8,
    1
  ];
  var vertices_unalias_id = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    0,
    2,
    3,
    3,
    3,
    4,
    7,
    8,
    9,
    9,
    10,
    11
  ];
  var ico_vertexuv = [
    5,
    1,
    3,
    1,
    6,
    4,
    0,
    0,
    5,
    3,
    4,
    2,
    2,
    2,
    4,
    0,
    2,
    0,
    1,
    1,
    6,
    0,
    6,
    2,
    0,
    4,
    3,
    3,
    4,
    4,
    3,
    1,
    4,
    2,
    4,
    4,
    0,
    2,
    1,
    1,
    2,
    2,
    3,
    3,
    1,
    3,
    2,
    4
  ];
  var ustep = 138 / 1024;
  var vstep = 239 / 1024;
  var uoffset = 60 / 1024;
  var voffset = 26 / 1024;
  var island_u_offset = -40 / 1024;
  var island_v_offset = 20 / 1024;
  var island = [
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    1,
    0
  ];
  var indices = new Array();
  var positions = new Array();
  var normals = new Array();
  var uvs = new Array();
  var current_indice = 0;
  var face_vertex_pos = new Array(3);
  var face_vertex_uv = new Array(3);
  var v012;
  for (v012 = 0; v012 < 3; v012++) {
    face_vertex_pos[v012] = Vector3.Zero();
    face_vertex_uv[v012] = Vector2.Zero();
  }
  for (var face = 0; face < 20; face++) {
    for (v012 = 0; v012 < 3; v012++) {
      var v_id = ico_indices[3 * face + v012];
      face_vertex_pos[v012].copyFromFloats(ico_vertices[3 * vertices_unalias_id[v_id]], ico_vertices[3 * vertices_unalias_id[v_id] + 1], ico_vertices[3 * vertices_unalias_id[v_id] + 2]);
      face_vertex_pos[v012].normalize().scaleInPlace(radius);
      face_vertex_uv[v012].copyFromFloats(ico_vertexuv[2 * v_id] * ustep + uoffset + island[face] * island_u_offset, ico_vertexuv[2 * v_id + 1] * vstep + voffset + island[face] * island_v_offset);
    }
    var interp_vertex = function(i12, i22, c1, c2) {
      var pos_x0 = Vector3.Lerp(face_vertex_pos[0], face_vertex_pos[2], i22 / subdivisions);
      var pos_x1 = Vector3.Lerp(face_vertex_pos[1], face_vertex_pos[2], i22 / subdivisions);
      var pos_interp = subdivisions === i22 ? face_vertex_pos[2] : Vector3.Lerp(pos_x0, pos_x1, i12 / (subdivisions - i22));
      pos_interp.normalize();
      var vertex_normal;
      if (flat) {
        var centroid_x0 = Vector3.Lerp(face_vertex_pos[0], face_vertex_pos[2], c2 / subdivisions);
        var centroid_x1 = Vector3.Lerp(face_vertex_pos[1], face_vertex_pos[2], c2 / subdivisions);
        vertex_normal = Vector3.Lerp(centroid_x0, centroid_x1, c1 / (subdivisions - c2));
      } else {
        vertex_normal = new Vector3(pos_interp.x, pos_interp.y, pos_interp.z);
      }
      vertex_normal.x /= radiusX;
      vertex_normal.y /= radiusY;
      vertex_normal.z /= radiusZ;
      vertex_normal.normalize();
      var uv_x0 = Vector2.Lerp(face_vertex_uv[0], face_vertex_uv[2], i22 / subdivisions);
      var uv_x1 = Vector2.Lerp(face_vertex_uv[1], face_vertex_uv[2], i22 / subdivisions);
      var uv_interp = subdivisions === i22 ? face_vertex_uv[2] : Vector2.Lerp(uv_x0, uv_x1, i12 / (subdivisions - i22));
      positions.push(pos_interp.x * radiusX, pos_interp.y * radiusY, pos_interp.z * radiusZ);
      normals.push(vertex_normal.x, vertex_normal.y, vertex_normal.z);
      uvs.push(uv_interp.x, uv_interp.y);
      indices.push(current_indice);
      current_indice++;
    };
    for (var i2 = 0; i2 < subdivisions; i2++) {
      for (var i1 = 0; i1 + i2 < subdivisions; i1++) {
        interp_vertex(i1, i2, i1 + 1 / 3, i2 + 1 / 3);
        interp_vertex(i1 + 1, i2, i1 + 1 / 3, i2 + 1 / 3);
        interp_vertex(i1, i2 + 1, i1 + 1 / 3, i2 + 1 / 3);
        if (i1 + i2 + 1 < subdivisions) {
          interp_vertex(i1 + 1, i2, i1 + 2 / 3, i2 + 2 / 3);
          interp_vertex(i1 + 1, i2 + 1, i1 + 2 / 3, i2 + 2 / 3);
          interp_vertex(i1, i2 + 1, i1 + 2 / 3, i2 + 2 / 3);
        }
      }
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  var vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
};
Mesh.CreateIcoSphere = function(name98, options, scene) {
  return IcoSphereBuilder.CreateIcoSphere(name98, options, scene);
};
var IcoSphereBuilder = function() {
  function IcoSphereBuilder2() {
  }
  IcoSphereBuilder2.CreateIcoSphere = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    var sphere = new Mesh(name98, scene);
    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
    sphere._originalBuilderSideOrientation = options.sideOrientation;
    var vertexData = VertexData.CreateIcoSphere(options);
    vertexData.applyToMesh(sphere, options.updatable);
    return sphere;
  };
  return IcoSphereBuilder2;
}();

// node_modules/@babylonjs/core/Meshes/Builders/decalBuilder.js
Mesh.CreateDecal = function(name98, sourceMesh, position, normal, size, angle) {
  var options = {
    position,
    normal,
    size,
    angle
  };
  return DecalBuilder.CreateDecal(name98, sourceMesh, options);
};
var DecalBuilder = function() {
  function DecalBuilder2() {
  }
  DecalBuilder2.CreateDecal = function(name98, sourceMesh, options) {
    var indices = sourceMesh.getIndices();
    var positions = sourceMesh.getVerticesData(VertexBuffer.PositionKind);
    var normals = sourceMesh.getVerticesData(VertexBuffer.NormalKind);
    var position = options.position || Vector3.Zero();
    var normal = options.normal || Vector3.Up();
    var size = options.size || Vector3.One();
    var angle = options.angle || 0;
    if (!normal) {
      var target = new Vector3(0, 0, 1);
      var camera = sourceMesh.getScene().activeCamera;
      var cameraWorldTarget = Vector3.TransformCoordinates(target, camera.getWorldMatrix());
      normal = camera.globalPosition.subtract(cameraWorldTarget);
    }
    var yaw = -Math.atan2(normal.z, normal.x) - Math.PI / 2;
    var len = Math.sqrt(normal.x * normal.x + normal.z * normal.z);
    var pitch = Math.atan2(normal.y, len);
    var decalWorldMatrix = Matrix.RotationYawPitchRoll(yaw, pitch, angle).multiply(Matrix.Translation(position.x, position.y, position.z));
    var inverseDecalWorldMatrix = Matrix.Invert(decalWorldMatrix);
    var meshWorldMatrix = sourceMesh.getWorldMatrix();
    var transformMatrix = meshWorldMatrix.multiply(inverseDecalWorldMatrix);
    var vertexData = new VertexData();
    vertexData.indices = [];
    vertexData.positions = [];
    vertexData.normals = [];
    vertexData.uvs = [];
    var currentVertexDataIndex = 0;
    var extractDecalVector3 = function(indexId) {
      var result = new PositionNormalVertex();
      if (!indices || !positions || !normals) {
        return result;
      }
      var vertexId = indices[indexId];
      result.position = new Vector3(positions[vertexId * 3], positions[vertexId * 3 + 1], positions[vertexId * 3 + 2]);
      result.position = Vector3.TransformCoordinates(result.position, transformMatrix);
      result.normal = new Vector3(normals[vertexId * 3], normals[vertexId * 3 + 1], normals[vertexId * 3 + 2]);
      result.normal = Vector3.TransformNormal(result.normal, transformMatrix);
      return result;
    };
    var clip = function(vertices, axis) {
      if (vertices.length === 0) {
        return vertices;
      }
      var clipSize = 0.5 * Math.abs(Vector3.Dot(size, axis));
      var clipVertices = function(v0, v1) {
        var clipFactor = Vector3.GetClipFactor(v0.position, v1.position, axis, clipSize);
        return new PositionNormalVertex(Vector3.Lerp(v0.position, v1.position, clipFactor), Vector3.Lerp(v0.normal, v1.normal, clipFactor));
      };
      var result = new Array();
      for (var index2 = 0; index2 < vertices.length; index2 += 3) {
        var v1Out;
        var v2Out;
        var v3Out;
        var total = 0;
        var nV1 = null;
        var nV2 = null;
        var nV3 = null;
        var nV4 = null;
        var d1 = Vector3.Dot(vertices[index2].position, axis) - clipSize;
        var d2 = Vector3.Dot(vertices[index2 + 1].position, axis) - clipSize;
        var d3 = Vector3.Dot(vertices[index2 + 2].position, axis) - clipSize;
        v1Out = d1 > 0;
        v2Out = d2 > 0;
        v3Out = d3 > 0;
        total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);
        switch (total) {
          case 0:
            result.push(vertices[index2]);
            result.push(vertices[index2 + 1]);
            result.push(vertices[index2 + 2]);
            break;
          case 1:
            if (v1Out) {
              nV1 = vertices[index2 + 1];
              nV2 = vertices[index2 + 2];
              nV3 = clipVertices(vertices[index2], nV1);
              nV4 = clipVertices(vertices[index2], nV2);
            }
            if (v2Out) {
              nV1 = vertices[index2];
              nV2 = vertices[index2 + 2];
              nV3 = clipVertices(vertices[index2 + 1], nV1);
              nV4 = clipVertices(vertices[index2 + 1], nV2);
              result.push(nV3);
              result.push(nV2.clone());
              result.push(nV1.clone());
              result.push(nV2.clone());
              result.push(nV3.clone());
              result.push(nV4);
              break;
            }
            if (v3Out) {
              nV1 = vertices[index2];
              nV2 = vertices[index2 + 1];
              nV3 = clipVertices(vertices[index2 + 2], nV1);
              nV4 = clipVertices(vertices[index2 + 2], nV2);
            }
            if (nV1 && nV2 && nV3 && nV4) {
              result.push(nV1.clone());
              result.push(nV2.clone());
              result.push(nV3);
              result.push(nV4);
              result.push(nV3.clone());
              result.push(nV2.clone());
            }
            break;
          case 2:
            if (!v1Out) {
              nV1 = vertices[index2].clone();
              nV2 = clipVertices(nV1, vertices[index2 + 1]);
              nV3 = clipVertices(nV1, vertices[index2 + 2]);
              result.push(nV1);
              result.push(nV2);
              result.push(nV3);
            }
            if (!v2Out) {
              nV1 = vertices[index2 + 1].clone();
              nV2 = clipVertices(nV1, vertices[index2 + 2]);
              nV3 = clipVertices(nV1, vertices[index2]);
              result.push(nV1);
              result.push(nV2);
              result.push(nV3);
            }
            if (!v3Out) {
              nV1 = vertices[index2 + 2].clone();
              nV2 = clipVertices(nV1, vertices[index2]);
              nV3 = clipVertices(nV1, vertices[index2 + 1]);
              result.push(nV1);
              result.push(nV2);
              result.push(nV3);
            }
            break;
          case 3:
            break;
        }
      }
      return result;
    };
    for (var index = 0; index < indices.length; index += 3) {
      var faceVertices = new Array();
      faceVertices.push(extractDecalVector3(index));
      faceVertices.push(extractDecalVector3(index + 1));
      faceVertices.push(extractDecalVector3(index + 2));
      faceVertices = clip(faceVertices, new Vector3(1, 0, 0));
      faceVertices = clip(faceVertices, new Vector3(-1, 0, 0));
      faceVertices = clip(faceVertices, new Vector3(0, 1, 0));
      faceVertices = clip(faceVertices, new Vector3(0, -1, 0));
      faceVertices = clip(faceVertices, new Vector3(0, 0, 1));
      faceVertices = clip(faceVertices, new Vector3(0, 0, -1));
      if (faceVertices.length === 0) {
        continue;
      }
      for (var vIndex = 0; vIndex < faceVertices.length; vIndex++) {
        var vertex = faceVertices[vIndex];
        vertexData.indices.push(currentVertexDataIndex);
        vertex.position.toArray(vertexData.positions, currentVertexDataIndex * 3);
        vertex.normal.toArray(vertexData.normals, currentVertexDataIndex * 3);
        vertexData.uvs.push(0.5 + vertex.position.x / size.x);
        vertexData.uvs.push(0.5 + vertex.position.y / size.y);
        currentVertexDataIndex++;
      }
    }
    var decal = new Mesh(name98, sourceMesh.getScene());
    vertexData.applyToMesh(decal);
    decal.position = position.clone();
    decal.rotation = new Vector3(pitch, yaw, angle);
    return decal;
  };
  return DecalBuilder2;
}();

// node_modules/@babylonjs/core/Meshes/Builders/capsuleBuilder.js
VertexData.CreateCapsule = function(options) {
  if (options === void 0) {
    options = {
      subdivisions: 2,
      tessellation: 16,
      height: 1,
      radius: 0.25,
      capSubdivisions: 6
    };
  }
  var subdivisions = Math.max(options.subdivisions ? options.subdivisions : 2, 1);
  var tessellation = Math.max(options.tessellation ? options.tessellation : 16, 3);
  var height = Math.max(options.height ? options.height : 1, 0);
  var radius = Math.max(options.radius ? options.radius : 0.25, 0);
  var capDetail = Math.max(options.capSubdivisions ? options.capSubdivisions : 6, 1);
  var radialSegments = tessellation;
  var heightSegments = subdivisions;
  var radiusTop = Math.max(options.radiusTop ? options.radiusTop : radius, 0);
  var radiusBottom = Math.max(options.radiusBottom ? options.radiusBottom : radius, 0);
  var heightMinusCaps = height - (radiusTop + radiusBottom);
  var thetaStart = 0;
  var thetaLength = 2 * Math.PI;
  var capsTopSegments = Math.max(options.topCapSubdivisions ? options.topCapSubdivisions : capDetail, 1);
  var capsBottomSegments = Math.max(options.bottomCapSubdivisions ? options.bottomCapSubdivisions : capDetail, 1);
  var alpha = Math.acos((radiusBottom - radiusTop) / height);
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  var index = 0, indexArray = [], halfHeight = heightMinusCaps * 0.5;
  var pi2 = Math.PI * 0.5;
  var x, y;
  var normal = Vector3.Zero();
  var vertex = Vector3.Zero();
  var cosAlpha = Math.cos(alpha);
  var sinAlpha = Math.sin(alpha);
  var cone_length = new Vector2(radiusTop * sinAlpha, halfHeight + radiusTop * cosAlpha).subtract(new Vector2(radiusBottom * sinAlpha, -halfHeight + radiusBottom * cosAlpha)).length();
  var vl = radiusTop * alpha + cone_length + radiusBottom * (pi2 - alpha);
  var v = 0;
  for (y = 0; y <= capsTopSegments; y++) {
    var indexRow = [];
    var a = pi2 - alpha * (y / capsTopSegments);
    v += radiusTop * alpha / capsTopSegments;
    var cosA = Math.cos(a);
    var sinA = Math.sin(a);
    var _radius = cosA * radiusTop;
    for (x = 0; x <= radialSegments; x++) {
      var u = x / radialSegments;
      var theta = u * thetaLength + thetaStart;
      var sinTheta = Math.sin(theta);
      var cosTheta = Math.cos(theta);
      vertex.x = _radius * sinTheta;
      vertex.y = halfHeight + sinA * radiusTop;
      vertex.z = _radius * cosTheta;
      vertices.push(vertex.x, vertex.y, vertex.z);
      normal.set(cosA * sinTheta, sinA, cosA * cosTheta);
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(u, 1 - v / vl);
      indexRow.push(index);
      index++;
    }
    indexArray.push(indexRow);
  }
  var cone_height = height - radiusTop - radiusBottom + cosAlpha * radiusTop - cosAlpha * radiusBottom;
  var slope = sinAlpha * (radiusBottom - radiusTop) / cone_height;
  for (y = 1; y <= heightSegments; y++) {
    var indexRow = [];
    v += cone_length / heightSegments;
    var _radius = sinAlpha * (y * (radiusBottom - radiusTop) / heightSegments + radiusTop);
    for (x = 0; x <= radialSegments; x++) {
      var u = x / radialSegments;
      var theta = u * thetaLength + thetaStart;
      var sinTheta = Math.sin(theta);
      var cosTheta = Math.cos(theta);
      vertex.x = _radius * sinTheta;
      vertex.y = halfHeight + cosAlpha * radiusTop - y * cone_height / heightSegments;
      vertex.z = _radius * cosTheta;
      vertices.push(vertex.x, vertex.y, vertex.z);
      normal.set(sinTheta, slope, cosTheta).normalize();
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(u, 1 - v / vl);
      indexRow.push(index);
      index++;
    }
    indexArray.push(indexRow);
  }
  for (y = 1; y <= capsBottomSegments; y++) {
    var indexRow = [];
    var a = pi2 - alpha - (Math.PI - alpha) * (y / capsBottomSegments);
    v += radiusBottom * alpha / capsBottomSegments;
    var cosA = Math.cos(a);
    var sinA = Math.sin(a);
    var _radius = cosA * radiusBottom;
    for (x = 0; x <= radialSegments; x++) {
      var u = x / radialSegments;
      var theta = u * thetaLength + thetaStart;
      var sinTheta = Math.sin(theta);
      var cosTheta = Math.cos(theta);
      vertex.x = _radius * sinTheta;
      vertex.y = -halfHeight + sinA * radiusBottom;
      vertex.z = _radius * cosTheta;
      vertices.push(vertex.x, vertex.y, vertex.z);
      normal.set(cosA * sinTheta, sinA, cosA * cosTheta);
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(u, 1 - v / vl);
      indexRow.push(index);
      index++;
    }
    indexArray.push(indexRow);
  }
  for (x = 0; x < radialSegments; x++) {
    for (y = 0; y < capsTopSegments + heightSegments + capsBottomSegments; y++) {
      var i1 = indexArray[y][x];
      var i2 = indexArray[y + 1][x];
      var i3 = indexArray[y + 1][x + 1];
      var i4 = indexArray[y][x + 1];
      indices.push(i1);
      indices.push(i2);
      indices.push(i4);
      indices.push(i2);
      indices.push(i3);
      indices.push(i4);
    }
  }
  indices = indices.reverse();
  if (options.orientation && !options.orientation.equals(Vector3.Up())) {
    var m = new Matrix();
    options.orientation.clone().scale(Math.PI * 0.5).cross(Vector3.Up()).toQuaternion().toRotationMatrix(m);
    var v_1 = Vector3.Zero();
    for (var i = 0; i < vertices.length; i += 3) {
      v_1.set(vertices[i], vertices[i + 1], vertices[i + 2]);
      Vector3.TransformCoordinatesToRef(v_1.clone(), m, v_1);
      vertices[i] = v_1.x;
      vertices[i + 1] = v_1.y;
      vertices[i + 2] = v_1.z;
    }
  }
  var vDat = new VertexData();
  vDat.positions = vertices;
  vDat.normals = normals;
  vDat.uvs = uvs;
  vDat.indices = indices;
  return vDat;
};
Mesh.CreateCapsule = function(name98, options, scene) {
  return CapsuleBuilder.CreateCapsule(name98, options, scene);
};
var CapsuleBuilder = function() {
  function CapsuleBuilder2() {
  }
  CapsuleBuilder2.CreateCapsule = function(name98, options, scene) {
    if (options === void 0) {
      options = {
        orientation: Vector3.Up(),
        subdivisions: 2,
        tessellation: 16,
        height: 1,
        radius: 0.25,
        capSubdivisions: 6
      };
    }
    var capsule = new Mesh(name98, scene);
    var vertexData = VertexData.CreateCapsule(options);
    vertexData.applyToMesh(capsule);
    return capsule;
  };
  return CapsuleBuilder2;
}();

// node_modules/@babylonjs/core/Meshes/meshBuilder.js
var MeshBuilder = function() {
  function MeshBuilder2() {
  }
  MeshBuilder2.CreateBox = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    return BoxBuilder.CreateBox(name98, options, scene);
  };
  MeshBuilder2.CreateTiledBox = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    return TiledBoxBuilder.CreateTiledBox(name98, options, scene);
  };
  MeshBuilder2.CreateSphere = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    return SphereBuilder.CreateSphere(name98, options, scene);
  };
  MeshBuilder2.CreateDisc = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    return DiscBuilder.CreateDisc(name98, options, scene);
  };
  MeshBuilder2.CreateIcoSphere = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    return IcoSphereBuilder.CreateIcoSphere(name98, options, scene);
  };
  MeshBuilder2.CreateRibbon = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    return RibbonBuilder.CreateRibbon(name98, options, scene);
  };
  MeshBuilder2.CreateCylinder = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    return CylinderBuilder.CreateCylinder(name98, options, scene);
  };
  MeshBuilder2.CreateTorus = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    return TorusBuilder.CreateTorus(name98, options, scene);
  };
  MeshBuilder2.CreateTorusKnot = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    return TorusKnotBuilder.CreateTorusKnot(name98, options, scene);
  };
  MeshBuilder2.CreateLineSystem = function(name98, options, scene) {
    return LinesBuilder.CreateLineSystem(name98, options, scene);
  };
  MeshBuilder2.CreateLines = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    return LinesBuilder.CreateLines(name98, options, scene);
  };
  MeshBuilder2.CreateDashedLines = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    return LinesBuilder.CreateDashedLines(name98, options, scene);
  };
  MeshBuilder2.ExtrudeShape = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    return ShapeBuilder.ExtrudeShape(name98, options, scene);
  };
  MeshBuilder2.ExtrudeShapeCustom = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    return ShapeBuilder.ExtrudeShapeCustom(name98, options, scene);
  };
  MeshBuilder2.CreateLathe = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    return LatheBuilder.CreateLathe(name98, options, scene);
  };
  MeshBuilder2.CreateTiledPlane = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    return TiledPlaneBuilder.CreateTiledPlane(name98, options, scene);
  };
  MeshBuilder2.CreatePlane = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    return PlaneBuilder.CreatePlane(name98, options, scene);
  };
  MeshBuilder2.CreateGround = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    return GroundBuilder.CreateGround(name98, options, scene);
  };
  MeshBuilder2.CreateTiledGround = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    return GroundBuilder.CreateTiledGround(name98, options, scene);
  };
  MeshBuilder2.CreateGroundFromHeightMap = function(name98, url, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    return GroundBuilder.CreateGroundFromHeightMap(name98, url, options, scene);
  };
  MeshBuilder2.CreatePolygon = function(name98, options, scene, earcutInjection) {
    if (scene === void 0) {
      scene = null;
    }
    if (earcutInjection === void 0) {
      earcutInjection = earcut;
    }
    return PolygonBuilder.CreatePolygon(name98, options, scene, earcutInjection);
  };
  MeshBuilder2.ExtrudePolygon = function(name98, options, scene, earcutInjection) {
    if (scene === void 0) {
      scene = null;
    }
    if (earcutInjection === void 0) {
      earcutInjection = earcut;
    }
    return PolygonBuilder.ExtrudePolygon(name98, options, scene, earcutInjection);
  };
  MeshBuilder2.CreateTube = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    return TubeBuilder.CreateTube(name98, options, scene);
  };
  MeshBuilder2.CreatePolyhedron = function(name98, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    return PolyhedronBuilder.CreatePolyhedron(name98, options, scene);
  };
  MeshBuilder2.CreateDecal = function(name98, sourceMesh, options) {
    return DecalBuilder.CreateDecal(name98, sourceMesh, options);
  };
  MeshBuilder2.CreateCapsule = function(name98, options, scene) {
    if (options === void 0) {
      options = {
        orientation: Vector3.Up(),
        subdivisions: 2,
        tessellation: 16,
        height: 1,
        radius: 0.25,
        capSubdivisions: 6
      };
    }
    if (scene === void 0) {
      scene = null;
    }
    return CapsuleBuilder.CreateCapsule(name98, options, scene);
  };
  return MeshBuilder2;
}();

// node_modules/@babylonjs/core/Meshes/meshSimplification.js
var SimplificationSettings = function() {
  function SimplificationSettings2(quality, distance, optimizeMesh) {
    this.quality = quality;
    this.distance = distance;
    this.optimizeMesh = optimizeMesh;
  }
  return SimplificationSettings2;
}();
var SimplificationQueue = function() {
  function SimplificationQueue2() {
    this.running = false;
    this._simplificationArray = [];
  }
  SimplificationQueue2.prototype.addTask = function(task) {
    this._simplificationArray.push(task);
  };
  SimplificationQueue2.prototype.executeNext = function() {
    var task = this._simplificationArray.pop();
    if (task) {
      this.running = true;
      this.runSimplification(task);
    } else {
      this.running = false;
    }
  };
  SimplificationQueue2.prototype.runSimplification = function(task) {
    var _this = this;
    if (task.parallelProcessing) {
      task.settings.forEach(function(setting) {
        var simplifier2 = _this.getSimplifier(task);
        simplifier2.simplify(setting, function(newMesh) {
          if (setting.distance !== void 0) {
            task.mesh.addLODLevel(setting.distance, newMesh);
          }
          newMesh.isVisible = true;
          if (setting.quality === task.settings[task.settings.length - 1].quality && task.successCallback) {
            task.successCallback();
          }
          _this.executeNext();
        });
      });
    } else {
      var simplifier = this.getSimplifier(task);
      var runDecimation = function(setting, callback) {
        simplifier.simplify(setting, function(newMesh) {
          if (setting.distance !== void 0) {
            task.mesh.addLODLevel(setting.distance, newMesh);
          }
          newMesh.isVisible = true;
          callback();
        });
      };
      AsyncLoop.Run(task.settings.length, function(loop) {
        runDecimation(task.settings[loop.index], function() {
          loop.executeNext();
        });
      }, function() {
        if (task.successCallback) {
          task.successCallback();
        }
        _this.executeNext();
      });
    }
  };
  SimplificationQueue2.prototype.getSimplifier = function(task) {
    switch (task.simplificationType) {
      case SimplificationType.QUADRATIC:
      default:
        return new QuadraticErrorSimplification(task.mesh);
    }
  };
  return SimplificationQueue2;
}();
var SimplificationType;
(function(SimplificationType2) {
  SimplificationType2[SimplificationType2["QUADRATIC"] = 0] = "QUADRATIC";
})(SimplificationType || (SimplificationType = {}));
var DecimationTriangle = function() {
  function DecimationTriangle2(vertices) {
    this.vertices = vertices;
    this.error = new Array(4);
    this.deleted = false;
    this.isDirty = false;
    this.deletePending = false;
    this.borderFactor = 0;
  }
  return DecimationTriangle2;
}();
var DecimationVertex = function() {
  function DecimationVertex2(position, id) {
    this.position = position;
    this.id = id;
    this.isBorder = true;
    this.q = new QuadraticMatrix();
    this.triangleCount = 0;
    this.triangleStart = 0;
    this.originalOffsets = [];
  }
  DecimationVertex2.prototype.updatePosition = function(newPosition) {
    this.position.copyFrom(newPosition);
  };
  return DecimationVertex2;
}();
var QuadraticMatrix = function() {
  function QuadraticMatrix2(data) {
    this.data = new Array(10);
    for (var i = 0; i < 10; ++i) {
      if (data && data[i]) {
        this.data[i] = data[i];
      } else {
        this.data[i] = 0;
      }
    }
  }
  QuadraticMatrix2.prototype.det = function(a11, a12, a13, a21, a22, a23, a31, a32, a33) {
    var det = this.data[a11] * this.data[a22] * this.data[a33] + this.data[a13] * this.data[a21] * this.data[a32] + this.data[a12] * this.data[a23] * this.data[a31] - this.data[a13] * this.data[a22] * this.data[a31] - this.data[a11] * this.data[a23] * this.data[a32] - this.data[a12] * this.data[a21] * this.data[a33];
    return det;
  };
  QuadraticMatrix2.prototype.addInPlace = function(matrix) {
    for (var i = 0; i < 10; ++i) {
      this.data[i] += matrix.data[i];
    }
  };
  QuadraticMatrix2.prototype.addArrayInPlace = function(data) {
    for (var i = 0; i < 10; ++i) {
      this.data[i] += data[i];
    }
  };
  QuadraticMatrix2.prototype.add = function(matrix) {
    var m = new QuadraticMatrix2();
    for (var i = 0; i < 10; ++i) {
      m.data[i] = this.data[i] + matrix.data[i];
    }
    return m;
  };
  QuadraticMatrix2.FromData = function(a, b, c, d) {
    return new QuadraticMatrix2(QuadraticMatrix2.DataFromNumbers(a, b, c, d));
  };
  QuadraticMatrix2.DataFromNumbers = function(a, b, c, d) {
    return [a * a, a * b, a * c, a * d, b * b, b * c, b * d, c * c, c * d, d * d];
  };
  return QuadraticMatrix2;
}();
var Reference = function() {
  function Reference2(vertexId, triangleId) {
    this.vertexId = vertexId;
    this.triangleId = triangleId;
  }
  return Reference2;
}();
var QuadraticErrorSimplification = function() {
  function QuadraticErrorSimplification2(_mesh) {
    this._mesh = _mesh;
    this.syncIterations = 5e3;
    this.aggressiveness = 7;
    this.decimationIterations = 100;
    this.boundingBoxEpsilon = Epsilon;
  }
  QuadraticErrorSimplification2.prototype.simplify = function(settings, successCallback) {
    var _this = this;
    this.initDecimatedMesh();
    AsyncLoop.Run(this._mesh.subMeshes.length, function(loop) {
      _this.initWithMesh(loop.index, function() {
        _this.runDecimation(settings, loop.index, function() {
          loop.executeNext();
        });
      }, settings.optimizeMesh);
    }, function() {
      setTimeout(function() {
        successCallback(_this._reconstructedMesh);
      }, 0);
    });
  };
  QuadraticErrorSimplification2.prototype.runDecimation = function(settings, submeshIndex, successCallback) {
    var _this = this;
    var targetCount = ~~(this.triangles.length * settings.quality);
    var deletedTriangles = 0;
    var triangleCount = this.triangles.length;
    var iterationFunction = function(iteration, callback) {
      setTimeout(function() {
        if (iteration % 5 === 0) {
          _this.updateMesh(iteration === 0);
        }
        for (var i = 0; i < _this.triangles.length; ++i) {
          _this.triangles[i].isDirty = false;
        }
        var threshold = 1e-9 * Math.pow(iteration + 3, _this.aggressiveness);
        var trianglesIterator = function(i2) {
          var tIdx = ~~((_this.triangles.length / 2 + i2) % _this.triangles.length);
          var t = _this.triangles[tIdx];
          if (!t) {
            return;
          }
          if (t.error[3] > threshold || t.deleted || t.isDirty) {
            return;
          }
          for (var j = 0; j < 3; ++j) {
            if (t.error[j] < threshold) {
              var deleted0 = [];
              var deleted1 = [];
              var v0 = t.vertices[j];
              var v1 = t.vertices[(j + 1) % 3];
              if (v0.isBorder || v1.isBorder) {
                continue;
              }
              var p = Vector3.Zero();
              _this.calculateError(v0, v1, p);
              var delTr = new Array();
              if (_this.isFlipped(v0, v1, p, deleted0, delTr)) {
                continue;
              }
              if (_this.isFlipped(v1, v0, p, deleted1, delTr)) {
                continue;
              }
              if (deleted0.indexOf(true) < 0 || deleted1.indexOf(true) < 0) {
                continue;
              }
              var uniqueArray = new Array();
              delTr.forEach(function(deletedT) {
                if (uniqueArray.indexOf(deletedT) === -1) {
                  deletedT.deletePending = true;
                  uniqueArray.push(deletedT);
                }
              });
              if (uniqueArray.length % 2 !== 0) {
                continue;
              }
              v0.q = v1.q.add(v0.q);
              v0.updatePosition(p);
              var tStart = _this.references.length;
              deletedTriangles = _this.updateTriangles(v0, v0, deleted0, deletedTriangles);
              deletedTriangles = _this.updateTriangles(v0, v1, deleted1, deletedTriangles);
              var tCount = _this.references.length - tStart;
              if (tCount <= v0.triangleCount) {
                if (tCount) {
                  for (var c = 0; c < tCount; c++) {
                    _this.references[v0.triangleStart + c] = _this.references[tStart + c];
                  }
                }
              } else {
                v0.triangleStart = tStart;
              }
              v0.triangleCount = tCount;
              break;
            }
          }
        };
        AsyncLoop.SyncAsyncForLoop(_this.triangles.length, _this.syncIterations, trianglesIterator, callback, function() {
          return triangleCount - deletedTriangles <= targetCount;
        });
      }, 0);
    };
    AsyncLoop.Run(this.decimationIterations, function(loop) {
      if (triangleCount - deletedTriangles <= targetCount) {
        loop.breakLoop();
      } else {
        iterationFunction(loop.index, function() {
          loop.executeNext();
        });
      }
    }, function() {
      setTimeout(function() {
        _this.reconstructMesh(submeshIndex);
        successCallback();
      }, 0);
    });
  };
  QuadraticErrorSimplification2.prototype.initWithMesh = function(submeshIndex, callback, optimizeMesh) {
    var _this = this;
    this.vertices = [];
    this.triangles = [];
    var positionData = this._mesh.getVerticesData(VertexBuffer.PositionKind);
    var indices = this._mesh.getIndices();
    var submesh = this._mesh.subMeshes[submeshIndex];
    var findInVertices = function(positionToSearch) {
      if (optimizeMesh) {
        for (var ii = 0; ii < _this.vertices.length; ++ii) {
          if (_this.vertices[ii].position.equalsWithEpsilon(positionToSearch, 1e-4)) {
            return _this.vertices[ii];
          }
        }
      }
      return null;
    };
    var vertexReferences = [];
    var vertexInit = function(i) {
      if (!positionData) {
        return;
      }
      var offset = i + submesh.verticesStart;
      var position = Vector3.FromArray(positionData, offset * 3);
      var vertex = findInVertices(position) || new DecimationVertex(position, _this.vertices.length);
      vertex.originalOffsets.push(offset);
      if (vertex.id === _this.vertices.length) {
        _this.vertices.push(vertex);
      }
      vertexReferences.push(vertex.id);
    };
    var totalVertices = submesh.verticesCount;
    AsyncLoop.SyncAsyncForLoop(totalVertices, this.syncIterations / 4 >> 0, vertexInit, function() {
      var indicesInit = function(i) {
        if (!indices) {
          return;
        }
        var offset = submesh.indexStart / 3 + i;
        var pos = offset * 3;
        var i0 = indices[pos + 0];
        var i1 = indices[pos + 1];
        var i2 = indices[pos + 2];
        var v0 = _this.vertices[vertexReferences[i0 - submesh.verticesStart]];
        var v1 = _this.vertices[vertexReferences[i1 - submesh.verticesStart]];
        var v2 = _this.vertices[vertexReferences[i2 - submesh.verticesStart]];
        var triangle = new DecimationTriangle([v0, v1, v2]);
        triangle.originalOffset = pos;
        _this.triangles.push(triangle);
      };
      AsyncLoop.SyncAsyncForLoop(submesh.indexCount / 3, _this.syncIterations, indicesInit, function() {
        _this.init(callback);
      });
    });
  };
  QuadraticErrorSimplification2.prototype.init = function(callback) {
    var _this = this;
    var triangleInit1 = function(i) {
      var t = _this.triangles[i];
      t.normal = Vector3.Cross(t.vertices[1].position.subtract(t.vertices[0].position), t.vertices[2].position.subtract(t.vertices[0].position)).normalize();
      for (var j = 0; j < 3; j++) {
        t.vertices[j].q.addArrayInPlace(QuadraticMatrix.DataFromNumbers(t.normal.x, t.normal.y, t.normal.z, -Vector3.Dot(t.normal, t.vertices[0].position)));
      }
    };
    AsyncLoop.SyncAsyncForLoop(this.triangles.length, this.syncIterations, triangleInit1, function() {
      var triangleInit2 = function(i) {
        var t = _this.triangles[i];
        for (var j = 0; j < 3; ++j) {
          t.error[j] = _this.calculateError(t.vertices[j], t.vertices[(j + 1) % 3]);
        }
        t.error[3] = Math.min(t.error[0], t.error[1], t.error[2]);
      };
      AsyncLoop.SyncAsyncForLoop(_this.triangles.length, _this.syncIterations, triangleInit2, function() {
        callback();
      });
    });
  };
  QuadraticErrorSimplification2.prototype.reconstructMesh = function(submeshIndex) {
    var newTriangles = [];
    var i;
    for (i = 0; i < this.vertices.length; ++i) {
      this.vertices[i].triangleCount = 0;
    }
    var t;
    var j;
    for (i = 0; i < this.triangles.length; ++i) {
      if (!this.triangles[i].deleted) {
        t = this.triangles[i];
        for (j = 0; j < 3; ++j) {
          t.vertices[j].triangleCount = 1;
        }
        newTriangles.push(t);
      }
    }
    var newPositionData = this._reconstructedMesh.getVerticesData(VertexBuffer.PositionKind) || [];
    var newNormalData = this._reconstructedMesh.getVerticesData(VertexBuffer.NormalKind) || [];
    var newUVsData = this._reconstructedMesh.getVerticesData(VertexBuffer.UVKind) || [];
    var newColorsData = this._reconstructedMesh.getVerticesData(VertexBuffer.ColorKind) || [];
    var normalData = this._mesh.getVerticesData(VertexBuffer.NormalKind);
    var uvs = this._mesh.getVerticesData(VertexBuffer.UVKind);
    var colorsData = this._mesh.getVerticesData(VertexBuffer.ColorKind);
    var vertexCount = 0;
    for (i = 0; i < this.vertices.length; ++i) {
      var vertex = this.vertices[i];
      vertex.id = vertexCount;
      if (vertex.triangleCount) {
        vertex.originalOffsets.forEach(function(originalOffset) {
          newPositionData.push(vertex.position.x);
          newPositionData.push(vertex.position.y);
          newPositionData.push(vertex.position.z);
          if (normalData && normalData.length) {
            newNormalData.push(normalData[originalOffset * 3]);
            newNormalData.push(normalData[originalOffset * 3 + 1]);
            newNormalData.push(normalData[originalOffset * 3 + 2]);
          }
          if (uvs && uvs.length) {
            newUVsData.push(uvs[originalOffset * 2]);
            newUVsData.push(uvs[originalOffset * 2 + 1]);
          }
          if (colorsData && colorsData.length) {
            newColorsData.push(colorsData[originalOffset * 4]);
            newColorsData.push(colorsData[originalOffset * 4 + 1]);
            newColorsData.push(colorsData[originalOffset * 4 + 2]);
            newColorsData.push(colorsData[originalOffset * 4 + 3]);
          }
          ++vertexCount;
        });
      }
    }
    var startingIndex = this._reconstructedMesh.getTotalIndices();
    var startingVertex = this._reconstructedMesh.getTotalVertices();
    var submeshesArray = this._reconstructedMesh.subMeshes;
    this._reconstructedMesh.subMeshes = [];
    var newIndicesArray = this._reconstructedMesh.getIndices();
    var originalIndices = this._mesh.getIndices();
    for (i = 0; i < newTriangles.length; ++i) {
      t = newTriangles[i];
      [0, 1, 2].forEach(function(idx) {
        var id = originalIndices[t.originalOffset + idx];
        var offset = t.vertices[idx].originalOffsets.indexOf(id);
        if (offset < 0) {
          offset = 0;
        }
        newIndicesArray.push(t.vertices[idx].id + offset + startingVertex);
      });
    }
    this._reconstructedMesh.setIndices(newIndicesArray);
    this._reconstructedMesh.setVerticesData(VertexBuffer.PositionKind, newPositionData);
    if (newNormalData.length > 0) {
      this._reconstructedMesh.setVerticesData(VertexBuffer.NormalKind, newNormalData);
    }
    if (newUVsData.length > 0) {
      this._reconstructedMesh.setVerticesData(VertexBuffer.UVKind, newUVsData);
    }
    if (newColorsData.length > 0) {
      this._reconstructedMesh.setVerticesData(VertexBuffer.ColorKind, newColorsData);
    }
    var originalSubmesh = this._mesh.subMeshes[submeshIndex];
    if (submeshIndex > 0) {
      this._reconstructedMesh.subMeshes = [];
      submeshesArray.forEach(function(submesh) {
        SubMesh.AddToMesh(submesh.materialIndex, submesh.verticesStart, submesh.verticesCount, submesh.indexStart, submesh.indexCount, submesh.getMesh());
      });
      SubMesh.AddToMesh(originalSubmesh.materialIndex, startingVertex, vertexCount, startingIndex, newTriangles.length * 3, this._reconstructedMesh);
    }
  };
  QuadraticErrorSimplification2.prototype.initDecimatedMesh = function() {
    this._reconstructedMesh = new Mesh(this._mesh.name + "Decimated", this._mesh.getScene());
    this._reconstructedMesh.material = this._mesh.material;
    this._reconstructedMesh.parent = this._mesh.parent;
    this._reconstructedMesh.isVisible = false;
    this._reconstructedMesh.renderingGroupId = this._mesh.renderingGroupId;
  };
  QuadraticErrorSimplification2.prototype.isFlipped = function(vertex1, vertex2, point, deletedArray, delTr) {
    for (var i = 0; i < vertex1.triangleCount; ++i) {
      var t = this.triangles[this.references[vertex1.triangleStart + i].triangleId];
      if (t.deleted) {
        continue;
      }
      var s = this.references[vertex1.triangleStart + i].vertexId;
      var v1 = t.vertices[(s + 1) % 3];
      var v2 = t.vertices[(s + 2) % 3];
      if (v1 === vertex2 || v2 === vertex2) {
        deletedArray[i] = true;
        delTr.push(t);
        continue;
      }
      var d1 = v1.position.subtract(point);
      d1 = d1.normalize();
      var d2 = v2.position.subtract(point);
      d2 = d2.normalize();
      if (Math.abs(Vector3.Dot(d1, d2)) > 0.999) {
        return true;
      }
      var normal = Vector3.Cross(d1, d2).normalize();
      deletedArray[i] = false;
      if (Vector3.Dot(normal, t.normal) < 0.2) {
        return true;
      }
    }
    return false;
  };
  QuadraticErrorSimplification2.prototype.updateTriangles = function(origVertex, vertex, deletedArray, deletedTriangles) {
    var newDeleted = deletedTriangles;
    for (var i = 0; i < vertex.triangleCount; ++i) {
      var ref = this.references[vertex.triangleStart + i];
      var t = this.triangles[ref.triangleId];
      if (t.deleted) {
        continue;
      }
      if (deletedArray[i] && t.deletePending) {
        t.deleted = true;
        newDeleted++;
        continue;
      }
      t.vertices[ref.vertexId] = origVertex;
      t.isDirty = true;
      t.error[0] = this.calculateError(t.vertices[0], t.vertices[1]) + t.borderFactor / 2;
      t.error[1] = this.calculateError(t.vertices[1], t.vertices[2]) + t.borderFactor / 2;
      t.error[2] = this.calculateError(t.vertices[2], t.vertices[0]) + t.borderFactor / 2;
      t.error[3] = Math.min(t.error[0], t.error[1], t.error[2]);
      this.references.push(ref);
    }
    return newDeleted;
  };
  QuadraticErrorSimplification2.prototype.identifyBorder = function() {
    for (var i = 0; i < this.vertices.length; ++i) {
      var vCount = [];
      var vId = [];
      var v = this.vertices[i];
      var j;
      for (j = 0; j < v.triangleCount; ++j) {
        var triangle = this.triangles[this.references[v.triangleStart + j].triangleId];
        for (var ii = 0; ii < 3; ii++) {
          var ofs = 0;
          var vv = triangle.vertices[ii];
          while (ofs < vCount.length) {
            if (vId[ofs] === vv.id) {
              break;
            }
            ++ofs;
          }
          if (ofs === vCount.length) {
            vCount.push(1);
            vId.push(vv.id);
          } else {
            vCount[ofs]++;
          }
        }
      }
      for (j = 0; j < vCount.length; ++j) {
        if (vCount[j] === 1) {
          this.vertices[vId[j]].isBorder = true;
        } else {
          this.vertices[vId[j]].isBorder = false;
        }
      }
    }
  };
  QuadraticErrorSimplification2.prototype.updateMesh = function(identifyBorders) {
    if (identifyBorders === void 0) {
      identifyBorders = false;
    }
    var i;
    if (!identifyBorders) {
      var newTrianglesVector = [];
      for (i = 0; i < this.triangles.length; ++i) {
        if (!this.triangles[i].deleted) {
          newTrianglesVector.push(this.triangles[i]);
        }
      }
      this.triangles = newTrianglesVector;
    }
    for (i = 0; i < this.vertices.length; ++i) {
      this.vertices[i].triangleCount = 0;
      this.vertices[i].triangleStart = 0;
    }
    var t;
    var j;
    var v;
    for (i = 0; i < this.triangles.length; ++i) {
      t = this.triangles[i];
      for (j = 0; j < 3; ++j) {
        v = t.vertices[j];
        v.triangleCount++;
      }
    }
    var tStart = 0;
    for (i = 0; i < this.vertices.length; ++i) {
      this.vertices[i].triangleStart = tStart;
      tStart += this.vertices[i].triangleCount;
      this.vertices[i].triangleCount = 0;
    }
    var newReferences = new Array(this.triangles.length * 3);
    for (i = 0; i < this.triangles.length; ++i) {
      t = this.triangles[i];
      for (j = 0; j < 3; ++j) {
        v = t.vertices[j];
        newReferences[v.triangleStart + v.triangleCount] = new Reference(j, i);
        v.triangleCount++;
      }
    }
    this.references = newReferences;
    if (identifyBorders) {
      this.identifyBorder();
    }
  };
  QuadraticErrorSimplification2.prototype.vertexError = function(q, point) {
    var x = point.x;
    var y = point.y;
    var z = point.z;
    return q.data[0] * x * x + 2 * q.data[1] * x * y + 2 * q.data[2] * x * z + 2 * q.data[3] * x + q.data[4] * y * y + 2 * q.data[5] * y * z + 2 * q.data[6] * y + q.data[7] * z * z + 2 * q.data[8] * z + q.data[9];
  };
  QuadraticErrorSimplification2.prototype.calculateError = function(vertex1, vertex2, pointResult) {
    var q = vertex1.q.add(vertex2.q);
    var border = vertex1.isBorder && vertex2.isBorder;
    var error = 0;
    var qDet = q.det(0, 1, 2, 1, 4, 5, 2, 5, 7);
    if (qDet !== 0 && !border) {
      if (!pointResult) {
        pointResult = Vector3.Zero();
      }
      pointResult.x = -1 / qDet * q.det(1, 2, 3, 4, 5, 6, 5, 7, 8);
      pointResult.y = 1 / qDet * q.det(0, 2, 3, 1, 5, 6, 2, 7, 8);
      pointResult.z = -1 / qDet * q.det(0, 1, 3, 1, 4, 6, 2, 5, 8);
      error = this.vertexError(q, pointResult);
    } else {
      var p3 = vertex1.position.add(vertex2.position).divide(new Vector3(2, 2, 2));
      var error1 = this.vertexError(q, vertex1.position);
      var error2 = this.vertexError(q, vertex2.position);
      var error3 = this.vertexError(q, p3);
      error = Math.min(error1, error2, error3);
      if (error === error1) {
        if (pointResult) {
          pointResult.copyFrom(vertex1.position);
        }
      } else if (error === error2) {
        if (pointResult) {
          pointResult.copyFrom(vertex2.position);
        }
      } else {
        if (pointResult) {
          pointResult.copyFrom(p3);
        }
      }
    }
    return error;
  };
  return QuadraticErrorSimplification2;
}();

// node_modules/@babylonjs/core/Meshes/meshSimplificationSceneComponent.js
Object.defineProperty(Scene.prototype, "simplificationQueue", {
  get: function() {
    if (!this._simplificationQueue) {
      this._simplificationQueue = new SimplificationQueue();
      var component = this._getComponent(SceneComponentConstants.NAME_SIMPLIFICATIONQUEUE);
      if (!component) {
        component = new SimplicationQueueSceneComponent(this);
        this._addComponent(component);
      }
    }
    return this._simplificationQueue;
  },
  set: function(value) {
    this._simplificationQueue = value;
  },
  enumerable: true,
  configurable: true
});
Mesh.prototype.simplify = function(settings, parallelProcessing, simplificationType, successCallback) {
  if (parallelProcessing === void 0) {
    parallelProcessing = true;
  }
  if (simplificationType === void 0) {
    simplificationType = SimplificationType.QUADRATIC;
  }
  this.getScene().simplificationQueue.addTask({
    settings,
    parallelProcessing,
    mesh: this,
    simplificationType,
    successCallback
  });
  return this;
};
var SimplicationQueueSceneComponent = function() {
  function SimplicationQueueSceneComponent2(scene) {
    this.name = SceneComponentConstants.NAME_SIMPLIFICATIONQUEUE;
    this.scene = scene;
  }
  SimplicationQueueSceneComponent2.prototype.register = function() {
    this.scene._beforeCameraUpdateStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE, this, this._beforeCameraUpdate);
  };
  SimplicationQueueSceneComponent2.prototype.rebuild = function() {
  };
  SimplicationQueueSceneComponent2.prototype.dispose = function() {
  };
  SimplicationQueueSceneComponent2.prototype._beforeCameraUpdate = function() {
    if (this.scene._simplificationQueue && !this.scene._simplificationQueue.running) {
      this.scene._simplificationQueue.executeNext();
    }
  };
  return SimplicationQueueSceneComponent2;
}();

// node_modules/@babylonjs/core/Meshes/thinInstanceMesh.js
Mesh.prototype.thinInstanceAdd = function(matrix, refresh) {
  if (refresh === void 0) {
    refresh = true;
  }
  this._thinInstanceUpdateBufferSize("matrix", Array.isArray(matrix) ? matrix.length : 1);
  var index = this._thinInstanceDataStorage.instancesCount;
  if (Array.isArray(matrix)) {
    for (var i = 0; i < matrix.length; ++i) {
      this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix[i], i === matrix.length - 1 && refresh);
    }
  } else {
    this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix, refresh);
  }
  return index;
};
Mesh.prototype.thinInstanceAddSelf = function(refresh) {
  if (refresh === void 0) {
    refresh = true;
  }
  return this.thinInstanceAdd(Matrix.IdentityReadOnly, refresh);
};
Mesh.prototype.thinInstanceRegisterAttribute = function(kind, stride) {
  this.removeVerticesData(kind);
  this._thinInstanceInitializeUserStorage();
  this._userThinInstanceBuffersStorage.strides[kind] = stride;
  this._userThinInstanceBuffersStorage.sizes[kind] = stride * Math.max(32, this._thinInstanceDataStorage.instancesCount);
  this._userThinInstanceBuffersStorage.data[kind] = new Float32Array(this._userThinInstanceBuffersStorage.sizes[kind]);
  this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, true, false, stride, true);
  this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
};
Mesh.prototype.thinInstanceSetMatrixAt = function(index, matrix, refresh) {
  if (refresh === void 0) {
    refresh = true;
  }
  if (!this._thinInstanceDataStorage.matrixData || index >= this._thinInstanceDataStorage.instancesCount) {
    return false;
  }
  var matrixData = this._thinInstanceDataStorage.matrixData;
  matrix.copyToArray(matrixData, index * 16);
  if (this._thinInstanceDataStorage.worldMatrices) {
    this._thinInstanceDataStorage.worldMatrices[index] = matrix;
  }
  if (refresh) {
    this.thinInstanceBufferUpdated("matrix");
    if (!this.doNotSyncBoundingInfo) {
      this.thinInstanceRefreshBoundingInfo(false);
    }
  }
  return true;
};
Mesh.prototype.thinInstanceSetAttributeAt = function(kind, index, value, refresh) {
  if (refresh === void 0) {
    refresh = true;
  }
  if (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.data[kind] || index >= this._thinInstanceDataStorage.instancesCount) {
    return false;
  }
  this._thinInstanceUpdateBufferSize(kind, 0);
  this._userThinInstanceBuffersStorage.data[kind].set(value, index * this._userThinInstanceBuffersStorage.strides[kind]);
  if (refresh) {
    this.thinInstanceBufferUpdated(kind);
  }
  return true;
};
Object.defineProperty(Mesh.prototype, "thinInstanceCount", {
  get: function() {
    return this._thinInstanceDataStorage.instancesCount;
  },
  set: function(value) {
    var _a, _b;
    var numMaxInstances = ((_b = (_a = this._thinInstanceDataStorage.matrixData) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) / 16;
    if (value <= numMaxInstances) {
      this._thinInstanceDataStorage.instancesCount = value;
    }
  },
  enumerable: true,
  configurable: true
});
Mesh.prototype.thinInstanceSetBuffer = function(kind, buffer, stride, staticBuffer) {
  var _a, _b;
  if (stride === void 0) {
    stride = 0;
  }
  if (staticBuffer === void 0) {
    staticBuffer = false;
  }
  stride = stride || 16;
  if (kind === "matrix") {
    (_a = this._thinInstanceDataStorage.matrixBuffer) === null || _a === void 0 ? void 0 : _a.dispose();
    this._thinInstanceDataStorage.matrixBuffer = null;
    this._thinInstanceDataStorage.matrixBufferSize = buffer ? buffer.length : 32 * stride;
    this._thinInstanceDataStorage.matrixData = buffer;
    this._thinInstanceDataStorage.worldMatrices = null;
    if (buffer !== null) {
      this._thinInstanceDataStorage.instancesCount = buffer.length / stride;
      var matrixBuffer = new Buffer(this.getEngine(), buffer, !staticBuffer, stride, false, true);
      this._thinInstanceDataStorage.matrixBuffer = matrixBuffer;
      this.setVerticesBuffer(matrixBuffer.createVertexBuffer("world0", 0, 4));
      this.setVerticesBuffer(matrixBuffer.createVertexBuffer("world1", 4, 4));
      this.setVerticesBuffer(matrixBuffer.createVertexBuffer("world2", 8, 4));
      this.setVerticesBuffer(matrixBuffer.createVertexBuffer("world3", 12, 4));
      if (!this.doNotSyncBoundingInfo) {
        this.thinInstanceRefreshBoundingInfo(false);
      }
    } else {
      this._thinInstanceDataStorage.instancesCount = 0;
      if (!this.doNotSyncBoundingInfo) {
        this.refreshBoundingInfo(true);
      }
    }
  } else {
    if (buffer === null) {
      if ((_b = this._userThinInstanceBuffersStorage) === null || _b === void 0 ? void 0 : _b.data[kind]) {
        this.removeVerticesData(kind);
        delete this._userThinInstanceBuffersStorage.data[kind];
        delete this._userThinInstanceBuffersStorage.strides[kind];
        delete this._userThinInstanceBuffersStorage.sizes[kind];
        delete this._userThinInstanceBuffersStorage.vertexBuffers[kind];
      }
    } else {
      this._thinInstanceInitializeUserStorage();
      this._userThinInstanceBuffersStorage.data[kind] = buffer;
      this._userThinInstanceBuffersStorage.strides[kind] = stride;
      this._userThinInstanceBuffersStorage.sizes[kind] = buffer.length;
      this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), buffer, kind, !staticBuffer, false, stride, true);
      this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
    }
  }
};
Mesh.prototype.thinInstanceBufferUpdated = function(kind) {
  var _a;
  if (kind === "matrix") {
    if (this._thinInstanceDataStorage.matrixBuffer) {
      this._thinInstanceDataStorage.matrixBuffer.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, this._thinInstanceDataStorage.instancesCount);
    }
  } else if ((_a = this._userThinInstanceBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) {
    this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(this._userThinInstanceBuffersStorage.data[kind], 0);
  }
};
Mesh.prototype.thinInstancePartialBufferUpdate = function(kind, data, offset) {
  var _a;
  if (kind === "matrix") {
    if (this._thinInstanceDataStorage.matrixBuffer) {
      this._thinInstanceDataStorage.matrixBuffer.updateDirectly(data, offset);
    }
  } else if ((_a = this._userThinInstanceBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) {
    this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(data, offset);
  }
};
Mesh.prototype.thinInstanceGetWorldMatrices = function() {
  if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {
    return [];
  }
  var matrixData = this._thinInstanceDataStorage.matrixData;
  if (!this._thinInstanceDataStorage.worldMatrices) {
    this._thinInstanceDataStorage.worldMatrices = new Array();
    for (var i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {
      this._thinInstanceDataStorage.worldMatrices[i] = Matrix.FromArray(matrixData, i * 16);
    }
  }
  return this._thinInstanceDataStorage.worldMatrices;
};
Mesh.prototype.thinInstanceRefreshBoundingInfo = function(forceRefreshParentInfo) {
  if (forceRefreshParentInfo === void 0) {
    forceRefreshParentInfo = false;
  }
  if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {
    return;
  }
  var vectors = this._thinInstanceDataStorage.boundingVectors;
  if (forceRefreshParentInfo) {
    vectors.length = 0;
    this.refreshBoundingInfo(true);
  }
  var boundingInfo = this.getBoundingInfo();
  var matrixData = this._thinInstanceDataStorage.matrixData;
  if (vectors.length === 0) {
    for (var v = 0; v < boundingInfo.boundingBox.vectors.length; ++v) {
      vectors.push(boundingInfo.boundingBox.vectors[v].clone());
    }
  }
  TmpVectors.Vector3[0].setAll(Number.POSITIVE_INFINITY);
  TmpVectors.Vector3[1].setAll(Number.NEGATIVE_INFINITY);
  for (var i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {
    Matrix.FromArrayToRef(matrixData, i * 16, TmpVectors.Matrix[0]);
    for (var v = 0; v < vectors.length; ++v) {
      Vector3.TransformCoordinatesToRef(vectors[v], TmpVectors.Matrix[0], TmpVectors.Vector3[2]);
      TmpVectors.Vector3[0].minimizeInPlace(TmpVectors.Vector3[2]);
      TmpVectors.Vector3[1].maximizeInPlace(TmpVectors.Vector3[2]);
    }
  }
  boundingInfo.reConstruct(TmpVectors.Vector3[0], TmpVectors.Vector3[1]);
  this._updateBoundingInfo();
};
Mesh.prototype._thinInstanceUpdateBufferSize = function(kind, numInstances) {
  var _a, _b;
  if (numInstances === void 0) {
    numInstances = 1;
  }
  var kindIsMatrix = kind === "matrix";
  if (!kindIsMatrix && (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.strides[kind])) {
    return;
  }
  var stride = kindIsMatrix ? 16 : this._userThinInstanceBuffersStorage.strides[kind];
  var currentSize = kindIsMatrix ? this._thinInstanceDataStorage.matrixBufferSize : this._userThinInstanceBuffersStorage.sizes[kind];
  var data = kindIsMatrix ? this._thinInstanceDataStorage.matrixData : this._userThinInstanceBuffersStorage.data[kind];
  var bufferSize = (this._thinInstanceDataStorage.instancesCount + numInstances) * stride;
  var newSize = currentSize;
  while (newSize < bufferSize) {
    newSize *= 2;
  }
  if (!data || currentSize != newSize) {
    if (!data) {
      data = new Float32Array(newSize);
    } else {
      var newData = new Float32Array(newSize);
      newData.set(data, 0);
      data = newData;
    }
    if (kindIsMatrix) {
      (_a = this._thinInstanceDataStorage.matrixBuffer) === null || _a === void 0 ? void 0 : _a.dispose();
      var matrixBuffer = new Buffer(this.getEngine(), data, true, stride, false, true);
      this._thinInstanceDataStorage.matrixBuffer = matrixBuffer;
      this._thinInstanceDataStorage.matrixData = data;
      this._thinInstanceDataStorage.matrixBufferSize = newSize;
      this.setVerticesBuffer(matrixBuffer.createVertexBuffer("world0", 0, 4));
      this.setVerticesBuffer(matrixBuffer.createVertexBuffer("world1", 4, 4));
      this.setVerticesBuffer(matrixBuffer.createVertexBuffer("world2", 8, 4));
      this.setVerticesBuffer(matrixBuffer.createVertexBuffer("world3", 12, 4));
    } else {
      (_b = this._userThinInstanceBuffersStorage.vertexBuffers[kind]) === null || _b === void 0 ? void 0 : _b.dispose();
      this._userThinInstanceBuffersStorage.data[kind] = data;
      this._userThinInstanceBuffersStorage.sizes[kind] = newSize;
      this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), data, kind, true, false, stride, true);
      this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
    }
  }
};
Mesh.prototype._thinInstanceInitializeUserStorage = function() {
  if (!this._userThinInstanceBuffersStorage) {
    this._userThinInstanceBuffersStorage = {
      data: {},
      sizes: {},
      vertexBuffers: {},
      strides: {}
    };
  }
};
Mesh.prototype._disposeThinInstanceSpecificData = function() {
  var _a;
  if ((_a = this._thinInstanceDataStorage) === null || _a === void 0 ? void 0 : _a.matrixBuffer) {
    this._thinInstanceDataStorage.matrixBuffer.dispose();
    this._thinInstanceDataStorage.matrixBuffer = null;
  }
};

// node_modules/@babylonjs/core/Navigation/Plugins/recastJSPlugin.js
var RecastJSPlugin = function() {
  function RecastJSPlugin2(recastInjection) {
    if (recastInjection === void 0) {
      recastInjection = Recast;
    }
    this.bjsRECAST = {};
    this.name = "RecastJSPlugin";
    this._maximumSubStepCount = 10;
    this._timeStep = 1 / 60;
    if (typeof recastInjection === "function") {
      recastInjection(this.bjsRECAST);
    } else {
      this.bjsRECAST = recastInjection;
    }
    if (!this.isSupported()) {
      Logger.Error("RecastJS is not available. Please make sure you included the js file.");
      return;
    }
    this.setTimeStep();
  }
  RecastJSPlugin2.prototype.setTimeStep = function(newTimeStep) {
    if (newTimeStep === void 0) {
      newTimeStep = 1 / 60;
    }
    this._timeStep = newTimeStep;
  };
  RecastJSPlugin2.prototype.getTimeStep = function() {
    return this._timeStep;
  };
  RecastJSPlugin2.prototype.setMaximumSubStepCount = function(newStepCount) {
    if (newStepCount === void 0) {
      newStepCount = 10;
    }
    this._maximumSubStepCount = newStepCount;
  };
  RecastJSPlugin2.prototype.getMaximumSubStepCount = function() {
    return this._maximumSubStepCount;
  };
  RecastJSPlugin2.prototype.createNavMesh = function(meshes, parameters) {
    var rc = new this.bjsRECAST.rcConfig();
    rc.cs = parameters.cs;
    rc.ch = parameters.ch;
    rc.borderSize = 0;
    rc.tileSize = 0;
    rc.walkableSlopeAngle = parameters.walkableSlopeAngle;
    rc.walkableHeight = parameters.walkableHeight;
    rc.walkableClimb = parameters.walkableClimb;
    rc.walkableRadius = parameters.walkableRadius;
    rc.maxEdgeLen = parameters.maxEdgeLen;
    rc.maxSimplificationError = parameters.maxSimplificationError;
    rc.minRegionArea = parameters.minRegionArea;
    rc.mergeRegionArea = parameters.mergeRegionArea;
    rc.maxVertsPerPoly = parameters.maxVertsPerPoly;
    rc.detailSampleDist = parameters.detailSampleDist;
    rc.detailSampleMaxError = parameters.detailSampleMaxError;
    this.navMesh = new this.bjsRECAST.NavMesh();
    var index;
    var tri;
    var pt;
    var indices = [];
    var positions = [];
    var offset = 0;
    for (index = 0; index < meshes.length; index++) {
      if (meshes[index]) {
        var mesh = meshes[index];
        var meshIndices = mesh.getIndices();
        if (!meshIndices) {
          continue;
        }
        var meshPositions = mesh.getVerticesData(VertexBuffer.PositionKind, false, false);
        if (!meshPositions) {
          continue;
        }
        var wm = mesh.computeWorldMatrix(true);
        for (tri = 0; tri < meshIndices.length; tri++) {
          indices.push(meshIndices[tri] + offset);
        }
        var transformed = Vector3.Zero();
        var position = Vector3.Zero();
        for (pt = 0; pt < meshPositions.length; pt += 3) {
          Vector3.FromArrayToRef(meshPositions, pt, position);
          Vector3.TransformCoordinatesToRef(position, wm, transformed);
          positions.push(transformed.x, transformed.y, transformed.z);
        }
        offset += meshPositions.length / 3;
      }
    }
    this.navMesh.build(positions, offset, indices, indices.length, rc);
  };
  RecastJSPlugin2.prototype.createDebugNavMesh = function(scene) {
    var tri;
    var pt;
    var debugNavMesh = this.navMesh.getDebugNavMesh();
    var triangleCount = debugNavMesh.getTriangleCount();
    var indices = [];
    var positions = [];
    for (tri = 0; tri < triangleCount * 3; tri++) {
      indices.push(tri);
    }
    for (tri = 0; tri < triangleCount; tri++) {
      for (pt = 0; pt < 3; pt++) {
        var point = debugNavMesh.getTriangle(tri).getPoint(pt);
        positions.push(point.x, point.y, point.z);
      }
    }
    var mesh = new Mesh("NavMeshDebug", scene);
    var vertexData = new VertexData();
    vertexData.indices = indices;
    vertexData.positions = positions;
    vertexData.applyToMesh(mesh, false);
    return mesh;
  };
  RecastJSPlugin2.prototype.getClosestPoint = function(position) {
    var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);
    var ret = this.navMesh.getClosestPoint(p);
    var pr = new Vector3(ret.x, ret.y, ret.z);
    return pr;
  };
  RecastJSPlugin2.prototype.getClosestPointToRef = function(position, result) {
    var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);
    var ret = this.navMesh.getClosestPoint(p);
    result.set(ret.x, ret.y, ret.z);
  };
  RecastJSPlugin2.prototype.getRandomPointAround = function(position, maxRadius) {
    var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);
    var ret = this.navMesh.getRandomPointAround(p, maxRadius);
    var pr = new Vector3(ret.x, ret.y, ret.z);
    return pr;
  };
  RecastJSPlugin2.prototype.getRandomPointAroundToRef = function(position, maxRadius, result) {
    var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);
    var ret = this.navMesh.getRandomPointAround(p, maxRadius);
    result.set(ret.x, ret.y, ret.z);
  };
  RecastJSPlugin2.prototype.moveAlong = function(position, destination) {
    var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);
    var d = new this.bjsRECAST.Vec3(destination.x, destination.y, destination.z);
    var ret = this.navMesh.moveAlong(p, d);
    var pr = new Vector3(ret.x, ret.y, ret.z);
    return pr;
  };
  RecastJSPlugin2.prototype.moveAlongToRef = function(position, destination, result) {
    var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);
    var d = new this.bjsRECAST.Vec3(destination.x, destination.y, destination.z);
    var ret = this.navMesh.moveAlong(p, d);
    result.set(ret.x, ret.y, ret.z);
  };
  RecastJSPlugin2.prototype.computePath = function(start, end) {
    var pt;
    var startPos = new this.bjsRECAST.Vec3(start.x, start.y, start.z);
    var endPos = new this.bjsRECAST.Vec3(end.x, end.y, end.z);
    var navPath = this.navMesh.computePath(startPos, endPos);
    var pointCount = navPath.getPointCount();
    var positions = [];
    for (pt = 0; pt < pointCount; pt++) {
      var p = navPath.getPoint(pt);
      positions.push(new Vector3(p.x, p.y, p.z));
    }
    return positions;
  };
  RecastJSPlugin2.prototype.createCrowd = function(maxAgents, maxAgentRadius, scene) {
    var crowd = new RecastJSCrowd(this, maxAgents, maxAgentRadius, scene);
    return crowd;
  };
  RecastJSPlugin2.prototype.setDefaultQueryExtent = function(extent) {
    var ext = new this.bjsRECAST.Vec3(extent.x, extent.y, extent.z);
    this.navMesh.setDefaultQueryExtent(ext);
  };
  RecastJSPlugin2.prototype.getDefaultQueryExtent = function() {
    var p = this.navMesh.getDefaultQueryExtent();
    return new Vector3(p.x, p.y, p.z);
  };
  RecastJSPlugin2.prototype.buildFromNavmeshData = function(data) {
    var nDataBytes = data.length * data.BYTES_PER_ELEMENT;
    var dataPtr = this.bjsRECAST._malloc(nDataBytes);
    var dataHeap = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, dataPtr, nDataBytes);
    dataHeap.set(data);
    var buf = new this.bjsRECAST.NavmeshData();
    buf.dataPointer = dataHeap.byteOffset;
    buf.size = data.length;
    this.navMesh = new this.bjsRECAST.NavMesh();
    this.navMesh.buildFromNavmeshData(buf);
    this.bjsRECAST._free(dataHeap.byteOffset);
  };
  RecastJSPlugin2.prototype.getNavmeshData = function() {
    var navmeshData = this.navMesh.getNavmeshData();
    var arrView = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, navmeshData.dataPointer, navmeshData.size);
    var ret = new Uint8Array(navmeshData.size);
    ret.set(arrView);
    this.navMesh.freeNavmeshData(navmeshData);
    return ret;
  };
  RecastJSPlugin2.prototype.getDefaultQueryExtentToRef = function(result) {
    var p = this.navMesh.getDefaultQueryExtent();
    result.set(p.x, p.y, p.z);
  };
  RecastJSPlugin2.prototype.dispose = function() {
  };
  RecastJSPlugin2.prototype.isSupported = function() {
    return this.bjsRECAST !== void 0;
  };
  return RecastJSPlugin2;
}();
var RecastJSCrowd = function() {
  function RecastJSCrowd2(plugin, maxAgents, maxAgentRadius, scene) {
    var _this = this;
    this.recastCrowd = {};
    this.transforms = new Array();
    this.agents = new Array();
    this._onBeforeAnimationsObserver = null;
    this.bjsRECASTPlugin = plugin;
    this.recastCrowd = new this.bjsRECASTPlugin.bjsRECAST.Crowd(maxAgents, maxAgentRadius, this.bjsRECASTPlugin.navMesh.getNavMesh());
    this._scene = scene;
    this._onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(function() {
      _this.update(scene.getEngine().getDeltaTime() * 1e-3);
    });
  }
  RecastJSCrowd2.prototype.addAgent = function(pos, parameters, transform) {
    var agentParams = new this.bjsRECASTPlugin.bjsRECAST.dtCrowdAgentParams();
    agentParams.radius = parameters.radius;
    agentParams.height = parameters.height;
    agentParams.maxAcceleration = parameters.maxAcceleration;
    agentParams.maxSpeed = parameters.maxSpeed;
    agentParams.collisionQueryRange = parameters.collisionQueryRange;
    agentParams.pathOptimizationRange = parameters.pathOptimizationRange;
    agentParams.separationWeight = parameters.separationWeight;
    agentParams.updateFlags = 7;
    agentParams.obstacleAvoidanceType = 0;
    agentParams.queryFilterType = 0;
    agentParams.userData = 0;
    var agentIndex = this.recastCrowd.addAgent(new this.bjsRECASTPlugin.bjsRECAST.Vec3(pos.x, pos.y, pos.z), agentParams);
    this.transforms.push(transform);
    this.agents.push(agentIndex);
    return agentIndex;
  };
  RecastJSCrowd2.prototype.getAgentPosition = function(index) {
    var agentPos = this.recastCrowd.getAgentPosition(index);
    return new Vector3(agentPos.x, agentPos.y, agentPos.z);
  };
  RecastJSCrowd2.prototype.getAgentPositionToRef = function(index, result) {
    var agentPos = this.recastCrowd.getAgentPosition(index);
    result.set(agentPos.x, agentPos.y, agentPos.z);
  };
  RecastJSCrowd2.prototype.getAgentVelocity = function(index) {
    var agentVel = this.recastCrowd.getAgentVelocity(index);
    return new Vector3(agentVel.x, agentVel.y, agentVel.z);
  };
  RecastJSCrowd2.prototype.getAgentVelocityToRef = function(index, result) {
    var agentVel = this.recastCrowd.getAgentVelocity(index);
    result.set(agentVel.x, agentVel.y, agentVel.z);
  };
  RecastJSCrowd2.prototype.getAgentNextTargetPath = function(index) {
    var pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);
    return new Vector3(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);
  };
  RecastJSCrowd2.prototype.getAgentNextTargetPathToRef = function(index, result) {
    var pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);
    result.set(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);
  };
  RecastJSCrowd2.prototype.getAgentState = function(index) {
    return this.recastCrowd.getAgentState(index);
  };
  RecastJSCrowd2.prototype.overOffmeshConnection = function(index) {
    return this.recastCrowd.overOffmeshConnection(index);
  };
  RecastJSCrowd2.prototype.agentGoto = function(index, destination) {
    this.recastCrowd.agentGoto(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));
  };
  RecastJSCrowd2.prototype.agentTeleport = function(index, destination) {
    this.recastCrowd.agentTeleport(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));
  };
  RecastJSCrowd2.prototype.updateAgentParameters = function(index, parameters) {
    var agentParams = this.recastCrowd.getAgentParameters(index);
    if (parameters.radius !== void 0) {
      agentParams.radius = parameters.radius;
    }
    if (parameters.height !== void 0) {
      agentParams.height = parameters.height;
    }
    if (parameters.maxAcceleration !== void 0) {
      agentParams.maxAcceleration = parameters.maxAcceleration;
    }
    if (parameters.maxSpeed !== void 0) {
      agentParams.maxSpeed = parameters.maxSpeed;
    }
    if (parameters.collisionQueryRange !== void 0) {
      agentParams.collisionQueryRange = parameters.collisionQueryRange;
    }
    if (parameters.pathOptimizationRange !== void 0) {
      agentParams.pathOptimizationRange = parameters.pathOptimizationRange;
    }
    if (parameters.separationWeight !== void 0) {
      agentParams.separationWeight = parameters.separationWeight;
    }
    this.recastCrowd.setAgentParameters(index, agentParams);
  };
  RecastJSCrowd2.prototype.removeAgent = function(index) {
    this.recastCrowd.removeAgent(index);
    var item = this.agents.indexOf(index);
    if (item > -1) {
      this.agents.splice(item, 1);
      this.transforms.splice(item, 1);
    }
  };
  RecastJSCrowd2.prototype.getAgents = function() {
    return this.agents;
  };
  RecastJSCrowd2.prototype.update = function(deltaTime) {
    var timeStep = this.bjsRECASTPlugin.getTimeStep();
    var maxStepCount = this.bjsRECASTPlugin.getMaximumSubStepCount();
    if (timeStep <= Epsilon) {
      this.recastCrowd.update(deltaTime);
    } else {
      var iterationCount = deltaTime / timeStep;
      if (maxStepCount && iterationCount > maxStepCount) {
        iterationCount = maxStepCount;
      }
      if (iterationCount < 1) {
        iterationCount = 1;
      }
      for (var i = 0; i < iterationCount; i++) {
        this.recastCrowd.update(timeStep);
      }
    }
    for (var index = 0; index < this.agents.length; index++) {
      this.transforms[index].position = this.getAgentPosition(this.agents[index]);
    }
  };
  RecastJSCrowd2.prototype.setDefaultQueryExtent = function(extent) {
    var ext = new this.bjsRECASTPlugin.bjsRECAST.Vec3(extent.x, extent.y, extent.z);
    this.recastCrowd.setDefaultQueryExtent(ext);
  };
  RecastJSCrowd2.prototype.getDefaultQueryExtent = function() {
    var p = this.recastCrowd.getDefaultQueryExtent();
    return new Vector3(p.x, p.y, p.z);
  };
  RecastJSCrowd2.prototype.getDefaultQueryExtentToRef = function(result) {
    var p = this.recastCrowd.getDefaultQueryExtent();
    result.set(p.x, p.y, p.z);
  };
  RecastJSCrowd2.prototype.dispose = function() {
    this.recastCrowd.destroy();
    this._scene.onBeforeAnimationsObservable.remove(this._onBeforeAnimationsObserver);
    this._onBeforeAnimationsObserver = null;
  };
  return RecastJSCrowd2;
}();

// node_modules/@babylonjs/core/Offline/database.js
Engine.OfflineProviderFactory = function(urlToScene, callbackManifestChecked, disableManifestCheck) {
  if (disableManifestCheck === void 0) {
    disableManifestCheck = false;
  }
  return new Database(urlToScene, callbackManifestChecked, disableManifestCheck);
};
var Database = function() {
  function Database2(urlToScene, callbackManifestChecked, disableManifestCheck) {
    var _this = this;
    if (disableManifestCheck === void 0) {
      disableManifestCheck = false;
    }
    this._idbFactory = typeof window !== "undefined" ? window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB : indexedDB;
    this._callbackManifestChecked = callbackManifestChecked;
    this._currentSceneUrl = Database2._ReturnFullUrlLocation(urlToScene);
    this._db = null;
    this._enableSceneOffline = false;
    this._enableTexturesOffline = false;
    this._manifestVersionFound = 0;
    this._mustUpdateRessources = false;
    this._hasReachedQuota = false;
    if (!Database2.IDBStorageEnabled) {
      this._callbackManifestChecked(true);
    } else {
      if (disableManifestCheck) {
        this._enableSceneOffline = true;
        this._enableTexturesOffline = true;
        this._manifestVersionFound = 1;
        Tools.SetImmediate(function() {
          _this._callbackManifestChecked(true);
        });
      } else {
        this._checkManifestFile();
      }
    }
  }
  Object.defineProperty(Database2.prototype, "enableSceneOffline", {
    get: function() {
      return this._enableSceneOffline;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Database2.prototype, "enableTexturesOffline", {
    get: function() {
      return this._enableTexturesOffline;
    },
    enumerable: false,
    configurable: true
  });
  Database2.prototype._checkManifestFile = function() {
    var _this = this;
    var noManifestFile = function() {
      _this._enableSceneOffline = false;
      _this._enableTexturesOffline = false;
      _this._callbackManifestChecked(false);
    };
    var timeStampUsed = false;
    var manifestURL = this._currentSceneUrl + ".manifest";
    var xhr = new WebRequest();
    if (navigator.onLine) {
      timeStampUsed = true;
      manifestURL = manifestURL + (manifestURL.match(/\?/) == null ? "?" : "&") + Date.now();
    }
    xhr.open("GET", manifestURL);
    xhr.addEventListener("load", function() {
      if (xhr.status === 200 || Database2._ValidateXHRData(xhr, 1)) {
        try {
          var manifestFile = JSON.parse(xhr.response);
          _this._enableSceneOffline = manifestFile.enableSceneOffline;
          _this._enableTexturesOffline = manifestFile.enableTexturesOffline && Database2.IsUASupportingBlobStorage;
          if (manifestFile.version && !isNaN(parseInt(manifestFile.version))) {
            _this._manifestVersionFound = manifestFile.version;
          }
          if (_this._callbackManifestChecked) {
            _this._callbackManifestChecked(true);
          }
        } catch (ex) {
          noManifestFile();
        }
      } else {
        noManifestFile();
      }
    }, false);
    xhr.addEventListener("error", function() {
      if (timeStampUsed) {
        timeStampUsed = false;
        var retryManifestURL = _this._currentSceneUrl + ".manifest";
        xhr.open("GET", retryManifestURL);
        xhr.send();
      } else {
        noManifestFile();
      }
    }, false);
    try {
      xhr.send();
    } catch (ex) {
      Logger.Error("Error on XHR send request.");
      this._callbackManifestChecked(false);
    }
  };
  Database2.prototype.open = function(successCallback, errorCallback) {
    var _this = this;
    var handleError = function() {
      _this._isSupported = false;
      if (errorCallback) {
        errorCallback();
      }
    };
    if (!this._idbFactory || !(this._enableSceneOffline || this._enableTexturesOffline)) {
      this._isSupported = false;
      if (errorCallback) {
        errorCallback();
      }
    } else {
      if (!this._db) {
        this._hasReachedQuota = false;
        this._isSupported = true;
        var request = this._idbFactory.open("babylonjs", 1);
        request.onerror = function() {
          handleError();
        };
        request.onblocked = function() {
          Logger.Error("IDB request blocked. Please reload the page.");
          handleError();
        };
        request.onsuccess = function() {
          _this._db = request.result;
          successCallback();
        };
        request.onupgradeneeded = function(event) {
          _this._db = event.target.result;
          if (_this._db) {
            try {
              _this._db.createObjectStore("scenes", { keyPath: "sceneUrl" });
              _this._db.createObjectStore("versions", { keyPath: "sceneUrl" });
              _this._db.createObjectStore("textures", { keyPath: "textureUrl" });
            } catch (ex) {
              Logger.Error("Error while creating object stores. Exception: " + ex.message);
              handleError();
            }
          }
        };
      } else {
        if (successCallback) {
          successCallback();
        }
      }
    }
  };
  Database2.prototype.loadImage = function(url, image) {
    var _this = this;
    var completeURL = Database2._ReturnFullUrlLocation(url);
    var saveAndLoadImage = function() {
      if (!_this._hasReachedQuota && _this._db !== null) {
        _this._saveImageIntoDBAsync(completeURL, image);
      } else {
        image.src = url;
      }
    };
    if (!this._mustUpdateRessources) {
      this._loadImageFromDBAsync(completeURL, image, saveAndLoadImage);
    } else {
      saveAndLoadImage();
    }
  };
  Database2.prototype._loadImageFromDBAsync = function(url, image, notInDBCallback) {
    if (this._isSupported && this._db !== null) {
      var texture;
      var transaction = this._db.transaction(["textures"]);
      transaction.onabort = function() {
        image.src = url;
      };
      transaction.oncomplete = function() {
        var blobTextureURL;
        if (texture) {
          var URL2 = window.URL || window.webkitURL;
          blobTextureURL = URL2.createObjectURL(texture.data);
          image.onerror = function() {
            Logger.Error("Error loading image from blob URL: " + blobTextureURL + " switching back to web url: " + url);
            image.src = url;
          };
          image.src = blobTextureURL;
        } else {
          notInDBCallback();
        }
      };
      var getRequest = transaction.objectStore("textures").get(url);
      getRequest.onsuccess = function(event) {
        texture = event.target.result;
      };
      getRequest.onerror = function() {
        Logger.Error("Error loading texture " + url + " from DB.");
        image.src = url;
      };
    } else {
      Logger.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open.");
      image.src = url;
    }
  };
  Database2.prototype._saveImageIntoDBAsync = function(url, image) {
    var _this = this;
    if (this._isSupported) {
      var generateBlobUrl = function() {
        var blobTextureURL;
        if (blob) {
          var URL2 = window.URL || window.webkitURL;
          try {
            blobTextureURL = URL2.createObjectURL(blob);
          } catch (ex) {
            blobTextureURL = URL2.createObjectURL(blob);
          }
        }
        if (blobTextureURL) {
          image.src = blobTextureURL;
        }
      };
      if (Database2.IsUASupportingBlobStorage) {
        var xhr = new WebRequest(), blob;
        xhr.open("GET", url);
        xhr.responseType = "blob";
        xhr.addEventListener("load", function() {
          if (xhr.status === 200 && _this._db) {
            blob = xhr.response;
            var transaction = _this._db.transaction(["textures"], "readwrite");
            transaction.onabort = function(event) {
              try {
                var srcElement = event.srcElement || event.target;
                var error = srcElement.error;
                if (error && error.name === "QuotaExceededError") {
                  _this._hasReachedQuota = true;
                }
              } catch (ex) {
              }
              generateBlobUrl();
            };
            transaction.oncomplete = function() {
              generateBlobUrl();
            };
            var newTexture = { textureUrl: url, data: blob };
            try {
              var addRequest = transaction.objectStore("textures").put(newTexture);
              addRequest.onsuccess = function() {
              };
              addRequest.onerror = function() {
                generateBlobUrl();
              };
            } catch (ex) {
              if (ex.code === 25) {
                Database2.IsUASupportingBlobStorage = false;
                _this._enableTexturesOffline = false;
              }
              image.src = url;
            }
          } else {
            image.src = url;
          }
        }, false);
        xhr.addEventListener("error", function() {
          Logger.Error("Error in XHR request in BABYLON.Database.");
          image.src = url;
        }, false);
        xhr.send();
      } else {
        image.src = url;
      }
    } else {
      Logger.Error("Error: IndexedDB not supported by your browser or Babylon.js database is not open.");
      image.src = url;
    }
  };
  Database2.prototype._checkVersionFromDB = function(url, versionLoaded) {
    var _this = this;
    var updateVersion = function() {
      _this._saveVersionIntoDBAsync(url, versionLoaded);
    };
    this._loadVersionFromDBAsync(url, versionLoaded, updateVersion);
  };
  Database2.prototype._loadVersionFromDBAsync = function(url, callback, updateInDBCallback) {
    var _this = this;
    if (this._isSupported && this._db) {
      var version;
      try {
        var transaction = this._db.transaction(["versions"]);
        transaction.oncomplete = function() {
          if (version) {
            if (_this._manifestVersionFound !== version.data) {
              _this._mustUpdateRessources = true;
              updateInDBCallback();
            } else {
              callback(version.data);
            }
          } else {
            _this._mustUpdateRessources = true;
            updateInDBCallback();
          }
        };
        transaction.onabort = function() {
          callback(-1);
        };
        var getRequest = transaction.objectStore("versions").get(url);
        getRequest.onsuccess = function(event) {
          version = event.target.result;
        };
        getRequest.onerror = function() {
          Logger.Error("Error loading version for scene " + url + " from DB.");
          callback(-1);
        };
      } catch (ex) {
        Logger.Error("Error while accessing 'versions' object store (READ OP). Exception: " + ex.message);
        callback(-1);
      }
    } else {
      Logger.Error("Error: IndexedDB not supported by your browser or Babylon.js database is not open.");
      callback(-1);
    }
  };
  Database2.prototype._saveVersionIntoDBAsync = function(url, callback) {
    var _this = this;
    if (this._isSupported && !this._hasReachedQuota && this._db) {
      try {
        var transaction = this._db.transaction(["versions"], "readwrite");
        transaction.onabort = function(event) {
          try {
            var error = event.srcElement["error"];
            if (error && error.name === "QuotaExceededError") {
              _this._hasReachedQuota = true;
            }
          } catch (ex) {
          }
          callback(-1);
        };
        transaction.oncomplete = function() {
          callback(_this._manifestVersionFound);
        };
        var newVersion = { sceneUrl: url, data: this._manifestVersionFound };
        var addRequest = transaction.objectStore("versions").put(newVersion);
        addRequest.onsuccess = function() {
        };
        addRequest.onerror = function() {
          Logger.Error("Error in DB add version request in BABYLON.Database.");
        };
      } catch (ex) {
        Logger.Error("Error while accessing 'versions' object store (WRITE OP). Exception: " + ex.message);
        callback(-1);
      }
    } else {
      callback(-1);
    }
  };
  Database2.prototype.loadFile = function(url, sceneLoaded, progressCallBack, errorCallback, useArrayBuffer) {
    var _this = this;
    var completeUrl = Database2._ReturnFullUrlLocation(url);
    var saveAndLoadFile = function() {
      _this._saveFileAsync(completeUrl, sceneLoaded, progressCallBack, useArrayBuffer, errorCallback);
    };
    this._checkVersionFromDB(completeUrl, function(version) {
      if (version !== -1) {
        if (!_this._mustUpdateRessources) {
          _this._loadFileAsync(completeUrl, sceneLoaded, saveAndLoadFile);
        } else {
          _this._saveFileAsync(completeUrl, sceneLoaded, progressCallBack, useArrayBuffer, errorCallback);
        }
      } else {
        if (errorCallback) {
          errorCallback();
        }
      }
    });
  };
  Database2.prototype._loadFileAsync = function(url, callback, notInDBCallback) {
    if (this._isSupported && this._db) {
      var targetStore;
      if (url.indexOf(".babylon") !== -1) {
        targetStore = "scenes";
      } else {
        targetStore = "textures";
      }
      var file;
      var transaction = this._db.transaction([targetStore]);
      transaction.oncomplete = function() {
        if (file) {
          callback(file.data);
        } else {
          notInDBCallback();
        }
      };
      transaction.onabort = function() {
        notInDBCallback();
      };
      var getRequest = transaction.objectStore(targetStore).get(url);
      getRequest.onsuccess = function(event) {
        file = event.target.result;
      };
      getRequest.onerror = function() {
        Logger.Error("Error loading file " + url + " from DB.");
        notInDBCallback();
      };
    } else {
      Logger.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open.");
      callback();
    }
  };
  Database2.prototype._saveFileAsync = function(url, callback, progressCallback, useArrayBuffer, errorCallback) {
    var _this = this;
    if (this._isSupported) {
      var targetStore;
      if (url.indexOf(".babylon") !== -1) {
        targetStore = "scenes";
      } else {
        targetStore = "textures";
      }
      var xhr = new WebRequest();
      var fileData;
      xhr.open("GET", url + "?" + Date.now());
      if (useArrayBuffer) {
        xhr.responseType = "arraybuffer";
      }
      if (progressCallback) {
        xhr.onprogress = progressCallback;
      }
      xhr.addEventListener("load", function() {
        if (xhr.status === 200 || xhr.status < 400 && Database2._ValidateXHRData(xhr, !useArrayBuffer ? 1 : 6)) {
          fileData = !useArrayBuffer ? xhr.responseText : xhr.response;
          if (!_this._hasReachedQuota && _this._db) {
            var transaction = _this._db.transaction([targetStore], "readwrite");
            transaction.onabort = function(event) {
              try {
                var error = event.srcElement["error"];
                if (error && error.name === "QuotaExceededError") {
                  _this._hasReachedQuota = true;
                }
              } catch (ex) {
              }
              callback(fileData);
            };
            transaction.oncomplete = function() {
              callback(fileData);
            };
            var newFile;
            if (targetStore === "scenes") {
              newFile = { sceneUrl: url, data: fileData, version: _this._manifestVersionFound };
            } else {
              newFile = { textureUrl: url, data: fileData };
            }
            try {
              var addRequest = transaction.objectStore(targetStore).put(newFile);
              addRequest.onsuccess = function() {
              };
              addRequest.onerror = function() {
                Logger.Error("Error in DB add file request in BABYLON.Database.");
              };
            } catch (ex) {
              callback(fileData);
            }
          } else {
            callback(fileData);
          }
        } else {
          if (xhr.status >= 400 && errorCallback) {
            errorCallback(xhr);
          } else {
            callback();
          }
        }
      }, false);
      xhr.addEventListener("error", function() {
        Logger.Error("error on XHR request.");
        callback();
      }, false);
      xhr.send();
    } else {
      Logger.Error("Error: IndexedDB not supported by your browser or Babylon.js database is not open.");
      callback();
    }
  };
  Database2._ValidateXHRData = function(xhr, dataType) {
    if (dataType === void 0) {
      dataType = 7;
    }
    try {
      if (dataType & 1) {
        if (xhr.responseText && xhr.responseText.length > 0) {
          return true;
        } else if (dataType === 1) {
          return false;
        }
      }
      if (dataType & 2) {
        var tgaHeader = TGATools.GetTGAHeader(xhr.response);
        if (tgaHeader.width && tgaHeader.height && tgaHeader.width > 0 && tgaHeader.height > 0) {
          return true;
        } else if (dataType === 2) {
          return false;
        }
      }
      if (dataType & 4) {
        var ddsHeader = new Uint8Array(xhr.response, 0, 3);
        if (ddsHeader[0] === 68 && ddsHeader[1] === 68 && ddsHeader[2] === 83) {
          return true;
        } else {
          return false;
        }
      }
    } catch (e) {
    }
    return false;
  };
  Database2.IsUASupportingBlobStorage = true;
  Database2.IDBStorageEnabled = false;
  Database2._ParseURL = function(url) {
    var a = document.createElement("a");
    a.href = url;
    var urlWithoutHash = url.substring(0, url.lastIndexOf("#"));
    var fileName = url.substring(urlWithoutHash.lastIndexOf("/") + 1, url.length);
    var absLocation = url.substring(0, url.indexOf(fileName, 0));
    return absLocation;
  };
  Database2._ReturnFullUrlLocation = function(url) {
    if (url.indexOf("http:/") === -1 && url.indexOf("https:/") === -1 && typeof window !== "undefined") {
      return Database2._ParseURL(window.location.href) + url;
    } else {
      return url;
    }
  };
  return Database2;
}();

// node_modules/@babylonjs/core/Misc/gradients.js
var ColorGradient = function() {
  function ColorGradient2(gradient, color1, color2) {
    this.gradient = gradient;
    this.color1 = color1;
    this.color2 = color2;
  }
  ColorGradient2.prototype.getColorToRef = function(result) {
    if (!this.color2) {
      result.copyFrom(this.color1);
      return;
    }
    Color4.LerpToRef(this.color1, this.color2, Math.random(), result);
  };
  return ColorGradient2;
}();
var Color3Gradient = function() {
  function Color3Gradient2(gradient, color) {
    this.gradient = gradient;
    this.color = color;
  }
  return Color3Gradient2;
}();
var FactorGradient = function() {
  function FactorGradient2(gradient, factor1, factor2) {
    this.gradient = gradient;
    this.factor1 = factor1;
    this.factor2 = factor2;
  }
  FactorGradient2.prototype.getFactor = function() {
    if (this.factor2 === void 0 || this.factor2 === this.factor1) {
      return this.factor1;
    }
    return this.factor1 + (this.factor2 - this.factor1) * Math.random();
  };
  return FactorGradient2;
}();
var GradientHelper = function() {
  function GradientHelper2() {
  }
  GradientHelper2.GetCurrentGradient = function(ratio, gradients, updateFunc) {
    if (gradients[0].gradient > ratio) {
      updateFunc(gradients[0], gradients[0], 1);
      return;
    }
    for (var gradientIndex = 0; gradientIndex < gradients.length - 1; gradientIndex++) {
      var currentGradient = gradients[gradientIndex];
      var nextGradient = gradients[gradientIndex + 1];
      if (ratio >= currentGradient.gradient && ratio <= nextGradient.gradient) {
        var scale = (ratio - currentGradient.gradient) / (nextGradient.gradient - currentGradient.gradient);
        updateFunc(currentGradient, nextGradient, scale);
        return;
      }
    }
    var lastIndex = gradients.length - 1;
    updateFunc(gradients[lastIndex], gradients[lastIndex], 1);
  };
  return GradientHelper2;
}();

// node_modules/@babylonjs/core/Particles/particle.js
var Particle = function() {
  function Particle2(particleSystem) {
    this.particleSystem = particleSystem;
    this.position = Vector3.Zero();
    this.direction = Vector3.Zero();
    this.color = new Color4(0, 0, 0, 0);
    this.colorStep = new Color4(0, 0, 0, 0);
    this.lifeTime = 1;
    this.age = 0;
    this.size = 0;
    this.scale = new Vector2(1, 1);
    this.angle = 0;
    this.angularSpeed = 0;
    this.cellIndex = 0;
    this._attachedSubEmitters = null;
    this._currentColor1 = new Color4(0, 0, 0, 0);
    this._currentColor2 = new Color4(0, 0, 0, 0);
    this._currentSize1 = 0;
    this._currentSize2 = 0;
    this._currentAngularSpeed1 = 0;
    this._currentAngularSpeed2 = 0;
    this._currentVelocity1 = 0;
    this._currentVelocity2 = 0;
    this._currentLimitVelocity1 = 0;
    this._currentLimitVelocity2 = 0;
    this._currentDrag1 = 0;
    this._currentDrag2 = 0;
    this.id = Particle2._Count++;
    if (!this.particleSystem.isAnimationSheetEnabled) {
      return;
    }
    this.updateCellInfoFromSystem();
  }
  Particle2.prototype.updateCellInfoFromSystem = function() {
    this.cellIndex = this.particleSystem.startSpriteCellID;
  };
  Particle2.prototype.updateCellIndex = function() {
    var offsetAge = this.age;
    var changeSpeed = this.particleSystem.spriteCellChangeSpeed;
    if (this.particleSystem.spriteRandomStartCell) {
      if (this._randomCellOffset === void 0) {
        this._randomCellOffset = Math.random() * this.lifeTime;
      }
      if (changeSpeed === 0) {
        changeSpeed = 1;
        offsetAge = this._randomCellOffset;
      } else {
        offsetAge += this._randomCellOffset;
      }
    }
    var dist = this._initialEndSpriteCellID - this._initialStartSpriteCellID;
    var ratio = Scalar.Clamp(offsetAge * changeSpeed % this.lifeTime / this.lifeTime);
    this.cellIndex = this._initialStartSpriteCellID + ratio * dist | 0;
  };
  Particle2.prototype._inheritParticleInfoToSubEmitter = function(subEmitter) {
    if (subEmitter.particleSystem.emitter.position) {
      var emitterMesh = subEmitter.particleSystem.emitter;
      emitterMesh.position.copyFrom(this.position);
      if (subEmitter.inheritDirection) {
        var temp = TmpVectors.Vector3[0];
        this.direction.normalizeToRef(temp);
        emitterMesh.setDirection(temp, 0, Math.PI / 2);
      }
    } else {
      var emitterPosition = subEmitter.particleSystem.emitter;
      emitterPosition.copyFrom(this.position);
    }
    this.direction.scaleToRef(subEmitter.inheritedVelocityAmount / 2, TmpVectors.Vector3[0]);
    subEmitter.particleSystem._inheritedVelocityOffset.copyFrom(TmpVectors.Vector3[0]);
  };
  Particle2.prototype._inheritParticleInfoToSubEmitters = function() {
    var _this = this;
    if (this._attachedSubEmitters && this._attachedSubEmitters.length > 0) {
      this._attachedSubEmitters.forEach(function(subEmitter) {
        _this._inheritParticleInfoToSubEmitter(subEmitter);
      });
    }
  };
  Particle2.prototype._reset = function() {
    this.age = 0;
    this.id = Particle2._Count++;
    this._currentColorGradient = null;
    this._currentSizeGradient = null;
    this._currentAngularSpeedGradient = null;
    this._currentVelocityGradient = null;
    this._currentLimitVelocityGradient = null;
    this._currentDragGradient = null;
    this.cellIndex = this.particleSystem.startSpriteCellID;
    this._randomCellOffset = void 0;
  };
  Particle2.prototype.copyTo = function(other) {
    other.position.copyFrom(this.position);
    if (this._initialDirection) {
      if (other._initialDirection) {
        other._initialDirection.copyFrom(this._initialDirection);
      } else {
        other._initialDirection = this._initialDirection.clone();
      }
    } else {
      other._initialDirection = null;
    }
    other.direction.copyFrom(this.direction);
    if (this._localPosition) {
      if (other._localPosition) {
        other._localPosition.copyFrom(this._localPosition);
      } else {
        other._localPosition = this._localPosition.clone();
      }
    }
    other.color.copyFrom(this.color);
    other.colorStep.copyFrom(this.colorStep);
    other.lifeTime = this.lifeTime;
    other.age = this.age;
    other._randomCellOffset = this._randomCellOffset;
    other.size = this.size;
    other.scale.copyFrom(this.scale);
    other.angle = this.angle;
    other.angularSpeed = this.angularSpeed;
    other.particleSystem = this.particleSystem;
    other.cellIndex = this.cellIndex;
    other.id = this.id;
    other._attachedSubEmitters = this._attachedSubEmitters;
    if (this._currentColorGradient) {
      other._currentColorGradient = this._currentColorGradient;
      other._currentColor1.copyFrom(this._currentColor1);
      other._currentColor2.copyFrom(this._currentColor2);
    }
    if (this._currentSizeGradient) {
      other._currentSizeGradient = this._currentSizeGradient;
      other._currentSize1 = this._currentSize1;
      other._currentSize2 = this._currentSize2;
    }
    if (this._currentAngularSpeedGradient) {
      other._currentAngularSpeedGradient = this._currentAngularSpeedGradient;
      other._currentAngularSpeed1 = this._currentAngularSpeed1;
      other._currentAngularSpeed2 = this._currentAngularSpeed2;
    }
    if (this._currentVelocityGradient) {
      other._currentVelocityGradient = this._currentVelocityGradient;
      other._currentVelocity1 = this._currentVelocity1;
      other._currentVelocity2 = this._currentVelocity2;
    }
    if (this._currentLimitVelocityGradient) {
      other._currentLimitVelocityGradient = this._currentLimitVelocityGradient;
      other._currentLimitVelocity1 = this._currentLimitVelocity1;
      other._currentLimitVelocity2 = this._currentLimitVelocity2;
    }
    if (this._currentDragGradient) {
      other._currentDragGradient = this._currentDragGradient;
      other._currentDrag1 = this._currentDrag1;
      other._currentDrag2 = this._currentDrag2;
    }
    if (this.particleSystem.isAnimationSheetEnabled) {
      other._initialStartSpriteCellID = this._initialStartSpriteCellID;
      other._initialEndSpriteCellID = this._initialEndSpriteCellID;
    }
    if (this.particleSystem.useRampGradients) {
      if (other.remapData && this.remapData) {
        other.remapData.copyFrom(this.remapData);
      } else {
        other.remapData = new Vector4(0, 0, 0, 0);
      }
    }
    if (this._randomNoiseCoordinates1) {
      if (other._randomNoiseCoordinates1) {
        other._randomNoiseCoordinates1.copyFrom(this._randomNoiseCoordinates1);
        other._randomNoiseCoordinates2.copyFrom(this._randomNoiseCoordinates2);
      } else {
        other._randomNoiseCoordinates1 = this._randomNoiseCoordinates1.clone();
        other._randomNoiseCoordinates2 = this._randomNoiseCoordinates2.clone();
      }
    }
  };
  Particle2._Count = 0;
  return Particle2;
}();

// node_modules/@babylonjs/core/Particles/subEmitter.js
var SubEmitterType;
(function(SubEmitterType2) {
  SubEmitterType2[SubEmitterType2["ATTACHED"] = 0] = "ATTACHED";
  SubEmitterType2[SubEmitterType2["END"] = 1] = "END";
})(SubEmitterType || (SubEmitterType = {}));
var SubEmitter = function() {
  function SubEmitter2(particleSystem) {
    this.particleSystem = particleSystem;
    this.type = SubEmitterType.END;
    this.inheritDirection = false;
    this.inheritedVelocityAmount = 0;
    if (!particleSystem.emitter || !particleSystem.emitter.dispose) {
      var internalClass = _TypeStore.GetClass("BABYLON.AbstractMesh");
      particleSystem.emitter = new internalClass("SubemitterSystemEmitter", particleSystem.getScene());
    }
    particleSystem.onDisposeObservable.add(function() {
      if (particleSystem.emitter && particleSystem.emitter.dispose) {
        particleSystem.emitter.dispose();
      }
    });
  }
  SubEmitter2.prototype.clone = function() {
    var emitter = this.particleSystem.emitter;
    if (!emitter) {
      emitter = new Vector3();
    } else if (emitter instanceof Vector3) {
      emitter = emitter.clone();
    } else if (emitter.getClassName().indexOf("Mesh") !== -1) {
      var internalClass = _TypeStore.GetClass("BABYLON.Mesh");
      emitter = new internalClass("", emitter.getScene());
      emitter.isVisible = false;
    }
    var clone = new SubEmitter2(this.particleSystem.clone("", emitter));
    clone.particleSystem.name += "Clone";
    clone.type = this.type;
    clone.inheritDirection = this.inheritDirection;
    clone.inheritedVelocityAmount = this.inheritedVelocityAmount;
    clone.particleSystem._disposeEmitterOnDispose = true;
    clone.particleSystem.disposeOnStop = true;
    return clone;
  };
  SubEmitter2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.type = this.type;
    serializationObject.inheritDirection = this.inheritDirection;
    serializationObject.inheritedVelocityAmount = this.inheritedVelocityAmount;
    serializationObject.particleSystem = this.particleSystem.serialize();
    return serializationObject;
  };
  SubEmitter2._ParseParticleSystem = function(system, sceneOrEngine, rootUrl) {
    throw _DevTools.WarnImport("ParseParticle");
  };
  SubEmitter2.Parse = function(serializationObject, sceneOrEngine, rootUrl) {
    var system = serializationObject.particleSystem;
    var subEmitter = new SubEmitter2(SubEmitter2._ParseParticleSystem(system, sceneOrEngine, rootUrl));
    subEmitter.type = serializationObject.type;
    subEmitter.inheritDirection = serializationObject.inheritDirection;
    subEmitter.inheritedVelocityAmount = serializationObject.inheritedVelocityAmount;
    subEmitter.particleSystem._isSubEmitter = true;
    return subEmitter;
  };
  SubEmitter2.prototype.dispose = function() {
    this.particleSystem.dispose();
  };
  return SubEmitter2;
}();

// node_modules/@babylonjs/core/Shaders/particles.fragment.js
var name45 = "particlesPixelShader";
var shader45 = "\nvarying vec2 vUV;\nvarying vec4 vColor;\nuniform vec4 textureMask;\nuniform sampler2D diffuseSampler;\n#include<clipPlaneFragmentDeclaration>\n#include<imageProcessingDeclaration>\n#include<helperFunctions>\n#include<imageProcessingFunctions>\n#ifdef RAMPGRADIENT\nvarying vec4 remapRanges;\nuniform sampler2D rampSampler;\n#endif\nvoid main(void) {\n#include<clipPlaneFragment>\nvec4 textureColor=texture2D(diffuseSampler,vUV);\nvec4 baseColor=(textureColor*textureMask+(vec4(1.,1.,1.,1.)-textureMask))*vColor;\n#ifdef RAMPGRADIENT\nfloat alpha=baseColor.a;\nfloat remappedColorIndex=clamp((alpha-remapRanges.x)/remapRanges.y,0.0,1.0);\nvec4 rampColor=texture2D(rampSampler,vec2(1.0-remappedColorIndex,0.));\nbaseColor.rgb*=rampColor.rgb;\n\nfloat finalAlpha=baseColor.a;\nbaseColor.a=clamp((alpha*rampColor.a-remapRanges.z)/remapRanges.w,0.0,1.0);\n#endif\n#ifdef BLENDMULTIPLYMODE\nfloat sourceAlpha=vColor.a*textureColor.a;\nbaseColor.rgb=baseColor.rgb*sourceAlpha+vec3(1.0)*(1.0-sourceAlpha);\n#endif\n\n\n#ifdef IMAGEPROCESSINGPOSTPROCESS\nbaseColor.rgb=toLinearSpace(baseColor.rgb);\n#else\n#ifdef IMAGEPROCESSING\nbaseColor.rgb=toLinearSpace(baseColor.rgb);\nbaseColor=applyImageProcessing(baseColor);\n#endif\n#endif\ngl_FragColor=baseColor;\n}";
Effect.ShadersStore[name45] = shader45;

// node_modules/@babylonjs/core/Shaders/particles.vertex.js
var name46 = "particlesVertexShader";
var shader46 = "\nattribute vec3 position;\nattribute vec4 color;\nattribute float angle;\nattribute vec2 size;\n#ifdef ANIMATESHEET\nattribute float cellIndex;\n#endif\n#ifndef BILLBOARD\nattribute vec3 direction;\n#endif\n#ifdef BILLBOARDSTRETCHED\nattribute vec3 direction;\n#endif\n#ifdef RAMPGRADIENT\nattribute vec4 remapData;\n#endif\nattribute vec2 offset;\n\nuniform mat4 view;\nuniform mat4 projection;\nuniform vec2 translationPivot;\n#ifdef ANIMATESHEET\nuniform vec3 particlesInfos;\n#endif\n\nvarying vec2 vUV;\nvarying vec4 vColor;\nvarying vec3 vPositionW;\n#ifdef RAMPGRADIENT\nvarying vec4 remapRanges;\n#endif\n#if defined(BILLBOARD) && !defined(BILLBOARDY) && !defined(BILLBOARDSTRETCHED)\nuniform mat4 invView;\n#endif\n#include<clipPlaneVertexDeclaration>\n#ifdef BILLBOARD\nuniform vec3 eyePosition;\n#endif\nvec3 rotate(vec3 yaxis,vec3 rotatedCorner) {\nvec3 xaxis=normalize(cross(vec3(0.,1.0,0.),yaxis));\nvec3 zaxis=normalize(cross(yaxis,xaxis));\nvec3 row0=vec3(xaxis.x,xaxis.y,xaxis.z);\nvec3 row1=vec3(yaxis.x,yaxis.y,yaxis.z);\nvec3 row2=vec3(zaxis.x,zaxis.y,zaxis.z);\nmat3 rotMatrix=mat3(row0,row1,row2);\nvec3 alignedCorner=rotMatrix*rotatedCorner;\nreturn position+alignedCorner;\n}\n#ifdef BILLBOARDSTRETCHED\nvec3 rotateAlign(vec3 toCamera,vec3 rotatedCorner) {\nvec3 normalizedToCamera=normalize(toCamera);\nvec3 normalizedCrossDirToCamera=normalize(cross(normalize(direction),normalizedToCamera));\nvec3 crossProduct=normalize(cross(normalizedToCamera,normalizedCrossDirToCamera));\nvec3 row0=vec3(normalizedCrossDirToCamera.x,normalizedCrossDirToCamera.y,normalizedCrossDirToCamera.z);\nvec3 row1=vec3(crossProduct.x,crossProduct.y,crossProduct.z);\nvec3 row2=vec3(normalizedToCamera.x,normalizedToCamera.y,normalizedToCamera.z);\nmat3 rotMatrix=mat3(row0,row1,row2);\nvec3 alignedCorner=rotMatrix*rotatedCorner;\nreturn position+alignedCorner;\n}\n#endif\nvoid main(void) {\nvec2 cornerPos;\ncornerPos=(vec2(offset.x-0.5,offset.y-0.5)-translationPivot)*size+translationPivot;\n#ifdef BILLBOARD\n\nvec3 rotatedCorner;\n#ifdef BILLBOARDY\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\nrotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\nrotatedCorner.y=0.;\nvec3 yaxis=position-eyePosition;\nyaxis.y=0.;\nvPositionW=rotate(normalize(yaxis),rotatedCorner);\nvec3 viewPos=(view*vec4(vPositionW,1.0)).xyz;\n#elif defined(BILLBOARDSTRETCHED)\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\nrotatedCorner.z=0.;\nvec3 toCamera=position-eyePosition;\nvPositionW=rotateAlign(toCamera,rotatedCorner);\nvec3 viewPos=(view*vec4(vPositionW,1.0)).xyz;\n#else\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\nrotatedCorner.z=0.;\nvec3 viewPos=(view*vec4(position,1.0)).xyz+rotatedCorner;\nvPositionW=(invView*vec4(viewPos,1)).xyz;\n#endif\n#ifdef RAMPGRADIENT\nremapRanges=remapData;\n#endif\n\ngl_Position=projection*vec4(viewPos,1.0);\n#else\n\nvec3 rotatedCorner;\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\nrotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\nrotatedCorner.y=0.;\nvec3 yaxis=normalize(direction);\nvPositionW=rotate(yaxis,rotatedCorner);\ngl_Position=projection*view*vec4(vPositionW,1.0);\n#endif\nvColor=color;\n#ifdef ANIMATESHEET\nfloat rowOffset=floor(cellIndex*particlesInfos.z);\nfloat columnOffset=cellIndex-rowOffset/particlesInfos.z;\nvec2 uvScale=particlesInfos.xy;\nvec2 uvOffset=vec2(offset.x ,1.0-offset.y);\nvUV=(uvOffset+vec2(columnOffset,rowOffset))*uvScale;\n#else\nvUV=offset;\n#endif\n\n#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nvec4 worldPos=vec4(vPositionW,1.0);\n#endif\n#include<clipPlaneVertex>\n}";
Effect.ShadersStore[name46] = shader46;

// node_modules/@babylonjs/core/Particles/particleSystem.js
var ParticleSystem = function(_super) {
  __extends(ParticleSystem2, _super);
  function ParticleSystem2(name98, capacity, sceneOrEngine, customEffect, isAnimationSheetEnabled, epsilon) {
    if (customEffect === void 0) {
      customEffect = null;
    }
    if (isAnimationSheetEnabled === void 0) {
      isAnimationSheetEnabled = false;
    }
    if (epsilon === void 0) {
      epsilon = 0.01;
    }
    var _this = _super.call(this, name98) || this;
    _this._inheritedVelocityOffset = new Vector3();
    _this.onDisposeObservable = new Observable();
    _this.onStoppedObservable = new Observable();
    _this._particles = new Array();
    _this._stockParticles = new Array();
    _this._newPartsExcess = 0;
    _this._vertexBuffers = {};
    _this._scaledColorStep = new Color4(0, 0, 0, 0);
    _this._colorDiff = new Color4(0, 0, 0, 0);
    _this._scaledDirection = Vector3.Zero();
    _this._scaledGravity = Vector3.Zero();
    _this._currentRenderId = -1;
    _this._useInstancing = false;
    _this._started = false;
    _this._stopped = false;
    _this._actualFrame = 0;
    _this._currentEmitRate1 = 0;
    _this._currentEmitRate2 = 0;
    _this._currentStartSize1 = 0;
    _this._currentStartSize2 = 0;
    _this._rawTextureWidth = 256;
    _this._useRampGradients = false;
    _this._disposeEmitterOnDispose = false;
    _this.isLocal = false;
    _this._onBeforeDrawParticlesObservable = null;
    _this.recycleParticle = function(particle) {
      var lastParticle = _this._particles.pop();
      if (lastParticle !== particle) {
        lastParticle.copyTo(particle);
      }
      _this._stockParticles.push(lastParticle);
    };
    _this._createParticle = function() {
      var particle;
      if (_this._stockParticles.length !== 0) {
        particle = _this._stockParticles.pop();
        particle._reset();
      } else {
        particle = new Particle(_this);
      }
      if (_this._subEmitters && _this._subEmitters.length > 0) {
        var subEmitters = _this._subEmitters[Math.floor(Math.random() * _this._subEmitters.length)];
        particle._attachedSubEmitters = [];
        subEmitters.forEach(function(subEmitter) {
          if (subEmitter.type === SubEmitterType.ATTACHED) {
            var newEmitter = subEmitter.clone();
            particle._attachedSubEmitters.push(newEmitter);
            newEmitter.particleSystem.start();
          }
        });
      }
      return particle;
    };
    _this._emitFromParticle = function(particle) {
      if (!_this._subEmitters || _this._subEmitters.length === 0) {
        return;
      }
      var templateIndex = Math.floor(Math.random() * _this._subEmitters.length);
      _this._subEmitters[templateIndex].forEach(function(subEmitter) {
        if (subEmitter.type === SubEmitterType.END) {
          var subSystem = subEmitter.clone();
          particle._inheritParticleInfoToSubEmitter(subSystem);
          subSystem.particleSystem._rootParticleSystem = _this;
          _this.activeSubSystems.push(subSystem.particleSystem);
          subSystem.particleSystem.start();
        }
      });
    };
    _this._capacity = capacity;
    _this._epsilon = epsilon;
    _this._isAnimationSheetEnabled = isAnimationSheetEnabled;
    if (!sceneOrEngine || sceneOrEngine.getClassName() === "Scene") {
      _this._scene = sceneOrEngine || EngineStore.LastCreatedScene;
      _this._engine = _this._scene.getEngine();
      _this.uniqueId = _this._scene.getUniqueId();
      _this._scene.particleSystems.push(_this);
    } else {
      _this._engine = sceneOrEngine;
      _this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100);
    }
    if (_this._engine.getCaps().vertexArrayObject) {
      _this._vertexArrayObject = null;
    }
    _this._attachImageProcessingConfiguration(null);
    _this._customEffect = { 0: customEffect };
    _this._useInstancing = _this._engine.getCaps().instancedArrays;
    _this._createIndexBuffer();
    _this._createVertexBuffers();
    _this.particleEmitterType = new BoxParticleEmitter();
    _this.updateFunction = function(particles) {
      var noiseTextureSize = null;
      var noiseTextureData = null;
      if (_this.noiseTexture) {
        noiseTextureSize = _this.noiseTexture.getSize();
        noiseTextureData = _this.noiseTexture.getContent();
      }
      var _loop_1 = function() {
        particle = particles[index];
        var scaledUpdateSpeed = _this._scaledUpdateSpeed;
        var previousAge = particle.age;
        particle.age += scaledUpdateSpeed;
        if (particle.age > particle.lifeTime) {
          var diff = particle.age - previousAge;
          var oldDiff = particle.lifeTime - previousAge;
          scaledUpdateSpeed = oldDiff * scaledUpdateSpeed / diff;
          particle.age = particle.lifeTime;
        }
        var ratio = particle.age / particle.lifeTime;
        if (_this._colorGradients && _this._colorGradients.length > 0) {
          GradientHelper.GetCurrentGradient(ratio, _this._colorGradients, function(currentGradient, nextGradient, scale) {
            if (currentGradient !== particle._currentColorGradient) {
              particle._currentColor1.copyFrom(particle._currentColor2);
              nextGradient.getColorToRef(particle._currentColor2);
              particle._currentColorGradient = currentGradient;
            }
            Color4.LerpToRef(particle._currentColor1, particle._currentColor2, scale, particle.color);
          });
        } else {
          particle.colorStep.scaleToRef(scaledUpdateSpeed, _this._scaledColorStep);
          particle.color.addInPlace(_this._scaledColorStep);
          if (particle.color.a < 0) {
            particle.color.a = 0;
          }
        }
        if (_this._angularSpeedGradients && _this._angularSpeedGradients.length > 0) {
          GradientHelper.GetCurrentGradient(ratio, _this._angularSpeedGradients, function(currentGradient, nextGradient, scale) {
            if (currentGradient !== particle._currentAngularSpeedGradient) {
              particle._currentAngularSpeed1 = particle._currentAngularSpeed2;
              particle._currentAngularSpeed2 = nextGradient.getFactor();
              particle._currentAngularSpeedGradient = currentGradient;
            }
            particle.angularSpeed = Scalar.Lerp(particle._currentAngularSpeed1, particle._currentAngularSpeed2, scale);
          });
        }
        particle.angle += particle.angularSpeed * scaledUpdateSpeed;
        var directionScale = scaledUpdateSpeed;
        if (_this._velocityGradients && _this._velocityGradients.length > 0) {
          GradientHelper.GetCurrentGradient(ratio, _this._velocityGradients, function(currentGradient, nextGradient, scale) {
            if (currentGradient !== particle._currentVelocityGradient) {
              particle._currentVelocity1 = particle._currentVelocity2;
              particle._currentVelocity2 = nextGradient.getFactor();
              particle._currentVelocityGradient = currentGradient;
            }
            directionScale *= Scalar.Lerp(particle._currentVelocity1, particle._currentVelocity2, scale);
          });
        }
        particle.direction.scaleToRef(directionScale, _this._scaledDirection);
        if (_this._limitVelocityGradients && _this._limitVelocityGradients.length > 0) {
          GradientHelper.GetCurrentGradient(ratio, _this._limitVelocityGradients, function(currentGradient, nextGradient, scale) {
            if (currentGradient !== particle._currentLimitVelocityGradient) {
              particle._currentLimitVelocity1 = particle._currentLimitVelocity2;
              particle._currentLimitVelocity2 = nextGradient.getFactor();
              particle._currentLimitVelocityGradient = currentGradient;
            }
            var limitVelocity = Scalar.Lerp(particle._currentLimitVelocity1, particle._currentLimitVelocity2, scale);
            var currentVelocity = particle.direction.length();
            if (currentVelocity > limitVelocity) {
              particle.direction.scaleInPlace(_this.limitVelocityDamping);
            }
          });
        }
        if (_this._dragGradients && _this._dragGradients.length > 0) {
          GradientHelper.GetCurrentGradient(ratio, _this._dragGradients, function(currentGradient, nextGradient, scale) {
            if (currentGradient !== particle._currentDragGradient) {
              particle._currentDrag1 = particle._currentDrag2;
              particle._currentDrag2 = nextGradient.getFactor();
              particle._currentDragGradient = currentGradient;
            }
            var drag = Scalar.Lerp(particle._currentDrag1, particle._currentDrag2, scale);
            _this._scaledDirection.scaleInPlace(1 - drag);
          });
        }
        if (_this.isLocal && particle._localPosition) {
          particle._localPosition.addInPlace(_this._scaledDirection);
          Vector3.TransformCoordinatesToRef(particle._localPosition, _this._emitterWorldMatrix, particle.position);
        } else {
          particle.position.addInPlace(_this._scaledDirection);
        }
        if (noiseTextureData && noiseTextureSize && particle._randomNoiseCoordinates1) {
          var fetchedColorR = _this._fetchR(particle._randomNoiseCoordinates1.x, particle._randomNoiseCoordinates1.y, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);
          var fetchedColorG = _this._fetchR(particle._randomNoiseCoordinates1.z, particle._randomNoiseCoordinates2.x, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);
          var fetchedColorB = _this._fetchR(particle._randomNoiseCoordinates2.y, particle._randomNoiseCoordinates2.z, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);
          var force = TmpVectors.Vector3[0];
          var scaledForce = TmpVectors.Vector3[1];
          force.copyFromFloats((2 * fetchedColorR - 1) * _this.noiseStrength.x, (2 * fetchedColorG - 1) * _this.noiseStrength.y, (2 * fetchedColorB - 1) * _this.noiseStrength.z);
          force.scaleToRef(scaledUpdateSpeed, scaledForce);
          particle.direction.addInPlace(scaledForce);
        }
        _this.gravity.scaleToRef(scaledUpdateSpeed, _this._scaledGravity);
        particle.direction.addInPlace(_this._scaledGravity);
        if (_this._sizeGradients && _this._sizeGradients.length > 0) {
          GradientHelper.GetCurrentGradient(ratio, _this._sizeGradients, function(currentGradient, nextGradient, scale) {
            if (currentGradient !== particle._currentSizeGradient) {
              particle._currentSize1 = particle._currentSize2;
              particle._currentSize2 = nextGradient.getFactor();
              particle._currentSizeGradient = currentGradient;
            }
            particle.size = Scalar.Lerp(particle._currentSize1, particle._currentSize2, scale);
          });
        }
        if (_this._useRampGradients) {
          if (_this._colorRemapGradients && _this._colorRemapGradients.length > 0) {
            GradientHelper.GetCurrentGradient(ratio, _this._colorRemapGradients, function(currentGradient, nextGradient, scale) {
              var min = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);
              var max = Scalar.Lerp(currentGradient.factor2, nextGradient.factor2, scale);
              particle.remapData.x = min;
              particle.remapData.y = max - min;
            });
          }
          if (_this._alphaRemapGradients && _this._alphaRemapGradients.length > 0) {
            GradientHelper.GetCurrentGradient(ratio, _this._alphaRemapGradients, function(currentGradient, nextGradient, scale) {
              var min = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);
              var max = Scalar.Lerp(currentGradient.factor2, nextGradient.factor2, scale);
              particle.remapData.z = min;
              particle.remapData.w = max - min;
            });
          }
        }
        if (_this._isAnimationSheetEnabled) {
          particle.updateCellIndex();
        }
        particle._inheritParticleInfoToSubEmitters();
        if (particle.age >= particle.lifeTime) {
          _this._emitFromParticle(particle);
          if (particle._attachedSubEmitters) {
            particle._attachedSubEmitters.forEach(function(subEmitter) {
              subEmitter.particleSystem.disposeOnStop = true;
              subEmitter.particleSystem.stop();
            });
            particle._attachedSubEmitters = null;
          }
          _this.recycleParticle(particle);
          index--;
          return "continue";
        }
      };
      var particle;
      for (var index = 0; index < particles.length; index++) {
        _loop_1();
      }
    };
    return _this;
  }
  Object.defineProperty(ParticleSystem2.prototype, "onDispose", {
    set: function(callback) {
      if (this._onDisposeObserver) {
        this.onDisposeObservable.remove(this._onDisposeObserver);
      }
      this._onDisposeObserver = this.onDisposeObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ParticleSystem2.prototype, "useRampGradients", {
    get: function() {
      return this._useRampGradients;
    },
    set: function(value) {
      if (this._useRampGradients === value) {
        return;
      }
      this._useRampGradients = value;
      this._resetEffect();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ParticleSystem2.prototype, "particles", {
    get: function() {
      return this._particles;
    },
    enumerable: false,
    configurable: true
  });
  ParticleSystem2.prototype.getActiveCount = function() {
    return this._particles.length;
  };
  ParticleSystem2.prototype.getClassName = function() {
    return "ParticleSystem";
  };
  ParticleSystem2.prototype.isStopping = function() {
    return this._stopped && this.isAlive();
  };
  ParticleSystem2.prototype.getCustomEffect = function(blendMode) {
    var _a;
    if (blendMode === void 0) {
      blendMode = 0;
    }
    return (_a = this._customEffect[blendMode]) !== null && _a !== void 0 ? _a : this._customEffect[0];
  };
  ParticleSystem2.prototype.setCustomEffect = function(effect, blendMode) {
    if (blendMode === void 0) {
      blendMode = 0;
    }
    this._customEffect[blendMode] = effect;
  };
  Object.defineProperty(ParticleSystem2.prototype, "onBeforeDrawParticlesObservable", {
    get: function() {
      if (!this._onBeforeDrawParticlesObservable) {
        this._onBeforeDrawParticlesObservable = new Observable();
      }
      return this._onBeforeDrawParticlesObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ParticleSystem2.prototype, "vertexShaderName", {
    get: function() {
      return "particles";
    },
    enumerable: false,
    configurable: true
  });
  ParticleSystem2.prototype._addFactorGradient = function(factorGradients, gradient, factor, factor2) {
    var newGradient = new FactorGradient(gradient, factor, factor2);
    factorGradients.push(newGradient);
    factorGradients.sort(function(a, b) {
      if (a.gradient < b.gradient) {
        return -1;
      } else if (a.gradient > b.gradient) {
        return 1;
      }
      return 0;
    });
  };
  ParticleSystem2.prototype._removeFactorGradient = function(factorGradients, gradient) {
    if (!factorGradients) {
      return;
    }
    var index = 0;
    for (var _i = 0, factorGradients_1 = factorGradients; _i < factorGradients_1.length; _i++) {
      var factorGradient = factorGradients_1[_i];
      if (factorGradient.gradient === gradient) {
        factorGradients.splice(index, 1);
        break;
      }
      index++;
    }
  };
  ParticleSystem2.prototype.addLifeTimeGradient = function(gradient, factor, factor2) {
    if (!this._lifeTimeGradients) {
      this._lifeTimeGradients = [];
    }
    this._addFactorGradient(this._lifeTimeGradients, gradient, factor, factor2);
    return this;
  };
  ParticleSystem2.prototype.removeLifeTimeGradient = function(gradient) {
    this._removeFactorGradient(this._lifeTimeGradients, gradient);
    return this;
  };
  ParticleSystem2.prototype.addSizeGradient = function(gradient, factor, factor2) {
    if (!this._sizeGradients) {
      this._sizeGradients = [];
    }
    this._addFactorGradient(this._sizeGradients, gradient, factor, factor2);
    return this;
  };
  ParticleSystem2.prototype.removeSizeGradient = function(gradient) {
    this._removeFactorGradient(this._sizeGradients, gradient);
    return this;
  };
  ParticleSystem2.prototype.addColorRemapGradient = function(gradient, min, max) {
    if (!this._colorRemapGradients) {
      this._colorRemapGradients = [];
    }
    this._addFactorGradient(this._colorRemapGradients, gradient, min, max);
    return this;
  };
  ParticleSystem2.prototype.removeColorRemapGradient = function(gradient) {
    this._removeFactorGradient(this._colorRemapGradients, gradient);
    return this;
  };
  ParticleSystem2.prototype.addAlphaRemapGradient = function(gradient, min, max) {
    if (!this._alphaRemapGradients) {
      this._alphaRemapGradients = [];
    }
    this._addFactorGradient(this._alphaRemapGradients, gradient, min, max);
    return this;
  };
  ParticleSystem2.prototype.removeAlphaRemapGradient = function(gradient) {
    this._removeFactorGradient(this._alphaRemapGradients, gradient);
    return this;
  };
  ParticleSystem2.prototype.addAngularSpeedGradient = function(gradient, factor, factor2) {
    if (!this._angularSpeedGradients) {
      this._angularSpeedGradients = [];
    }
    this._addFactorGradient(this._angularSpeedGradients, gradient, factor, factor2);
    return this;
  };
  ParticleSystem2.prototype.removeAngularSpeedGradient = function(gradient) {
    this._removeFactorGradient(this._angularSpeedGradients, gradient);
    return this;
  };
  ParticleSystem2.prototype.addVelocityGradient = function(gradient, factor, factor2) {
    if (!this._velocityGradients) {
      this._velocityGradients = [];
    }
    this._addFactorGradient(this._velocityGradients, gradient, factor, factor2);
    return this;
  };
  ParticleSystem2.prototype.removeVelocityGradient = function(gradient) {
    this._removeFactorGradient(this._velocityGradients, gradient);
    return this;
  };
  ParticleSystem2.prototype.addLimitVelocityGradient = function(gradient, factor, factor2) {
    if (!this._limitVelocityGradients) {
      this._limitVelocityGradients = [];
    }
    this._addFactorGradient(this._limitVelocityGradients, gradient, factor, factor2);
    return this;
  };
  ParticleSystem2.prototype.removeLimitVelocityGradient = function(gradient) {
    this._removeFactorGradient(this._limitVelocityGradients, gradient);
    return this;
  };
  ParticleSystem2.prototype.addDragGradient = function(gradient, factor, factor2) {
    if (!this._dragGradients) {
      this._dragGradients = [];
    }
    this._addFactorGradient(this._dragGradients, gradient, factor, factor2);
    return this;
  };
  ParticleSystem2.prototype.removeDragGradient = function(gradient) {
    this._removeFactorGradient(this._dragGradients, gradient);
    return this;
  };
  ParticleSystem2.prototype.addEmitRateGradient = function(gradient, factor, factor2) {
    if (!this._emitRateGradients) {
      this._emitRateGradients = [];
    }
    this._addFactorGradient(this._emitRateGradients, gradient, factor, factor2);
    return this;
  };
  ParticleSystem2.prototype.removeEmitRateGradient = function(gradient) {
    this._removeFactorGradient(this._emitRateGradients, gradient);
    return this;
  };
  ParticleSystem2.prototype.addStartSizeGradient = function(gradient, factor, factor2) {
    if (!this._startSizeGradients) {
      this._startSizeGradients = [];
    }
    this._addFactorGradient(this._startSizeGradients, gradient, factor, factor2);
    return this;
  };
  ParticleSystem2.prototype.removeStartSizeGradient = function(gradient) {
    this._removeFactorGradient(this._startSizeGradients, gradient);
    return this;
  };
  ParticleSystem2.prototype._createRampGradientTexture = function() {
    if (!this._rampGradients || !this._rampGradients.length || this._rampGradientsTexture || !this._scene) {
      return;
    }
    var data = new Uint8Array(this._rawTextureWidth * 4);
    var tmpColor = TmpColors.Color3[0];
    for (var x = 0; x < this._rawTextureWidth; x++) {
      var ratio = x / this._rawTextureWidth;
      GradientHelper.GetCurrentGradient(ratio, this._rampGradients, function(currentGradient, nextGradient, scale) {
        Color3.LerpToRef(currentGradient.color, nextGradient.color, scale, tmpColor);
        data[x * 4] = tmpColor.r * 255;
        data[x * 4 + 1] = tmpColor.g * 255;
        data[x * 4 + 2] = tmpColor.b * 255;
        data[x * 4 + 3] = 255;
      });
    }
    this._rampGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, 1);
  };
  ParticleSystem2.prototype.getRampGradients = function() {
    return this._rampGradients;
  };
  ParticleSystem2.prototype.forceRefreshGradients = function() {
    this._syncRampGradientTexture();
  };
  ParticleSystem2.prototype._syncRampGradientTexture = function() {
    if (!this._rampGradients) {
      return;
    }
    this._rampGradients.sort(function(a, b) {
      if (a.gradient < b.gradient) {
        return -1;
      } else if (a.gradient > b.gradient) {
        return 1;
      }
      return 0;
    });
    if (this._rampGradientsTexture) {
      this._rampGradientsTexture.dispose();
      this._rampGradientsTexture = null;
    }
    this._createRampGradientTexture();
  };
  ParticleSystem2.prototype.addRampGradient = function(gradient, color) {
    if (!this._rampGradients) {
      this._rampGradients = [];
    }
    var rampGradient = new Color3Gradient(gradient, color);
    this._rampGradients.push(rampGradient);
    this._syncRampGradientTexture();
    return this;
  };
  ParticleSystem2.prototype.removeRampGradient = function(gradient) {
    this._removeGradientAndTexture(gradient, this._rampGradients, this._rampGradientsTexture);
    this._rampGradientsTexture = null;
    if (this._rampGradients && this._rampGradients.length > 0) {
      this._createRampGradientTexture();
    }
    return this;
  };
  ParticleSystem2.prototype.addColorGradient = function(gradient, color1, color2) {
    if (!this._colorGradients) {
      this._colorGradients = [];
    }
    var colorGradient = new ColorGradient(gradient, color1, color2);
    this._colorGradients.push(colorGradient);
    this._colorGradients.sort(function(a, b) {
      if (a.gradient < b.gradient) {
        return -1;
      } else if (a.gradient > b.gradient) {
        return 1;
      }
      return 0;
    });
    return this;
  };
  ParticleSystem2.prototype.removeColorGradient = function(gradient) {
    if (!this._colorGradients) {
      return this;
    }
    var index = 0;
    for (var _i = 0, _a = this._colorGradients; _i < _a.length; _i++) {
      var colorGradient = _a[_i];
      if (colorGradient.gradient === gradient) {
        this._colorGradients.splice(index, 1);
        break;
      }
      index++;
    }
    return this;
  };
  ParticleSystem2.prototype._fetchR = function(u, v, width, height, pixels) {
    u = Math.abs(u) * 0.5 + 0.5;
    v = Math.abs(v) * 0.5 + 0.5;
    var wrappedU = u * width % width | 0;
    var wrappedV = v * height % height | 0;
    var position = (wrappedU + wrappedV * width) * 4;
    return pixels[position] / 255;
  };
  ParticleSystem2.prototype._reset = function() {
    this._resetEffect();
  };
  ParticleSystem2.prototype._resetEffect = function() {
    if (this._vertexBuffer) {
      this._vertexBuffer.dispose();
      this._vertexBuffer = null;
    }
    if (this._spriteBuffer) {
      this._spriteBuffer.dispose();
      this._spriteBuffer = null;
    }
    if (this._vertexArrayObject) {
      this._engine.releaseVertexArrayObject(this._vertexArrayObject);
      this._vertexArrayObject = null;
    }
    this._createVertexBuffers();
  };
  ParticleSystem2.prototype._createVertexBuffers = function() {
    this._vertexBufferSize = this._useInstancing ? 10 : 12;
    if (this._isAnimationSheetEnabled) {
      this._vertexBufferSize += 1;
    }
    if (!this._isBillboardBased || this.billboardMode === ParticleSystem2.BILLBOARDMODE_STRETCHED) {
      this._vertexBufferSize += 3;
    }
    if (this._useRampGradients) {
      this._vertexBufferSize += 4;
    }
    var engine = this._engine;
    this._vertexData = new Float32Array(this._capacity * this._vertexBufferSize * (this._useInstancing ? 1 : 4));
    this._vertexBuffer = new Buffer(engine, this._vertexData, true, this._vertexBufferSize);
    var dataOffset = 0;
    var positions = this._vertexBuffer.createVertexBuffer(VertexBuffer.PositionKind, dataOffset, 3, this._vertexBufferSize, this._useInstancing);
    this._vertexBuffers[VertexBuffer.PositionKind] = positions;
    dataOffset += 3;
    var colors = this._vertexBuffer.createVertexBuffer(VertexBuffer.ColorKind, dataOffset, 4, this._vertexBufferSize, this._useInstancing);
    this._vertexBuffers[VertexBuffer.ColorKind] = colors;
    dataOffset += 4;
    var options = this._vertexBuffer.createVertexBuffer("angle", dataOffset, 1, this._vertexBufferSize, this._useInstancing);
    this._vertexBuffers["angle"] = options;
    dataOffset += 1;
    var size = this._vertexBuffer.createVertexBuffer("size", dataOffset, 2, this._vertexBufferSize, this._useInstancing);
    this._vertexBuffers["size"] = size;
    dataOffset += 2;
    if (this._isAnimationSheetEnabled) {
      var cellIndexBuffer = this._vertexBuffer.createVertexBuffer("cellIndex", dataOffset, 1, this._vertexBufferSize, this._useInstancing);
      this._vertexBuffers["cellIndex"] = cellIndexBuffer;
      dataOffset += 1;
    }
    if (!this._isBillboardBased || this.billboardMode === ParticleSystem2.BILLBOARDMODE_STRETCHED) {
      var directionBuffer = this._vertexBuffer.createVertexBuffer("direction", dataOffset, 3, this._vertexBufferSize, this._useInstancing);
      this._vertexBuffers["direction"] = directionBuffer;
      dataOffset += 3;
    }
    if (this._useRampGradients) {
      var rampDataBuffer = this._vertexBuffer.createVertexBuffer("remapData", dataOffset, 4, this._vertexBufferSize, this._useInstancing);
      this._vertexBuffers["remapData"] = rampDataBuffer;
      dataOffset += 4;
    }
    var offsets;
    if (this._useInstancing) {
      var spriteData = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
      this._spriteBuffer = new Buffer(engine, spriteData, false, 2);
      offsets = this._spriteBuffer.createVertexBuffer("offset", 0, 2);
    } else {
      offsets = this._vertexBuffer.createVertexBuffer("offset", dataOffset, 2, this._vertexBufferSize, this._useInstancing);
      dataOffset += 2;
    }
    this._vertexBuffers["offset"] = offsets;
  };
  ParticleSystem2.prototype._createIndexBuffer = function() {
    if (this._useInstancing) {
      return;
    }
    var indices = [];
    var index = 0;
    for (var count = 0; count < this._capacity; count++) {
      indices.push(index);
      indices.push(index + 1);
      indices.push(index + 2);
      indices.push(index);
      indices.push(index + 2);
      indices.push(index + 3);
      index += 4;
    }
    this._indexBuffer = this._engine.createIndexBuffer(indices);
  };
  ParticleSystem2.prototype.getCapacity = function() {
    return this._capacity;
  };
  ParticleSystem2.prototype.isAlive = function() {
    return this._alive;
  };
  ParticleSystem2.prototype.isStarted = function() {
    return this._started;
  };
  ParticleSystem2.prototype._prepareSubEmitterInternalArray = function() {
    var _this = this;
    this._subEmitters = new Array();
    if (this.subEmitters) {
      this.subEmitters.forEach(function(subEmitter) {
        if (subEmitter instanceof ParticleSystem2) {
          _this._subEmitters.push([new SubEmitter(subEmitter)]);
        } else if (subEmitter instanceof SubEmitter) {
          _this._subEmitters.push([subEmitter]);
        } else if (subEmitter instanceof Array) {
          _this._subEmitters.push(subEmitter);
        }
      });
    }
  };
  ParticleSystem2.prototype.start = function(delay) {
    var _this = this;
    var _a;
    if (delay === void 0) {
      delay = this.startDelay;
    }
    if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {
      throw "Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set";
    }
    if (delay) {
      setTimeout(function() {
        _this.start(0);
      }, delay);
      return;
    }
    this._prepareSubEmitterInternalArray();
    this._started = true;
    this._stopped = false;
    this._actualFrame = 0;
    if (this._subEmitters && this._subEmitters.length != 0) {
      this.activeSubSystems = new Array();
    }
    if (this._emitRateGradients) {
      if (this._emitRateGradients.length > 0) {
        this._currentEmitRateGradient = this._emitRateGradients[0];
        this._currentEmitRate1 = this._currentEmitRateGradient.getFactor();
        this._currentEmitRate2 = this._currentEmitRate1;
      }
      if (this._emitRateGradients.length > 1) {
        this._currentEmitRate2 = this._emitRateGradients[1].getFactor();
      }
    }
    if (this._startSizeGradients) {
      if (this._startSizeGradients.length > 0) {
        this._currentStartSizeGradient = this._startSizeGradients[0];
        this._currentStartSize1 = this._currentStartSizeGradient.getFactor();
        this._currentStartSize2 = this._currentStartSize1;
      }
      if (this._startSizeGradients.length > 1) {
        this._currentStartSize2 = this._startSizeGradients[1].getFactor();
      }
    }
    if (this.preWarmCycles) {
      if (((_a = this.emitter) === null || _a === void 0 ? void 0 : _a.getClassName().indexOf("Mesh")) !== -1) {
        this.emitter.computeWorldMatrix(true);
      }
      var noiseTextureAsProcedural_1 = this.noiseTexture;
      if (noiseTextureAsProcedural_1 && noiseTextureAsProcedural_1.onGeneratedObservable) {
        noiseTextureAsProcedural_1.onGeneratedObservable.addOnce(function() {
          setTimeout(function() {
            for (var index2 = 0; index2 < _this.preWarmCycles; index2++) {
              _this.animate(true);
              noiseTextureAsProcedural_1.render();
            }
          });
        });
      } else {
        for (var index = 0; index < this.preWarmCycles; index++) {
          this.animate(true);
        }
      }
    }
    if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {
      this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);
    }
  };
  ParticleSystem2.prototype.stop = function(stopSubEmitters) {
    if (stopSubEmitters === void 0) {
      stopSubEmitters = true;
    }
    if (this._stopped) {
      return;
    }
    this.onStoppedObservable.notifyObservers(this);
    this._stopped = true;
    if (stopSubEmitters) {
      this._stopSubEmitters();
    }
  };
  ParticleSystem2.prototype.reset = function() {
    this._stockParticles = [];
    this._particles = [];
  };
  ParticleSystem2.prototype._appendParticleVertex = function(index, particle, offsetX, offsetY) {
    var offset = index * this._vertexBufferSize;
    this._vertexData[offset++] = particle.position.x + this.worldOffset.x;
    this._vertexData[offset++] = particle.position.y + this.worldOffset.y;
    this._vertexData[offset++] = particle.position.z + this.worldOffset.z;
    this._vertexData[offset++] = particle.color.r;
    this._vertexData[offset++] = particle.color.g;
    this._vertexData[offset++] = particle.color.b;
    this._vertexData[offset++] = particle.color.a;
    this._vertexData[offset++] = particle.angle;
    this._vertexData[offset++] = particle.scale.x * particle.size;
    this._vertexData[offset++] = particle.scale.y * particle.size;
    if (this._isAnimationSheetEnabled) {
      this._vertexData[offset++] = particle.cellIndex;
    }
    if (!this._isBillboardBased) {
      if (particle._initialDirection) {
        var initialDirection = particle._initialDirection;
        if (this.isLocal) {
          Vector3.TransformNormalToRef(initialDirection, this._emitterWorldMatrix, TmpVectors.Vector3[0]);
          initialDirection = TmpVectors.Vector3[0];
        }
        if (initialDirection.x === 0 && initialDirection.z === 0) {
          initialDirection.x = 1e-3;
        }
        this._vertexData[offset++] = initialDirection.x;
        this._vertexData[offset++] = initialDirection.y;
        this._vertexData[offset++] = initialDirection.z;
      } else {
        var direction = particle.direction;
        if (this.isLocal) {
          Vector3.TransformNormalToRef(direction, this._emitterWorldMatrix, TmpVectors.Vector3[0]);
          direction = TmpVectors.Vector3[0];
        }
        if (direction.x === 0 && direction.z === 0) {
          direction.x = 1e-3;
        }
        this._vertexData[offset++] = direction.x;
        this._vertexData[offset++] = direction.y;
        this._vertexData[offset++] = direction.z;
      }
    } else if (this.billboardMode === ParticleSystem2.BILLBOARDMODE_STRETCHED) {
      this._vertexData[offset++] = particle.direction.x;
      this._vertexData[offset++] = particle.direction.y;
      this._vertexData[offset++] = particle.direction.z;
    }
    if (this._useRampGradients && particle.remapData) {
      this._vertexData[offset++] = particle.remapData.x;
      this._vertexData[offset++] = particle.remapData.y;
      this._vertexData[offset++] = particle.remapData.z;
      this._vertexData[offset++] = particle.remapData.w;
    }
    if (!this._useInstancing) {
      if (this._isAnimationSheetEnabled) {
        if (offsetX === 0) {
          offsetX = this._epsilon;
        } else if (offsetX === 1) {
          offsetX = 1 - this._epsilon;
        }
        if (offsetY === 0) {
          offsetY = this._epsilon;
        } else if (offsetY === 1) {
          offsetY = 1 - this._epsilon;
        }
      }
      this._vertexData[offset++] = offsetX;
      this._vertexData[offset++] = offsetY;
    }
  };
  ParticleSystem2.prototype._stopSubEmitters = function() {
    if (!this.activeSubSystems) {
      return;
    }
    this.activeSubSystems.forEach(function(subSystem) {
      subSystem.stop(true);
    });
    this.activeSubSystems = new Array();
  };
  ParticleSystem2.prototype._removeFromRoot = function() {
    if (!this._rootParticleSystem) {
      return;
    }
    var index = this._rootParticleSystem.activeSubSystems.indexOf(this);
    if (index !== -1) {
      this._rootParticleSystem.activeSubSystems.splice(index, 1);
    }
    this._rootParticleSystem = null;
  };
  ParticleSystem2.prototype._update = function(newParticles) {
    var _this = this;
    this._alive = this._particles.length > 0;
    if (this.emitter.position) {
      var emitterMesh = this.emitter;
      this._emitterWorldMatrix = emitterMesh.getWorldMatrix();
    } else {
      var emitterPosition = this.emitter;
      this._emitterWorldMatrix = Matrix.Translation(emitterPosition.x, emitterPosition.y, emitterPosition.z);
    }
    this.updateFunction(this._particles);
    var particle;
    var _loop_2 = function() {
      if (this_1._particles.length === this_1._capacity) {
        return "break";
      }
      particle = this_1._createParticle();
      this_1._particles.push(particle);
      if (this_1.targetStopDuration && this_1._lifeTimeGradients && this_1._lifeTimeGradients.length > 0) {
        var ratio_1 = Scalar.Clamp(this_1._actualFrame / this_1.targetStopDuration);
        GradientHelper.GetCurrentGradient(ratio_1, this_1._lifeTimeGradients, function(currentGradient, nextGradient) {
          var factorGradient1 = currentGradient;
          var factorGradient2 = nextGradient;
          var lifeTime1 = factorGradient1.getFactor();
          var lifeTime2 = factorGradient2.getFactor();
          var gradient = (ratio_1 - factorGradient1.gradient) / (factorGradient2.gradient - factorGradient1.gradient);
          particle.lifeTime = Scalar.Lerp(lifeTime1, lifeTime2, gradient);
        });
      } else {
        particle.lifeTime = Scalar.RandomRange(this_1.minLifeTime, this_1.maxLifeTime);
      }
      var emitPower = Scalar.RandomRange(this_1.minEmitPower, this_1.maxEmitPower);
      if (this_1.startPositionFunction) {
        this_1.startPositionFunction(this_1._emitterWorldMatrix, particle.position, particle, this_1.isLocal);
      } else {
        this_1.particleEmitterType.startPositionFunction(this_1._emitterWorldMatrix, particle.position, particle, this_1.isLocal);
      }
      if (this_1.isLocal) {
        if (!particle._localPosition) {
          particle._localPosition = particle.position.clone();
        } else {
          particle._localPosition.copyFrom(particle.position);
        }
        Vector3.TransformCoordinatesToRef(particle._localPosition, this_1._emitterWorldMatrix, particle.position);
      }
      if (this_1.startDirectionFunction) {
        this_1.startDirectionFunction(this_1._emitterWorldMatrix, particle.direction, particle, this_1.isLocal);
      } else {
        this_1.particleEmitterType.startDirectionFunction(this_1._emitterWorldMatrix, particle.direction, particle, this_1.isLocal);
      }
      if (emitPower === 0) {
        if (!particle._initialDirection) {
          particle._initialDirection = particle.direction.clone();
        } else {
          particle._initialDirection.copyFrom(particle.direction);
        }
      } else {
        particle._initialDirection = null;
      }
      particle.direction.scaleInPlace(emitPower);
      if (!this_1._sizeGradients || this_1._sizeGradients.length === 0) {
        particle.size = Scalar.RandomRange(this_1.minSize, this_1.maxSize);
      } else {
        particle._currentSizeGradient = this_1._sizeGradients[0];
        particle._currentSize1 = particle._currentSizeGradient.getFactor();
        particle.size = particle._currentSize1;
        if (this_1._sizeGradients.length > 1) {
          particle._currentSize2 = this_1._sizeGradients[1].getFactor();
        } else {
          particle._currentSize2 = particle._currentSize1;
        }
      }
      particle.scale.copyFromFloats(Scalar.RandomRange(this_1.minScaleX, this_1.maxScaleX), Scalar.RandomRange(this_1.minScaleY, this_1.maxScaleY));
      if (this_1._startSizeGradients && this_1._startSizeGradients[0] && this_1.targetStopDuration) {
        var ratio = this_1._actualFrame / this_1.targetStopDuration;
        GradientHelper.GetCurrentGradient(ratio, this_1._startSizeGradients, function(currentGradient, nextGradient, scale) {
          if (currentGradient !== _this._currentStartSizeGradient) {
            _this._currentStartSize1 = _this._currentStartSize2;
            _this._currentStartSize2 = nextGradient.getFactor();
            _this._currentStartSizeGradient = currentGradient;
          }
          var value = Scalar.Lerp(_this._currentStartSize1, _this._currentStartSize2, scale);
          particle.scale.scaleInPlace(value);
        });
      }
      if (!this_1._angularSpeedGradients || this_1._angularSpeedGradients.length === 0) {
        particle.angularSpeed = Scalar.RandomRange(this_1.minAngularSpeed, this_1.maxAngularSpeed);
      } else {
        particle._currentAngularSpeedGradient = this_1._angularSpeedGradients[0];
        particle.angularSpeed = particle._currentAngularSpeedGradient.getFactor();
        particle._currentAngularSpeed1 = particle.angularSpeed;
        if (this_1._angularSpeedGradients.length > 1) {
          particle._currentAngularSpeed2 = this_1._angularSpeedGradients[1].getFactor();
        } else {
          particle._currentAngularSpeed2 = particle._currentAngularSpeed1;
        }
      }
      particle.angle = Scalar.RandomRange(this_1.minInitialRotation, this_1.maxInitialRotation);
      if (this_1._velocityGradients && this_1._velocityGradients.length > 0) {
        particle._currentVelocityGradient = this_1._velocityGradients[0];
        particle._currentVelocity1 = particle._currentVelocityGradient.getFactor();
        if (this_1._velocityGradients.length > 1) {
          particle._currentVelocity2 = this_1._velocityGradients[1].getFactor();
        } else {
          particle._currentVelocity2 = particle._currentVelocity1;
        }
      }
      if (this_1._limitVelocityGradients && this_1._limitVelocityGradients.length > 0) {
        particle._currentLimitVelocityGradient = this_1._limitVelocityGradients[0];
        particle._currentLimitVelocity1 = particle._currentLimitVelocityGradient.getFactor();
        if (this_1._limitVelocityGradients.length > 1) {
          particle._currentLimitVelocity2 = this_1._limitVelocityGradients[1].getFactor();
        } else {
          particle._currentLimitVelocity2 = particle._currentLimitVelocity1;
        }
      }
      if (this_1._dragGradients && this_1._dragGradients.length > 0) {
        particle._currentDragGradient = this_1._dragGradients[0];
        particle._currentDrag1 = particle._currentDragGradient.getFactor();
        if (this_1._dragGradients.length > 1) {
          particle._currentDrag2 = this_1._dragGradients[1].getFactor();
        } else {
          particle._currentDrag2 = particle._currentDrag1;
        }
      }
      if (!this_1._colorGradients || this_1._colorGradients.length === 0) {
        step = Scalar.RandomRange(0, 1);
        Color4.LerpToRef(this_1.color1, this_1.color2, step, particle.color);
        this_1.colorDead.subtractToRef(particle.color, this_1._colorDiff);
        this_1._colorDiff.scaleToRef(1 / particle.lifeTime, particle.colorStep);
      } else {
        particle._currentColorGradient = this_1._colorGradients[0];
        particle._currentColorGradient.getColorToRef(particle.color);
        particle._currentColor1.copyFrom(particle.color);
        if (this_1._colorGradients.length > 1) {
          this_1._colorGradients[1].getColorToRef(particle._currentColor2);
        } else {
          particle._currentColor2.copyFrom(particle.color);
        }
      }
      if (this_1._isAnimationSheetEnabled) {
        particle._initialStartSpriteCellID = this_1.startSpriteCellID;
        particle._initialEndSpriteCellID = this_1.endSpriteCellID;
      }
      particle.direction.addInPlace(this_1._inheritedVelocityOffset);
      if (this_1._useRampGradients) {
        particle.remapData = new Vector4(0, 1, 0, 1);
      }
      if (this_1.noiseTexture) {
        if (particle._randomNoiseCoordinates1) {
          particle._randomNoiseCoordinates1.copyFromFloats(Math.random(), Math.random(), Math.random());
          particle._randomNoiseCoordinates2.copyFromFloats(Math.random(), Math.random(), Math.random());
        } else {
          particle._randomNoiseCoordinates1 = new Vector3(Math.random(), Math.random(), Math.random());
          particle._randomNoiseCoordinates2 = new Vector3(Math.random(), Math.random(), Math.random());
        }
      }
      particle._inheritParticleInfoToSubEmitters();
    };
    var this_1 = this, step;
    for (var index = 0; index < newParticles; index++) {
      var state_1 = _loop_2();
      if (state_1 === "break")
        break;
    }
  };
  ParticleSystem2._GetAttributeNamesOrOptions = function(isAnimationSheetEnabled, isBillboardBased, useRampGradients) {
    if (isAnimationSheetEnabled === void 0) {
      isAnimationSheetEnabled = false;
    }
    if (isBillboardBased === void 0) {
      isBillboardBased = false;
    }
    if (useRampGradients === void 0) {
      useRampGradients = false;
    }
    var attributeNamesOrOptions = [VertexBuffer.PositionKind, VertexBuffer.ColorKind, "angle", "offset", "size"];
    if (isAnimationSheetEnabled) {
      attributeNamesOrOptions.push("cellIndex");
    }
    if (!isBillboardBased) {
      attributeNamesOrOptions.push("direction");
    }
    if (useRampGradients) {
      attributeNamesOrOptions.push("remapData");
    }
    return attributeNamesOrOptions;
  };
  ParticleSystem2._GetEffectCreationOptions = function(isAnimationSheetEnabled) {
    if (isAnimationSheetEnabled === void 0) {
      isAnimationSheetEnabled = false;
    }
    var effectCreationOption = ["invView", "view", "projection", "vClipPlane", "vClipPlane2", "vClipPlane3", "vClipPlane4", "vClipPlane5", "vClipPlane6", "textureMask", "translationPivot", "eyePosition"];
    if (isAnimationSheetEnabled) {
      effectCreationOption.push("particlesInfos");
    }
    return effectCreationOption;
  };
  ParticleSystem2.prototype.fillDefines = function(defines, blendMode) {
    if (this._scene) {
      if (this._scene.clipPlane) {
        defines.push("#define CLIPPLANE");
      }
      if (this._scene.clipPlane2) {
        defines.push("#define CLIPPLANE2");
      }
      if (this._scene.clipPlane3) {
        defines.push("#define CLIPPLANE3");
      }
      if (this._scene.clipPlane4) {
        defines.push("#define CLIPPLANE4");
      }
      if (this._scene.clipPlane5) {
        defines.push("#define CLIPPLANE5");
      }
      if (this._scene.clipPlane6) {
        defines.push("#define CLIPPLANE6");
      }
    }
    if (this._isAnimationSheetEnabled) {
      defines.push("#define ANIMATESHEET");
    }
    if (blendMode === ParticleSystem2.BLENDMODE_MULTIPLY) {
      defines.push("#define BLENDMULTIPLYMODE");
    }
    if (this._useRampGradients) {
      defines.push("#define RAMPGRADIENT");
    }
    if (this._isBillboardBased) {
      defines.push("#define BILLBOARD");
      switch (this.billboardMode) {
        case ParticleSystem2.BILLBOARDMODE_Y:
          defines.push("#define BILLBOARDY");
          break;
        case ParticleSystem2.BILLBOARDMODE_STRETCHED:
          defines.push("#define BILLBOARDSTRETCHED");
          break;
        case ParticleSystem2.BILLBOARDMODE_ALL:
          defines.push("#define BILLBOARDMODE_ALL");
          break;
        default:
          break;
      }
    }
    if (this._imageProcessingConfiguration) {
      this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);
      defines.push(this._imageProcessingConfigurationDefines.toString());
    }
  };
  ParticleSystem2.prototype.fillUniformsAttributesAndSamplerNames = function(uniforms, attributes, samplers) {
    attributes.push.apply(attributes, ParticleSystem2._GetAttributeNamesOrOptions(this._isAnimationSheetEnabled, this._isBillboardBased && this.billboardMode !== ParticleSystem2.BILLBOARDMODE_STRETCHED, this._useRampGradients));
    uniforms.push.apply(uniforms, ParticleSystem2._GetEffectCreationOptions(this._isAnimationSheetEnabled));
    samplers.push("diffuseSampler", "rampSampler");
    if (this._imageProcessingConfiguration) {
      ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);
      ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);
    }
  };
  ParticleSystem2.prototype._getEffect = function(blendMode) {
    var customEffect = this.getCustomEffect(blendMode);
    if (customEffect) {
      return customEffect;
    }
    var defines = [];
    this.fillDefines(defines, blendMode);
    var join = defines.join("\n");
    if (this._cachedDefines !== join) {
      this._cachedDefines = join;
      var attributesNamesOrOptions = [];
      var effectCreationOption = [];
      var samplers = [];
      this.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, samplers);
      this._effect = this._engine.createEffect("particles", attributesNamesOrOptions, effectCreationOption, samplers, join);
    }
    return this._effect;
  };
  ParticleSystem2.prototype.animate = function(preWarmOnly) {
    var _this = this;
    var _a;
    if (preWarmOnly === void 0) {
      preWarmOnly = false;
    }
    if (!this._started) {
      return;
    }
    if (!preWarmOnly && this._scene) {
      if (!this.isReady()) {
        return;
      }
      if (this._currentRenderId === this._scene.getFrameId()) {
        return;
      }
      this._currentRenderId = this._scene.getFrameId();
    }
    this._scaledUpdateSpeed = this.updateSpeed * (preWarmOnly ? this.preWarmStepOffset : ((_a = this._scene) === null || _a === void 0 ? void 0 : _a.getAnimationRatio()) || 1);
    var newParticles;
    if (this.manualEmitCount > -1) {
      newParticles = this.manualEmitCount;
      this._newPartsExcess = 0;
      this.manualEmitCount = 0;
    } else {
      var rate_1 = this.emitRate;
      if (this._emitRateGradients && this._emitRateGradients.length > 0 && this.targetStopDuration) {
        var ratio = this._actualFrame / this.targetStopDuration;
        GradientHelper.GetCurrentGradient(ratio, this._emitRateGradients, function(currentGradient, nextGradient, scale) {
          if (currentGradient !== _this._currentEmitRateGradient) {
            _this._currentEmitRate1 = _this._currentEmitRate2;
            _this._currentEmitRate2 = nextGradient.getFactor();
            _this._currentEmitRateGradient = currentGradient;
          }
          rate_1 = Scalar.Lerp(_this._currentEmitRate1, _this._currentEmitRate2, scale);
        });
      }
      newParticles = rate_1 * this._scaledUpdateSpeed >> 0;
      this._newPartsExcess += rate_1 * this._scaledUpdateSpeed - newParticles;
    }
    if (this._newPartsExcess > 1) {
      newParticles += this._newPartsExcess >> 0;
      this._newPartsExcess -= this._newPartsExcess >> 0;
    }
    this._alive = false;
    if (!this._stopped) {
      this._actualFrame += this._scaledUpdateSpeed;
      if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {
        this.stop();
      }
    } else {
      newParticles = 0;
    }
    this._update(newParticles);
    if (this._stopped) {
      if (!this._alive) {
        this._started = false;
        if (this.onAnimationEnd) {
          this.onAnimationEnd();
        }
        if (this.disposeOnStop && this._scene) {
          this._scene._toBeDisposed.push(this);
        }
      }
    }
    if (!preWarmOnly) {
      var offset = 0;
      for (var index = 0; index < this._particles.length; index++) {
        var particle = this._particles[index];
        this._appendParticleVertices(offset, particle);
        offset += this._useInstancing ? 1 : 4;
      }
      if (this._vertexBuffer) {
        this._vertexBuffer.update(this._vertexData);
      }
    }
    if (this.manualEmitCount === 0 && this.disposeOnStop) {
      this.stop();
    }
  };
  ParticleSystem2.prototype._appendParticleVertices = function(offset, particle) {
    this._appendParticleVertex(offset++, particle, 0, 0);
    if (!this._useInstancing) {
      this._appendParticleVertex(offset++, particle, 1, 0);
      this._appendParticleVertex(offset++, particle, 1, 1);
      this._appendParticleVertex(offset++, particle, 0, 1);
    }
  };
  ParticleSystem2.prototype.rebuild = function() {
    this._createIndexBuffer();
    if (this._vertexBuffer) {
      this._vertexBuffer._rebuild();
    }
    for (var key in this._vertexBuffers) {
      this._vertexBuffers[key]._rebuild();
    }
  };
  ParticleSystem2.prototype.isReady = function() {
    if (!this.emitter || this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady() || !this.particleTexture || !this.particleTexture.isReady()) {
      return false;
    }
    if (this.blendMode !== ParticleSystem2.BLENDMODE_MULTIPLYADD) {
      if (!this._getEffect(this.blendMode).isReady()) {
        return false;
      }
    } else {
      if (!this._getEffect(ParticleSystem2.BLENDMODE_MULTIPLY).isReady()) {
        return false;
      }
      if (!this._getEffect(ParticleSystem2.BLENDMODE_ADD).isReady()) {
        return false;
      }
    }
    return true;
  };
  ParticleSystem2.prototype._render = function(blendMode) {
    var _a, _b;
    var effect = this._getEffect(blendMode);
    var engine = this._engine;
    engine.enableEffect(effect);
    var viewMatrix = (_a = this.defaultViewMatrix) !== null && _a !== void 0 ? _a : this._scene.getViewMatrix();
    effect.setTexture("diffuseSampler", this.particleTexture);
    effect.setMatrix("view", viewMatrix);
    effect.setMatrix("projection", (_b = this.defaultProjectionMatrix) !== null && _b !== void 0 ? _b : this._scene.getProjectionMatrix());
    if (this._isAnimationSheetEnabled && this.particleTexture) {
      var baseSize = this.particleTexture.getBaseSize();
      effect.setFloat3("particlesInfos", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, this.spriteCellWidth / baseSize.width);
    }
    effect.setVector2("translationPivot", this.translationPivot);
    effect.setFloat4("textureMask", this.textureMask.r, this.textureMask.g, this.textureMask.b, this.textureMask.a);
    if (this._isBillboardBased && this._scene) {
      var camera = this._scene.activeCamera;
      effect.setVector3("eyePosition", camera.globalPosition);
    }
    if (this._rampGradientsTexture) {
      if (!this._rampGradients || !this._rampGradients.length) {
        this._rampGradientsTexture.dispose();
        this._rampGradientsTexture = null;
      }
      effect.setTexture("rampSampler", this._rampGradientsTexture);
    }
    var defines = effect.defines;
    if (this._scene) {
      if (this._scene.clipPlane || this._scene.clipPlane2 || this._scene.clipPlane3 || this._scene.clipPlane4 || this._scene.clipPlane5 || this._scene.clipPlane6) {
        ThinMaterialHelper.BindClipPlane(effect, this._scene);
      }
    }
    if (defines.indexOf("#define BILLBOARDMODE_ALL") >= 0) {
      viewMatrix.invertToRef(TmpVectors.Matrix[0]);
      effect.setMatrix("invView", TmpVectors.Matrix[0]);
    }
    if (this._vertexArrayObject !== void 0) {
      if (!this._vertexArrayObject) {
        this._vertexArrayObject = this._engine.recordVertexArrayObject(this._vertexBuffers, this._indexBuffer, effect);
      }
      this._engine.bindVertexArrayObject(this._vertexArrayObject, this._indexBuffer);
    } else {
      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
    }
    if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {
      this._imageProcessingConfiguration.bind(effect);
    }
    switch (blendMode) {
      case ParticleSystem2.BLENDMODE_ADD:
        engine.setAlphaMode(1);
        break;
      case ParticleSystem2.BLENDMODE_ONEONE:
        engine.setAlphaMode(6);
        break;
      case ParticleSystem2.BLENDMODE_STANDARD:
        engine.setAlphaMode(2);
        break;
      case ParticleSystem2.BLENDMODE_MULTIPLY:
        engine.setAlphaMode(4);
        break;
    }
    if (this._onBeforeDrawParticlesObservable) {
      this._onBeforeDrawParticlesObservable.notifyObservers(effect);
    }
    if (this._useInstancing) {
      engine.drawArraysType(8, 0, 4, this._particles.length);
    } else {
      engine.drawElementsType(0, 0, this._particles.length * 6);
    }
    return this._particles.length;
  };
  ParticleSystem2.prototype.render = function() {
    if (!this.isReady() || !this._particles.length) {
      return 0;
    }
    var engine = this._engine;
    if (engine.setState) {
      engine.setState(false);
      if (this.forceDepthWrite) {
        engine.setDepthWrite(true);
      }
    }
    var outparticles = 0;
    if (this.blendMode === ParticleSystem2.BLENDMODE_MULTIPLYADD) {
      outparticles = this._render(ParticleSystem2.BLENDMODE_MULTIPLY) + this._render(ParticleSystem2.BLENDMODE_ADD);
    } else {
      outparticles = this._render(this.blendMode);
    }
    this._engine.unbindInstanceAttributes();
    this._engine.setAlphaMode(0);
    return outparticles;
  };
  ParticleSystem2.prototype.dispose = function(disposeTexture) {
    if (disposeTexture === void 0) {
      disposeTexture = true;
    }
    if (this._vertexBuffer) {
      this._vertexBuffer.dispose();
      this._vertexBuffer = null;
    }
    if (this._spriteBuffer) {
      this._spriteBuffer.dispose();
      this._spriteBuffer = null;
    }
    if (this._indexBuffer) {
      this._engine._releaseBuffer(this._indexBuffer);
      this._indexBuffer = null;
    }
    if (this._vertexArrayObject) {
      this._engine.releaseVertexArrayObject(this._vertexArrayObject);
      this._vertexArrayObject = null;
    }
    if (disposeTexture && this.particleTexture) {
      this.particleTexture.dispose();
      this.particleTexture = null;
    }
    if (disposeTexture && this.noiseTexture) {
      this.noiseTexture.dispose();
      this.noiseTexture = null;
    }
    if (this._rampGradientsTexture) {
      this._rampGradientsTexture.dispose();
      this._rampGradientsTexture = null;
    }
    this._removeFromRoot();
    if (this._subEmitters && this._subEmitters.length) {
      for (var index = 0; index < this._subEmitters.length; index++) {
        for (var _i = 0, _a = this._subEmitters[index]; _i < _a.length; _i++) {
          var subEmitter = _a[_i];
          subEmitter.dispose();
        }
      }
      this._subEmitters = [];
      this.subEmitters = [];
    }
    if (this._disposeEmitterOnDispose && this.emitter && this.emitter.dispose) {
      this.emitter.dispose(true);
    }
    if (this._onBeforeDrawParticlesObservable) {
      this._onBeforeDrawParticlesObservable.clear();
    }
    if (this._scene) {
      var index = this._scene.particleSystems.indexOf(this);
      if (index > -1) {
        this._scene.particleSystems.splice(index, 1);
      }
      this._scene._activeParticleSystems.dispose();
    }
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    this.onStoppedObservable.clear();
    this.reset();
  };
  ParticleSystem2.prototype.clone = function(name98, newEmitter) {
    var custom = __assign({}, this._customEffect);
    var program = null;
    var engine = this._engine;
    if (engine.createEffectForParticles) {
      if (this.customShader != null) {
        program = this.customShader;
        var defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join("\n") : "";
        custom[0] = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);
      }
    }
    var serialization = this.serialize();
    var result = ParticleSystem2.Parse(serialization, this._scene || this._engine, "");
    result.name = name98;
    result.customShader = program;
    result._customEffect = custom;
    if (newEmitter === void 0) {
      newEmitter = this.emitter;
    }
    if (this.noiseTexture) {
      result.noiseTexture = this.noiseTexture.clone();
    }
    result.emitter = newEmitter;
    if (!this.preventAutoStart) {
      result.start();
    }
    return result;
  };
  ParticleSystem2.prototype.serialize = function(serializeTexture) {
    if (serializeTexture === void 0) {
      serializeTexture = false;
    }
    var serializationObject = {};
    ParticleSystem2._Serialize(serializationObject, this, serializeTexture);
    serializationObject.textureMask = this.textureMask.asArray();
    serializationObject.customShader = this.customShader;
    serializationObject.preventAutoStart = this.preventAutoStart;
    if (this.subEmitters) {
      serializationObject.subEmitters = [];
      if (!this._subEmitters) {
        this._prepareSubEmitterInternalArray();
      }
      for (var _i = 0, _a = this._subEmitters; _i < _a.length; _i++) {
        var subs = _a[_i];
        var cell = [];
        for (var _b = 0, subs_1 = subs; _b < subs_1.length; _b++) {
          var sub = subs_1[_b];
          cell.push(sub.serialize());
        }
        serializationObject.subEmitters.push(cell);
      }
    }
    return serializationObject;
  };
  ParticleSystem2._Serialize = function(serializationObject, particleSystem, serializeTexture) {
    serializationObject.name = particleSystem.name;
    serializationObject.id = particleSystem.id;
    serializationObject.capacity = particleSystem.getCapacity();
    if (particleSystem.emitter.position) {
      var emitterMesh = particleSystem.emitter;
      serializationObject.emitterId = emitterMesh.id;
    } else {
      var emitterPosition = particleSystem.emitter;
      serializationObject.emitter = emitterPosition.asArray();
    }
    if (particleSystem.particleEmitterType) {
      serializationObject.particleEmitterType = particleSystem.particleEmitterType.serialize();
    }
    if (particleSystem.particleTexture) {
      if (serializeTexture) {
        serializationObject.texture = particleSystem.particleTexture.serialize();
      } else {
        serializationObject.textureName = particleSystem.particleTexture.name;
        serializationObject.invertY = !!particleSystem.particleTexture._invertY;
      }
    }
    serializationObject.isLocal = particleSystem.isLocal;
    SerializationHelper.AppendSerializedAnimations(particleSystem, serializationObject);
    serializationObject.beginAnimationOnStart = particleSystem.beginAnimationOnStart;
    serializationObject.beginAnimationFrom = particleSystem.beginAnimationFrom;
    serializationObject.beginAnimationTo = particleSystem.beginAnimationTo;
    serializationObject.beginAnimationLoop = particleSystem.beginAnimationLoop;
    serializationObject.startDelay = particleSystem.startDelay;
    serializationObject.renderingGroupId = particleSystem.renderingGroupId;
    serializationObject.isBillboardBased = particleSystem.isBillboardBased;
    serializationObject.billboardMode = particleSystem.billboardMode;
    serializationObject.minAngularSpeed = particleSystem.minAngularSpeed;
    serializationObject.maxAngularSpeed = particleSystem.maxAngularSpeed;
    serializationObject.minSize = particleSystem.minSize;
    serializationObject.maxSize = particleSystem.maxSize;
    serializationObject.minScaleX = particleSystem.minScaleX;
    serializationObject.maxScaleX = particleSystem.maxScaleX;
    serializationObject.minScaleY = particleSystem.minScaleY;
    serializationObject.maxScaleY = particleSystem.maxScaleY;
    serializationObject.minEmitPower = particleSystem.minEmitPower;
    serializationObject.maxEmitPower = particleSystem.maxEmitPower;
    serializationObject.minLifeTime = particleSystem.minLifeTime;
    serializationObject.maxLifeTime = particleSystem.maxLifeTime;
    serializationObject.emitRate = particleSystem.emitRate;
    serializationObject.gravity = particleSystem.gravity.asArray();
    serializationObject.noiseStrength = particleSystem.noiseStrength.asArray();
    serializationObject.color1 = particleSystem.color1.asArray();
    serializationObject.color2 = particleSystem.color2.asArray();
    serializationObject.colorDead = particleSystem.colorDead.asArray();
    serializationObject.updateSpeed = particleSystem.updateSpeed;
    serializationObject.targetStopDuration = particleSystem.targetStopDuration;
    serializationObject.blendMode = particleSystem.blendMode;
    serializationObject.preWarmCycles = particleSystem.preWarmCycles;
    serializationObject.preWarmStepOffset = particleSystem.preWarmStepOffset;
    serializationObject.minInitialRotation = particleSystem.minInitialRotation;
    serializationObject.maxInitialRotation = particleSystem.maxInitialRotation;
    serializationObject.startSpriteCellID = particleSystem.startSpriteCellID;
    serializationObject.endSpriteCellID = particleSystem.endSpriteCellID;
    serializationObject.spriteCellChangeSpeed = particleSystem.spriteCellChangeSpeed;
    serializationObject.spriteCellWidth = particleSystem.spriteCellWidth;
    serializationObject.spriteCellHeight = particleSystem.spriteCellHeight;
    serializationObject.spriteRandomStartCell = particleSystem.spriteRandomStartCell;
    serializationObject.isAnimationSheetEnabled = particleSystem.isAnimationSheetEnabled;
    var colorGradients = particleSystem.getColorGradients();
    if (colorGradients) {
      serializationObject.colorGradients = [];
      for (var _i = 0, colorGradients_1 = colorGradients; _i < colorGradients_1.length; _i++) {
        var colorGradient = colorGradients_1[_i];
        var serializedGradient = {
          gradient: colorGradient.gradient,
          color1: colorGradient.color1.asArray()
        };
        if (colorGradient.color2) {
          serializedGradient.color2 = colorGradient.color2.asArray();
        } else {
          serializedGradient.color2 = colorGradient.color1.asArray();
        }
        serializationObject.colorGradients.push(serializedGradient);
      }
    }
    var rampGradients = particleSystem.getRampGradients();
    if (rampGradients) {
      serializationObject.rampGradients = [];
      for (var _a = 0, rampGradients_1 = rampGradients; _a < rampGradients_1.length; _a++) {
        var rampGradient = rampGradients_1[_a];
        var serializedGradient = {
          gradient: rampGradient.gradient,
          color: rampGradient.color.asArray()
        };
        serializationObject.rampGradients.push(serializedGradient);
      }
      serializationObject.useRampGradients = particleSystem.useRampGradients;
    }
    var colorRemapGradients = particleSystem.getColorRemapGradients();
    if (colorRemapGradients) {
      serializationObject.colorRemapGradients = [];
      for (var _b = 0, colorRemapGradients_1 = colorRemapGradients; _b < colorRemapGradients_1.length; _b++) {
        var colorRemapGradient = colorRemapGradients_1[_b];
        var serializedGradient = {
          gradient: colorRemapGradient.gradient,
          factor1: colorRemapGradient.factor1
        };
        if (colorRemapGradient.factor2 !== void 0) {
          serializedGradient.factor2 = colorRemapGradient.factor2;
        } else {
          serializedGradient.factor2 = colorRemapGradient.factor1;
        }
        serializationObject.colorRemapGradients.push(serializedGradient);
      }
    }
    var alphaRemapGradients = particleSystem.getAlphaRemapGradients();
    if (alphaRemapGradients) {
      serializationObject.alphaRemapGradients = [];
      for (var _c = 0, alphaRemapGradients_1 = alphaRemapGradients; _c < alphaRemapGradients_1.length; _c++) {
        var alphaRemapGradient = alphaRemapGradients_1[_c];
        var serializedGradient = {
          gradient: alphaRemapGradient.gradient,
          factor1: alphaRemapGradient.factor1
        };
        if (alphaRemapGradient.factor2 !== void 0) {
          serializedGradient.factor2 = alphaRemapGradient.factor2;
        } else {
          serializedGradient.factor2 = alphaRemapGradient.factor1;
        }
        serializationObject.alphaRemapGradients.push(serializedGradient);
      }
    }
    var sizeGradients = particleSystem.getSizeGradients();
    if (sizeGradients) {
      serializationObject.sizeGradients = [];
      for (var _d = 0, sizeGradients_1 = sizeGradients; _d < sizeGradients_1.length; _d++) {
        var sizeGradient = sizeGradients_1[_d];
        var serializedGradient = {
          gradient: sizeGradient.gradient,
          factor1: sizeGradient.factor1
        };
        if (sizeGradient.factor2 !== void 0) {
          serializedGradient.factor2 = sizeGradient.factor2;
        } else {
          serializedGradient.factor2 = sizeGradient.factor1;
        }
        serializationObject.sizeGradients.push(serializedGradient);
      }
    }
    var angularSpeedGradients = particleSystem.getAngularSpeedGradients();
    if (angularSpeedGradients) {
      serializationObject.angularSpeedGradients = [];
      for (var _e = 0, angularSpeedGradients_1 = angularSpeedGradients; _e < angularSpeedGradients_1.length; _e++) {
        var angularSpeedGradient = angularSpeedGradients_1[_e];
        var serializedGradient = {
          gradient: angularSpeedGradient.gradient,
          factor1: angularSpeedGradient.factor1
        };
        if (angularSpeedGradient.factor2 !== void 0) {
          serializedGradient.factor2 = angularSpeedGradient.factor2;
        } else {
          serializedGradient.factor2 = angularSpeedGradient.factor1;
        }
        serializationObject.angularSpeedGradients.push(serializedGradient);
      }
    }
    var velocityGradients = particleSystem.getVelocityGradients();
    if (velocityGradients) {
      serializationObject.velocityGradients = [];
      for (var _f = 0, velocityGradients_1 = velocityGradients; _f < velocityGradients_1.length; _f++) {
        var velocityGradient = velocityGradients_1[_f];
        var serializedGradient = {
          gradient: velocityGradient.gradient,
          factor1: velocityGradient.factor1
        };
        if (velocityGradient.factor2 !== void 0) {
          serializedGradient.factor2 = velocityGradient.factor2;
        } else {
          serializedGradient.factor2 = velocityGradient.factor1;
        }
        serializationObject.velocityGradients.push(serializedGradient);
      }
    }
    var dragGradients = particleSystem.getDragGradients();
    if (dragGradients) {
      serializationObject.dragGradients = [];
      for (var _g = 0, dragGradients_1 = dragGradients; _g < dragGradients_1.length; _g++) {
        var dragGradient = dragGradients_1[_g];
        var serializedGradient = {
          gradient: dragGradient.gradient,
          factor1: dragGradient.factor1
        };
        if (dragGradient.factor2 !== void 0) {
          serializedGradient.factor2 = dragGradient.factor2;
        } else {
          serializedGradient.factor2 = dragGradient.factor1;
        }
        serializationObject.dragGradients.push(serializedGradient);
      }
    }
    var emitRateGradients = particleSystem.getEmitRateGradients();
    if (emitRateGradients) {
      serializationObject.emitRateGradients = [];
      for (var _h = 0, emitRateGradients_1 = emitRateGradients; _h < emitRateGradients_1.length; _h++) {
        var emitRateGradient = emitRateGradients_1[_h];
        var serializedGradient = {
          gradient: emitRateGradient.gradient,
          factor1: emitRateGradient.factor1
        };
        if (emitRateGradient.factor2 !== void 0) {
          serializedGradient.factor2 = emitRateGradient.factor2;
        } else {
          serializedGradient.factor2 = emitRateGradient.factor1;
        }
        serializationObject.emitRateGradients.push(serializedGradient);
      }
    }
    var startSizeGradients = particleSystem.getStartSizeGradients();
    if (startSizeGradients) {
      serializationObject.startSizeGradients = [];
      for (var _j = 0, startSizeGradients_1 = startSizeGradients; _j < startSizeGradients_1.length; _j++) {
        var startSizeGradient = startSizeGradients_1[_j];
        var serializedGradient = {
          gradient: startSizeGradient.gradient,
          factor1: startSizeGradient.factor1
        };
        if (startSizeGradient.factor2 !== void 0) {
          serializedGradient.factor2 = startSizeGradient.factor2;
        } else {
          serializedGradient.factor2 = startSizeGradient.factor1;
        }
        serializationObject.startSizeGradients.push(serializedGradient);
      }
    }
    var lifeTimeGradients = particleSystem.getLifeTimeGradients();
    if (lifeTimeGradients) {
      serializationObject.lifeTimeGradients = [];
      for (var _k = 0, lifeTimeGradients_1 = lifeTimeGradients; _k < lifeTimeGradients_1.length; _k++) {
        var lifeTimeGradient = lifeTimeGradients_1[_k];
        var serializedGradient = {
          gradient: lifeTimeGradient.gradient,
          factor1: lifeTimeGradient.factor1
        };
        if (lifeTimeGradient.factor2 !== void 0) {
          serializedGradient.factor2 = lifeTimeGradient.factor2;
        } else {
          serializedGradient.factor2 = lifeTimeGradient.factor1;
        }
        serializationObject.lifeTimeGradients.push(serializedGradient);
      }
    }
    var limitVelocityGradients = particleSystem.getLimitVelocityGradients();
    if (limitVelocityGradients) {
      serializationObject.limitVelocityGradients = [];
      for (var _l = 0, limitVelocityGradients_1 = limitVelocityGradients; _l < limitVelocityGradients_1.length; _l++) {
        var limitVelocityGradient = limitVelocityGradients_1[_l];
        var serializedGradient = {
          gradient: limitVelocityGradient.gradient,
          factor1: limitVelocityGradient.factor1
        };
        if (limitVelocityGradient.factor2 !== void 0) {
          serializedGradient.factor2 = limitVelocityGradient.factor2;
        } else {
          serializedGradient.factor2 = limitVelocityGradient.factor1;
        }
        serializationObject.limitVelocityGradients.push(serializedGradient);
      }
      serializationObject.limitVelocityDamping = particleSystem.limitVelocityDamping;
    }
    if (particleSystem.noiseTexture) {
      serializationObject.noiseTexture = particleSystem.noiseTexture.serialize();
    }
  };
  ParticleSystem2._Parse = function(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl) {
    var scene;
    if (sceneOrEngine instanceof ThinEngine) {
      scene = null;
    } else {
      scene = sceneOrEngine;
    }
    var internalClass = _TypeStore.GetClass("BABYLON.Texture");
    if (internalClass && scene) {
      if (parsedParticleSystem.texture) {
        particleSystem.particleTexture = internalClass.Parse(parsedParticleSystem.texture, scene, rootUrl);
      } else if (parsedParticleSystem.textureName) {
        particleSystem.particleTexture = new internalClass(rootUrl + parsedParticleSystem.textureName, scene, false, parsedParticleSystem.invertY !== void 0 ? parsedParticleSystem.invertY : true);
        particleSystem.particleTexture.name = parsedParticleSystem.textureName;
      }
    }
    if (!parsedParticleSystem.emitterId && parsedParticleSystem.emitterId !== 0 && parsedParticleSystem.emitter === void 0) {
      particleSystem.emitter = Vector3.Zero();
    } else if (parsedParticleSystem.emitterId && scene) {
      particleSystem.emitter = scene.getLastMeshByID(parsedParticleSystem.emitterId);
    } else {
      particleSystem.emitter = Vector3.FromArray(parsedParticleSystem.emitter);
    }
    particleSystem.isLocal = !!parsedParticleSystem.isLocal;
    if (parsedParticleSystem.renderingGroupId !== void 0) {
      particleSystem.renderingGroupId = parsedParticleSystem.renderingGroupId;
    }
    if (parsedParticleSystem.isBillboardBased !== void 0) {
      particleSystem.isBillboardBased = parsedParticleSystem.isBillboardBased;
    }
    if (parsedParticleSystem.billboardMode !== void 0) {
      particleSystem.billboardMode = parsedParticleSystem.billboardMode;
    }
    if (parsedParticleSystem.animations) {
      for (var animationIndex = 0; animationIndex < parsedParticleSystem.animations.length; animationIndex++) {
        var parsedAnimation = parsedParticleSystem.animations[animationIndex];
        var internalClass_1 = _TypeStore.GetClass("BABYLON.Animation");
        if (internalClass_1) {
          particleSystem.animations.push(internalClass_1.Parse(parsedAnimation));
        }
      }
      particleSystem.beginAnimationOnStart = parsedParticleSystem.beginAnimationOnStart;
      particleSystem.beginAnimationFrom = parsedParticleSystem.beginAnimationFrom;
      particleSystem.beginAnimationTo = parsedParticleSystem.beginAnimationTo;
      particleSystem.beginAnimationLoop = parsedParticleSystem.beginAnimationLoop;
    }
    if (parsedParticleSystem.autoAnimate && scene) {
      scene.beginAnimation(particleSystem, parsedParticleSystem.autoAnimateFrom, parsedParticleSystem.autoAnimateTo, parsedParticleSystem.autoAnimateLoop, parsedParticleSystem.autoAnimateSpeed || 1);
    }
    particleSystem.startDelay = parsedParticleSystem.startDelay | 0;
    particleSystem.minAngularSpeed = parsedParticleSystem.minAngularSpeed;
    particleSystem.maxAngularSpeed = parsedParticleSystem.maxAngularSpeed;
    particleSystem.minSize = parsedParticleSystem.minSize;
    particleSystem.maxSize = parsedParticleSystem.maxSize;
    if (parsedParticleSystem.minScaleX) {
      particleSystem.minScaleX = parsedParticleSystem.minScaleX;
      particleSystem.maxScaleX = parsedParticleSystem.maxScaleX;
      particleSystem.minScaleY = parsedParticleSystem.minScaleY;
      particleSystem.maxScaleY = parsedParticleSystem.maxScaleY;
    }
    if (parsedParticleSystem.preWarmCycles !== void 0) {
      particleSystem.preWarmCycles = parsedParticleSystem.preWarmCycles;
      particleSystem.preWarmStepOffset = parsedParticleSystem.preWarmStepOffset;
    }
    if (parsedParticleSystem.minInitialRotation !== void 0) {
      particleSystem.minInitialRotation = parsedParticleSystem.minInitialRotation;
      particleSystem.maxInitialRotation = parsedParticleSystem.maxInitialRotation;
    }
    particleSystem.minLifeTime = parsedParticleSystem.minLifeTime;
    particleSystem.maxLifeTime = parsedParticleSystem.maxLifeTime;
    particleSystem.minEmitPower = parsedParticleSystem.minEmitPower;
    particleSystem.maxEmitPower = parsedParticleSystem.maxEmitPower;
    particleSystem.emitRate = parsedParticleSystem.emitRate;
    particleSystem.gravity = Vector3.FromArray(parsedParticleSystem.gravity);
    if (parsedParticleSystem.noiseStrength) {
      particleSystem.noiseStrength = Vector3.FromArray(parsedParticleSystem.noiseStrength);
    }
    particleSystem.color1 = Color4.FromArray(parsedParticleSystem.color1);
    particleSystem.color2 = Color4.FromArray(parsedParticleSystem.color2);
    particleSystem.colorDead = Color4.FromArray(parsedParticleSystem.colorDead);
    particleSystem.updateSpeed = parsedParticleSystem.updateSpeed;
    particleSystem.targetStopDuration = parsedParticleSystem.targetStopDuration;
    particleSystem.blendMode = parsedParticleSystem.blendMode;
    if (parsedParticleSystem.colorGradients) {
      for (var _i = 0, _a = parsedParticleSystem.colorGradients; _i < _a.length; _i++) {
        var colorGradient = _a[_i];
        particleSystem.addColorGradient(colorGradient.gradient, Color4.FromArray(colorGradient.color1), colorGradient.color2 ? Color4.FromArray(colorGradient.color2) : void 0);
      }
    }
    if (parsedParticleSystem.rampGradients) {
      for (var _b = 0, _c = parsedParticleSystem.rampGradients; _b < _c.length; _b++) {
        var rampGradient = _c[_b];
        particleSystem.addRampGradient(rampGradient.gradient, Color3.FromArray(rampGradient.color));
      }
      particleSystem.useRampGradients = parsedParticleSystem.useRampGradients;
    }
    if (parsedParticleSystem.colorRemapGradients) {
      for (var _d = 0, _e = parsedParticleSystem.colorRemapGradients; _d < _e.length; _d++) {
        var colorRemapGradient = _e[_d];
        particleSystem.addColorRemapGradient(colorRemapGradient.gradient, colorRemapGradient.factor1 !== void 0 ? colorRemapGradient.factor1 : colorRemapGradient.factor, colorRemapGradient.factor2);
      }
    }
    if (parsedParticleSystem.alphaRemapGradients) {
      for (var _f = 0, _g = parsedParticleSystem.alphaRemapGradients; _f < _g.length; _f++) {
        var alphaRemapGradient = _g[_f];
        particleSystem.addAlphaRemapGradient(alphaRemapGradient.gradient, alphaRemapGradient.factor1 !== void 0 ? alphaRemapGradient.factor1 : alphaRemapGradient.factor, alphaRemapGradient.factor2);
      }
    }
    if (parsedParticleSystem.sizeGradients) {
      for (var _h = 0, _j = parsedParticleSystem.sizeGradients; _h < _j.length; _h++) {
        var sizeGradient = _j[_h];
        particleSystem.addSizeGradient(sizeGradient.gradient, sizeGradient.factor1 !== void 0 ? sizeGradient.factor1 : sizeGradient.factor, sizeGradient.factor2);
      }
    }
    if (parsedParticleSystem.angularSpeedGradients) {
      for (var _k = 0, _l = parsedParticleSystem.angularSpeedGradients; _k < _l.length; _k++) {
        var angularSpeedGradient = _l[_k];
        particleSystem.addAngularSpeedGradient(angularSpeedGradient.gradient, angularSpeedGradient.factor1 !== void 0 ? angularSpeedGradient.factor1 : angularSpeedGradient.factor, angularSpeedGradient.factor2);
      }
    }
    if (parsedParticleSystem.velocityGradients) {
      for (var _m = 0, _o = parsedParticleSystem.velocityGradients; _m < _o.length; _m++) {
        var velocityGradient = _o[_m];
        particleSystem.addVelocityGradient(velocityGradient.gradient, velocityGradient.factor1 !== void 0 ? velocityGradient.factor1 : velocityGradient.factor, velocityGradient.factor2);
      }
    }
    if (parsedParticleSystem.dragGradients) {
      for (var _p = 0, _q = parsedParticleSystem.dragGradients; _p < _q.length; _p++) {
        var dragGradient = _q[_p];
        particleSystem.addDragGradient(dragGradient.gradient, dragGradient.factor1 !== void 0 ? dragGradient.factor1 : dragGradient.factor, dragGradient.factor2);
      }
    }
    if (parsedParticleSystem.emitRateGradients) {
      for (var _r = 0, _s = parsedParticleSystem.emitRateGradients; _r < _s.length; _r++) {
        var emitRateGradient = _s[_r];
        particleSystem.addEmitRateGradient(emitRateGradient.gradient, emitRateGradient.factor1 !== void 0 ? emitRateGradient.factor1 : emitRateGradient.factor, emitRateGradient.factor2);
      }
    }
    if (parsedParticleSystem.startSizeGradients) {
      for (var _t = 0, _u = parsedParticleSystem.startSizeGradients; _t < _u.length; _t++) {
        var startSizeGradient = _u[_t];
        particleSystem.addStartSizeGradient(startSizeGradient.gradient, startSizeGradient.factor1 !== void 0 ? startSizeGradient.factor1 : startSizeGradient.factor, startSizeGradient.factor2);
      }
    }
    if (parsedParticleSystem.lifeTimeGradients) {
      for (var _v = 0, _w = parsedParticleSystem.lifeTimeGradients; _v < _w.length; _v++) {
        var lifeTimeGradient = _w[_v];
        particleSystem.addLifeTimeGradient(lifeTimeGradient.gradient, lifeTimeGradient.factor1 !== void 0 ? lifeTimeGradient.factor1 : lifeTimeGradient.factor, lifeTimeGradient.factor2);
      }
    }
    if (parsedParticleSystem.limitVelocityGradients) {
      for (var _x = 0, _y = parsedParticleSystem.limitVelocityGradients; _x < _y.length; _x++) {
        var limitVelocityGradient = _y[_x];
        particleSystem.addLimitVelocityGradient(limitVelocityGradient.gradient, limitVelocityGradient.factor1 !== void 0 ? limitVelocityGradient.factor1 : limitVelocityGradient.factor, limitVelocityGradient.factor2);
      }
      particleSystem.limitVelocityDamping = parsedParticleSystem.limitVelocityDamping;
    }
    if (parsedParticleSystem.noiseTexture && scene) {
      var internalClass_2 = _TypeStore.GetClass("BABYLON.ProceduralTexture");
      particleSystem.noiseTexture = internalClass_2.Parse(parsedParticleSystem.noiseTexture, scene, rootUrl);
    }
    var emitterType;
    if (parsedParticleSystem.particleEmitterType) {
      switch (parsedParticleSystem.particleEmitterType.type) {
        case "SphereParticleEmitter":
          emitterType = new SphereParticleEmitter();
          break;
        case "SphereDirectedParticleEmitter":
          emitterType = new SphereDirectedParticleEmitter();
          break;
        case "ConeEmitter":
        case "ConeParticleEmitter":
          emitterType = new ConeParticleEmitter();
          break;
        case "CylinderParticleEmitter":
          emitterType = new CylinderParticleEmitter();
          break;
        case "CylinderDirectedParticleEmitter":
          emitterType = new CylinderDirectedParticleEmitter();
          break;
        case "HemisphericParticleEmitter":
          emitterType = new HemisphericParticleEmitter();
          break;
        case "PointParticleEmitter":
          emitterType = new PointParticleEmitter();
          break;
        case "MeshParticleEmitter":
          emitterType = new MeshParticleEmitter();
          break;
        case "BoxEmitter":
        case "BoxParticleEmitter":
        default:
          emitterType = new BoxParticleEmitter();
          break;
      }
      emitterType.parse(parsedParticleSystem.particleEmitterType, scene);
    } else {
      emitterType = new BoxParticleEmitter();
      emitterType.parse(parsedParticleSystem, scene);
    }
    particleSystem.particleEmitterType = emitterType;
    particleSystem.startSpriteCellID = parsedParticleSystem.startSpriteCellID;
    particleSystem.endSpriteCellID = parsedParticleSystem.endSpriteCellID;
    particleSystem.spriteCellWidth = parsedParticleSystem.spriteCellWidth;
    particleSystem.spriteCellHeight = parsedParticleSystem.spriteCellHeight;
    particleSystem.spriteCellChangeSpeed = parsedParticleSystem.spriteCellChangeSpeed;
    particleSystem.spriteRandomStartCell = parsedParticleSystem.spriteRandomStartCell;
  };
  ParticleSystem2.Parse = function(parsedParticleSystem, sceneOrEngine, rootUrl, doNotStart) {
    if (doNotStart === void 0) {
      doNotStart = false;
    }
    var name98 = parsedParticleSystem.name;
    var custom = null;
    var program = null;
    var engine;
    var scene;
    if (sceneOrEngine instanceof ThinEngine) {
      engine = sceneOrEngine;
    } else {
      scene = sceneOrEngine;
      engine = scene.getEngine();
    }
    if (parsedParticleSystem.customShader && engine.createEffectForParticles) {
      program = parsedParticleSystem.customShader;
      var defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join("\n") : "";
      custom = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);
    }
    var particleSystem = new ParticleSystem2(name98, parsedParticleSystem.capacity, sceneOrEngine, custom, parsedParticleSystem.isAnimationSheetEnabled);
    particleSystem.customShader = program;
    if (parsedParticleSystem.id) {
      particleSystem.id = parsedParticleSystem.id;
    }
    if (parsedParticleSystem.subEmitters) {
      particleSystem.subEmitters = [];
      for (var _i = 0, _a = parsedParticleSystem.subEmitters; _i < _a.length; _i++) {
        var cell = _a[_i];
        var cellArray = [];
        for (var _b = 0, cell_1 = cell; _b < cell_1.length; _b++) {
          var sub = cell_1[_b];
          cellArray.push(SubEmitter.Parse(sub, sceneOrEngine, rootUrl));
        }
        particleSystem.subEmitters.push(cellArray);
      }
    }
    ParticleSystem2._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);
    if (parsedParticleSystem.textureMask) {
      particleSystem.textureMask = Color4.FromArray(parsedParticleSystem.textureMask);
    }
    if (parsedParticleSystem.preventAutoStart) {
      particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;
    }
    if (!doNotStart && !particleSystem.preventAutoStart) {
      particleSystem.start();
    }
    return particleSystem;
  };
  ParticleSystem2.BILLBOARDMODE_Y = 2;
  ParticleSystem2.BILLBOARDMODE_ALL = 7;
  ParticleSystem2.BILLBOARDMODE_STRETCHED = 8;
  return ParticleSystem2;
}(BaseParticleSystem);
SubEmitter._ParseParticleSystem = ParticleSystem.Parse;

// node_modules/@babylonjs/core/Shaders/gpuUpdateParticles.fragment.js
var name47 = "gpuUpdateParticlesPixelShader";
var shader47 = "#version 300 es\nvoid main() {\ndiscard;\n}\n";
Effect.ShadersStore[name47] = shader47;

// node_modules/@babylonjs/core/Shaders/gpuUpdateParticles.vertex.js
var name48 = "gpuUpdateParticlesVertexShader";
var shader48 = "#version 300 es\n#define PI 3.14159\nuniform float currentCount;\nuniform float timeDelta;\nuniform float stopFactor;\n#ifndef LOCAL\nuniform mat4 emitterWM;\n#endif\nuniform vec2 lifeTime;\nuniform vec2 emitPower;\nuniform vec2 sizeRange;\nuniform vec4 scaleRange;\n#ifndef COLORGRADIENTS\nuniform vec4 color1;\nuniform vec4 color2;\n#endif\nuniform vec3 gravity;\nuniform sampler2D randomSampler;\nuniform sampler2D randomSampler2;\nuniform vec4 angleRange;\n#ifdef BOXEMITTER\nuniform vec3 direction1;\nuniform vec3 direction2;\nuniform vec3 minEmitBox;\nuniform vec3 maxEmitBox;\n#endif\n#ifdef POINTEMITTER\nuniform vec3 direction1;\nuniform vec3 direction2;\n#endif\n#ifdef HEMISPHERICEMITTER\nuniform float radius;\nuniform float radiusRange;\nuniform float directionRandomizer;\n#endif\n#ifdef SPHEREEMITTER\nuniform float radius;\nuniform float radiusRange;\n#ifdef DIRECTEDSPHEREEMITTER\nuniform vec3 direction1;\nuniform vec3 direction2;\n#else\nuniform float directionRandomizer;\n#endif\n#endif\n#ifdef CYLINDEREMITTER\nuniform float radius;\nuniform float height;\nuniform float radiusRange;\n#ifdef DIRECTEDCYLINDEREMITTER\nuniform vec3 direction1;\nuniform vec3 direction2;\n#else\nuniform float directionRandomizer;\n#endif\n#endif\n#ifdef CONEEMITTER\nuniform vec2 radius;\nuniform float coneAngle;\nuniform vec2 height;\nuniform float directionRandomizer;\n#endif\n\nin vec3 position;\n#ifdef CUSTOMEMITTER\nin vec3 initialPosition;\n#endif\nin float age;\nin float life;\nin vec4 seed;\nin vec3 size;\n#ifndef COLORGRADIENTS\nin vec4 color;\n#endif\nin vec3 direction;\n#ifndef BILLBOARD\nin vec3 initialDirection;\n#endif\n#ifdef ANGULARSPEEDGRADIENTS\nin float angle;\n#else\nin vec2 angle;\n#endif\n#ifdef ANIMATESHEET\nin float cellIndex;\n#ifdef ANIMATESHEETRANDOMSTART\nin float cellStartOffset;\n#endif\n#endif\n#ifdef NOISE\nin vec3 noiseCoordinates1;\nin vec3 noiseCoordinates2;\n#endif\n\nout vec3 outPosition;\n#ifdef CUSTOMEMITTER\nout vec3 outInitialPosition;\n#endif\nout float outAge;\nout float outLife;\nout vec4 outSeed;\nout vec3 outSize;\n#ifndef COLORGRADIENTS\nout vec4 outColor;\n#endif\nout vec3 outDirection;\n#ifndef BILLBOARD\nout vec3 outInitialDirection;\n#endif\n#ifdef ANGULARSPEEDGRADIENTS\nout float outAngle;\n#else\nout vec2 outAngle;\n#endif\n#ifdef ANIMATESHEET\nout float outCellIndex;\n#ifdef ANIMATESHEETRANDOMSTART\nout float outCellStartOffset;\n#endif\n#endif\n#ifdef NOISE\nout vec3 outNoiseCoordinates1;\nout vec3 outNoiseCoordinates2;\n#endif\n#ifdef SIZEGRADIENTS\nuniform sampler2D sizeGradientSampler;\n#endif\n#ifdef ANGULARSPEEDGRADIENTS\nuniform sampler2D angularSpeedGradientSampler;\n#endif\n#ifdef VELOCITYGRADIENTS\nuniform sampler2D velocityGradientSampler;\n#endif\n#ifdef LIMITVELOCITYGRADIENTS\nuniform sampler2D limitVelocityGradientSampler;\nuniform float limitVelocityDamping;\n#endif\n#ifdef DRAGGRADIENTS\nuniform sampler2D dragGradientSampler;\n#endif\n#ifdef NOISE\nuniform vec3 noiseStrength;\nuniform sampler2D noiseSampler;\n#endif\n#ifdef ANIMATESHEET\nuniform vec3 cellInfos;\n#endif\nvec3 getRandomVec3(float offset) {\nreturn texture(randomSampler2,vec2(float(gl_VertexID)*offset/currentCount,0)).rgb;\n}\nvec4 getRandomVec4(float offset) {\nreturn texture(randomSampler,vec2(float(gl_VertexID)*offset/currentCount,0));\n}\nvoid main() {\nfloat newAge=age+timeDelta;\n\nif (newAge>=life && stopFactor != 0.) {\nvec3 newPosition;\nvec3 newDirection;\n\nvec4 randoms=getRandomVec4(seed.x);\n\noutLife=lifeTime.x+(lifeTime.y-lifeTime.x)*randoms.r;\noutAge=newAge-life;\n\noutSeed=seed;\n\n#ifdef SIZEGRADIENTS\noutSize.x=texture(sizeGradientSampler,vec2(0,0)).r;\n#else\noutSize.x=sizeRange.x+(sizeRange.y-sizeRange.x)*randoms.g;\n#endif\noutSize.y=scaleRange.x+(scaleRange.y-scaleRange.x)*randoms.b;\noutSize.z=scaleRange.z+(scaleRange.w-scaleRange.z)*randoms.a;\n#ifndef COLORGRADIENTS\n\noutColor=color1+(color2-color1)*randoms.b;\n#endif\n\n#ifndef ANGULARSPEEDGRADIENTS\noutAngle.y=angleRange.x+(angleRange.y-angleRange.x)*randoms.a;\noutAngle.x=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;\n#else\noutAngle=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;\n#endif\n\n#ifdef POINTEMITTER\nvec3 randoms2=getRandomVec3(seed.y);\nvec3 randoms3=getRandomVec3(seed.z);\nnewPosition=vec3(0,0,0);\nnewDirection=direction1+(direction2-direction1)*randoms3;\n#elif defined(BOXEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\nvec3 randoms3=getRandomVec3(seed.z);\nnewPosition=minEmitBox+(maxEmitBox-minEmitBox)*randoms2;\nnewDirection=direction1+(direction2-direction1)*randoms3;\n#elif defined(HEMISPHERICEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\nvec3 randoms3=getRandomVec3(seed.z);\n\nfloat phi=2.0*PI*randoms2.x;\nfloat theta=acos(2.0*randoms2.y-1.0);\nfloat randX=cos(phi)*sin(theta);\nfloat randY=cos(theta);\nfloat randZ=sin(phi)*sin(theta);\nnewPosition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,abs(randY),randZ);\nnewDirection=newPosition+directionRandomizer*randoms3;\n#elif defined(SPHEREEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\nvec3 randoms3=getRandomVec3(seed.z);\n\nfloat phi=2.0*PI*randoms2.x;\nfloat theta=acos(2.0*randoms2.y-1.0);\nfloat randX=cos(phi)*sin(theta);\nfloat randY=cos(theta);\nfloat randZ=sin(phi)*sin(theta);\nnewPosition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,randY,randZ);\n#ifdef DIRECTEDSPHEREEMITTER\nnewDirection=direction1+(direction2-direction1)*randoms3;\n#else\n\nnewDirection=newPosition+directionRandomizer*randoms3;\n#endif\n#elif defined(CYLINDEREMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\nvec3 randoms3=getRandomVec3(seed.z);\n\nfloat yPos=(randoms2.x-0.5)*height;\nfloat angle=randoms2.y*PI*2.;\nfloat inverseRadiusRangeSquared=((1.-radiusRange)*(1.-radiusRange));\nfloat positionRadius=radius*sqrt(inverseRadiusRangeSquared+(randoms2.z*(1.-inverseRadiusRangeSquared)));\nfloat xPos=positionRadius*cos(angle);\nfloat zPos=positionRadius*sin(angle);\nnewPosition=vec3(xPos,yPos,zPos);\n#ifdef DIRECTEDCYLINDEREMITTER\nnewDirection=direction1+(direction2-direction1)*randoms3;\n#else\n\nangle=angle+((randoms3.x-0.5)*PI);\nnewDirection=vec3(cos(angle),randoms3.y-0.5,sin(angle));\nnewDirection=normalize(newDirection);\n#endif\n#elif defined(CONEEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\nfloat s=2.0*PI*randoms2.x;\n#ifdef CONEEMITTERSPAWNPOINT\nfloat h=0.0001;\n#else\nfloat h=randoms2.y*height.y;\n\nh=1.-h*h;\n#endif\nfloat lRadius=radius.x-radius.x*randoms2.z*radius.y;\nlRadius=lRadius*h;\nfloat randX=lRadius*sin(s);\nfloat randZ=lRadius*cos(s);\nfloat randY=h*height.x;\nnewPosition=vec3(randX,randY,randZ);\n\nif (abs(cos(coneAngle)) == 1.0) {\nnewDirection=vec3(0.,1.0,0.);\n} else {\nvec3 randoms3=getRandomVec3(seed.z);\nnewDirection=normalize(newPosition+directionRandomizer*randoms3);\n}\n#elif defined(CUSTOMEMITTER)\nnewPosition=initialPosition;\noutInitialPosition=initialPosition;\n#else\n\nnewPosition=vec3(0.,0.,0.);\n\nnewDirection=2.0*(getRandomVec3(seed.w)-vec3(0.5,0.5,0.5));\n#endif\nfloat power=emitPower.x+(emitPower.y-emitPower.x)*randoms.a;\n#ifdef LOCAL\noutPosition=newPosition;\n#else\noutPosition=(emitterWM*vec4(newPosition,1.)).xyz;\n#endif\n#ifdef CUSTOMEMITTER\noutDirection=direction;\n#ifndef BILLBOARD\noutInitialDirection=direction;\n#endif\n#else\n#ifdef LOCAL\nvec3 initial=newDirection;\n#else\nvec3 initial=(emitterWM*vec4(newDirection,0.)).xyz;\n#endif\noutDirection=initial*power;\n#ifndef BILLBOARD\noutInitialDirection=initial;\n#endif\n#endif\n#ifdef ANIMATESHEET\noutCellIndex=cellInfos.x;\n#ifdef ANIMATESHEETRANDOMSTART\noutCellStartOffset=randoms.a*outLife;\n#endif\n#endif\n#ifdef NOISE\noutNoiseCoordinates1=noiseCoordinates1;\noutNoiseCoordinates2=noiseCoordinates2;\n#endif\n} else {\nfloat directionScale=timeDelta;\noutAge=newAge;\nfloat ageGradient=newAge/life;\n#ifdef VELOCITYGRADIENTS\ndirectionScale*=texture(velocityGradientSampler,vec2(ageGradient,0)).r;\n#endif\n#ifdef DRAGGRADIENTS\ndirectionScale*=1.0-texture(dragGradientSampler,vec2(ageGradient,0)).r;\n#endif\n#if defined(CUSTOMEMITTER)\noutPosition=position+(direction-position)*ageGradient;\noutInitialPosition=initialPosition;\n#else\noutPosition=position+direction*directionScale;\n#endif\noutLife=life;\noutSeed=seed;\n#ifndef COLORGRADIENTS\noutColor=color;\n#endif\n#ifdef SIZEGRADIENTS\noutSize.x=texture(sizeGradientSampler,vec2(ageGradient,0)).r;\noutSize.yz=size.yz;\n#else\noutSize=size;\n#endif\n#ifndef BILLBOARD\noutInitialDirection=initialDirection;\n#endif\n#ifdef CUSTOMEMITTER\noutDirection=direction;\n#else\nvec3 updatedDirection=direction+gravity*timeDelta;\n#ifdef LIMITVELOCITYGRADIENTS\nfloat limitVelocity=texture(limitVelocityGradientSampler,vec2(ageGradient,0)).r;\nfloat currentVelocity=length(updatedDirection);\nif (currentVelocity>limitVelocity) {\nupdatedDirection=updatedDirection*limitVelocityDamping;\n}\n#endif\noutDirection=updatedDirection;\n#ifdef NOISE\nfloat fetchedR=texture(noiseSampler,vec2(noiseCoordinates1.x,noiseCoordinates1.y)*vec2(0.5)+vec2(0.5)).r;\nfloat fetchedG=texture(noiseSampler,vec2(noiseCoordinates1.z,noiseCoordinates2.x)*vec2(0.5)+vec2(0.5)).r;\nfloat fetchedB=texture(noiseSampler,vec2(noiseCoordinates2.y,noiseCoordinates2.z)*vec2(0.5)+vec2(0.5)).r;\nvec3 force=vec3(2.*fetchedR-1.,2.*fetchedG-1.,2.*fetchedB-1.)*noiseStrength;\noutDirection=outDirection+force*timeDelta;\noutNoiseCoordinates1=noiseCoordinates1;\noutNoiseCoordinates2=noiseCoordinates2;\n#endif\n#endif\n#ifdef ANGULARSPEEDGRADIENTS\nfloat angularSpeed=texture(angularSpeedGradientSampler,vec2(ageGradient,0)).r;\noutAngle=angle+angularSpeed*timeDelta;\n#else\noutAngle=vec2(angle.x+angle.y*timeDelta,angle.y);\n#endif\n#ifdef ANIMATESHEET\nfloat offsetAge=outAge;\nfloat dist=cellInfos.y-cellInfos.x;\n#ifdef ANIMATESHEETRANDOMSTART\noutCellStartOffset=cellStartOffset;\noffsetAge+=cellStartOffset;\n#else\nfloat cellStartOffset=0.;\n#endif\nfloat ratio=clamp(mod(cellStartOffset+cellInfos.z*offsetAge,life)/life,0.,1.0);\noutCellIndex=float(int(cellInfos.x+ratio*dist));\n#endif\n}\n}";
Effect.ShadersStore[name48] = shader48;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration2.js
var name49 = "clipPlaneFragmentDeclaration2";
var shader49 = "#ifdef CLIPPLANE\nin float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nin float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nin float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nin float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nin float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nin float fClipDistance6;\n#endif";
Effect.IncludesShadersStore[name49] = shader49;

// node_modules/@babylonjs/core/Shaders/gpuRenderParticles.fragment.js
var name50 = "gpuRenderParticlesPixelShader";
var shader50 = "#version 300 es\nuniform sampler2D diffuseSampler;\nin vec2 vUV;\nin vec4 vColor;\nout vec4 outFragColor;\n#include<clipPlaneFragmentDeclaration2>\n#include<imageProcessingDeclaration>\n#include<helperFunctions>\n#include<imageProcessingFunctions>\nvoid main() {\n#include<clipPlaneFragment>\nvec4 textureColor=texture(diffuseSampler,vUV);\noutFragColor=textureColor*vColor;\n#ifdef BLENDMULTIPLYMODE\nfloat alpha=vColor.a*textureColor.a;\noutFragColor.rgb=outFragColor.rgb*alpha+vec3(1.0)*(1.0-alpha);\n#endif\n\n\n#ifdef IMAGEPROCESSINGPOSTPROCESS\noutFragColor.rgb=toLinearSpace(outFragColor.rgb);\n#else\n#ifdef IMAGEPROCESSING\noutFragColor.rgb=toLinearSpace(outFragColor.rgb);\noutFragColor=applyImageProcessing(outFragColor);\n#endif\n#endif\n}\n";
Effect.ShadersStore[name50] = shader50;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration2.js
var name51 = "clipPlaneVertexDeclaration2";
var shader51 = "#ifdef CLIPPLANE\nuniform vec4 vClipPlane;\nout float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nuniform vec4 vClipPlane2;\nout float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nuniform vec4 vClipPlane3;\nout float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nuniform vec4 vClipPlane4;\nout float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nuniform vec4 vClipPlane5;\nout float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nuniform vec4 vClipPlane6;\nout float fClipDistance6;\n#endif";
Effect.IncludesShadersStore[name51] = shader51;

// node_modules/@babylonjs/core/Shaders/gpuRenderParticles.vertex.js
var name52 = "gpuRenderParticlesVertexShader";
var shader52 = "#version 300 es\nuniform mat4 view;\nuniform mat4 projection;\nuniform vec2 translationPivot;\nuniform vec3 worldOffset;\n#ifdef LOCAL\nuniform mat4 emitterWM;\n#endif\n\nin vec3 position;\nin float age;\nin float life;\nin vec3 size;\n#ifndef BILLBOARD\nin vec3 initialDirection;\n#endif\n#ifdef BILLBOARDSTRETCHED\nin vec3 direction;\n#endif\nin float angle;\n#ifdef ANIMATESHEET\nin float cellIndex;\n#endif\nin vec2 offset;\nin vec2 uv;\nout vec2 vUV;\nout vec4 vColor;\nout vec3 vPositionW;\n#if defined(BILLBOARD) && !defined(BILLBOARDY) && !defined(BILLBOARDSTRETCHED)\nuniform mat4 invView;\n#endif\n#include<clipPlaneVertexDeclaration2>\n#ifdef COLORGRADIENTS\nuniform sampler2D colorGradientSampler;\n#else\nuniform vec4 colorDead;\nin vec4 color;\n#endif\n#ifdef ANIMATESHEET\nuniform vec3 sheetInfos;\n#endif\n#ifdef BILLBOARD\nuniform vec3 eyePosition;\n#endif\nvec3 rotate(vec3 yaxis,vec3 rotatedCorner) {\nvec3 xaxis=normalize(cross(vec3(0.,1.0,0.),yaxis));\nvec3 zaxis=normalize(cross(yaxis,xaxis));\nvec3 row0=vec3(xaxis.x,xaxis.y,xaxis.z);\nvec3 row1=vec3(yaxis.x,yaxis.y,yaxis.z);\nvec3 row2=vec3(zaxis.x,zaxis.y,zaxis.z);\nmat3 rotMatrix=mat3(row0,row1,row2);\nvec3 alignedCorner=rotMatrix*rotatedCorner;\n#ifdef LOCAL\nreturn ((emitterWM*vec4(position,1.0)).xyz+worldOffset)+alignedCorner;\n#else\nreturn (position+worldOffset)+alignedCorner;\n#endif\n}\n#ifdef BILLBOARDSTRETCHED\nvec3 rotateAlign(vec3 toCamera,vec3 rotatedCorner) {\nvec3 normalizedToCamera=normalize(toCamera);\nvec3 normalizedCrossDirToCamera=normalize(cross(normalize(direction),normalizedToCamera));\nvec3 crossProduct=normalize(cross(normalizedToCamera,normalizedCrossDirToCamera));\nvec3 row0=vec3(normalizedCrossDirToCamera.x,normalizedCrossDirToCamera.y,normalizedCrossDirToCamera.z);\nvec3 row1=vec3(crossProduct.x,crossProduct.y,crossProduct.z);\nvec3 row2=vec3(normalizedToCamera.x,normalizedToCamera.y,normalizedToCamera.z);\nmat3 rotMatrix=mat3(row0,row1,row2);\nvec3 alignedCorner=rotMatrix*rotatedCorner;\n#ifdef LOCAL\nreturn ((emitterWM*vec4(position,1.0)).xyz+worldOffset)+alignedCorner;\n#else\nreturn (position+worldOffset)+alignedCorner;\n#endif\n}\n#endif\nvoid main() {\n#ifdef ANIMATESHEET\nfloat rowOffset=floor(cellIndex/sheetInfos.z);\nfloat columnOffset=cellIndex-rowOffset*sheetInfos.z;\nvec2 uvScale=sheetInfos.xy;\nvec2 uvOffset=vec2(uv.x ,1.0-uv.y);\nvUV=(uvOffset+vec2(columnOffset,rowOffset))*uvScale;\n#else\nvUV=uv;\n#endif\nfloat ratio=age/life;\n#ifdef COLORGRADIENTS\nvColor=texture(colorGradientSampler,vec2(ratio,0));\n#else\nvColor=color*vec4(1.0-ratio)+colorDead*vec4(ratio);\n#endif\nvec2 cornerPos=(offset-translationPivot)*size.yz*size.x+translationPivot;\n#ifdef BILLBOARD\nvec4 rotatedCorner;\nrotatedCorner.w=0.;\n#ifdef BILLBOARDY\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\nrotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\nrotatedCorner.y=0.;\nvec3 yaxis=(position+worldOffset)-eyePosition;\nyaxis.y=0.;\nvPositionW=rotate(normalize(yaxis),rotatedCorner.xyz);\nvec4 viewPosition=(view*vec4(vPositionW,1.0));\n#elif defined(BILLBOARDSTRETCHED)\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\nrotatedCorner.z=0.;\nvec3 toCamera=(position+worldOffset)-eyePosition;\nvPositionW=rotateAlign(toCamera,rotatedCorner.xyz);\nvec4 viewPosition=(view*vec4(vPositionW,1.0));\n#else\n\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\nrotatedCorner.z=0.;\n\n#ifdef LOCAL\nvec4 viewPosition=view*vec4(((emitterWM*vec4(position,1.0)).xyz+worldOffset),1.0)+rotatedCorner;\n#else\nvec4 viewPosition=view*vec4((position+worldOffset),1.0)+rotatedCorner;\n#endif\nvPositionW=(invView*viewPosition).xyz;\n#endif\n#else\n\nvec3 rotatedCorner;\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\nrotatedCorner.y=0.;\nrotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\nvec3 yaxis=normalize(initialDirection);\nvPositionW=rotate(yaxis,rotatedCorner);\n\nvec4 viewPosition=view*vec4(vPositionW,1.0);\n#endif\ngl_Position=projection*viewPosition;\n\n#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nvec4 worldPos=vec4(vPositionW,1.0);\n#endif\n#include<clipPlaneVertex>\n}";
Effect.ShadersStore[name52] = shader52;

// node_modules/@babylonjs/core/Particles/gpuParticleSystem.js
var GPUParticleSystem = function(_super) {
  __extends(GPUParticleSystem2, _super);
  function GPUParticleSystem2(name98, options, sceneOrEngine, isAnimationSheetEnabled, customEffect) {
    if (isAnimationSheetEnabled === void 0) {
      isAnimationSheetEnabled = false;
    }
    if (customEffect === void 0) {
      customEffect = null;
    }
    var _this = _super.call(this, name98) || this;
    _this.layerMask = 268435455;
    _this._accumulatedCount = 0;
    _this._targetIndex = 0;
    _this._currentRenderId = -1;
    _this._started = false;
    _this._stopped = false;
    _this._timeDelta = 0;
    _this._actualFrame = 0;
    _this._rawTextureWidth = 256;
    _this.onDisposeObservable = new Observable();
    _this.onStoppedObservable = new Observable();
    _this.forceDepthWrite = false;
    _this._preWarmDone = false;
    _this.isLocal = false;
    _this._onBeforeDrawParticlesObservable = null;
    if (!sceneOrEngine || sceneOrEngine.getClassName() === "Scene") {
      _this._scene = sceneOrEngine || EngineStore.LastCreatedScene;
      _this._engine = _this._scene.getEngine();
      _this.uniqueId = _this._scene.getUniqueId();
      _this._scene.particleSystems.push(_this);
    } else {
      _this._engine = sceneOrEngine;
      _this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100);
    }
    _this._customEffect = { 0: customEffect };
    _this._attachImageProcessingConfiguration(null);
    if (!options.randomTextureSize) {
      delete options.randomTextureSize;
    }
    var fullOptions = __assign({ capacity: 5e4, randomTextureSize: _this._engine.getCaps().maxTextureSize }, options);
    var optionsAsNumber = options;
    if (isFinite(optionsAsNumber)) {
      fullOptions.capacity = optionsAsNumber;
    }
    _this._capacity = fullOptions.capacity;
    _this._activeCount = fullOptions.capacity;
    _this._currentActiveCount = 0;
    _this._isAnimationSheetEnabled = isAnimationSheetEnabled;
    _this._updateEffectOptions = {
      attributes: ["position", "initialPosition", "age", "life", "seed", "size", "color", "direction", "initialDirection", "angle", "cellIndex", "cellStartOffset", "noiseCoordinates1", "noiseCoordinates2"],
      uniformsNames: [
        "currentCount",
        "timeDelta",
        "emitterWM",
        "lifeTime",
        "color1",
        "color2",
        "sizeRange",
        "scaleRange",
        "gravity",
        "emitPower",
        "direction1",
        "direction2",
        "minEmitBox",
        "maxEmitBox",
        "radius",
        "directionRandomizer",
        "height",
        "coneAngle",
        "stopFactor",
        "angleRange",
        "radiusRange",
        "cellInfos",
        "noiseStrength",
        "limitVelocityDamping"
      ],
      uniformBuffersNames: [],
      samplers: ["randomSampler", "randomSampler2", "sizeGradientSampler", "angularSpeedGradientSampler", "velocityGradientSampler", "limitVelocityGradientSampler", "noiseSampler", "dragGradientSampler"],
      defines: "",
      fallbacks: null,
      onCompiled: null,
      onError: null,
      indexParameters: null,
      maxSimultaneousLights: 0,
      transformFeedbackVaryings: []
    };
    _this.particleEmitterType = new BoxParticleEmitter();
    var maxTextureSize = Math.min(_this._engine.getCaps().maxTextureSize, fullOptions.randomTextureSize);
    var d = [];
    for (var i = 0; i < maxTextureSize; ++i) {
      d.push(Math.random());
      d.push(Math.random());
      d.push(Math.random());
      d.push(Math.random());
    }
    _this._randomTexture = new RawTexture(new Float32Array(d), maxTextureSize, 1, 5, sceneOrEngine, false, false, 1, 1);
    _this._randomTexture.wrapU = 1;
    _this._randomTexture.wrapV = 1;
    d = [];
    for (var i = 0; i < maxTextureSize; ++i) {
      d.push(Math.random());
      d.push(Math.random());
      d.push(Math.random());
      d.push(Math.random());
    }
    _this._randomTexture2 = new RawTexture(new Float32Array(d), maxTextureSize, 1, 5, sceneOrEngine, false, false, 1, 1);
    _this._randomTexture2.wrapU = 1;
    _this._randomTexture2.wrapV = 1;
    _this._randomTextureSize = maxTextureSize;
    return _this;
  }
  Object.defineProperty(GPUParticleSystem2, "IsSupported", {
    get: function() {
      if (!EngineStore.LastCreatedEngine) {
        return false;
      }
      return EngineStore.LastCreatedEngine.webGLVersion > 1;
    },
    enumerable: false,
    configurable: true
  });
  GPUParticleSystem2.prototype.getCapacity = function() {
    return this._capacity;
  };
  Object.defineProperty(GPUParticleSystem2.prototype, "activeParticleCount", {
    get: function() {
      return this._activeCount;
    },
    set: function(value) {
      this._activeCount = Math.min(value, this._capacity);
    },
    enumerable: false,
    configurable: true
  });
  GPUParticleSystem2.prototype.isReady = function() {
    if (!this._updateEffect) {
      this._recreateUpdateEffect();
      this._recreateRenderEffect();
      return false;
    }
    if (!this.emitter || !this._updateEffect.isReady() || this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady() || !this._getEffect().isReady() || !this.particleTexture || !this.particleTexture.isReady()) {
      return false;
    }
    return true;
  };
  GPUParticleSystem2.prototype.isStarted = function() {
    return this._started;
  };
  GPUParticleSystem2.prototype.isStopped = function() {
    return this._stopped;
  };
  GPUParticleSystem2.prototype.isStopping = function() {
    return false;
  };
  GPUParticleSystem2.prototype.getActiveCount = function() {
    return this._currentActiveCount;
  };
  GPUParticleSystem2.prototype.start = function(delay) {
    var _this = this;
    if (delay === void 0) {
      delay = this.startDelay;
    }
    if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {
      throw "Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set";
    }
    if (delay) {
      setTimeout(function() {
        _this.start(0);
      }, delay);
      return;
    }
    this._started = true;
    this._stopped = false;
    this._preWarmDone = false;
    if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {
      this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);
    }
  };
  GPUParticleSystem2.prototype.stop = function() {
    if (this._stopped) {
      return;
    }
    this._stopped = true;
  };
  GPUParticleSystem2.prototype.reset = function() {
    this._releaseBuffers();
    this._releaseVAOs();
    this._currentActiveCount = 0;
    this._targetIndex = 0;
  };
  GPUParticleSystem2.prototype.getClassName = function() {
    return "GPUParticleSystem";
  };
  GPUParticleSystem2.prototype.getCustomEffect = function(blendMode) {
    var _a;
    if (blendMode === void 0) {
      blendMode = 0;
    }
    return (_a = this._customEffect[blendMode]) !== null && _a !== void 0 ? _a : this._customEffect[0];
  };
  GPUParticleSystem2.prototype.setCustomEffect = function(effect, blendMode) {
    if (blendMode === void 0) {
      blendMode = 0;
    }
    this._customEffect[blendMode] = effect;
  };
  Object.defineProperty(GPUParticleSystem2.prototype, "onBeforeDrawParticlesObservable", {
    get: function() {
      if (!this._onBeforeDrawParticlesObservable) {
        this._onBeforeDrawParticlesObservable = new Observable();
      }
      return this._onBeforeDrawParticlesObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GPUParticleSystem2.prototype, "vertexShaderName", {
    get: function() {
      return "gpuRenderParticles";
    },
    enumerable: false,
    configurable: true
  });
  GPUParticleSystem2.prototype._removeGradientAndTexture = function(gradient, gradients, texture) {
    _super.prototype._removeGradientAndTexture.call(this, gradient, gradients, texture);
    this._releaseBuffers();
    return this;
  };
  GPUParticleSystem2.prototype.addColorGradient = function(gradient, color1, color2) {
    if (!this._colorGradients) {
      this._colorGradients = [];
    }
    var colorGradient = new ColorGradient(gradient, color1);
    this._colorGradients.push(colorGradient);
    this._refreshColorGradient(true);
    this._releaseBuffers();
    return this;
  };
  GPUParticleSystem2.prototype._refreshColorGradient = function(reorder) {
    if (reorder === void 0) {
      reorder = false;
    }
    if (this._colorGradients) {
      if (reorder) {
        this._colorGradients.sort(function(a, b) {
          if (a.gradient < b.gradient) {
            return -1;
          } else if (a.gradient > b.gradient) {
            return 1;
          }
          return 0;
        });
      }
      if (this._colorGradientsTexture) {
        this._colorGradientsTexture.dispose();
        this._colorGradientsTexture = null;
      }
    }
  };
  GPUParticleSystem2.prototype.forceRefreshGradients = function() {
    this._refreshColorGradient();
    this._refreshFactorGradient(this._sizeGradients, "_sizeGradientsTexture");
    this._refreshFactorGradient(this._angularSpeedGradients, "_angularSpeedGradientsTexture");
    this._refreshFactorGradient(this._velocityGradients, "_velocityGradientsTexture");
    this._refreshFactorGradient(this._limitVelocityGradients, "_limitVelocityGradientsTexture");
    this._refreshFactorGradient(this._dragGradients, "_dragGradientsTexture");
    this.reset();
  };
  GPUParticleSystem2.prototype.removeColorGradient = function(gradient) {
    this._removeGradientAndTexture(gradient, this._colorGradients, this._colorGradientsTexture);
    this._colorGradientsTexture = null;
    return this;
  };
  GPUParticleSystem2.prototype._addFactorGradient = function(factorGradients, gradient, factor) {
    var valueGradient = new FactorGradient(gradient, factor);
    factorGradients.push(valueGradient);
    this._releaseBuffers();
  };
  GPUParticleSystem2.prototype.addSizeGradient = function(gradient, factor) {
    if (!this._sizeGradients) {
      this._sizeGradients = [];
    }
    this._addFactorGradient(this._sizeGradients, gradient, factor);
    this._refreshFactorGradient(this._sizeGradients, "_sizeGradientsTexture", true);
    this._releaseBuffers();
    return this;
  };
  GPUParticleSystem2.prototype.removeSizeGradient = function(gradient) {
    this._removeGradientAndTexture(gradient, this._sizeGradients, this._sizeGradientsTexture);
    this._sizeGradientsTexture = null;
    return this;
  };
  GPUParticleSystem2.prototype._refreshFactorGradient = function(factorGradients, textureName, reorder) {
    if (reorder === void 0) {
      reorder = false;
    }
    if (!factorGradients) {
      return;
    }
    if (reorder) {
      factorGradients.sort(function(a, b) {
        if (a.gradient < b.gradient) {
          return -1;
        } else if (a.gradient > b.gradient) {
          return 1;
        }
        return 0;
      });
    }
    var that = this;
    if (that[textureName]) {
      that[textureName].dispose();
      that[textureName] = null;
    }
  };
  GPUParticleSystem2.prototype.addAngularSpeedGradient = function(gradient, factor) {
    if (!this._angularSpeedGradients) {
      this._angularSpeedGradients = [];
    }
    this._addFactorGradient(this._angularSpeedGradients, gradient, factor);
    this._refreshFactorGradient(this._angularSpeedGradients, "_angularSpeedGradientsTexture", true);
    this._releaseBuffers();
    return this;
  };
  GPUParticleSystem2.prototype.removeAngularSpeedGradient = function(gradient) {
    this._removeGradientAndTexture(gradient, this._angularSpeedGradients, this._angularSpeedGradientsTexture);
    this._angularSpeedGradientsTexture = null;
    return this;
  };
  GPUParticleSystem2.prototype.addVelocityGradient = function(gradient, factor) {
    if (!this._velocityGradients) {
      this._velocityGradients = [];
    }
    this._addFactorGradient(this._velocityGradients, gradient, factor);
    this._refreshFactorGradient(this._velocityGradients, "_velocityGradientsTexture", true);
    this._releaseBuffers();
    return this;
  };
  GPUParticleSystem2.prototype.removeVelocityGradient = function(gradient) {
    this._removeGradientAndTexture(gradient, this._velocityGradients, this._velocityGradientsTexture);
    this._velocityGradientsTexture = null;
    return this;
  };
  GPUParticleSystem2.prototype.addLimitVelocityGradient = function(gradient, factor) {
    if (!this._limitVelocityGradients) {
      this._limitVelocityGradients = [];
    }
    this._addFactorGradient(this._limitVelocityGradients, gradient, factor);
    this._refreshFactorGradient(this._limitVelocityGradients, "_limitVelocityGradientsTexture", true);
    this._releaseBuffers();
    return this;
  };
  GPUParticleSystem2.prototype.removeLimitVelocityGradient = function(gradient) {
    this._removeGradientAndTexture(gradient, this._limitVelocityGradients, this._limitVelocityGradientsTexture);
    this._limitVelocityGradientsTexture = null;
    return this;
  };
  GPUParticleSystem2.prototype.addDragGradient = function(gradient, factor) {
    if (!this._dragGradients) {
      this._dragGradients = [];
    }
    this._addFactorGradient(this._dragGradients, gradient, factor);
    this._refreshFactorGradient(this._dragGradients, "_dragGradientsTexture", true);
    this._releaseBuffers();
    return this;
  };
  GPUParticleSystem2.prototype.removeDragGradient = function(gradient) {
    this._removeGradientAndTexture(gradient, this._dragGradients, this._dragGradientsTexture);
    this._dragGradientsTexture = null;
    return this;
  };
  GPUParticleSystem2.prototype.addEmitRateGradient = function(gradient, factor, factor2) {
    return this;
  };
  GPUParticleSystem2.prototype.removeEmitRateGradient = function(gradient) {
    return this;
  };
  GPUParticleSystem2.prototype.addStartSizeGradient = function(gradient, factor, factor2) {
    return this;
  };
  GPUParticleSystem2.prototype.removeStartSizeGradient = function(gradient) {
    return this;
  };
  GPUParticleSystem2.prototype.addColorRemapGradient = function(gradient, min, max) {
    return this;
  };
  GPUParticleSystem2.prototype.removeColorRemapGradient = function() {
    return this;
  };
  GPUParticleSystem2.prototype.addAlphaRemapGradient = function(gradient, min, max) {
    return this;
  };
  GPUParticleSystem2.prototype.removeAlphaRemapGradient = function() {
    return this;
  };
  GPUParticleSystem2.prototype.addRampGradient = function(gradient, color) {
    return this;
  };
  GPUParticleSystem2.prototype.removeRampGradient = function() {
    return this;
  };
  GPUParticleSystem2.prototype.getRampGradients = function() {
    return null;
  };
  Object.defineProperty(GPUParticleSystem2.prototype, "useRampGradients", {
    get: function() {
      return false;
    },
    set: function(value) {
    },
    enumerable: false,
    configurable: true
  });
  GPUParticleSystem2.prototype.addLifeTimeGradient = function(gradient, factor, factor2) {
    return this;
  };
  GPUParticleSystem2.prototype.removeLifeTimeGradient = function(gradient) {
    return this;
  };
  GPUParticleSystem2.prototype._reset = function() {
    this._releaseBuffers();
  };
  GPUParticleSystem2.prototype._createUpdateVAO = function(source) {
    var updateVertexBuffers = {};
    updateVertexBuffers["position"] = source.createVertexBuffer("position", 0, 3);
    var offset = 3;
    if (this.particleEmitterType instanceof CustomParticleEmitter) {
      updateVertexBuffers["initialPosition"] = source.createVertexBuffer("initialPosition", offset, 3);
      offset += 3;
    }
    updateVertexBuffers["age"] = source.createVertexBuffer("age", offset, 1);
    offset += 1;
    updateVertexBuffers["life"] = source.createVertexBuffer("life", offset, 1);
    offset += 1;
    updateVertexBuffers["seed"] = source.createVertexBuffer("seed", offset, 4);
    offset += 4;
    updateVertexBuffers["size"] = source.createVertexBuffer("size", offset, 3);
    offset += 3;
    if (!this._colorGradientsTexture) {
      updateVertexBuffers["color"] = source.createVertexBuffer("color", offset, 4);
      offset += 4;
    }
    updateVertexBuffers["direction"] = source.createVertexBuffer("direction", offset, 3);
    offset += 3;
    if (!this._isBillboardBased) {
      updateVertexBuffers["initialDirection"] = source.createVertexBuffer("initialDirection", offset, 3);
      offset += 3;
    }
    if (this._angularSpeedGradientsTexture) {
      updateVertexBuffers["angle"] = source.createVertexBuffer("angle", offset, 1);
      offset += 1;
    } else {
      updateVertexBuffers["angle"] = source.createVertexBuffer("angle", offset, 2);
      offset += 2;
    }
    if (this._isAnimationSheetEnabled) {
      updateVertexBuffers["cellIndex"] = source.createVertexBuffer("cellIndex", offset, 1);
      offset += 1;
      if (this.spriteRandomStartCell) {
        updateVertexBuffers["cellStartOffset"] = source.createVertexBuffer("cellStartOffset", offset, 1);
        offset += 1;
      }
    }
    if (this.noiseTexture) {
      updateVertexBuffers["noiseCoordinates1"] = source.createVertexBuffer("noiseCoordinates1", offset, 3);
      offset += 3;
      updateVertexBuffers["noiseCoordinates2"] = source.createVertexBuffer("noiseCoordinates2", offset, 3);
      offset += 3;
    }
    var vao = this._engine.recordVertexArrayObject(updateVertexBuffers, null, this._updateEffect);
    this._engine.bindArrayBuffer(null);
    return vao;
  };
  GPUParticleSystem2.prototype._createRenderVAO = function(source, spriteSource) {
    var renderVertexBuffers = {};
    renderVertexBuffers["position"] = source.createVertexBuffer("position", 0, 3, this._attributesStrideSize, true);
    var offset = 3;
    if (this.particleEmitterType instanceof CustomParticleEmitter) {
      offset += 3;
    }
    renderVertexBuffers["age"] = source.createVertexBuffer("age", offset, 1, this._attributesStrideSize, true);
    offset += 1;
    renderVertexBuffers["life"] = source.createVertexBuffer("life", offset, 1, this._attributesStrideSize, true);
    offset += 5;
    renderVertexBuffers["size"] = source.createVertexBuffer("size", offset, 3, this._attributesStrideSize, true);
    offset += 3;
    if (!this._colorGradientsTexture) {
      renderVertexBuffers["color"] = source.createVertexBuffer("color", offset, 4, this._attributesStrideSize, true);
      offset += 4;
    }
    if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {
      renderVertexBuffers["direction"] = source.createVertexBuffer("direction", offset, 3, this._attributesStrideSize, true);
    }
    offset += 3;
    if (!this._isBillboardBased) {
      renderVertexBuffers["initialDirection"] = source.createVertexBuffer("initialDirection", offset, 3, this._attributesStrideSize, true);
      offset += 3;
    }
    renderVertexBuffers["angle"] = source.createVertexBuffer("angle", offset, 1, this._attributesStrideSize, true);
    if (this._angularSpeedGradientsTexture) {
      offset++;
    } else {
      offset += 2;
    }
    if (this._isAnimationSheetEnabled) {
      renderVertexBuffers["cellIndex"] = source.createVertexBuffer("cellIndex", offset, 1, this._attributesStrideSize, true);
      offset += 1;
      if (this.spriteRandomStartCell) {
        renderVertexBuffers["cellStartOffset"] = source.createVertexBuffer("cellStartOffset", offset, 1, this._attributesStrideSize, true);
        offset += 1;
      }
    }
    if (this.noiseTexture) {
      renderVertexBuffers["noiseCoordinates1"] = source.createVertexBuffer("noiseCoordinates1", offset, 3, this._attributesStrideSize, true);
      offset += 3;
      renderVertexBuffers["noiseCoordinates2"] = source.createVertexBuffer("noiseCoordinates2", offset, 3, this._attributesStrideSize, true);
      offset += 3;
    }
    renderVertexBuffers["offset"] = spriteSource.createVertexBuffer("offset", 0, 2);
    renderVertexBuffers["uv"] = spriteSource.createVertexBuffer("uv", 2, 2);
    var vao = this._engine.recordVertexArrayObject(renderVertexBuffers, null, this._getEffect());
    this._engine.bindArrayBuffer(null);
    return vao;
  };
  GPUParticleSystem2.prototype._initialize = function(force) {
    if (force === void 0) {
      force = false;
    }
    if (this._buffer0 && !force) {
      return;
    }
    var engine = this._engine;
    var data = new Array();
    this._attributesStrideSize = 21;
    this._targetIndex = 0;
    if (this.particleEmitterType instanceof CustomParticleEmitter) {
      this._attributesStrideSize += 3;
    }
    if (!this.isBillboardBased) {
      this._attributesStrideSize += 3;
    }
    if (this._colorGradientsTexture) {
      this._attributesStrideSize -= 4;
    }
    if (this._angularSpeedGradientsTexture) {
      this._attributesStrideSize -= 1;
    }
    if (this._isAnimationSheetEnabled) {
      this._attributesStrideSize += 1;
      if (this.spriteRandomStartCell) {
        this._attributesStrideSize += 1;
      }
    }
    if (this.noiseTexture) {
      this._attributesStrideSize += 6;
    }
    var usingCustomEmitter = this.particleEmitterType instanceof CustomParticleEmitter;
    var tmpVector = TmpVectors.Vector3[0];
    for (var particleIndex = 0; particleIndex < this._capacity; particleIndex++) {
      data.push(0);
      data.push(0);
      data.push(0);
      if (usingCustomEmitter) {
        this.particleEmitterType.particlePositionGenerator(particleIndex, null, tmpVector);
        data.push(tmpVector.x);
        data.push(tmpVector.y);
        data.push(tmpVector.z);
      }
      data.push(0);
      data.push(0);
      data.push(Math.random());
      data.push(Math.random());
      data.push(Math.random());
      data.push(Math.random());
      data.push(0);
      data.push(0);
      data.push(0);
      if (!this._colorGradientsTexture) {
        data.push(0);
        data.push(0);
        data.push(0);
        data.push(0);
      }
      if (usingCustomEmitter) {
        this.particleEmitterType.particleDestinationGenerator(particleIndex, null, tmpVector);
        data.push(tmpVector.x);
        data.push(tmpVector.y);
        data.push(tmpVector.z);
      } else {
        data.push(0);
        data.push(0);
        data.push(0);
      }
      if (!this.isBillboardBased) {
        data.push(0);
        data.push(0);
        data.push(0);
      }
      data.push(0);
      if (!this._angularSpeedGradientsTexture) {
        data.push(0);
      }
      if (this._isAnimationSheetEnabled) {
        data.push(0);
        if (this.spriteRandomStartCell) {
          data.push(0);
        }
      }
      if (this.noiseTexture) {
        data.push(Math.random());
        data.push(Math.random());
        data.push(Math.random());
        data.push(Math.random());
        data.push(Math.random());
        data.push(Math.random());
      }
    }
    var spriteData = new Float32Array([
      0.5,
      0.5,
      1,
      1,
      -0.5,
      0.5,
      0,
      1,
      -0.5,
      -0.5,
      0,
      0,
      0.5,
      -0.5,
      1,
      0
    ]);
    this._buffer0 = new Buffer(engine, data, false, this._attributesStrideSize);
    this._buffer1 = new Buffer(engine, data, false, this._attributesStrideSize);
    this._spriteBuffer = new Buffer(engine, spriteData, false, 4);
    this._updateVAO = [];
    this._updateVAO.push(this._createUpdateVAO(this._buffer0));
    this._updateVAO.push(this._createUpdateVAO(this._buffer1));
    this._renderVAO = [];
    this._renderVAO.push(this._createRenderVAO(this._buffer1, this._spriteBuffer));
    this._renderVAO.push(this._createRenderVAO(this._buffer0, this._spriteBuffer));
    this._sourceBuffer = this._buffer0;
    this._targetBuffer = this._buffer1;
  };
  GPUParticleSystem2.prototype._recreateUpdateEffect = function() {
    var defines = this.particleEmitterType ? this.particleEmitterType.getEffectDefines() : "";
    if (this._isBillboardBased) {
      defines += "\n#define BILLBOARD";
    }
    if (this._colorGradientsTexture) {
      defines += "\n#define COLORGRADIENTS";
    }
    if (this._sizeGradientsTexture) {
      defines += "\n#define SIZEGRADIENTS";
    }
    if (this._angularSpeedGradientsTexture) {
      defines += "\n#define ANGULARSPEEDGRADIENTS";
    }
    if (this._velocityGradientsTexture) {
      defines += "\n#define VELOCITYGRADIENTS";
    }
    if (this._limitVelocityGradientsTexture) {
      defines += "\n#define LIMITVELOCITYGRADIENTS";
    }
    if (this._dragGradientsTexture) {
      defines += "\n#define DRAGGRADIENTS";
    }
    if (this.isAnimationSheetEnabled) {
      defines += "\n#define ANIMATESHEET";
      if (this.spriteRandomStartCell) {
        defines += "\n#define ANIMATESHEETRANDOMSTART";
      }
    }
    if (this.noiseTexture) {
      defines += "\n#define NOISE";
    }
    if (this.isLocal) {
      defines += "\n#define LOCAL";
    }
    if (this._updateEffect && this._updateEffectOptions.defines === defines) {
      return;
    }
    this._updateEffectOptions.transformFeedbackVaryings = ["outPosition"];
    if (this.particleEmitterType instanceof CustomParticleEmitter) {
      this._updateEffectOptions.transformFeedbackVaryings.push("outInitialPosition");
    }
    this._updateEffectOptions.transformFeedbackVaryings.push("outAge");
    this._updateEffectOptions.transformFeedbackVaryings.push("outLife");
    this._updateEffectOptions.transformFeedbackVaryings.push("outSeed");
    this._updateEffectOptions.transformFeedbackVaryings.push("outSize");
    if (!this._colorGradientsTexture) {
      this._updateEffectOptions.transformFeedbackVaryings.push("outColor");
    }
    this._updateEffectOptions.transformFeedbackVaryings.push("outDirection");
    if (!this._isBillboardBased) {
      this._updateEffectOptions.transformFeedbackVaryings.push("outInitialDirection");
    }
    this._updateEffectOptions.transformFeedbackVaryings.push("outAngle");
    if (this.isAnimationSheetEnabled) {
      this._updateEffectOptions.transformFeedbackVaryings.push("outCellIndex");
      if (this.spriteRandomStartCell) {
        this._updateEffectOptions.transformFeedbackVaryings.push("outCellStartOffset");
      }
    }
    if (this.noiseTexture) {
      this._updateEffectOptions.transformFeedbackVaryings.push("outNoiseCoordinates1");
      this._updateEffectOptions.transformFeedbackVaryings.push("outNoiseCoordinates2");
    }
    this._updateEffectOptions.defines = defines;
    this._updateEffect = new Effect("gpuUpdateParticles", this._updateEffectOptions, this._engine);
  };
  GPUParticleSystem2.prototype._getEffect = function() {
    var _a;
    return (_a = this.getCustomEffect()) !== null && _a !== void 0 ? _a : this._renderEffect;
  };
  GPUParticleSystem2.prototype.fillDefines = function(defines, blendMode) {
    if (blendMode === void 0) {
      blendMode = 0;
    }
    if (this._scene) {
      if (this._scene.clipPlane) {
        defines.push("#define CLIPPLANE");
      }
      if (this._scene.clipPlane2) {
        defines.push("#define CLIPPLANE2");
      }
      if (this._scene.clipPlane3) {
        defines.push("#define CLIPPLANE3");
      }
      if (this._scene.clipPlane4) {
        defines.push("#define CLIPPLANE4");
      }
      if (this._scene.clipPlane5) {
        defines.push("#define CLIPPLANE5");
      }
      if (this._scene.clipPlane6) {
        defines.push("#define CLIPPLANE6");
      }
    }
    if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {
      defines.push("#define BLENDMULTIPLYMODE");
    }
    if (this.isLocal) {
      defines.push("#define LOCAL");
    }
    if (this._isBillboardBased) {
      defines.push("#define BILLBOARD");
      switch (this.billboardMode) {
        case ParticleSystem.BILLBOARDMODE_Y:
          defines.push("#define BILLBOARDY");
          break;
        case ParticleSystem.BILLBOARDMODE_STRETCHED:
          defines.push("#define BILLBOARDSTRETCHED");
          break;
        case ParticleSystem.BILLBOARDMODE_ALL:
          defines.push("#define BILLBOARDMODE_ALL");
          break;
        default:
          break;
      }
    }
    if (this._colorGradientsTexture) {
      defines.push("#define COLORGRADIENTS");
    }
    if (this.isAnimationSheetEnabled) {
      defines.push("#define ANIMATESHEET");
    }
    if (this._imageProcessingConfiguration) {
      this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);
      defines.push("" + this._imageProcessingConfigurationDefines.toString());
    }
  };
  GPUParticleSystem2.prototype.fillUniformsAttributesAndSamplerNames = function(uniforms, attributes, samplers) {
    attributes.push("position", "age", "life", "size", "color", "offset", "uv", "direction", "initialDirection", "angle", "cellIndex");
    uniforms.push("emitterWM", "worldOffset", "view", "projection", "colorDead", "invView", "vClipPlane", "vClipPlane2", "vClipPlane3", "vClipPlane4", "vClipPlane5", "vClipPlane6", "sheetInfos", "translationPivot", "eyePosition");
    samplers.push("diffuseSampler", "colorGradientSampler");
    if (this._imageProcessingConfiguration) {
      ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);
      ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);
    }
  };
  GPUParticleSystem2.prototype._recreateRenderEffect = function() {
    var customEffect = this.getCustomEffect();
    if (customEffect) {
      return customEffect;
    }
    var defines = [];
    this.fillDefines(defines);
    var join = defines.join("\n");
    if (this._renderEffect && this._renderEffect.defines === join) {
      return this._renderEffect;
    }
    var attributes = [];
    var uniforms = [];
    var samplers = [];
    this.fillUniformsAttributesAndSamplerNames(uniforms, attributes, samplers);
    this._renderEffect = new Effect("gpuRenderParticles", attributes, uniforms, samplers, this._engine, join);
    return this._renderEffect;
  };
  GPUParticleSystem2.prototype.animate = function(preWarm) {
    var _a;
    if (preWarm === void 0) {
      preWarm = false;
    }
    this._timeDelta = this.updateSpeed * (preWarm ? this.preWarmStepOffset : ((_a = this._scene) === null || _a === void 0 ? void 0 : _a.getAnimationRatio()) || 1);
    this._actualFrame += this._timeDelta;
    if (!this._stopped) {
      if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {
        this.stop();
      }
    }
  };
  GPUParticleSystem2.prototype._createFactorGradientTexture = function(factorGradients, textureName) {
    var texture = this[textureName];
    if (!factorGradients || !factorGradients.length || texture) {
      return;
    }
    var data = new Float32Array(this._rawTextureWidth);
    for (var x = 0; x < this._rawTextureWidth; x++) {
      var ratio = x / this._rawTextureWidth;
      GradientHelper.GetCurrentGradient(ratio, factorGradients, function(currentGradient, nextGradient, scale) {
        data[x] = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);
      });
    }
    this[textureName] = RawTexture.CreateRTexture(data, this._rawTextureWidth, 1, this._scene || this._engine, false, false, 1);
  };
  GPUParticleSystem2.prototype._createSizeGradientTexture = function() {
    this._createFactorGradientTexture(this._sizeGradients, "_sizeGradientsTexture");
  };
  GPUParticleSystem2.prototype._createAngularSpeedGradientTexture = function() {
    this._createFactorGradientTexture(this._angularSpeedGradients, "_angularSpeedGradientsTexture");
  };
  GPUParticleSystem2.prototype._createVelocityGradientTexture = function() {
    this._createFactorGradientTexture(this._velocityGradients, "_velocityGradientsTexture");
  };
  GPUParticleSystem2.prototype._createLimitVelocityGradientTexture = function() {
    this._createFactorGradientTexture(this._limitVelocityGradients, "_limitVelocityGradientsTexture");
  };
  GPUParticleSystem2.prototype._createDragGradientTexture = function() {
    this._createFactorGradientTexture(this._dragGradients, "_dragGradientsTexture");
  };
  GPUParticleSystem2.prototype._createColorGradientTexture = function() {
    if (!this._colorGradients || !this._colorGradients.length || this._colorGradientsTexture) {
      return;
    }
    var data = new Uint8Array(this._rawTextureWidth * 4);
    var tmpColor = TmpColors.Color4[0];
    for (var x = 0; x < this._rawTextureWidth; x++) {
      var ratio = x / this._rawTextureWidth;
      GradientHelper.GetCurrentGradient(ratio, this._colorGradients, function(currentGradient, nextGradient, scale) {
        Color4.LerpToRef(currentGradient.color1, nextGradient.color1, scale, tmpColor);
        data[x * 4] = tmpColor.r * 255;
        data[x * 4 + 1] = tmpColor.g * 255;
        data[x * 4 + 2] = tmpColor.b * 255;
        data[x * 4 + 3] = tmpColor.a * 255;
      });
    }
    this._colorGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, 1);
  };
  GPUParticleSystem2.prototype.render = function(preWarm) {
    var _a, _b;
    if (preWarm === void 0) {
      preWarm = false;
    }
    if (!this._started) {
      return 0;
    }
    this._createColorGradientTexture();
    this._createSizeGradientTexture();
    this._createAngularSpeedGradientTexture();
    this._createVelocityGradientTexture();
    this._createLimitVelocityGradientTexture();
    this._createDragGradientTexture();
    this._recreateUpdateEffect();
    this._recreateRenderEffect();
    if (!this.isReady()) {
      return 0;
    }
    if (!preWarm && this._scene) {
      if (!this._preWarmDone && this.preWarmCycles) {
        for (var index = 0; index < this.preWarmCycles; index++) {
          this.animate(true);
          this.render(true);
        }
        this._preWarmDone = true;
      }
      if (this._currentRenderId === this._scene.getFrameId()) {
        return 0;
      }
      this._currentRenderId = this._scene.getFrameId();
    }
    this._initialize();
    this._accumulatedCount += this.emitRate * this._timeDelta;
    if (this._accumulatedCount > 1) {
      var intPart = this._accumulatedCount | 0;
      this._accumulatedCount -= intPart;
      this._currentActiveCount = Math.min(this._activeCount, this._currentActiveCount + intPart);
    }
    if (!this._currentActiveCount) {
      return 0;
    }
    this._engine.enableEffect(this._updateEffect);
    var engine = this._engine;
    if (!engine.setState) {
      throw new Error("GPU particles cannot work with a full Engine. ThinEngine is not supported");
    }
    this._updateEffect.setFloat("currentCount", this._currentActiveCount);
    this._updateEffect.setFloat("timeDelta", this._timeDelta);
    this._updateEffect.setFloat("stopFactor", this._stopped ? 0 : 1);
    this._updateEffect.setTexture("randomSampler", this._randomTexture);
    this._updateEffect.setTexture("randomSampler2", this._randomTexture2);
    this._updateEffect.setFloat2("lifeTime", this.minLifeTime, this.maxLifeTime);
    this._updateEffect.setFloat2("emitPower", this.minEmitPower, this.maxEmitPower);
    if (!this._colorGradientsTexture) {
      this._updateEffect.setDirectColor4("color1", this.color1);
      this._updateEffect.setDirectColor4("color2", this.color2);
    }
    this._updateEffect.setFloat2("sizeRange", this.minSize, this.maxSize);
    this._updateEffect.setFloat4("scaleRange", this.minScaleX, this.maxScaleX, this.minScaleY, this.maxScaleY);
    this._updateEffect.setFloat4("angleRange", this.minAngularSpeed, this.maxAngularSpeed, this.minInitialRotation, this.maxInitialRotation);
    this._updateEffect.setVector3("gravity", this.gravity);
    if (this._sizeGradientsTexture) {
      this._updateEffect.setTexture("sizeGradientSampler", this._sizeGradientsTexture);
    }
    if (this._angularSpeedGradientsTexture) {
      this._updateEffect.setTexture("angularSpeedGradientSampler", this._angularSpeedGradientsTexture);
    }
    if (this._velocityGradientsTexture) {
      this._updateEffect.setTexture("velocityGradientSampler", this._velocityGradientsTexture);
    }
    if (this._limitVelocityGradientsTexture) {
      this._updateEffect.setTexture("limitVelocityGradientSampler", this._limitVelocityGradientsTexture);
      this._updateEffect.setFloat("limitVelocityDamping", this.limitVelocityDamping);
    }
    if (this._dragGradientsTexture) {
      this._updateEffect.setTexture("dragGradientSampler", this._dragGradientsTexture);
    }
    if (this.particleEmitterType) {
      this.particleEmitterType.applyToShader(this._updateEffect);
    }
    if (this._isAnimationSheetEnabled) {
      this._updateEffect.setFloat3("cellInfos", this.startSpriteCellID, this.endSpriteCellID, this.spriteCellChangeSpeed);
    }
    if (this.noiseTexture) {
      this._updateEffect.setTexture("noiseSampler", this.noiseTexture);
      this._updateEffect.setVector3("noiseStrength", this.noiseStrength);
    }
    var emitterWM;
    if (this.emitter.position) {
      var emitterMesh = this.emitter;
      emitterWM = emitterMesh.getWorldMatrix();
    } else {
      var emitterPosition = this.emitter;
      emitterWM = Matrix.Translation(emitterPosition.x, emitterPosition.y, emitterPosition.z);
    }
    if (!this.isLocal) {
      this._updateEffect.setMatrix("emitterWM", emitterWM);
    }
    this._engine.bindVertexArrayObject(this._updateVAO[this._targetIndex], null);
    engine.bindTransformFeedbackBuffer(this._targetBuffer.getBuffer());
    engine.setRasterizerState(false);
    engine.beginTransformFeedback(true);
    engine.drawArraysType(3, 0, this._currentActiveCount);
    engine.endTransformFeedback();
    engine.setRasterizerState(true);
    engine.bindTransformFeedbackBuffer(null);
    if (!preWarm) {
      var effect = this._getEffect();
      this._engine.enableEffect(effect);
      var viewMatrix = ((_a = this._scene) === null || _a === void 0 ? void 0 : _a.getViewMatrix()) || Matrix.IdentityReadOnly;
      effect.setMatrix("view", viewMatrix);
      effect.setMatrix("projection", (_b = this.defaultProjectionMatrix) !== null && _b !== void 0 ? _b : this._scene.getProjectionMatrix());
      effect.setTexture("diffuseSampler", this.particleTexture);
      effect.setVector2("translationPivot", this.translationPivot);
      effect.setVector3("worldOffset", this.worldOffset);
      if (this.isLocal) {
        effect.setMatrix("emitterWM", emitterWM);
      }
      if (this._colorGradientsTexture) {
        effect.setTexture("colorGradientSampler", this._colorGradientsTexture);
      } else {
        effect.setDirectColor4("colorDead", this.colorDead);
      }
      if (this._isAnimationSheetEnabled && this.particleTexture) {
        var baseSize = this.particleTexture.getBaseSize();
        effect.setFloat3("sheetInfos", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, baseSize.width / this.spriteCellWidth);
      }
      if (this._isBillboardBased && this._scene) {
        var camera = this._scene.activeCamera;
        effect.setVector3("eyePosition", camera.globalPosition);
      }
      var defines = effect.defines;
      if (this._scene) {
        if (this._scene.clipPlane || this._scene.clipPlane2 || this._scene.clipPlane3 || this._scene.clipPlane4 || this._scene.clipPlane5 || this._scene.clipPlane6) {
          MaterialHelper.BindClipPlane(effect, this._scene);
        }
      }
      if (defines.indexOf("#define BILLBOARDMODE_ALL") >= 0) {
        var invView = viewMatrix.clone();
        invView.invert();
        effect.setMatrix("invView", invView);
      }
      if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {
        this._imageProcessingConfiguration.bind(effect);
      }
      switch (this.blendMode) {
        case ParticleSystem.BLENDMODE_ADD:
          this._engine.setAlphaMode(1);
          break;
        case ParticleSystem.BLENDMODE_ONEONE:
          this._engine.setAlphaMode(6);
          break;
        case ParticleSystem.BLENDMODE_STANDARD:
          this._engine.setAlphaMode(2);
          break;
        case ParticleSystem.BLENDMODE_MULTIPLY:
          this._engine.setAlphaMode(4);
          break;
      }
      if (this.forceDepthWrite) {
        engine.setDepthWrite(true);
      }
      this._engine.bindVertexArrayObject(this._renderVAO[this._targetIndex], null);
      if (this._onBeforeDrawParticlesObservable) {
        this._onBeforeDrawParticlesObservable.notifyObservers(effect);
      }
      this._engine.drawArraysType(8, 0, 4, this._currentActiveCount);
      this._engine.setAlphaMode(0);
    }
    this._targetIndex++;
    if (this._targetIndex === 2) {
      this._targetIndex = 0;
    }
    var tmpBuffer = this._sourceBuffer;
    this._sourceBuffer = this._targetBuffer;
    this._targetBuffer = tmpBuffer;
    return this._currentActiveCount;
  };
  GPUParticleSystem2.prototype.rebuild = function() {
    this._initialize(true);
  };
  GPUParticleSystem2.prototype._releaseBuffers = function() {
    if (this._buffer0) {
      this._buffer0.dispose();
      this._buffer0 = null;
    }
    if (this._buffer1) {
      this._buffer1.dispose();
      this._buffer1 = null;
    }
    if (this._spriteBuffer) {
      this._spriteBuffer.dispose();
      this._spriteBuffer = null;
    }
  };
  GPUParticleSystem2.prototype._releaseVAOs = function() {
    if (!this._updateVAO) {
      return;
    }
    for (var index = 0; index < this._updateVAO.length; index++) {
      this._engine.releaseVertexArrayObject(this._updateVAO[index]);
    }
    this._updateVAO = [];
    for (var index = 0; index < this._renderVAO.length; index++) {
      this._engine.releaseVertexArrayObject(this._renderVAO[index]);
    }
    this._renderVAO = [];
  };
  GPUParticleSystem2.prototype.dispose = function(disposeTexture) {
    if (disposeTexture === void 0) {
      disposeTexture = true;
    }
    if (this._scene) {
      var index = this._scene.particleSystems.indexOf(this);
      if (index > -1) {
        this._scene.particleSystems.splice(index, 1);
      }
    }
    this._releaseBuffers();
    this._releaseVAOs();
    if (this._colorGradientsTexture) {
      this._colorGradientsTexture.dispose();
      this._colorGradientsTexture = null;
    }
    if (this._sizeGradientsTexture) {
      this._sizeGradientsTexture.dispose();
      this._sizeGradientsTexture = null;
    }
    if (this._angularSpeedGradientsTexture) {
      this._angularSpeedGradientsTexture.dispose();
      this._angularSpeedGradientsTexture = null;
    }
    if (this._velocityGradientsTexture) {
      this._velocityGradientsTexture.dispose();
      this._velocityGradientsTexture = null;
    }
    if (this._limitVelocityGradientsTexture) {
      this._limitVelocityGradientsTexture.dispose();
      this._limitVelocityGradientsTexture = null;
    }
    if (this._dragGradientsTexture) {
      this._dragGradientsTexture.dispose();
      this._dragGradientsTexture = null;
    }
    if (this._randomTexture) {
      this._randomTexture.dispose();
      this._randomTexture = null;
    }
    if (this._randomTexture2) {
      this._randomTexture2.dispose();
      this._randomTexture2 = null;
    }
    if (disposeTexture && this.particleTexture) {
      this.particleTexture.dispose();
      this.particleTexture = null;
    }
    if (disposeTexture && this.noiseTexture) {
      this.noiseTexture.dispose();
      this.noiseTexture = null;
    }
    this.onStoppedObservable.clear();
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
  };
  GPUParticleSystem2.prototype.clone = function(name98, newEmitter) {
    var serialization = this.serialize();
    var result = GPUParticleSystem2.Parse(serialization, this._scene || this._engine, "");
    var custom = __assign({}, this._customEffect);
    result.name = name98;
    result._customEffect = custom;
    if (newEmitter === void 0) {
      newEmitter = this.emitter;
    }
    result.emitter = newEmitter;
    result.noiseTexture = this.noiseTexture;
    return result;
  };
  GPUParticleSystem2.prototype.serialize = function(serializeTexture) {
    if (serializeTexture === void 0) {
      serializeTexture = false;
    }
    var serializationObject = {};
    ParticleSystem._Serialize(serializationObject, this, serializeTexture);
    serializationObject.activeParticleCount = this.activeParticleCount;
    serializationObject.randomTextureSize = this._randomTextureSize;
    return serializationObject;
  };
  GPUParticleSystem2.Parse = function(parsedParticleSystem, sceneOrEngine, rootUrl, doNotStart) {
    if (doNotStart === void 0) {
      doNotStart = false;
    }
    var name98 = parsedParticleSystem.name;
    var particleSystem = new GPUParticleSystem2(name98, { capacity: parsedParticleSystem.capacity, randomTextureSize: parsedParticleSystem.randomTextureSize }, sceneOrEngine);
    if (parsedParticleSystem.activeParticleCount) {
      particleSystem.activeParticleCount = parsedParticleSystem.activeParticleCount;
    }
    ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);
    if (parsedParticleSystem.preventAutoStart) {
      particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;
    }
    if (!doNotStart && !particleSystem.preventAutoStart) {
      particleSystem.start();
    }
    return particleSystem;
  };
  return GPUParticleSystem2;
}(BaseParticleSystem);

// node_modules/@babylonjs/core/Particles/particleSystemSet.js
var ParticleSystemSetEmitterCreationOptions = function() {
  function ParticleSystemSetEmitterCreationOptions2() {
  }
  return ParticleSystemSetEmitterCreationOptions2;
}();
var ParticleSystemSet = function() {
  function ParticleSystemSet2() {
    this.systems = new Array();
  }
  Object.defineProperty(ParticleSystemSet2.prototype, "emitterNode", {
    get: function() {
      return this._emitterNode;
    },
    enumerable: false,
    configurable: true
  });
  ParticleSystemSet2.prototype.setEmitterAsSphere = function(options, renderingGroupId, scene) {
    if (this._emitterNode) {
      this._emitterNode.dispose();
    }
    this._emitterCreationOptions = {
      kind: "Sphere",
      options,
      renderingGroupId
    };
    var emitterMesh = SphereBuilder.CreateSphere("emitterSphere", { diameter: options.diameter, segments: options.segments }, scene);
    emitterMesh.renderingGroupId = renderingGroupId;
    var material = new StandardMaterial("emitterSphereMaterial", scene);
    material.emissiveColor = options.color;
    emitterMesh.material = material;
    for (var _i = 0, _a = this.systems; _i < _a.length; _i++) {
      var system = _a[_i];
      system.emitter = emitterMesh;
    }
    this._emitterNode = emitterMesh;
  };
  ParticleSystemSet2.prototype.start = function(emitter) {
    for (var _i = 0, _a = this.systems; _i < _a.length; _i++) {
      var system = _a[_i];
      if (emitter) {
        system.emitter = emitter;
      }
      system.start();
    }
  };
  ParticleSystemSet2.prototype.dispose = function() {
    for (var _i = 0, _a = this.systems; _i < _a.length; _i++) {
      var system = _a[_i];
      system.dispose();
    }
    this.systems = [];
    if (this._emitterNode) {
      this._emitterNode.dispose();
      this._emitterNode = null;
    }
  };
  ParticleSystemSet2.prototype.serialize = function(serializeTexture) {
    if (serializeTexture === void 0) {
      serializeTexture = false;
    }
    var result = {};
    result.systems = [];
    for (var _i = 0, _a = this.systems; _i < _a.length; _i++) {
      var system = _a[_i];
      result.systems.push(system.serialize(serializeTexture));
    }
    if (this._emitterNode) {
      result.emitter = this._emitterCreationOptions;
    }
    return result;
  };
  ParticleSystemSet2.Parse = function(data, scene, gpu) {
    if (gpu === void 0) {
      gpu = false;
    }
    var result = new ParticleSystemSet2();
    var rootUrl = this.BaseAssetsUrl + "/textures/";
    scene = scene || EngineStore.LastCreatedScene;
    for (var _i = 0, _a = data.systems; _i < _a.length; _i++) {
      var system = _a[_i];
      result.systems.push(gpu ? GPUParticleSystem.Parse(system, scene, rootUrl, true) : ParticleSystem.Parse(system, scene, rootUrl, true));
    }
    if (data.emitter) {
      var options = data.emitter.options;
      switch (data.emitter.kind) {
        case "Sphere":
          result.setEmitterAsSphere({
            diameter: options.diameter,
            segments: options.segments,
            color: Color3.FromArray(options.color)
          }, data.emitter.renderingGroupId, scene);
          break;
      }
    }
    return result;
  };
  ParticleSystemSet2.BaseAssetsUrl = "https://assets.babylonjs.com/particles";
  return ParticleSystemSet2;
}();

// node_modules/@babylonjs/core/Particles/particleHelper.js
var ParticleHelper = function() {
  function ParticleHelper2() {
  }
  ParticleHelper2.CreateDefault = function(emitter, capacity, scene, useGPU) {
    if (capacity === void 0) {
      capacity = 500;
    }
    if (useGPU === void 0) {
      useGPU = false;
    }
    var system;
    if (useGPU) {
      system = new GPUParticleSystem("default system", { capacity }, scene);
    } else {
      system = new ParticleSystem("default system", capacity, scene);
    }
    system.emitter = emitter;
    system.particleTexture = new Texture("https://www.babylonjs.com/assets/Flare.png", system.getScene());
    system.createConeEmitter(0.1, Math.PI / 4);
    system.color1 = new Color4(1, 1, 1, 1);
    system.color2 = new Color4(1, 1, 1, 1);
    system.colorDead = new Color4(1, 1, 1, 0);
    system.minSize = 0.1;
    system.maxSize = 0.1;
    system.minEmitPower = 2;
    system.maxEmitPower = 2;
    system.updateSpeed = 1 / 60;
    system.emitRate = 30;
    return system;
  };
  ParticleHelper2.CreateAsync = function(type, scene, gpu) {
    if (gpu === void 0) {
      gpu = false;
    }
    if (!scene) {
      scene = EngineStore.LastCreatedScene;
    }
    var token = {};
    scene._addPendingData(token);
    return new Promise(function(resolve, reject) {
      if (gpu && !GPUParticleSystem.IsSupported) {
        scene._removePendingData(token);
        return reject("Particle system with GPU is not supported.");
      }
      Tools.LoadFile(ParticleHelper2.BaseAssetsUrl + "/systems/" + type + ".json", function(data) {
        scene._removePendingData(token);
        var newData = JSON.parse(data.toString());
        return resolve(ParticleSystemSet.Parse(newData, scene, gpu));
      }, void 0, void 0, void 0, function() {
        scene._removePendingData(token);
        return reject("An error occured while the creation of your particle system. Check if your type '" + type + "' exists.");
      });
    });
  };
  ParticleHelper2.ExportSet = function(systems) {
    var set = new ParticleSystemSet();
    for (var _i = 0, systems_1 = systems; _i < systems_1.length; _i++) {
      var system = systems_1[_i];
      set.systems.push(system);
    }
    return set;
  };
  ParticleHelper2.ParseFromFileAsync = function(name98, url, scene, gpu, rootUrl) {
    if (gpu === void 0) {
      gpu = false;
    }
    if (rootUrl === void 0) {
      rootUrl = "";
    }
    return new Promise(function(resolve, reject) {
      var request = new WebRequest();
      request.addEventListener("readystatechange", function() {
        if (request.readyState == 4) {
          if (request.status == 200) {
            var serializationObject = JSON.parse(request.responseText);
            var output = void 0;
            if (gpu) {
              output = GPUParticleSystem.Parse(serializationObject, scene, rootUrl);
            } else {
              output = ParticleSystem.Parse(serializationObject, scene, rootUrl);
            }
            if (name98) {
              output.name = name98;
            }
            resolve(output);
          } else {
            reject("Unable to load the particle system");
          }
        }
      });
      request.open("GET", url);
      request.send();
    });
  };
  ParticleHelper2.CreateFromSnippetAsync = function(snippetId, scene, gpu, rootUrl) {
    var _this = this;
    if (gpu === void 0) {
      gpu = false;
    }
    if (rootUrl === void 0) {
      rootUrl = "";
    }
    if (snippetId === "_BLANK") {
      var system = this.CreateDefault(null);
      system.start();
      return Promise.resolve(system);
    }
    return new Promise(function(resolve, reject) {
      var request = new WebRequest();
      request.addEventListener("readystatechange", function() {
        if (request.readyState == 4) {
          if (request.status == 200) {
            var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
            var serializationObject = JSON.parse(snippet.particleSystem);
            var output = void 0;
            if (gpu) {
              output = GPUParticleSystem.Parse(serializationObject, scene, rootUrl);
            } else {
              output = ParticleSystem.Parse(serializationObject, scene, rootUrl);
            }
            output.snippetId = snippetId;
            resolve(output);
          } else {
            reject("Unable to load the snippet " + snippetId);
          }
        }
      });
      request.open("GET", _this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
      request.send();
    });
  };
  ParticleHelper2.BaseAssetsUrl = ParticleSystemSet.BaseAssetsUrl;
  ParticleHelper2.SnippetUrl = "https://snippet.babylonjs.com";
  return ParticleHelper2;
}();

// node_modules/@babylonjs/core/Particles/particleSystemComponent.js
AbstractScene.AddParser(SceneComponentConstants.NAME_PARTICLESYSTEM, function(parsedData, scene, container, rootUrl) {
  var individualParser = AbstractScene.GetIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM);
  if (!individualParser) {
    return;
  }
  if (parsedData.particleSystems !== void 0 && parsedData.particleSystems !== null) {
    for (var index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {
      var parsedParticleSystem = parsedData.particleSystems[index];
      container.particleSystems.push(individualParser(parsedParticleSystem, scene, rootUrl));
    }
  }
});
AbstractScene.AddIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM, function(parsedParticleSystem, scene, rootUrl) {
  if (parsedParticleSystem.activeParticleCount) {
    var ps = GPUParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);
    return ps;
  } else {
    var ps = ParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);
    return ps;
  }
});
Engine.prototype.createEffectForParticles = function(fragmentName, uniformsNames, samplers, defines, fallbacks, onCompiled, onError, particleSystem) {
  var _a;
  if (uniformsNames === void 0) {
    uniformsNames = [];
  }
  if (samplers === void 0) {
    samplers = [];
  }
  if (defines === void 0) {
    defines = "";
  }
  var attributesNamesOrOptions = [];
  var effectCreationOption = [];
  var allSamplers = [];
  if (particleSystem) {
    particleSystem.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, allSamplers);
  } else {
    attributesNamesOrOptions = ParticleSystem._GetAttributeNamesOrOptions();
    effectCreationOption = ParticleSystem._GetEffectCreationOptions();
  }
  if (defines.indexOf(" BILLBOARD") === -1) {
    defines += "\n#define BILLBOARD\n";
  }
  if (samplers.indexOf("diffuseSampler") === -1) {
    samplers.push("diffuseSampler");
  }
  return this.createEffect({
    vertex: (_a = particleSystem === null || particleSystem === void 0 ? void 0 : particleSystem.vertexShaderName) !== null && _a !== void 0 ? _a : "particles",
    fragmentElement: fragmentName
  }, attributesNamesOrOptions, effectCreationOption.concat(uniformsNames), allSamplers.concat(samplers), defines, fallbacks, onCompiled, onError);
};
Mesh.prototype.getEmittedParticleSystems = function() {
  var results = new Array();
  for (var index = 0; index < this.getScene().particleSystems.length; index++) {
    var particleSystem = this.getScene().particleSystems[index];
    if (particleSystem.emitter === this) {
      results.push(particleSystem);
    }
  }
  return results;
};
Mesh.prototype.getHierarchyEmittedParticleSystems = function() {
  var results = new Array();
  var descendants = this.getDescendants();
  descendants.push(this);
  for (var index = 0; index < this.getScene().particleSystems.length; index++) {
    var particleSystem = this.getScene().particleSystems[index];
    var emitter = particleSystem.emitter;
    if (emitter.position && descendants.indexOf(emitter) !== -1) {
      results.push(particleSystem);
    }
  }
  return results;
};

// node_modules/@babylonjs/core/Particles/solidParticle.js
var SolidParticle = function() {
  function SolidParticle2(particleIndex, particleId, positionIndex, indiceIndex, model, shapeId, idxInShape, sps, modelBoundingInfo, materialIndex) {
    if (modelBoundingInfo === void 0) {
      modelBoundingInfo = null;
    }
    if (materialIndex === void 0) {
      materialIndex = null;
    }
    this.idx = 0;
    this.id = 0;
    this.color = new Color4(1, 1, 1, 1);
    this.position = Vector3.Zero();
    this.rotation = Vector3.Zero();
    this.scaling = Vector3.One();
    this.uvs = new Vector4(0, 0, 1, 1);
    this.velocity = Vector3.Zero();
    this.pivot = Vector3.Zero();
    this.translateFromPivot = false;
    this.alive = true;
    this.isVisible = true;
    this._pos = 0;
    this._ind = 0;
    this.shapeId = 0;
    this.idxInShape = 0;
    this._stillInvisible = false;
    this._rotationMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    this.parentId = null;
    this.materialIndex = null;
    this.props = null;
    this.cullingStrategy = AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;
    this._globalPosition = Vector3.Zero();
    this.idx = particleIndex;
    this.id = particleId;
    this._pos = positionIndex;
    this._ind = indiceIndex;
    this._model = model;
    this.shapeId = shapeId;
    this.idxInShape = idxInShape;
    this._sps = sps;
    if (modelBoundingInfo) {
      this._modelBoundingInfo = modelBoundingInfo;
      this._boundingInfo = new BoundingInfo(modelBoundingInfo.minimum, modelBoundingInfo.maximum);
    }
    if (materialIndex !== null) {
      this.materialIndex = materialIndex;
    }
  }
  SolidParticle2.prototype.copyToRef = function(target) {
    target.position.copyFrom(this.position);
    target.rotation.copyFrom(this.rotation);
    if (this.rotationQuaternion) {
      if (target.rotationQuaternion) {
        target.rotationQuaternion.copyFrom(this.rotationQuaternion);
      } else {
        target.rotationQuaternion = this.rotationQuaternion.clone();
      }
    }
    target.scaling.copyFrom(this.scaling);
    if (this.color) {
      if (target.color) {
        target.color.copyFrom(this.color);
      } else {
        target.color = this.color.clone();
      }
    }
    target.uvs.copyFrom(this.uvs);
    target.velocity.copyFrom(this.velocity);
    target.pivot.copyFrom(this.pivot);
    target.translateFromPivot = this.translateFromPivot;
    target.alive = this.alive;
    target.isVisible = this.isVisible;
    target.parentId = this.parentId;
    target.cullingStrategy = this.cullingStrategy;
    if (this.materialIndex !== null) {
      target.materialIndex = this.materialIndex;
    }
    return this;
  };
  Object.defineProperty(SolidParticle2.prototype, "scale", {
    get: function() {
      return this.scaling;
    },
    set: function(scale) {
      this.scaling = scale;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SolidParticle2.prototype, "quaternion", {
    get: function() {
      return this.rotationQuaternion;
    },
    set: function(q) {
      this.rotationQuaternion = q;
    },
    enumerable: false,
    configurable: true
  });
  SolidParticle2.prototype.intersectsMesh = function(target) {
    if (!this._boundingInfo || !target._boundingInfo) {
      return false;
    }
    if (this._sps._bSphereOnly) {
      return BoundingSphere.Intersects(this._boundingInfo.boundingSphere, target._boundingInfo.boundingSphere);
    }
    return this._boundingInfo.intersects(target._boundingInfo, false);
  };
  SolidParticle2.prototype.isInFrustum = function(frustumPlanes) {
    return this._boundingInfo !== null && this._boundingInfo.isInFrustum(frustumPlanes, this.cullingStrategy);
  };
  SolidParticle2.prototype.getRotationMatrix = function(m) {
    var quaternion;
    if (this.rotationQuaternion) {
      quaternion = this.rotationQuaternion;
    } else {
      quaternion = TmpVectors.Quaternion[0];
      var rotation = this.rotation;
      Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);
    }
    quaternion.toRotationMatrix(m);
  };
  return SolidParticle2;
}();
var ModelShape = function() {
  function ModelShape2(id, shape, indices, normals, colors, shapeUV, posFunction, vtxFunction, material) {
    this._indicesLength = 0;
    this.shapeID = id;
    this._shape = shape;
    this._indices = indices;
    this._indicesLength = indices.length;
    this._shapeUV = shapeUV;
    this._shapeColors = colors;
    this._normals = normals;
    this._positionFunction = posFunction;
    this._vertexFunction = vtxFunction;
    this._material = material;
  }
  return ModelShape2;
}();
var DepthSortedParticle = function() {
  function DepthSortedParticle2(idx, ind, indLength, materialIndex) {
    this.idx = 0;
    this.ind = 0;
    this.indicesLength = 0;
    this.sqDistance = 0;
    this.materialIndex = 0;
    this.idx = idx;
    this.ind = ind;
    this.indicesLength = indLength;
    this.materialIndex = materialIndex;
  }
  return DepthSortedParticle2;
}();
var SolidParticleVertex = function() {
  function SolidParticleVertex2() {
    this.position = Vector3.Zero();
    this.color = new Color4(1, 1, 1, 1);
    this.uv = Vector2.Zero();
  }
  Object.defineProperty(SolidParticleVertex2.prototype, "x", {
    get: function() {
      return this.position.x;
    },
    set: function(val) {
      this.position.x = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SolidParticleVertex2.prototype, "y", {
    get: function() {
      return this.position.y;
    },
    set: function(val) {
      this.position.y = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SolidParticleVertex2.prototype, "z", {
    get: function() {
      return this.position.z;
    },
    set: function(val) {
      this.position.z = val;
    },
    enumerable: false,
    configurable: true
  });
  return SolidParticleVertex2;
}();

// node_modules/@babylonjs/core/Particles/solidParticleSystem.js
var SolidParticleSystem = function() {
  function SolidParticleSystem2(name98, scene, options) {
    this.particles = new Array();
    this.nbParticles = 0;
    this.billboard = false;
    this.recomputeNormals = false;
    this.counter = 0;
    this.vars = {};
    this._bSphereOnly = false;
    this._bSphereRadiusFactor = 1;
    this._positions = new Array();
    this._indices = new Array();
    this._normals = new Array();
    this._colors = new Array();
    this._uvs = new Array();
    this._index = 0;
    this._updatable = true;
    this._pickable = false;
    this._isVisibilityBoxLocked = false;
    this._alwaysVisible = false;
    this._depthSort = false;
    this._expandable = false;
    this._shapeCounter = 0;
    this._copy = new SolidParticle(0, 0, 0, 0, null, 0, 0, this);
    this._color = new Color4(0, 0, 0, 0);
    this._computeParticleColor = true;
    this._computeParticleTexture = true;
    this._computeParticleRotation = true;
    this._computeParticleVertex = false;
    this._computeBoundingBox = false;
    this._depthSortParticles = true;
    this._mustUnrotateFixedNormals = false;
    this._particlesIntersect = false;
    this._needs32Bits = false;
    this._isNotBuilt = true;
    this._lastParticleId = 0;
    this._idxOfId = [];
    this._multimaterialEnabled = false;
    this._useModelMaterial = false;
    this._depthSortFunction = function(p1, p2) {
      return p2.sqDistance - p1.sqDistance;
    };
    this._materialSortFunction = function(p1, p2) {
      return p1.materialIndex - p2.materialIndex;
    };
    this._autoUpdateSubMeshes = false;
    this.name = name98;
    this._scene = scene || EngineStore.LastCreatedScene;
    this._camera = scene.activeCamera;
    this._pickable = options ? options.isPickable : false;
    this._depthSort = options ? options.enableDepthSort : false;
    this._multimaterialEnabled = options ? options.enableMultiMaterial : false;
    this._useModelMaterial = options ? options.useModelMaterial : false;
    this._multimaterialEnabled = this._useModelMaterial ? true : this._multimaterialEnabled;
    this._expandable = options ? options.expandable : false;
    this._particlesIntersect = options ? options.particleIntersection : false;
    this._bSphereOnly = options ? options.boundingSphereOnly : false;
    this._bSphereRadiusFactor = options && options.bSphereRadiusFactor ? options.bSphereRadiusFactor : 1;
    if (options && options.updatable !== void 0) {
      this._updatable = options.updatable;
    } else {
      this._updatable = true;
    }
    if (this._pickable) {
      this.pickedBySubMesh = [[]];
      this.pickedParticles = this.pickedBySubMesh[0];
    }
    if (this._depthSort || this._multimaterialEnabled) {
      this.depthSortedParticles = [];
    }
    if (this._multimaterialEnabled) {
      this._multimaterial = new MultiMaterial(this.name + "MultiMaterial", this._scene);
      this._materials = [];
      this._materialIndexesById = {};
    }
    this._tmpVertex = new SolidParticleVertex();
  }
  SolidParticleSystem2.prototype.buildMesh = function() {
    if (!this._isNotBuilt && this.mesh) {
      return this.mesh;
    }
    if (this.nbParticles === 0 && !this.mesh) {
      var triangle = DiscBuilder.CreateDisc("", { radius: 1, tessellation: 3 }, this._scene);
      this.addShape(triangle, 1);
      triangle.dispose();
    }
    this._indices32 = this._needs32Bits ? new Uint32Array(this._indices) : new Uint16Array(this._indices);
    this._positions32 = new Float32Array(this._positions);
    this._uvs32 = new Float32Array(this._uvs);
    this._colors32 = new Float32Array(this._colors);
    if (!this.mesh) {
      var mesh = new Mesh(this.name, this._scene);
      this.mesh = mesh;
    }
    if (!this._updatable && this._multimaterialEnabled) {
      this._sortParticlesByMaterial();
    }
    if (this.recomputeNormals) {
      VertexData.ComputeNormals(this._positions32, this._indices32, this._normals);
    }
    this._normals32 = new Float32Array(this._normals);
    this._fixedNormal32 = new Float32Array(this._normals);
    if (this._mustUnrotateFixedNormals) {
      this._unrotateFixedNormals();
    }
    var vertexData = new VertexData();
    vertexData.indices = this._depthSort ? this._indices : this._indices32;
    vertexData.set(this._positions32, VertexBuffer.PositionKind);
    vertexData.set(this._normals32, VertexBuffer.NormalKind);
    if (this._uvs32.length > 0) {
      vertexData.set(this._uvs32, VertexBuffer.UVKind);
    }
    if (this._colors32.length > 0) {
      vertexData.set(this._colors32, VertexBuffer.ColorKind);
    }
    vertexData.applyToMesh(this.mesh, this._updatable);
    this.mesh.isPickable = this._pickable;
    if (this._pickable) {
      var faceId = 0;
      for (var p = 0; p < this.nbParticles; p++) {
        var part = this.particles[p];
        var lind = part._model._indicesLength;
        for (var i = 0; i < lind; i++) {
          var f = i % 3;
          if (f == 0) {
            var pickedData = { idx: part.idx, faceId };
            this.pickedParticles[faceId] = pickedData;
            faceId++;
          }
        }
      }
    }
    if (this._multimaterialEnabled) {
      this.setMultiMaterial(this._materials);
    }
    if (!this._expandable) {
      if (!this._depthSort && !this._multimaterialEnabled) {
        this._indices = null;
      }
      this._positions = null;
      this._normals = null;
      this._uvs = null;
      this._colors = null;
      if (!this._updatable) {
        this.particles.length = 0;
      }
    }
    this._isNotBuilt = false;
    this.recomputeNormals = false;
    return this.mesh;
  };
  SolidParticleSystem2.prototype.digest = function(mesh, options) {
    var size = options && options.facetNb || 1;
    var number = options && options.number || 0;
    var delta = options && options.delta || 0;
    var meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);
    var meshInd = mesh.getIndices();
    var meshUV = mesh.getVerticesData(VertexBuffer.UVKind);
    var meshCol = mesh.getVerticesData(VertexBuffer.ColorKind);
    var meshNor = mesh.getVerticesData(VertexBuffer.NormalKind);
    var storage = options && options.storage ? options.storage : null;
    var f = 0;
    var totalFacets = meshInd.length / 3;
    if (number) {
      number = number > totalFacets ? totalFacets : number;
      size = Math.round(totalFacets / number);
      delta = 0;
    } else {
      size = size > totalFacets ? totalFacets : size;
    }
    var facetPos = [];
    var facetNor = [];
    var facetInd = [];
    var facetUV = [];
    var facetCol = [];
    var barycenter = Vector3.Zero();
    var sizeO = size;
    while (f < totalFacets) {
      size = sizeO + Math.floor((1 + delta) * Math.random());
      if (f > totalFacets - size) {
        size = totalFacets - f;
      }
      facetPos.length = 0;
      facetNor.length = 0;
      facetInd.length = 0;
      facetUV.length = 0;
      facetCol.length = 0;
      var fi = 0;
      for (var j = f * 3; j < (f + size) * 3; j++) {
        facetInd.push(fi);
        var i = meshInd[j];
        var i3 = i * 3;
        facetPos.push(meshPos[i3], meshPos[i3 + 1], meshPos[i3 + 2]);
        facetNor.push(meshNor[i3], meshNor[i3 + 1], meshNor[i3 + 2]);
        if (meshUV) {
          var i2 = i * 2;
          facetUV.push(meshUV[i2], meshUV[i2 + 1]);
        }
        if (meshCol) {
          var i4 = i * 4;
          facetCol.push(meshCol[i4], meshCol[i4 + 1], meshCol[i4 + 2], meshCol[i4 + 3]);
        }
        fi++;
      }
      var idx = this.nbParticles;
      var shape = this._posToShape(facetPos);
      var shapeUV = this._uvsToShapeUV(facetUV);
      var shapeInd = Tools.Slice(facetInd);
      var shapeCol = Tools.Slice(facetCol);
      var shapeNor = Tools.Slice(facetNor);
      barycenter.copyFromFloats(0, 0, 0);
      var v;
      for (v = 0; v < shape.length; v++) {
        barycenter.addInPlace(shape[v]);
      }
      barycenter.scaleInPlace(1 / shape.length);
      var minimum = new Vector3(Infinity, Infinity, Infinity);
      var maximum = new Vector3(-Infinity, -Infinity, -Infinity);
      for (v = 0; v < shape.length; v++) {
        shape[v].subtractInPlace(barycenter);
        minimum.minimizeInPlaceFromFloats(shape[v].x, shape[v].y, shape[v].z);
        maximum.maximizeInPlaceFromFloats(shape[v].x, shape[v].y, shape[v].z);
      }
      var bInfo;
      if (this._particlesIntersect) {
        bInfo = new BoundingInfo(minimum, maximum);
      }
      var material = null;
      if (this._useModelMaterial) {
        material = mesh.material ? mesh.material : this._setDefaultMaterial();
      }
      var modelShape = new ModelShape(this._shapeCounter, shape, shapeInd, shapeNor, shapeCol, shapeUV, null, null, material);
      var currentPos = this._positions.length;
      var currentInd = this._indices.length;
      this._meshBuilder(this._index, currentInd, shape, this._positions, shapeInd, this._indices, facetUV, this._uvs, shapeCol, this._colors, shapeNor, this._normals, idx, 0, null, modelShape);
      this._addParticle(idx, this._lastParticleId, currentPos, currentInd, modelShape, this._shapeCounter, 0, bInfo, storage);
      this.particles[this.nbParticles].position.addInPlace(barycenter);
      if (!storage) {
        this._index += shape.length;
        idx++;
        this.nbParticles++;
        this._lastParticleId++;
      }
      this._shapeCounter++;
      f += size;
    }
    this._isNotBuilt = true;
    return this;
  };
  SolidParticleSystem2.prototype._unrotateFixedNormals = function() {
    var index = 0;
    var idx = 0;
    var tmpNormal = TmpVectors.Vector3[0];
    var quaternion = TmpVectors.Quaternion[0];
    var invertedRotMatrix = TmpVectors.Matrix[0];
    for (var p = 0; p < this.particles.length; p++) {
      var particle = this.particles[p];
      var shape = particle._model._shape;
      if (particle.rotationQuaternion) {
        particle.rotationQuaternion.conjugateToRef(quaternion);
      } else {
        var rotation = particle.rotation;
        Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);
        quaternion.conjugateInPlace();
      }
      quaternion.toRotationMatrix(invertedRotMatrix);
      for (var pt = 0; pt < shape.length; pt++) {
        idx = index + pt * 3;
        Vector3.TransformNormalFromFloatsToRef(this._normals32[idx], this._normals32[idx + 1], this._normals32[idx + 2], invertedRotMatrix, tmpNormal);
        tmpNormal.toArray(this._fixedNormal32, idx);
      }
      index = idx + 3;
    }
  };
  SolidParticleSystem2.prototype._resetCopy = function() {
    var copy = this._copy;
    copy.position.setAll(0);
    copy.rotation.setAll(0);
    copy.rotationQuaternion = null;
    copy.scaling.setAll(1);
    copy.uvs.copyFromFloats(0, 0, 1, 1);
    copy.color = null;
    copy.translateFromPivot = false;
    copy.shapeId = 0;
    copy.materialIndex = null;
  };
  SolidParticleSystem2.prototype._meshBuilder = function(p, ind, shape, positions, meshInd, indices, meshUV, uvs, meshCol, colors, meshNor, normals, idx, idxInShape, options, model) {
    var i;
    var u = 0;
    var c = 0;
    var n = 0;
    this._resetCopy();
    var copy = this._copy;
    var storeApart = options && options.storage ? true : false;
    copy.idx = idx;
    copy.idxInShape = idxInShape;
    copy.shapeId = model.shapeID;
    if (this._useModelMaterial) {
      var materialId = model._material.uniqueId;
      var materialIndexesById = this._materialIndexesById;
      if (!materialIndexesById.hasOwnProperty(materialId)) {
        materialIndexesById[materialId] = this._materials.length;
        this._materials.push(model._material);
      }
      var matIdx = materialIndexesById[materialId];
      copy.materialIndex = matIdx;
    }
    if (options && options.positionFunction) {
      options.positionFunction(copy, idx, idxInShape);
      this._mustUnrotateFixedNormals = true;
    }
    if (storeApart) {
      return copy;
    }
    var rotMatrix = TmpVectors.Matrix[0];
    var tmpVertex = this._tmpVertex;
    var tmpVector = tmpVertex.position;
    var tmpColor = tmpVertex.color;
    var tmpUV = tmpVertex.uv;
    var tmpRotated = TmpVectors.Vector3[1];
    var pivotBackTranslation = TmpVectors.Vector3[2];
    var scaledPivot = TmpVectors.Vector3[3];
    Matrix.IdentityToRef(rotMatrix);
    copy.getRotationMatrix(rotMatrix);
    copy.pivot.multiplyToRef(copy.scaling, scaledPivot);
    if (copy.translateFromPivot) {
      pivotBackTranslation.setAll(0);
    } else {
      pivotBackTranslation.copyFrom(scaledPivot);
    }
    var someVertexFunction = options && options.vertexFunction;
    for (i = 0; i < shape.length; i++) {
      tmpVector.copyFrom(shape[i]);
      if (copy.color) {
        tmpColor.copyFrom(copy.color);
      }
      if (meshUV) {
        tmpUV.copyFromFloats(meshUV[u], meshUV[u + 1]);
      }
      if (someVertexFunction) {
        options.vertexFunction(copy, tmpVertex, i);
      }
      tmpVector.multiplyInPlace(copy.scaling).subtractInPlace(scaledPivot);
      Vector3.TransformCoordinatesToRef(tmpVector, rotMatrix, tmpRotated);
      tmpRotated.addInPlace(pivotBackTranslation).addInPlace(copy.position);
      positions.push(tmpRotated.x, tmpRotated.y, tmpRotated.z);
      if (meshUV) {
        var copyUvs = copy.uvs;
        uvs.push((copyUvs.z - copyUvs.x) * tmpUV.x + copyUvs.x, (copyUvs.w - copyUvs.y) * tmpUV.y + copyUvs.y);
        u += 2;
      }
      if (copy.color) {
        this._color.copyFrom(tmpColor);
      } else {
        var color = this._color;
        if (meshCol && meshCol[c] !== void 0) {
          color.r = meshCol[c];
          color.g = meshCol[c + 1];
          color.b = meshCol[c + 2];
          color.a = meshCol[c + 3];
        } else {
          color.r = 1;
          color.g = 1;
          color.b = 1;
          color.a = 1;
        }
      }
      colors.push(this._color.r, this._color.g, this._color.b, this._color.a);
      c += 4;
      if (!this.recomputeNormals && meshNor) {
        Vector3.TransformNormalFromFloatsToRef(meshNor[n], meshNor[n + 1], meshNor[n + 2], rotMatrix, tmpVector);
        normals.push(tmpVector.x, tmpVector.y, tmpVector.z);
        n += 3;
      }
    }
    for (i = 0; i < meshInd.length; i++) {
      var current_ind = p + meshInd[i];
      indices.push(current_ind);
      if (current_ind > 65535) {
        this._needs32Bits = true;
      }
    }
    if (this._depthSort || this._multimaterialEnabled) {
      var matIndex = copy.materialIndex !== null ? copy.materialIndex : 0;
      this.depthSortedParticles.push(new DepthSortedParticle(idx, ind, meshInd.length, matIndex));
    }
    return copy;
  };
  SolidParticleSystem2.prototype._posToShape = function(positions) {
    var shape = [];
    for (var i = 0; i < positions.length; i += 3) {
      shape.push(Vector3.FromArray(positions, i));
    }
    return shape;
  };
  SolidParticleSystem2.prototype._uvsToShapeUV = function(uvs) {
    var shapeUV = [];
    if (uvs) {
      for (var i = 0; i < uvs.length; i++) {
        shapeUV.push(uvs[i]);
      }
    }
    return shapeUV;
  };
  SolidParticleSystem2.prototype._addParticle = function(idx, id, idxpos, idxind, model, shapeId, idxInShape, bInfo, storage) {
    if (bInfo === void 0) {
      bInfo = null;
    }
    if (storage === void 0) {
      storage = null;
    }
    var sp = new SolidParticle(idx, id, idxpos, idxind, model, shapeId, idxInShape, this, bInfo);
    var target = storage ? storage : this.particles;
    target.push(sp);
    return sp;
  };
  SolidParticleSystem2.prototype.addShape = function(mesh, nb, options) {
    var meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);
    var meshInd = mesh.getIndices();
    var meshUV = mesh.getVerticesData(VertexBuffer.UVKind);
    var meshCol = mesh.getVerticesData(VertexBuffer.ColorKind);
    var meshNor = mesh.getVerticesData(VertexBuffer.NormalKind);
    this.recomputeNormals = meshNor ? false : true;
    var indices = Tools.SliceToArray(meshInd);
    var shapeNormals = Tools.SliceToArray(meshNor);
    var shapeColors = meshCol ? Tools.SliceToArray(meshCol) : [];
    var storage = options && options.storage ? options.storage : null;
    var bbInfo = null;
    if (this._particlesIntersect) {
      bbInfo = mesh.getBoundingInfo();
    }
    var shape = this._posToShape(meshPos);
    var shapeUV = this._uvsToShapeUV(meshUV);
    var posfunc = options ? options.positionFunction : null;
    var vtxfunc = options ? options.vertexFunction : null;
    var material = null;
    if (this._useModelMaterial) {
      material = mesh.material ? mesh.material : this._setDefaultMaterial();
    }
    var modelShape = new ModelShape(this._shapeCounter, shape, indices, shapeNormals, shapeColors, shapeUV, posfunc, vtxfunc, material);
    for (var i = 0; i < nb; i++) {
      this._insertNewParticle(this.nbParticles, i, modelShape, shape, meshInd, meshUV, meshCol, meshNor, bbInfo, storage, options);
    }
    this._shapeCounter++;
    this._isNotBuilt = true;
    return this._shapeCounter - 1;
  };
  SolidParticleSystem2.prototype._rebuildParticle = function(particle, reset) {
    if (reset === void 0) {
      reset = false;
    }
    this._resetCopy();
    var copy = this._copy;
    if (particle._model._positionFunction) {
      particle._model._positionFunction(copy, particle.idx, particle.idxInShape);
    }
    var rotMatrix = TmpVectors.Matrix[0];
    var tmpVertex = TmpVectors.Vector3[0];
    var tmpRotated = TmpVectors.Vector3[1];
    var pivotBackTranslation = TmpVectors.Vector3[2];
    var scaledPivot = TmpVectors.Vector3[3];
    copy.getRotationMatrix(rotMatrix);
    particle.pivot.multiplyToRef(particle.scaling, scaledPivot);
    if (copy.translateFromPivot) {
      pivotBackTranslation.copyFromFloats(0, 0, 0);
    } else {
      pivotBackTranslation.copyFrom(scaledPivot);
    }
    var shape = particle._model._shape;
    for (var pt = 0; pt < shape.length; pt++) {
      tmpVertex.copyFrom(shape[pt]);
      if (particle._model._vertexFunction) {
        particle._model._vertexFunction(copy, tmpVertex, pt);
      }
      tmpVertex.multiplyInPlace(copy.scaling).subtractInPlace(scaledPivot);
      Vector3.TransformCoordinatesToRef(tmpVertex, rotMatrix, tmpRotated);
      tmpRotated.addInPlace(pivotBackTranslation).addInPlace(copy.position).toArray(this._positions32, particle._pos + pt * 3);
    }
    if (reset) {
      particle.position.setAll(0);
      particle.rotation.setAll(0);
      particle.rotationQuaternion = null;
      particle.scaling.setAll(1);
      particle.uvs.setAll(0);
      particle.pivot.setAll(0);
      particle.translateFromPivot = false;
      particle.parentId = null;
    }
  };
  SolidParticleSystem2.prototype.rebuildMesh = function(reset) {
    if (reset === void 0) {
      reset = false;
    }
    for (var p = 0; p < this.particles.length; p++) {
      this._rebuildParticle(this.particles[p], reset);
    }
    this.mesh.updateVerticesData(VertexBuffer.PositionKind, this._positions32, false, false);
    return this;
  };
  SolidParticleSystem2.prototype.removeParticles = function(start, end) {
    var nb = end - start + 1;
    if (!this._expandable || nb <= 0 || nb >= this.nbParticles || !this._updatable) {
      return [];
    }
    var particles = this.particles;
    var currentNb = this.nbParticles;
    if (end < currentNb - 1) {
      var firstRemaining = end + 1;
      var shiftPos = particles[firstRemaining]._pos - particles[start]._pos;
      var shifInd = particles[firstRemaining]._ind - particles[start]._ind;
      for (var i = firstRemaining; i < currentNb; i++) {
        var part = particles[i];
        part._pos -= shiftPos;
        part._ind -= shifInd;
      }
    }
    var removed = particles.splice(start, nb);
    this._positions.length = 0;
    this._indices.length = 0;
    this._colors.length = 0;
    this._uvs.length = 0;
    this._normals.length = 0;
    this._index = 0;
    this._idxOfId.length = 0;
    if (this._depthSort || this._multimaterialEnabled) {
      this.depthSortedParticles = [];
    }
    var ind = 0;
    var particlesLength = particles.length;
    for (var p = 0; p < particlesLength; p++) {
      var particle = particles[p];
      var model = particle._model;
      var shape = model._shape;
      var modelIndices = model._indices;
      var modelNormals = model._normals;
      var modelColors = model._shapeColors;
      var modelUVs = model._shapeUV;
      particle.idx = p;
      this._idxOfId[particle.id] = p;
      this._meshBuilder(this._index, ind, shape, this._positions, modelIndices, this._indices, modelUVs, this._uvs, modelColors, this._colors, modelNormals, this._normals, particle.idx, particle.idxInShape, null, model);
      this._index += shape.length;
      ind += modelIndices.length;
    }
    this.nbParticles -= nb;
    this._isNotBuilt = true;
    return removed;
  };
  SolidParticleSystem2.prototype.insertParticlesFromArray = function(solidParticleArray) {
    if (!this._expandable) {
      return this;
    }
    var idxInShape = 0;
    var currentShapeId = solidParticleArray[0].shapeId;
    var nb = solidParticleArray.length;
    for (var i = 0; i < nb; i++) {
      var sp = solidParticleArray[i];
      var model = sp._model;
      var shape = model._shape;
      var meshInd = model._indices;
      var meshUV = model._shapeUV;
      var meshCol = model._shapeColors;
      var meshNor = model._normals;
      var noNor = meshNor ? false : true;
      this.recomputeNormals = noNor || this.recomputeNormals;
      var bbInfo = sp._boundingInfo;
      var newPart = this._insertNewParticle(this.nbParticles, idxInShape, model, shape, meshInd, meshUV, meshCol, meshNor, bbInfo, null, null);
      sp.copyToRef(newPart);
      idxInShape++;
      if (currentShapeId != sp.shapeId) {
        currentShapeId = sp.shapeId;
        idxInShape = 0;
      }
    }
    this._isNotBuilt = true;
    return this;
  };
  SolidParticleSystem2.prototype._insertNewParticle = function(idx, i, modelShape, shape, meshInd, meshUV, meshCol, meshNor, bbInfo, storage, options) {
    var currentPos = this._positions.length;
    var currentInd = this._indices.length;
    var currentCopy = this._meshBuilder(this._index, currentInd, shape, this._positions, meshInd, this._indices, meshUV, this._uvs, meshCol, this._colors, meshNor, this._normals, idx, i, options, modelShape);
    var sp = null;
    if (this._updatable) {
      sp = this._addParticle(this.nbParticles, this._lastParticleId, currentPos, currentInd, modelShape, this._shapeCounter, i, bbInfo, storage);
      sp.position.copyFrom(currentCopy.position);
      sp.rotation.copyFrom(currentCopy.rotation);
      if (currentCopy.rotationQuaternion) {
        if (sp.rotationQuaternion) {
          sp.rotationQuaternion.copyFrom(currentCopy.rotationQuaternion);
        } else {
          sp.rotationQuaternion = currentCopy.rotationQuaternion.clone();
        }
      }
      if (currentCopy.color) {
        if (sp.color) {
          sp.color.copyFrom(currentCopy.color);
        } else {
          sp.color = currentCopy.color.clone();
        }
      }
      sp.scaling.copyFrom(currentCopy.scaling);
      sp.uvs.copyFrom(currentCopy.uvs);
      if (currentCopy.materialIndex !== null) {
        sp.materialIndex = currentCopy.materialIndex;
      }
      if (this.expandable) {
        this._idxOfId[sp.id] = sp.idx;
      }
    }
    if (!storage) {
      this._index += shape.length;
      this.nbParticles++;
      this._lastParticleId++;
    }
    return sp;
  };
  SolidParticleSystem2.prototype.setParticles = function(start, end, update) {
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = this.nbParticles - 1;
    }
    if (update === void 0) {
      update = true;
    }
    if (!this._updatable || this._isNotBuilt) {
      return this;
    }
    this.beforeUpdateParticles(start, end, update);
    var rotMatrix = TmpVectors.Matrix[0];
    var invertedMatrix = TmpVectors.Matrix[1];
    var mesh = this.mesh;
    var colors32 = this._colors32;
    var positions32 = this._positions32;
    var normals32 = this._normals32;
    var uvs32 = this._uvs32;
    var indices32 = this._indices32;
    var indices = this._indices;
    var fixedNormal32 = this._fixedNormal32;
    var tempVectors = TmpVectors.Vector3;
    var camAxisX = tempVectors[5].copyFromFloats(1, 0, 0);
    var camAxisY = tempVectors[6].copyFromFloats(0, 1, 0);
    var camAxisZ = tempVectors[7].copyFromFloats(0, 0, 1);
    var minimum = tempVectors[8].setAll(Number.MAX_VALUE);
    var maximum = tempVectors[9].setAll(-Number.MAX_VALUE);
    var camInvertedPosition = tempVectors[10].setAll(0);
    var tmpVertex = this._tmpVertex;
    var tmpVector = tmpVertex.position;
    var tmpColor = tmpVertex.color;
    var tmpUV = tmpVertex.uv;
    if (this.billboard || this._depthSort) {
      this.mesh.computeWorldMatrix(true);
      this.mesh._worldMatrix.invertToRef(invertedMatrix);
    }
    if (this.billboard) {
      var tmpVector0 = tempVectors[0];
      this._camera.getDirectionToRef(Axis.Z, tmpVector0);
      Vector3.TransformNormalToRef(tmpVector0, invertedMatrix, camAxisZ);
      camAxisZ.normalize();
      var view = this._camera.getViewMatrix(true);
      Vector3.TransformNormalFromFloatsToRef(view.m[1], view.m[5], view.m[9], invertedMatrix, camAxisY);
      Vector3.CrossToRef(camAxisY, camAxisZ, camAxisX);
      camAxisY.normalize();
      camAxisX.normalize();
    }
    if (this._depthSort) {
      Vector3.TransformCoordinatesToRef(this._camera.globalPosition, invertedMatrix, camInvertedPosition);
    }
    Matrix.IdentityToRef(rotMatrix);
    var idx = 0;
    var index = 0;
    var colidx = 0;
    var colorIndex = 0;
    var uvidx = 0;
    var uvIndex = 0;
    var pt = 0;
    if (this.mesh.isFacetDataEnabled) {
      this._computeBoundingBox = true;
    }
    end = end >= this.nbParticles ? this.nbParticles - 1 : end;
    if (this._computeBoundingBox) {
      if (start != 0 || end != this.nbParticles - 1) {
        var boundingInfo = this.mesh._boundingInfo;
        if (boundingInfo) {
          minimum.copyFrom(boundingInfo.minimum);
          maximum.copyFrom(boundingInfo.maximum);
        }
      }
    }
    index = this.particles[start]._pos;
    var vpos = index / 3 | 0;
    colorIndex = vpos * 4;
    uvIndex = vpos * 2;
    for (var p = start; p <= end; p++) {
      var particle = this.particles[p];
      this.updateParticle(particle);
      var shape = particle._model._shape;
      var shapeUV = particle._model._shapeUV;
      var particleRotationMatrix = particle._rotationMatrix;
      var particlePosition = particle.position;
      var particleRotation = particle.rotation;
      var particleScaling = particle.scaling;
      var particleGlobalPosition = particle._globalPosition;
      if (this._depthSort && this._depthSortParticles) {
        var dsp = this.depthSortedParticles[p];
        dsp.idx = particle.idx;
        dsp.ind = particle._ind;
        dsp.indicesLength = particle._model._indicesLength;
        dsp.sqDistance = Vector3.DistanceSquared(particle.position, camInvertedPosition);
      }
      if (!particle.alive || particle._stillInvisible && !particle.isVisible) {
        pt = shape.length;
        index += pt * 3;
        colorIndex += pt * 4;
        uvIndex += pt * 2;
        continue;
      }
      if (particle.isVisible) {
        particle._stillInvisible = false;
        var scaledPivot = tempVectors[12];
        particle.pivot.multiplyToRef(particleScaling, scaledPivot);
        if (this.billboard) {
          particleRotation.x = 0;
          particleRotation.y = 0;
        }
        if (this._computeParticleRotation || this.billboard) {
          particle.getRotationMatrix(rotMatrix);
        }
        var particleHasParent = particle.parentId !== null;
        if (particleHasParent) {
          var parent_1 = this.getParticleById(particle.parentId);
          if (parent_1) {
            var parentRotationMatrix = parent_1._rotationMatrix;
            var parentGlobalPosition = parent_1._globalPosition;
            var rotatedY = particlePosition.x * parentRotationMatrix[1] + particlePosition.y * parentRotationMatrix[4] + particlePosition.z * parentRotationMatrix[7];
            var rotatedX = particlePosition.x * parentRotationMatrix[0] + particlePosition.y * parentRotationMatrix[3] + particlePosition.z * parentRotationMatrix[6];
            var rotatedZ = particlePosition.x * parentRotationMatrix[2] + particlePosition.y * parentRotationMatrix[5] + particlePosition.z * parentRotationMatrix[8];
            particleGlobalPosition.x = parentGlobalPosition.x + rotatedX;
            particleGlobalPosition.y = parentGlobalPosition.y + rotatedY;
            particleGlobalPosition.z = parentGlobalPosition.z + rotatedZ;
            if (this._computeParticleRotation || this.billboard) {
              var rotMatrixValues = rotMatrix.m;
              particleRotationMatrix[0] = rotMatrixValues[0] * parentRotationMatrix[0] + rotMatrixValues[1] * parentRotationMatrix[3] + rotMatrixValues[2] * parentRotationMatrix[6];
              particleRotationMatrix[1] = rotMatrixValues[0] * parentRotationMatrix[1] + rotMatrixValues[1] * parentRotationMatrix[4] + rotMatrixValues[2] * parentRotationMatrix[7];
              particleRotationMatrix[2] = rotMatrixValues[0] * parentRotationMatrix[2] + rotMatrixValues[1] * parentRotationMatrix[5] + rotMatrixValues[2] * parentRotationMatrix[8];
              particleRotationMatrix[3] = rotMatrixValues[4] * parentRotationMatrix[0] + rotMatrixValues[5] * parentRotationMatrix[3] + rotMatrixValues[6] * parentRotationMatrix[6];
              particleRotationMatrix[4] = rotMatrixValues[4] * parentRotationMatrix[1] + rotMatrixValues[5] * parentRotationMatrix[4] + rotMatrixValues[6] * parentRotationMatrix[7];
              particleRotationMatrix[5] = rotMatrixValues[4] * parentRotationMatrix[2] + rotMatrixValues[5] * parentRotationMatrix[5] + rotMatrixValues[6] * parentRotationMatrix[8];
              particleRotationMatrix[6] = rotMatrixValues[8] * parentRotationMatrix[0] + rotMatrixValues[9] * parentRotationMatrix[3] + rotMatrixValues[10] * parentRotationMatrix[6];
              particleRotationMatrix[7] = rotMatrixValues[8] * parentRotationMatrix[1] + rotMatrixValues[9] * parentRotationMatrix[4] + rotMatrixValues[10] * parentRotationMatrix[7];
              particleRotationMatrix[8] = rotMatrixValues[8] * parentRotationMatrix[2] + rotMatrixValues[9] * parentRotationMatrix[5] + rotMatrixValues[10] * parentRotationMatrix[8];
            }
          } else {
            particle.parentId = null;
          }
        } else {
          particleGlobalPosition.x = particlePosition.x;
          particleGlobalPosition.y = particlePosition.y;
          particleGlobalPosition.z = particlePosition.z;
          if (this._computeParticleRotation || this.billboard) {
            var rotMatrixValues = rotMatrix.m;
            particleRotationMatrix[0] = rotMatrixValues[0];
            particleRotationMatrix[1] = rotMatrixValues[1];
            particleRotationMatrix[2] = rotMatrixValues[2];
            particleRotationMatrix[3] = rotMatrixValues[4];
            particleRotationMatrix[4] = rotMatrixValues[5];
            particleRotationMatrix[5] = rotMatrixValues[6];
            particleRotationMatrix[6] = rotMatrixValues[8];
            particleRotationMatrix[7] = rotMatrixValues[9];
            particleRotationMatrix[8] = rotMatrixValues[10];
          }
        }
        var pivotBackTranslation = tempVectors[11];
        if (particle.translateFromPivot) {
          pivotBackTranslation.setAll(0);
        } else {
          pivotBackTranslation.copyFrom(scaledPivot);
        }
        for (pt = 0; pt < shape.length; pt++) {
          idx = index + pt * 3;
          colidx = colorIndex + pt * 4;
          uvidx = uvIndex + pt * 2;
          var iu = 2 * pt;
          var iv = iu + 1;
          tmpVector.copyFrom(shape[pt]);
          if (this._computeParticleColor && particle.color) {
            tmpColor.copyFrom(particle.color);
          }
          if (this._computeParticleTexture) {
            tmpUV.copyFromFloats(shapeUV[iu], shapeUV[iv]);
          }
          if (this._computeParticleVertex) {
            this.updateParticleVertex(particle, tmpVertex, pt);
          }
          var vertexX = tmpVector.x * particleScaling.x - scaledPivot.x;
          var vertexY = tmpVector.y * particleScaling.y - scaledPivot.y;
          var vertexZ = tmpVector.z * particleScaling.z - scaledPivot.z;
          var rotatedX = vertexX * particleRotationMatrix[0] + vertexY * particleRotationMatrix[3] + vertexZ * particleRotationMatrix[6];
          var rotatedY = vertexX * particleRotationMatrix[1] + vertexY * particleRotationMatrix[4] + vertexZ * particleRotationMatrix[7];
          var rotatedZ = vertexX * particleRotationMatrix[2] + vertexY * particleRotationMatrix[5] + vertexZ * particleRotationMatrix[8];
          rotatedX += pivotBackTranslation.x;
          rotatedY += pivotBackTranslation.y;
          rotatedZ += pivotBackTranslation.z;
          var px = positions32[idx] = particleGlobalPosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ;
          var py = positions32[idx + 1] = particleGlobalPosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ;
          var pz = positions32[idx + 2] = particleGlobalPosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ;
          if (this._computeBoundingBox) {
            minimum.minimizeInPlaceFromFloats(px, py, pz);
            maximum.maximizeInPlaceFromFloats(px, py, pz);
          }
          if (!this._computeParticleVertex) {
            var normalx = fixedNormal32[idx];
            var normaly = fixedNormal32[idx + 1];
            var normalz = fixedNormal32[idx + 2];
            var rotatedx = normalx * particleRotationMatrix[0] + normaly * particleRotationMatrix[3] + normalz * particleRotationMatrix[6];
            var rotatedy = normalx * particleRotationMatrix[1] + normaly * particleRotationMatrix[4] + normalz * particleRotationMatrix[7];
            var rotatedz = normalx * particleRotationMatrix[2] + normaly * particleRotationMatrix[5] + normalz * particleRotationMatrix[8];
            normals32[idx] = camAxisX.x * rotatedx + camAxisY.x * rotatedy + camAxisZ.x * rotatedz;
            normals32[idx + 1] = camAxisX.y * rotatedx + camAxisY.y * rotatedy + camAxisZ.y * rotatedz;
            normals32[idx + 2] = camAxisX.z * rotatedx + camAxisY.z * rotatedy + camAxisZ.z * rotatedz;
          }
          if (this._computeParticleColor && particle.color) {
            var colors32_1 = this._colors32;
            colors32_1[colidx] = tmpColor.r;
            colors32_1[colidx + 1] = tmpColor.g;
            colors32_1[colidx + 2] = tmpColor.b;
            colors32_1[colidx + 3] = tmpColor.a;
          }
          if (this._computeParticleTexture) {
            var uvs = particle.uvs;
            uvs32[uvidx] = tmpUV.x * (uvs.z - uvs.x) + uvs.x;
            uvs32[uvidx + 1] = tmpUV.y * (uvs.w - uvs.y) + uvs.y;
          }
        }
      } else {
        particle._stillInvisible = true;
        for (pt = 0; pt < shape.length; pt++) {
          idx = index + pt * 3;
          colidx = colorIndex + pt * 4;
          uvidx = uvIndex + pt * 2;
          positions32[idx] = positions32[idx + 1] = positions32[idx + 2] = 0;
          normals32[idx] = normals32[idx + 1] = normals32[idx + 2] = 0;
          if (this._computeParticleColor && particle.color) {
            var color = particle.color;
            colors32[colidx] = color.r;
            colors32[colidx + 1] = color.g;
            colors32[colidx + 2] = color.b;
            colors32[colidx + 3] = color.a;
          }
          if (this._computeParticleTexture) {
            var uvs = particle.uvs;
            uvs32[uvidx] = shapeUV[pt * 2] * (uvs.z - uvs.x) + uvs.x;
            uvs32[uvidx + 1] = shapeUV[pt * 2 + 1] * (uvs.w - uvs.y) + uvs.y;
          }
        }
      }
      if (this._particlesIntersect) {
        var bInfo = particle._boundingInfo;
        var bBox = bInfo.boundingBox;
        var bSphere = bInfo.boundingSphere;
        var modelBoundingInfo = particle._modelBoundingInfo;
        if (!this._bSphereOnly) {
          var modelBoundingInfoVectors = modelBoundingInfo.boundingBox.vectors;
          var tempMin = tempVectors[1];
          var tempMax = tempVectors[2];
          tempMin.setAll(Number.MAX_VALUE);
          tempMax.setAll(-Number.MAX_VALUE);
          for (var b = 0; b < 8; b++) {
            var scaledX = modelBoundingInfoVectors[b].x * particleScaling.x;
            var scaledY = modelBoundingInfoVectors[b].y * particleScaling.y;
            var scaledZ = modelBoundingInfoVectors[b].z * particleScaling.z;
            var rotatedX = scaledX * particleRotationMatrix[0] + scaledY * particleRotationMatrix[3] + scaledZ * particleRotationMatrix[6];
            var rotatedY = scaledX * particleRotationMatrix[1] + scaledY * particleRotationMatrix[4] + scaledZ * particleRotationMatrix[7];
            var rotatedZ = scaledX * particleRotationMatrix[2] + scaledY * particleRotationMatrix[5] + scaledZ * particleRotationMatrix[8];
            var x = particlePosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ;
            var y = particlePosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ;
            var z = particlePosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ;
            tempMin.minimizeInPlaceFromFloats(x, y, z);
            tempMax.maximizeInPlaceFromFloats(x, y, z);
          }
          bBox.reConstruct(tempMin, tempMax, mesh._worldMatrix);
        }
        var minBbox = modelBoundingInfo.minimum.multiplyToRef(particleScaling, tempVectors[1]);
        var maxBbox = modelBoundingInfo.maximum.multiplyToRef(particleScaling, tempVectors[2]);
        var bSphereCenter = maxBbox.addToRef(minBbox, tempVectors[3]).scaleInPlace(0.5).addInPlace(particleGlobalPosition);
        var halfDiag = maxBbox.subtractToRef(minBbox, tempVectors[4]).scaleInPlace(0.5 * this._bSphereRadiusFactor);
        var bSphereMinBbox = bSphereCenter.subtractToRef(halfDiag, tempVectors[1]);
        var bSphereMaxBbox = bSphereCenter.addToRef(halfDiag, tempVectors[2]);
        bSphere.reConstruct(bSphereMinBbox, bSphereMaxBbox, mesh._worldMatrix);
      }
      index = idx + 3;
      colorIndex = colidx + 4;
      uvIndex = uvidx + 2;
    }
    if (update) {
      if (this._computeParticleColor) {
        mesh.updateVerticesData(VertexBuffer.ColorKind, colors32, false, false);
      }
      if (this._computeParticleTexture) {
        mesh.updateVerticesData(VertexBuffer.UVKind, uvs32, false, false);
      }
      mesh.updateVerticesData(VertexBuffer.PositionKind, positions32, false, false);
      if (!mesh.areNormalsFrozen || mesh.isFacetDataEnabled) {
        if (this._computeParticleVertex || mesh.isFacetDataEnabled) {
          var params = mesh.isFacetDataEnabled ? mesh.getFacetDataParameters() : null;
          VertexData.ComputeNormals(positions32, indices32, normals32, params);
          for (var i = 0; i < normals32.length; i++) {
            fixedNormal32[i] = normals32[i];
          }
        }
        if (!mesh.areNormalsFrozen) {
          mesh.updateVerticesData(VertexBuffer.NormalKind, normals32, false, false);
        }
      }
      if (this._depthSort && this._depthSortParticles) {
        var depthSortedParticles = this.depthSortedParticles;
        depthSortedParticles.sort(this._depthSortFunction);
        var dspl = depthSortedParticles.length;
        var sid = 0;
        var faceId = 0;
        for (var sorted = 0; sorted < dspl; sorted++) {
          var sortedParticle = depthSortedParticles[sorted];
          var lind = sortedParticle.indicesLength;
          var sind = sortedParticle.ind;
          for (var i = 0; i < lind; i++) {
            indices32[sid] = indices[sind + i];
            sid++;
            if (this._pickable) {
              var f = i % 3;
              if (f == 0) {
                var pickedData = this.pickedParticles[faceId];
                pickedData.idx = sortedParticle.idx;
                pickedData.faceId = faceId;
                faceId++;
              }
            }
          }
        }
        mesh.updateIndices(indices32);
      }
    }
    if (this._computeBoundingBox) {
      if (mesh._boundingInfo) {
        mesh._boundingInfo.reConstruct(minimum, maximum, mesh._worldMatrix);
      } else {
        mesh._boundingInfo = new BoundingInfo(minimum, maximum, mesh._worldMatrix);
      }
    }
    if (this._autoUpdateSubMeshes) {
      this.computeSubMeshes();
    }
    this.afterUpdateParticles(start, end, update);
    return this;
  };
  SolidParticleSystem2.prototype.dispose = function() {
    this.mesh.dispose();
    this.vars = null;
    this._positions = null;
    this._indices = null;
    this._normals = null;
    this._uvs = null;
    this._colors = null;
    this._indices32 = null;
    this._positions32 = null;
    this._normals32 = null;
    this._fixedNormal32 = null;
    this._uvs32 = null;
    this._colors32 = null;
    this.pickedParticles = null;
    this.pickedBySubMesh = null;
    this._materials = null;
    this._materialIndexes = null;
    this._indicesByMaterial = null;
    this._idxOfId = null;
  };
  SolidParticleSystem2.prototype.pickedParticle = function(pickingInfo) {
    if (pickingInfo.hit) {
      var subMesh = pickingInfo.subMeshId;
      var faceId = pickingInfo.faceId;
      var picked = this.pickedBySubMesh;
      if (picked[subMesh] && picked[subMesh][faceId]) {
        return picked[subMesh][faceId];
      }
    }
    return null;
  };
  SolidParticleSystem2.prototype.getParticleById = function(id) {
    var p = this.particles[id];
    if (p && p.id == id) {
      return p;
    }
    var particles = this.particles;
    var idx = this._idxOfId[id];
    if (idx !== void 0) {
      return particles[idx];
    }
    var i = 0;
    var nb = this.nbParticles;
    while (i < nb) {
      var particle = particles[i];
      if (particle.id == id) {
        return particle;
      }
      i++;
    }
    return null;
  };
  SolidParticleSystem2.prototype.getParticlesByShapeId = function(shapeId) {
    var ref = [];
    this.getParticlesByShapeIdToRef(shapeId, ref);
    return ref;
  };
  SolidParticleSystem2.prototype.getParticlesByShapeIdToRef = function(shapeId, ref) {
    ref.length = 0;
    for (var i = 0; i < this.nbParticles; i++) {
      var p = this.particles[i];
      if (p.shapeId == shapeId) {
        ref.push(p);
      }
    }
    return this;
  };
  SolidParticleSystem2.prototype.computeSubMeshes = function() {
    if (!this.mesh || !this._multimaterialEnabled) {
      return this;
    }
    var depthSortedParticles = this.depthSortedParticles;
    if (this.particles.length > 0) {
      for (var p = 0; p < this.particles.length; p++) {
        var part = this.particles[p];
        if (!part.materialIndex) {
          part.materialIndex = 0;
        }
        var sortedPart = depthSortedParticles[p];
        sortedPart.materialIndex = part.materialIndex;
        sortedPart.ind = part._ind;
        sortedPart.indicesLength = part._model._indicesLength;
        sortedPart.idx = part.idx;
      }
    }
    this._sortParticlesByMaterial();
    var indicesByMaterial = this._indicesByMaterial;
    var materialIndexes = this._materialIndexes;
    var mesh = this.mesh;
    mesh.subMeshes = [];
    var vcount = mesh.getTotalVertices();
    for (var m = 0; m < materialIndexes.length; m++) {
      var start = indicesByMaterial[m];
      var count = indicesByMaterial[m + 1] - start;
      var matIndex = materialIndexes[m];
      new SubMesh(matIndex, 0, vcount, start, count, mesh);
    }
    return this;
  };
  SolidParticleSystem2.prototype._sortParticlesByMaterial = function() {
    var indicesByMaterial = [0];
    this._indicesByMaterial = indicesByMaterial;
    var materialIndexes = [];
    this._materialIndexes = materialIndexes;
    var depthSortedParticles = this.depthSortedParticles;
    depthSortedParticles.sort(this._materialSortFunction);
    var length = depthSortedParticles.length;
    var indices32 = this._indices32;
    var indices = this._indices;
    var subMeshIndex = 0;
    var subMeshFaceId = 0;
    var sid = 0;
    var lastMatIndex = depthSortedParticles[0].materialIndex;
    materialIndexes.push(lastMatIndex);
    if (this._pickable) {
      this.pickedBySubMesh = [[]];
      this.pickedParticles = this.pickedBySubMesh[0];
    }
    for (var sorted = 0; sorted < length; sorted++) {
      var sortedPart = depthSortedParticles[sorted];
      var lind = sortedPart.indicesLength;
      var sind = sortedPart.ind;
      if (sortedPart.materialIndex !== lastMatIndex) {
        lastMatIndex = sortedPart.materialIndex;
        indicesByMaterial.push(sid);
        materialIndexes.push(lastMatIndex);
        if (this._pickable) {
          subMeshIndex++;
          this.pickedBySubMesh[subMeshIndex] = [];
          subMeshFaceId = 0;
        }
      }
      var faceId = 0;
      for (var i = 0; i < lind; i++) {
        indices32[sid] = indices[sind + i];
        if (this._pickable) {
          var f = i % 3;
          if (f == 0) {
            var pickedData = this.pickedBySubMesh[subMeshIndex][subMeshFaceId];
            if (pickedData) {
              pickedData.idx = sortedPart.idx;
              pickedData.faceId = faceId;
            } else {
              this.pickedBySubMesh[subMeshIndex][subMeshFaceId] = { idx: sortedPart.idx, faceId };
            }
            subMeshFaceId++;
            faceId++;
          }
        }
        sid++;
      }
    }
    indicesByMaterial.push(indices32.length);
    if (this._updatable) {
      this.mesh.updateIndices(indices32);
    }
    return this;
  };
  SolidParticleSystem2.prototype._setMaterialIndexesById = function() {
    this._materialIndexesById = {};
    for (var i = 0; i < this._materials.length; i++) {
      var id = this._materials[i].uniqueId;
      this._materialIndexesById[id] = i;
    }
  };
  SolidParticleSystem2.prototype._filterUniqueMaterialId = function(array) {
    var filtered = array.filter(function(value, index, self2) {
      return self2.indexOf(value) === index;
    });
    return filtered;
  };
  SolidParticleSystem2.prototype._setDefaultMaterial = function() {
    if (!this._defaultMaterial) {
      this._defaultMaterial = new StandardMaterial(this.name + "DefaultMaterial", this._scene);
    }
    return this._defaultMaterial;
  };
  SolidParticleSystem2.prototype.refreshVisibleSize = function() {
    if (!this._isVisibilityBoxLocked) {
      this.mesh.refreshBoundingInfo();
    }
    return this;
  };
  SolidParticleSystem2.prototype.setVisibilityBox = function(size) {
    var vis = size / 2;
    this.mesh._boundingInfo = new BoundingInfo(new Vector3(-vis, -vis, -vis), new Vector3(vis, vis, vis));
  };
  Object.defineProperty(SolidParticleSystem2.prototype, "isAlwaysVisible", {
    get: function() {
      return this._alwaysVisible;
    },
    set: function(val) {
      this._alwaysVisible = val;
      this.mesh.alwaysSelectAsActiveMesh = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SolidParticleSystem2.prototype, "isVisibilityBoxLocked", {
    get: function() {
      return this._isVisibilityBoxLocked;
    },
    set: function(val) {
      this._isVisibilityBoxLocked = val;
      var boundingInfo = this.mesh.getBoundingInfo();
      boundingInfo.isLocked = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SolidParticleSystem2.prototype, "computeParticleRotation", {
    get: function() {
      return this._computeParticleRotation;
    },
    set: function(val) {
      this._computeParticleRotation = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SolidParticleSystem2.prototype, "computeParticleColor", {
    get: function() {
      return this._computeParticleColor;
    },
    set: function(val) {
      this._computeParticleColor = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SolidParticleSystem2.prototype, "computeParticleTexture", {
    get: function() {
      return this._computeParticleTexture;
    },
    set: function(val) {
      this._computeParticleTexture = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SolidParticleSystem2.prototype, "computeParticleVertex", {
    get: function() {
      return this._computeParticleVertex;
    },
    set: function(val) {
      this._computeParticleVertex = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SolidParticleSystem2.prototype, "computeBoundingBox", {
    get: function() {
      return this._computeBoundingBox;
    },
    set: function(val) {
      this._computeBoundingBox = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SolidParticleSystem2.prototype, "depthSortParticles", {
    get: function() {
      return this._depthSortParticles;
    },
    set: function(val) {
      this._depthSortParticles = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SolidParticleSystem2.prototype, "expandable", {
    get: function() {
      return this._expandable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SolidParticleSystem2.prototype, "multimaterialEnabled", {
    get: function() {
      return this._multimaterialEnabled;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SolidParticleSystem2.prototype, "useModelMaterial", {
    get: function() {
      return this._useModelMaterial;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SolidParticleSystem2.prototype, "materials", {
    get: function() {
      return this._materials;
    },
    enumerable: false,
    configurable: true
  });
  SolidParticleSystem2.prototype.setMultiMaterial = function(materials) {
    this._materials = this._filterUniqueMaterialId(materials);
    this._setMaterialIndexesById();
    if (this._multimaterial) {
      this._multimaterial.dispose();
    }
    this._multimaterial = new MultiMaterial(this.name + "MultiMaterial", this._scene);
    for (var m = 0; m < this._materials.length; m++) {
      this._multimaterial.subMaterials.push(this._materials[m]);
    }
    this.computeSubMeshes();
    this.mesh.material = this._multimaterial;
  };
  Object.defineProperty(SolidParticleSystem2.prototype, "multimaterial", {
    get: function() {
      return this._multimaterial;
    },
    set: function(mm) {
      this._multimaterial = mm;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SolidParticleSystem2.prototype, "autoUpdateSubMeshes", {
    get: function() {
      return this._autoUpdateSubMeshes;
    },
    set: function(val) {
      this._autoUpdateSubMeshes = val;
    },
    enumerable: false,
    configurable: true
  });
  SolidParticleSystem2.prototype.initParticles = function() {
  };
  SolidParticleSystem2.prototype.recycleParticle = function(particle) {
    return particle;
  };
  SolidParticleSystem2.prototype.updateParticle = function(particle) {
    return particle;
  };
  SolidParticleSystem2.prototype.updateParticleVertex = function(particle, vertex, pt) {
    return this;
  };
  SolidParticleSystem2.prototype.beforeUpdateParticles = function(start, stop, update) {
  };
  SolidParticleSystem2.prototype.afterUpdateParticles = function(start, stop, update) {
  };
  return SolidParticleSystem2;
}();

// node_modules/@babylonjs/core/Particles/cloudPoint.js
var CloudPoint = function() {
  function CloudPoint2(particleIndex, group, groupId, idxInGroup, pcs) {
    this.idx = 0;
    this.color = new Color4(1, 1, 1, 1);
    this.position = Vector3.Zero();
    this.rotation = Vector3.Zero();
    this.uv = new Vector2(0, 0);
    this.velocity = Vector3.Zero();
    this.pivot = Vector3.Zero();
    this.translateFromPivot = false;
    this._pos = 0;
    this._ind = 0;
    this.groupId = 0;
    this.idxInGroup = 0;
    this._stillInvisible = false;
    this._rotationMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    this.parentId = null;
    this._globalPosition = Vector3.Zero();
    this.idx = particleIndex;
    this._group = group;
    this.groupId = groupId;
    this.idxInGroup = idxInGroup;
    this._pcs = pcs;
  }
  Object.defineProperty(CloudPoint2.prototype, "size", {
    get: function() {
      return this.size;
    },
    set: function(scale) {
      this.size = scale;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CloudPoint2.prototype, "quaternion", {
    get: function() {
      return this.rotationQuaternion;
    },
    set: function(q) {
      this.rotationQuaternion = q;
    },
    enumerable: false,
    configurable: true
  });
  CloudPoint2.prototype.intersectsMesh = function(target, isSphere) {
    if (!target._boundingInfo) {
      return false;
    }
    isSphere = isSphere ? isSphere : false;
    if (isSphere) {
      return target.getBoundingInfo().boundingSphere.intersectsPoint(this.position.add(this._pcs.mesh.position));
    } else {
      var maxX = 0;
      var minX = 0;
      var maxY = 0;
      var minY = 0;
      var maxZ = 0;
      var minZ = 0;
      maxX = target.getBoundingInfo().boundingBox.maximumWorld.x;
      minX = target.getBoundingInfo().boundingBox.minimumWorld.x;
      maxY = target.getBoundingInfo().boundingBox.maximumWorld.y;
      minY = target.getBoundingInfo().boundingBox.minimumWorld.y;
      maxZ = target.getBoundingInfo().boundingBox.maximumWorld.z;
      minZ = target.getBoundingInfo().boundingBox.minimumWorld.z;
      var x = this.position.x + this._pcs.mesh.position.x;
      var y = this.position.y + this._pcs.mesh.position.y;
      var z = this.position.z + this._pcs.mesh.position.z;
      return minX <= x && x <= maxX && minY <= y && y <= maxY && minZ <= z && z <= maxZ;
    }
  };
  CloudPoint2.prototype.getRotationMatrix = function(m) {
    var quaternion;
    if (this.rotationQuaternion) {
      quaternion = this.rotationQuaternion;
    } else {
      quaternion = TmpVectors.Quaternion[0];
      var rotation = this.rotation;
      Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);
    }
    quaternion.toRotationMatrix(m);
  };
  return CloudPoint2;
}();
var PointsGroup = function() {
  function PointsGroup2(id, posFunction) {
    this.groupID = id;
    this._positionFunction = posFunction;
  }
  return PointsGroup2;
}();

// node_modules/@babylonjs/core/Particles/pointsCloudSystem.js
var PointColor;
(function(PointColor2) {
  PointColor2[PointColor2["Color"] = 2] = "Color";
  PointColor2[PointColor2["UV"] = 1] = "UV";
  PointColor2[PointColor2["Random"] = 0] = "Random";
  PointColor2[PointColor2["Stated"] = 3] = "Stated";
})(PointColor || (PointColor = {}));
var PointsCloudSystem = function() {
  function PointsCloudSystem2(name98, pointSize, scene, options) {
    this.particles = new Array();
    this.nbParticles = 0;
    this.counter = 0;
    this.vars = {};
    this._promises = [];
    this._positions = new Array();
    this._indices = new Array();
    this._normals = new Array();
    this._colors = new Array();
    this._uvs = new Array();
    this._updatable = true;
    this._isVisibilityBoxLocked = false;
    this._alwaysVisible = false;
    this._groups = new Array();
    this._groupCounter = 0;
    this._computeParticleColor = true;
    this._computeParticleTexture = true;
    this._computeParticleRotation = true;
    this._computeBoundingBox = false;
    this._isReady = false;
    this.name = name98;
    this._size = pointSize;
    this._scene = scene || EngineStore.LastCreatedScene;
    if (options && options.updatable !== void 0) {
      this._updatable = options.updatable;
    } else {
      this._updatable = true;
    }
  }
  PointsCloudSystem2.prototype.buildMeshAsync = function() {
    var _this = this;
    return Promise.all(this._promises).then(function() {
      _this._isReady = true;
      return _this._buildMesh();
    });
  };
  PointsCloudSystem2.prototype._buildMesh = function() {
    if (this.nbParticles === 0) {
      this.addPoints(1);
    }
    this._positions32 = new Float32Array(this._positions);
    this._uvs32 = new Float32Array(this._uvs);
    this._colors32 = new Float32Array(this._colors);
    var vertexData = new VertexData();
    vertexData.set(this._positions32, VertexBuffer.PositionKind);
    if (this._uvs32.length > 0) {
      vertexData.set(this._uvs32, VertexBuffer.UVKind);
    }
    var ec = 0;
    if (this._colors32.length > 0) {
      ec = 1;
      vertexData.set(this._colors32, VertexBuffer.ColorKind);
    }
    var mesh = new Mesh(this.name, this._scene);
    vertexData.applyToMesh(mesh, this._updatable);
    this.mesh = mesh;
    this._positions = null;
    this._uvs = null;
    this._colors = null;
    if (!this._updatable) {
      this.particles.length = 0;
    }
    var mat = new StandardMaterial("point cloud material", this._scene);
    mat.emissiveColor = new Color3(ec, ec, ec);
    mat.disableLighting = true;
    mat.pointsCloud = true;
    mat.pointSize = this._size;
    mesh.material = mat;
    return new Promise(function(resolve) {
      return resolve(mesh);
    });
  };
  PointsCloudSystem2.prototype._addParticle = function(idx, group, groupId, idxInGroup) {
    var cp = new CloudPoint(idx, group, groupId, idxInGroup, this);
    this.particles.push(cp);
    return cp;
  };
  PointsCloudSystem2.prototype._randomUnitVector = function(particle) {
    particle.position = new Vector3(Math.random(), Math.random(), Math.random());
    particle.color = new Color4(1, 1, 1, 1);
  };
  PointsCloudSystem2.prototype._getColorIndicesForCoord = function(pointsGroup, x, y, width) {
    var imageData = pointsGroup._groupImageData;
    var color = y * (width * 4) + x * 4;
    var colorIndices = [color, color + 1, color + 2, color + 3];
    var redIndex = colorIndices[0];
    var greenIndex = colorIndices[1];
    var blueIndex = colorIndices[2];
    var alphaIndex = colorIndices[3];
    var redForCoord = imageData[redIndex];
    var greenForCoord = imageData[greenIndex];
    var blueForCoord = imageData[blueIndex];
    var alphaForCoord = imageData[alphaIndex];
    return new Color4(redForCoord / 255, greenForCoord / 255, blueForCoord / 255, alphaForCoord);
  };
  PointsCloudSystem2.prototype._setPointsColorOrUV = function(mesh, pointsGroup, isVolume, colorFromTexture, hasTexture, color, range) {
    if (isVolume) {
      mesh.updateFacetData();
    }
    var boundInfo = mesh.getBoundingInfo();
    var diameter = 2 * boundInfo.boundingSphere.radius;
    var meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);
    var meshInd = mesh.getIndices();
    var meshUV = mesh.getVerticesData(VertexBuffer.UVKind);
    var meshCol = mesh.getVerticesData(VertexBuffer.ColorKind);
    var place = Vector3.Zero();
    mesh.computeWorldMatrix();
    var meshMatrix = mesh.getWorldMatrix();
    if (!meshMatrix.isIdentity()) {
      for (var p = 0; p < meshPos.length / 3; p++) {
        Vector3.TransformCoordinatesFromFloatsToRef(meshPos[3 * p], meshPos[3 * p + 1], meshPos[3 * p + 2], meshMatrix, place);
        meshPos[3 * p] = place.x;
        meshPos[3 * p + 1] = place.y;
        meshPos[3 * p + 2] = place.z;
      }
    }
    var idxPoints = 0;
    var index = 0;
    var id0 = 0;
    var id1 = 0;
    var id2 = 0;
    var v0X = 0;
    var v0Y = 0;
    var v0Z = 0;
    var v1X = 0;
    var v1Y = 0;
    var v1Z = 0;
    var v2X = 0;
    var v2Y = 0;
    var v2Z = 0;
    var vertex0 = Vector3.Zero();
    var vertex1 = Vector3.Zero();
    var vertex2 = Vector3.Zero();
    var vec0 = Vector3.Zero();
    var vec1 = Vector3.Zero();
    var uv0X = 0;
    var uv0Y = 0;
    var uv1X = 0;
    var uv1Y = 0;
    var uv2X = 0;
    var uv2Y = 0;
    var uv0 = Vector2.Zero();
    var uv1 = Vector2.Zero();
    var uv2 = Vector2.Zero();
    var uvec0 = Vector2.Zero();
    var uvec1 = Vector2.Zero();
    var col0X = 0;
    var col0Y = 0;
    var col0Z = 0;
    var col0A = 0;
    var col1X = 0;
    var col1Y = 0;
    var col1Z = 0;
    var col1A = 0;
    var col2X = 0;
    var col2Y = 0;
    var col2Z = 0;
    var col2A = 0;
    var col0 = Vector4.Zero();
    var col1 = Vector4.Zero();
    var col2 = Vector4.Zero();
    var colvec0 = Vector4.Zero();
    var colvec1 = Vector4.Zero();
    var lamda = 0;
    var mu = 0;
    range = range ? range : 0;
    var facetPoint;
    var uvPoint;
    var colPoint = new Vector4(0, 0, 0, 0);
    var norm = Vector3.Zero();
    var tang = Vector3.Zero();
    var biNorm = Vector3.Zero();
    var angle = 0;
    var facetPlaneVec = Vector3.Zero();
    var gap = 0;
    var distance = 0;
    var ray = new Ray(Vector3.Zero(), new Vector3(1, 0, 0));
    var pickInfo;
    var direction = Vector3.Zero();
    for (var index = 0; index < meshInd.length / 3; index++) {
      id0 = meshInd[3 * index];
      id1 = meshInd[3 * index + 1];
      id2 = meshInd[3 * index + 2];
      v0X = meshPos[3 * id0];
      v0Y = meshPos[3 * id0 + 1];
      v0Z = meshPos[3 * id0 + 2];
      v1X = meshPos[3 * id1];
      v1Y = meshPos[3 * id1 + 1];
      v1Z = meshPos[3 * id1 + 2];
      v2X = meshPos[3 * id2];
      v2Y = meshPos[3 * id2 + 1];
      v2Z = meshPos[3 * id2 + 2];
      vertex0.set(v0X, v0Y, v0Z);
      vertex1.set(v1X, v1Y, v1Z);
      vertex2.set(v2X, v2Y, v2Z);
      vertex1.subtractToRef(vertex0, vec0);
      vertex2.subtractToRef(vertex1, vec1);
      if (meshUV) {
        uv0X = meshUV[2 * id0];
        uv0Y = meshUV[2 * id0 + 1];
        uv1X = meshUV[2 * id1];
        uv1Y = meshUV[2 * id1 + 1];
        uv2X = meshUV[2 * id2];
        uv2Y = meshUV[2 * id2 + 1];
        uv0.set(uv0X, uv0Y);
        uv1.set(uv1X, uv1Y);
        uv2.set(uv2X, uv2Y);
        uv1.subtractToRef(uv0, uvec0);
        uv2.subtractToRef(uv1, uvec1);
      }
      if (meshCol && colorFromTexture) {
        col0X = meshCol[4 * id0];
        col0Y = meshCol[4 * id0 + 1];
        col0Z = meshCol[4 * id0 + 2];
        col0A = meshCol[4 * id0 + 3];
        col1X = meshCol[4 * id1];
        col1Y = meshCol[4 * id1 + 1];
        col1Z = meshCol[4 * id1 + 2];
        col1A = meshCol[4 * id1 + 3];
        col2X = meshCol[4 * id2];
        col2Y = meshCol[4 * id2 + 1];
        col2Z = meshCol[4 * id2 + 2];
        col2A = meshCol[4 * id2 + 3];
        col0.set(col0X, col0Y, col0Z, col0A);
        col1.set(col1X, col1Y, col1Z, col1A);
        col2.set(col2X, col2Y, col2Z, col2A);
        col1.subtractToRef(col0, colvec0);
        col2.subtractToRef(col1, colvec1);
      }
      var width;
      var height;
      var deltaS;
      var deltaV;
      var h;
      var s;
      var v;
      var hsvCol;
      var statedColor = new Color3(0, 0, 0);
      var colPoint3 = new Color3(0, 0, 0);
      var pointColors;
      var particle;
      for (var i = 0; i < pointsGroup._groupDensity[index]; i++) {
        idxPoints = this.particles.length;
        this._addParticle(idxPoints, pointsGroup, this._groupCounter, index + i);
        particle = this.particles[idxPoints];
        lamda = Scalar.RandomRange(0, 1);
        mu = Scalar.RandomRange(0, 1);
        facetPoint = vertex0.add(vec0.scale(lamda)).add(vec1.scale(lamda * mu));
        if (isVolume) {
          norm = mesh.getFacetNormal(index).normalize().scale(-1);
          tang = vec0.clone().normalize();
          biNorm = Vector3.Cross(norm, tang);
          angle = Scalar.RandomRange(0, 2 * Math.PI);
          facetPlaneVec = tang.scale(Math.cos(angle)).add(biNorm.scale(Math.sin(angle)));
          angle = Scalar.RandomRange(0.1, Math.PI / 2);
          direction = facetPlaneVec.scale(Math.cos(angle)).add(norm.scale(Math.sin(angle)));
          ray.origin = facetPoint.add(direction.scale(1e-5));
          ray.direction = direction;
          ray.length = diameter;
          pickInfo = ray.intersectsMesh(mesh);
          if (pickInfo.hit) {
            distance = pickInfo.pickedPoint.subtract(facetPoint).length();
            gap = Scalar.RandomRange(0, 1) * distance;
            facetPoint.addInPlace(direction.scale(gap));
          }
        }
        particle.position = facetPoint.clone();
        this._positions.push(particle.position.x, particle.position.y, particle.position.z);
        if (colorFromTexture !== void 0) {
          if (meshUV) {
            uvPoint = uv0.add(uvec0.scale(lamda)).add(uvec1.scale(lamda * mu));
            if (colorFromTexture) {
              if (hasTexture && pointsGroup._groupImageData !== null) {
                width = pointsGroup._groupImgWidth;
                height = pointsGroup._groupImgHeight;
                pointColors = this._getColorIndicesForCoord(pointsGroup, Math.round(uvPoint.x * width), Math.round(uvPoint.y * height), width);
                particle.color = pointColors;
                this._colors.push(pointColors.r, pointColors.g, pointColors.b, pointColors.a);
              } else {
                if (meshCol) {
                  colPoint = col0.add(colvec0.scale(lamda)).add(colvec1.scale(lamda * mu));
                  particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);
                  this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);
                } else {
                  colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);
                  particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);
                  this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);
                }
              }
            } else {
              particle.uv = uvPoint.clone();
              this._uvs.push(particle.uv.x, particle.uv.y);
            }
          }
        } else {
          if (color) {
            statedColor.set(color.r, color.g, color.b);
            deltaS = Scalar.RandomRange(-range, range);
            deltaV = Scalar.RandomRange(-range, range);
            hsvCol = statedColor.toHSV();
            h = hsvCol.r;
            s = hsvCol.g + deltaS;
            v = hsvCol.b + deltaV;
            if (s < 0) {
              s = 0;
            }
            if (s > 1) {
              s = 1;
            }
            if (v < 0) {
              v = 0;
            }
            if (v > 1) {
              v = 1;
            }
            Color3.HSVtoRGBToRef(h, s, v, colPoint3);
            colPoint.set(colPoint3.r, colPoint3.g, colPoint3.b, 1);
          } else {
            colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);
          }
          particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);
          this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);
        }
      }
    }
  };
  PointsCloudSystem2.prototype._colorFromTexture = function(mesh, pointsGroup, isVolume) {
    var _this = this;
    if (mesh.material === null) {
      Logger.Warn(mesh.name + "has no material.");
      pointsGroup._groupImageData = null;
      this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);
      return;
    }
    var mat = mesh.material;
    var textureList = mat.getActiveTextures();
    if (textureList.length === 0) {
      Logger.Warn(mesh.name + "has no useable texture.");
      pointsGroup._groupImageData = null;
      this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);
      return;
    }
    var clone = mesh.clone();
    clone.setEnabled(false);
    this._promises.push(new Promise(function(resolve) {
      BaseTexture.WhenAllReady(textureList, function() {
        var n = pointsGroup._textureNb;
        if (n < 0) {
          n = 0;
        }
        if (n > textureList.length - 1) {
          n = textureList.length - 1;
        }
        pointsGroup._groupImageData = textureList[n].readPixels();
        pointsGroup._groupImgWidth = textureList[n].getSize().width;
        pointsGroup._groupImgHeight = textureList[n].getSize().height;
        _this._setPointsColorOrUV(clone, pointsGroup, isVolume, true, true);
        clone.dispose();
        return resolve();
      });
    }));
  };
  PointsCloudSystem2.prototype._calculateDensity = function(nbPoints, positions, indices) {
    var density = new Array();
    var index;
    var id0;
    var id1;
    var id2;
    var v0X;
    var v0Y;
    var v0Z;
    var v1X;
    var v1Y;
    var v1Z;
    var v2X;
    var v2Y;
    var v2Z;
    var vertex0 = Vector3.Zero();
    var vertex1 = Vector3.Zero();
    var vertex2 = Vector3.Zero();
    var vec0 = Vector3.Zero();
    var vec1 = Vector3.Zero();
    var vec2 = Vector3.Zero();
    var a;
    var b;
    var c;
    var p;
    var area;
    var areas = new Array();
    var surfaceArea = 0;
    var nbFacets = indices.length / 3;
    for (var index = 0; index < nbFacets; index++) {
      id0 = indices[3 * index];
      id1 = indices[3 * index + 1];
      id2 = indices[3 * index + 2];
      v0X = positions[3 * id0];
      v0Y = positions[3 * id0 + 1];
      v0Z = positions[3 * id0 + 2];
      v1X = positions[3 * id1];
      v1Y = positions[3 * id1 + 1];
      v1Z = positions[3 * id1 + 2];
      v2X = positions[3 * id2];
      v2Y = positions[3 * id2 + 1];
      v2Z = positions[3 * id2 + 2];
      vertex0.set(v0X, v0Y, v0Z);
      vertex1.set(v1X, v1Y, v1Z);
      vertex2.set(v2X, v2Y, v2Z);
      vertex1.subtractToRef(vertex0, vec0);
      vertex2.subtractToRef(vertex1, vec1);
      vertex2.subtractToRef(vertex0, vec2);
      a = vec0.length();
      b = vec1.length();
      c = vec2.length();
      p = (a + b + c) / 2;
      area = Math.sqrt(p * (p - a) * (p - b) * (p - c));
      surfaceArea += area;
      areas[index] = area;
    }
    var pointCount = 0;
    for (var index = 0; index < nbFacets; index++) {
      density[index] = Math.floor(nbPoints * areas[index] / surfaceArea);
      pointCount += density[index];
    }
    var diff = nbPoints - pointCount;
    var pointsPerFacet = Math.floor(diff / nbFacets);
    var extraPoints = diff % nbFacets;
    if (pointsPerFacet > 0) {
      density = density.map(function(x) {
        return x + pointsPerFacet;
      });
    }
    for (var index = 0; index < extraPoints; index++) {
      density[index] += 1;
    }
    return density;
  };
  PointsCloudSystem2.prototype.addPoints = function(nb, pointFunction) {
    if (pointFunction === void 0) {
      pointFunction = this._randomUnitVector;
    }
    var pointsGroup = new PointsGroup(this._groupCounter, pointFunction);
    var cp;
    var idx = this.nbParticles;
    for (var i = 0; i < nb; i++) {
      cp = this._addParticle(idx, pointsGroup, this._groupCounter, i);
      if (pointsGroup && pointsGroup._positionFunction) {
        pointsGroup._positionFunction(cp, idx, i);
      }
      this._positions.push(cp.position.x, cp.position.y, cp.position.z);
      if (cp.color) {
        this._colors.push(cp.color.r, cp.color.g, cp.color.b, cp.color.a);
      }
      if (cp.uv) {
        this._uvs.push(cp.uv.x, cp.uv.y);
      }
      idx++;
    }
    this.nbParticles += nb;
    this._groupCounter++;
    return this._groupCounter;
  };
  PointsCloudSystem2.prototype.addSurfacePoints = function(mesh, nb, colorWith, color, range) {
    var colored = colorWith ? colorWith : PointColor.Random;
    if (isNaN(colored) || colored < 0 || colored > 3) {
      colored = PointColor.Random;
    }
    var meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);
    var meshInd = mesh.getIndices();
    this._groups.push(this._groupCounter);
    var pointsGroup = new PointsGroup(this._groupCounter, null);
    pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);
    if (colored === PointColor.Color) {
      pointsGroup._textureNb = color ? color : 0;
    } else {
      color = color ? color : new Color4(1, 1, 1, 1);
    }
    switch (colored) {
      case PointColor.Color:
        this._colorFromTexture(mesh, pointsGroup, false);
        break;
      case PointColor.UV:
        this._setPointsColorOrUV(mesh, pointsGroup, false, false, false);
        break;
      case PointColor.Random:
        this._setPointsColorOrUV(mesh, pointsGroup, false);
        break;
      case PointColor.Stated:
        this._setPointsColorOrUV(mesh, pointsGroup, false, void 0, void 0, color, range);
        break;
    }
    this.nbParticles += nb;
    this._groupCounter++;
    return this._groupCounter - 1;
  };
  PointsCloudSystem2.prototype.addVolumePoints = function(mesh, nb, colorWith, color, range) {
    var colored = colorWith ? colorWith : PointColor.Random;
    if (isNaN(colored) || colored < 0 || colored > 3) {
      colored = PointColor.Random;
    }
    var meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);
    var meshInd = mesh.getIndices();
    this._groups.push(this._groupCounter);
    var pointsGroup = new PointsGroup(this._groupCounter, null);
    pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);
    if (colored === PointColor.Color) {
      pointsGroup._textureNb = color ? color : 0;
    } else {
      color = color ? color : new Color4(1, 1, 1, 1);
    }
    switch (colored) {
      case PointColor.Color:
        this._colorFromTexture(mesh, pointsGroup, true);
        break;
      case PointColor.UV:
        this._setPointsColorOrUV(mesh, pointsGroup, true, false, false);
        break;
      case PointColor.Random:
        this._setPointsColorOrUV(mesh, pointsGroup, true);
        break;
      case PointColor.Stated:
        this._setPointsColorOrUV(mesh, pointsGroup, true, void 0, void 0, color, range);
        break;
    }
    this.nbParticles += nb;
    this._groupCounter++;
    return this._groupCounter - 1;
  };
  PointsCloudSystem2.prototype.setParticles = function(start, end, update) {
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = this.nbParticles - 1;
    }
    if (update === void 0) {
      update = true;
    }
    if (!this._updatable || !this._isReady) {
      return this;
    }
    this.beforeUpdateParticles(start, end, update);
    var rotMatrix = TmpVectors.Matrix[0];
    var mesh = this.mesh;
    var colors32 = this._colors32;
    var positions32 = this._positions32;
    var uvs32 = this._uvs32;
    var tempVectors = TmpVectors.Vector3;
    var camAxisX = tempVectors[5].copyFromFloats(1, 0, 0);
    var camAxisY = tempVectors[6].copyFromFloats(0, 1, 0);
    var camAxisZ = tempVectors[7].copyFromFloats(0, 0, 1);
    var minimum = tempVectors[8].setAll(Number.MAX_VALUE);
    var maximum = tempVectors[9].setAll(-Number.MAX_VALUE);
    Matrix.IdentityToRef(rotMatrix);
    var idx = 0;
    if (this.mesh.isFacetDataEnabled) {
      this._computeBoundingBox = true;
    }
    end = end >= this.nbParticles ? this.nbParticles - 1 : end;
    if (this._computeBoundingBox) {
      if (start != 0 || end != this.nbParticles - 1) {
        var boundingInfo = this.mesh._boundingInfo;
        if (boundingInfo) {
          minimum.copyFrom(boundingInfo.minimum);
          maximum.copyFrom(boundingInfo.maximum);
        }
      }
    }
    var idx = 0;
    var pindex = 0;
    var cindex = 0;
    var uindex = 0;
    for (var p = start; p <= end; p++) {
      var particle = this.particles[p];
      idx = particle.idx;
      pindex = 3 * idx;
      cindex = 4 * idx;
      uindex = 2 * idx;
      this.updateParticle(particle);
      var particleRotationMatrix = particle._rotationMatrix;
      var particlePosition = particle.position;
      var particleGlobalPosition = particle._globalPosition;
      if (this._computeParticleRotation) {
        particle.getRotationMatrix(rotMatrix);
      }
      var particleHasParent = particle.parentId !== null;
      if (particleHasParent) {
        var parent_1 = this.particles[particle.parentId];
        var parentRotationMatrix = parent_1._rotationMatrix;
        var parentGlobalPosition = parent_1._globalPosition;
        var rotatedY_1 = particlePosition.x * parentRotationMatrix[1] + particlePosition.y * parentRotationMatrix[4] + particlePosition.z * parentRotationMatrix[7];
        var rotatedX_1 = particlePosition.x * parentRotationMatrix[0] + particlePosition.y * parentRotationMatrix[3] + particlePosition.z * parentRotationMatrix[6];
        var rotatedZ_1 = particlePosition.x * parentRotationMatrix[2] + particlePosition.y * parentRotationMatrix[5] + particlePosition.z * parentRotationMatrix[8];
        particleGlobalPosition.x = parentGlobalPosition.x + rotatedX_1;
        particleGlobalPosition.y = parentGlobalPosition.y + rotatedY_1;
        particleGlobalPosition.z = parentGlobalPosition.z + rotatedZ_1;
        if (this._computeParticleRotation) {
          var rotMatrixValues = rotMatrix.m;
          particleRotationMatrix[0] = rotMatrixValues[0] * parentRotationMatrix[0] + rotMatrixValues[1] * parentRotationMatrix[3] + rotMatrixValues[2] * parentRotationMatrix[6];
          particleRotationMatrix[1] = rotMatrixValues[0] * parentRotationMatrix[1] + rotMatrixValues[1] * parentRotationMatrix[4] + rotMatrixValues[2] * parentRotationMatrix[7];
          particleRotationMatrix[2] = rotMatrixValues[0] * parentRotationMatrix[2] + rotMatrixValues[1] * parentRotationMatrix[5] + rotMatrixValues[2] * parentRotationMatrix[8];
          particleRotationMatrix[3] = rotMatrixValues[4] * parentRotationMatrix[0] + rotMatrixValues[5] * parentRotationMatrix[3] + rotMatrixValues[6] * parentRotationMatrix[6];
          particleRotationMatrix[4] = rotMatrixValues[4] * parentRotationMatrix[1] + rotMatrixValues[5] * parentRotationMatrix[4] + rotMatrixValues[6] * parentRotationMatrix[7];
          particleRotationMatrix[5] = rotMatrixValues[4] * parentRotationMatrix[2] + rotMatrixValues[5] * parentRotationMatrix[5] + rotMatrixValues[6] * parentRotationMatrix[8];
          particleRotationMatrix[6] = rotMatrixValues[8] * parentRotationMatrix[0] + rotMatrixValues[9] * parentRotationMatrix[3] + rotMatrixValues[10] * parentRotationMatrix[6];
          particleRotationMatrix[7] = rotMatrixValues[8] * parentRotationMatrix[1] + rotMatrixValues[9] * parentRotationMatrix[4] + rotMatrixValues[10] * parentRotationMatrix[7];
          particleRotationMatrix[8] = rotMatrixValues[8] * parentRotationMatrix[2] + rotMatrixValues[9] * parentRotationMatrix[5] + rotMatrixValues[10] * parentRotationMatrix[8];
        }
      } else {
        particleGlobalPosition.x = 0;
        particleGlobalPosition.y = 0;
        particleGlobalPosition.z = 0;
        if (this._computeParticleRotation) {
          var rotMatrixValues = rotMatrix.m;
          particleRotationMatrix[0] = rotMatrixValues[0];
          particleRotationMatrix[1] = rotMatrixValues[1];
          particleRotationMatrix[2] = rotMatrixValues[2];
          particleRotationMatrix[3] = rotMatrixValues[4];
          particleRotationMatrix[4] = rotMatrixValues[5];
          particleRotationMatrix[5] = rotMatrixValues[6];
          particleRotationMatrix[6] = rotMatrixValues[8];
          particleRotationMatrix[7] = rotMatrixValues[9];
          particleRotationMatrix[8] = rotMatrixValues[10];
        }
      }
      var pivotBackTranslation = tempVectors[11];
      if (particle.translateFromPivot) {
        pivotBackTranslation.setAll(0);
      } else {
        pivotBackTranslation.copyFrom(particle.pivot);
      }
      var tmpVertex = tempVectors[0];
      tmpVertex.copyFrom(particle.position);
      var vertexX = tmpVertex.x - particle.pivot.x;
      var vertexY = tmpVertex.y - particle.pivot.y;
      var vertexZ = tmpVertex.z - particle.pivot.z;
      var rotatedX = vertexX * particleRotationMatrix[0] + vertexY * particleRotationMatrix[3] + vertexZ * particleRotationMatrix[6];
      var rotatedY = vertexX * particleRotationMatrix[1] + vertexY * particleRotationMatrix[4] + vertexZ * particleRotationMatrix[7];
      var rotatedZ = vertexX * particleRotationMatrix[2] + vertexY * particleRotationMatrix[5] + vertexZ * particleRotationMatrix[8];
      rotatedX += pivotBackTranslation.x;
      rotatedY += pivotBackTranslation.y;
      rotatedZ += pivotBackTranslation.z;
      var px = positions32[pindex] = particleGlobalPosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ;
      var py = positions32[pindex + 1] = particleGlobalPosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ;
      var pz = positions32[pindex + 2] = particleGlobalPosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ;
      if (this._computeBoundingBox) {
        minimum.minimizeInPlaceFromFloats(px, py, pz);
        maximum.maximizeInPlaceFromFloats(px, py, pz);
      }
      if (this._computeParticleColor && particle.color) {
        var color = particle.color;
        var colors32_1 = this._colors32;
        colors32_1[cindex] = color.r;
        colors32_1[cindex + 1] = color.g;
        colors32_1[cindex + 2] = color.b;
        colors32_1[cindex + 3] = color.a;
      }
      if (this._computeParticleTexture && particle.uv) {
        var uv = particle.uv;
        var uvs32_1 = this._uvs32;
        uvs32_1[uindex] = uv.x;
        uvs32_1[uindex + 1] = uv.y;
      }
    }
    if (update) {
      if (this._computeParticleColor) {
        mesh.updateVerticesData(VertexBuffer.ColorKind, colors32, false, false);
      }
      if (this._computeParticleTexture) {
        mesh.updateVerticesData(VertexBuffer.UVKind, uvs32, false, false);
      }
      mesh.updateVerticesData(VertexBuffer.PositionKind, positions32, false, false);
    }
    if (this._computeBoundingBox) {
      if (mesh._boundingInfo) {
        mesh._boundingInfo.reConstruct(minimum, maximum, mesh._worldMatrix);
      } else {
        mesh._boundingInfo = new BoundingInfo(minimum, maximum, mesh._worldMatrix);
      }
    }
    this.afterUpdateParticles(start, end, update);
    return this;
  };
  PointsCloudSystem2.prototype.dispose = function() {
    this.mesh.dispose();
    this.vars = null;
    this._positions = null;
    this._indices = null;
    this._normals = null;
    this._uvs = null;
    this._colors = null;
    this._indices32 = null;
    this._positions32 = null;
    this._uvs32 = null;
    this._colors32 = null;
  };
  PointsCloudSystem2.prototype.refreshVisibleSize = function() {
    if (!this._isVisibilityBoxLocked) {
      this.mesh.refreshBoundingInfo();
    }
    return this;
  };
  PointsCloudSystem2.prototype.setVisibilityBox = function(size) {
    var vis = size / 2;
    this.mesh._boundingInfo = new BoundingInfo(new Vector3(-vis, -vis, -vis), new Vector3(vis, vis, vis));
  };
  Object.defineProperty(PointsCloudSystem2.prototype, "isAlwaysVisible", {
    get: function() {
      return this._alwaysVisible;
    },
    set: function(val) {
      this._alwaysVisible = val;
      this.mesh.alwaysSelectAsActiveMesh = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PointsCloudSystem2.prototype, "computeParticleRotation", {
    set: function(val) {
      this._computeParticleRotation = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PointsCloudSystem2.prototype, "computeParticleColor", {
    get: function() {
      return this._computeParticleColor;
    },
    set: function(val) {
      this._computeParticleColor = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PointsCloudSystem2.prototype, "computeParticleTexture", {
    get: function() {
      return this._computeParticleTexture;
    },
    set: function(val) {
      this._computeParticleTexture = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PointsCloudSystem2.prototype, "computeBoundingBox", {
    get: function() {
      return this._computeBoundingBox;
    },
    set: function(val) {
      this._computeBoundingBox = val;
    },
    enumerable: false,
    configurable: true
  });
  PointsCloudSystem2.prototype.initParticles = function() {
  };
  PointsCloudSystem2.prototype.recycleParticle = function(particle) {
    return particle;
  };
  PointsCloudSystem2.prototype.updateParticle = function(particle) {
    return particle;
  };
  PointsCloudSystem2.prototype.beforeUpdateParticles = function(start, stop, update) {
  };
  PointsCloudSystem2.prototype.afterUpdateParticles = function(start, stop, update) {
  };
  return PointsCloudSystem2;
}();

// node_modules/@babylonjs/core/Physics/physicsEngineComponent.js
Scene.prototype.getPhysicsEngine = function() {
  return this._physicsEngine;
};
Scene.prototype.enablePhysics = function(gravity, plugin) {
  if (gravity === void 0) {
    gravity = null;
  }
  if (this._physicsEngine) {
    return true;
  }
  var component = this._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE);
  if (!component) {
    component = new PhysicsEngineSceneComponent(this);
    this._addComponent(component);
  }
  try {
    this._physicsEngine = new PhysicsEngine(gravity, plugin);
    this._physicsTimeAccumulator = 0;
    return true;
  } catch (e) {
    Logger.Error(e.message);
    return false;
  }
};
Scene.prototype.disablePhysicsEngine = function() {
  if (!this._physicsEngine) {
    return;
  }
  this._physicsEngine.dispose();
  this._physicsEngine = null;
};
Scene.prototype.isPhysicsEnabled = function() {
  return this._physicsEngine !== void 0;
};
Scene.prototype.deleteCompoundImpostor = function(compound) {
  var mesh = compound.parts[0].mesh;
  if (mesh.physicsImpostor) {
    mesh.physicsImpostor.dispose();
    mesh.physicsImpostor = null;
  }
};
Scene.prototype._advancePhysicsEngineStep = function(step) {
  if (this._physicsEngine) {
    var subTime = this._physicsEngine.getSubTimeStep();
    if (subTime > 0) {
      this._physicsTimeAccumulator += step;
      while (this._physicsTimeAccumulator > subTime) {
        this.onBeforePhysicsObservable.notifyObservers(this);
        this._physicsEngine._step(subTime / 1e3);
        this.onAfterPhysicsObservable.notifyObservers(this);
        this._physicsTimeAccumulator -= subTime;
      }
    } else {
      this.onBeforePhysicsObservable.notifyObservers(this);
      this._physicsEngine._step(step / 1e3);
      this.onAfterPhysicsObservable.notifyObservers(this);
    }
  }
};
Object.defineProperty(AbstractMesh.prototype, "physicsImpostor", {
  get: function() {
    return this._physicsImpostor;
  },
  set: function(value) {
    var _this = this;
    if (this._physicsImpostor === value) {
      return;
    }
    if (this._disposePhysicsObserver) {
      this.onDisposeObservable.remove(this._disposePhysicsObserver);
    }
    this._physicsImpostor = value;
    if (value) {
      this._disposePhysicsObserver = this.onDisposeObservable.add(function() {
        if (_this.physicsImpostor) {
          _this.physicsImpostor.dispose();
          _this.physicsImpostor = null;
        }
      });
    }
  },
  enumerable: true,
  configurable: true
});
AbstractMesh.prototype.getPhysicsImpostor = function() {
  return this.physicsImpostor;
};
AbstractMesh.prototype.applyImpulse = function(force, contactPoint) {
  if (!this.physicsImpostor) {
    return this;
  }
  this.physicsImpostor.applyImpulse(force, contactPoint);
  return this;
};
AbstractMesh.prototype.setPhysicsLinkWith = function(otherMesh, pivot1, pivot2, options) {
  if (!this.physicsImpostor || !otherMesh.physicsImpostor) {
    return this;
  }
  this.physicsImpostor.createJoint(otherMesh.physicsImpostor, PhysicsJoint.HingeJoint, {
    mainPivot: pivot1,
    connectedPivot: pivot2,
    nativeParams: options
  });
  return this;
};
var PhysicsEngineSceneComponent = function() {
  function PhysicsEngineSceneComponent2(scene) {
    var _this = this;
    this.name = SceneComponentConstants.NAME_PHYSICSENGINE;
    this.scene = scene;
    this.scene.onBeforePhysicsObservable = new Observable();
    this.scene.onAfterPhysicsObservable = new Observable();
    this.scene.getDeterministicFrameTime = function() {
      if (_this.scene._physicsEngine) {
        return _this.scene._physicsEngine.getTimeStep() * 1e3;
      }
      return 1e3 / 60;
    };
  }
  PhysicsEngineSceneComponent2.prototype.register = function() {
  };
  PhysicsEngineSceneComponent2.prototype.rebuild = function() {
  };
  PhysicsEngineSceneComponent2.prototype.dispose = function() {
    this.scene.onBeforePhysicsObservable.clear();
    this.scene.onAfterPhysicsObservable.clear();
    if (this.scene._physicsEngine) {
      this.scene.disablePhysicsEngine();
    }
  };
  return PhysicsEngineSceneComponent2;
}();

// node_modules/@babylonjs/core/Physics/physicsHelper.js
var PhysicsHelper = function() {
  function PhysicsHelper2(scene) {
    this._scene = scene;
    this._physicsEngine = this._scene.getPhysicsEngine();
    if (!this._physicsEngine) {
      Logger.Warn("Physics engine not enabled. Please enable the physics before you can use the methods.");
      return;
    }
  }
  PhysicsHelper2.prototype.applyRadialExplosionImpulse = function(origin, radiusOrEventOptions, strength, falloff) {
    if (!this._physicsEngine) {
      Logger.Warn("Physics engine not enabled. Please enable the physics before you call this method.");
      return null;
    }
    var impostors = this._physicsEngine.getImpostors();
    if (impostors.length === 0) {
      return null;
    }
    if (typeof radiusOrEventOptions === "number") {
      radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();
      radiusOrEventOptions.radius = radiusOrEventOptions;
      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;
      radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;
    }
    var event = new PhysicsRadialExplosionEvent(this._scene, radiusOrEventOptions);
    var affectedImpostorsWithData = Array();
    impostors.forEach(function(impostor) {
      var impostorHitData = event.getImpostorHitData(impostor, origin);
      if (!impostorHitData) {
        return;
      }
      impostor.applyImpulse(impostorHitData.force, impostorHitData.contactPoint);
      affectedImpostorsWithData.push({
        impostor,
        hitData: impostorHitData
      });
    });
    event.triggerAffectedImpostorsCallback(affectedImpostorsWithData);
    event.dispose(false);
    return event;
  };
  PhysicsHelper2.prototype.applyRadialExplosionForce = function(origin, radiusOrEventOptions, strength, falloff) {
    if (!this._physicsEngine) {
      Logger.Warn("Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.");
      return null;
    }
    var impostors = this._physicsEngine.getImpostors();
    if (impostors.length === 0) {
      return null;
    }
    if (typeof radiusOrEventOptions === "number") {
      radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();
      radiusOrEventOptions.radius = radiusOrEventOptions;
      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;
      radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;
    }
    var event = new PhysicsRadialExplosionEvent(this._scene, radiusOrEventOptions);
    var affectedImpostorsWithData = Array();
    impostors.forEach(function(impostor) {
      var impostorHitData = event.getImpostorHitData(impostor, origin);
      if (!impostorHitData) {
        return;
      }
      impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);
      affectedImpostorsWithData.push({
        impostor,
        hitData: impostorHitData
      });
    });
    event.triggerAffectedImpostorsCallback(affectedImpostorsWithData);
    event.dispose(false);
    return event;
  };
  PhysicsHelper2.prototype.gravitationalField = function(origin, radiusOrEventOptions, strength, falloff) {
    if (!this._physicsEngine) {
      Logger.Warn("Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.");
      return null;
    }
    var impostors = this._physicsEngine.getImpostors();
    if (impostors.length === 0) {
      return null;
    }
    if (typeof radiusOrEventOptions === "number") {
      radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();
      radiusOrEventOptions.radius = radiusOrEventOptions;
      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;
      radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;
    }
    var event = new PhysicsGravitationalFieldEvent(this, this._scene, origin, radiusOrEventOptions);
    event.dispose(false);
    return event;
  };
  PhysicsHelper2.prototype.updraft = function(origin, radiusOrEventOptions, strength, height, updraftMode) {
    if (!this._physicsEngine) {
      Logger.Warn("Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.");
      return null;
    }
    if (this._physicsEngine.getImpostors().length === 0) {
      return null;
    }
    if (typeof radiusOrEventOptions === "number") {
      radiusOrEventOptions = new PhysicsUpdraftEventOptions();
      radiusOrEventOptions.radius = radiusOrEventOptions;
      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;
      radiusOrEventOptions.height = height || radiusOrEventOptions.height;
      radiusOrEventOptions.updraftMode = updraftMode || radiusOrEventOptions.updraftMode;
    }
    var event = new PhysicsUpdraftEvent(this._scene, origin, radiusOrEventOptions);
    event.dispose(false);
    return event;
  };
  PhysicsHelper2.prototype.vortex = function(origin, radiusOrEventOptions, strength, height) {
    if (!this._physicsEngine) {
      Logger.Warn("Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.");
      return null;
    }
    if (this._physicsEngine.getImpostors().length === 0) {
      return null;
    }
    if (typeof radiusOrEventOptions === "number") {
      radiusOrEventOptions = new PhysicsVortexEventOptions();
      radiusOrEventOptions.radius = radiusOrEventOptions;
      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;
      radiusOrEventOptions.height = height || radiusOrEventOptions.height;
    }
    var event = new PhysicsVortexEvent(this._scene, origin, radiusOrEventOptions);
    event.dispose(false);
    return event;
  };
  return PhysicsHelper2;
}();
var PhysicsRadialExplosionEvent = function() {
  function PhysicsRadialExplosionEvent2(_scene, _options) {
    this._scene = _scene;
    this._options = _options;
    this._dataFetched = false;
    this._options = __assign(__assign({}, new PhysicsRadialExplosionEventOptions()), this._options);
  }
  PhysicsRadialExplosionEvent2.prototype.getData = function() {
    this._dataFetched = true;
    return {
      sphere: this._sphere
    };
  };
  PhysicsRadialExplosionEvent2.prototype.getImpostorHitData = function(impostor, origin) {
    if (impostor.mass === 0) {
      return null;
    }
    if (!this._intersectsWithSphere(impostor, origin, this._options.radius)) {
      return null;
    }
    if (impostor.object.getClassName() !== "Mesh" && impostor.object.getClassName() !== "InstancedMesh") {
      return null;
    }
    var impostorObjectCenter = impostor.getObjectCenter();
    var direction = impostorObjectCenter.subtract(origin);
    var ray = new Ray(origin, direction, this._options.radius);
    var hit = ray.intersectsMesh(impostor.object);
    var contactPoint = hit.pickedPoint;
    if (!contactPoint) {
      return null;
    }
    var distanceFromOrigin = Vector3.Distance(origin, contactPoint);
    if (distanceFromOrigin > this._options.radius) {
      return null;
    }
    var multiplier = this._options.falloff === PhysicsRadialImpulseFalloff.Constant ? this._options.strength : this._options.strength * (1 - distanceFromOrigin / this._options.radius);
    var force = direction.multiplyByFloats(multiplier, multiplier, multiplier);
    return { force, contactPoint, distanceFromOrigin };
  };
  PhysicsRadialExplosionEvent2.prototype.triggerAffectedImpostorsCallback = function(affectedImpostorsWithData) {
    if (this._options.affectedImpostorsCallback) {
      this._options.affectedImpostorsCallback(affectedImpostorsWithData);
    }
  };
  PhysicsRadialExplosionEvent2.prototype.dispose = function(force) {
    var _this = this;
    if (force === void 0) {
      force = true;
    }
    if (force) {
      this._sphere.dispose();
    } else {
      setTimeout(function() {
        if (!_this._dataFetched) {
          _this._sphere.dispose();
        }
      }, 0);
    }
  };
  PhysicsRadialExplosionEvent2.prototype._prepareSphere = function() {
    if (!this._sphere) {
      this._sphere = SphereBuilder.CreateSphere("radialExplosionEventSphere", this._options.sphere, this._scene);
      this._sphere.isVisible = false;
    }
  };
  PhysicsRadialExplosionEvent2.prototype._intersectsWithSphere = function(impostor, origin, radius) {
    var impostorObject = impostor.object;
    this._prepareSphere();
    this._sphere.position = origin;
    this._sphere.scaling = new Vector3(radius * 2, radius * 2, radius * 2);
    this._sphere._updateBoundingInfo();
    this._sphere.computeWorldMatrix(true);
    return this._sphere.intersectsMesh(impostorObject, true);
  };
  return PhysicsRadialExplosionEvent2;
}();
var PhysicsGravitationalFieldEvent = function() {
  function PhysicsGravitationalFieldEvent2(_physicsHelper, _scene, _origin, _options) {
    this._physicsHelper = _physicsHelper;
    this._scene = _scene;
    this._origin = _origin;
    this._options = _options;
    this._dataFetched = false;
    this._options = __assign(__assign({}, new PhysicsRadialExplosionEventOptions()), this._options);
    this._tickCallback = this._tick.bind(this);
    this._options.strength = this._options.strength * -1;
  }
  PhysicsGravitationalFieldEvent2.prototype.getData = function() {
    this._dataFetched = true;
    return {
      sphere: this._sphere
    };
  };
  PhysicsGravitationalFieldEvent2.prototype.enable = function() {
    this._tickCallback.call(this);
    this._scene.registerBeforeRender(this._tickCallback);
  };
  PhysicsGravitationalFieldEvent2.prototype.disable = function() {
    this._scene.unregisterBeforeRender(this._tickCallback);
  };
  PhysicsGravitationalFieldEvent2.prototype.dispose = function(force) {
    var _this = this;
    if (force === void 0) {
      force = true;
    }
    if (force) {
      this._sphere.dispose();
    } else {
      setTimeout(function() {
        if (!_this._dataFetched) {
          _this._sphere.dispose();
        }
      }, 0);
    }
  };
  PhysicsGravitationalFieldEvent2.prototype._tick = function() {
    if (this._sphere) {
      this._physicsHelper.applyRadialExplosionForce(this._origin, this._options);
    } else {
      var radialExplosionEvent = this._physicsHelper.applyRadialExplosionForce(this._origin, this._options);
      if (radialExplosionEvent) {
        this._sphere = radialExplosionEvent.getData().sphere.clone("radialExplosionEventSphereClone");
      }
    }
  };
  return PhysicsGravitationalFieldEvent2;
}();
var PhysicsUpdraftEvent = function() {
  function PhysicsUpdraftEvent2(_scene, _origin, _options) {
    this._scene = _scene;
    this._origin = _origin;
    this._options = _options;
    this._originTop = Vector3.Zero();
    this._originDirection = Vector3.Zero();
    this._cylinderPosition = Vector3.Zero();
    this._dataFetched = false;
    this._physicsEngine = this._scene.getPhysicsEngine();
    this._options = __assign(__assign({}, new PhysicsUpdraftEventOptions()), this._options);
    this._origin.addToRef(new Vector3(0, this._options.height / 2, 0), this._cylinderPosition);
    this._origin.addToRef(new Vector3(0, this._options.height, 0), this._originTop);
    if (this._options.updraftMode === PhysicsUpdraftMode.Perpendicular) {
      this._originDirection = this._origin.subtract(this._originTop).normalize();
    }
    this._tickCallback = this._tick.bind(this);
    this._prepareCylinder();
  }
  PhysicsUpdraftEvent2.prototype.getData = function() {
    this._dataFetched = true;
    return {
      cylinder: this._cylinder
    };
  };
  PhysicsUpdraftEvent2.prototype.enable = function() {
    this._tickCallback.call(this);
    this._scene.registerBeforeRender(this._tickCallback);
  };
  PhysicsUpdraftEvent2.prototype.disable = function() {
    this._scene.unregisterBeforeRender(this._tickCallback);
  };
  PhysicsUpdraftEvent2.prototype.dispose = function(force) {
    var _this = this;
    if (force === void 0) {
      force = true;
    }
    if (!this._cylinder) {
      return;
    }
    if (force) {
      this._cylinder.dispose();
    } else {
      setTimeout(function() {
        if (!_this._dataFetched) {
          _this._cylinder.dispose();
        }
      }, 0);
    }
  };
  PhysicsUpdraftEvent2.prototype.getImpostorHitData = function(impostor) {
    if (impostor.mass === 0) {
      return null;
    }
    if (!this._intersectsWithCylinder(impostor)) {
      return null;
    }
    var impostorObjectCenter = impostor.getObjectCenter();
    if (this._options.updraftMode === PhysicsUpdraftMode.Perpendicular) {
      var direction = this._originDirection;
    } else {
      var direction = impostorObjectCenter.subtract(this._originTop);
    }
    var distanceFromOrigin = Vector3.Distance(this._origin, impostorObjectCenter);
    var multiplier = this._options.strength * -1;
    var force = direction.multiplyByFloats(multiplier, multiplier, multiplier);
    return { force, contactPoint: impostorObjectCenter, distanceFromOrigin };
  };
  PhysicsUpdraftEvent2.prototype._tick = function() {
    var _this = this;
    this._physicsEngine.getImpostors().forEach(function(impostor) {
      var impostorHitData = _this.getImpostorHitData(impostor);
      if (!impostorHitData) {
        return;
      }
      impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);
    });
  };
  PhysicsUpdraftEvent2.prototype._prepareCylinder = function() {
    if (!this._cylinder) {
      this._cylinder = CylinderBuilder.CreateCylinder("updraftEventCylinder", {
        height: this._options.height,
        diameter: this._options.radius * 2
      }, this._scene);
      this._cylinder.isVisible = false;
    }
  };
  PhysicsUpdraftEvent2.prototype._intersectsWithCylinder = function(impostor) {
    var impostorObject = impostor.object;
    this._cylinder.position = this._cylinderPosition;
    return this._cylinder.intersectsMesh(impostorObject, true);
  };
  return PhysicsUpdraftEvent2;
}();
var PhysicsVortexEvent = function() {
  function PhysicsVortexEvent2(_scene, _origin, _options) {
    this._scene = _scene;
    this._origin = _origin;
    this._options = _options;
    this._originTop = Vector3.Zero();
    this._cylinderPosition = Vector3.Zero();
    this._dataFetched = false;
    this._physicsEngine = this._scene.getPhysicsEngine();
    this._options = __assign(__assign({}, new PhysicsVortexEventOptions()), this._options);
    this._origin.addToRef(new Vector3(0, this._options.height / 2, 0), this._cylinderPosition);
    this._origin.addToRef(new Vector3(0, this._options.height, 0), this._originTop);
    this._tickCallback = this._tick.bind(this);
    this._prepareCylinder();
  }
  PhysicsVortexEvent2.prototype.getData = function() {
    this._dataFetched = true;
    return {
      cylinder: this._cylinder
    };
  };
  PhysicsVortexEvent2.prototype.enable = function() {
    this._tickCallback.call(this);
    this._scene.registerBeforeRender(this._tickCallback);
  };
  PhysicsVortexEvent2.prototype.disable = function() {
    this._scene.unregisterBeforeRender(this._tickCallback);
  };
  PhysicsVortexEvent2.prototype.dispose = function(force) {
    var _this = this;
    if (force === void 0) {
      force = true;
    }
    if (force) {
      this._cylinder.dispose();
    } else {
      setTimeout(function() {
        if (!_this._dataFetched) {
          _this._cylinder.dispose();
        }
      }, 0);
    }
  };
  PhysicsVortexEvent2.prototype.getImpostorHitData = function(impostor) {
    if (impostor.mass === 0) {
      return null;
    }
    if (!this._intersectsWithCylinder(impostor)) {
      return null;
    }
    if (impostor.object.getClassName() !== "Mesh" && impostor.object.getClassName() !== "InstancedMesh") {
      return null;
    }
    var impostorObjectCenter = impostor.getObjectCenter();
    var originOnPlane = new Vector3(this._origin.x, impostorObjectCenter.y, this._origin.z);
    var originToImpostorDirection = impostorObjectCenter.subtract(originOnPlane);
    var ray = new Ray(originOnPlane, originToImpostorDirection, this._options.radius);
    var hit = ray.intersectsMesh(impostor.object);
    var contactPoint = hit.pickedPoint;
    if (!contactPoint) {
      return null;
    }
    var absoluteDistanceFromOrigin = hit.distance / this._options.radius;
    var directionToOrigin = contactPoint.normalize();
    if (absoluteDistanceFromOrigin > this._options.centripetalForceThreshold) {
      directionToOrigin = directionToOrigin.negate();
    }
    if (absoluteDistanceFromOrigin > this._options.centripetalForceThreshold) {
      var forceX = directionToOrigin.x * this._options.centripetalForceMultiplier;
      var forceY = directionToOrigin.y * this._options.updraftForceMultiplier;
      var forceZ = directionToOrigin.z * this._options.centripetalForceMultiplier;
    } else {
      var perpendicularDirection = Vector3.Cross(originOnPlane, impostorObjectCenter).normalize();
      var forceX = (perpendicularDirection.x + directionToOrigin.x) * this._options.centrifugalForceMultiplier;
      var forceY = this._originTop.y * this._options.updraftForceMultiplier;
      var forceZ = (perpendicularDirection.z + directionToOrigin.z) * this._options.centrifugalForceMultiplier;
    }
    var force = new Vector3(forceX, forceY, forceZ);
    force = force.multiplyByFloats(this._options.strength, this._options.strength, this._options.strength);
    return { force, contactPoint: impostorObjectCenter, distanceFromOrigin: absoluteDistanceFromOrigin };
  };
  PhysicsVortexEvent2.prototype._tick = function() {
    var _this = this;
    this._physicsEngine.getImpostors().forEach(function(impostor) {
      var impostorHitData = _this.getImpostorHitData(impostor);
      if (!impostorHitData) {
        return;
      }
      impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);
    });
  };
  PhysicsVortexEvent2.prototype._prepareCylinder = function() {
    if (!this._cylinder) {
      this._cylinder = CylinderBuilder.CreateCylinder("vortexEventCylinder", {
        height: this._options.height,
        diameter: this._options.radius * 2
      }, this._scene);
      this._cylinder.isVisible = false;
    }
  };
  PhysicsVortexEvent2.prototype._intersectsWithCylinder = function(impostor) {
    var impostorObject = impostor.object;
    this._cylinder.position = this._cylinderPosition;
    return this._cylinder.intersectsMesh(impostorObject, true);
  };
  return PhysicsVortexEvent2;
}();
var PhysicsRadialExplosionEventOptions = function() {
  function PhysicsRadialExplosionEventOptions2() {
    this.radius = 5;
    this.strength = 10;
    this.falloff = PhysicsRadialImpulseFalloff.Constant;
    this.sphere = { segments: 32, diameter: 1 };
  }
  return PhysicsRadialExplosionEventOptions2;
}();
var PhysicsUpdraftEventOptions = function() {
  function PhysicsUpdraftEventOptions2() {
    this.radius = 5;
    this.strength = 10;
    this.height = 10;
    this.updraftMode = PhysicsUpdraftMode.Center;
  }
  return PhysicsUpdraftEventOptions2;
}();
var PhysicsVortexEventOptions = function() {
  function PhysicsVortexEventOptions2() {
    this.radius = 5;
    this.strength = 10;
    this.height = 10;
    this.centripetalForceThreshold = 0.7;
    this.centripetalForceMultiplier = 5;
    this.centrifugalForceMultiplier = 0.5;
    this.updraftForceMultiplier = 0.02;
  }
  return PhysicsVortexEventOptions2;
}();
var PhysicsRadialImpulseFalloff;
(function(PhysicsRadialImpulseFalloff2) {
  PhysicsRadialImpulseFalloff2[PhysicsRadialImpulseFalloff2["Constant"] = 0] = "Constant";
  PhysicsRadialImpulseFalloff2[PhysicsRadialImpulseFalloff2["Linear"] = 1] = "Linear";
})(PhysicsRadialImpulseFalloff || (PhysicsRadialImpulseFalloff = {}));
var PhysicsUpdraftMode;
(function(PhysicsUpdraftMode2) {
  PhysicsUpdraftMode2[PhysicsUpdraftMode2["Center"] = 0] = "Center";
  PhysicsUpdraftMode2[PhysicsUpdraftMode2["Perpendicular"] = 1] = "Perpendicular";
})(PhysicsUpdraftMode || (PhysicsUpdraftMode = {}));

// node_modules/@babylonjs/core/Shaders/blackAndWhite.fragment.js
var name53 = "blackAndWhitePixelShader";
var shader53 = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform float degree;\nvoid main(void)\n{\nvec3 color=texture2D(textureSampler,vUV).rgb;\nfloat luminance=dot(color,vec3(0.3,0.59,0.11));\nvec3 blackAndWhite=vec3(luminance,luminance,luminance);\ngl_FragColor=vec4(color-((color-blackAndWhite)*degree),1.0);\n}";
Effect.ShadersStore[name53] = shader53;

// node_modules/@babylonjs/core/PostProcesses/blackAndWhitePostProcess.js
var BlackAndWhitePostProcess = function(_super) {
  __extends(BlackAndWhitePostProcess2, _super);
  function BlackAndWhitePostProcess2(name98, options, camera, samplingMode, engine, reusable) {
    var _this = _super.call(this, name98, "blackAndWhite", ["degree"], null, options, camera, samplingMode, engine, reusable) || this;
    _this.degree = 1;
    _this.onApplyObservable.add(function(effect) {
      effect.setFloat("degree", _this.degree);
    });
    return _this;
  }
  BlackAndWhitePostProcess2.prototype.getClassName = function() {
    return "BlackAndWhitePostProcess";
  };
  BlackAndWhitePostProcess2._Parse = function(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(function() {
      return new BlackAndWhitePostProcess2(parsedPostProcess.name, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable);
    }, parsedPostProcess, scene, rootUrl);
  };
  __decorate([
    serialize()
  ], BlackAndWhitePostProcess2.prototype, "degree", void 0);
  return BlackAndWhitePostProcess2;
}(PostProcess);
_TypeStore.RegisteredTypes["BABYLON.BlackAndWhitePostProcess"] = BlackAndWhitePostProcess;

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/postProcessRenderEffect.js
var PostProcessRenderEffect = function() {
  function PostProcessRenderEffect2(engine, name98, getPostProcesses, singleInstance) {
    this._name = name98;
    this._singleInstance = singleInstance || true;
    this._getPostProcesses = getPostProcesses;
    this._cameras = {};
    this._indicesForCamera = {};
    this._postProcesses = {};
  }
  Object.defineProperty(PostProcessRenderEffect2.prototype, "isSupported", {
    get: function() {
      for (var index in this._postProcesses) {
        if (this._postProcesses.hasOwnProperty(index)) {
          var pps = this._postProcesses[index];
          for (var ppIndex = 0; ppIndex < pps.length; ppIndex++) {
            if (!pps[ppIndex].isSupported) {
              return false;
            }
          }
        }
      }
      return true;
    },
    enumerable: false,
    configurable: true
  });
  PostProcessRenderEffect2.prototype._update = function() {
  };
  PostProcessRenderEffect2.prototype._attachCameras = function(cameras) {
    var _this = this;
    var cameraKey;
    var cams = Tools.MakeArray(cameras || this._cameras);
    if (!cams) {
      return;
    }
    for (var i = 0; i < cams.length; i++) {
      var camera = cams[i];
      if (!camera) {
        continue;
      }
      var cameraName = camera.name;
      if (this._singleInstance) {
        cameraKey = 0;
      } else {
        cameraKey = cameraName;
      }
      if (!this._postProcesses[cameraKey]) {
        var postProcess = this._getPostProcesses();
        if (postProcess) {
          this._postProcesses[cameraKey] = Array.isArray(postProcess) ? postProcess : [postProcess];
        }
      }
      if (!this._indicesForCamera[cameraName]) {
        this._indicesForCamera[cameraName] = [];
      }
      this._postProcesses[cameraKey].forEach(function(postProcess2) {
        var index = camera.attachPostProcess(postProcess2);
        _this._indicesForCamera[cameraName].push(index);
      });
      if (!this._cameras[cameraName]) {
        this._cameras[cameraName] = camera;
      }
    }
  };
  PostProcessRenderEffect2.prototype._detachCameras = function(cameras) {
    var cams = Tools.MakeArray(cameras || this._cameras);
    if (!cams) {
      return;
    }
    for (var i = 0; i < cams.length; i++) {
      var camera = cams[i];
      var cameraName = camera.name;
      var postProcesses = this._postProcesses[this._singleInstance ? 0 : cameraName];
      if (postProcesses) {
        postProcesses.forEach(function(postProcess) {
          camera.detachPostProcess(postProcess);
        });
      }
      if (this._cameras[cameraName]) {
        this._cameras[cameraName] = null;
      }
    }
  };
  PostProcessRenderEffect2.prototype._enable = function(cameras) {
    var _this = this;
    var cams = Tools.MakeArray(cameras || this._cameras);
    if (!cams) {
      return;
    }
    for (var i = 0; i < cams.length; i++) {
      var camera = cams[i];
      var cameraName = camera.name;
      for (var j = 0; j < this._indicesForCamera[cameraName].length; j++) {
        if (camera._postProcesses[this._indicesForCamera[cameraName][j]] === void 0 || camera._postProcesses[this._indicesForCamera[cameraName][j]] === null) {
          this._postProcesses[this._singleInstance ? 0 : cameraName].forEach(function(postProcess) {
            cams[i].attachPostProcess(postProcess, _this._indicesForCamera[cameraName][j]);
          });
        }
      }
    }
  };
  PostProcessRenderEffect2.prototype._disable = function(cameras) {
    var cams = Tools.MakeArray(cameras || this._cameras);
    if (!cams) {
      return;
    }
    for (var i = 0; i < cams.length; i++) {
      var camera = cams[i];
      var cameraName = camera.name;
      this._postProcesses[this._singleInstance ? 0 : cameraName].forEach(function(postProcess) {
        camera.detachPostProcess(postProcess);
      });
    }
  };
  PostProcessRenderEffect2.prototype.getPostProcesses = function(camera) {
    if (this._singleInstance) {
      return this._postProcesses[0];
    } else {
      if (!camera) {
        return null;
      }
      return this._postProcesses[camera.name];
    }
  };
  return PostProcessRenderEffect2;
}();

// node_modules/@babylonjs/core/Shaders/extractHighlights.fragment.js
var name54 = "extractHighlightsPixelShader";
var shader54 = "#include<helperFunctions>\n\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform float threshold;\nuniform float exposure;\nvoid main(void)\n{\ngl_FragColor=texture2D(textureSampler,vUV);\nfloat luma=getLuminance(gl_FragColor.rgb*exposure);\ngl_FragColor.rgb=step(threshold,luma)*gl_FragColor.rgb;\n}";
Effect.ShadersStore[name54] = shader54;

// node_modules/@babylonjs/core/PostProcesses/extractHighlightsPostProcess.js
var ExtractHighlightsPostProcess = function(_super) {
  __extends(ExtractHighlightsPostProcess2, _super);
  function ExtractHighlightsPostProcess2(name98, options, camera, samplingMode, engine, reusable, textureType, blockCompilation) {
    if (textureType === void 0) {
      textureType = 0;
    }
    if (blockCompilation === void 0) {
      blockCompilation = false;
    }
    var _this = _super.call(this, name98, "extractHighlights", ["threshold", "exposure"], null, options, camera, samplingMode, engine, reusable, null, textureType, void 0, null, blockCompilation) || this;
    _this.threshold = 0.9;
    _this._exposure = 1;
    _this._inputPostProcess = null;
    _this.onApplyObservable.add(function(effect) {
      if (_this._inputPostProcess) {
        effect.setTextureFromPostProcess("textureSampler", _this._inputPostProcess);
      }
      effect.setFloat("threshold", Math.pow(_this.threshold, ToGammaSpace));
      effect.setFloat("exposure", _this._exposure);
    });
    return _this;
  }
  ExtractHighlightsPostProcess2.prototype.getClassName = function() {
    return "ExtractHighlightsPostProcess";
  };
  __decorate([
    serialize()
  ], ExtractHighlightsPostProcess2.prototype, "threshold", void 0);
  return ExtractHighlightsPostProcess2;
}(PostProcess);
_TypeStore.RegisteredTypes["BABYLON.ExtractHighlightsPostProcess"] = ExtractHighlightsPostProcess;

// node_modules/@babylonjs/core/Shaders/bloomMerge.fragment.js
var name55 = "bloomMergePixelShader";
var shader55 = "uniform sampler2D textureSampler;\nuniform sampler2D bloomBlur;\nvarying vec2 vUV;\nuniform float bloomWeight;\nvoid main(void)\n{\ngl_FragColor=texture2D(textureSampler,vUV);\nvec3 blurred=texture2D(bloomBlur,vUV).rgb;\ngl_FragColor.rgb=gl_FragColor.rgb+(blurred.rgb*bloomWeight);\n}\n";
Effect.ShadersStore[name55] = shader55;

// node_modules/@babylonjs/core/PostProcesses/bloomMergePostProcess.js
var BloomMergePostProcess = function(_super) {
  __extends(BloomMergePostProcess2, _super);
  function BloomMergePostProcess2(name98, originalFromInput, blurred, weight, options, camera, samplingMode, engine, reusable, textureType, blockCompilation) {
    if (textureType === void 0) {
      textureType = 0;
    }
    if (blockCompilation === void 0) {
      blockCompilation = false;
    }
    var _this = _super.call(this, name98, "bloomMerge", ["bloomWeight"], ["circleOfConfusionSampler", "blurStep0", "blurStep1", "blurStep2", "bloomBlur"], options, camera, samplingMode, engine, reusable, null, textureType, void 0, null, true) || this;
    _this.weight = 1;
    _this.weight = weight;
    _this.onApplyObservable.add(function(effect) {
      effect.setTextureFromPostProcess("textureSampler", originalFromInput);
      effect.setTextureFromPostProcessOutput("bloomBlur", blurred);
      effect.setFloat("bloomWeight", _this.weight);
    });
    if (!blockCompilation) {
      _this.updateEffect();
    }
    return _this;
  }
  BloomMergePostProcess2.prototype.getClassName = function() {
    return "BloomMergePostProcess";
  };
  __decorate([
    serialize()
  ], BloomMergePostProcess2.prototype, "weight", void 0);
  return BloomMergePostProcess2;
}(PostProcess);
_TypeStore.RegisteredTypes["BABYLON.BloomMergePostProcess"] = BloomMergePostProcess;

// node_modules/@babylonjs/core/PostProcesses/bloomEffect.js
var BloomEffect = function(_super) {
  __extends(BloomEffect2, _super);
  function BloomEffect2(scene, bloomScale, bloomWeight, bloomKernel, pipelineTextureType, blockCompilation) {
    if (pipelineTextureType === void 0) {
      pipelineTextureType = 0;
    }
    if (blockCompilation === void 0) {
      blockCompilation = false;
    }
    var _this = _super.call(this, scene.getEngine(), "bloom", function() {
      return _this._effects;
    }, true) || this;
    _this.bloomScale = bloomScale;
    _this._effects = [];
    _this._downscale = new ExtractHighlightsPostProcess("highlights", 1, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);
    _this._blurX = new BlurPostProcess("horizontal blur", new Vector2(1, 0), 10, bloomScale, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, void 0, blockCompilation);
    _this._blurX.alwaysForcePOT = true;
    _this._blurX.autoClear = false;
    _this._blurY = new BlurPostProcess("vertical blur", new Vector2(0, 1), 10, bloomScale, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, void 0, blockCompilation);
    _this._blurY.alwaysForcePOT = true;
    _this._blurY.autoClear = false;
    _this.kernel = bloomKernel;
    _this._effects = [_this._downscale, _this._blurX, _this._blurY];
    _this._merge = new BloomMergePostProcess("bloomMerge", _this._downscale, _this._blurY, bloomWeight, bloomScale, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);
    _this._merge.autoClear = false;
    _this._effects.push(_this._merge);
    return _this;
  }
  Object.defineProperty(BloomEffect2.prototype, "threshold", {
    get: function() {
      return this._downscale.threshold;
    },
    set: function(value) {
      this._downscale.threshold = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BloomEffect2.prototype, "weight", {
    get: function() {
      return this._merge.weight;
    },
    set: function(value) {
      this._merge.weight = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BloomEffect2.prototype, "kernel", {
    get: function() {
      return this._blurX.kernel / this.bloomScale;
    },
    set: function(value) {
      this._blurX.kernel = value * this.bloomScale;
      this._blurY.kernel = value * this.bloomScale;
    },
    enumerable: false,
    configurable: true
  });
  BloomEffect2.prototype.disposeEffects = function(camera) {
    for (var effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {
      this._effects[effectIndex].dispose(camera);
    }
  };
  BloomEffect2.prototype._updateEffects = function() {
    for (var effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {
      this._effects[effectIndex].updateEffect();
    }
  };
  BloomEffect2.prototype._isReady = function() {
    for (var effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {
      if (!this._effects[effectIndex].isReady()) {
        return false;
      }
    }
    return true;
  };
  return BloomEffect2;
}(PostProcessRenderEffect);

// node_modules/@babylonjs/core/Shaders/chromaticAberration.fragment.js
var name56 = "chromaticAberrationPixelShader";
var shader56 = "\nuniform sampler2D textureSampler;\n\nuniform float chromatic_aberration;\nuniform float radialIntensity;\nuniform vec2 direction;\nuniform vec2 centerPosition;\nuniform float screen_width;\nuniform float screen_height;\n\nvarying vec2 vUV;\nvoid main(void)\n{\nvec2 centered_screen_pos=vec2(vUV.x-centerPosition.x,vUV.y-centerPosition.y);\nvec2 directionOfEffect=direction;\nif(directionOfEffect.x == 0. && directionOfEffect.y == 0.){\ndirectionOfEffect=normalize(centered_screen_pos);\n}\nfloat radius2=centered_screen_pos.x*centered_screen_pos.x\n+centered_screen_pos.y*centered_screen_pos.y;\nfloat radius=sqrt(radius2);\nvec4 original=texture2D(textureSampler,vUV);\n\nvec3 ref_indices=vec3(-0.3,0.0,0.3);\nfloat ref_shiftX=chromatic_aberration*pow(radius,radialIntensity)*directionOfEffect.x/screen_width;\nfloat ref_shiftY=chromatic_aberration*pow(radius,radialIntensity)*directionOfEffect.y/screen_height;\n\nvec2 ref_coords_r=vec2(vUV.x+ref_indices.r*ref_shiftX,vUV.y+ref_indices.r*ref_shiftY*0.5);\nvec2 ref_coords_g=vec2(vUV.x+ref_indices.g*ref_shiftX,vUV.y+ref_indices.g*ref_shiftY*0.5);\nvec2 ref_coords_b=vec2(vUV.x+ref_indices.b*ref_shiftX,vUV.y+ref_indices.b*ref_shiftY*0.5);\noriginal.r=texture2D(textureSampler,ref_coords_r).r;\noriginal.g=texture2D(textureSampler,ref_coords_g).g;\noriginal.b=texture2D(textureSampler,ref_coords_b).b;\noriginal.a=clamp(texture2D(textureSampler,ref_coords_r).a+texture2D(textureSampler,ref_coords_g).a+texture2D(textureSampler,ref_coords_b).a,0.,1.);\ngl_FragColor=original;\n}";
Effect.ShadersStore[name56] = shader56;

// node_modules/@babylonjs/core/PostProcesses/chromaticAberrationPostProcess.js
var ChromaticAberrationPostProcess = function(_super) {
  __extends(ChromaticAberrationPostProcess2, _super);
  function ChromaticAberrationPostProcess2(name98, screenWidth, screenHeight, options, camera, samplingMode, engine, reusable, textureType, blockCompilation) {
    if (textureType === void 0) {
      textureType = 0;
    }
    if (blockCompilation === void 0) {
      blockCompilation = false;
    }
    var _this = _super.call(this, name98, "chromaticAberration", ["chromatic_aberration", "screen_width", "screen_height", "direction", "radialIntensity", "centerPosition"], [], options, camera, samplingMode, engine, reusable, null, textureType, void 0, null, blockCompilation) || this;
    _this.aberrationAmount = 30;
    _this.radialIntensity = 0;
    _this.direction = new Vector2(0.707, 0.707);
    _this.centerPosition = new Vector2(0.5, 0.5);
    _this.screenWidth = screenWidth;
    _this.screenHeight = screenHeight;
    _this.onApplyObservable.add(function(effect) {
      effect.setFloat("chromatic_aberration", _this.aberrationAmount);
      effect.setFloat("screen_width", screenWidth);
      effect.setFloat("screen_height", screenHeight);
      effect.setFloat("radialIntensity", _this.radialIntensity);
      effect.setFloat2("direction", _this.direction.x, _this.direction.y);
      effect.setFloat2("centerPosition", _this.centerPosition.x, _this.centerPosition.y);
    });
    return _this;
  }
  ChromaticAberrationPostProcess2.prototype.getClassName = function() {
    return "ChromaticAberrationPostProcess";
  };
  ChromaticAberrationPostProcess2._Parse = function(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(function() {
      return new ChromaticAberrationPostProcess2(parsedPostProcess.name, parsedPostProcess.screenWidth, parsedPostProcess.screenHeight, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable, parsedPostProcess.textureType, false);
    }, parsedPostProcess, scene, rootUrl);
  };
  __decorate([
    serialize()
  ], ChromaticAberrationPostProcess2.prototype, "aberrationAmount", void 0);
  __decorate([
    serialize()
  ], ChromaticAberrationPostProcess2.prototype, "radialIntensity", void 0);
  __decorate([
    serialize()
  ], ChromaticAberrationPostProcess2.prototype, "direction", void 0);
  __decorate([
    serialize()
  ], ChromaticAberrationPostProcess2.prototype, "centerPosition", void 0);
  __decorate([
    serialize()
  ], ChromaticAberrationPostProcess2.prototype, "screenWidth", void 0);
  __decorate([
    serialize()
  ], ChromaticAberrationPostProcess2.prototype, "screenHeight", void 0);
  return ChromaticAberrationPostProcess2;
}(PostProcess);
_TypeStore.RegisteredTypes["BABYLON.ChromaticAberrationPostProcess"] = ChromaticAberrationPostProcess;

// node_modules/@babylonjs/core/Shaders/circleOfConfusion.fragment.js
var name57 = "circleOfConfusionPixelShader";
var shader57 = "\nuniform sampler2D depthSampler;\n\nvarying vec2 vUV;\n\nuniform vec2 cameraMinMaxZ;\n\nuniform float focusDistance;\nuniform float cocPrecalculation;\nvoid main(void)\n{\nfloat depth=texture2D(depthSampler,vUV).r;\nfloat pixelDistance=(cameraMinMaxZ.x+(cameraMinMaxZ.y-cameraMinMaxZ.x)*depth)*1000.0;\nfloat coc=abs(cocPrecalculation* ((focusDistance-pixelDistance)/pixelDistance));\ncoc=clamp(coc,0.0,1.0);\ngl_FragColor=vec4(coc,depth,coc,1.0);\n}\n";
Effect.ShadersStore[name57] = shader57;

// node_modules/@babylonjs/core/PostProcesses/circleOfConfusionPostProcess.js
var CircleOfConfusionPostProcess = function(_super) {
  __extends(CircleOfConfusionPostProcess2, _super);
  function CircleOfConfusionPostProcess2(name98, depthTexture, options, camera, samplingMode, engine, reusable, textureType, blockCompilation) {
    if (textureType === void 0) {
      textureType = 0;
    }
    if (blockCompilation === void 0) {
      blockCompilation = false;
    }
    var _this = _super.call(this, name98, "circleOfConfusion", ["cameraMinMaxZ", "focusDistance", "cocPrecalculation"], ["depthSampler"], options, camera, samplingMode, engine, reusable, null, textureType, void 0, null, blockCompilation) || this;
    _this.lensSize = 50;
    _this.fStop = 1.4;
    _this.focusDistance = 2e3;
    _this.focalLength = 50;
    _this._depthTexture = null;
    _this._depthTexture = depthTexture;
    _this.onApplyObservable.add(function(effect) {
      if (!_this._depthTexture) {
        Logger.Warn("No depth texture set on CircleOfConfusionPostProcess");
        return;
      }
      effect.setTexture("depthSampler", _this._depthTexture);
      var aperture = _this.lensSize / _this.fStop;
      var cocPrecalculation = aperture * _this.focalLength / (_this.focusDistance - _this.focalLength);
      effect.setFloat("focusDistance", _this.focusDistance);
      effect.setFloat("cocPrecalculation", cocPrecalculation);
      effect.setFloat2("cameraMinMaxZ", _this._depthTexture.activeCamera.minZ, _this._depthTexture.activeCamera.maxZ);
    });
    return _this;
  }
  CircleOfConfusionPostProcess2.prototype.getClassName = function() {
    return "CircleOfConfusionPostProcess";
  };
  Object.defineProperty(CircleOfConfusionPostProcess2.prototype, "depthTexture", {
    set: function(value) {
      this._depthTexture = value;
    },
    enumerable: false,
    configurable: true
  });
  __decorate([
    serialize()
  ], CircleOfConfusionPostProcess2.prototype, "lensSize", void 0);
  __decorate([
    serialize()
  ], CircleOfConfusionPostProcess2.prototype, "fStop", void 0);
  __decorate([
    serialize()
  ], CircleOfConfusionPostProcess2.prototype, "focusDistance", void 0);
  __decorate([
    serialize()
  ], CircleOfConfusionPostProcess2.prototype, "focalLength", void 0);
  return CircleOfConfusionPostProcess2;
}(PostProcess);
_TypeStore.RegisteredTypes["BABYLON.CircleOfConfusionPostProcess"] = CircleOfConfusionPostProcess;

// node_modules/@babylonjs/core/Shaders/colorCorrection.fragment.js
var name58 = "colorCorrectionPixelShader";
var shader58 = "\nuniform sampler2D textureSampler;\nuniform sampler2D colorTable;\n\nvarying vec2 vUV;\n\nconst float SLICE_COUNT=16.0;\n\nvec4 sampleAs3DTexture(sampler2D textureSampler,vec3 uv,float width) {\nfloat sliceSize=1.0/width;\nfloat slicePixelSize=sliceSize/width;\nfloat sliceInnerSize=slicePixelSize*(width-1.0);\nfloat zSlice0=min(floor(uv.z*width),width-1.0);\nfloat zSlice1=min(zSlice0+1.0,width-1.0);\nfloat xOffset=slicePixelSize*0.5+uv.x*sliceInnerSize;\nfloat s0=xOffset+(zSlice0*sliceSize);\nfloat s1=xOffset+(zSlice1*sliceSize);\nvec4 slice0Color=texture2D(textureSampler,vec2(s0,uv.y));\nvec4 slice1Color=texture2D(textureSampler,vec2(s1,uv.y));\nfloat zOffset=mod(uv.z*width,1.0);\nvec4 result=mix(slice0Color,slice1Color,zOffset);\nreturn result;\n}\nvoid main(void)\n{\nvec4 screen_color=texture2D(textureSampler,vUV);\ngl_FragColor=sampleAs3DTexture(colorTable,screen_color.rgb,SLICE_COUNT);\n}";
Effect.ShadersStore[name58] = shader58;

// node_modules/@babylonjs/core/PostProcesses/colorCorrectionPostProcess.js
var ColorCorrectionPostProcess = function(_super) {
  __extends(ColorCorrectionPostProcess2, _super);
  function ColorCorrectionPostProcess2(name98, colorTableUrl, options, camera, samplingMode, engine, reusable) {
    var _this = _super.call(this, name98, "colorCorrection", null, ["colorTable"], options, camera, samplingMode, engine, reusable) || this;
    _this._colorTableTexture = new Texture(colorTableUrl, camera.getScene(), true, false, Texture.TRILINEAR_SAMPLINGMODE);
    _this._colorTableTexture.anisotropicFilteringLevel = 1;
    _this._colorTableTexture.wrapU = Texture.CLAMP_ADDRESSMODE;
    _this._colorTableTexture.wrapV = Texture.CLAMP_ADDRESSMODE;
    _this.colorTableUrl = colorTableUrl;
    _this.onApply = function(effect) {
      effect.setTexture("colorTable", _this._colorTableTexture);
    };
    return _this;
  }
  ColorCorrectionPostProcess2.prototype.getClassName = function() {
    return "ColorCorrectionPostProcess";
  };
  ColorCorrectionPostProcess2._Parse = function(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(function() {
      return new ColorCorrectionPostProcess2(parsedPostProcess.name, parsedPostProcess.colorTableUrl, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable);
    }, parsedPostProcess, scene, rootUrl);
  };
  __decorate([
    serialize()
  ], ColorCorrectionPostProcess2.prototype, "colorTableUrl", void 0);
  return ColorCorrectionPostProcess2;
}(PostProcess);
_TypeStore.RegisteredTypes["BABYLON.ColorCorrectionPostProcess"] = ColorCorrectionPostProcess;

// node_modules/@babylonjs/core/Shaders/convolution.fragment.js
var name59 = "convolutionPixelShader";
var shader59 = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform vec2 screenSize;\nuniform float kernel[9];\nvoid main(void)\n{\nvec2 onePixel=vec2(1.0,1.0)/screenSize;\nvec4 colorSum =\ntexture2D(textureSampler,vUV+onePixel*vec2(-1,-1))*kernel[0] +\ntexture2D(textureSampler,vUV+onePixel*vec2(0,-1))*kernel[1] +\ntexture2D(textureSampler,vUV+onePixel*vec2(1,-1))*kernel[2] +\ntexture2D(textureSampler,vUV+onePixel*vec2(-1,0))*kernel[3] +\ntexture2D(textureSampler,vUV+onePixel*vec2(0,0))*kernel[4] +\ntexture2D(textureSampler,vUV+onePixel*vec2(1,0))*kernel[5] +\ntexture2D(textureSampler,vUV+onePixel*vec2(-1,1))*kernel[6] +\ntexture2D(textureSampler,vUV+onePixel*vec2(0,1))*kernel[7] +\ntexture2D(textureSampler,vUV+onePixel*vec2(1,1))*kernel[8];\nfloat kernelWeight =\nkernel[0] +\nkernel[1] +\nkernel[2] +\nkernel[3] +\nkernel[4] +\nkernel[5] +\nkernel[6] +\nkernel[7] +\nkernel[8];\nif (kernelWeight<=0.0) {\nkernelWeight=1.0;\n}\ngl_FragColor=vec4((colorSum/kernelWeight).rgb,1);\n}";
Effect.ShadersStore[name59] = shader59;

// node_modules/@babylonjs/core/PostProcesses/convolutionPostProcess.js
var ConvolutionPostProcess = function(_super) {
  __extends(ConvolutionPostProcess2, _super);
  function ConvolutionPostProcess2(name98, kernel, options, camera, samplingMode, engine, reusable, textureType) {
    if (textureType === void 0) {
      textureType = 0;
    }
    var _this = _super.call(this, name98, "convolution", ["kernel", "screenSize"], null, options, camera, samplingMode, engine, reusable, null, textureType) || this;
    _this.kernel = kernel;
    _this.onApply = function(effect) {
      effect.setFloat2("screenSize", _this.width, _this.height);
      effect.setArray("kernel", _this.kernel);
    };
    return _this;
  }
  ConvolutionPostProcess2.prototype.getClassName = function() {
    return "ConvolutionPostProcess";
  };
  ConvolutionPostProcess2._Parse = function(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(function() {
      return new ConvolutionPostProcess2(parsedPostProcess.name, parsedPostProcess.kernel, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable, parsedPostProcess.textureType);
    }, parsedPostProcess, scene, rootUrl);
  };
  ConvolutionPostProcess2.EdgeDetect0Kernel = [1, 0, -1, 0, 0, 0, -1, 0, 1];
  ConvolutionPostProcess2.EdgeDetect1Kernel = [0, 1, 0, 1, -4, 1, 0, 1, 0];
  ConvolutionPostProcess2.EdgeDetect2Kernel = [-1, -1, -1, -1, 8, -1, -1, -1, -1];
  ConvolutionPostProcess2.SharpenKernel = [0, -1, 0, -1, 5, -1, 0, -1, 0];
  ConvolutionPostProcess2.EmbossKernel = [-2, -1, 0, -1, 1, 1, 0, 1, 2];
  ConvolutionPostProcess2.GaussianKernel = [0, 1, 0, 1, 1, 1, 0, 1, 0];
  __decorate([
    serialize()
  ], ConvolutionPostProcess2.prototype, "kernel", void 0);
  return ConvolutionPostProcess2;
}(PostProcess);
_TypeStore.RegisteredTypes["BABYLON.ConvolutionPostProcess"] = ConvolutionPostProcess;

// node_modules/@babylonjs/core/PostProcesses/depthOfFieldBlurPostProcess.js
var DepthOfFieldBlurPostProcess = function(_super) {
  __extends(DepthOfFieldBlurPostProcess2, _super);
  function DepthOfFieldBlurPostProcess2(name98, scene, direction, kernel, options, camera, circleOfConfusion, imageToBlur, samplingMode, engine, reusable, textureType, blockCompilation) {
    if (imageToBlur === void 0) {
      imageToBlur = null;
    }
    if (samplingMode === void 0) {
      samplingMode = Texture.BILINEAR_SAMPLINGMODE;
    }
    if (textureType === void 0) {
      textureType = 0;
    }
    if (blockCompilation === void 0) {
      blockCompilation = false;
    }
    var _this = _super.call(this, name98, direction, kernel, options, camera, samplingMode = 2, engine, reusable, textureType = 0, "#define DOF 1\r\n", blockCompilation) || this;
    _this.direction = direction;
    _this.onApplyObservable.add(function(effect) {
      if (imageToBlur != null) {
        effect.setTextureFromPostProcess("textureSampler", imageToBlur);
      }
      effect.setTextureFromPostProcessOutput("circleOfConfusionSampler", circleOfConfusion);
      if (scene.activeCamera) {
        effect.setFloat2("cameraMinMaxZ", scene.activeCamera.minZ, scene.activeCamera.maxZ);
      }
    });
    return _this;
  }
  DepthOfFieldBlurPostProcess2.prototype.getClassName = function() {
    return "DepthOfFieldBlurPostProcess";
  };
  __decorate([
    serialize()
  ], DepthOfFieldBlurPostProcess2.prototype, "direction", void 0);
  return DepthOfFieldBlurPostProcess2;
}(BlurPostProcess);
_TypeStore.RegisteredTypes["BABYLON.DepthOfFieldBlurPostProcess"] = DepthOfFieldBlurPostProcess;

// node_modules/@babylonjs/core/Shaders/depthOfFieldMerge.fragment.js
var name60 = "depthOfFieldMergePixelShader";
var shader60 = "uniform sampler2D textureSampler;\nvarying vec2 vUV;\nuniform sampler2D circleOfConfusionSampler;\nuniform sampler2D blurStep0;\n#if BLUR_LEVEL>0\nuniform sampler2D blurStep1;\n#endif\n#if BLUR_LEVEL>1\nuniform sampler2D blurStep2;\n#endif\nvoid main(void)\n{\nfloat coc=texture2D(circleOfConfusionSampler,vUV).r;\n#if BLUR_LEVEL == 0\nvec4 original=texture2D(textureSampler,vUV);\nvec4 blurred0=texture2D(blurStep0,vUV);\ngl_FragColor=mix(original,blurred0,coc);\n#endif\n#if BLUR_LEVEL == 1\nif(coc<0.5){\nvec4 original=texture2D(textureSampler,vUV);\nvec4 blurred1=texture2D(blurStep1,vUV);\ngl_FragColor=mix(original,blurred1,coc/0.5);\n}else{\nvec4 blurred0=texture2D(blurStep0,vUV);\nvec4 blurred1=texture2D(blurStep1,vUV);\ngl_FragColor=mix(blurred1,blurred0,(coc-0.5)/0.5);\n}\n#endif\n#if BLUR_LEVEL == 2\nif(coc<0.33){\nvec4 original=texture2D(textureSampler,vUV);\nvec4 blurred2=texture2D(blurStep2,vUV);\ngl_FragColor=mix(original,blurred2,coc/0.33);\n}else if(coc<0.66){\nvec4 blurred1=texture2D(blurStep1,vUV);\nvec4 blurred2=texture2D(blurStep2,vUV);\ngl_FragColor=mix(blurred2,blurred1,(coc-0.33)/0.33);\n}else{\nvec4 blurred0=texture2D(blurStep0,vUV);\nvec4 blurred1=texture2D(blurStep1,vUV);\ngl_FragColor=mix(blurred1,blurred0,(coc-0.66)/0.34);\n}\n#endif\n}\n";
Effect.ShadersStore[name60] = shader60;

// node_modules/@babylonjs/core/PostProcesses/depthOfFieldMergePostProcess.js
var DepthOfFieldMergePostProcessOptions = function() {
  function DepthOfFieldMergePostProcessOptions2() {
  }
  return DepthOfFieldMergePostProcessOptions2;
}();
var DepthOfFieldMergePostProcess = function(_super) {
  __extends(DepthOfFieldMergePostProcess2, _super);
  function DepthOfFieldMergePostProcess2(name98, originalFromInput, circleOfConfusion, blurSteps, options, camera, samplingMode, engine, reusable, textureType, blockCompilation) {
    if (textureType === void 0) {
      textureType = 0;
    }
    if (blockCompilation === void 0) {
      blockCompilation = false;
    }
    var _this = _super.call(this, name98, "depthOfFieldMerge", [], ["circleOfConfusionSampler", "blurStep0", "blurStep1", "blurStep2"], options, camera, samplingMode, engine, reusable, null, textureType, void 0, null, true) || this;
    _this.blurSteps = blurSteps;
    _this.onApplyObservable.add(function(effect) {
      effect.setTextureFromPostProcess("textureSampler", originalFromInput);
      effect.setTextureFromPostProcessOutput("circleOfConfusionSampler", circleOfConfusion);
      blurSteps.forEach(function(step, index) {
        effect.setTextureFromPostProcessOutput("blurStep" + (blurSteps.length - index - 1), step);
      });
    });
    if (!blockCompilation) {
      _this.updateEffect();
    }
    return _this;
  }
  DepthOfFieldMergePostProcess2.prototype.getClassName = function() {
    return "DepthOfFieldMergePostProcess";
  };
  DepthOfFieldMergePostProcess2.prototype.updateEffect = function(defines, uniforms, samplers, indexParameters, onCompiled, onError) {
    if (defines === void 0) {
      defines = null;
    }
    if (uniforms === void 0) {
      uniforms = null;
    }
    if (samplers === void 0) {
      samplers = null;
    }
    if (!defines) {
      defines = "";
      defines += "#define BLUR_LEVEL " + (this.blurSteps.length - 1) + "\n";
    }
    _super.prototype.updateEffect.call(this, defines, uniforms, samplers, indexParameters, onCompiled, onError);
  };
  return DepthOfFieldMergePostProcess2;
}(PostProcess);

// node_modules/@babylonjs/core/PostProcesses/depthOfFieldEffect.js
var DepthOfFieldEffectBlurLevel;
(function(DepthOfFieldEffectBlurLevel2) {
  DepthOfFieldEffectBlurLevel2[DepthOfFieldEffectBlurLevel2["Low"] = 0] = "Low";
  DepthOfFieldEffectBlurLevel2[DepthOfFieldEffectBlurLevel2["Medium"] = 1] = "Medium";
  DepthOfFieldEffectBlurLevel2[DepthOfFieldEffectBlurLevel2["High"] = 2] = "High";
})(DepthOfFieldEffectBlurLevel || (DepthOfFieldEffectBlurLevel = {}));
var DepthOfFieldEffect = function(_super) {
  __extends(DepthOfFieldEffect2, _super);
  function DepthOfFieldEffect2(scene, depthTexture, blurLevel, pipelineTextureType, blockCompilation) {
    if (blurLevel === void 0) {
      blurLevel = DepthOfFieldEffectBlurLevel.Low;
    }
    if (pipelineTextureType === void 0) {
      pipelineTextureType = 0;
    }
    if (blockCompilation === void 0) {
      blockCompilation = false;
    }
    var _this = _super.call(this, scene.getEngine(), "depth of field", function() {
      return _this._effects;
    }, true) || this;
    _this._effects = [];
    _this._circleOfConfusion = new CircleOfConfusionPostProcess("circleOfConfusion", depthTexture, 1, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);
    _this._depthOfFieldBlurY = [];
    _this._depthOfFieldBlurX = [];
    var blurCount = 1;
    var kernelSize = 15;
    switch (blurLevel) {
      case DepthOfFieldEffectBlurLevel.High: {
        blurCount = 3;
        kernelSize = 51;
        break;
      }
      case DepthOfFieldEffectBlurLevel.Medium: {
        blurCount = 2;
        kernelSize = 31;
        break;
      }
      default: {
        kernelSize = 15;
        blurCount = 1;
        break;
      }
    }
    var adjustedKernelSize = kernelSize / Math.pow(2, blurCount - 1);
    var ratio = 1;
    for (var i = 0; i < blurCount; i++) {
      var blurY = new DepthOfFieldBlurPostProcess("verticle blur", scene, new Vector2(0, 1), adjustedKernelSize, ratio, null, _this._circleOfConfusion, i == 0 ? _this._circleOfConfusion : null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);
      blurY.autoClear = false;
      ratio = 0.75 / Math.pow(2, i);
      var blurX = new DepthOfFieldBlurPostProcess("horizontal blur", scene, new Vector2(1, 0), adjustedKernelSize, ratio, null, _this._circleOfConfusion, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);
      blurX.autoClear = false;
      _this._depthOfFieldBlurY.push(blurY);
      _this._depthOfFieldBlurX.push(blurX);
    }
    _this._effects = [_this._circleOfConfusion];
    for (var i = 0; i < _this._depthOfFieldBlurX.length; i++) {
      _this._effects.push(_this._depthOfFieldBlurY[i]);
      _this._effects.push(_this._depthOfFieldBlurX[i]);
    }
    _this._dofMerge = new DepthOfFieldMergePostProcess("dofMerge", _this._circleOfConfusion, _this._circleOfConfusion, _this._depthOfFieldBlurX, ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);
    _this._dofMerge.autoClear = false;
    _this._effects.push(_this._dofMerge);
    return _this;
  }
  Object.defineProperty(DepthOfFieldEffect2.prototype, "focalLength", {
    get: function() {
      return this._circleOfConfusion.focalLength;
    },
    set: function(value) {
      this._circleOfConfusion.focalLength = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DepthOfFieldEffect2.prototype, "fStop", {
    get: function() {
      return this._circleOfConfusion.fStop;
    },
    set: function(value) {
      this._circleOfConfusion.fStop = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DepthOfFieldEffect2.prototype, "focusDistance", {
    get: function() {
      return this._circleOfConfusion.focusDistance;
    },
    set: function(value) {
      this._circleOfConfusion.focusDistance = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DepthOfFieldEffect2.prototype, "lensSize", {
    get: function() {
      return this._circleOfConfusion.lensSize;
    },
    set: function(value) {
      this._circleOfConfusion.lensSize = value;
    },
    enumerable: false,
    configurable: true
  });
  DepthOfFieldEffect2.prototype.getClassName = function() {
    return "DepthOfFieldEffect";
  };
  Object.defineProperty(DepthOfFieldEffect2.prototype, "depthTexture", {
    set: function(value) {
      this._circleOfConfusion.depthTexture = value;
    },
    enumerable: false,
    configurable: true
  });
  DepthOfFieldEffect2.prototype.disposeEffects = function(camera) {
    for (var effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {
      this._effects[effectIndex].dispose(camera);
    }
  };
  DepthOfFieldEffect2.prototype._updateEffects = function() {
    for (var effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {
      this._effects[effectIndex].updateEffect();
    }
  };
  DepthOfFieldEffect2.prototype._isReady = function() {
    for (var effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {
      if (!this._effects[effectIndex].isReady()) {
        return false;
      }
    }
    return true;
  };
  return DepthOfFieldEffect2;
}(PostProcessRenderEffect);

// node_modules/@babylonjs/core/Shaders/displayPass.fragment.js
var name61 = "displayPassPixelShader";
var shader61 = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform sampler2D passSampler;\nvoid main(void)\n{\ngl_FragColor=texture2D(passSampler,vUV);\n}";
Effect.ShadersStore[name61] = shader61;

// node_modules/@babylonjs/core/PostProcesses/displayPassPostProcess.js
var DisplayPassPostProcess = function(_super) {
  __extends(DisplayPassPostProcess2, _super);
  function DisplayPassPostProcess2(name98, options, camera, samplingMode, engine, reusable) {
    return _super.call(this, name98, "displayPass", ["passSampler"], ["passSampler"], options, camera, samplingMode, engine, reusable) || this;
  }
  DisplayPassPostProcess2.prototype.getClassName = function() {
    return "DisplayPassPostProcess";
  };
  DisplayPassPostProcess2._Parse = function(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(function() {
      return new DisplayPassPostProcess2(parsedPostProcess.name, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable);
    }, parsedPostProcess, scene, rootUrl);
  };
  return DisplayPassPostProcess2;
}(PostProcess);
_TypeStore.RegisteredTypes["BABYLON.DisplayPassPostProcess"] = DisplayPassPostProcess;

// node_modules/@babylonjs/core/Shaders/filter.fragment.js
var name62 = "filterPixelShader";
var shader62 = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform mat4 kernelMatrix;\nvoid main(void)\n{\nvec3 baseColor=texture2D(textureSampler,vUV).rgb;\nvec3 updatedColor=(kernelMatrix*vec4(baseColor,1.0)).rgb;\ngl_FragColor=vec4(updatedColor,1.0);\n}";
Effect.ShadersStore[name62] = shader62;

// node_modules/@babylonjs/core/PostProcesses/filterPostProcess.js
var FilterPostProcess = function(_super) {
  __extends(FilterPostProcess2, _super);
  function FilterPostProcess2(name98, kernelMatrix, options, camera, samplingMode, engine, reusable) {
    var _this = _super.call(this, name98, "filter", ["kernelMatrix"], null, options, camera, samplingMode, engine, reusable) || this;
    _this.kernelMatrix = kernelMatrix;
    _this.onApply = function(effect) {
      effect.setMatrix("kernelMatrix", _this.kernelMatrix);
    };
    return _this;
  }
  FilterPostProcess2.prototype.getClassName = function() {
    return "FilterPostProcess";
  };
  FilterPostProcess2._Parse = function(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(function() {
      return new FilterPostProcess2(parsedPostProcess.name, parsedPostProcess.kernelMatrix, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable);
    }, parsedPostProcess, scene, rootUrl);
  };
  __decorate([
    serializeAsMatrix()
  ], FilterPostProcess2.prototype, "kernelMatrix", void 0);
  return FilterPostProcess2;
}(PostProcess);
_TypeStore.RegisteredTypes["BABYLON.FilterPostProcess"] = FilterPostProcess;

// node_modules/@babylonjs/core/Shaders/fxaa.fragment.js
var name63 = "fxaaPixelShader";
var shader63 = "uniform sampler2D textureSampler;\nuniform vec2 texelSize;\nvarying vec2 vUV;\nvarying vec2 sampleCoordS;\nvarying vec2 sampleCoordE;\nvarying vec2 sampleCoordN;\nvarying vec2 sampleCoordW;\nvarying vec2 sampleCoordNW;\nvarying vec2 sampleCoordSE;\nvarying vec2 sampleCoordNE;\nvarying vec2 sampleCoordSW;\nconst float fxaaQualitySubpix=1.0;\nconst float fxaaQualityEdgeThreshold=0.166;\nconst float fxaaQualityEdgeThresholdMin=0.0833;\nconst vec3 kLumaCoefficients=vec3(0.2126,0.7152,0.0722);\n#define FxaaLuma(rgba) dot(rgba.rgb,kLumaCoefficients)\nvoid main(){\nvec2 posM;\nposM.x=vUV.x;\nposM.y=vUV.y;\nvec4 rgbyM=texture2D(textureSampler,vUV,0.0);\nfloat lumaM=FxaaLuma(rgbyM);\nfloat lumaS=FxaaLuma(texture2D(textureSampler,sampleCoordS,0.0));\nfloat lumaE=FxaaLuma(texture2D(textureSampler,sampleCoordE,0.0));\nfloat lumaN=FxaaLuma(texture2D(textureSampler,sampleCoordN,0.0));\nfloat lumaW=FxaaLuma(texture2D(textureSampler,sampleCoordW,0.0));\nfloat maxSM=max(lumaS,lumaM);\nfloat minSM=min(lumaS,lumaM);\nfloat maxESM=max(lumaE,maxSM);\nfloat minESM=min(lumaE,minSM);\nfloat maxWN=max(lumaN,lumaW);\nfloat minWN=min(lumaN,lumaW);\nfloat rangeMax=max(maxWN,maxESM);\nfloat rangeMin=min(minWN,minESM);\nfloat rangeMaxScaled=rangeMax*fxaaQualityEdgeThreshold;\nfloat range=rangeMax-rangeMin;\nfloat rangeMaxClamped=max(fxaaQualityEdgeThresholdMin,rangeMaxScaled);\n#ifndef MALI\nif(range<rangeMaxClamped)\n{\ngl_FragColor=rgbyM;\nreturn;\n}\n#endif\nfloat lumaNW=FxaaLuma(texture2D(textureSampler,sampleCoordNW,0.0));\nfloat lumaSE=FxaaLuma(texture2D(textureSampler,sampleCoordSE,0.0));\nfloat lumaNE=FxaaLuma(texture2D(textureSampler,sampleCoordNE,0.0));\nfloat lumaSW=FxaaLuma(texture2D(textureSampler,sampleCoordSW,0.0));\nfloat lumaNS=lumaN+lumaS;\nfloat lumaWE=lumaW+lumaE;\nfloat subpixRcpRange=1.0/range;\nfloat subpixNSWE=lumaNS+lumaWE;\nfloat edgeHorz1=(-2.0*lumaM)+lumaNS;\nfloat edgeVert1=(-2.0*lumaM)+lumaWE;\nfloat lumaNESE=lumaNE+lumaSE;\nfloat lumaNWNE=lumaNW+lumaNE;\nfloat edgeHorz2=(-2.0*lumaE)+lumaNESE;\nfloat edgeVert2=(-2.0*lumaN)+lumaNWNE;\nfloat lumaNWSW=lumaNW+lumaSW;\nfloat lumaSWSE=lumaSW+lumaSE;\nfloat edgeHorz4=(abs(edgeHorz1)*2.0)+abs(edgeHorz2);\nfloat edgeVert4=(abs(edgeVert1)*2.0)+abs(edgeVert2);\nfloat edgeHorz3=(-2.0*lumaW)+lumaNWSW;\nfloat edgeVert3=(-2.0*lumaS)+lumaSWSE;\nfloat edgeHorz=abs(edgeHorz3)+edgeHorz4;\nfloat edgeVert=abs(edgeVert3)+edgeVert4;\nfloat subpixNWSWNESE=lumaNWSW+lumaNESE;\nfloat lengthSign=texelSize.x;\nbool horzSpan=edgeHorz>=edgeVert;\nfloat subpixA=subpixNSWE*2.0+subpixNWSWNESE;\nif (!horzSpan)\n{\nlumaN=lumaW;\n}\nif (!horzSpan)\n{\nlumaS=lumaE;\n}\nif (horzSpan)\n{\nlengthSign=texelSize.y;\n}\nfloat subpixB=(subpixA*(1.0/12.0))-lumaM;\nfloat gradientN=lumaN-lumaM;\nfloat gradientS=lumaS-lumaM;\nfloat lumaNN=lumaN+lumaM;\nfloat lumaSS=lumaS+lumaM;\nbool pairN=abs(gradientN)>=abs(gradientS);\nfloat gradient=max(abs(gradientN),abs(gradientS));\nif (pairN)\n{\nlengthSign=-lengthSign;\n}\nfloat subpixC=clamp(abs(subpixB)*subpixRcpRange,0.0,1.0);\nvec2 posB;\nposB.x=posM.x;\nposB.y=posM.y;\nvec2 offNP;\noffNP.x=(!horzSpan) ? 0.0 : texelSize.x;\noffNP.y=(horzSpan) ? 0.0 : texelSize.y;\nif (!horzSpan)\n{\nposB.x+=lengthSign*0.5;\n}\nif (horzSpan)\n{\nposB.y+=lengthSign*0.5;\n}\nvec2 posN;\nposN.x=posB.x-offNP.x*1.5;\nposN.y=posB.y-offNP.y*1.5;\nvec2 posP;\nposP.x=posB.x+offNP.x*1.5;\nposP.y=posB.y+offNP.y*1.5;\nfloat subpixD=((-2.0)*subpixC)+3.0;\nfloat lumaEndN=FxaaLuma(texture2D(textureSampler,posN,0.0));\nfloat subpixE=subpixC*subpixC;\nfloat lumaEndP=FxaaLuma(texture2D(textureSampler,posP,0.0));\nif (!pairN)\n{\nlumaNN=lumaSS;\n}\nfloat gradientScaled=gradient*1.0/4.0;\nfloat lumaMM=lumaM-lumaNN*0.5;\nfloat subpixF=subpixD*subpixE;\nbool lumaMLTZero=lumaMM<0.0;\nlumaEndN-=lumaNN*0.5;\nlumaEndP-=lumaNN*0.5;\nbool doneN=abs(lumaEndN)>=gradientScaled;\nbool doneP=abs(lumaEndP)>=gradientScaled;\nif (!doneN)\n{\nposN.x-=offNP.x*3.0;\n}\nif (!doneN)\n{\nposN.y-=offNP.y*3.0;\n}\nbool doneNP=(!doneN) || (!doneP);\nif (!doneP)\n{\nposP.x+=offNP.x*3.0;\n}\nif (!doneP)\n{\nposP.y+=offNP.y*3.0;\n}\nif (doneNP)\n{\nif (!doneN) lumaEndN=FxaaLuma(texture2D(textureSampler,posN.xy,0.0));\nif (!doneP) lumaEndP=FxaaLuma(texture2D(textureSampler,posP.xy,0.0));\nif (!doneN) lumaEndN=lumaEndN-lumaNN*0.5;\nif (!doneP) lumaEndP=lumaEndP-lumaNN*0.5;\ndoneN=abs(lumaEndN)>=gradientScaled;\ndoneP=abs(lumaEndP)>=gradientScaled;\nif (!doneN) posN.x-=offNP.x*12.0;\nif (!doneN) posN.y-=offNP.y*12.0;\ndoneNP=(!doneN) || (!doneP);\nif (!doneP) posP.x+=offNP.x*12.0;\nif (!doneP) posP.y+=offNP.y*12.0;\n}\nfloat dstN=posM.x-posN.x;\nfloat dstP=posP.x-posM.x;\nif (!horzSpan)\n{\ndstN=posM.y-posN.y;\n}\nif (!horzSpan)\n{\ndstP=posP.y-posM.y;\n}\nbool goodSpanN=(lumaEndN<0.0) != lumaMLTZero;\nfloat spanLength=(dstP+dstN);\nbool goodSpanP=(lumaEndP<0.0) != lumaMLTZero;\nfloat spanLengthRcp=1.0/spanLength;\nbool directionN=dstN<dstP;\nfloat dst=min(dstN,dstP);\nbool goodSpan=directionN ? goodSpanN : goodSpanP;\nfloat subpixG=subpixF*subpixF;\nfloat pixelOffset=(dst*(-spanLengthRcp))+0.5;\nfloat subpixH=subpixG*fxaaQualitySubpix;\nfloat pixelOffsetGood=goodSpan ? pixelOffset : 0.0;\nfloat pixelOffsetSubpix=max(pixelOffsetGood,subpixH);\nif (!horzSpan)\n{\nposM.x+=pixelOffsetSubpix*lengthSign;\n}\nif (horzSpan)\n{\nposM.y+=pixelOffsetSubpix*lengthSign;\n}\n#ifdef MALI\nif(range<rangeMaxClamped)\n{\ngl_FragColor=rgbyM;\n}\nelse\n{\ngl_FragColor=texture2D(textureSampler,posM,0.0);\n}\n#else\ngl_FragColor=texture2D(textureSampler,posM,0.0);\n#endif\n}";
Effect.ShadersStore[name63] = shader63;

// node_modules/@babylonjs/core/Shaders/fxaa.vertex.js
var name64 = "fxaaVertexShader";
var shader64 = "\nattribute vec2 position;\nuniform vec2 texelSize;\n\nvarying vec2 vUV;\nvarying vec2 sampleCoordS;\nvarying vec2 sampleCoordE;\nvarying vec2 sampleCoordN;\nvarying vec2 sampleCoordW;\nvarying vec2 sampleCoordNW;\nvarying vec2 sampleCoordSE;\nvarying vec2 sampleCoordNE;\nvarying vec2 sampleCoordSW;\nconst vec2 madd=vec2(0.5,0.5);\nvoid main(void) {\nvUV=(position*madd+madd);\nsampleCoordS=vUV+vec2( 0.0,1.0)*texelSize;\nsampleCoordE=vUV+vec2( 1.0,0.0)*texelSize;\nsampleCoordN=vUV+vec2( 0.0,-1.0)*texelSize;\nsampleCoordW=vUV+vec2(-1.0,0.0)*texelSize;\nsampleCoordNW=vUV+vec2(-1.0,-1.0)*texelSize;\nsampleCoordSE=vUV+vec2( 1.0,1.0)*texelSize;\nsampleCoordNE=vUV+vec2( 1.0,-1.0)*texelSize;\nsampleCoordSW=vUV+vec2(-1.0,1.0)*texelSize;\ngl_Position=vec4(position,0.0,1.0);\n}";
Effect.ShadersStore[name64] = shader64;

// node_modules/@babylonjs/core/PostProcesses/fxaaPostProcess.js
var FxaaPostProcess = function(_super) {
  __extends(FxaaPostProcess2, _super);
  function FxaaPostProcess2(name98, options, camera, samplingMode, engine, reusable, textureType) {
    if (camera === void 0) {
      camera = null;
    }
    if (textureType === void 0) {
      textureType = 0;
    }
    var _this = _super.call(this, name98, "fxaa", ["texelSize"], null, options, camera, samplingMode || Texture.BILINEAR_SAMPLINGMODE, engine, reusable, null, textureType, "fxaa", void 0, true) || this;
    var defines = _this._getDefines();
    _this.updateEffect(defines);
    _this.onApplyObservable.add(function(effect) {
      var texelSize = _this.texelSize;
      effect.setFloat2("texelSize", texelSize.x, texelSize.y);
    });
    return _this;
  }
  FxaaPostProcess2.prototype.getClassName = function() {
    return "FxaaPostProcess";
  };
  FxaaPostProcess2.prototype._getDefines = function() {
    var engine = this.getEngine();
    if (!engine) {
      return null;
    }
    var glInfo = engine.getGlInfo();
    if (glInfo && glInfo.renderer && glInfo.renderer.toLowerCase().indexOf("mali") > -1) {
      return "#define MALI 1\n";
    }
    return null;
  };
  FxaaPostProcess2._Parse = function(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(function() {
      return new FxaaPostProcess2(parsedPostProcess.name, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable);
    }, parsedPostProcess, scene, rootUrl);
  };
  return FxaaPostProcess2;
}(PostProcess);
_TypeStore.RegisteredTypes["BABYLON.FxaaPostProcess"] = FxaaPostProcess;

// node_modules/@babylonjs/core/Shaders/grain.fragment.js
var name65 = "grainPixelShader";
var shader65 = "#include<helperFunctions>\n\nuniform sampler2D textureSampler;\n\nuniform float intensity;\nuniform float animatedSeed;\n\nvarying vec2 vUV;\nvoid main(void)\n{\ngl_FragColor=texture2D(textureSampler,vUV);\nvec2 seed=vUV*(animatedSeed);\nfloat grain=dither(seed,intensity);\n\nfloat lum=getLuminance(gl_FragColor.rgb);\nfloat grainAmount=(cos(-PI+(lum*PI*2.))+1.)/2.;\ngl_FragColor.rgb+=grain*grainAmount;\ngl_FragColor.rgb=max(gl_FragColor.rgb,0.0);\n}";
Effect.ShadersStore[name65] = shader65;

// node_modules/@babylonjs/core/PostProcesses/grainPostProcess.js
var GrainPostProcess = function(_super) {
  __extends(GrainPostProcess2, _super);
  function GrainPostProcess2(name98, options, camera, samplingMode, engine, reusable, textureType, blockCompilation) {
    if (textureType === void 0) {
      textureType = 0;
    }
    if (blockCompilation === void 0) {
      blockCompilation = false;
    }
    var _this = _super.call(this, name98, "grain", ["intensity", "animatedSeed"], [], options, camera, samplingMode, engine, reusable, null, textureType, void 0, null, blockCompilation) || this;
    _this.intensity = 30;
    _this.animated = false;
    _this.onApplyObservable.add(function(effect) {
      effect.setFloat("intensity", _this.intensity);
      effect.setFloat("animatedSeed", _this.animated ? Math.random() + 1 : 1);
    });
    return _this;
  }
  GrainPostProcess2.prototype.getClassName = function() {
    return "GrainPostProcess";
  };
  GrainPostProcess2._Parse = function(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(function() {
      return new GrainPostProcess2(parsedPostProcess.name, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable);
    }, parsedPostProcess, scene, rootUrl);
  };
  __decorate([
    serialize()
  ], GrainPostProcess2.prototype, "intensity", void 0);
  __decorate([
    serialize()
  ], GrainPostProcess2.prototype, "animated", void 0);
  return GrainPostProcess2;
}(PostProcess);
_TypeStore.RegisteredTypes["BABYLON.GrainPostProcess"] = GrainPostProcess;

// node_modules/@babylonjs/core/Shaders/highlights.fragment.js
var name66 = "highlightsPixelShader";
var shader66 = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nconst vec3 RGBLuminanceCoefficients=vec3(0.2126,0.7152,0.0722);\nvoid main(void)\n{\nvec4 tex=texture2D(textureSampler,vUV);\nvec3 c=tex.rgb;\nfloat luma=dot(c.rgb,RGBLuminanceCoefficients);\n\n\ngl_FragColor=vec4(pow(c,vec3(25.0-luma*15.0)),tex.a);\n}";
Effect.ShadersStore[name66] = shader66;

// node_modules/@babylonjs/core/PostProcesses/highlightsPostProcess.js
var HighlightsPostProcess = function(_super) {
  __extends(HighlightsPostProcess2, _super);
  function HighlightsPostProcess2(name98, options, camera, samplingMode, engine, reusable, textureType) {
    if (textureType === void 0) {
      textureType = 0;
    }
    return _super.call(this, name98, "highlights", null, null, options, camera, samplingMode, engine, reusable, null, textureType) || this;
  }
  HighlightsPostProcess2.prototype.getClassName = function() {
    return "HighlightsPostProcess";
  };
  return HighlightsPostProcess2;
}(PostProcess);

// node_modules/@babylonjs/core/Shaders/ShadersInclude/mrtFragmentDeclaration.js
var name67 = "mrtFragmentDeclaration";
var shader67 = "#if __VERSION__>=200\nlayout(location=0) out vec4 glFragData[{X}];\n#endif\n";
Effect.IncludesShadersStore[name67] = shader67;

// node_modules/@babylonjs/core/Shaders/geometry.fragment.js
var name68 = "geometryPixelShader";
var shader68 = "#extension GL_EXT_draw_buffers : require\n#if defined(BUMP) || !defined(NORMAL)\n#extension GL_OES_standard_derivatives : enable\n#endif\nprecision highp float;\nprecision highp int;\n#ifdef BUMP\nvarying mat4 vWorldView;\nvarying vec3 vNormalW;\n#else\nvarying vec3 vNormalV;\n#endif\nvarying vec4 vViewPos;\n#if defined(POSITION) || defined(BUMP)\nvarying vec3 vPositionW;\n#endif\n#ifdef VELOCITY\nvarying vec4 vCurrentPosition;\nvarying vec4 vPreviousPosition;\n#endif\n#ifdef NEED_UV\nvarying vec2 vUV;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform vec2 vTangentSpaceParams;\n#endif\n#ifdef REFLECTIVITY\nvarying vec2 vReflectivityUV;\nuniform sampler2D reflectivitySampler;\n#endif\n#ifdef ALPHATEST\nuniform sampler2D diffuseSampler;\n#endif\n#include<mrtFragmentDeclaration>[RENDER_TARGET_COUNT]\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\nvoid main() {\n#ifdef ALPHATEST\nif (texture2D(diffuseSampler,vUV).a<0.4)\ndiscard;\n#endif\nvec3 normalOutput;\n#ifdef BUMP\nvec3 normalW=normalize(vNormalW);\n#include<bumpFragment>\nnormalOutput=normalize(vec3(vWorldView*vec4(normalW,0.0)));\n#else\nnormalOutput=normalize(vNormalV);\n#endif\n#ifdef PREPASS\n#ifdef PREPASS_DEPTHNORMAL\ngl_FragData[DEPTHNORMAL_INDEX]=vec4(vViewPos.z/vViewPos.w,normalOutput);\n#endif\n#else\ngl_FragData[0]=vec4(vViewPos.z/vViewPos.w,0.0,0.0,1.0);\ngl_FragData[1]=vec4(normalOutput,1.0);\n#endif\n#ifdef POSITION\ngl_FragData[POSITION_INDEX]=vec4(vPositionW,1.0);\n#endif\n#ifdef VELOCITY\nvec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;\nvec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;\nvec2 velocity=abs(a-b);\nvelocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;\ngl_FragData[VELOCITY_INDEX]=vec4(velocity,0.0,1.0);\n#endif\n#ifdef REFLECTIVITY\n#ifdef HAS_SPECULAR\n\nvec4 reflectivity=texture2D(reflectivitySampler,vReflectivityUV);\n#elif HAS_REFLECTIVITY\n\nvec4 reflectivity=vec4(texture2D(reflectivitySampler,vReflectivityUV).rgb,1.0);\n#else\nvec4 reflectivity=vec4(0.0,0.0,0.0,1.0);\n#endif\ngl_FragData[REFLECTIVITY_INDEX]=reflectivity;\n#endif\n}";
Effect.ShadersStore[name68] = shader68;

// node_modules/@babylonjs/core/Shaders/geometry.vertex.js
var name69 = "geometryVertexShader";
var shader69 = "precision highp float;\nprecision highp int;\n#include<bonesDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<instancesDeclaration>\nattribute vec3 position;\nattribute vec3 normal;\n#ifdef NEED_UV\nvarying vec2 vUV;\n#ifdef ALPHATEST\nuniform mat4 diffuseMatrix;\n#endif\n#ifdef BUMP\nuniform mat4 bumpMatrix;\nvarying vec2 vBumpUV;\n#endif\n#ifdef REFLECTIVITY\nuniform mat4 reflectivityMatrix;\nvarying vec2 vReflectivityUV;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\n\nuniform mat4 viewProjection;\nuniform mat4 view;\n#ifdef BUMP\nvarying mat4 vWorldView;\n#endif\n#ifdef BUMP\nvarying vec3 vNormalW;\n#else\nvarying vec3 vNormalV;\n#endif\nvarying vec4 vViewPos;\n#if defined(POSITION) || defined(BUMP)\nvarying vec3 vPositionW;\n#endif\n#ifdef VELOCITY\nuniform mat4 previousWorld;\nuniform mat4 previousViewProjection;\n#ifdef BONES_VELOCITY_ENABLED\n#if NUM_BONE_INFLUENCERS>0\nuniform mat4 mPreviousBones[BonesPerMesh];\n#endif\n#endif\nvarying vec4 vCurrentPosition;\nvarying vec4 vPreviousPosition;\n#endif\nvoid main(void)\n{\nvec3 positionUpdated=position;\nvec3 normalUpdated=normal;\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#if defined(VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\n\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);\nvPreviousPosition=previousViewProjection*previousWorld*vec4(positionUpdated,1.0);\n#endif\n#include<bonesVertex>\nvec4 pos=vec4(finalWorld*vec4(positionUpdated,1.0));\n#ifdef BUMP\nvWorldView=view*finalWorld;\nvNormalW=normalUpdated;\n#else\nvNormalV=normalize(vec3((view*finalWorld)*vec4(normalUpdated,0.0)));\n#endif\nvViewPos=view*pos;\n#if defined(VELOCITY) && defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);\n#if NUM_BONE_INFLUENCERS>0\nmat4 previousInfluence;\npreviousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\npreviousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\npreviousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\npreviousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\n#endif\nvPreviousPosition=previousViewProjection*previousWorld*previousInfluence*vec4(positionUpdated,1.0);\n#else\nvPreviousPosition=previousViewProjection*previousWorld*vec4(positionUpdated,1.0);\n#endif\n#endif\n#if defined(POSITION) || defined(BUMP)\nvPositionW=pos.xyz/pos.w;\n#endif\ngl_Position=viewProjection*finalWorld*vec4(positionUpdated,1.0);\n#ifdef NEED_UV\n#ifdef UV1\n#ifdef ALPHATEST\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\n#else\nvUV=uv;\n#endif\n#ifdef BUMP\nvBumpUV=vec2(bumpMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef REFLECTIVITY\nvReflectivityUV=vec2(reflectivityMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#endif\n#ifdef UV2\n#ifdef ALPHATEST\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n#else\nvUV=uv2;\n#endif\n#ifdef BUMP\nvBumpUV=vec2(bumpMatrix*vec4(uv2,1.0,0.0));\n#endif\n#ifdef REFLECTIVITY\nvReflectivityUV=vec2(reflectivityMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n#endif\n#include<bumpVertex>\n}\n";
Effect.ShadersStore[name69] = shader69;

// node_modules/@babylonjs/core/Rendering/geometryBufferRenderer.js
var GeometryBufferRenderer = function() {
  function GeometryBufferRenderer2(scene, ratio) {
    if (ratio === void 0) {
      ratio = 1;
    }
    this._previousTransformationMatrices = {};
    this._previousBonesTransformationMatrices = {};
    this.excludedSkinnedMeshesFromVelocity = [];
    this.renderTransparentMeshes = true;
    this._resizeObserver = null;
    this._enablePosition = false;
    this._enableVelocity = false;
    this._enableReflectivity = false;
    this._positionIndex = -1;
    this._velocityIndex = -1;
    this._reflectivityIndex = -1;
    this._depthNormalIndex = -1;
    this._linkedWithPrePass = false;
    this._scene = scene;
    this._ratio = ratio;
    GeometryBufferRenderer2._SceneComponentInitialization(this._scene);
    this._createRenderTargets();
  }
  GeometryBufferRenderer2.prototype._linkPrePassRenderer = function(prePassRenderer) {
    this._linkedWithPrePass = true;
    this._prePassRenderer = prePassRenderer;
    if (this._multiRenderTarget) {
      this._multiRenderTarget.onClearObservable.clear();
      this._multiRenderTarget.onClearObservable.add(function(engine) {
      });
    }
  };
  GeometryBufferRenderer2.prototype._unlinkPrePassRenderer = function() {
    this._linkedWithPrePass = false;
    this._createRenderTargets();
  };
  GeometryBufferRenderer2.prototype._resetLayout = function() {
    this._enablePosition = false;
    this._enableReflectivity = false;
    this._enableVelocity = false;
    this._attachments = [];
  };
  GeometryBufferRenderer2.prototype._forceTextureType = function(geometryBufferType, index) {
    if (geometryBufferType === GeometryBufferRenderer2.POSITION_TEXTURE_TYPE) {
      this._positionIndex = index;
      this._enablePosition = true;
    } else if (geometryBufferType === GeometryBufferRenderer2.VELOCITY_TEXTURE_TYPE) {
      this._velocityIndex = index;
      this._enableVelocity = true;
    } else if (geometryBufferType === GeometryBufferRenderer2.REFLECTIVITY_TEXTURE_TYPE) {
      this._reflectivityIndex = index;
      this._enableReflectivity = true;
    } else if (geometryBufferType === GeometryBufferRenderer2.DEPTHNORMAL_TEXTURE_TYPE) {
      this._depthNormalIndex = index;
    }
  };
  GeometryBufferRenderer2.prototype._setAttachments = function(attachments) {
    this._attachments = attachments;
  };
  GeometryBufferRenderer2.prototype._linkInternalTexture = function(internalTexture) {
    this._multiRenderTarget._texture = internalTexture;
  };
  Object.defineProperty(GeometryBufferRenderer2.prototype, "renderList", {
    get: function() {
      return this._multiRenderTarget.renderList;
    },
    set: function(meshes) {
      this._multiRenderTarget.renderList = meshes;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GeometryBufferRenderer2.prototype, "isSupported", {
    get: function() {
      return this._multiRenderTarget.isSupported;
    },
    enumerable: false,
    configurable: true
  });
  GeometryBufferRenderer2.prototype.getTextureIndex = function(textureType) {
    switch (textureType) {
      case GeometryBufferRenderer2.POSITION_TEXTURE_TYPE:
        return this._positionIndex;
      case GeometryBufferRenderer2.VELOCITY_TEXTURE_TYPE:
        return this._velocityIndex;
      case GeometryBufferRenderer2.REFLECTIVITY_TEXTURE_TYPE:
        return this._reflectivityIndex;
      default:
        return -1;
    }
  };
  Object.defineProperty(GeometryBufferRenderer2.prototype, "enablePosition", {
    get: function() {
      return this._enablePosition;
    },
    set: function(enable) {
      this._enablePosition = enable;
      if (!this._linkedWithPrePass) {
        this.dispose();
        this._createRenderTargets();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GeometryBufferRenderer2.prototype, "enableVelocity", {
    get: function() {
      return this._enableVelocity;
    },
    set: function(enable) {
      this._enableVelocity = enable;
      if (!enable) {
        this._previousTransformationMatrices = {};
      }
      if (!this._linkedWithPrePass) {
        this.dispose();
        this._createRenderTargets();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GeometryBufferRenderer2.prototype, "enableReflectivity", {
    get: function() {
      return this._enableReflectivity;
    },
    set: function(enable) {
      this._enableReflectivity = enable;
      if (!this._linkedWithPrePass) {
        this.dispose();
        this._createRenderTargets();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GeometryBufferRenderer2.prototype, "scene", {
    get: function() {
      return this._scene;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GeometryBufferRenderer2.prototype, "ratio", {
    get: function() {
      return this._ratio;
    },
    enumerable: false,
    configurable: true
  });
  GeometryBufferRenderer2.prototype.isReady = function(subMesh, useInstances) {
    var material = subMesh.getMaterial();
    if (material && material.disableDepthWrite) {
      return false;
    }
    var defines = [];
    var attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];
    var mesh = subMesh.getMesh();
    if (material) {
      var needUv = false;
      if (material.needAlphaTesting()) {
        defines.push("#define ALPHATEST");
        needUv = true;
      }
      if (material.bumpTexture && StandardMaterial.BumpTextureEnabled) {
        defines.push("#define BUMP");
        defines.push("#define BUMPDIRECTUV 0");
        needUv = true;
      }
      if (this._enableReflectivity) {
        if (material instanceof StandardMaterial && material.specularTexture) {
          defines.push("#define HAS_SPECULAR");
          needUv = true;
        } else if (material instanceof PBRMaterial && material.reflectivityTexture) {
          defines.push("#define HAS_REFLECTIVITY");
          needUv = true;
        }
      }
      if (needUv) {
        defines.push("#define NEED_UV");
        if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
          attribs.push(VertexBuffer.UVKind);
          defines.push("#define UV1");
        }
        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
          attribs.push(VertexBuffer.UV2Kind);
          defines.push("#define UV2");
        }
      }
    }
    if (this._linkedWithPrePass) {
      defines.push("#define PREPASS");
      if (this._depthNormalIndex !== -1) {
        defines.push("#define DEPTHNORMAL_INDEX " + this._depthNormalIndex);
        defines.push("#define PREPASS_DEPTHNORMAL");
      }
    }
    if (this._enablePosition) {
      defines.push("#define POSITION");
      defines.push("#define POSITION_INDEX " + this._positionIndex);
    }
    if (this._enableVelocity) {
      defines.push("#define VELOCITY");
      defines.push("#define VELOCITY_INDEX " + this._velocityIndex);
      if (this.excludedSkinnedMeshesFromVelocity.indexOf(mesh) === -1) {
        defines.push("#define BONES_VELOCITY_ENABLED");
      }
    }
    if (this._enableReflectivity) {
      defines.push("#define REFLECTIVITY");
      defines.push("#define REFLECTIVITY_INDEX " + this._reflectivityIndex);
    }
    if (mesh.useBones && mesh.computeBonesUsingShaders) {
      attribs.push(VertexBuffer.MatricesIndicesKind);
      attribs.push(VertexBuffer.MatricesWeightsKind);
      if (mesh.numBoneInfluencers > 4) {
        attribs.push(VertexBuffer.MatricesIndicesExtraKind);
        attribs.push(VertexBuffer.MatricesWeightsExtraKind);
      }
      defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
      defines.push("#define BonesPerMesh " + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));
    } else {
      defines.push("#define NUM_BONE_INFLUENCERS 0");
    }
    var morphTargetManager = mesh.morphTargetManager;
    var numMorphInfluencers = 0;
    if (morphTargetManager) {
      if (morphTargetManager.numInfluencers > 0) {
        numMorphInfluencers = morphTargetManager.numInfluencers;
        defines.push("#define MORPHTARGETS");
        defines.push("#define NUM_MORPH_INFLUENCERS " + numMorphInfluencers);
        MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);
      }
    }
    if (useInstances) {
      defines.push("#define INSTANCES");
      MaterialHelper.PushAttributesForInstances(attribs);
      if (subMesh.getRenderingMesh().hasThinInstances) {
        defines.push("#define THIN_INSTANCES");
      }
    }
    if (this._linkedWithPrePass) {
      defines.push("#define RENDER_TARGET_COUNT " + this._attachments.length);
    } else {
      defines.push("#define RENDER_TARGET_COUNT " + this._multiRenderTarget.textures.length);
    }
    var join = defines.join("\n");
    if (this._cachedDefines !== join) {
      this._cachedDefines = join;
      this._effect = this._scene.getEngine().createEffect("geometry", attribs, [
        "world",
        "mBones",
        "viewProjection",
        "diffuseMatrix",
        "view",
        "previousWorld",
        "previousViewProjection",
        "mPreviousBones",
        "morphTargetInfluences",
        "bumpMatrix",
        "reflectivityMatrix",
        "vTangentSpaceParams",
        "vBumpInfos"
      ], ["diffuseSampler", "bumpSampler", "reflectivitySampler"], join, void 0, void 0, void 0, { buffersCount: this._multiRenderTarget.textures.length - 1, maxSimultaneousMorphTargets: numMorphInfluencers });
    }
    return this._effect.isReady();
  };
  GeometryBufferRenderer2.prototype.getGBuffer = function() {
    return this._multiRenderTarget;
  };
  Object.defineProperty(GeometryBufferRenderer2.prototype, "samples", {
    get: function() {
      return this._multiRenderTarget.samples;
    },
    set: function(value) {
      this._multiRenderTarget.samples = value;
    },
    enumerable: false,
    configurable: true
  });
  GeometryBufferRenderer2.prototype.dispose = function() {
    if (this._resizeObserver) {
      var engine = this._scene.getEngine();
      engine.onResizeObservable.remove(this._resizeObserver);
      this._resizeObserver = null;
    }
    this.getGBuffer().dispose();
  };
  GeometryBufferRenderer2.prototype._assignRenderTargetIndices = function() {
    var count = 2;
    if (this._enablePosition) {
      this._positionIndex = count;
      count++;
    }
    if (this._enableVelocity) {
      this._velocityIndex = count;
      count++;
    }
    if (this._enableReflectivity) {
      this._reflectivityIndex = count;
      count++;
    }
    return count;
  };
  GeometryBufferRenderer2.prototype._createRenderTargets = function() {
    var _this = this;
    var engine = this._scene.getEngine();
    var count = this._assignRenderTargetIndices();
    this._multiRenderTarget = new MultiRenderTarget("gBuffer", { width: engine.getRenderWidth() * this._ratio, height: engine.getRenderHeight() * this._ratio }, count, this._scene, { generateMipMaps: false, generateDepthTexture: true, defaultType: 1 });
    if (!this.isSupported) {
      return;
    }
    this._multiRenderTarget.wrapU = Texture.CLAMP_ADDRESSMODE;
    this._multiRenderTarget.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._multiRenderTarget.refreshRate = 1;
    this._multiRenderTarget.renderParticles = false;
    this._multiRenderTarget.renderList = null;
    this._multiRenderTarget.onClearObservable.add(function(engine2) {
      engine2.clear(new Color4(0, 0, 0, 1), true, true, true);
    });
    this._resizeObserver = engine.onResizeObservable.add(function() {
      if (_this._multiRenderTarget) {
        _this._multiRenderTarget.resize({ width: engine.getRenderWidth() * _this._ratio, height: engine.getRenderHeight() * _this._ratio });
      }
    });
    var renderSubMesh = function(subMesh) {
      var renderingMesh = subMesh.getRenderingMesh();
      var effectiveMesh = subMesh.getEffectiveMesh();
      var scene = _this._scene;
      var engine2 = scene.getEngine();
      var material = subMesh.getMaterial();
      if (!material) {
        return;
      }
      effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;
      if (_this._enableVelocity && !_this._previousTransformationMatrices[effectiveMesh.uniqueId]) {
        _this._previousTransformationMatrices[effectiveMesh.uniqueId] = {
          world: Matrix.Identity(),
          viewProjection: scene.getTransformMatrix()
        };
        if (renderingMesh.skeleton) {
          var bonesTransformations = renderingMesh.skeleton.getTransformMatrices(renderingMesh);
          _this._previousBonesTransformationMatrices[renderingMesh.uniqueId] = _this._copyBonesTransformationMatrices(bonesTransformations, new Float32Array(bonesTransformations.length));
        }
      }
      var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
      if (batch.mustReturn) {
        return;
      }
      var hardwareInstancedRendering = engine2.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);
      var world = effectiveMesh.getWorldMatrix();
      if (_this.isReady(subMesh, hardwareInstancedRendering)) {
        engine2.enableEffect(_this._effect);
        renderingMesh._bind(subMesh, _this._effect, material.fillMode);
        _this._effect.setMatrix("viewProjection", scene.getTransformMatrix());
        _this._effect.setMatrix("view", scene.getViewMatrix());
        if (material) {
          var sideOrientation;
          var instanceDataStorage = effectiveMesh._instanceDataStorage;
          if (!instanceDataStorage.isFrozen && (material.backFaceCulling || material.overrideMaterialSideOrientation !== null)) {
            var mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();
            sideOrientation = material.overrideMaterialSideOrientation;
            if (sideOrientation == null) {
              sideOrientation = material.sideOrientation;
            }
            if (mainDeterminant < 0) {
              sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;
            }
          } else {
            sideOrientation = instanceDataStorage.sideOrientation;
          }
          material._preBind(_this._effect, sideOrientation);
          if (material.needAlphaTesting()) {
            var alphaTexture = material.getAlphaTestTexture();
            if (alphaTexture) {
              _this._effect.setTexture("diffuseSampler", alphaTexture);
              _this._effect.setMatrix("diffuseMatrix", alphaTexture.getTextureMatrix());
            }
          }
          if (material.bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial.BumpTextureEnabled) {
            _this._effect.setFloat3("vBumpInfos", material.bumpTexture.coordinatesIndex, 1 / material.bumpTexture.level, material.parallaxScaleBias);
            _this._effect.setMatrix("bumpMatrix", material.bumpTexture.getTextureMatrix());
            _this._effect.setTexture("bumpSampler", material.bumpTexture);
            _this._effect.setFloat2("vTangentSpaceParams", material.invertNormalMapX ? -1 : 1, material.invertNormalMapY ? -1 : 1);
          }
          if (_this._enableReflectivity) {
            if (material instanceof StandardMaterial && material.specularTexture) {
              _this._effect.setMatrix("reflectivityMatrix", material.specularTexture.getTextureMatrix());
              _this._effect.setTexture("reflectivitySampler", material.specularTexture);
            } else if (material instanceof PBRMaterial && material.reflectivityTexture) {
              _this._effect.setMatrix("reflectivityMatrix", material.reflectivityTexture.getTextureMatrix());
              _this._effect.setTexture("reflectivitySampler", material.reflectivityTexture);
            }
          }
        }
        if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {
          _this._effect.setMatrices("mBones", renderingMesh.skeleton.getTransformMatrices(renderingMesh));
          if (_this._enableVelocity) {
            _this._effect.setMatrices("mPreviousBones", _this._previousBonesTransformationMatrices[renderingMesh.uniqueId]);
          }
        }
        MaterialHelper.BindMorphTargetParameters(renderingMesh, _this._effect);
        if (_this._enableVelocity) {
          _this._effect.setMatrix("previousWorld", _this._previousTransformationMatrices[effectiveMesh.uniqueId].world);
          _this._effect.setMatrix("previousViewProjection", _this._previousTransformationMatrices[effectiveMesh.uniqueId].viewProjection);
        }
        renderingMesh._processRendering(effectiveMesh, subMesh, _this._effect, material.fillMode, batch, hardwareInstancedRendering, function(isInstance, w) {
          return _this._effect.setMatrix("world", w);
        });
      }
      if (_this._enableVelocity) {
        _this._previousTransformationMatrices[effectiveMesh.uniqueId].world = world.clone();
        _this._previousTransformationMatrices[effectiveMesh.uniqueId].viewProjection = _this._scene.getTransformMatrix().clone();
        if (renderingMesh.skeleton) {
          _this._copyBonesTransformationMatrices(renderingMesh.skeleton.getTransformMatrices(renderingMesh), _this._previousBonesTransformationMatrices[effectiveMesh.uniqueId]);
        }
      }
    };
    this._multiRenderTarget.customRenderFunction = function(opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {
      var index;
      if (_this._linkedWithPrePass) {
        if (!_this._prePassRenderer.enabled) {
          return;
        }
        _this._scene.getEngine().bindAttachments(_this._attachments);
      }
      if (depthOnlySubMeshes.length) {
        engine.setColorWrite(false);
        for (index = 0; index < depthOnlySubMeshes.length; index++) {
          renderSubMesh(depthOnlySubMeshes.data[index]);
        }
        engine.setColorWrite(true);
      }
      for (index = 0; index < opaqueSubMeshes.length; index++) {
        renderSubMesh(opaqueSubMeshes.data[index]);
      }
      for (index = 0; index < alphaTestSubMeshes.length; index++) {
        renderSubMesh(alphaTestSubMeshes.data[index]);
      }
      if (_this.renderTransparentMeshes) {
        for (index = 0; index < transparentSubMeshes.length; index++) {
          renderSubMesh(transparentSubMeshes.data[index]);
        }
      }
    };
  };
  GeometryBufferRenderer2.prototype._copyBonesTransformationMatrices = function(source, target) {
    for (var i = 0; i < source.length; i++) {
      target[i] = source[i];
    }
    return target;
  };
  GeometryBufferRenderer2.DEPTHNORMAL_TEXTURE_TYPE = 0;
  GeometryBufferRenderer2.POSITION_TEXTURE_TYPE = 1;
  GeometryBufferRenderer2.VELOCITY_TEXTURE_TYPE = 2;
  GeometryBufferRenderer2.REFLECTIVITY_TEXTURE_TYPE = 3;
  GeometryBufferRenderer2._SceneComponentInitialization = function(_) {
    throw _DevTools.WarnImport("GeometryBufferRendererSceneComponent");
  };
  return GeometryBufferRenderer2;
}();

// node_modules/@babylonjs/core/Rendering/motionBlurConfiguration.js
var MotionBlurConfiguration = function() {
  function MotionBlurConfiguration2() {
    this.enabled = false;
    this.name = "motionBlur";
    this.texturesRequired = [
      2
    ];
  }
  return MotionBlurConfiguration2;
}();

// node_modules/@babylonjs/core/Rendering/geometryBufferRendererSceneComponent.js
Object.defineProperty(Scene.prototype, "geometryBufferRenderer", {
  get: function() {
    this._geometryBufferRenderer;
  },
  set: function(value) {
    if (value && value.isSupported) {
      this._geometryBufferRenderer = value;
    }
  },
  enumerable: true,
  configurable: true
});
Scene.prototype.enableGeometryBufferRenderer = function(ratio) {
  if (ratio === void 0) {
    ratio = 1;
  }
  if (this._geometryBufferRenderer) {
    return this._geometryBufferRenderer;
  }
  this._geometryBufferRenderer = new GeometryBufferRenderer(this, ratio);
  if (!this._geometryBufferRenderer.isSupported) {
    this._geometryBufferRenderer = null;
  }
  return this._geometryBufferRenderer;
};
Scene.prototype.disableGeometryBufferRenderer = function() {
  if (!this._geometryBufferRenderer) {
    return;
  }
  this._geometryBufferRenderer.dispose();
  this._geometryBufferRenderer = null;
};
var GeometryBufferRendererSceneComponent = function() {
  function GeometryBufferRendererSceneComponent2(scene) {
    this.name = SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER;
    this.scene = scene;
  }
  GeometryBufferRendererSceneComponent2.prototype.register = function() {
    this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER, this, this._gatherRenderTargets);
  };
  GeometryBufferRendererSceneComponent2.prototype.rebuild = function() {
  };
  GeometryBufferRendererSceneComponent2.prototype.dispose = function() {
  };
  GeometryBufferRendererSceneComponent2.prototype._gatherRenderTargets = function(renderTargets) {
    if (this.scene._geometryBufferRenderer) {
      renderTargets.push(this.scene._geometryBufferRenderer.getGBuffer());
    }
  };
  return GeometryBufferRendererSceneComponent2;
}();
GeometryBufferRenderer._SceneComponentInitialization = function(scene) {
  var component = scene._getComponent(SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER);
  if (!component) {
    component = new GeometryBufferRendererSceneComponent(scene);
    scene._addComponent(component);
  }
};

// node_modules/@babylonjs/core/Shaders/motionBlur.fragment.js
var name70 = "motionBlurPixelShader";
var shader70 = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform float motionStrength;\nuniform float motionScale;\nuniform vec2 screenSize;\n#ifdef OBJECT_BASED\nuniform sampler2D velocitySampler;\n#else\nuniform sampler2D depthSampler;\nuniform mat4 inverseViewProjection;\nuniform mat4 prevViewProjection;\n#endif\nvoid main(void)\n{\n#ifdef GEOMETRY_SUPPORTED\n#ifdef OBJECT_BASED\nvec2 texelSize=1.0/screenSize;\nvec2 velocityColor=texture2D(velocitySampler,vUV).rg*2.0-1.0;\nvec2 velocity=vec2(pow(velocityColor.r,3.0),pow(velocityColor.g,3.0));\nvelocity*=motionScale*motionStrength;\nfloat speed=length(velocity/texelSize);\nint samplesCount=int(clamp(speed,1.0,SAMPLES));\nvelocity=normalize(velocity)*texelSize;\nfloat hlim=float(-samplesCount)*0.5+0.5;\nvec4 result=texture2D(textureSampler,vUV);\nfor (int i=1; i<int(SAMPLES); ++i)\n{\nif (i>=samplesCount)\nbreak;\nvec2 offset=vUV+velocity*(hlim+float(i));\nresult+=texture2D(textureSampler,offset);\n}\ngl_FragColor=result/float(samplesCount);\ngl_FragColor.a=1.0;\n#else\nvec2 texelSize=1.0/screenSize;\nfloat depth=texture2D(depthSampler,vUV).r;\nvec4 cpos=vec4(vUV*2.0-1.0,depth,1.0);\ncpos=cpos*inverseViewProjection;\nvec4 ppos=cpos*prevViewProjection;\nppos.xyz/=ppos.w;\nppos.xy=ppos.xy*0.5+0.5;\nvec2 velocity=(ppos.xy-vUV)*motionScale*motionStrength;\nfloat speed=length(velocity/texelSize);\nint nSamples=int(clamp(speed,1.0,SAMPLES));\nvec4 result=texture2D(textureSampler,vUV);\nfor (int i=1; i<int(SAMPLES); ++i) {\nif (i>=nSamples)\nbreak;\nvec2 offset1=vUV+velocity*(float(i)/float(nSamples-1)-0.5);\nresult+=texture2D(textureSampler,offset1);\n}\ngl_FragColor=result/float(nSamples);\n#endif\n#else\ngl_FragColor=texture2D(textureSampler,vUV);\n#endif\n}\n";
Effect.ShadersStore[name70] = shader70;

// node_modules/@babylonjs/core/PostProcesses/motionBlurPostProcess.js
var MotionBlurPostProcess = function(_super) {
  __extends(MotionBlurPostProcess2, _super);
  function MotionBlurPostProcess2(name98, scene, options, camera, samplingMode, engine, reusable, textureType, blockCompilation, forceGeometryBuffer) {
    if (textureType === void 0) {
      textureType = 0;
    }
    if (blockCompilation === void 0) {
      blockCompilation = false;
    }
    if (forceGeometryBuffer === void 0) {
      forceGeometryBuffer = true;
    }
    var _this = _super.call(this, name98, "motionBlur", ["motionStrength", "motionScale", "screenSize", "inverseViewProjection", "prevViewProjection"], ["velocitySampler"], options, camera, samplingMode, engine, reusable, "#define GEOMETRY_SUPPORTED\n#define SAMPLES 64.0\n#define OBJECT_BASED", textureType, void 0, null, blockCompilation) || this;
    _this.motionStrength = 1;
    _this._motionBlurSamples = 32;
    _this._isObjectBased = true;
    _this._forceGeometryBuffer = false;
    _this._geometryBufferRenderer = null;
    _this._prePassRenderer = null;
    _this._invViewProjection = null;
    _this._previousViewProjection = null;
    _this._forceGeometryBuffer = forceGeometryBuffer;
    if (_this._forceGeometryBuffer) {
      _this._geometryBufferRenderer = scene.enableGeometryBufferRenderer();
      if (_this._geometryBufferRenderer) {
        _this._geometryBufferRenderer.enableVelocity = true;
      }
    } else {
      _this._prePassRenderer = scene.enablePrePassRenderer();
      if (_this._prePassRenderer) {
        _this._prePassRenderer.markAsDirty();
        _this._prePassEffectConfiguration = new MotionBlurConfiguration();
      }
    }
    _this._applyMode();
    return _this;
  }
  Object.defineProperty(MotionBlurPostProcess2.prototype, "motionBlurSamples", {
    get: function() {
      return this._motionBlurSamples;
    },
    set: function(samples) {
      this._motionBlurSamples = samples;
      this._updateEffect();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MotionBlurPostProcess2.prototype, "isObjectBased", {
    get: function() {
      return this._isObjectBased;
    },
    set: function(value) {
      if (this._isObjectBased === value) {
        return;
      }
      this._isObjectBased = value;
      this._applyMode();
    },
    enumerable: false,
    configurable: true
  });
  MotionBlurPostProcess2.prototype.getClassName = function() {
    return "MotionBlurPostProcess";
  };
  MotionBlurPostProcess2.prototype.excludeSkinnedMesh = function(skinnedMesh) {
    if (skinnedMesh.skeleton) {
      var list = void 0;
      if (this._geometryBufferRenderer) {
        list = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;
      } else if (this._prePassRenderer) {
        list = this._prePassRenderer.excludedSkinnedMesh;
      } else {
        return;
      }
      list.push(skinnedMesh);
    }
  };
  MotionBlurPostProcess2.prototype.removeExcludedSkinnedMesh = function(skinnedMesh) {
    if (skinnedMesh.skeleton) {
      var list = void 0;
      if (this._geometryBufferRenderer) {
        list = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;
      } else if (this._prePassRenderer) {
        list = this._prePassRenderer.excludedSkinnedMesh;
      } else {
        return;
      }
      var index = list.indexOf(skinnedMesh);
      if (index !== -1) {
        list.splice(index, 1);
      }
    }
  };
  MotionBlurPostProcess2.prototype.dispose = function(camera) {
    if (this._geometryBufferRenderer) {
      this._geometryBufferRenderer._previousTransformationMatrices = {};
      this._geometryBufferRenderer._previousBonesTransformationMatrices = {};
      this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity = [];
    }
    _super.prototype.dispose.call(this, camera);
  };
  MotionBlurPostProcess2.prototype._applyMode = function() {
    var _this = this;
    if (!this._geometryBufferRenderer && !this._prePassRenderer) {
      Logger.Warn("Multiple Render Target support needed to compute object based motion blur");
      return this.updateEffect();
    }
    this._updateEffect();
    this._invViewProjection = null;
    this._previousViewProjection = null;
    if (this.isObjectBased) {
      if (this._prePassRenderer && this._prePassEffectConfiguration) {
        this._prePassEffectConfiguration.texturesRequired[0] = 2;
      }
      this.onApply = function(effect) {
        return _this._onApplyObjectBased(effect);
      };
    } else {
      this._invViewProjection = Matrix.Identity();
      this._previousViewProjection = Matrix.Identity();
      if (this._prePassRenderer && this._prePassEffectConfiguration) {
        this._prePassEffectConfiguration.texturesRequired[0] = 5;
      }
      this.onApply = function(effect) {
        return _this._onApplyScreenBased(effect);
      };
    }
  };
  MotionBlurPostProcess2.prototype._onApplyObjectBased = function(effect) {
    effect.setVector2("screenSize", new Vector2(this.width, this.height));
    effect.setFloat("motionScale", this._scene.getAnimationRatio());
    effect.setFloat("motionStrength", this.motionStrength);
    if (this._geometryBufferRenderer) {
      var velocityIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE);
      effect.setTexture("velocitySampler", this._geometryBufferRenderer.getGBuffer().textures[velocityIndex]);
    } else if (this._prePassRenderer) {
      var velocityIndex = this._prePassRenderer.getIndex(2);
      effect.setTexture("velocitySampler", this._prePassRenderer.prePassRT.textures[velocityIndex]);
    }
  };
  MotionBlurPostProcess2.prototype._onApplyScreenBased = function(effect) {
    var viewProjection = this._scene.getProjectionMatrix().multiply(this._scene.getViewMatrix());
    viewProjection.invertToRef(this._invViewProjection);
    effect.setMatrix("inverseViewProjection", this._invViewProjection);
    effect.setMatrix("prevViewProjection", this._previousViewProjection);
    this._previousViewProjection = viewProjection;
    effect.setVector2("screenSize", new Vector2(this.width, this.height));
    effect.setFloat("motionScale", this._scene.getAnimationRatio());
    effect.setFloat("motionStrength", this.motionStrength);
    if (this._geometryBufferRenderer) {
      var depthIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.DEPTHNORMAL_TEXTURE_TYPE);
      effect.setTexture("depthSampler", this._geometryBufferRenderer.getGBuffer().textures[depthIndex]);
    } else if (this._prePassRenderer) {
      var depthIndex = this._prePassRenderer.getIndex(5);
      effect.setTexture("depthSampler", this._prePassRenderer.prePassRT.textures[depthIndex]);
    }
  };
  MotionBlurPostProcess2.prototype._updateEffect = function() {
    if (this._geometryBufferRenderer || this._prePassRenderer) {
      var defines = [
        "#define GEOMETRY_SUPPORTED",
        "#define SAMPLES " + this._motionBlurSamples.toFixed(1),
        this._isObjectBased ? "#define OBJECT_BASED" : "#define SCREEN_BASED"
      ];
      this.updateEffect(defines.join("\n"));
    }
  };
  MotionBlurPostProcess2._Parse = function(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(function() {
      return new MotionBlurPostProcess2(parsedPostProcess.name, scene, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable, parsedPostProcess.textureType, false);
    }, parsedPostProcess, scene, rootUrl);
  };
  __decorate([
    serialize()
  ], MotionBlurPostProcess2.prototype, "motionStrength", void 0);
  __decorate([
    serialize()
  ], MotionBlurPostProcess2.prototype, "motionBlurSamples", null);
  __decorate([
    serialize()
  ], MotionBlurPostProcess2.prototype, "isObjectBased", null);
  return MotionBlurPostProcess2;
}(PostProcess);
_TypeStore.RegisteredTypes["BABYLON.MotionBlurPostProcess"] = MotionBlurPostProcess;

// node_modules/@babylonjs/core/Shaders/refraction.fragment.js
var name71 = "refractionPixelShader";
var shader71 = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform sampler2D refractionSampler;\n\nuniform vec3 baseColor;\nuniform float depth;\nuniform float colorLevel;\nvoid main() {\nfloat ref=1.0-texture2D(refractionSampler,vUV).r;\nvec2 uv=vUV-vec2(0.5);\nvec2 offset=uv*depth*ref;\nvec3 sourceColor=texture2D(textureSampler,vUV-offset).rgb;\ngl_FragColor=vec4(sourceColor+sourceColor*ref*colorLevel,1.0);\n}";
Effect.ShadersStore[name71] = shader71;

// node_modules/@babylonjs/core/PostProcesses/refractionPostProcess.js
var RefractionPostProcess = function(_super) {
  __extends(RefractionPostProcess2, _super);
  function RefractionPostProcess2(name98, refractionTextureUrl, color, depth, colorLevel, options, camera, samplingMode, engine, reusable) {
    var _this = _super.call(this, name98, "refraction", ["baseColor", "depth", "colorLevel"], ["refractionSampler"], options, camera, samplingMode, engine, reusable) || this;
    _this._ownRefractionTexture = true;
    _this.color = color;
    _this.depth = depth;
    _this.colorLevel = colorLevel;
    _this.refractionTextureUrl = refractionTextureUrl;
    _this.onActivateObservable.add(function(cam) {
      _this._refTexture = _this._refTexture || new Texture(refractionTextureUrl, cam.getScene());
    });
    _this.onApplyObservable.add(function(effect) {
      effect.setColor3("baseColor", _this.color);
      effect.setFloat("depth", _this.depth);
      effect.setFloat("colorLevel", _this.colorLevel);
      effect.setTexture("refractionSampler", _this._refTexture);
    });
    return _this;
  }
  Object.defineProperty(RefractionPostProcess2.prototype, "refractionTexture", {
    get: function() {
      return this._refTexture;
    },
    set: function(value) {
      if (this._refTexture && this._ownRefractionTexture) {
        this._refTexture.dispose();
      }
      this._refTexture = value;
      this._ownRefractionTexture = false;
    },
    enumerable: false,
    configurable: true
  });
  RefractionPostProcess2.prototype.getClassName = function() {
    return "RefractionPostProcess";
  };
  RefractionPostProcess2.prototype.dispose = function(camera) {
    if (this._refTexture && this._ownRefractionTexture) {
      this._refTexture.dispose();
      this._refTexture = null;
    }
    _super.prototype.dispose.call(this, camera);
  };
  RefractionPostProcess2._Parse = function(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(function() {
      return new RefractionPostProcess2(parsedPostProcess.name, parsedPostProcess.refractionTextureUrl, parsedPostProcess.color, parsedPostProcess.depth, parsedPostProcess.colorLevel, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable);
    }, parsedPostProcess, scene, rootUrl);
  };
  __decorate([
    serialize()
  ], RefractionPostProcess2.prototype, "color", void 0);
  __decorate([
    serialize()
  ], RefractionPostProcess2.prototype, "depth", void 0);
  __decorate([
    serialize()
  ], RefractionPostProcess2.prototype, "colorLevel", void 0);
  __decorate([
    serialize()
  ], RefractionPostProcess2.prototype, "refractionTextureUrl", void 0);
  return RefractionPostProcess2;
}(PostProcess);
_TypeStore.RegisteredTypes["BABYLON.RefractionPostProcess"] = RefractionPostProcess;

// node_modules/@babylonjs/core/Shaders/sharpen.fragment.js
var name72 = "sharpenPixelShader";
var shader72 = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform vec2 screenSize;\nuniform vec2 sharpnessAmounts;\nvoid main(void)\n{\nvec2 onePixel=vec2(1.0,1.0)/screenSize;\nvec4 color=texture2D(textureSampler,vUV);\nvec4 edgeDetection=texture2D(textureSampler,vUV+onePixel*vec2(0,-1)) +\ntexture2D(textureSampler,vUV+onePixel*vec2(-1,0)) +\ntexture2D(textureSampler,vUV+onePixel*vec2(1,0)) +\ntexture2D(textureSampler,vUV+onePixel*vec2(0,1)) -\ncolor*4.0;\ngl_FragColor=max(vec4(color.rgb*sharpnessAmounts.y,color.a)-(sharpnessAmounts.x*vec4(edgeDetection.rgb,0)),0.);\n}";
Effect.ShadersStore[name72] = shader72;

// node_modules/@babylonjs/core/PostProcesses/sharpenPostProcess.js
var SharpenPostProcess = function(_super) {
  __extends(SharpenPostProcess2, _super);
  function SharpenPostProcess2(name98, options, camera, samplingMode, engine, reusable, textureType, blockCompilation) {
    if (textureType === void 0) {
      textureType = 0;
    }
    if (blockCompilation === void 0) {
      blockCompilation = false;
    }
    var _this = _super.call(this, name98, "sharpen", ["sharpnessAmounts", "screenSize"], null, options, camera, samplingMode, engine, reusable, null, textureType, void 0, null, blockCompilation) || this;
    _this.colorAmount = 1;
    _this.edgeAmount = 0.3;
    _this.onApply = function(effect) {
      effect.setFloat2("screenSize", _this.width, _this.height);
      effect.setFloat2("sharpnessAmounts", _this.edgeAmount, _this.colorAmount);
    };
    return _this;
  }
  SharpenPostProcess2.prototype.getClassName = function() {
    return "SharpenPostProcess";
  };
  SharpenPostProcess2._Parse = function(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(function() {
      return new SharpenPostProcess2(parsedPostProcess.name, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.textureType, parsedPostProcess.reusable);
    }, parsedPostProcess, scene, rootUrl);
  };
  __decorate([
    serialize()
  ], SharpenPostProcess2.prototype, "colorAmount", void 0);
  __decorate([
    serialize()
  ], SharpenPostProcess2.prototype, "edgeAmount", void 0);
  return SharpenPostProcess2;
}(PostProcess);
_TypeStore.RegisteredTypes["BABYLON.SharpenPostProcess"] = SharpenPostProcess;

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/postProcessRenderPipeline.js
var PostProcessRenderPipeline = function() {
  function PostProcessRenderPipeline2(engine, name98) {
    this.engine = engine;
    this._name = name98;
    this._renderEffects = {};
    this._renderEffectsForIsolatedPass = new Array();
    this._cameras = [];
  }
  Object.defineProperty(PostProcessRenderPipeline2.prototype, "name", {
    get: function() {
      return this._name;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PostProcessRenderPipeline2.prototype, "cameras", {
    get: function() {
      return this._cameras;
    },
    enumerable: false,
    configurable: true
  });
  PostProcessRenderPipeline2.prototype.getClassName = function() {
    return "PostProcessRenderPipeline";
  };
  Object.defineProperty(PostProcessRenderPipeline2.prototype, "isSupported", {
    get: function() {
      for (var renderEffectName in this._renderEffects) {
        if (this._renderEffects.hasOwnProperty(renderEffectName)) {
          if (!this._renderEffects[renderEffectName].isSupported) {
            return false;
          }
        }
      }
      return true;
    },
    enumerable: false,
    configurable: true
  });
  PostProcessRenderPipeline2.prototype.addEffect = function(renderEffect) {
    this._renderEffects[renderEffect._name] = renderEffect;
  };
  PostProcessRenderPipeline2.prototype._rebuild = function() {
  };
  PostProcessRenderPipeline2.prototype._enableEffect = function(renderEffectName, cameras) {
    var renderEffects = this._renderEffects[renderEffectName];
    if (!renderEffects) {
      return;
    }
    renderEffects._enable(Tools.MakeArray(cameras || this._cameras));
  };
  PostProcessRenderPipeline2.prototype._disableEffect = function(renderEffectName, cameras) {
    var renderEffects = this._renderEffects[renderEffectName];
    if (!renderEffects) {
      return;
    }
    renderEffects._disable(Tools.MakeArray(cameras || this._cameras));
  };
  PostProcessRenderPipeline2.prototype._attachCameras = function(cameras, unique) {
    var cams = Tools.MakeArray(cameras || this._cameras);
    if (!cams) {
      return;
    }
    var indicesToDelete = [];
    var i;
    for (i = 0; i < cams.length; i++) {
      var camera = cams[i];
      if (!camera) {
        continue;
      }
      var cameraName = camera.name;
      if (this._cameras.indexOf(camera) === -1) {
        this._cameras[cameraName] = camera;
      } else if (unique) {
        indicesToDelete.push(i);
      }
    }
    for (i = 0; i < indicesToDelete.length; i++) {
      cameras.splice(indicesToDelete[i], 1);
    }
    for (var renderEffectName in this._renderEffects) {
      if (this._renderEffects.hasOwnProperty(renderEffectName)) {
        this._renderEffects[renderEffectName]._attachCameras(cams);
      }
    }
  };
  PostProcessRenderPipeline2.prototype._detachCameras = function(cameras) {
    var cams = Tools.MakeArray(cameras || this._cameras);
    if (!cams) {
      return;
    }
    for (var renderEffectName in this._renderEffects) {
      if (this._renderEffects.hasOwnProperty(renderEffectName)) {
        this._renderEffects[renderEffectName]._detachCameras(cams);
      }
    }
    for (var i = 0; i < cams.length; i++) {
      this._cameras.splice(this._cameras.indexOf(cams[i]), 1);
    }
  };
  PostProcessRenderPipeline2.prototype._update = function() {
    for (var renderEffectName in this._renderEffects) {
      if (this._renderEffects.hasOwnProperty(renderEffectName)) {
        this._renderEffects[renderEffectName]._update();
      }
    }
    for (var i = 0; i < this._cameras.length; i++) {
      if (!this._cameras[i]) {
        continue;
      }
      var cameraName = this._cameras[i].name;
      if (this._renderEffectsForIsolatedPass[cameraName]) {
        this._renderEffectsForIsolatedPass[cameraName]._update();
      }
    }
  };
  PostProcessRenderPipeline2.prototype._reset = function() {
    this._renderEffects = {};
    this._renderEffectsForIsolatedPass = new Array();
  };
  PostProcessRenderPipeline2.prototype._enableMSAAOnFirstPostProcess = function(sampleCount) {
    if (this.engine.webGLVersion === 1) {
      return false;
    }
    var effectKeys = Object.keys(this._renderEffects);
    if (effectKeys.length > 0) {
      var postProcesses = this._renderEffects[effectKeys[0]].getPostProcesses();
      if (postProcesses) {
        postProcesses[0].samples = sampleCount;
      }
    }
    return true;
  };
  PostProcessRenderPipeline2.prototype.setPrePassRenderer = function(prePassRenderer) {
    return false;
  };
  PostProcessRenderPipeline2.prototype.dispose = function() {
  };
  __decorate([
    serialize()
  ], PostProcessRenderPipeline2.prototype, "_name", void 0);
  return PostProcessRenderPipeline2;
}();

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/postProcessRenderPipelineManager.js
var PostProcessRenderPipelineManager = function() {
  function PostProcessRenderPipelineManager2() {
    this._renderPipelines = {};
  }
  Object.defineProperty(PostProcessRenderPipelineManager2.prototype, "supportedPipelines", {
    get: function() {
      var result = [];
      for (var renderPipelineName in this._renderPipelines) {
        if (this._renderPipelines.hasOwnProperty(renderPipelineName)) {
          var pipeline = this._renderPipelines[renderPipelineName];
          if (pipeline.isSupported) {
            result.push(pipeline);
          }
        }
      }
      return result;
    },
    enumerable: false,
    configurable: true
  });
  PostProcessRenderPipelineManager2.prototype.addPipeline = function(renderPipeline) {
    this._renderPipelines[renderPipeline._name] = renderPipeline;
  };
  PostProcessRenderPipelineManager2.prototype.attachCamerasToRenderPipeline = function(renderPipelineName, cameras, unique) {
    if (unique === void 0) {
      unique = false;
    }
    var renderPipeline = this._renderPipelines[renderPipelineName];
    if (!renderPipeline) {
      return;
    }
    renderPipeline._attachCameras(cameras, unique);
  };
  PostProcessRenderPipelineManager2.prototype.detachCamerasFromRenderPipeline = function(renderPipelineName, cameras) {
    var renderPipeline = this._renderPipelines[renderPipelineName];
    if (!renderPipeline) {
      return;
    }
    renderPipeline._detachCameras(cameras);
  };
  PostProcessRenderPipelineManager2.prototype.enableEffectInPipeline = function(renderPipelineName, renderEffectName, cameras) {
    var renderPipeline = this._renderPipelines[renderPipelineName];
    if (!renderPipeline) {
      return;
    }
    renderPipeline._enableEffect(renderEffectName, cameras);
  };
  PostProcessRenderPipelineManager2.prototype.disableEffectInPipeline = function(renderPipelineName, renderEffectName, cameras) {
    var renderPipeline = this._renderPipelines[renderPipelineName];
    if (!renderPipeline) {
      return;
    }
    renderPipeline._disableEffect(renderEffectName, cameras);
  };
  PostProcessRenderPipelineManager2.prototype.update = function() {
    for (var renderPipelineName in this._renderPipelines) {
      if (this._renderPipelines.hasOwnProperty(renderPipelineName)) {
        var pipeline = this._renderPipelines[renderPipelineName];
        if (!pipeline.isSupported) {
          pipeline.dispose();
          delete this._renderPipelines[renderPipelineName];
        } else {
          pipeline._update();
        }
      }
    }
  };
  PostProcessRenderPipelineManager2.prototype._rebuild = function() {
    for (var renderPipelineName in this._renderPipelines) {
      if (this._renderPipelines.hasOwnProperty(renderPipelineName)) {
        var pipeline = this._renderPipelines[renderPipelineName];
        pipeline._rebuild();
      }
    }
  };
  PostProcessRenderPipelineManager2.prototype.dispose = function() {
    for (var renderPipelineName in this._renderPipelines) {
      if (this._renderPipelines.hasOwnProperty(renderPipelineName)) {
        var pipeline = this._renderPipelines[renderPipelineName];
        pipeline.dispose();
      }
    }
  };
  return PostProcessRenderPipelineManager2;
}();

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/postProcessRenderPipelineManagerSceneComponent.js
Object.defineProperty(Scene.prototype, "postProcessRenderPipelineManager", {
  get: function() {
    if (!this._postProcessRenderPipelineManager) {
      var component = this._getComponent(SceneComponentConstants.NAME_POSTPROCESSRENDERPIPELINEMANAGER);
      if (!component) {
        component = new PostProcessRenderPipelineManagerSceneComponent(this);
        this._addComponent(component);
      }
      this._postProcessRenderPipelineManager = new PostProcessRenderPipelineManager();
    }
    return this._postProcessRenderPipelineManager;
  },
  enumerable: true,
  configurable: true
});
var PostProcessRenderPipelineManagerSceneComponent = function() {
  function PostProcessRenderPipelineManagerSceneComponent2(scene) {
    this.name = SceneComponentConstants.NAME_POSTPROCESSRENDERPIPELINEMANAGER;
    this.scene = scene;
  }
  PostProcessRenderPipelineManagerSceneComponent2.prototype.register = function() {
    this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER, this, this._gatherRenderTargets);
  };
  PostProcessRenderPipelineManagerSceneComponent2.prototype.rebuild = function() {
    if (this.scene._postProcessRenderPipelineManager) {
      this.scene._postProcessRenderPipelineManager._rebuild();
    }
  };
  PostProcessRenderPipelineManagerSceneComponent2.prototype.dispose = function() {
    if (this.scene._postProcessRenderPipelineManager) {
      this.scene._postProcessRenderPipelineManager.dispose();
    }
  };
  PostProcessRenderPipelineManagerSceneComponent2.prototype._gatherRenderTargets = function() {
    if (this.scene._postProcessRenderPipelineManager) {
      this.scene._postProcessRenderPipelineManager.update();
    }
  };
  return PostProcessRenderPipelineManagerSceneComponent2;
}();

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/defaultRenderingPipeline.js
var DefaultRenderingPipeline = function(_super) {
  __extends(DefaultRenderingPipeline2, _super);
  function DefaultRenderingPipeline2(name98, hdr, scene, cameras, automaticBuild) {
    if (name98 === void 0) {
      name98 = "";
    }
    if (hdr === void 0) {
      hdr = true;
    }
    if (scene === void 0) {
      scene = EngineStore.LastCreatedScene;
    }
    if (automaticBuild === void 0) {
      automaticBuild = true;
    }
    var _this = _super.call(this, scene.getEngine(), name98) || this;
    _this._camerasToBeAttached = [];
    _this.SharpenPostProcessId = "SharpenPostProcessEffect";
    _this.ImageProcessingPostProcessId = "ImageProcessingPostProcessEffect";
    _this.FxaaPostProcessId = "FxaaPostProcessEffect";
    _this.ChromaticAberrationPostProcessId = "ChromaticAberrationPostProcessEffect";
    _this.GrainPostProcessId = "GrainPostProcessEffect";
    _this._glowLayer = null;
    _this.animations = [];
    _this._imageProcessingConfigurationObserver = null;
    _this._sharpenEnabled = false;
    _this._bloomEnabled = false;
    _this._depthOfFieldEnabled = false;
    _this._depthOfFieldBlurLevel = DepthOfFieldEffectBlurLevel.Low;
    _this._fxaaEnabled = false;
    _this._imageProcessingEnabled = true;
    _this._bloomScale = 0.5;
    _this._chromaticAberrationEnabled = false;
    _this._grainEnabled = false;
    _this._buildAllowed = true;
    _this.onBuildObservable = new Observable();
    _this._resizeObserver = null;
    _this._hardwareScaleLevel = 1;
    _this._bloomKernel = 64;
    _this._bloomWeight = 0.15;
    _this._bloomThreshold = 0.9;
    _this._samples = 1;
    _this._hasCleared = false;
    _this._prevPostProcess = null;
    _this._prevPrevPostProcess = null;
    _this._depthOfFieldSceneObserver = null;
    _this._cameras = cameras || scene.cameras;
    _this._cameras = _this._cameras.slice();
    _this._camerasToBeAttached = _this._cameras.slice();
    _this._buildAllowed = automaticBuild;
    _this._scene = scene;
    var caps = _this._scene.getEngine().getCaps();
    _this._hdr = hdr && (caps.textureHalfFloatRender || caps.textureFloatRender);
    if (_this._hdr) {
      if (caps.textureHalfFloatRender) {
        _this._defaultPipelineTextureType = 2;
      } else if (caps.textureFloatRender) {
        _this._defaultPipelineTextureType = 1;
      }
    } else {
      _this._defaultPipelineTextureType = 0;
    }
    scene.postProcessRenderPipelineManager.addPipeline(_this);
    var engine = _this._scene.getEngine();
    _this.sharpen = new SharpenPostProcess("sharpen", 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, _this._defaultPipelineTextureType, true);
    _this._sharpenEffect = new PostProcessRenderEffect(engine, _this.SharpenPostProcessId, function() {
      return _this.sharpen;
    }, true);
    _this.depthOfField = new DepthOfFieldEffect(_this._scene, null, _this._depthOfFieldBlurLevel, _this._defaultPipelineTextureType, true);
    _this.bloom = new BloomEffect(_this._scene, _this._bloomScale, _this._bloomWeight, _this.bloomKernel, _this._defaultPipelineTextureType, true);
    _this.chromaticAberration = new ChromaticAberrationPostProcess("ChromaticAberration", engine.getRenderWidth(), engine.getRenderHeight(), 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, _this._defaultPipelineTextureType, true);
    _this._chromaticAberrationEffect = new PostProcessRenderEffect(engine, _this.ChromaticAberrationPostProcessId, function() {
      return _this.chromaticAberration;
    }, true);
    _this.grain = new GrainPostProcess("Grain", 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, _this._defaultPipelineTextureType, true);
    _this._grainEffect = new PostProcessRenderEffect(engine, _this.GrainPostProcessId, function() {
      return _this.grain;
    }, true);
    _this._resizeObserver = engine.onResizeObservable.add(function() {
      _this._hardwareScaleLevel = engine.getHardwareScalingLevel();
      _this.bloomKernel = _this.bloomKernel;
    });
    _this._imageProcessingConfigurationObserver = _this._scene.imageProcessingConfiguration.onUpdateParameters.add(function() {
      _this.bloom._downscale._exposure = _this._scene.imageProcessingConfiguration.exposure;
      if (_this.imageProcessingEnabled !== _this._scene.imageProcessingConfiguration.isEnabled) {
        _this._imageProcessingEnabled = _this._scene.imageProcessingConfiguration.isEnabled;
        _this._buildPipeline();
      }
    });
    _this._buildPipeline();
    return _this;
  }
  Object.defineProperty(DefaultRenderingPipeline2.prototype, "scene", {
    get: function() {
      return this._scene;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DefaultRenderingPipeline2.prototype, "sharpenEnabled", {
    get: function() {
      return this._sharpenEnabled;
    },
    set: function(enabled) {
      if (this._sharpenEnabled === enabled) {
        return;
      }
      this._sharpenEnabled = enabled;
      this._buildPipeline();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DefaultRenderingPipeline2.prototype, "bloomKernel", {
    get: function() {
      return this._bloomKernel;
    },
    set: function(value) {
      this._bloomKernel = value;
      this.bloom.kernel = value / this._hardwareScaleLevel;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DefaultRenderingPipeline2.prototype, "bloomWeight", {
    get: function() {
      return this._bloomWeight;
    },
    set: function(value) {
      if (this._bloomWeight === value) {
        return;
      }
      this.bloom.weight = value;
      this._bloomWeight = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DefaultRenderingPipeline2.prototype, "bloomThreshold", {
    get: function() {
      return this._bloomThreshold;
    },
    set: function(value) {
      if (this._bloomThreshold === value) {
        return;
      }
      this.bloom.threshold = value;
      this._bloomThreshold = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DefaultRenderingPipeline2.prototype, "bloomScale", {
    get: function() {
      return this._bloomScale;
    },
    set: function(value) {
      if (this._bloomScale === value) {
        return;
      }
      this._bloomScale = value;
      this._rebuildBloom();
      this._buildPipeline();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DefaultRenderingPipeline2.prototype, "bloomEnabled", {
    get: function() {
      return this._bloomEnabled;
    },
    set: function(enabled) {
      if (this._bloomEnabled === enabled) {
        return;
      }
      this._bloomEnabled = enabled;
      this._buildPipeline();
    },
    enumerable: false,
    configurable: true
  });
  DefaultRenderingPipeline2.prototype._rebuildBloom = function() {
    var oldBloom = this.bloom;
    this.bloom = new BloomEffect(this._scene, this.bloomScale, this._bloomWeight, this.bloomKernel, this._defaultPipelineTextureType, false);
    this.bloom.threshold = oldBloom.threshold;
    for (var i = 0; i < this._cameras.length; i++) {
      oldBloom.disposeEffects(this._cameras[i]);
    }
  };
  Object.defineProperty(DefaultRenderingPipeline2.prototype, "depthOfFieldEnabled", {
    get: function() {
      return this._depthOfFieldEnabled;
    },
    set: function(enabled) {
      if (this._depthOfFieldEnabled === enabled) {
        return;
      }
      this._depthOfFieldEnabled = enabled;
      this._buildPipeline();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DefaultRenderingPipeline2.prototype, "depthOfFieldBlurLevel", {
    get: function() {
      return this._depthOfFieldBlurLevel;
    },
    set: function(value) {
      if (this._depthOfFieldBlurLevel === value) {
        return;
      }
      this._depthOfFieldBlurLevel = value;
      var oldDof = this.depthOfField;
      this.depthOfField = new DepthOfFieldEffect(this._scene, null, this._depthOfFieldBlurLevel, this._defaultPipelineTextureType, false);
      this.depthOfField.focalLength = oldDof.focalLength;
      this.depthOfField.focusDistance = oldDof.focusDistance;
      this.depthOfField.fStop = oldDof.fStop;
      this.depthOfField.lensSize = oldDof.lensSize;
      for (var i = 0; i < this._cameras.length; i++) {
        oldDof.disposeEffects(this._cameras[i]);
      }
      this._buildPipeline();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DefaultRenderingPipeline2.prototype, "fxaaEnabled", {
    get: function() {
      return this._fxaaEnabled;
    },
    set: function(enabled) {
      if (this._fxaaEnabled === enabled) {
        return;
      }
      this._fxaaEnabled = enabled;
      this._buildPipeline();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DefaultRenderingPipeline2.prototype, "samples", {
    get: function() {
      return this._samples;
    },
    set: function(sampleCount) {
      if (this._samples === sampleCount) {
        return;
      }
      this._samples = sampleCount;
      this._buildPipeline();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DefaultRenderingPipeline2.prototype, "imageProcessingEnabled", {
    get: function() {
      return this._imageProcessingEnabled;
    },
    set: function(enabled) {
      if (this._imageProcessingEnabled === enabled) {
        return;
      }
      this._scene.imageProcessingConfiguration.isEnabled = enabled;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DefaultRenderingPipeline2.prototype, "glowLayerEnabled", {
    get: function() {
      return this._glowLayer != null;
    },
    set: function(enabled) {
      if (enabled && !this._glowLayer) {
        this._glowLayer = new GlowLayer("", this._scene);
      } else if (!enabled && this._glowLayer) {
        this._glowLayer.dispose();
        this._glowLayer = null;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DefaultRenderingPipeline2.prototype, "glowLayer", {
    get: function() {
      return this._glowLayer;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DefaultRenderingPipeline2.prototype, "chromaticAberrationEnabled", {
    get: function() {
      return this._chromaticAberrationEnabled;
    },
    set: function(enabled) {
      if (this._chromaticAberrationEnabled === enabled) {
        return;
      }
      this._chromaticAberrationEnabled = enabled;
      this._buildPipeline();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DefaultRenderingPipeline2.prototype, "grainEnabled", {
    get: function() {
      return this._grainEnabled;
    },
    set: function(enabled) {
      if (this._grainEnabled === enabled) {
        return;
      }
      this._grainEnabled = enabled;
      this._buildPipeline();
    },
    enumerable: false,
    configurable: true
  });
  DefaultRenderingPipeline2.prototype.getClassName = function() {
    return "DefaultRenderingPipeline";
  };
  DefaultRenderingPipeline2.prototype.prepare = function() {
    var previousState = this._buildAllowed;
    this._buildAllowed = true;
    this._buildPipeline();
    this._buildAllowed = previousState;
  };
  DefaultRenderingPipeline2.prototype._setAutoClearAndTextureSharing = function(postProcess, skipTextureSharing) {
    if (skipTextureSharing === void 0) {
      skipTextureSharing = false;
    }
    if (this._hasCleared) {
      postProcess.autoClear = false;
    } else {
      postProcess.autoClear = true;
      this._scene.autoClear = false;
      this._hasCleared = true;
    }
    if (!skipTextureSharing) {
      if (this._prevPrevPostProcess) {
        postProcess.shareOutputWith(this._prevPrevPostProcess);
      } else {
        postProcess.useOwnOutput();
      }
      if (this._prevPostProcess) {
        this._prevPrevPostProcess = this._prevPostProcess;
      }
      this._prevPostProcess = postProcess;
    }
  };
  DefaultRenderingPipeline2.prototype._buildPipeline = function() {
    var _this = this;
    if (!this._buildAllowed) {
      return;
    }
    this._scene.autoClear = true;
    var engine = this._scene.getEngine();
    this._disposePostProcesses();
    if (this._cameras !== null) {
      this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);
      this._cameras = this._camerasToBeAttached.slice();
    }
    this._reset();
    this._prevPostProcess = null;
    this._prevPrevPostProcess = null;
    this._hasCleared = false;
    if (this.depthOfFieldEnabled) {
      if (this._cameras.length > 1) {
        for (var _i = 0, _a = this._cameras; _i < _a.length; _i++) {
          var camera = _a[_i];
          var depthRenderer = this._scene.enableDepthRenderer(camera);
          depthRenderer.useOnlyInActiveCamera = true;
        }
        this._depthOfFieldSceneObserver = this._scene.onAfterRenderTargetsRenderObservable.add(function(scene) {
          if (_this._cameras.indexOf(scene.activeCamera) > -1) {
            _this.depthOfField.depthTexture = scene.enableDepthRenderer(scene.activeCamera).getDepthMap();
          }
        });
      } else {
        this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);
        var depthRenderer = this._scene.enableDepthRenderer(this._cameras[0]);
        this.depthOfField.depthTexture = depthRenderer.getDepthMap();
      }
      if (!this.depthOfField._isReady()) {
        this.depthOfField._updateEffects();
      }
      this.addEffect(this.depthOfField);
      this._setAutoClearAndTextureSharing(this.depthOfField._effects[0], true);
    } else {
      this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);
    }
    if (this.bloomEnabled) {
      if (!this.bloom._isReady()) {
        this.bloom._updateEffects();
      }
      this.addEffect(this.bloom);
      this._setAutoClearAndTextureSharing(this.bloom._effects[0], true);
    }
    if (this._imageProcessingEnabled) {
      this.imageProcessing = new ImageProcessingPostProcess("imageProcessing", 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType);
      if (this._hdr) {
        this.addEffect(new PostProcessRenderEffect(engine, this.ImageProcessingPostProcessId, function() {
          return _this.imageProcessing;
        }, true));
        this._setAutoClearAndTextureSharing(this.imageProcessing);
      } else {
        this._scene.imageProcessingConfiguration.applyByPostProcess = false;
      }
      if (!this.cameras || this.cameras.length === 0) {
        this._scene.imageProcessingConfiguration.applyByPostProcess = false;
      }
      if (!this.imageProcessing.getEffect()) {
        this.imageProcessing._updateParameters();
      }
    }
    if (this.sharpenEnabled) {
      if (!this.sharpen.isReady()) {
        this.sharpen.updateEffect();
      }
      this.addEffect(this._sharpenEffect);
      this._setAutoClearAndTextureSharing(this.sharpen);
    }
    if (this.grainEnabled) {
      if (!this.grain.isReady()) {
        this.grain.updateEffect();
      }
      this.addEffect(this._grainEffect);
      this._setAutoClearAndTextureSharing(this.grain);
    }
    if (this.chromaticAberrationEnabled) {
      if (!this.chromaticAberration.isReady()) {
        this.chromaticAberration.updateEffect();
      }
      this.addEffect(this._chromaticAberrationEffect);
      this._setAutoClearAndTextureSharing(this.chromaticAberration);
    }
    if (this.fxaaEnabled) {
      this.fxaa = new FxaaPostProcess("fxaa", 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType);
      this.addEffect(new PostProcessRenderEffect(engine, this.FxaaPostProcessId, function() {
        return _this.fxaa;
      }, true));
      this._setAutoClearAndTextureSharing(this.fxaa, true);
    }
    if (this._cameras !== null) {
      this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);
    }
    if (this._scene.activeCameras && this._scene.activeCameras.length > 1) {
      this._scene.autoClear = true;
    }
    if (!this._enableMSAAOnFirstPostProcess(this.samples) && this.samples > 1) {
      Logger.Warn("MSAA failed to enable, MSAA is only supported in browsers that support webGL >= 2.0");
    }
    this.onBuildObservable.notifyObservers(this);
  };
  DefaultRenderingPipeline2.prototype._disposePostProcesses = function(disposeNonRecreated) {
    if (disposeNonRecreated === void 0) {
      disposeNonRecreated = false;
    }
    for (var i = 0; i < this._cameras.length; i++) {
      var camera = this._cameras[i];
      if (this.imageProcessing) {
        this.imageProcessing.dispose(camera);
      }
      if (this.fxaa) {
        this.fxaa.dispose(camera);
      }
      if (disposeNonRecreated) {
        if (this.sharpen) {
          this.sharpen.dispose(camera);
        }
        if (this.depthOfField) {
          this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);
          this.depthOfField.disposeEffects(camera);
        }
        if (this.bloom) {
          this.bloom.disposeEffects(camera);
        }
        if (this.chromaticAberration) {
          this.chromaticAberration.dispose(camera);
        }
        if (this.grain) {
          this.grain.dispose(camera);
        }
        if (this._glowLayer) {
          this._glowLayer.dispose();
        }
      }
    }
    this.imageProcessing = null;
    this.fxaa = null;
    if (disposeNonRecreated) {
      this.sharpen = null;
      this._sharpenEffect = null;
      this.depthOfField = null;
      this.bloom = null;
      this.chromaticAberration = null;
      this._chromaticAberrationEffect = null;
      this.grain = null;
      this._grainEffect = null;
      this._glowLayer = null;
    }
  };
  DefaultRenderingPipeline2.prototype.addCamera = function(camera) {
    this._camerasToBeAttached.push(camera);
    this._buildPipeline();
  };
  DefaultRenderingPipeline2.prototype.removeCamera = function(camera) {
    var index = this._camerasToBeAttached.indexOf(camera);
    this._camerasToBeAttached.splice(index, 1);
    this._buildPipeline();
  };
  DefaultRenderingPipeline2.prototype.dispose = function() {
    this.onBuildObservable.clear();
    this._disposePostProcesses(true);
    this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);
    this._scene.autoClear = true;
    if (this._resizeObserver) {
      this._scene.getEngine().onResizeObservable.remove(this._resizeObserver);
      this._resizeObserver = null;
    }
    this._scene.imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingConfigurationObserver);
    _super.prototype.dispose.call(this);
  };
  DefaultRenderingPipeline2.prototype.serialize = function() {
    var serializationObject = SerializationHelper.Serialize(this);
    serializationObject.customType = "DefaultRenderingPipeline";
    return serializationObject;
  };
  DefaultRenderingPipeline2.Parse = function(source, scene, rootUrl) {
    return SerializationHelper.Parse(function() {
      return new DefaultRenderingPipeline2(source._name, source._name._hdr, scene);
    }, source, scene, rootUrl);
  };
  __decorate([
    serialize()
  ], DefaultRenderingPipeline2.prototype, "sharpenEnabled", null);
  __decorate([
    serialize()
  ], DefaultRenderingPipeline2.prototype, "bloomKernel", null);
  __decorate([
    serialize()
  ], DefaultRenderingPipeline2.prototype, "_bloomWeight", void 0);
  __decorate([
    serialize()
  ], DefaultRenderingPipeline2.prototype, "_bloomThreshold", void 0);
  __decorate([
    serialize()
  ], DefaultRenderingPipeline2.prototype, "_hdr", void 0);
  __decorate([
    serialize()
  ], DefaultRenderingPipeline2.prototype, "bloomWeight", null);
  __decorate([
    serialize()
  ], DefaultRenderingPipeline2.prototype, "bloomThreshold", null);
  __decorate([
    serialize()
  ], DefaultRenderingPipeline2.prototype, "bloomScale", null);
  __decorate([
    serialize()
  ], DefaultRenderingPipeline2.prototype, "bloomEnabled", null);
  __decorate([
    serialize()
  ], DefaultRenderingPipeline2.prototype, "depthOfFieldEnabled", null);
  __decorate([
    serialize()
  ], DefaultRenderingPipeline2.prototype, "depthOfFieldBlurLevel", null);
  __decorate([
    serialize()
  ], DefaultRenderingPipeline2.prototype, "fxaaEnabled", null);
  __decorate([
    serialize()
  ], DefaultRenderingPipeline2.prototype, "samples", null);
  __decorate([
    serialize()
  ], DefaultRenderingPipeline2.prototype, "imageProcessingEnabled", null);
  __decorate([
    serialize()
  ], DefaultRenderingPipeline2.prototype, "glowLayerEnabled", null);
  __decorate([
    serialize()
  ], DefaultRenderingPipeline2.prototype, "chromaticAberrationEnabled", null);
  __decorate([
    serialize()
  ], DefaultRenderingPipeline2.prototype, "grainEnabled", null);
  return DefaultRenderingPipeline2;
}(PostProcessRenderPipeline);
_TypeStore.RegisteredTypes["BABYLON.DefaultRenderingPipeline"] = DefaultRenderingPipeline;

// node_modules/@babylonjs/core/Shaders/lensHighlights.fragment.js
var name73 = "lensHighlightsPixelShader";
var shader73 = "\nuniform sampler2D textureSampler;\n\nuniform float gain;\nuniform float threshold;\nuniform float screen_width;\nuniform float screen_height;\n\nvarying vec2 vUV;\n\nvec4 highlightColor(vec4 color) {\nvec4 highlight=color;\nfloat luminance=dot(highlight.rgb,vec3(0.2125,0.7154,0.0721));\nfloat lum_threshold;\nif (threshold>1.0) { lum_threshold=0.94+0.01*threshold; }\nelse { lum_threshold=0.5+0.44*threshold; }\nluminance=clamp((luminance-lum_threshold)*(1.0/(1.0-lum_threshold)),0.0,1.0);\nhighlight*=luminance*gain;\nhighlight.a=1.0;\nreturn highlight;\n}\nvoid main(void)\n{\nvec4 original=texture2D(textureSampler,vUV);\n\nif (gain == -1.0) {\ngl_FragColor=vec4(0.0,0.0,0.0,1.0);\nreturn;\n}\nfloat w=2.0/screen_width;\nfloat h=2.0/screen_height;\nfloat weight=1.0;\n\nvec4 blurred=vec4(0.0,0.0,0.0,0.0);\n#ifdef PENTAGON\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.84*w,0.43*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.48*w,-1.29*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.61*w,1.51*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.55*w,-0.74*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.71*w,-0.52*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.94*w,1.59*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.40*w,-1.87*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.62*w,1.16*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.09*w,0.25*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.46*w,-1.71*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.08*w,2.42*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.85*w,-1.89*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.89*w,0.16*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.29*w,1.88*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.40*w,-2.81*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.54*w,2.26*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.60*w,-0.61*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.31*w,-1.30*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.83*w,2.53*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.12*w,-2.48*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.60*w,1.11*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.82*w,0.99*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.50*w,-2.81*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.85*w,3.33*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.94*w,-1.92*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.27*w,-0.53*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.95*w,2.48*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.23*w,-3.04*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.17*w,2.05*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.97*w,-0.04*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.25*w,-2.00*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.31*w,3.08*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.94*w,-2.59*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.37*w,0.64*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.13*w,1.93*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.03*w,-3.65*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.60*w,3.17*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.14*w,-1.19*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.00*w,-1.19*h)));\n#else\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.85*w,0.36*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.52*w,-1.14*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.46*w,1.42*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.46*w,-0.83*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.79*w,-0.42*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.11*w,1.62*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.29*w,-2.07*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.69*w,1.39*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.28*w,0.12*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.65*w,-1.69*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.08*w,2.44*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.63*w,-1.90*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.55*w,0.31*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.13*w,1.52*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.56*w,-2.61*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.38*w,2.34*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.64*w,-0.81*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.53*w,-1.21*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.06*w,2.63*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.00*w,-2.69*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.59*w,1.32*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.82*w,0.78*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.57*w,-2.50*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.54*w,2.93*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.39*w,-1.81*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.01*w,-0.28*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.04*w,2.25*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.02*w,-3.05*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.09*w,2.25*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.07*w,-0.25*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.44*w,-1.90*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.52*w,3.05*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.68*w,-2.61*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.01*w,0.79*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.76*w,1.46*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.05*w,-2.94*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.21*w,2.88*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.84*w,-1.30*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.98*w,-0.96*h)));\n#endif\nblurred/=39.0;\ngl_FragColor=blurred;\n\n}";
Effect.ShadersStore[name73] = shader73;

// node_modules/@babylonjs/core/Shaders/depthOfField.fragment.js
var name74 = "depthOfFieldPixelShader";
var shader74 = "\n\n\n\n\nuniform sampler2D textureSampler;\nuniform sampler2D highlightsSampler;\nuniform sampler2D depthSampler;\nuniform sampler2D grainSampler;\n\nuniform float grain_amount;\nuniform bool blur_noise;\nuniform float screen_width;\nuniform float screen_height;\nuniform float distortion;\nuniform bool dof_enabled;\n\nuniform float screen_distance;\nuniform float aperture;\nuniform float darken;\nuniform float edge_blur;\nuniform bool highlights;\n\nuniform float near;\nuniform float far;\n\nvarying vec2 vUV;\n\n#define PI 3.14159265\n#define TWOPI 6.28318530\n#define inverse_focal_length 0.1\n\nvec2 centered_screen_pos;\nvec2 distorted_coords;\nfloat radius2;\nfloat radius;\n\nvec2 rand(vec2 co)\n{\nfloat noise1=(fract(sin(dot(co,vec2(12.9898,78.233)))*43758.5453));\nfloat noise2=(fract(sin(dot(co,vec2(12.9898,78.233)*2.0))*43758.5453));\nreturn clamp(vec2(noise1,noise2),0.0,1.0);\n}\n\nvec2 getDistortedCoords(vec2 coords) {\nif (distortion == 0.0) { return coords; }\nvec2 direction=1.0*normalize(centered_screen_pos);\nvec2 dist_coords=vec2(0.5,0.5);\ndist_coords.x=0.5+direction.x*radius2*1.0;\ndist_coords.y=0.5+direction.y*radius2*1.0;\nfloat dist_amount=clamp(distortion*0.23,0.0,1.0);\ndist_coords=mix(coords,dist_coords,dist_amount);\nreturn dist_coords;\n}\n\nfloat sampleScreen(inout vec4 color,const in vec2 offset,const in float weight) {\n\nvec2 coords=distorted_coords;\nfloat angle=rand(coords*100.0).x*TWOPI;\ncoords+=vec2(offset.x*cos(angle)-offset.y*sin(angle),offset.x*sin(angle)+offset.y*cos(angle));\ncolor+=texture2D(textureSampler,coords)*weight;\nreturn weight;\n}\n\nfloat getBlurLevel(float size) {\nreturn min(3.0,ceil(size/1.0));\n}\n\nvec4 getBlurColor(float size) {\nvec4 col=texture2D(textureSampler,distorted_coords);\nif (size == 0.0) { return col; }\n\n\nfloat blur_level=getBlurLevel(size);\nfloat w=(size/screen_width);\nfloat h=(size/screen_height);\nfloat total_weight=1.0;\nvec2 sample_coords;\ntotal_weight+=sampleScreen(col,vec2(-0.50*w,0.24*h),0.93);\ntotal_weight+=sampleScreen(col,vec2(0.30*w,-0.75*h),0.90);\ntotal_weight+=sampleScreen(col,vec2(0.36*w,0.96*h),0.87);\ntotal_weight+=sampleScreen(col,vec2(-1.08*w,-0.55*h),0.85);\ntotal_weight+=sampleScreen(col,vec2(1.33*w,-0.37*h),0.83);\ntotal_weight+=sampleScreen(col,vec2(-0.82*w,1.31*h),0.80);\ntotal_weight+=sampleScreen(col,vec2(-0.31*w,-1.67*h),0.78);\ntotal_weight+=sampleScreen(col,vec2(1.47*w,1.11*h),0.76);\ntotal_weight+=sampleScreen(col,vec2(-1.97*w,0.19*h),0.74);\ntotal_weight+=sampleScreen(col,vec2(1.42*w,-1.57*h),0.72);\nif (blur_level>1.0) {\ntotal_weight+=sampleScreen(col,vec2(0.01*w,2.25*h),0.70);\ntotal_weight+=sampleScreen(col,vec2(-1.62*w,-1.74*h),0.67);\ntotal_weight+=sampleScreen(col,vec2(2.49*w,0.20*h),0.65);\ntotal_weight+=sampleScreen(col,vec2(-2.07*w,1.61*h),0.63);\ntotal_weight+=sampleScreen(col,vec2(0.46*w,-2.70*h),0.61);\ntotal_weight+=sampleScreen(col,vec2(1.55*w,2.40*h),0.59);\ntotal_weight+=sampleScreen(col,vec2(-2.88*w,-0.75*h),0.56);\ntotal_weight+=sampleScreen(col,vec2(2.73*w,-1.44*h),0.54);\ntotal_weight+=sampleScreen(col,vec2(-1.08*w,3.02*h),0.52);\ntotal_weight+=sampleScreen(col,vec2(-1.28*w,-3.05*h),0.49);\n}\nif (blur_level>2.0) {\ntotal_weight+=sampleScreen(col,vec2(3.11*w,1.43*h),0.46);\ntotal_weight+=sampleScreen(col,vec2(-3.36*w,1.08*h),0.44);\ntotal_weight+=sampleScreen(col,vec2(1.80*w,-3.16*h),0.41);\ntotal_weight+=sampleScreen(col,vec2(0.83*w,3.65*h),0.38);\ntotal_weight+=sampleScreen(col,vec2(-3.16*w,-2.19*h),0.34);\ntotal_weight+=sampleScreen(col,vec2(3.92*w,-0.53*h),0.31);\ntotal_weight+=sampleScreen(col,vec2(-2.59*w,3.12*h),0.26);\ntotal_weight+=sampleScreen(col,vec2(-0.20*w,-4.15*h),0.22);\ntotal_weight+=sampleScreen(col,vec2(3.02*w,3.00*h),0.15);\n}\ncol/=total_weight;\n\nif (darken>0.0) {\ncol.rgb*=clamp(0.3,1.0,1.05-size*0.5*darken);\n}\n\n\n\n\nreturn col;\n}\nvoid main(void)\n{\n\ncentered_screen_pos=vec2(vUV.x-0.5,vUV.y-0.5);\nradius2=centered_screen_pos.x*centered_screen_pos.x+centered_screen_pos.y*centered_screen_pos.y;\nradius=sqrt(radius2);\ndistorted_coords=getDistortedCoords(vUV);\nvec2 texels_coords=vec2(vUV.x*screen_width,vUV.y*screen_height);\nfloat depth=texture2D(depthSampler,distorted_coords).r;\nfloat distance=near+(far-near)*depth;\nvec4 color=texture2D(textureSampler,vUV);\n\n\nfloat coc=abs(aperture*(screen_distance*(inverse_focal_length-1.0/distance)-1.0));\n\nif (dof_enabled == false || coc<0.07) { coc=0.0; }\n\nfloat edge_blur_amount=0.0;\nif (edge_blur>0.0) {\nedge_blur_amount=clamp((radius*2.0-1.0+0.15*edge_blur)*1.5,0.0,1.0)*1.3;\n}\n\nfloat blur_amount=max(edge_blur_amount,coc);\n\nif (blur_amount == 0.0) {\ngl_FragColor=texture2D(textureSampler,distorted_coords);\n}\nelse {\n\ngl_FragColor=getBlurColor(blur_amount*1.7);\n\nif (highlights) {\ngl_FragColor.rgb+=clamp(coc,0.0,1.0)*texture2D(highlightsSampler,distorted_coords).rgb;\n}\nif (blur_noise) {\n\nvec2 noise=rand(distorted_coords)*0.01*blur_amount;\nvec2 blurred_coord=vec2(distorted_coords.x+noise.x,distorted_coords.y+noise.y);\ngl_FragColor=0.04*texture2D(textureSampler,blurred_coord)+0.96*gl_FragColor;\n}\n}\n\nif (grain_amount>0.0) {\nvec4 grain_color=texture2D(grainSampler,texels_coords*0.003);\ngl_FragColor.rgb+=(-0.5+grain_color.rgb)*0.30*grain_amount;\n}\n}\n";
Effect.ShadersStore[name74] = shader74;

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/lensRenderingPipeline.js
var LensRenderingPipeline = function(_super) {
  __extends(LensRenderingPipeline2, _super);
  function LensRenderingPipeline2(name98, parameters, scene, ratio, cameras) {
    if (ratio === void 0) {
      ratio = 1;
    }
    var _this = _super.call(this, scene.getEngine(), name98) || this;
    _this.LensChromaticAberrationEffect = "LensChromaticAberrationEffect";
    _this.HighlightsEnhancingEffect = "HighlightsEnhancingEffect";
    _this.LensDepthOfFieldEffect = "LensDepthOfFieldEffect";
    _this._pentagonBokehIsEnabled = false;
    _this._scene = scene;
    _this._depthTexture = scene.enableDepthRenderer().getDepthMap();
    if (parameters.grain_texture) {
      _this._grainTexture = parameters.grain_texture;
    } else {
      _this._createGrainTexture();
    }
    _this._edgeBlur = parameters.edge_blur ? parameters.edge_blur : 0;
    _this._grainAmount = parameters.grain_amount ? parameters.grain_amount : 0;
    _this._chromaticAberration = parameters.chromatic_aberration ? parameters.chromatic_aberration : 0;
    _this._distortion = parameters.distortion ? parameters.distortion : 0;
    _this._highlightsGain = parameters.dof_gain !== void 0 ? parameters.dof_gain : -1;
    _this._highlightsThreshold = parameters.dof_threshold ? parameters.dof_threshold : 1;
    _this._dofDistance = parameters.dof_focus_distance !== void 0 ? parameters.dof_focus_distance : -1;
    _this._dofAperture = parameters.dof_aperture ? parameters.dof_aperture : 1;
    _this._dofDarken = parameters.dof_darken ? parameters.dof_darken : 0;
    _this._dofPentagon = parameters.dof_pentagon !== void 0 ? parameters.dof_pentagon : true;
    _this._blurNoise = parameters.blur_noise !== void 0 ? parameters.blur_noise : true;
    _this._createChromaticAberrationPostProcess(ratio);
    _this._createHighlightsPostProcess(ratio);
    _this._createDepthOfFieldPostProcess(ratio / 4);
    _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.LensChromaticAberrationEffect, function() {
      return _this._chromaticAberrationPostProcess;
    }, true));
    _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.HighlightsEnhancingEffect, function() {
      return _this._highlightsPostProcess;
    }, true));
    _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.LensDepthOfFieldEffect, function() {
      return _this._depthOfFieldPostProcess;
    }, true));
    if (_this._highlightsGain === -1) {
      _this._disableEffect(_this.HighlightsEnhancingEffect, null);
    }
    scene.postProcessRenderPipelineManager.addPipeline(_this);
    if (cameras) {
      scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(name98, cameras);
    }
    return _this;
  }
  LensRenderingPipeline2.prototype.getClassName = function() {
    return "LensRenderingPipeline";
  };
  Object.defineProperty(LensRenderingPipeline2.prototype, "scene", {
    get: function() {
      return this._scene;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LensRenderingPipeline2.prototype, "edgeBlur", {
    get: function() {
      return this._edgeBlur;
    },
    set: function(value) {
      this.setEdgeBlur(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LensRenderingPipeline2.prototype, "grainAmount", {
    get: function() {
      return this._grainAmount;
    },
    set: function(value) {
      this.setGrainAmount(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LensRenderingPipeline2.prototype, "chromaticAberration", {
    get: function() {
      return this._chromaticAberration;
    },
    set: function(value) {
      this.setChromaticAberration(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LensRenderingPipeline2.prototype, "dofAperture", {
    get: function() {
      return this._dofAperture;
    },
    set: function(value) {
      this.setAperture(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LensRenderingPipeline2.prototype, "edgeDistortion", {
    get: function() {
      return this._distortion;
    },
    set: function(value) {
      this.setEdgeDistortion(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LensRenderingPipeline2.prototype, "dofDistortion", {
    get: function() {
      return this._dofDistance;
    },
    set: function(value) {
      this.setFocusDistance(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LensRenderingPipeline2.prototype, "darkenOutOfFocus", {
    get: function() {
      return this._dofDarken;
    },
    set: function(value) {
      this.setDarkenOutOfFocus(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LensRenderingPipeline2.prototype, "blurNoise", {
    get: function() {
      return this._blurNoise;
    },
    set: function(value) {
      this._blurNoise = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LensRenderingPipeline2.prototype, "pentagonBokeh", {
    get: function() {
      return this._pentagonBokehIsEnabled;
    },
    set: function(value) {
      if (value) {
        this.enablePentagonBokeh();
      } else {
        this.disablePentagonBokeh();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LensRenderingPipeline2.prototype, "highlightsGain", {
    get: function() {
      return this._highlightsGain;
    },
    set: function(value) {
      this.setHighlightsGain(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LensRenderingPipeline2.prototype, "highlightsThreshold", {
    get: function() {
      return this._highlightsThreshold;
    },
    set: function(value) {
      this.setHighlightsThreshold(value);
    },
    enumerable: false,
    configurable: true
  });
  LensRenderingPipeline2.prototype.setEdgeBlur = function(amount) {
    this._edgeBlur = amount;
  };
  LensRenderingPipeline2.prototype.disableEdgeBlur = function() {
    this._edgeBlur = 0;
  };
  LensRenderingPipeline2.prototype.setGrainAmount = function(amount) {
    this._grainAmount = amount;
  };
  LensRenderingPipeline2.prototype.disableGrain = function() {
    this._grainAmount = 0;
  };
  LensRenderingPipeline2.prototype.setChromaticAberration = function(amount) {
    this._chromaticAberration = amount;
  };
  LensRenderingPipeline2.prototype.disableChromaticAberration = function() {
    this._chromaticAberration = 0;
  };
  LensRenderingPipeline2.prototype.setEdgeDistortion = function(amount) {
    this._distortion = amount;
  };
  LensRenderingPipeline2.prototype.disableEdgeDistortion = function() {
    this._distortion = 0;
  };
  LensRenderingPipeline2.prototype.setFocusDistance = function(amount) {
    this._dofDistance = amount;
  };
  LensRenderingPipeline2.prototype.disableDepthOfField = function() {
    this._dofDistance = -1;
  };
  LensRenderingPipeline2.prototype.setAperture = function(amount) {
    this._dofAperture = amount;
  };
  LensRenderingPipeline2.prototype.setDarkenOutOfFocus = function(amount) {
    this._dofDarken = amount;
  };
  LensRenderingPipeline2.prototype.enablePentagonBokeh = function() {
    this._highlightsPostProcess.updateEffect("#define PENTAGON\n");
    this._pentagonBokehIsEnabled = true;
  };
  LensRenderingPipeline2.prototype.disablePentagonBokeh = function() {
    this._pentagonBokehIsEnabled = false;
    this._highlightsPostProcess.updateEffect();
  };
  LensRenderingPipeline2.prototype.enableNoiseBlur = function() {
    this._blurNoise = true;
  };
  LensRenderingPipeline2.prototype.disableNoiseBlur = function() {
    this._blurNoise = false;
  };
  LensRenderingPipeline2.prototype.setHighlightsGain = function(amount) {
    this._highlightsGain = amount;
  };
  LensRenderingPipeline2.prototype.setHighlightsThreshold = function(amount) {
    if (this._highlightsGain === -1) {
      this._highlightsGain = 1;
    }
    this._highlightsThreshold = amount;
  };
  LensRenderingPipeline2.prototype.disableHighlights = function() {
    this._highlightsGain = -1;
  };
  LensRenderingPipeline2.prototype.dispose = function(disableDepthRender) {
    if (disableDepthRender === void 0) {
      disableDepthRender = false;
    }
    this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._scene.cameras);
    this._chromaticAberrationPostProcess = null;
    this._highlightsPostProcess = null;
    this._depthOfFieldPostProcess = null;
    this._grainTexture.dispose();
    if (disableDepthRender) {
      this._scene.disableDepthRenderer();
    }
  };
  LensRenderingPipeline2.prototype._createChromaticAberrationPostProcess = function(ratio) {
    var _this = this;
    this._chromaticAberrationPostProcess = new PostProcess("LensChromaticAberration", "chromaticAberration", ["chromatic_aberration", "screen_width", "screen_height", "direction", "radialIntensity", "centerPosition"], [], ratio, null, Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), false);
    this._chromaticAberrationPostProcess.onApply = function(effect) {
      effect.setFloat("chromatic_aberration", _this._chromaticAberration);
      effect.setFloat("screen_width", _this._scene.getEngine().getRenderWidth());
      effect.setFloat("screen_height", _this._scene.getEngine().getRenderHeight());
      effect.setFloat("radialIntensity", 1);
      effect.setFloat2("direction", 17, 17);
      effect.setFloat2("centerPosition", 0.5, 0.5);
    };
  };
  LensRenderingPipeline2.prototype._createHighlightsPostProcess = function(ratio) {
    var _this = this;
    this._highlightsPostProcess = new PostProcess("LensHighlights", "lensHighlights", ["gain", "threshold", "screen_width", "screen_height"], [], ratio, null, Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, this._dofPentagon ? "#define PENTAGON\n" : "");
    this._highlightsPostProcess.onApply = function(effect) {
      effect.setFloat("gain", _this._highlightsGain);
      effect.setFloat("threshold", _this._highlightsThreshold);
      effect.setTextureFromPostProcess("textureSampler", _this._chromaticAberrationPostProcess);
      effect.setFloat("screen_width", _this._scene.getEngine().getRenderWidth());
      effect.setFloat("screen_height", _this._scene.getEngine().getRenderHeight());
    };
  };
  LensRenderingPipeline2.prototype._createDepthOfFieldPostProcess = function(ratio) {
    var _this = this;
    this._depthOfFieldPostProcess = new PostProcess("LensDepthOfField", "depthOfField", [
      "grain_amount",
      "blur_noise",
      "screen_width",
      "screen_height",
      "distortion",
      "dof_enabled",
      "screen_distance",
      "aperture",
      "darken",
      "edge_blur",
      "highlights",
      "near",
      "far"
    ], ["depthSampler", "grainSampler", "highlightsSampler"], ratio, null, Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), false);
    this._depthOfFieldPostProcess.onApply = function(effect) {
      effect.setTexture("depthSampler", _this._depthTexture);
      effect.setTexture("grainSampler", _this._grainTexture);
      effect.setTextureFromPostProcess("textureSampler", _this._highlightsPostProcess);
      effect.setTextureFromPostProcess("highlightsSampler", _this._depthOfFieldPostProcess);
      effect.setFloat("grain_amount", _this._grainAmount);
      effect.setBool("blur_noise", _this._blurNoise);
      effect.setFloat("screen_width", _this._scene.getEngine().getRenderWidth());
      effect.setFloat("screen_height", _this._scene.getEngine().getRenderHeight());
      effect.setFloat("distortion", _this._distortion);
      effect.setBool("dof_enabled", _this._dofDistance !== -1);
      effect.setFloat("screen_distance", 1 / (0.1 - 1 / _this._dofDistance));
      effect.setFloat("aperture", _this._dofAperture);
      effect.setFloat("darken", _this._dofDarken);
      effect.setFloat("edge_blur", _this._edgeBlur);
      effect.setBool("highlights", _this._highlightsGain !== -1);
      if (_this._scene.activeCamera) {
        effect.setFloat("near", _this._scene.activeCamera.minZ);
        effect.setFloat("far", _this._scene.activeCamera.maxZ);
      }
    };
  };
  LensRenderingPipeline2.prototype._createGrainTexture = function() {
    var size = 512;
    this._grainTexture = new DynamicTexture("LensNoiseTexture", size, this._scene, false, Texture.BILINEAR_SAMPLINGMODE);
    this._grainTexture.wrapU = Texture.WRAP_ADDRESSMODE;
    this._grainTexture.wrapV = Texture.WRAP_ADDRESSMODE;
    var context = this._grainTexture.getContext();
    var rand = function(min, max) {
      return Math.random() * (max - min) + min;
    };
    var value;
    for (var x = 0; x < size; x++) {
      for (var y = 0; y < size; y++) {
        value = Math.floor(rand(0.42, 0.58) * 255);
        context.fillStyle = "rgb(" + value + ", " + value + ", " + value + ")";
        context.fillRect(x, y, 1, 1);
      }
    }
    this._grainTexture.update(false);
  };
  return LensRenderingPipeline2;
}(PostProcessRenderPipeline);

// node_modules/@babylonjs/core/Rendering/ssao2Configuration.js
var SSAO2Configuration = function() {
  function SSAO2Configuration2() {
    this.enabled = false;
    this.name = "ssao2";
    this.texturesRequired = [
      5
    ];
  }
  return SSAO2Configuration2;
}();

// node_modules/@babylonjs/core/Shaders/ssao2.fragment.js
var name75 = "ssao2PixelShader";
var shader75 = "\nprecision highp float;\nuniform sampler2D textureSampler;\nuniform float near;\nuniform float far;\nuniform float radius;\nfloat scales[16]=float[16](\n0.1,\n0.11406250000000001,\n0.131640625,\n0.15625,\n0.187890625,\n0.2265625,\n0.272265625,\n0.325,\n0.384765625,\n0.4515625,\n0.525390625,\n0.60625,\n0.694140625,\n0.7890625,\n0.891015625,\n1.0\n);\nvarying vec2 vUV;\nfloat perspectiveDepthToViewZ( const in float invClipZ,const in float near,const in float far ) {\nreturn ( near*far )/( ( far-near )*invClipZ-far );\n}\nfloat viewZToPerspectiveDepth( const in float viewZ,const in float near,const in float far ) {\nreturn ( near*far/viewZ+far)/( far-near );\n}\nfloat viewZToOrthographicDepth( const in float viewZ,const in float near,const in float far ) {\nreturn ( viewZ+near )/( near-far );\n}\n#ifdef SSAO\nuniform sampler2D randomSampler;\n#ifndef GEOMETRYBUFFER\nuniform sampler2D depthNormalSampler;\n#else\nuniform sampler2D depthSampler;\nuniform sampler2D normalSampler;\n#endif\nuniform float randTextureTiles;\nuniform float samplesFactor;\nuniform vec3 sampleSphere[SAMPLES];\nuniform float totalStrength;\nuniform float base;\nuniform float xViewport;\nuniform float yViewport;\nuniform float maxZ;\nuniform float minZAspect;\nuniform vec2 texelSize;\nuniform mat4 projection;\nvoid main()\n{\nvec3 random=texture2D(randomSampler,vUV*randTextureTiles).rgb;\n#ifndef GEOMETRYBUFFER\nfloat depth=texture2D(depthNormalSampler,vUV).r;\n#else\nfloat depth=texture2D(depthSampler,vUV).r;\n#endif\nfloat depthSign=depth/abs(depth);\ndepth=depth*depthSign;\n#ifndef GEOMETRYBUFFER\nvec3 normal=texture2D(depthNormalSampler,vUV).gba;\n#else\nvec3 normal=texture2D(normalSampler,vUV).rgb;\n#endif\nfloat occlusion=0.0;\nfloat correctedRadius=min(radius,minZAspect*depth/near);\nvec3 vViewRay=vec3((vUV.x*2.0-1.0)*xViewport,(vUV.y*2.0-1.0)*yViewport,depthSign);\nvec3 origin=vViewRay*depth;\nvec3 rvec=random*2.0-1.0;\nrvec.z=0.0;\n\nfloat dotProduct=dot(rvec,normal);\nrvec=1.0-abs(dotProduct)>1e-2 ? rvec : vec3(-rvec.y,0.0,rvec.x);\nvec3 tangent=normalize(rvec-normal*dot(rvec,normal));\nvec3 bitangent=cross(normal,tangent);\nmat3 tbn=mat3(tangent,bitangent,normal);\nfloat difference;\nfor (int i=0; i<SAMPLES; ++i) {\n\nvec3 samplePosition=scales[(i+int(random.x*16.0)) % 16]*tbn*sampleSphere[(i+int(random.y*16.0)) % 16];\nsamplePosition=samplePosition*correctedRadius+origin;\n\nvec4 offset=vec4(samplePosition,1.0);\noffset=projection*offset;\noffset.xyz/=offset.w;\noffset.xy=offset.xy*0.5+0.5;\nif (offset.x<0.0 || offset.y<0.0 || offset.x>1.0 || offset.y>1.0) {\ncontinue;\n}\n\n#ifndef GEOMETRYBUFFER\nfloat sampleDepth=abs(texture2D(depthNormalSampler,offset.xy).r);\n#else\nfloat sampleDepth=abs(texture2D(depthSampler,offset.xy).r);\n#endif\n\ndifference=depthSign*samplePosition.z-sampleDepth;\nfloat rangeCheck=1.0-smoothstep(correctedRadius*0.5,correctedRadius,difference);\nocclusion+=(difference>=0.0 ? 1.0 : 0.0)*rangeCheck;\n}\nocclusion=occlusion*(1.0-smoothstep(maxZ*0.75,maxZ,depth));\nfloat ao=1.0-totalStrength*occlusion*samplesFactor;\nfloat result=clamp(ao+base,0.0,1.0);\ngl_FragColor=vec4(vec3(result),1.0);\n}\n#endif\n#ifdef BILATERAL_BLUR\nuniform sampler2D depthNormalSampler;\nuniform float outSize;\nuniform float samplerOffsets[SAMPLES];\nvec4 blur9(sampler2D image,vec2 uv,float resolution,vec2 direction) {\nvec4 color=vec4(0.0);\nvec2 off1=vec2(1.3846153846)*direction;\nvec2 off2=vec2(3.2307692308)*direction;\ncolor+=texture2D(image,uv)*0.2270270270;\ncolor+=texture2D(image,uv+(off1/resolution))*0.3162162162;\ncolor+=texture2D(image,uv-(off1/resolution))*0.3162162162;\ncolor+=texture2D(image,uv+(off2/resolution))*0.0702702703;\ncolor+=texture2D(image,uv-(off2/resolution))*0.0702702703;\nreturn color;\n}\nvec4 blur13(sampler2D image,vec2 uv,float resolution,vec2 direction) {\nvec4 color=vec4(0.0);\nvec2 off1=vec2(1.411764705882353)*direction;\nvec2 off2=vec2(3.2941176470588234)*direction;\nvec2 off3=vec2(5.176470588235294)*direction;\ncolor+=texture2D(image,uv)*0.1964825501511404;\ncolor+=texture2D(image,uv+(off1/resolution))*0.2969069646728344;\ncolor+=texture2D(image,uv-(off1/resolution))*0.2969069646728344;\ncolor+=texture2D(image,uv+(off2/resolution))*0.09447039785044732;\ncolor+=texture2D(image,uv-(off2/resolution))*0.09447039785044732;\ncolor+=texture2D(image,uv+(off3/resolution))*0.010381362401148057;\ncolor+=texture2D(image,uv-(off3/resolution))*0.010381362401148057;\nreturn color;\n}\nvec4 blur13Bilateral(sampler2D image,vec2 uv,float resolution,vec2 direction) {\nvec4 color=vec4(0.0);\nvec2 off1=vec2(1.411764705882353)*direction;\nvec2 off2=vec2(3.2941176470588234)*direction;\nvec2 off3=vec2(5.176470588235294)*direction;\nfloat compareDepth=abs(texture2D(depthNormalSampler,uv).r);\nfloat sampleDepth;\nfloat weight;\nfloat weightSum=30.0;\ncolor+=texture2D(image,uv)*30.0;\nsampleDepth=abs(texture2D(depthNormalSampler,uv+(off1/resolution)).r);\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\nweightSum+=weight;\ncolor+=texture2D(image,uv+(off1/resolution))*weight;\nsampleDepth=abs(texture2D(depthNormalSampler,uv-(off1/resolution)).r);\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\nweightSum+=weight;\ncolor+=texture2D(image,uv-(off1/resolution))*weight;\nsampleDepth=abs(texture2D(depthNormalSampler,uv+(off2/resolution)).r);\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\nweightSum+=weight;\ncolor+=texture2D(image,uv+(off2/resolution))*weight;\nsampleDepth=abs(texture2D(depthNormalSampler,uv-(off2/resolution)).r);\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\nweightSum+=weight;\ncolor+=texture2D(image,uv-(off2/resolution))*weight;\nsampleDepth=abs(texture2D(depthNormalSampler,uv+(off3/resolution)).r);\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\nweightSum+=weight;\ncolor+=texture2D(image,uv+(off3/resolution))*weight;\nsampleDepth=abs(texture2D(depthNormalSampler,uv-(off3/resolution)).r);\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\nweightSum+=weight;\ncolor+=texture2D(image,uv-(off3/resolution))*weight;\nreturn color/weightSum;\n}\nvoid main()\n{\n#if EXPENSIVE\nfloat compareDepth=abs(texture2D(depthNormalSampler,vUV).r);\nfloat texelsize=1.0/outSize;\nfloat result=0.0;\nfloat weightSum=0.0;\nfor (int i=0; i<SAMPLES; ++i)\n{\n#ifdef BILATERAL_BLUR_H\nvec2 direction=vec2(1.0,0.0);\nvec2 sampleOffset=vec2(texelsize*samplerOffsets[i],0.0);\n#else\nvec2 direction=vec2(0.0,1.0);\nvec2 sampleOffset=vec2(0.0,texelsize*samplerOffsets[i]);\n#endif\nvec2 samplePos=vUV+sampleOffset;\nfloat sampleDepth=abs(texture2D(depthNormalSampler,samplePos).r);\nfloat weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30000.0);\nresult+=texture2D(textureSampler,samplePos).r*weight;\nweightSum+=weight;\n}\nresult/=weightSum;\ngl_FragColor.rgb=vec3(result);\ngl_FragColor.a=1.0;\n#else\nvec4 color;\n#ifdef BILATERAL_BLUR_H\nvec2 direction=vec2(1.0,0.0);\ncolor=blur13Bilateral(textureSampler,vUV,outSize,direction);\n#else\nvec2 direction=vec2(0.0,1.0);\ncolor=blur13Bilateral(textureSampler,vUV,outSize,direction);\n#endif\ngl_FragColor.rgb=vec3(color.r);\ngl_FragColor.a=1.0;\n#endif\n}\n#endif\n";
Effect.ShadersStore[name75] = shader75;

// node_modules/@babylonjs/core/Shaders/ssaoCombine.fragment.js
var name76 = "ssaoCombinePixelShader";
var shader76 = "uniform sampler2D textureSampler;\nuniform sampler2D originalColor;\nuniform vec4 viewport;\nvarying vec2 vUV;\nvoid main(void) {\nvec4 ssaoColor=texture2D(textureSampler,viewport.xy+vUV*viewport.zw);\nvec4 sceneColor=texture2D(originalColor,vUV);\ngl_FragColor=sceneColor*ssaoColor;\n}\n";
Effect.ShadersStore[name76] = shader76;

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/ssao2RenderingPipeline.js
var SSAO2RenderingPipeline = function(_super) {
  __extends(SSAO2RenderingPipeline2, _super);
  function SSAO2RenderingPipeline2(name98, scene, ratio, cameras, forceGeometryBuffer) {
    if (forceGeometryBuffer === void 0) {
      forceGeometryBuffer = true;
    }
    var _this = _super.call(this, scene.getEngine(), name98) || this;
    _this.SSAOOriginalSceneColorEffect = "SSAOOriginalSceneColorEffect";
    _this.SSAORenderEffect = "SSAORenderEffect";
    _this.SSAOBlurHRenderEffect = "SSAOBlurHRenderEffect";
    _this.SSAOBlurVRenderEffect = "SSAOBlurVRenderEffect";
    _this.SSAOCombineRenderEffect = "SSAOCombineRenderEffect";
    _this.totalStrength = 1;
    _this.maxZ = 100;
    _this.minZAspect = 0.2;
    _this._samples = 8;
    _this._textureSamples = 1;
    _this._forceGeometryBuffer = false;
    _this._expensiveBlur = true;
    _this.radius = 2;
    _this.base = 0;
    _this._bits = new Uint32Array(1);
    _this._scene = scene;
    _this._ratio = ratio;
    _this._forceGeometryBuffer = forceGeometryBuffer;
    if (!_this.isSupported) {
      Logger.Error("SSAO 2 needs WebGL 2 support.");
      return _this;
    }
    var ssaoRatio = _this._ratio.ssaoRatio || ratio;
    var blurRatio = _this._ratio.blurRatio || ratio;
    if (_this._forceGeometryBuffer) {
      scene.enableGeometryBufferRenderer();
    } else {
      _this._prePassRenderer = scene.enablePrePassRenderer();
    }
    _this._createRandomTexture();
    _this._originalColorPostProcess = new PassPostProcess("SSAOOriginalSceneColor", 1, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false);
    _this._originalColorPostProcess.samples = _this.textureSamples;
    _this._createSSAOPostProcess(1);
    _this._createBlurPostProcess(ssaoRatio, blurRatio);
    _this._createSSAOCombinePostProcess(blurRatio);
    _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.SSAOOriginalSceneColorEffect, function() {
      return _this._originalColorPostProcess;
    }, true));
    _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.SSAORenderEffect, function() {
      return _this._ssaoPostProcess;
    }, true));
    _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.SSAOBlurHRenderEffect, function() {
      return _this._blurHPostProcess;
    }, true));
    _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.SSAOBlurVRenderEffect, function() {
      return _this._blurVPostProcess;
    }, true));
    _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.SSAOCombineRenderEffect, function() {
      return _this._ssaoCombinePostProcess;
    }, true));
    scene.postProcessRenderPipelineManager.addPipeline(_this);
    if (cameras) {
      scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(name98, cameras);
    }
    return _this;
  }
  Object.defineProperty(SSAO2RenderingPipeline2.prototype, "samples", {
    get: function() {
      return this._samples;
    },
    set: function(n) {
      this._samples = n;
      this._ssaoPostProcess.updateEffect(this._getDefinesForSSAO());
      this._sampleSphere = this._generateHemisphere();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SSAO2RenderingPipeline2.prototype, "textureSamples", {
    get: function() {
      return this._textureSamples;
    },
    set: function(n) {
      this._textureSamples = n;
      this._originalColorPostProcess.samples = n;
      this._blurHPostProcess.samples = n;
      this._blurVPostProcess.samples = n;
      this._ssaoPostProcess.samples = n;
      this._ssaoCombinePostProcess.samples = n;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SSAO2RenderingPipeline2.prototype, "expensiveBlur", {
    get: function() {
      return this._expensiveBlur;
    },
    set: function(b) {
      this._blurHPostProcess.updateEffect("#define BILATERAL_BLUR\n#define BILATERAL_BLUR_H\n#define SAMPLES 16\n#define EXPENSIVE " + (b ? "1" : "0") + "\n", null, ["textureSampler", "depthNormalSampler"]);
      this._blurVPostProcess.updateEffect("#define BILATERAL_BLUR\n#define SAMPLES 16\n#define EXPENSIVE " + (b ? "1" : "0") + "\n", null, ["textureSampler", "depthNormalSampler"]);
      this._expensiveBlur = b;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SSAO2RenderingPipeline2, "IsSupported", {
    get: function() {
      var engine = EngineStore.LastCreatedEngine;
      if (!engine) {
        return false;
      }
      return engine.webGLVersion >= 2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SSAO2RenderingPipeline2.prototype, "scene", {
    get: function() {
      return this._scene;
    },
    enumerable: false,
    configurable: true
  });
  SSAO2RenderingPipeline2.prototype.getClassName = function() {
    return "SSAO2RenderingPipeline";
  };
  SSAO2RenderingPipeline2.prototype.dispose = function(disableGeometryBufferRenderer) {
    if (disableGeometryBufferRenderer === void 0) {
      disableGeometryBufferRenderer = false;
    }
    for (var i = 0; i < this._scene.cameras.length; i++) {
      var camera = this._scene.cameras[i];
      this._originalColorPostProcess.dispose(camera);
      this._ssaoPostProcess.dispose(camera);
      this._blurHPostProcess.dispose(camera);
      this._blurVPostProcess.dispose(camera);
      this._ssaoCombinePostProcess.dispose(camera);
    }
    this._randomTexture.dispose();
    if (disableGeometryBufferRenderer) {
      this._scene.disableGeometryBufferRenderer();
    }
    this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._scene.cameras);
    _super.prototype.dispose.call(this);
  };
  SSAO2RenderingPipeline2.prototype._createBlurPostProcess = function(ssaoRatio, blurRatio) {
    var _this = this;
    this._samplerOffsets = [];
    var expensive = this.expensiveBlur;
    for (var i = -8; i < 8; i++) {
      this._samplerOffsets.push(i * 2 + 0.5);
    }
    this._blurHPostProcess = new PostProcess("BlurH", "ssao2", ["outSize", "samplerOffsets", "near", "far", "radius"], ["depthNormalSampler"], ssaoRatio, null, Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, "#define BILATERAL_BLUR\n#define BILATERAL_BLUR_H\n#define SAMPLES 16\n#define EXPENSIVE " + (expensive ? "1" : "0") + "\n");
    this._blurHPostProcess.onApply = function(effect) {
      if (!_this._scene.activeCamera) {
        return;
      }
      effect.setFloat("outSize", _this._ssaoCombinePostProcess.width > 0 ? _this._ssaoCombinePostProcess.width : _this._originalColorPostProcess.width);
      effect.setFloat("near", _this._scene.activeCamera.minZ);
      effect.setFloat("far", _this._scene.activeCamera.maxZ);
      effect.setFloat("radius", _this.radius);
      if (_this._forceGeometryBuffer) {
        effect.setTexture("depthNormalSampler", _this._scene.enableGeometryBufferRenderer().getGBuffer().textures[0]);
      } else {
        effect.setTexture("depthNormalSampler", _this._prePassRenderer.prePassRT.textures[_this._prePassRenderer.getIndex(5)]);
      }
      effect.setArray("samplerOffsets", _this._samplerOffsets);
    };
    this._blurVPostProcess = new PostProcess("BlurV", "ssao2", ["outSize", "samplerOffsets", "near", "far", "radius"], ["depthNormalSampler"], blurRatio, null, Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, "#define BILATERAL_BLUR\n#define BILATERAL_BLUR_V\n#define SAMPLES 16\n#define EXPENSIVE " + (expensive ? "1" : "0") + "\n");
    this._blurVPostProcess.onApply = function(effect) {
      if (!_this._scene.activeCamera) {
        return;
      }
      effect.setFloat("outSize", _this._ssaoCombinePostProcess.height > 0 ? _this._ssaoCombinePostProcess.height : _this._originalColorPostProcess.height);
      effect.setFloat("near", _this._scene.activeCamera.minZ);
      effect.setFloat("far", _this._scene.activeCamera.maxZ);
      effect.setFloat("radius", _this.radius);
      if (_this._forceGeometryBuffer) {
        effect.setTexture("depthNormalSampler", _this._scene.enableGeometryBufferRenderer().getGBuffer().textures[0]);
      } else {
        effect.setTexture("depthNormalSampler", _this._prePassRenderer.prePassRT.textures[_this._prePassRenderer.getIndex(5)]);
      }
      effect.setArray("samplerOffsets", _this._samplerOffsets);
    };
    this._blurHPostProcess.samples = this.textureSamples;
    this._blurVPostProcess.samples = this.textureSamples;
  };
  SSAO2RenderingPipeline2.prototype._rebuild = function() {
    _super.prototype._rebuild.call(this);
  };
  SSAO2RenderingPipeline2.prototype._radicalInverse_VdC = function(i) {
    this._bits[0] = i;
    this._bits[0] = (this._bits[0] << 16 | this._bits[0] >> 16) >>> 0;
    this._bits[0] = (this._bits[0] & 1431655765) << 1 | (this._bits[0] & 2863311530) >>> 1 >>> 0;
    this._bits[0] = (this._bits[0] & 858993459) << 2 | (this._bits[0] & 3435973836) >>> 2 >>> 0;
    this._bits[0] = (this._bits[0] & 252645135) << 4 | (this._bits[0] & 4042322160) >>> 4 >>> 0;
    this._bits[0] = (this._bits[0] & 16711935) << 8 | (this._bits[0] & 4278255360) >>> 8 >>> 0;
    return this._bits[0] * 23283064365386963e-26;
  };
  SSAO2RenderingPipeline2.prototype._hammersley = function(i, n) {
    return [i / n, this._radicalInverse_VdC(i)];
  };
  SSAO2RenderingPipeline2.prototype._hemisphereSample_uniform = function(u, v) {
    var phi = v * 2 * Math.PI;
    var cosTheta = 1 - (u * 0.85 + 0.15);
    var sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
    return new Vector3(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta);
  };
  SSAO2RenderingPipeline2.prototype._generateHemisphere = function() {
    var numSamples = this.samples;
    var result = [];
    var vector;
    var i = 0;
    while (i < numSamples) {
      if (numSamples < 16) {
        vector = this._hemisphereSample_uniform(Math.random(), Math.random());
      } else {
        var rand = this._hammersley(i, numSamples);
        vector = this._hemisphereSample_uniform(rand[0], rand[1]);
      }
      result.push(vector.x, vector.y, vector.z);
      i++;
    }
    return result;
  };
  SSAO2RenderingPipeline2.prototype._getDefinesForSSAO = function() {
    var defines = "#define SAMPLES " + this.samples + "\n#define SSAO";
    if (this._forceGeometryBuffer) {
      defines = defines + "\n#define GEOMETRYBUFFER";
    }
    return defines;
  };
  SSAO2RenderingPipeline2.prototype._createSSAOPostProcess = function(ratio) {
    var _this = this;
    this._sampleSphere = this._generateHemisphere();
    var defines = this._getDefinesForSSAO();
    var samplers;
    if (this._forceGeometryBuffer) {
      samplers = ["randomSampler", "depthSampler", "normalSampler"];
    } else {
      samplers = ["randomSampler", "depthNormalSampler"];
    }
    this._ssaoPostProcess = new PostProcess("ssao2", "ssao2", [
      "sampleSphere",
      "samplesFactor",
      "randTextureTiles",
      "totalStrength",
      "radius",
      "base",
      "range",
      "projection",
      "near",
      "far",
      "texelSize",
      "xViewport",
      "yViewport",
      "maxZ",
      "minZAspect"
    ], samplers, ratio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, defines);
    this._ssaoPostProcess.onApply = function(effect) {
      if (!_this._scene.activeCamera) {
        return;
      }
      effect.setArray3("sampleSphere", _this._sampleSphere);
      effect.setFloat("randTextureTiles", 32);
      effect.setFloat("samplesFactor", 1 / _this.samples);
      effect.setFloat("totalStrength", _this.totalStrength);
      effect.setFloat2("texelSize", 1 / _this._ssaoPostProcess.width, 1 / _this._ssaoPostProcess.height);
      effect.setFloat("radius", _this.radius);
      effect.setFloat("maxZ", _this.maxZ);
      effect.setFloat("minZAspect", _this.minZAspect);
      effect.setFloat("base", _this.base);
      effect.setFloat("near", _this._scene.activeCamera.minZ);
      effect.setFloat("far", _this._scene.activeCamera.maxZ);
      effect.setFloat("xViewport", Math.tan(_this._scene.activeCamera.fov / 2) * _this._scene.getEngine().getAspectRatio(_this._scene.activeCamera, true));
      effect.setFloat("yViewport", Math.tan(_this._scene.activeCamera.fov / 2));
      effect.setMatrix("projection", _this._scene.getProjectionMatrix());
      if (_this._forceGeometryBuffer) {
        effect.setTexture("depthSampler", _this._scene.enableGeometryBufferRenderer().getGBuffer().textures[0]);
        effect.setTexture("normalSampler", _this._scene.enableGeometryBufferRenderer().getGBuffer().textures[1]);
      } else {
        effect.setTexture("depthNormalSampler", _this._prePassRenderer.prePassRT.textures[_this._prePassRenderer.getIndex(5)]);
      }
      effect.setTexture("randomSampler", _this._randomTexture);
    };
    this._ssaoPostProcess.samples = this.textureSamples;
  };
  SSAO2RenderingPipeline2.prototype._createSSAOCombinePostProcess = function(ratio) {
    var _this = this;
    this._ssaoCombinePostProcess = new PostProcess("ssaoCombine", "ssaoCombine", [], ["originalColor", "viewport"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false);
    this._ssaoCombinePostProcess.onApply = function(effect) {
      var viewport = _this._scene.activeCamera.viewport;
      effect.setVector4("viewport", TmpVectors.Vector4[0].copyFromFloats(viewport.x, viewport.y, viewport.width, viewport.height));
      effect.setTextureFromPostProcessOutput("originalColor", _this._originalColorPostProcess);
    };
    this._ssaoCombinePostProcess.samples = this.textureSamples;
    if (!this._forceGeometryBuffer) {
      this._ssaoCombinePostProcess._prePassEffectConfiguration = new SSAO2Configuration();
    }
  };
  SSAO2RenderingPipeline2.prototype._createRandomTexture = function() {
    var size = 128;
    this._randomTexture = new DynamicTexture("SSAORandomTexture", size, this._scene, false, Texture.TRILINEAR_SAMPLINGMODE);
    this._randomTexture.wrapU = Texture.WRAP_ADDRESSMODE;
    this._randomTexture.wrapV = Texture.WRAP_ADDRESSMODE;
    var context = this._randomTexture.getContext();
    var rand = function(min, max) {
      return Math.random() * (max - min) + min;
    };
    var randVector = Vector3.Zero();
    for (var x = 0; x < size; x++) {
      for (var y = 0; y < size; y++) {
        randVector.x = rand(0, 1);
        randVector.y = rand(0, 1);
        randVector.z = 0;
        randVector.normalize();
        randVector.scaleInPlace(255);
        randVector.x = Math.floor(randVector.x);
        randVector.y = Math.floor(randVector.y);
        context.fillStyle = "rgb(" + randVector.x + ", " + randVector.y + ", " + randVector.z + ")";
        context.fillRect(x, y, 1, 1);
      }
    }
    this._randomTexture.update(false);
  };
  SSAO2RenderingPipeline2.prototype.serialize = function() {
    var serializationObject = SerializationHelper.Serialize(this);
    serializationObject.customType = "SSAO2RenderingPipeline";
    return serializationObject;
  };
  SSAO2RenderingPipeline2.Parse = function(source, scene, rootUrl) {
    return SerializationHelper.Parse(function() {
      return new SSAO2RenderingPipeline2(source._name, scene, source._ratio);
    }, source, scene, rootUrl);
  };
  __decorate([
    serialize()
  ], SSAO2RenderingPipeline2.prototype, "totalStrength", void 0);
  __decorate([
    serialize()
  ], SSAO2RenderingPipeline2.prototype, "maxZ", void 0);
  __decorate([
    serialize()
  ], SSAO2RenderingPipeline2.prototype, "minZAspect", void 0);
  __decorate([
    serialize("samples")
  ], SSAO2RenderingPipeline2.prototype, "_samples", void 0);
  __decorate([
    serialize("textureSamples")
  ], SSAO2RenderingPipeline2.prototype, "_textureSamples", void 0);
  __decorate([
    serialize()
  ], SSAO2RenderingPipeline2.prototype, "_ratio", void 0);
  __decorate([
    serialize("expensiveBlur")
  ], SSAO2RenderingPipeline2.prototype, "_expensiveBlur", void 0);
  __decorate([
    serialize()
  ], SSAO2RenderingPipeline2.prototype, "radius", void 0);
  __decorate([
    serialize()
  ], SSAO2RenderingPipeline2.prototype, "base", void 0);
  return SSAO2RenderingPipeline2;
}(PostProcessRenderPipeline);
_TypeStore.RegisteredTypes["BABYLON.SSAO2RenderingPipeline"] = SSAO2RenderingPipeline;

// node_modules/@babylonjs/core/Shaders/ssao.fragment.js
var name77 = "ssaoPixelShader";
var shader77 = "\nuniform sampler2D textureSampler;\nvarying vec2 vUV;\n#ifdef SSAO\nuniform sampler2D randomSampler;\nuniform float randTextureTiles;\nuniform float samplesFactor;\nuniform vec3 sampleSphere[SAMPLES];\nuniform float totalStrength;\nuniform float radius;\nuniform float area;\nuniform float fallOff;\nuniform float base;\nvec3 normalFromDepth(float depth,vec2 coords)\n{\nvec2 offset1=vec2(0.0,radius);\nvec2 offset2=vec2(radius,0.0);\nfloat depth1=texture2D(textureSampler,coords+offset1).r;\nfloat depth2=texture2D(textureSampler,coords+offset2).r;\nvec3 p1=vec3(offset1,depth1-depth);\nvec3 p2=vec3(offset2,depth2-depth);\nvec3 normal=cross(p1,p2);\nnormal.z=-normal.z;\nreturn normalize(normal);\n}\nvoid main()\n{\nvec3 random=normalize(texture2D(randomSampler,vUV*randTextureTiles).rgb);\nfloat depth=texture2D(textureSampler,vUV).r;\nvec3 position=vec3(vUV,depth);\nvec3 normal=normalFromDepth(depth,vUV);\nfloat radiusDepth=radius/depth;\nfloat occlusion=0.0;\nvec3 ray;\nvec3 hemiRay;\nfloat occlusionDepth;\nfloat difference;\nfor (int i=0; i<SAMPLES; i++)\n{\nray=radiusDepth*reflect(sampleSphere[i],random);\nhemiRay=position+sign(dot(ray,normal))*ray;\nocclusionDepth=texture2D(textureSampler,clamp(hemiRay.xy,vec2(0.001,0.001),vec2(0.999,0.999))).r;\ndifference=depth-occlusionDepth;\nocclusion+=step(fallOff,difference)*(1.0-smoothstep(fallOff,area,difference));\n}\nfloat ao=1.0-totalStrength*occlusion*samplesFactor;\nfloat result=clamp(ao+base,0.0,1.0);\ngl_FragColor.r=result;\ngl_FragColor.g=result;\ngl_FragColor.b=result;\ngl_FragColor.a=1.0;\n}\n#endif\n";
Effect.ShadersStore[name77] = shader77;

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/ssaoRenderingPipeline.js
var SSAORenderingPipeline = function(_super) {
  __extends(SSAORenderingPipeline2, _super);
  function SSAORenderingPipeline2(name98, scene, ratio, cameras) {
    var _this = _super.call(this, scene.getEngine(), name98) || this;
    _this.SSAOOriginalSceneColorEffect = "SSAOOriginalSceneColorEffect";
    _this.SSAORenderEffect = "SSAORenderEffect";
    _this.SSAOBlurHRenderEffect = "SSAOBlurHRenderEffect";
    _this.SSAOBlurVRenderEffect = "SSAOBlurVRenderEffect";
    _this.SSAOCombineRenderEffect = "SSAOCombineRenderEffect";
    _this.totalStrength = 1;
    _this.radius = 1e-4;
    _this.area = 75e-4;
    _this.fallOff = 1e-6;
    _this.base = 0.5;
    _this._firstUpdate = true;
    _this._scene = scene;
    _this._createRandomTexture();
    _this._depthTexture = scene.enableDepthRenderer().getDepthMap();
    var ssaoRatio = ratio.ssaoRatio || ratio;
    var combineRatio = ratio.combineRatio || ratio;
    _this._originalColorPostProcess = new PassPostProcess("SSAOOriginalSceneColor", combineRatio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false);
    _this._createSSAOPostProcess(ssaoRatio);
    _this._createBlurPostProcess(ssaoRatio);
    _this._createSSAOCombinePostProcess(combineRatio);
    _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.SSAOOriginalSceneColorEffect, function() {
      return _this._originalColorPostProcess;
    }, true));
    _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.SSAORenderEffect, function() {
      return _this._ssaoPostProcess;
    }, true));
    _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.SSAOBlurHRenderEffect, function() {
      return _this._blurHPostProcess;
    }, true));
    _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.SSAOBlurVRenderEffect, function() {
      return _this._blurVPostProcess;
    }, true));
    _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.SSAOCombineRenderEffect, function() {
      return _this._ssaoCombinePostProcess;
    }, true));
    scene.postProcessRenderPipelineManager.addPipeline(_this);
    if (cameras) {
      scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(name98, cameras);
    }
    return _this;
  }
  Object.defineProperty(SSAORenderingPipeline2.prototype, "scene", {
    get: function() {
      return this._scene;
    },
    enumerable: false,
    configurable: true
  });
  SSAORenderingPipeline2.prototype.getClassName = function() {
    return "SSAORenderingPipeline";
  };
  SSAORenderingPipeline2.prototype.dispose = function(disableDepthRender) {
    if (disableDepthRender === void 0) {
      disableDepthRender = false;
    }
    for (var i = 0; i < this._scene.cameras.length; i++) {
      var camera = this._scene.cameras[i];
      this._originalColorPostProcess.dispose(camera);
      this._ssaoPostProcess.dispose(camera);
      this._blurHPostProcess.dispose(camera);
      this._blurVPostProcess.dispose(camera);
      this._ssaoCombinePostProcess.dispose(camera);
    }
    this._randomTexture.dispose();
    if (disableDepthRender) {
      this._scene.disableDepthRenderer();
    }
    this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._scene.cameras);
    _super.prototype.dispose.call(this);
  };
  SSAORenderingPipeline2.prototype._createBlurPostProcess = function(ratio) {
    var _this = this;
    var size = 16;
    this._blurHPostProcess = new BlurPostProcess("BlurH", new Vector2(1, 0), size, ratio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, 0);
    this._blurVPostProcess = new BlurPostProcess("BlurV", new Vector2(0, 1), size, ratio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, 0);
    this._blurHPostProcess.onActivateObservable.add(function() {
      var dw = _this._blurHPostProcess.width / _this._scene.getEngine().getRenderWidth();
      _this._blurHPostProcess.kernel = size * dw;
    });
    this._blurVPostProcess.onActivateObservable.add(function() {
      var dw = _this._blurVPostProcess.height / _this._scene.getEngine().getRenderHeight();
      _this._blurVPostProcess.kernel = size * dw;
    });
  };
  SSAORenderingPipeline2.prototype._rebuild = function() {
    this._firstUpdate = true;
    _super.prototype._rebuild.call(this);
  };
  SSAORenderingPipeline2.prototype._createSSAOPostProcess = function(ratio) {
    var _this = this;
    var numSamples = 16;
    var sampleSphere = [
      0.5381,
      0.1856,
      -0.4319,
      0.1379,
      0.2486,
      0.443,
      0.3371,
      0.5679,
      -57e-4,
      -0.6999,
      -0.0451,
      -19e-4,
      0.0689,
      -0.1598,
      -0.8547,
      0.056,
      69e-4,
      -0.1843,
      -0.0146,
      0.1402,
      0.0762,
      0.01,
      -0.1924,
      -0.0344,
      -0.3577,
      -0.5301,
      -0.4358,
      -0.3169,
      0.1063,
      0.0158,
      0.0103,
      -0.5869,
      46e-4,
      -0.0897,
      -0.494,
      0.3287,
      0.7119,
      -0.0154,
      -0.0918,
      -0.0533,
      0.0596,
      -0.5411,
      0.0352,
      -0.0631,
      0.546,
      -0.4776,
      0.2847,
      -0.0271
    ];
    var samplesFactor = 1 / numSamples;
    this._ssaoPostProcess = new PostProcess("ssao", "ssao", [
      "sampleSphere",
      "samplesFactor",
      "randTextureTiles",
      "totalStrength",
      "radius",
      "area",
      "fallOff",
      "base",
      "range",
      "viewport"
    ], ["randomSampler"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, "#define SAMPLES " + numSamples + "\n#define SSAO");
    this._ssaoPostProcess.onApply = function(effect) {
      if (_this._firstUpdate) {
        effect.setArray3("sampleSphere", sampleSphere);
        effect.setFloat("samplesFactor", samplesFactor);
        effect.setFloat("randTextureTiles", 4);
      }
      effect.setFloat("totalStrength", _this.totalStrength);
      effect.setFloat("radius", _this.radius);
      effect.setFloat("area", _this.area);
      effect.setFloat("fallOff", _this.fallOff);
      effect.setFloat("base", _this.base);
      effect.setTexture("textureSampler", _this._depthTexture);
      effect.setTexture("randomSampler", _this._randomTexture);
    };
  };
  SSAORenderingPipeline2.prototype._createSSAOCombinePostProcess = function(ratio) {
    var _this = this;
    this._ssaoCombinePostProcess = new PostProcess("ssaoCombine", "ssaoCombine", [], ["originalColor", "viewport"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false);
    this._ssaoCombinePostProcess.onApply = function(effect) {
      effect.setVector4("viewport", TmpVectors.Vector4[0].copyFromFloats(0, 0, 1, 1));
      effect.setTextureFromPostProcess("originalColor", _this._originalColorPostProcess);
    };
  };
  SSAORenderingPipeline2.prototype._createRandomTexture = function() {
    var size = 512;
    this._randomTexture = new DynamicTexture("SSAORandomTexture", size, this._scene, false, Texture.TRILINEAR_SAMPLINGMODE);
    this._randomTexture.wrapU = Texture.WRAP_ADDRESSMODE;
    this._randomTexture.wrapV = Texture.WRAP_ADDRESSMODE;
    var context = this._randomTexture.getContext();
    var rand = function(min, max) {
      return Math.random() * (max - min) + min;
    };
    var randVector = Vector3.Zero();
    for (var x = 0; x < size; x++) {
      for (var y = 0; y < size; y++) {
        randVector.x = Math.floor(rand(-1, 1) * 255);
        randVector.y = Math.floor(rand(-1, 1) * 255);
        randVector.z = Math.floor(rand(-1, 1) * 255);
        context.fillStyle = "rgb(" + randVector.x + ", " + randVector.y + ", " + randVector.z + ")";
        context.fillRect(x, y, 1, 1);
      }
    }
    this._randomTexture.update(false);
  };
  __decorate([
    serialize()
  ], SSAORenderingPipeline2.prototype, "totalStrength", void 0);
  __decorate([
    serialize()
  ], SSAORenderingPipeline2.prototype, "radius", void 0);
  __decorate([
    serialize()
  ], SSAORenderingPipeline2.prototype, "area", void 0);
  __decorate([
    serialize()
  ], SSAORenderingPipeline2.prototype, "fallOff", void 0);
  __decorate([
    serialize()
  ], SSAORenderingPipeline2.prototype, "base", void 0);
  return SSAORenderingPipeline2;
}(PostProcessRenderPipeline);

// node_modules/@babylonjs/core/Rendering/screenSpaceReflectionsConfiguration.js
var ScreenSpaceReflectionsConfiguration = function() {
  function ScreenSpaceReflectionsConfiguration2() {
    this.enabled = false;
    this.name = "screenSpaceReflections";
    this.texturesRequired = [
      5,
      3,
      1
    ];
  }
  return ScreenSpaceReflectionsConfiguration2;
}();

// node_modules/@babylonjs/core/Shaders/screenSpaceReflection.fragment.js
var name78 = "screenSpaceReflectionPixelShader";
var shader78 = "\n\nuniform sampler2D textureSampler;\nuniform sampler2D normalSampler;\nuniform sampler2D positionSampler;\nuniform sampler2D reflectivitySampler;\nuniform mat4 view;\nuniform mat4 projection;\nuniform float step;\nuniform float strength;\nuniform float threshold;\nuniform float roughnessFactor;\nuniform float reflectionSpecularFalloffExponent;\n\nvarying vec2 vUV;\n\nstruct ReflectionInfo {\nvec3 color;\nvec4 coords;\n};\n\nvec3 fresnelSchlick(float cosTheta,vec3 F0)\n{\nreturn F0+(1.0-F0)*pow(1.0-cosTheta,5.0);\n}\n\nReflectionInfo smoothReflectionInfo(vec3 dir,vec3 hitCoord)\n{\nReflectionInfo info;\ninfo.color=vec3(0.0);\nvec4 projectedCoord;\nfloat sampledDepth;\nfor(int i=0; i<SMOOTH_STEPS; i++)\n{\nprojectedCoord=projection*vec4(hitCoord,1.0);\nprojectedCoord.xy/=projectedCoord.w;\nprojectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);\nsampledDepth=(view*texture2D(positionSampler,projectedCoord.xy)).z;\nfloat depth=sampledDepth-hitCoord.z;\ndir*=0.5;\nif(depth>0.0)\nhitCoord-=dir;\nelse\nhitCoord+=dir;\ninfo.color+=texture2D(textureSampler,projectedCoord.xy).rgb;\n}\nprojectedCoord=projection*vec4(hitCoord,1.0);\nprojectedCoord.xy/=projectedCoord.w;\nprojectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);\n\ninfo.coords=vec4(projectedCoord.xy,sampledDepth,1.0);\ninfo.color+=texture2D(textureSampler,projectedCoord.xy).rgb;\ninfo.color/=float(SMOOTH_STEPS+1);\nreturn info;\n}\n\nReflectionInfo getReflectionInfo(vec3 dir,vec3 hitCoord)\n{\nReflectionInfo info;\nvec4 projectedCoord;\nfloat sampledDepth;\ndir*=step;\nfor(int i=0; i<REFLECTION_SAMPLES; i++)\n{\nhitCoord+=dir;\nprojectedCoord=projection*vec4(hitCoord,1.0);\nprojectedCoord.xy/=projectedCoord.w;\nprojectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);\nsampledDepth=(view*texture2D(positionSampler,projectedCoord.xy)).z;\nfloat depth=sampledDepth-hitCoord.z;\nif(((depth-dir.z)<threshold) && depth<=0.0)\n{\n#ifdef ENABLE_SMOOTH_REFLECTIONS\nreturn smoothReflectionInfo(dir,hitCoord);\n#else\ninfo.color=texture2D(textureSampler,projectedCoord.xy).rgb;\ninfo.coords=vec4(projectedCoord.xy,sampledDepth,0.0);\nreturn info;\n#endif\n}\n}\ninfo.color=texture2D(textureSampler,projectedCoord.xy).rgb;\ninfo.coords=vec4(projectedCoord.xy,sampledDepth,0.0);\nreturn info;\n}\nvec3 hash(vec3 a)\n{\na=fract(a*0.8);\na+=dot(a,a.yxz+19.19);\nreturn fract((a.xxy+a.yxx)*a.zyx);\n}\nvoid main()\n{\n#ifdef SSR_SUPPORTED\n\nvec4 albedoFull=texture2D(textureSampler,vUV);\nvec3 albedo=albedoFull.rgb;\nfloat spec=texture2D(reflectivitySampler,vUV).r;\nif (spec == 0.0) {\ngl_FragColor=albedoFull;\nreturn;\n}\n\n#ifdef PREPASS_LAYOUT\nvec3 normal=(texture2D(normalSampler,vUV)).gba;\n#else\nvec3 normal=(texture2D(normalSampler,vUV)).xyz;\n#endif\nvec3 position=(view*texture2D(positionSampler,vUV)).xyz;\nvec3 reflected=normalize(reflect(normalize(position),normalize(normal)));\nfloat roughness=1.0-texture2D(reflectivitySampler,vUV).a;\nvec3 jitt=mix(vec3(0.0),hash(position),roughness)*roughnessFactor;\nReflectionInfo info=getReflectionInfo(jitt+reflected,position);\n\nvec2 dCoords=smoothstep(0.2,0.6,abs(vec2(0.5,0.5)-info.coords.xy));\nfloat screenEdgefactor=clamp(1.0-(dCoords.x+dCoords.y),0.0,1.0);\n\nvec3 F0=vec3(0.04);\nF0=mix(F0,albedo,spec);\nvec3 fresnel=fresnelSchlick(max(dot(normalize(normal),normalize(position)),0.0),F0);\n\nfloat reflectionMultiplier=clamp(pow(spec*strength,reflectionSpecularFalloffExponent)*screenEdgefactor*reflected.z,0.0,0.9);\nfloat albedoMultiplier=1.0-reflectionMultiplier;\nvec3 SSR=info.color*fresnel;\ngl_FragColor=vec4((albedo*albedoMultiplier)+(SSR*reflectionMultiplier),albedoFull.a);\n#else\ngl_FragColor=texture2D(textureSampler,vUV);\n#endif\n}\n";
Effect.ShadersStore[name78] = shader78;

// node_modules/@babylonjs/core/PostProcesses/screenSpaceReflectionPostProcess.js
var ScreenSpaceReflectionPostProcess = function(_super) {
  __extends(ScreenSpaceReflectionPostProcess2, _super);
  function ScreenSpaceReflectionPostProcess2(name98, scene, options, camera, samplingMode, engine, reusable, textureType, blockCompilation, forceGeometryBuffer) {
    if (textureType === void 0) {
      textureType = 0;
    }
    if (blockCompilation === void 0) {
      blockCompilation = false;
    }
    if (forceGeometryBuffer === void 0) {
      forceGeometryBuffer = true;
    }
    var _this = _super.call(this, name98, "screenSpaceReflection", [
      "projection",
      "view",
      "threshold",
      "reflectionSpecularFalloffExponent",
      "strength",
      "step",
      "roughnessFactor"
    ], [
      "textureSampler",
      "normalSampler",
      "positionSampler",
      "reflectivitySampler"
    ], options, camera, samplingMode, engine, reusable, "#define SSR_SUPPORTED\n#define REFLECTION_SAMPLES 64\n#define SMOOTH_STEPS 5\n", textureType, void 0, null, blockCompilation) || this;
    _this.threshold = 1.2;
    _this.strength = 1;
    _this.reflectionSpecularFalloffExponent = 3;
    _this.step = 1;
    _this.roughnessFactor = 0.2;
    _this._forceGeometryBuffer = false;
    _this._enableSmoothReflections = false;
    _this._reflectionSamples = 64;
    _this._smoothSteps = 5;
    _this._forceGeometryBuffer = forceGeometryBuffer;
    if (_this._forceGeometryBuffer) {
      var geometryBufferRenderer = scene.enableGeometryBufferRenderer();
      if (geometryBufferRenderer) {
        if (geometryBufferRenderer.isSupported) {
          geometryBufferRenderer.enablePosition = true;
          geometryBufferRenderer.enableReflectivity = true;
          _this._geometryBufferRenderer = geometryBufferRenderer;
        }
      }
    } else {
      _this._prePassRenderer = scene.enablePrePassRenderer();
      _this._prePassRenderer.markAsDirty();
      _this._prePassEffectConfiguration = new ScreenSpaceReflectionsConfiguration();
    }
    _this._updateEffectDefines();
    _this.onApply = function(effect) {
      var geometryBufferRenderer2 = _this._geometryBufferRenderer;
      var prePassRenderer = _this._prePassRenderer;
      if (!prePassRenderer && !geometryBufferRenderer2) {
        return;
      }
      if (geometryBufferRenderer2) {
        var positionIndex = geometryBufferRenderer2.getTextureIndex(GeometryBufferRenderer.POSITION_TEXTURE_TYPE);
        var roughnessIndex = geometryBufferRenderer2.getTextureIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE);
        effect.setTexture("normalSampler", geometryBufferRenderer2.getGBuffer().textures[1]);
        effect.setTexture("positionSampler", geometryBufferRenderer2.getGBuffer().textures[positionIndex]);
        effect.setTexture("reflectivitySampler", geometryBufferRenderer2.getGBuffer().textures[roughnessIndex]);
      } else {
        var positionIndex = prePassRenderer.getIndex(1);
        var roughnessIndex = prePassRenderer.getIndex(3);
        var normalIndex = prePassRenderer.getIndex(5);
        effect.setTexture("normalSampler", prePassRenderer.prePassRT.textures[normalIndex]);
        effect.setTexture("positionSampler", prePassRenderer.prePassRT.textures[positionIndex]);
        effect.setTexture("reflectivitySampler", prePassRenderer.prePassRT.textures[roughnessIndex]);
      }
      var camera2 = scene.activeCamera;
      if (!camera2) {
        return;
      }
      var viewMatrix = camera2.getViewMatrix();
      var projectionMatrix = camera2.getProjectionMatrix();
      effect.setMatrix("projection", projectionMatrix);
      effect.setMatrix("view", viewMatrix);
      effect.setFloat("threshold", _this.threshold);
      effect.setFloat("reflectionSpecularFalloffExponent", _this.reflectionSpecularFalloffExponent);
      effect.setFloat("strength", _this.strength);
      effect.setFloat("step", _this.step);
      effect.setFloat("roughnessFactor", _this.roughnessFactor);
    };
    return _this;
  }
  ScreenSpaceReflectionPostProcess2.prototype.getClassName = function() {
    return "ScreenSpaceReflectionPostProcess";
  };
  Object.defineProperty(ScreenSpaceReflectionPostProcess2.prototype, "enableSmoothReflections", {
    get: function() {
      return this._enableSmoothReflections;
    },
    set: function(enabled) {
      if (enabled === this._enableSmoothReflections) {
        return;
      }
      this._enableSmoothReflections = enabled;
      this._updateEffectDefines();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScreenSpaceReflectionPostProcess2.prototype, "reflectionSamples", {
    get: function() {
      return this._reflectionSamples;
    },
    set: function(samples) {
      if (samples === this._reflectionSamples) {
        return;
      }
      this._reflectionSamples = samples;
      this._updateEffectDefines();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScreenSpaceReflectionPostProcess2.prototype, "smoothSteps", {
    get: function() {
      return this._smoothSteps;
    },
    set: function(steps) {
      if (steps === this._smoothSteps) {
        return;
      }
      this._smoothSteps = steps;
      this._updateEffectDefines();
    },
    enumerable: false,
    configurable: true
  });
  ScreenSpaceReflectionPostProcess2.prototype._updateEffectDefines = function() {
    var defines = [];
    if (this._geometryBufferRenderer || this._prePassRenderer) {
      defines.push("#define SSR_SUPPORTED");
      if (this._prePassRenderer) {
        defines.push("#define PREPASS_LAYOUT");
      }
    }
    if (this._enableSmoothReflections) {
      defines.push("#define ENABLE_SMOOTH_REFLECTIONS");
    }
    defines.push("#define REFLECTION_SAMPLES " + (this._reflectionSamples >> 0));
    defines.push("#define SMOOTH_STEPS " + (this._smoothSteps >> 0));
    this.updateEffect(defines.join("\n"));
  };
  ScreenSpaceReflectionPostProcess2._Parse = function(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(function() {
      return new ScreenSpaceReflectionPostProcess2(parsedPostProcess.name, scene, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.textureType, parsedPostProcess.reusable);
    }, parsedPostProcess, scene, rootUrl);
  };
  __decorate([
    serialize()
  ], ScreenSpaceReflectionPostProcess2.prototype, "threshold", void 0);
  __decorate([
    serialize()
  ], ScreenSpaceReflectionPostProcess2.prototype, "strength", void 0);
  __decorate([
    serialize()
  ], ScreenSpaceReflectionPostProcess2.prototype, "reflectionSpecularFalloffExponent", void 0);
  __decorate([
    serialize()
  ], ScreenSpaceReflectionPostProcess2.prototype, "step", void 0);
  __decorate([
    serialize()
  ], ScreenSpaceReflectionPostProcess2.prototype, "roughnessFactor", void 0);
  __decorate([
    serialize()
  ], ScreenSpaceReflectionPostProcess2.prototype, "enableSmoothReflections", null);
  __decorate([
    serialize()
  ], ScreenSpaceReflectionPostProcess2.prototype, "reflectionSamples", null);
  __decorate([
    serialize()
  ], ScreenSpaceReflectionPostProcess2.prototype, "smoothSteps", null);
  return ScreenSpaceReflectionPostProcess2;
}(PostProcess);
_TypeStore.RegisteredTypes["BABYLON.ScreenSpaceReflectionPostProcess"] = ScreenSpaceReflectionPostProcess;

// node_modules/@babylonjs/core/Shaders/standard.fragment.js
var name79 = "standardPixelShader";
var shader79 = "uniform sampler2D textureSampler;\nvarying vec2 vUV;\n#if defined(PASS_POST_PROCESS)\nvoid main(void)\n{\nvec4 color=texture2D(textureSampler,vUV);\ngl_FragColor=color;\n}\n#endif\n#if defined(DOWN_SAMPLE_X4)\nuniform vec2 dsOffsets[16];\nvoid main(void)\n{\nvec4 average=vec4(0.0,0.0,0.0,0.0);\naverage=texture2D(textureSampler,vUV+dsOffsets[0]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[1]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[2]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[3]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[4]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[5]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[6]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[7]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[8]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[9]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[10]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[11]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[12]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[13]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[14]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[15]);\naverage/=16.0;\ngl_FragColor=average;\n}\n#endif\n#if defined(BRIGHT_PASS)\nuniform vec2 dsOffsets[4];\nuniform float brightThreshold;\nvoid main(void)\n{\nvec4 average=vec4(0.0,0.0,0.0,0.0);\naverage=texture2D(textureSampler,vUV+vec2(dsOffsets[0].x,dsOffsets[0].y));\naverage+=texture2D(textureSampler,vUV+vec2(dsOffsets[1].x,dsOffsets[1].y));\naverage+=texture2D(textureSampler,vUV+vec2(dsOffsets[2].x,dsOffsets[2].y));\naverage+=texture2D(textureSampler,vUV+vec2(dsOffsets[3].x,dsOffsets[3].y));\naverage*=0.25;\nfloat luminance=length(average.rgb);\nif (luminance<brightThreshold) {\naverage=vec4(0.0,0.0,0.0,1.0);\n}\ngl_FragColor=average;\n}\n#endif\n#if defined(TEXTURE_ADDER)\nuniform sampler2D otherSampler;\nuniform sampler2D lensSampler;\nuniform float exposure;\nvoid main(void)\n{\nvec3 colour=texture2D(textureSampler,vUV).rgb;\ncolour*=exposure;\nvec3 X=max(vec3(0.0,0.0,0.0),colour-0.004);\nvec3 retColor=(X*(6.2*X+0.5))/(X*(6.2*X+1.7)+0.06);\ncolour=retColor*retColor;\ncolour+=colour*texture2D(lensSampler,vUV).rgb;\nvec4 finalColor=vec4(colour.rgb,1.0)+texture2D(otherSampler,vUV);\ngl_FragColor=finalColor;\n}\n#endif\n#if defined(VLS)\n#define PI 3.1415926535897932384626433832795\nuniform mat4 shadowViewProjection;\nuniform mat4 lightWorld;\nuniform vec3 cameraPosition;\nuniform vec3 sunDirection;\nuniform vec3 sunColor;\nuniform vec2 depthValues;\nuniform float scatteringCoefficient;\nuniform float scatteringPower;\nuniform sampler2D shadowMapSampler;\nuniform sampler2D positionSampler;\nfloat computeScattering(float lightDotView)\n{\nfloat result=1.0-scatteringCoefficient*scatteringCoefficient;\nresult/=(4.0*PI*pow(1.0+scatteringCoefficient*scatteringCoefficient-(2.0*scatteringCoefficient)*lightDotView,1.5));\nreturn result;\n}\nvoid main(void)\n{\n\nvec3 worldPos=texture2D(positionSampler,vUV).rgb;\nvec3 startPosition=cameraPosition;\nvec3 rayVector=worldPos-startPosition;\nfloat rayLength=length(rayVector);\nvec3 rayDirection=rayVector/rayLength;\nfloat stepLength=rayLength/NB_STEPS;\nvec3 stepL=rayDirection*stepLength;\nvec3 currentPosition=startPosition;\nvec3 accumFog=vec3(0.0);\nfor (int i=0; i<int(NB_STEPS); i++)\n{\nvec4 worldInShadowCameraSpace=shadowViewProjection*vec4(currentPosition,1.0);\nfloat depthMetric=(worldInShadowCameraSpace.z+depthValues.x)/(depthValues.y);\nfloat shadowPixelDepth=clamp(depthMetric,0.0,1.0);\nworldInShadowCameraSpace.xyz/=worldInShadowCameraSpace.w;\nworldInShadowCameraSpace.xyz=0.5*worldInShadowCameraSpace.xyz+vec3(0.5);\nfloat shadowMapValue=texture2D(shadowMapSampler,worldInShadowCameraSpace.xy).r;\nif (shadowMapValue>shadowPixelDepth)\naccumFog+=sunColor*computeScattering(dot(rayDirection,sunDirection));\ncurrentPosition+=stepL;\n}\naccumFog/=NB_STEPS;\nvec3 color=accumFog*scatteringPower;\ngl_FragColor=vec4(color*exp(color) ,1.0);\n}\n#endif\n#if defined(VLSMERGE)\nuniform sampler2D originalSampler;\nvoid main(void)\n{\ngl_FragColor=texture2D(originalSampler,vUV)+texture2D(textureSampler,vUV);\n}\n#endif\n#if defined(LUMINANCE)\nuniform vec2 lumOffsets[4];\nvoid main()\n{\nfloat average=0.0;\nvec4 color=vec4(0.0);\nfloat maximum=-1e20;\nvec3 weight=vec3(0.299,0.587,0.114);\nfor (int i=0; i<4; i++)\n{\ncolor=texture2D(textureSampler,vUV+ lumOffsets[i]);\n\nfloat GreyValue=dot(color.rgb,vec3(0.33,0.33,0.33));\n\n#ifdef WEIGHTED_AVERAGE\nfloat GreyValue=dot(color.rgb,weight);\n#endif\n#ifdef BRIGHTNESS\nfloat GreyValue=max(color.r,max(color.g,color.b));\n#endif\n#ifdef HSL_COMPONENT\nfloat GreyValue=0.5*(max(color.r,max(color.g,color.b))+min(color.r,min(color.g,color.b)));\n#endif\n#ifdef MAGNITUDE\nfloat GreyValue=length(color.rgb);\n#endif\nmaximum=max(maximum,GreyValue);\naverage+=(0.25*log(1e-5+GreyValue));\n}\naverage=exp(average);\ngl_FragColor=vec4(average,maximum,0.0,1.0);\n}\n#endif\n#if defined(LUMINANCE_DOWN_SAMPLE)\nuniform vec2 dsOffsets[9];\nuniform float halfDestPixelSize;\n#ifdef FINAL_DOWN_SAMPLER\n#include<packingFunctions>\n#endif\nvoid main()\n{\nvec4 color=vec4(0.0);\nfloat average=0.0;\nfor (int i=0; i<9; i++)\n{\ncolor=texture2D(textureSampler,vUV+vec2(halfDestPixelSize,halfDestPixelSize)+dsOffsets[i]);\naverage+=color.r;\n}\naverage/=9.0;\n#ifdef FINAL_DOWN_SAMPLER\ngl_FragColor=pack(average);\n#else\ngl_FragColor=vec4(average,average,0.0,1.0);\n#endif\n}\n#endif\n#if defined(HDR)\nuniform sampler2D textureAdderSampler;\nuniform float averageLuminance;\nvoid main()\n{\nvec4 color=texture2D(textureAdderSampler,vUV);\n#ifndef AUTO_EXPOSURE\nvec4 adjustedColor=color/averageLuminance;\ncolor=adjustedColor;\ncolor.a=1.0;\n#endif\ngl_FragColor=color;\n}\n#endif\n#if defined(LENS_FLARE)\n#define GHOSTS 3\nuniform sampler2D lensColorSampler;\nuniform float strength;\nuniform float ghostDispersal;\nuniform float haloWidth;\nuniform vec2 resolution;\nuniform float distortionStrength;\nfloat hash(vec2 p)\n{\nfloat h=dot(p,vec2(127.1,311.7));\nreturn -1.0+2.0*fract(sin(h)*43758.5453123);\n}\nfloat noise(in vec2 p)\n{\nvec2 i=floor(p);\nvec2 f=fract(p);\nvec2 u=f*f*(3.0-2.0*f);\nreturn mix(mix(hash(i+vec2(0.0,0.0)),\nhash(i+vec2(1.0,0.0)),u.x),\nmix(hash(i+vec2(0.0,1.0)),\nhash(i+vec2(1.0,1.0)),u.x),u.y);\n}\nfloat fbm(vec2 p)\n{\nfloat f=0.0;\nf+=0.5000*noise(p); p*=2.02;\nf+=0.2500*noise(p); p*=2.03;\nf+=0.1250*noise(p); p*=2.01;\nf+=0.0625*noise(p); p*=2.04;\nf/=0.9375;\nreturn f;\n}\nvec3 pattern(vec2 uv)\n{\nvec2 p=-1.0+2.0*uv;\nfloat p2=dot(p,p);\nfloat f=fbm(vec2(15.0*p2))/2.0;\nfloat r=0.2+0.6*sin(12.5*length(uv-vec2(0.5)));\nfloat g=0.2+0.6*sin(20.5*length(uv-vec2(0.5)));\nfloat b=0.2+0.6*sin(17.2*length(uv-vec2(0.5)));\nreturn (1.0-f)*vec3(r,g,b);\n}\nfloat luminance(vec3 color)\n{\nreturn dot(color.rgb,vec3(0.2126,0.7152,0.0722));\n}\nvec4 textureDistorted(sampler2D tex,vec2 texcoord,vec2 direction,vec3 distortion)\n{\nreturn vec4(\ntexture2D(tex,texcoord+direction*distortion.r).r,\ntexture2D(tex,texcoord+direction*distortion.g).g,\ntexture2D(tex,texcoord+direction*distortion.b).b,\n1.0\n);\n}\nvoid main(void)\n{\nvec2 uv=-vUV+vec2(1.0);\nvec2 ghostDir=(vec2(0.5)-uv)*ghostDispersal;\nvec2 texelSize=1.0/resolution;\nvec3 distortion=vec3(-texelSize.x*distortionStrength,0.0,texelSize.x*distortionStrength);\nvec4 result=vec4(0.0);\nfloat ghostIndice=1.0;\nfor (int i=0; i<GHOSTS; ++i)\n{\nvec2 offset=fract(uv+ghostDir*ghostIndice);\nfloat weight=length(vec2(0.5)-offset)/length(vec2(0.5));\nweight=pow(1.0-weight,10.0);\nresult+=textureDistorted(textureSampler,offset,normalize(ghostDir),distortion)*weight*strength;\nghostIndice+=1.0;\n}\nvec2 haloVec=normalize(ghostDir)*haloWidth;\nfloat weight=length(vec2(0.5)-fract(uv+haloVec))/length(vec2(0.5));\nweight=pow(1.0-weight,10.0);\nresult+=textureDistorted(textureSampler,fract(uv+haloVec),normalize(ghostDir),distortion)*weight*strength;\nresult*=texture2D(lensColorSampler,vec2(length(vec2(0.5)-uv)/length(vec2(0.5))));\ngl_FragColor=result;\n}\n#endif\n#if defined(LENS_FLARE_COMPOSE)\nuniform sampler2D otherSampler;\nuniform sampler2D lensDirtSampler;\nuniform sampler2D lensStarSampler;\nuniform mat4 lensStarMatrix;\nvoid main(void)\n{\nvec2 lensFlareCoords=(lensStarMatrix*vec4(vUV,1.0,1.0)).xy;\nvec4 lensMod=texture2D(lensDirtSampler,vUV);\nlensMod+=texture2D(lensStarSampler,vUV);\nvec4 result=texture2D(textureSampler,vUV)*lensMod;\ngl_FragColor=texture2D(otherSampler,vUV)+result;\n}\n#endif\n#if defined(DEPTH_OF_FIELD)\nuniform sampler2D otherSampler;\nuniform sampler2D depthSampler;\nuniform float distance;\nvoid main(void)\n{\nvec4 sharp=texture2D(otherSampler,vUV);\nvec4 blur=texture2D(textureSampler,vUV);\nfloat dist=clamp(texture2D(depthSampler,vUV).r*distance,0.0,1.0);\nfloat factor=0.0;\nif (dist<0.05)\nfactor=1.0;\nelse if (dist<0.1)\nfactor=20.0*(0.1-dist);\nelse if (dist<0.5)\nfactor=0.0;\nelse\nfactor=2.0*(dist-0.5);\nfactor=clamp(factor,0.0,0.90);\ngl_FragColor=mix(sharp,blur,factor);\n}\n#endif\n#if defined(MOTION_BLUR)\nuniform mat4 inverseViewProjection;\nuniform mat4 prevViewProjection;\nuniform vec2 screenSize;\nuniform float motionScale;\nuniform float motionStrength;\nuniform sampler2D depthSampler;\nvoid main(void)\n{\nvec2 texelSize=1.0/screenSize;\nfloat depth=texture2D(depthSampler,vUV).r;\nvec4 cpos=vec4(vUV*2.0-1.0,depth,1.0);\ncpos=cpos*inverseViewProjection;\nvec4 ppos=cpos*prevViewProjection;\nppos.xyz/=ppos.w;\nppos.xy=ppos.xy*0.5+0.5;\nvec2 velocity=(ppos.xy-vUV)*motionScale*motionStrength;\nfloat speed=length(velocity/texelSize);\nint nSamples=int(clamp(speed,1.0,MAX_MOTION_SAMPLES));\nvec4 result=texture2D(textureSampler,vUV);\nfor (int i=1; i<int(MAX_MOTION_SAMPLES); ++i) {\nif (i>=nSamples)\nbreak;\nvec2 offset1=vUV+velocity*(float(i)/float(nSamples-1)-0.5);\nresult+=texture2D(textureSampler,offset1);\n}\ngl_FragColor=result/float(nSamples);\n}\n#endif\n";
Effect.ShadersStore[name79] = shader79;

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/standardRenderingPipeline.js
var StandardRenderingPipeline = function(_super) {
  __extends(StandardRenderingPipeline2, _super);
  function StandardRenderingPipeline2(name98, scene, ratio, originalPostProcess, cameras) {
    if (originalPostProcess === void 0) {
      originalPostProcess = null;
    }
    var _this = _super.call(this, scene.getEngine(), name98) || this;
    _this.downSampleX4PostProcess = null;
    _this.brightPassPostProcess = null;
    _this.blurHPostProcesses = [];
    _this.blurVPostProcesses = [];
    _this.textureAdderPostProcess = null;
    _this.volumetricLightPostProcess = null;
    _this.volumetricLightSmoothXPostProcess = null;
    _this.volumetricLightSmoothYPostProcess = null;
    _this.volumetricLightMergePostProces = null;
    _this.volumetricLightFinalPostProcess = null;
    _this.luminancePostProcess = null;
    _this.luminanceDownSamplePostProcesses = [];
    _this.hdrPostProcess = null;
    _this.textureAdderFinalPostProcess = null;
    _this.lensFlareFinalPostProcess = null;
    _this.hdrFinalPostProcess = null;
    _this.lensFlarePostProcess = null;
    _this.lensFlareComposePostProcess = null;
    _this.motionBlurPostProcess = null;
    _this.depthOfFieldPostProcess = null;
    _this.fxaaPostProcess = null;
    _this.screenSpaceReflectionPostProcess = null;
    _this.brightThreshold = 1;
    _this.blurWidth = 512;
    _this.horizontalBlur = false;
    _this.lensTexture = null;
    _this.volumetricLightCoefficient = 0.2;
    _this.volumetricLightPower = 4;
    _this.volumetricLightBlurScale = 64;
    _this.sourceLight = null;
    _this.hdrMinimumLuminance = 1;
    _this.hdrDecreaseRate = 0.5;
    _this.hdrIncreaseRate = 0.5;
    _this.lensColorTexture = null;
    _this.lensFlareStrength = 20;
    _this.lensFlareGhostDispersal = 1.4;
    _this.lensFlareHaloWidth = 0.7;
    _this.lensFlareDistortionStrength = 16;
    _this.lensFlareBlurWidth = 512;
    _this.lensStarTexture = null;
    _this.lensFlareDirtTexture = null;
    _this.depthOfFieldDistance = 10;
    _this.depthOfFieldBlurWidth = 64;
    _this.animations = [];
    _this._currentDepthOfFieldSource = null;
    _this._fixedExposure = 1;
    _this._currentExposure = 1;
    _this._hdrAutoExposure = false;
    _this._hdrCurrentLuminance = 1;
    _this._motionStrength = 1;
    _this._isObjectBasedMotionBlur = false;
    _this._camerasToBeAttached = [];
    _this._bloomEnabled = false;
    _this._depthOfFieldEnabled = false;
    _this._vlsEnabled = false;
    _this._lensFlareEnabled = false;
    _this._hdrEnabled = false;
    _this._motionBlurEnabled = false;
    _this._fxaaEnabled = false;
    _this._screenSpaceReflectionsEnabled = false;
    _this._motionBlurSamples = 64;
    _this._volumetricLightStepsCount = 50;
    _this._samples = 1;
    _this._cameras = cameras || scene.cameras;
    _this._cameras = _this._cameras.slice();
    _this._camerasToBeAttached = _this._cameras.slice();
    _this._scene = scene;
    _this._basePostProcess = originalPostProcess;
    _this._ratio = ratio;
    _this._floatTextureType = scene.getEngine().getCaps().textureFloatRender ? 1 : 2;
    scene.postProcessRenderPipelineManager.addPipeline(_this);
    _this._buildPipeline();
    return _this;
  }
  Object.defineProperty(StandardRenderingPipeline2.prototype, "exposure", {
    get: function() {
      return this._fixedExposure;
    },
    set: function(value) {
      this._fixedExposure = value;
      this._currentExposure = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardRenderingPipeline2.prototype, "hdrAutoExposure", {
    get: function() {
      return this._hdrAutoExposure;
    },
    set: function(value) {
      this._hdrAutoExposure = value;
      if (this.hdrPostProcess) {
        var defines = ["#define HDR"];
        if (value) {
          defines.push("#define AUTO_EXPOSURE");
        }
        this.hdrPostProcess.updateEffect(defines.join("\n"));
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardRenderingPipeline2.prototype, "motionStrength", {
    get: function() {
      return this._motionStrength;
    },
    set: function(strength) {
      this._motionStrength = strength;
      if (this._isObjectBasedMotionBlur && this.motionBlurPostProcess) {
        this.motionBlurPostProcess.motionStrength = strength;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardRenderingPipeline2.prototype, "objectBasedMotionBlur", {
    get: function() {
      return this._isObjectBasedMotionBlur;
    },
    set: function(value) {
      var shouldRebuild = this._isObjectBasedMotionBlur !== value;
      this._isObjectBasedMotionBlur = value;
      if (shouldRebuild) {
        this._buildPipeline();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardRenderingPipeline2.prototype, "BloomEnabled", {
    get: function() {
      return this._bloomEnabled;
    },
    set: function(enabled) {
      if (this._bloomEnabled === enabled) {
        return;
      }
      this._bloomEnabled = enabled;
      this._buildPipeline();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardRenderingPipeline2.prototype, "DepthOfFieldEnabled", {
    get: function() {
      return this._depthOfFieldEnabled;
    },
    set: function(enabled) {
      if (this._depthOfFieldEnabled === enabled) {
        return;
      }
      this._depthOfFieldEnabled = enabled;
      this._buildPipeline();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardRenderingPipeline2.prototype, "LensFlareEnabled", {
    get: function() {
      return this._lensFlareEnabled;
    },
    set: function(enabled) {
      if (this._lensFlareEnabled === enabled) {
        return;
      }
      this._lensFlareEnabled = enabled;
      this._buildPipeline();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardRenderingPipeline2.prototype, "HDREnabled", {
    get: function() {
      return this._hdrEnabled;
    },
    set: function(enabled) {
      if (this._hdrEnabled === enabled) {
        return;
      }
      this._hdrEnabled = enabled;
      this._buildPipeline();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardRenderingPipeline2.prototype, "VLSEnabled", {
    get: function() {
      return this._vlsEnabled;
    },
    set: function(enabled) {
      if (this._vlsEnabled === enabled) {
        return;
      }
      if (enabled) {
        var geometry = this._scene.enableGeometryBufferRenderer();
        if (!geometry) {
          Logger.Warn("Geometry renderer is not supported, cannot create volumetric lights in Standard Rendering Pipeline");
          return;
        }
      }
      this._vlsEnabled = enabled;
      this._buildPipeline();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardRenderingPipeline2.prototype, "MotionBlurEnabled", {
    get: function() {
      return this._motionBlurEnabled;
    },
    set: function(enabled) {
      if (this._motionBlurEnabled === enabled) {
        return;
      }
      this._motionBlurEnabled = enabled;
      this._buildPipeline();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardRenderingPipeline2.prototype, "fxaaEnabled", {
    get: function() {
      return this._fxaaEnabled;
    },
    set: function(enabled) {
      if (this._fxaaEnabled === enabled) {
        return;
      }
      this._fxaaEnabled = enabled;
      this._buildPipeline();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardRenderingPipeline2.prototype, "screenSpaceReflectionsEnabled", {
    get: function() {
      return this._screenSpaceReflectionsEnabled;
    },
    set: function(enabled) {
      if (this._screenSpaceReflectionsEnabled === enabled) {
        return;
      }
      this._screenSpaceReflectionsEnabled = enabled;
      this._buildPipeline();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardRenderingPipeline2.prototype, "volumetricLightStepsCount", {
    get: function() {
      return this._volumetricLightStepsCount;
    },
    set: function(count) {
      if (this.volumetricLightPostProcess) {
        this.volumetricLightPostProcess.updateEffect("#define VLS\n#define NB_STEPS " + count.toFixed(1));
      }
      this._volumetricLightStepsCount = count;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardRenderingPipeline2.prototype, "motionBlurSamples", {
    get: function() {
      return this._motionBlurSamples;
    },
    set: function(samples) {
      if (this.motionBlurPostProcess) {
        if (this._isObjectBasedMotionBlur) {
          this.motionBlurPostProcess.motionBlurSamples = samples;
        } else {
          this.motionBlurPostProcess.updateEffect("#define MOTION_BLUR\n#define MAX_MOTION_SAMPLES " + samples.toFixed(1));
        }
      }
      this._motionBlurSamples = samples;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardRenderingPipeline2.prototype, "samples", {
    get: function() {
      return this._samples;
    },
    set: function(sampleCount) {
      if (this._samples === sampleCount) {
        return;
      }
      this._samples = sampleCount;
      this._buildPipeline();
    },
    enumerable: false,
    configurable: true
  });
  StandardRenderingPipeline2.prototype._buildPipeline = function() {
    var _this = this;
    var ratio = this._ratio;
    var scene = this._scene;
    this._disposePostProcesses();
    if (this._cameras !== null) {
      this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);
      this._cameras = this._camerasToBeAttached.slice();
    }
    this._reset();
    if (this._screenSpaceReflectionsEnabled) {
      this.screenSpaceReflectionPostProcess = new ScreenSpaceReflectionPostProcess("HDRPass", scene, ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, this._floatTextureType);
      this.screenSpaceReflectionPostProcess.onApplyObservable.add(function() {
        _this._currentDepthOfFieldSource = _this.screenSpaceReflectionPostProcess;
      });
      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRScreenSpaceReflections", function() {
        return _this.screenSpaceReflectionPostProcess;
      }, true));
    }
    if (!this._basePostProcess) {
      this.originalPostProcess = new PostProcess("HDRPass", "standard", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define PASS_POST_PROCESS", this._floatTextureType);
    } else {
      this.originalPostProcess = this._basePostProcess;
    }
    this.originalPostProcess.autoClear = !this.screenSpaceReflectionPostProcess;
    this.originalPostProcess.onApplyObservable.add(function() {
      _this._currentDepthOfFieldSource = _this.originalPostProcess;
    });
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRPassPostProcess", function() {
      return _this.originalPostProcess;
    }, true));
    if (this._bloomEnabled) {
      this._createDownSampleX4PostProcess(scene, ratio / 4);
      this._createBrightPassPostProcess(scene, ratio / 4);
      this._createBlurPostProcesses(scene, ratio / 4, 1);
      this._createTextureAdderPostProcess(scene, ratio);
      this.textureAdderFinalPostProcess = new PostProcess("HDRDepthOfFieldSource", "standard", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define PASS_POST_PROCESS", 0);
      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRBaseDepthOfFieldSource", function() {
        return _this.textureAdderFinalPostProcess;
      }, true));
    }
    if (this._vlsEnabled) {
      this._createVolumetricLightPostProcess(scene, ratio);
      this.volumetricLightFinalPostProcess = new PostProcess("HDRVLSFinal", "standard", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define PASS_POST_PROCESS", 0);
      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRVLSFinal", function() {
        return _this.volumetricLightFinalPostProcess;
      }, true));
    }
    if (this._lensFlareEnabled) {
      this._createLensFlarePostProcess(scene, ratio);
      this.lensFlareFinalPostProcess = new PostProcess("HDRPostLensFlareDepthOfFieldSource", "standard", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define PASS_POST_PROCESS", 0);
      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRPostLensFlareDepthOfFieldSource", function() {
        return _this.lensFlareFinalPostProcess;
      }, true));
    }
    if (this._hdrEnabled) {
      this._createLuminancePostProcesses(scene, this._floatTextureType);
      this._createHdrPostProcess(scene, ratio);
      this.hdrFinalPostProcess = new PostProcess("HDRPostHDReDepthOfFieldSource", "standard", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define PASS_POST_PROCESS", 0);
      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRPostHDReDepthOfFieldSource", function() {
        return _this.hdrFinalPostProcess;
      }, true));
    }
    if (this._depthOfFieldEnabled) {
      this._createBlurPostProcesses(scene, ratio / 2, 3, "depthOfFieldBlurWidth");
      this._createDepthOfFieldPostProcess(scene, ratio);
    }
    if (this._motionBlurEnabled) {
      this._createMotionBlurPostProcess(scene, ratio);
    }
    if (this._fxaaEnabled) {
      this.fxaaPostProcess = new FxaaPostProcess("fxaa", 1, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, 0);
      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRFxaa", function() {
        return _this.fxaaPostProcess;
      }, true));
    }
    if (this._cameras !== null) {
      this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);
    }
    if (!this._enableMSAAOnFirstPostProcess(this._samples) && this._samples > 1) {
      Logger.Warn("MSAA failed to enable, MSAA is only supported in browsers that support webGL >= 2.0");
    }
  };
  StandardRenderingPipeline2.prototype._createDownSampleX4PostProcess = function(scene, ratio) {
    var _this = this;
    var downSampleX4Offsets = new Array(32);
    this.downSampleX4PostProcess = new PostProcess("HDRDownSampleX4", "standard", ["dsOffsets"], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define DOWN_SAMPLE_X4", this._floatTextureType);
    this.downSampleX4PostProcess.onApply = function(effect) {
      var id = 0;
      var width = _this.downSampleX4PostProcess.width;
      var height = _this.downSampleX4PostProcess.height;
      for (var i = -2; i < 2; i++) {
        for (var j = -2; j < 2; j++) {
          downSampleX4Offsets[id] = (i + 0.5) * (1 / width);
          downSampleX4Offsets[id + 1] = (j + 0.5) * (1 / height);
          id += 2;
        }
      }
      effect.setArray2("dsOffsets", downSampleX4Offsets);
    };
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRDownSampleX4", function() {
      return _this.downSampleX4PostProcess;
    }, true));
  };
  StandardRenderingPipeline2.prototype._createBrightPassPostProcess = function(scene, ratio) {
    var _this = this;
    var brightOffsets = new Array(8);
    this.brightPassPostProcess = new PostProcess("HDRBrightPass", "standard", ["dsOffsets", "brightThreshold"], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define BRIGHT_PASS", this._floatTextureType);
    this.brightPassPostProcess.onApply = function(effect) {
      var sU = 1 / _this.brightPassPostProcess.width;
      var sV = 1 / _this.brightPassPostProcess.height;
      brightOffsets[0] = -0.5 * sU;
      brightOffsets[1] = 0.5 * sV;
      brightOffsets[2] = 0.5 * sU;
      brightOffsets[3] = 0.5 * sV;
      brightOffsets[4] = -0.5 * sU;
      brightOffsets[5] = -0.5 * sV;
      brightOffsets[6] = 0.5 * sU;
      brightOffsets[7] = -0.5 * sV;
      effect.setArray2("dsOffsets", brightOffsets);
      effect.setFloat("brightThreshold", _this.brightThreshold);
    };
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRBrightPass", function() {
      return _this.brightPassPostProcess;
    }, true));
  };
  StandardRenderingPipeline2.prototype._createBlurPostProcesses = function(scene, ratio, indice, blurWidthKey) {
    var _this = this;
    if (blurWidthKey === void 0) {
      blurWidthKey = "blurWidth";
    }
    var engine = scene.getEngine();
    var blurX = new BlurPostProcess("HDRBlurH_" + indice, new Vector2(1, 0), this[blurWidthKey], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, this._floatTextureType);
    var blurY = new BlurPostProcess("HDRBlurV_" + indice, new Vector2(0, 1), this[blurWidthKey], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, this._floatTextureType);
    blurX.onActivateObservable.add(function() {
      var dw = blurX.width / engine.getRenderWidth();
      blurX.kernel = _this[blurWidthKey] * dw;
    });
    blurY.onActivateObservable.add(function() {
      var dw = blurY.height / engine.getRenderHeight();
      blurY.kernel = _this.horizontalBlur ? 64 * dw : _this[blurWidthKey] * dw;
    });
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRBlurH" + indice, function() {
      return blurX;
    }, true));
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRBlurV" + indice, function() {
      return blurY;
    }, true));
    this.blurHPostProcesses.push(blurX);
    this.blurVPostProcesses.push(blurY);
  };
  StandardRenderingPipeline2.prototype._createTextureAdderPostProcess = function(scene, ratio) {
    var _this = this;
    this.textureAdderPostProcess = new PostProcess("HDRTextureAdder", "standard", ["exposure"], ["otherSampler", "lensSampler"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define TEXTURE_ADDER", this._floatTextureType);
    this.textureAdderPostProcess.onApply = function(effect) {
      effect.setTextureFromPostProcess("otherSampler", _this._vlsEnabled ? _this._currentDepthOfFieldSource : _this.originalPostProcess);
      effect.setTexture("lensSampler", _this.lensTexture);
      effect.setFloat("exposure", _this._currentExposure);
      _this._currentDepthOfFieldSource = _this.textureAdderFinalPostProcess;
    };
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRTextureAdder", function() {
      return _this.textureAdderPostProcess;
    }, true));
  };
  StandardRenderingPipeline2.prototype._createVolumetricLightPostProcess = function(scene, ratio) {
    var _this = this;
    var geometryRenderer = scene.enableGeometryBufferRenderer();
    geometryRenderer.enablePosition = true;
    var geometry = geometryRenderer.getGBuffer();
    this.volumetricLightPostProcess = new PostProcess("HDRVLS", "standard", ["shadowViewProjection", "cameraPosition", "sunDirection", "sunColor", "scatteringCoefficient", "scatteringPower", "depthValues"], ["shadowMapSampler", "positionSampler"], ratio / 8, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define VLS\n#define NB_STEPS " + this._volumetricLightStepsCount.toFixed(1));
    var depthValues = Vector2.Zero();
    this.volumetricLightPostProcess.onApply = function(effect) {
      if (_this.sourceLight && _this.sourceLight.getShadowGenerator() && _this._scene.activeCamera) {
        var generator = _this.sourceLight.getShadowGenerator();
        effect.setTexture("shadowMapSampler", generator.getShadowMap());
        effect.setTexture("positionSampler", geometry.textures[2]);
        effect.setColor3("sunColor", _this.sourceLight.diffuse);
        effect.setVector3("sunDirection", _this.sourceLight.getShadowDirection());
        effect.setVector3("cameraPosition", _this._scene.activeCamera.globalPosition);
        effect.setMatrix("shadowViewProjection", generator.getTransformMatrix());
        effect.setFloat("scatteringCoefficient", _this.volumetricLightCoefficient);
        effect.setFloat("scatteringPower", _this.volumetricLightPower);
        depthValues.x = _this.sourceLight.getDepthMinZ(_this._scene.activeCamera);
        depthValues.y = _this.sourceLight.getDepthMaxZ(_this._scene.activeCamera);
        effect.setVector2("depthValues", depthValues);
      }
    };
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRVLS", function() {
      return _this.volumetricLightPostProcess;
    }, true));
    this._createBlurPostProcesses(scene, ratio / 4, 0, "volumetricLightBlurScale");
    this.volumetricLightMergePostProces = new PostProcess("HDRVLSMerge", "standard", [], ["originalSampler"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define VLSMERGE");
    this.volumetricLightMergePostProces.onApply = function(effect) {
      effect.setTextureFromPostProcess("originalSampler", _this._bloomEnabled ? _this.textureAdderFinalPostProcess : _this.originalPostProcess);
      _this._currentDepthOfFieldSource = _this.volumetricLightFinalPostProcess;
    };
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRVLSMerge", function() {
      return _this.volumetricLightMergePostProces;
    }, true));
  };
  StandardRenderingPipeline2.prototype._createLuminancePostProcesses = function(scene, textureType) {
    var _this = this;
    var size = Math.pow(3, StandardRenderingPipeline2.LuminanceSteps);
    this.luminancePostProcess = new PostProcess("HDRLuminance", "standard", ["lumOffsets"], [], { width: size, height: size }, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define LUMINANCE", textureType);
    var offsets = [];
    this.luminancePostProcess.onApply = function(effect) {
      var sU = 1 / _this.luminancePostProcess.width;
      var sV = 1 / _this.luminancePostProcess.height;
      offsets[0] = -0.5 * sU;
      offsets[1] = 0.5 * sV;
      offsets[2] = 0.5 * sU;
      offsets[3] = 0.5 * sV;
      offsets[4] = -0.5 * sU;
      offsets[5] = -0.5 * sV;
      offsets[6] = 0.5 * sU;
      offsets[7] = -0.5 * sV;
      effect.setArray2("lumOffsets", offsets);
    };
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRLuminance", function() {
      return _this.luminancePostProcess;
    }, true));
    for (var i = StandardRenderingPipeline2.LuminanceSteps - 1; i >= 0; i--) {
      var size = Math.pow(3, i);
      var defines = "#define LUMINANCE_DOWN_SAMPLE\n";
      if (i === 0) {
        defines += "#define FINAL_DOWN_SAMPLER";
      }
      var postProcess = new PostProcess("HDRLuminanceDownSample" + i, "standard", ["dsOffsets", "halfDestPixelSize"], [], { width: size, height: size }, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, defines, textureType);
      this.luminanceDownSamplePostProcesses.push(postProcess);
    }
    var lastLuminance = this.luminancePostProcess;
    this.luminanceDownSamplePostProcesses.forEach(function(pp, index) {
      var downSampleOffsets = new Array(18);
      pp.onApply = function(effect) {
        if (!lastLuminance) {
          return;
        }
        var id = 0;
        for (var x = -1; x < 2; x++) {
          for (var y = -1; y < 2; y++) {
            downSampleOffsets[id] = x / lastLuminance.width;
            downSampleOffsets[id + 1] = y / lastLuminance.height;
            id += 2;
          }
        }
        effect.setArray2("dsOffsets", downSampleOffsets);
        effect.setFloat("halfDestPixelSize", 0.5 / lastLuminance.width);
        if (index === _this.luminanceDownSamplePostProcesses.length - 1) {
          lastLuminance = _this.luminancePostProcess;
        } else {
          lastLuminance = pp;
        }
      };
      if (index === _this.luminanceDownSamplePostProcesses.length - 1) {
        pp.onAfterRender = function() {
          var pixel = scene.getEngine().readPixels(0, 0, 1, 1);
          var bit_shift = new Vector4(1 / (255 * 255 * 255), 1 / (255 * 255), 1 / 255, 1);
          _this._hdrCurrentLuminance = (pixel[0] * bit_shift.x + pixel[1] * bit_shift.y + pixel[2] * bit_shift.z + pixel[3] * bit_shift.w) / 100;
        };
      }
      _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRLuminanceDownSample" + index, function() {
        return pp;
      }, true));
    });
  };
  StandardRenderingPipeline2.prototype._createHdrPostProcess = function(scene, ratio) {
    var _this = this;
    var defines = ["#define HDR"];
    if (this._hdrAutoExposure) {
      defines.push("#define AUTO_EXPOSURE");
    }
    this.hdrPostProcess = new PostProcess("HDR", "standard", ["averageLuminance"], ["textureAdderSampler"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, defines.join("\n"), 0);
    var outputLiminance = 1;
    var time = 0;
    var lastTime = 0;
    this.hdrPostProcess.onApply = function(effect) {
      effect.setTextureFromPostProcess("textureAdderSampler", _this._currentDepthOfFieldSource);
      time += scene.getEngine().getDeltaTime();
      if (outputLiminance < 0) {
        outputLiminance = _this._hdrCurrentLuminance;
      } else {
        var dt = (lastTime - time) / 1e3;
        if (_this._hdrCurrentLuminance < outputLiminance + _this.hdrDecreaseRate * dt) {
          outputLiminance += _this.hdrDecreaseRate * dt;
        } else if (_this._hdrCurrentLuminance > outputLiminance - _this.hdrIncreaseRate * dt) {
          outputLiminance -= _this.hdrIncreaseRate * dt;
        } else {
          outputLiminance = _this._hdrCurrentLuminance;
        }
      }
      if (_this.hdrAutoExposure) {
        _this._currentExposure = _this._fixedExposure / outputLiminance;
      } else {
        outputLiminance = Scalar.Clamp(outputLiminance, _this.hdrMinimumLuminance, 1e20);
        effect.setFloat("averageLuminance", outputLiminance);
      }
      lastTime = time;
      _this._currentDepthOfFieldSource = _this.hdrFinalPostProcess;
    };
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDR", function() {
      return _this.hdrPostProcess;
    }, true));
  };
  StandardRenderingPipeline2.prototype._createLensFlarePostProcess = function(scene, ratio) {
    var _this = this;
    this.lensFlarePostProcess = new PostProcess("HDRLensFlare", "standard", ["strength", "ghostDispersal", "haloWidth", "resolution", "distortionStrength"], ["lensColorSampler"], ratio / 2, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define LENS_FLARE", 0);
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRLensFlare", function() {
      return _this.lensFlarePostProcess;
    }, true));
    this._createBlurPostProcesses(scene, ratio / 4, 2, "lensFlareBlurWidth");
    this.lensFlareComposePostProcess = new PostProcess("HDRLensFlareCompose", "standard", ["lensStarMatrix"], ["otherSampler", "lensDirtSampler", "lensStarSampler"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define LENS_FLARE_COMPOSE", 0);
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRLensFlareCompose", function() {
      return _this.lensFlareComposePostProcess;
    }, true));
    var resolution = new Vector2(0, 0);
    this.lensFlarePostProcess.onApply = function(effect) {
      effect.setTextureFromPostProcess("textureSampler", _this._bloomEnabled ? _this.blurHPostProcesses[0] : _this.originalPostProcess);
      effect.setTexture("lensColorSampler", _this.lensColorTexture);
      effect.setFloat("strength", _this.lensFlareStrength);
      effect.setFloat("ghostDispersal", _this.lensFlareGhostDispersal);
      effect.setFloat("haloWidth", _this.lensFlareHaloWidth);
      resolution.x = _this.lensFlarePostProcess.width;
      resolution.y = _this.lensFlarePostProcess.height;
      effect.setVector2("resolution", resolution);
      effect.setFloat("distortionStrength", _this.lensFlareDistortionStrength);
    };
    var scaleBias1 = Matrix.FromValues(2, 0, -1, 0, 0, 2, -1, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    var scaleBias2 = Matrix.FromValues(0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    this.lensFlareComposePostProcess.onApply = function(effect) {
      if (!_this._scene.activeCamera) {
        return;
      }
      effect.setTextureFromPostProcess("otherSampler", _this.lensFlarePostProcess);
      effect.setTexture("lensDirtSampler", _this.lensFlareDirtTexture);
      effect.setTexture("lensStarSampler", _this.lensStarTexture);
      var camerax = _this._scene.activeCamera.getViewMatrix().getRow(0);
      var cameraz = _this._scene.activeCamera.getViewMatrix().getRow(2);
      var camRot = Vector3.Dot(camerax.toVector3(), new Vector3(1, 0, 0)) + Vector3.Dot(cameraz.toVector3(), new Vector3(0, 0, 1));
      camRot *= 4;
      var starRotation = Matrix.FromValues(Math.cos(camRot) * 0.5, -Math.sin(camRot), 0, 0, Math.sin(camRot), Math.cos(camRot) * 0.5, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      var lensStarMatrix = scaleBias2.multiply(starRotation).multiply(scaleBias1);
      effect.setMatrix("lensStarMatrix", lensStarMatrix);
      _this._currentDepthOfFieldSource = _this.lensFlareFinalPostProcess;
    };
  };
  StandardRenderingPipeline2.prototype._createDepthOfFieldPostProcess = function(scene, ratio) {
    var _this = this;
    this.depthOfFieldPostProcess = new PostProcess("HDRDepthOfField", "standard", ["distance"], ["otherSampler", "depthSampler"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define DEPTH_OF_FIELD", 0);
    this.depthOfFieldPostProcess.onApply = function(effect) {
      effect.setTextureFromPostProcess("otherSampler", _this._currentDepthOfFieldSource);
      effect.setTexture("depthSampler", _this._getDepthTexture());
      effect.setFloat("distance", _this.depthOfFieldDistance);
    };
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRDepthOfField", function() {
      return _this.depthOfFieldPostProcess;
    }, true));
  };
  StandardRenderingPipeline2.prototype._createMotionBlurPostProcess = function(scene, ratio) {
    var _this = this;
    if (this._isObjectBasedMotionBlur) {
      var mb = new MotionBlurPostProcess("HDRMotionBlur", scene, ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, 0);
      mb.motionStrength = this.motionStrength;
      mb.motionBlurSamples = this.motionBlurSamples;
      this.motionBlurPostProcess = mb;
    } else {
      this.motionBlurPostProcess = new PostProcess("HDRMotionBlur", "standard", ["inverseViewProjection", "prevViewProjection", "screenSize", "motionScale", "motionStrength"], ["depthSampler"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define MOTION_BLUR\n#define MAX_MOTION_SAMPLES " + this.motionBlurSamples.toFixed(1), 0);
      var motionScale = 0;
      var prevViewProjection = Matrix.Identity();
      var invViewProjection = Matrix.Identity();
      var viewProjection = Matrix.Identity();
      var screenSize = Vector2.Zero();
      this.motionBlurPostProcess.onApply = function(effect) {
        viewProjection = scene.getProjectionMatrix().multiply(scene.getViewMatrix());
        viewProjection.invertToRef(invViewProjection);
        effect.setMatrix("inverseViewProjection", invViewProjection);
        effect.setMatrix("prevViewProjection", prevViewProjection);
        prevViewProjection = viewProjection;
        screenSize.x = _this.motionBlurPostProcess.width;
        screenSize.y = _this.motionBlurPostProcess.height;
        effect.setVector2("screenSize", screenSize);
        motionScale = scene.getEngine().getFps() / 60;
        effect.setFloat("motionScale", motionScale);
        effect.setFloat("motionStrength", _this.motionStrength);
        effect.setTexture("depthSampler", _this._getDepthTexture());
      };
    }
    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRMotionBlur", function() {
      return _this.motionBlurPostProcess;
    }, true));
  };
  StandardRenderingPipeline2.prototype._getDepthTexture = function() {
    if (this._scene.getEngine().getCaps().drawBuffersExtension) {
      var renderer = this._scene.enableGeometryBufferRenderer();
      return renderer.getGBuffer().textures[0];
    }
    return this._scene.enableDepthRenderer().getDepthMap();
  };
  StandardRenderingPipeline2.prototype._disposePostProcesses = function() {
    for (var i = 0; i < this._cameras.length; i++) {
      var camera = this._cameras[i];
      if (this.originalPostProcess) {
        this.originalPostProcess.dispose(camera);
      }
      if (this.screenSpaceReflectionPostProcess) {
        this.screenSpaceReflectionPostProcess.dispose(camera);
      }
      if (this.downSampleX4PostProcess) {
        this.downSampleX4PostProcess.dispose(camera);
      }
      if (this.brightPassPostProcess) {
        this.brightPassPostProcess.dispose(camera);
      }
      if (this.textureAdderPostProcess) {
        this.textureAdderPostProcess.dispose(camera);
      }
      if (this.volumetricLightPostProcess) {
        this.volumetricLightPostProcess.dispose(camera);
      }
      if (this.volumetricLightSmoothXPostProcess) {
        this.volumetricLightSmoothXPostProcess.dispose(camera);
      }
      if (this.volumetricLightSmoothYPostProcess) {
        this.volumetricLightSmoothYPostProcess.dispose(camera);
      }
      if (this.volumetricLightMergePostProces) {
        this.volumetricLightMergePostProces.dispose(camera);
      }
      if (this.volumetricLightFinalPostProcess) {
        this.volumetricLightFinalPostProcess.dispose(camera);
      }
      if (this.lensFlarePostProcess) {
        this.lensFlarePostProcess.dispose(camera);
      }
      if (this.lensFlareComposePostProcess) {
        this.lensFlareComposePostProcess.dispose(camera);
      }
      for (var j = 0; j < this.luminanceDownSamplePostProcesses.length; j++) {
        this.luminanceDownSamplePostProcesses[j].dispose(camera);
      }
      if (this.luminancePostProcess) {
        this.luminancePostProcess.dispose(camera);
      }
      if (this.hdrPostProcess) {
        this.hdrPostProcess.dispose(camera);
      }
      if (this.hdrFinalPostProcess) {
        this.hdrFinalPostProcess.dispose(camera);
      }
      if (this.depthOfFieldPostProcess) {
        this.depthOfFieldPostProcess.dispose(camera);
      }
      if (this.motionBlurPostProcess) {
        this.motionBlurPostProcess.dispose(camera);
      }
      if (this.fxaaPostProcess) {
        this.fxaaPostProcess.dispose(camera);
      }
      for (var j = 0; j < this.blurHPostProcesses.length; j++) {
        this.blurHPostProcesses[j].dispose(camera);
      }
      for (var j = 0; j < this.blurVPostProcesses.length; j++) {
        this.blurVPostProcesses[j].dispose(camera);
      }
    }
    this.originalPostProcess = null;
    this.downSampleX4PostProcess = null;
    this.brightPassPostProcess = null;
    this.textureAdderPostProcess = null;
    this.textureAdderFinalPostProcess = null;
    this.volumetricLightPostProcess = null;
    this.volumetricLightSmoothXPostProcess = null;
    this.volumetricLightSmoothYPostProcess = null;
    this.volumetricLightMergePostProces = null;
    this.volumetricLightFinalPostProcess = null;
    this.lensFlarePostProcess = null;
    this.lensFlareComposePostProcess = null;
    this.luminancePostProcess = null;
    this.hdrPostProcess = null;
    this.hdrFinalPostProcess = null;
    this.depthOfFieldPostProcess = null;
    this.motionBlurPostProcess = null;
    this.fxaaPostProcess = null;
    this.screenSpaceReflectionPostProcess = null;
    this.luminanceDownSamplePostProcesses = [];
    this.blurHPostProcesses = [];
    this.blurVPostProcesses = [];
  };
  StandardRenderingPipeline2.prototype.dispose = function() {
    this._disposePostProcesses();
    this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);
    _super.prototype.dispose.call(this);
  };
  StandardRenderingPipeline2.prototype.serialize = function() {
    var serializationObject = SerializationHelper.Serialize(this);
    if (this.sourceLight) {
      serializationObject.sourceLightId = this.sourceLight.id;
    }
    if (this.screenSpaceReflectionPostProcess) {
      serializationObject.screenSpaceReflectionPostProcess = SerializationHelper.Serialize(this.screenSpaceReflectionPostProcess);
    }
    serializationObject.customType = "StandardRenderingPipeline";
    return serializationObject;
  };
  StandardRenderingPipeline2.Parse = function(source, scene, rootUrl) {
    var p = SerializationHelper.Parse(function() {
      return new StandardRenderingPipeline2(source._name, scene, source._ratio);
    }, source, scene, rootUrl);
    if (source.sourceLightId) {
      p.sourceLight = scene.getLightByID(source.sourceLightId);
    }
    if (source.screenSpaceReflectionPostProcess) {
      SerializationHelper.Parse(function() {
        return p.screenSpaceReflectionPostProcess;
      }, source.screenSpaceReflectionPostProcess, scene, rootUrl);
    }
    return p;
  };
  StandardRenderingPipeline2.LuminanceSteps = 6;
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "brightThreshold", void 0);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "blurWidth", void 0);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "horizontalBlur", void 0);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "exposure", null);
  __decorate([
    serializeAsTexture("lensTexture")
  ], StandardRenderingPipeline2.prototype, "lensTexture", void 0);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "volumetricLightCoefficient", void 0);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "volumetricLightPower", void 0);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "volumetricLightBlurScale", void 0);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "hdrMinimumLuminance", void 0);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "hdrDecreaseRate", void 0);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "hdrIncreaseRate", void 0);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "hdrAutoExposure", null);
  __decorate([
    serializeAsTexture("lensColorTexture")
  ], StandardRenderingPipeline2.prototype, "lensColorTexture", void 0);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "lensFlareStrength", void 0);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "lensFlareGhostDispersal", void 0);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "lensFlareHaloWidth", void 0);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "lensFlareDistortionStrength", void 0);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "lensFlareBlurWidth", void 0);
  __decorate([
    serializeAsTexture("lensStarTexture")
  ], StandardRenderingPipeline2.prototype, "lensStarTexture", void 0);
  __decorate([
    serializeAsTexture("lensFlareDirtTexture")
  ], StandardRenderingPipeline2.prototype, "lensFlareDirtTexture", void 0);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "depthOfFieldDistance", void 0);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "depthOfFieldBlurWidth", void 0);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "motionStrength", null);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "objectBasedMotionBlur", null);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "_ratio", void 0);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "BloomEnabled", null);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "DepthOfFieldEnabled", null);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "LensFlareEnabled", null);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "HDREnabled", null);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "VLSEnabled", null);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "MotionBlurEnabled", null);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "fxaaEnabled", null);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "screenSpaceReflectionsEnabled", null);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "volumetricLightStepsCount", null);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "motionBlurSamples", null);
  __decorate([
    serialize()
  ], StandardRenderingPipeline2.prototype, "samples", null);
  return StandardRenderingPipeline2;
}(PostProcessRenderPipeline);
_TypeStore.RegisteredTypes["BABYLON.StandardRenderingPipeline"] = StandardRenderingPipeline;

// node_modules/@babylonjs/core/Shaders/stereoscopicInterlace.fragment.js
var name80 = "stereoscopicInterlacePixelShader";
var shader80 = "const vec3 TWO=vec3(2.0,2.0,2.0);\nvarying vec2 vUV;\nuniform sampler2D camASampler;\nuniform sampler2D textureSampler;\nuniform vec2 stepSize;\nvoid main(void)\n{\nbool useCamA;\nbool useCamB;\nvec2 texCoord1;\nvec2 texCoord2;\nvec3 frag1;\nvec3 frag2;\n#ifdef IS_STEREOSCOPIC_HORIZ\nuseCamB=vUV.x>0.5;\nuseCamA=!useCamB;\ntexCoord1=vec2(useCamB ? (vUV.x-0.5)*2.0 : vUV.x*2.0,vUV.y);\ntexCoord2=vec2(texCoord1.x+stepSize.x,vUV.y);\n#else\n#ifdef IS_STEREOSCOPIC_INTERLACED\nfloat rowNum=floor(vUV.y/stepSize.y);\nuseCamA=mod(rowNum,2.0) == 1.0;\nuseCamB=mod(rowNum,2.0) == 0.0;\ntexCoord1=vec2(vUV.x,vUV.y);\ntexCoord2=vec2(vUV.x,vUV.y);\n#else\nuseCamB=vUV.y>0.5;\nuseCamA=!useCamB;\ntexCoord1=vec2(vUV.x,useCamB ? (vUV.y-0.5)*2.0 : vUV.y*2.0);\ntexCoord2=vec2(vUV.x,texCoord1.y+stepSize.y);\n#endif\n#endif\n\nif (useCamB){\nfrag1=texture2D(textureSampler,texCoord1).rgb;\nfrag2=texture2D(textureSampler,texCoord2).rgb;\n}else if (useCamA){\nfrag1=texture2D(camASampler ,texCoord1).rgb;\nfrag2=texture2D(camASampler ,texCoord2).rgb;\n}else {\ndiscard;\n}\ngl_FragColor=vec4((frag1+frag2)/TWO,1.0);\n}\n";
Effect.ShadersStore[name80] = shader80;

// node_modules/@babylonjs/core/PostProcesses/stereoscopicInterlacePostProcess.js
var StereoscopicInterlacePostProcessI = function(_super) {
  __extends(StereoscopicInterlacePostProcessI2, _super);
  function StereoscopicInterlacePostProcessI2(name98, rigCameras, isStereoscopicHoriz, isStereoscopicInterlaced, samplingMode, engine, reusable) {
    var _this = _super.call(this, name98, "stereoscopicInterlace", ["stepSize"], ["camASampler"], 1, rigCameras[1], samplingMode, engine, reusable, isStereoscopicInterlaced ? "#define IS_STEREOSCOPIC_INTERLACED 1" : isStereoscopicHoriz ? "#define IS_STEREOSCOPIC_HORIZ 1" : void 0) || this;
    _this._passedProcess = rigCameras[0]._rigPostProcess;
    _this._stepSize = new Vector2(1 / _this.width, 1 / _this.height);
    _this.onSizeChangedObservable.add(function() {
      _this._stepSize = new Vector2(1 / _this.width, 1 / _this.height);
    });
    _this.onApplyObservable.add(function(effect) {
      effect.setTextureFromPostProcess("camASampler", _this._passedProcess);
      effect.setFloat2("stepSize", _this._stepSize.x, _this._stepSize.y);
    });
    return _this;
  }
  StereoscopicInterlacePostProcessI2.prototype.getClassName = function() {
    return "StereoscopicInterlacePostProcessI";
  };
  return StereoscopicInterlacePostProcessI2;
}(PostProcess);
var StereoscopicInterlacePostProcess = function(_super) {
  __extends(StereoscopicInterlacePostProcess2, _super);
  function StereoscopicInterlacePostProcess2(name98, rigCameras, isStereoscopicHoriz, samplingMode, engine, reusable) {
    var _this = _super.call(this, name98, "stereoscopicInterlace", ["stepSize"], ["camASampler"], 1, rigCameras[1], samplingMode, engine, reusable, isStereoscopicHoriz ? "#define IS_STEREOSCOPIC_HORIZ 1" : void 0) || this;
    _this._passedProcess = rigCameras[0]._rigPostProcess;
    _this._stepSize = new Vector2(1 / _this.width, 1 / _this.height);
    _this.onSizeChangedObservable.add(function() {
      _this._stepSize = new Vector2(1 / _this.width, 1 / _this.height);
    });
    _this.onApplyObservable.add(function(effect) {
      effect.setTextureFromPostProcess("camASampler", _this._passedProcess);
      effect.setFloat2("stepSize", _this._stepSize.x, _this._stepSize.y);
    });
    return _this;
  }
  StereoscopicInterlacePostProcess2.prototype.getClassName = function() {
    return "StereoscopicInterlacePostProcess";
  };
  return StereoscopicInterlacePostProcess2;
}(PostProcess);

// node_modules/@babylonjs/core/Shaders/tonemap.fragment.js
var name81 = "tonemapPixelShader";
var shader81 = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nuniform float _ExposureAdjustment;\n#if defined(HABLE_TONEMAPPING)\nconst float A=0.15;\nconst float B=0.50;\nconst float C=0.10;\nconst float D=0.20;\nconst float E=0.02;\nconst float F=0.30;\nconst float W=11.2;\n#endif\nfloat Luminance(vec3 c)\n{\nreturn dot(c,vec3(0.22,0.707,0.071));\n}\nvoid main(void)\n{\nvec3 colour=texture2D(textureSampler,vUV).rgb;\n#if defined(REINHARD_TONEMAPPING)\nfloat lum=Luminance(colour.rgb);\nfloat lumTm=lum*_ExposureAdjustment;\nfloat scale=lumTm/(1.0+lumTm);\ncolour*=scale/lum;\n#elif defined(HABLE_TONEMAPPING)\ncolour*=_ExposureAdjustment;\nconst float ExposureBias=2.0;\nvec3 x=ExposureBias*colour;\nvec3 curr=((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\nx=vec3(W,W,W);\nvec3 whiteScale=1.0/(((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F);\ncolour=curr*whiteScale;\n#elif defined(OPTIMIZED_HEJIDAWSON_TONEMAPPING)\ncolour*=_ExposureAdjustment;\nvec3 X=max(vec3(0.0,0.0,0.0),colour-0.004);\nvec3 retColor=(X*(6.2*X+0.5))/(X*(6.2*X+1.7)+0.06);\ncolour=retColor*retColor;\n#elif defined(PHOTOGRAPHIC_TONEMAPPING)\ncolour=vec3(1.0,1.0,1.0)-exp2(-_ExposureAdjustment*colour);\n#endif\ngl_FragColor=vec4(colour.rgb,1.0);\n}";
Effect.ShadersStore[name81] = shader81;

// node_modules/@babylonjs/core/PostProcesses/tonemapPostProcess.js
var TonemappingOperator;
(function(TonemappingOperator2) {
  TonemappingOperator2[TonemappingOperator2["Hable"] = 0] = "Hable";
  TonemappingOperator2[TonemappingOperator2["Reinhard"] = 1] = "Reinhard";
  TonemappingOperator2[TonemappingOperator2["HejiDawson"] = 2] = "HejiDawson";
  TonemappingOperator2[TonemappingOperator2["Photographic"] = 3] = "Photographic";
})(TonemappingOperator || (TonemappingOperator = {}));
var TonemapPostProcess = function(_super) {
  __extends(TonemapPostProcess2, _super);
  function TonemapPostProcess2(name98, _operator, exposureAdjustment, camera, samplingMode, engine, textureFormat) {
    if (samplingMode === void 0) {
      samplingMode = 2;
    }
    if (textureFormat === void 0) {
      textureFormat = 0;
    }
    var _this = _super.call(this, name98, "tonemap", ["_ExposureAdjustment"], null, 1, camera, samplingMode, engine, true, null, textureFormat) || this;
    _this._operator = _operator;
    _this.exposureAdjustment = exposureAdjustment;
    var defines = "#define ";
    if (_this._operator === TonemappingOperator.Hable) {
      defines += "HABLE_TONEMAPPING";
    } else if (_this._operator === TonemappingOperator.Reinhard) {
      defines += "REINHARD_TONEMAPPING";
    } else if (_this._operator === TonemappingOperator.HejiDawson) {
      defines += "OPTIMIZED_HEJIDAWSON_TONEMAPPING";
    } else if (_this._operator === TonemappingOperator.Photographic) {
      defines += "PHOTOGRAPHIC_TONEMAPPING";
    }
    _this.updateEffect(defines);
    _this.onApply = function(effect) {
      effect.setFloat("_ExposureAdjustment", _this.exposureAdjustment);
    };
    return _this;
  }
  TonemapPostProcess2.prototype.getClassName = function() {
    return "TonemapPostProcess";
  };
  return TonemapPostProcess2;
}(PostProcess);

// node_modules/@babylonjs/core/Shaders/volumetricLightScattering.fragment.js
var name82 = "volumetricLightScatteringPixelShader";
var shader82 = "uniform sampler2D textureSampler;\nuniform sampler2D lightScatteringSampler;\nuniform float decay;\nuniform float exposure;\nuniform float weight;\nuniform float density;\nuniform vec2 meshPositionOnScreen;\nvarying vec2 vUV;\nvoid main(void) {\nvec2 tc=vUV;\nvec2 deltaTexCoord=(tc-meshPositionOnScreen.xy);\ndeltaTexCoord*=1.0/float(NUM_SAMPLES)*density;\nfloat illuminationDecay=1.0;\nvec4 color=texture2D(lightScatteringSampler,tc)*0.4;\nfor(int i=0; i<NUM_SAMPLES; i++) {\ntc-=deltaTexCoord;\nvec4 dataSample=texture2D(lightScatteringSampler,tc)*0.4;\ndataSample*=illuminationDecay*weight;\ncolor+=dataSample;\nilluminationDecay*=decay;\n}\nvec4 realColor=texture2D(textureSampler,vUV);\ngl_FragColor=((vec4((vec3(color.r,color.g,color.b)*exposure),1))+(realColor*(1.5-0.4)));\n}\n";
Effect.ShadersStore[name82] = shader82;

// node_modules/@babylonjs/core/Shaders/volumetricLightScatteringPass.vertex.js
var name83 = "volumetricLightScatteringPassVertexShader";
var shader83 = "\nattribute vec3 position;\n#include<bonesDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\nuniform vec2 depthValues;\n#if defined(ALPHATEST) || defined(NEED_UV)\nvarying vec2 vUV;\nuniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\nvoid main(void)\n{\nvec3 positionUpdated=position;\n#if (defined(ALPHATEST) || defined(NEED_UV)) && defined(UV1)\nvec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\ngl_Position=viewProjection*finalWorld*vec4(positionUpdated,1.0);\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n}\n";
Effect.ShadersStore[name83] = shader83;

// node_modules/@babylonjs/core/Shaders/volumetricLightScatteringPass.fragment.js
var name84 = "volumetricLightScatteringPassPixelShader";
var shader84 = "#if defined(ALPHATEST) || defined(NEED_UV)\nvarying vec2 vUV;\n#endif\n#if defined(ALPHATEST)\nuniform sampler2D diffuseSampler;\n#endif\nvoid main(void)\n{\n#if defined(ALPHATEST)\nvec4 diffuseColor=texture2D(diffuseSampler,vUV);\nif (diffuseColor.a<0.4)\ndiscard;\n#endif\ngl_FragColor=vec4(0.0,0.0,0.0,1.0);\n}\n";
Effect.ShadersStore[name84] = shader84;

// node_modules/@babylonjs/core/PostProcesses/volumetricLightScatteringPostProcess.js
var VolumetricLightScatteringPostProcess = function(_super) {
  __extends(VolumetricLightScatteringPostProcess2, _super);
  function VolumetricLightScatteringPostProcess2(name98, ratio, camera, mesh, samples, samplingMode, engine, reusable, scene) {
    if (samples === void 0) {
      samples = 100;
    }
    if (samplingMode === void 0) {
      samplingMode = Texture.BILINEAR_SAMPLINGMODE;
    }
    var _this = _super.call(this, name98, "volumetricLightScattering", ["decay", "exposure", "weight", "meshPositionOnScreen", "density"], ["lightScatteringSampler"], ratio.postProcessRatio || ratio, camera, samplingMode, engine, reusable, "#define NUM_SAMPLES " + samples) || this;
    _this._screenCoordinates = Vector2.Zero();
    _this.customMeshPosition = Vector3.Zero();
    _this.useCustomMeshPosition = false;
    _this.invert = true;
    _this.excludedMeshes = new Array();
    _this.exposure = 0.3;
    _this.decay = 0.96815;
    _this.weight = 0.58767;
    _this.density = 0.926;
    scene = camera === null ? scene : camera.getScene();
    engine = scene.getEngine();
    _this._viewPort = new Viewport(0, 0, 1, 1).toGlobal(engine.getRenderWidth(), engine.getRenderHeight());
    _this.mesh = mesh !== null ? mesh : VolumetricLightScatteringPostProcess2.CreateDefaultMesh("VolumetricLightScatteringMesh", scene);
    _this._createPass(scene, ratio.passRatio || ratio);
    _this.onActivate = function(camera2) {
      if (!_this.isSupported) {
        _this.dispose(camera2);
      }
      _this.onActivate = null;
    };
    _this.onApplyObservable.add(function(effect) {
      _this._updateMeshScreenCoordinates(scene);
      effect.setTexture("lightScatteringSampler", _this._volumetricLightScatteringRTT);
      effect.setFloat("exposure", _this.exposure);
      effect.setFloat("decay", _this.decay);
      effect.setFloat("weight", _this.weight);
      effect.setFloat("density", _this.density);
      effect.setVector2("meshPositionOnScreen", _this._screenCoordinates);
    });
    return _this;
  }
  Object.defineProperty(VolumetricLightScatteringPostProcess2.prototype, "useDiffuseColor", {
    get: function() {
      Logger.Warn("VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead");
      return false;
    },
    set: function(useDiffuseColor) {
      Logger.Warn("VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead");
    },
    enumerable: false,
    configurable: true
  });
  VolumetricLightScatteringPostProcess2.prototype.getClassName = function() {
    return "VolumetricLightScatteringPostProcess";
  };
  VolumetricLightScatteringPostProcess2.prototype._isReady = function(subMesh, useInstances) {
    var mesh = subMesh.getMesh();
    if (mesh === this.mesh && mesh.material) {
      return mesh.material.isReady(mesh);
    }
    var defines = [];
    var attribs = [VertexBuffer.PositionKind];
    var material = subMesh.getMaterial();
    if (material) {
      if (material.needAlphaTesting()) {
        defines.push("#define ALPHATEST");
      }
      if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
        attribs.push(VertexBuffer.UVKind);
        defines.push("#define UV1");
      }
      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
        attribs.push(VertexBuffer.UV2Kind);
        defines.push("#define UV2");
      }
    }
    if (mesh.useBones && mesh.computeBonesUsingShaders) {
      attribs.push(VertexBuffer.MatricesIndicesKind);
      attribs.push(VertexBuffer.MatricesWeightsKind);
      defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
      defines.push("#define BonesPerMesh " + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));
    } else {
      defines.push("#define NUM_BONE_INFLUENCERS 0");
    }
    if (useInstances) {
      defines.push("#define INSTANCES");
      MaterialHelper.PushAttributesForInstances(attribs);
      if (subMesh.getRenderingMesh().hasThinInstances) {
        defines.push("#define THIN_INSTANCES");
      }
    }
    var join = defines.join("\n");
    if (this._cachedDefines !== join) {
      this._cachedDefines = join;
      this._volumetricLightScatteringPass = mesh.getScene().getEngine().createEffect("volumetricLightScatteringPass", attribs, ["world", "mBones", "viewProjection", "diffuseMatrix"], ["diffuseSampler"], join, void 0, void 0, void 0, { maxSimultaneousMorphTargets: mesh.numBoneInfluencers });
    }
    return this._volumetricLightScatteringPass.isReady();
  };
  VolumetricLightScatteringPostProcess2.prototype.setCustomMeshPosition = function(position) {
    this.customMeshPosition = position;
  };
  VolumetricLightScatteringPostProcess2.prototype.getCustomMeshPosition = function() {
    return this.customMeshPosition;
  };
  VolumetricLightScatteringPostProcess2.prototype.dispose = function(camera) {
    var rttIndex = camera.getScene().customRenderTargets.indexOf(this._volumetricLightScatteringRTT);
    if (rttIndex !== -1) {
      camera.getScene().customRenderTargets.splice(rttIndex, 1);
    }
    this._volumetricLightScatteringRTT.dispose();
    _super.prototype.dispose.call(this, camera);
  };
  VolumetricLightScatteringPostProcess2.prototype.getPass = function() {
    return this._volumetricLightScatteringRTT;
  };
  VolumetricLightScatteringPostProcess2.prototype._meshExcluded = function(mesh) {
    if (this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {
      return true;
    }
    return false;
  };
  VolumetricLightScatteringPostProcess2.prototype._createPass = function(scene, ratio) {
    var _this = this;
    var engine = scene.getEngine();
    this._volumetricLightScatteringRTT = new RenderTargetTexture("volumetricLightScatteringMap", { width: engine.getRenderWidth() * ratio, height: engine.getRenderHeight() * ratio }, scene, false, true, 0);
    this._volumetricLightScatteringRTT.wrapU = Texture.CLAMP_ADDRESSMODE;
    this._volumetricLightScatteringRTT.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._volumetricLightScatteringRTT.renderList = null;
    this._volumetricLightScatteringRTT.renderParticles = false;
    this._volumetricLightScatteringRTT.ignoreCameraViewport = true;
    var camera = this.getCamera();
    if (camera) {
      camera.customRenderTargets.push(this._volumetricLightScatteringRTT);
    } else {
      scene.customRenderTargets.push(this._volumetricLightScatteringRTT);
    }
    var renderSubMesh = function(subMesh) {
      var renderingMesh = subMesh.getRenderingMesh();
      var effectiveMesh = subMesh.getEffectiveMesh();
      if (_this._meshExcluded(renderingMesh)) {
        return;
      }
      effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;
      var material = subMesh.getMaterial();
      if (!material) {
        return;
      }
      var scene2 = renderingMesh.getScene();
      var engine2 = scene2.getEngine();
      engine2.setState(material.backFaceCulling);
      var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
      if (batch.mustReturn) {
        return;
      }
      var hardwareInstancedRendering = engine2.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);
      if (_this._isReady(subMesh, hardwareInstancedRendering)) {
        var effect = _this._volumetricLightScatteringPass;
        if (renderingMesh === _this.mesh) {
          if (subMesh.effect) {
            effect = subMesh.effect;
          } else {
            effect = material.getEffect();
          }
        }
        engine2.enableEffect(effect);
        renderingMesh._bind(subMesh, effect, material.fillMode);
        if (renderingMesh === _this.mesh) {
          material.bind(effectiveMesh.getWorldMatrix(), renderingMesh);
        } else {
          _this._volumetricLightScatteringPass.setMatrix("viewProjection", scene2.getTransformMatrix());
          if (material && material.needAlphaTesting()) {
            var alphaTexture = material.getAlphaTestTexture();
            _this._volumetricLightScatteringPass.setTexture("diffuseSampler", alphaTexture);
            if (alphaTexture) {
              _this._volumetricLightScatteringPass.setMatrix("diffuseMatrix", alphaTexture.getTextureMatrix());
            }
          }
          if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {
            _this._volumetricLightScatteringPass.setMatrices("mBones", renderingMesh.skeleton.getTransformMatrices(renderingMesh));
          }
        }
        renderingMesh._processRendering(effectiveMesh, subMesh, _this._volumetricLightScatteringPass, Material.TriangleFillMode, batch, hardwareInstancedRendering, function(isInstance, world) {
          return effect.setMatrix("world", world);
        });
      }
    };
    var savedSceneClearColor;
    var sceneClearColor = new Color4(0, 0, 0, 1);
    this._volumetricLightScatteringRTT.onBeforeRenderObservable.add(function() {
      savedSceneClearColor = scene.clearColor;
      scene.clearColor = sceneClearColor;
    });
    this._volumetricLightScatteringRTT.onAfterRenderObservable.add(function() {
      scene.clearColor = savedSceneClearColor;
    });
    this._volumetricLightScatteringRTT.customRenderFunction = function(opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {
      var engine2 = scene.getEngine();
      var index;
      if (depthOnlySubMeshes.length) {
        engine2.setColorWrite(false);
        for (index = 0; index < depthOnlySubMeshes.length; index++) {
          renderSubMesh(depthOnlySubMeshes.data[index]);
        }
        engine2.setColorWrite(true);
      }
      for (index = 0; index < opaqueSubMeshes.length; index++) {
        renderSubMesh(opaqueSubMeshes.data[index]);
      }
      for (index = 0; index < alphaTestSubMeshes.length; index++) {
        renderSubMesh(alphaTestSubMeshes.data[index]);
      }
      if (transparentSubMeshes.length) {
        for (index = 0; index < transparentSubMeshes.length; index++) {
          var submesh = transparentSubMeshes.data[index];
          var boundingInfo = submesh.getBoundingInfo();
          if (boundingInfo && scene.activeCamera) {
            submesh._alphaIndex = submesh.getMesh().alphaIndex;
            submesh._distanceToCamera = boundingInfo.boundingSphere.centerWorld.subtract(scene.activeCamera.position).length();
          }
        }
        var sortedArray = transparentSubMeshes.data.slice(0, transparentSubMeshes.length);
        sortedArray.sort(function(a, b) {
          if (a._alphaIndex > b._alphaIndex) {
            return 1;
          }
          if (a._alphaIndex < b._alphaIndex) {
            return -1;
          }
          if (a._distanceToCamera < b._distanceToCamera) {
            return 1;
          }
          if (a._distanceToCamera > b._distanceToCamera) {
            return -1;
          }
          return 0;
        });
        engine2.setAlphaMode(2);
        for (index = 0; index < sortedArray.length; index++) {
          renderSubMesh(sortedArray[index]);
        }
        engine2.setAlphaMode(0);
      }
    };
  };
  VolumetricLightScatteringPostProcess2.prototype._updateMeshScreenCoordinates = function(scene) {
    var transform = scene.getTransformMatrix();
    var meshPosition;
    if (this.useCustomMeshPosition) {
      meshPosition = this.customMeshPosition;
    } else if (this.attachedNode) {
      meshPosition = this.attachedNode.position;
    } else {
      meshPosition = this.mesh.parent ? this.mesh.getAbsolutePosition() : this.mesh.position;
    }
    var pos = Vector3.Project(meshPosition, Matrix.Identity(), transform, this._viewPort);
    this._screenCoordinates.x = pos.x / this._viewPort.width;
    this._screenCoordinates.y = pos.y / this._viewPort.height;
    if (this.invert) {
      this._screenCoordinates.y = 1 - this._screenCoordinates.y;
    }
  };
  VolumetricLightScatteringPostProcess2.CreateDefaultMesh = function(name98, scene) {
    var mesh = Mesh.CreatePlane(name98, 1, scene);
    mesh.billboardMode = AbstractMesh.BILLBOARDMODE_ALL;
    var material = new StandardMaterial(name98 + "Material", scene);
    material.emissiveColor = new Color3(1, 1, 1);
    mesh.material = material;
    return mesh;
  };
  __decorate([
    serializeAsVector3()
  ], VolumetricLightScatteringPostProcess2.prototype, "customMeshPosition", void 0);
  __decorate([
    serialize()
  ], VolumetricLightScatteringPostProcess2.prototype, "useCustomMeshPosition", void 0);
  __decorate([
    serialize()
  ], VolumetricLightScatteringPostProcess2.prototype, "invert", void 0);
  __decorate([
    serializeAsMeshReference()
  ], VolumetricLightScatteringPostProcess2.prototype, "mesh", void 0);
  __decorate([
    serialize()
  ], VolumetricLightScatteringPostProcess2.prototype, "excludedMeshes", void 0);
  __decorate([
    serialize()
  ], VolumetricLightScatteringPostProcess2.prototype, "exposure", void 0);
  __decorate([
    serialize()
  ], VolumetricLightScatteringPostProcess2.prototype, "decay", void 0);
  __decorate([
    serialize()
  ], VolumetricLightScatteringPostProcess2.prototype, "weight", void 0);
  __decorate([
    serialize()
  ], VolumetricLightScatteringPostProcess2.prototype, "density", void 0);
  return VolumetricLightScatteringPostProcess2;
}(PostProcess);
_TypeStore.RegisteredTypes["BABYLON.VolumetricLightScatteringPostProcess"] = VolumetricLightScatteringPostProcess;

// node_modules/@babylonjs/core/Shaders/screenSpaceCurvature.fragment.js
var name85 = "screenSpaceCurvaturePixelShader";
var shader85 = "\n\nprecision highp float;\n\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform sampler2D normalSampler;\nuniform float curvature_ridge;\nuniform float curvature_valley;\n#ifndef CURVATURE_OFFSET\n#define CURVATURE_OFFSET 1\n#endif\nfloat curvature_soft_clamp(float curvature,float control)\n{\nif (curvature<0.5/control)\nreturn curvature*(1.0-curvature*control);\nreturn 0.25/control;\n}\nfloat calculate_curvature(ivec2 texel,float ridge,float valley)\n{\nvec2 normal_up=texelFetchOffset(normalSampler,texel,0,ivec2(0,CURVATURE_OFFSET)).rb;\nvec2 normal_down=texelFetchOffset(normalSampler,texel,0,ivec2(0,-CURVATURE_OFFSET)).rb;\nvec2 normal_left=texelFetchOffset(normalSampler,texel,0,ivec2(-CURVATURE_OFFSET,0)).rb;\nvec2 normal_right=texelFetchOffset(normalSampler,texel,0,ivec2( CURVATURE_OFFSET,0)).rb;\nfloat normal_diff=((normal_up.g-normal_down.g)+(normal_right.r-normal_left.r));\nif (normal_diff<0.0)\nreturn -2.0*curvature_soft_clamp(-normal_diff,valley);\nreturn 2.0*curvature_soft_clamp(normal_diff,ridge);\n}\nvoid main(void)\n{\nivec2 texel=ivec2(gl_FragCoord.xy);\nvec4 baseColor=texture2D(textureSampler,vUV);\nfloat curvature=calculate_curvature(texel,curvature_ridge,curvature_valley);\nbaseColor.rgb*=curvature+1.0;\ngl_FragColor=baseColor;\n}";
Effect.ShadersStore[name85] = shader85;

// node_modules/@babylonjs/core/PostProcesses/screenSpaceCurvaturePostProcess.js
var ScreenSpaceCurvaturePostProcess = function(_super) {
  __extends(ScreenSpaceCurvaturePostProcess2, _super);
  function ScreenSpaceCurvaturePostProcess2(name98, scene, options, camera, samplingMode, engine, reusable, textureType, blockCompilation) {
    if (textureType === void 0) {
      textureType = 0;
    }
    if (blockCompilation === void 0) {
      blockCompilation = false;
    }
    var _this = _super.call(this, name98, "screenSpaceCurvature", ["curvature_ridge", "curvature_valley"], ["textureSampler", "normalSampler"], options, camera, samplingMode, engine, reusable, void 0, textureType, void 0, null, blockCompilation) || this;
    _this.ridge = 1;
    _this.valley = 1;
    _this._geometryBufferRenderer = scene.enableGeometryBufferRenderer();
    if (!_this._geometryBufferRenderer) {
      Logger.Error("Multiple Render Target support needed for screen space curvature post process. Please use IsSupported test first.");
    } else {
      _this.onApply = function(effect) {
        effect.setFloat("curvature_ridge", 0.5 / Math.max(_this.ridge * _this.ridge, 1e-4));
        effect.setFloat("curvature_valley", 0.7 / Math.max(_this.valley * _this.valley, 1e-4));
        var normalTexture = _this._geometryBufferRenderer.getGBuffer().textures[1];
        effect.setTexture("normalSampler", normalTexture);
      };
    }
    return _this;
  }
  ScreenSpaceCurvaturePostProcess2.prototype.getClassName = function() {
    return "ScreenSpaceCurvaturePostProcess";
  };
  Object.defineProperty(ScreenSpaceCurvaturePostProcess2, "IsSupported", {
    get: function() {
      var engine = EngineStore.LastCreatedEngine;
      if (!engine) {
        return false;
      }
      return engine.webGLVersion > 1 || engine.getCaps().drawBuffersExtension;
    },
    enumerable: false,
    configurable: true
  });
  ScreenSpaceCurvaturePostProcess2._Parse = function(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(function() {
      return new ScreenSpaceCurvaturePostProcess2(parsedPostProcess.name, scene, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.textureType, parsedPostProcess.reusable);
    }, parsedPostProcess, scene, rootUrl);
  };
  __decorate([
    serialize()
  ], ScreenSpaceCurvaturePostProcess2.prototype, "ridge", void 0);
  __decorate([
    serialize()
  ], ScreenSpaceCurvaturePostProcess2.prototype, "valley", void 0);
  return ScreenSpaceCurvaturePostProcess2;
}(PostProcess);
_TypeStore.RegisteredTypes["BABYLON.ScreenSpaceCurvaturePostProcess"] = ScreenSpaceCurvaturePostProcess;

// node_modules/@babylonjs/core/Rendering/boundingBoxRenderer.js
Object.defineProperty(Scene.prototype, "forceShowBoundingBoxes", {
  get: function() {
    return this._forceShowBoundingBoxes || false;
  },
  set: function(value) {
    this._forceShowBoundingBoxes = value;
    if (value) {
      this.getBoundingBoxRenderer();
    }
  },
  enumerable: true,
  configurable: true
});
Scene.prototype.getBoundingBoxRenderer = function() {
  if (!this._boundingBoxRenderer) {
    this._boundingBoxRenderer = new BoundingBoxRenderer(this);
  }
  return this._boundingBoxRenderer;
};
Object.defineProperty(AbstractMesh.prototype, "showBoundingBox", {
  get: function() {
    return this._showBoundingBox || false;
  },
  set: function(value) {
    this._showBoundingBox = value;
    if (value) {
      this.getScene().getBoundingBoxRenderer();
    }
  },
  enumerable: true,
  configurable: true
});
var BoundingBoxRenderer = function() {
  function BoundingBoxRenderer2(scene) {
    this.name = SceneComponentConstants.NAME_BOUNDINGBOXRENDERER;
    this.frontColor = new Color3(1, 1, 1);
    this.backColor = new Color3(0.1, 0.1, 0.1);
    this.showBackLines = true;
    this.onBeforeBoxRenderingObservable = new Observable();
    this.onAfterBoxRenderingObservable = new Observable();
    this.onResourcesReadyObservable = new Observable();
    this.enabled = true;
    this.renderList = new SmartArray(32);
    this._vertexBuffers = {};
    this._fillIndexBuffer = null;
    this._fillIndexData = null;
    this.scene = scene;
    scene._addComponent(this);
  }
  BoundingBoxRenderer2.prototype.register = function() {
    this.scene._beforeEvaluateActiveMeshStage.registerStep(SceneComponentConstants.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER, this, this.reset);
    this.scene._preActiveMeshStage.registerStep(SceneComponentConstants.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER, this, this._preActiveMesh);
    this.scene._evaluateSubMeshStage.registerStep(SceneComponentConstants.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER, this, this._evaluateSubMesh);
    this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER, this, this.render);
  };
  BoundingBoxRenderer2.prototype._evaluateSubMesh = function(mesh, subMesh) {
    if (mesh.showSubMeshesBoundingBox) {
      var boundingInfo = subMesh.getBoundingInfo();
      if (boundingInfo !== null && boundingInfo !== void 0) {
        boundingInfo.boundingBox._tag = mesh.renderingGroupId;
        this.renderList.push(boundingInfo.boundingBox);
      }
    }
  };
  BoundingBoxRenderer2.prototype._preActiveMesh = function(mesh) {
    if (mesh.showBoundingBox || this.scene.forceShowBoundingBoxes) {
      var boundingInfo = mesh.getBoundingInfo();
      boundingInfo.boundingBox._tag = mesh.renderingGroupId;
      this.renderList.push(boundingInfo.boundingBox);
    }
  };
  BoundingBoxRenderer2.prototype._prepareResources = function() {
    if (this._colorShader) {
      return;
    }
    this._colorShader = new ShaderMaterial("colorShader", this.scene, "color", {
      attributes: [VertexBuffer.PositionKind],
      uniforms: ["world", "viewProjection", "color"]
    });
    this._colorShader.reservedDataStore = {
      hidden: true
    };
    var engine = this.scene.getEngine();
    var boxdata = VertexData.CreateBox({ size: 1 });
    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, boxdata.positions, VertexBuffer.PositionKind, false);
    this._createIndexBuffer();
    this._fillIndexData = boxdata.indices;
    this.onResourcesReadyObservable.notifyObservers(this);
  };
  BoundingBoxRenderer2.prototype._createIndexBuffer = function() {
    var engine = this.scene.getEngine();
    this._indexBuffer = engine.createIndexBuffer([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 7, 1, 6, 2, 5, 3, 4]);
  };
  BoundingBoxRenderer2.prototype.rebuild = function() {
    var vb = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vb) {
      vb._rebuild();
    }
    this._createIndexBuffer();
  };
  BoundingBoxRenderer2.prototype.reset = function() {
    this.renderList.reset();
  };
  BoundingBoxRenderer2.prototype.render = function(renderingGroupId) {
    if (this.renderList.length === 0 || !this.enabled) {
      return;
    }
    this._prepareResources();
    if (!this._colorShader.isReady()) {
      return;
    }
    var engine = this.scene.getEngine();
    engine.setDepthWrite(false);
    this._colorShader._preBind();
    for (var boundingBoxIndex = 0; boundingBoxIndex < this.renderList.length; boundingBoxIndex++) {
      var boundingBox = this.renderList.data[boundingBoxIndex];
      if (boundingBox._tag !== renderingGroupId) {
        continue;
      }
      this.onBeforeBoxRenderingObservable.notifyObservers(boundingBox);
      var min = boundingBox.minimum;
      var max = boundingBox.maximum;
      var diff = max.subtract(min);
      var median = min.add(diff.scale(0.5));
      var worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z).multiply(Matrix.Translation(median.x, median.y, median.z)).multiply(boundingBox.getWorldMatrix());
      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._colorShader.getEffect());
      if (this.showBackLines) {
        engine.setDepthFunctionToGreaterOrEqual();
        this.scene.resetCachedMaterial();
        this._colorShader.setColor4("color", this.backColor.toColor4());
        this._colorShader.bind(worldMatrix);
        engine.drawElementsType(Material.LineListDrawMode, 0, 24);
      }
      engine.setDepthFunctionToLess();
      this.scene.resetCachedMaterial();
      this._colorShader.setColor4("color", this.frontColor.toColor4());
      this._colorShader.bind(worldMatrix);
      engine.drawElementsType(Material.LineListDrawMode, 0, 24);
      this.onAfterBoxRenderingObservable.notifyObservers(boundingBox);
    }
    this._colorShader.unbind();
    engine.setDepthFunctionToLessOrEqual();
    engine.setDepthWrite(true);
  };
  BoundingBoxRenderer2.prototype.renderOcclusionBoundingBox = function(mesh) {
    this._prepareResources();
    if (!this._colorShader.isReady() || !mesh._boundingInfo) {
      return;
    }
    var engine = this.scene.getEngine();
    if (!this._fillIndexBuffer) {
      this._fillIndexBuffer = engine.createIndexBuffer(this._fillIndexData);
    }
    engine.setDepthWrite(false);
    engine.setColorWrite(false);
    this._colorShader._preBind();
    var boundingBox = mesh._boundingInfo.boundingBox;
    var min = boundingBox.minimum;
    var max = boundingBox.maximum;
    var diff = max.subtract(min);
    var median = min.add(diff.scale(0.5));
    var worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z).multiply(Matrix.Translation(median.x, median.y, median.z)).multiply(boundingBox.getWorldMatrix());
    engine.bindBuffers(this._vertexBuffers, this._fillIndexBuffer, this._colorShader.getEffect());
    engine.setDepthFunctionToLess();
    this.scene.resetCachedMaterial();
    this._colorShader.bind(worldMatrix);
    engine.drawElementsType(Material.TriangleFillMode, 0, 36);
    this._colorShader.unbind();
    engine.setDepthFunctionToLessOrEqual();
    engine.setDepthWrite(true);
    engine.setColorWrite(true);
  };
  BoundingBoxRenderer2.prototype.dispose = function() {
    if (!this._colorShader) {
      return;
    }
    this.onBeforeBoxRenderingObservable.clear();
    this.onAfterBoxRenderingObservable.clear();
    this.onResourcesReadyObservable.clear();
    this.renderList.dispose();
    this._colorShader.dispose();
    var buffer = this._vertexBuffers[VertexBuffer.PositionKind];
    if (buffer) {
      buffer.dispose();
      this._vertexBuffers[VertexBuffer.PositionKind] = null;
    }
    this.scene.getEngine()._releaseBuffer(this._indexBuffer);
    if (this._fillIndexBuffer) {
      this.scene.getEngine()._releaseBuffer(this._fillIndexBuffer);
      this._fillIndexBuffer = null;
    }
  };
  return BoundingBoxRenderer2;
}();

// node_modules/@babylonjs/core/Rendering/depthRendererSceneComponent.js
Scene.prototype.enableDepthRenderer = function(camera, storeNonLinearDepth, force32bitsFloat) {
  if (storeNonLinearDepth === void 0) {
    storeNonLinearDepth = false;
  }
  if (force32bitsFloat === void 0) {
    force32bitsFloat = false;
  }
  camera = camera || this.activeCamera;
  if (!camera) {
    throw "No camera available to enable depth renderer";
  }
  if (!this._depthRenderer) {
    this._depthRenderer = {};
  }
  if (!this._depthRenderer[camera.id]) {
    var supportFullfloat = !!this.getEngine().getCaps().textureFloatRender;
    var textureType = 0;
    if (this.getEngine().getCaps().textureHalfFloatRender && (!force32bitsFloat || !supportFullfloat)) {
      textureType = 2;
    } else if (supportFullfloat) {
      textureType = 1;
    } else {
      textureType = 0;
    }
    this._depthRenderer[camera.id] = new DepthRenderer(this, textureType, camera, storeNonLinearDepth);
  }
  return this._depthRenderer[camera.id];
};
Scene.prototype.disableDepthRenderer = function(camera) {
  camera = camera || this.activeCamera;
  if (!camera || !this._depthRenderer || !this._depthRenderer[camera.id]) {
    return;
  }
  this._depthRenderer[camera.id].dispose();
  delete this._depthRenderer[camera.id];
};
var DepthRendererSceneComponent = function() {
  function DepthRendererSceneComponent2(scene) {
    this.name = SceneComponentConstants.NAME_DEPTHRENDERER;
    this.scene = scene;
  }
  DepthRendererSceneComponent2.prototype.register = function() {
    this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_DEPTHRENDERER, this, this._gatherRenderTargets);
    this.scene._gatherActiveCameraRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER, this, this._gatherActiveCameraRenderTargets);
  };
  DepthRendererSceneComponent2.prototype.rebuild = function() {
  };
  DepthRendererSceneComponent2.prototype.dispose = function() {
    for (var key in this.scene._depthRenderer) {
      this.scene._depthRenderer[key].dispose();
    }
  };
  DepthRendererSceneComponent2.prototype._gatherRenderTargets = function(renderTargets) {
    if (this.scene._depthRenderer) {
      for (var key in this.scene._depthRenderer) {
        var depthRenderer = this.scene._depthRenderer[key];
        if (depthRenderer.enabled && !depthRenderer.useOnlyInActiveCamera) {
          renderTargets.push(depthRenderer.getDepthMap());
        }
      }
    }
  };
  DepthRendererSceneComponent2.prototype._gatherActiveCameraRenderTargets = function(renderTargets) {
    if (this.scene._depthRenderer) {
      for (var key in this.scene._depthRenderer) {
        var depthRenderer = this.scene._depthRenderer[key];
        if (depthRenderer.enabled && depthRenderer.useOnlyInActiveCamera && this.scene.activeCamera.id === key) {
          renderTargets.push(depthRenderer.getDepthMap());
        }
      }
    }
  };
  return DepthRendererSceneComponent2;
}();
DepthRenderer._SceneComponentInitialization = function(scene) {
  var component = scene._getComponent(SceneComponentConstants.NAME_DEPTHRENDERER);
  if (!component) {
    component = new DepthRendererSceneComponent(scene);
    scene._addComponent(component);
  }
};

// node_modules/@babylonjs/core/Shaders/line.fragment.js
var name86 = "linePixelShader";
var shader86 = "uniform vec4 color;\nvoid main(void) {\ngl_FragColor=color;\n}";
Effect.ShadersStore[name86] = shader86;

// node_modules/@babylonjs/core/Shaders/line.vertex.js
var name87 = "lineVertexShader";
var shader87 = "#include<instancesDeclaration>\n\nattribute vec3 position;\nattribute vec4 normal;\n\nuniform mat4 viewProjection;\nuniform float width;\nuniform float aspectRatio;\nvoid main(void) {\n#include<instancesVertex>\nmat4 worldViewProjection=viewProjection*finalWorld;\nvec4 viewPosition=worldViewProjection*vec4(position,1.0);\nvec4 viewPositionNext=worldViewProjection*vec4(normal.xyz,1.0);\nvec2 currentScreen=viewPosition.xy/viewPosition.w;\nvec2 nextScreen=viewPositionNext.xy/viewPositionNext.w;\ncurrentScreen.x*=aspectRatio;\nnextScreen.x*=aspectRatio;\nvec2 dir=normalize(nextScreen-currentScreen);\nvec2 normalDir=vec2(-dir.y,dir.x);\nnormalDir*=width/2.0;\nnormalDir.x/=aspectRatio;\nvec4 offset=vec4(normalDir*normal.w,0.0,0.0);\ngl_Position=viewPosition+offset;\n}";
Effect.ShadersStore[name87] = shader87;

// node_modules/@babylonjs/core/Rendering/edgesRenderer.js
AbstractMesh.prototype.disableEdgesRendering = function() {
  if (this._edgesRenderer) {
    this._edgesRenderer.dispose();
    this._edgesRenderer = null;
  }
  return this;
};
AbstractMesh.prototype.enableEdgesRendering = function(epsilon, checkVerticesInsteadOfIndices, options) {
  if (epsilon === void 0) {
    epsilon = 0.95;
  }
  if (checkVerticesInsteadOfIndices === void 0) {
    checkVerticesInsteadOfIndices = false;
  }
  this.disableEdgesRendering();
  this._edgesRenderer = new EdgesRenderer(this, epsilon, checkVerticesInsteadOfIndices, true, options);
  return this;
};
Object.defineProperty(AbstractMesh.prototype, "edgesRenderer", {
  get: function() {
    return this._edgesRenderer;
  },
  enumerable: true,
  configurable: true
});
LinesMesh.prototype.enableEdgesRendering = function(epsilon, checkVerticesInsteadOfIndices) {
  if (epsilon === void 0) {
    epsilon = 0.95;
  }
  if (checkVerticesInsteadOfIndices === void 0) {
    checkVerticesInsteadOfIndices = false;
  }
  this.disableEdgesRendering();
  this._edgesRenderer = new LineEdgesRenderer(this, epsilon, checkVerticesInsteadOfIndices);
  return this;
};
InstancedLinesMesh.prototype.enableEdgesRendering = function(epsilon, checkVerticesInsteadOfIndices) {
  if (epsilon === void 0) {
    epsilon = 0.95;
  }
  if (checkVerticesInsteadOfIndices === void 0) {
    checkVerticesInsteadOfIndices = false;
  }
  LinesMesh.prototype.enableEdgesRendering.apply(this, arguments);
  return this;
};
var FaceAdjacencies = function() {
  function FaceAdjacencies2() {
    this.edges = new Array();
    this.edgesConnectedCount = 0;
  }
  return FaceAdjacencies2;
}();
var EdgesRenderer = function() {
  function EdgesRenderer2(source, epsilon, checkVerticesInsteadOfIndices, generateEdgesLines, options) {
    var _this = this;
    if (epsilon === void 0) {
      epsilon = 0.95;
    }
    if (checkVerticesInsteadOfIndices === void 0) {
      checkVerticesInsteadOfIndices = false;
    }
    if (generateEdgesLines === void 0) {
      generateEdgesLines = true;
    }
    var _a;
    this.edgesWidthScalerForOrthographic = 1e3;
    this.edgesWidthScalerForPerspective = 50;
    this._linesPositions = new Array();
    this._linesNormals = new Array();
    this._linesIndices = new Array();
    this._buffers = {};
    this._buffersForInstances = {};
    this._checkVerticesInsteadOfIndices = false;
    this.isEnabled = true;
    this.customInstances = new SmartArray(32);
    this._source = source;
    this._checkVerticesInsteadOfIndices = checkVerticesInsteadOfIndices;
    this._options = options !== null && options !== void 0 ? options : null;
    this._epsilon = epsilon;
    this._prepareRessources();
    if (generateEdgesLines) {
      if ((_a = options === null || options === void 0 ? void 0 : options.useAlternateEdgeFinder) !== null && _a !== void 0 ? _a : true) {
        this._generateEdgesLinesAlternate();
      } else {
        this._generateEdgesLines();
      }
    }
    this._meshRebuildObserver = this._source.onRebuildObservable.add(function() {
      _this._rebuild();
    });
    this._meshDisposeObserver = this._source.onDisposeObservable.add(function() {
      _this.dispose();
    });
  }
  Object.defineProperty(EdgesRenderer2.prototype, "linesPositions", {
    get: function() {
      return this._linesPositions;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EdgesRenderer2.prototype, "linesNormals", {
    get: function() {
      return this._linesNormals;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EdgesRenderer2.prototype, "linesIndices", {
    get: function() {
      return this._linesIndices;
    },
    enumerable: false,
    configurable: true
  });
  EdgesRenderer2.GetShader = function(scene) {
    if (!scene._edgeRenderLineShader) {
      var shader98 = new ShaderMaterial("lineShader", scene, "line", {
        attributes: ["position", "normal"],
        uniforms: ["world", "viewProjection", "color", "width", "aspectRatio"]
      });
      shader98.disableDepthWrite = true;
      shader98.backFaceCulling = false;
      scene._edgeRenderLineShader = shader98;
    }
    return scene._edgeRenderLineShader;
  };
  EdgesRenderer2.prototype._prepareRessources = function() {
    if (this._lineShader) {
      return;
    }
    this._lineShader = EdgesRenderer2.GetShader(this._source.getScene());
  };
  EdgesRenderer2.prototype._rebuild = function() {
    var buffer = this._buffers[VertexBuffer.PositionKind];
    if (buffer) {
      buffer._rebuild();
    }
    buffer = this._buffers[VertexBuffer.NormalKind];
    if (buffer) {
      buffer._rebuild();
    }
    var scene = this._source.getScene();
    var engine = scene.getEngine();
    this._ib = engine.createIndexBuffer(this._linesIndices);
  };
  EdgesRenderer2.prototype.dispose = function() {
    this._source.onRebuildObservable.remove(this._meshRebuildObserver);
    this._source.onDisposeObservable.remove(this._meshDisposeObserver);
    var buffer = this._buffers[VertexBuffer.PositionKind];
    if (buffer) {
      buffer.dispose();
      this._buffers[VertexBuffer.PositionKind] = null;
    }
    buffer = this._buffers[VertexBuffer.NormalKind];
    if (buffer) {
      buffer.dispose();
      this._buffers[VertexBuffer.NormalKind] = null;
    }
    if (this._ib) {
      this._source.getScene().getEngine()._releaseBuffer(this._ib);
    }
    this._lineShader.dispose();
  };
  EdgesRenderer2.prototype._processEdgeForAdjacencies = function(pa, pb, p0, p1, p2) {
    if (pa === p0 && pb === p1 || pa === p1 && pb === p0) {
      return 0;
    }
    if (pa === p1 && pb === p2 || pa === p2 && pb === p1) {
      return 1;
    }
    if (pa === p2 && pb === p0 || pa === p0 && pb === p2) {
      return 2;
    }
    return -1;
  };
  EdgesRenderer2.prototype._processEdgeForAdjacenciesWithVertices = function(pa, pb, p0, p1, p2) {
    var eps = 1e-10;
    if (pa.equalsWithEpsilon(p0, eps) && pb.equalsWithEpsilon(p1, eps) || pa.equalsWithEpsilon(p1, eps) && pb.equalsWithEpsilon(p0, eps)) {
      return 0;
    }
    if (pa.equalsWithEpsilon(p1, eps) && pb.equalsWithEpsilon(p2, eps) || pa.equalsWithEpsilon(p2, eps) && pb.equalsWithEpsilon(p1, eps)) {
      return 1;
    }
    if (pa.equalsWithEpsilon(p2, eps) && pb.equalsWithEpsilon(p0, eps) || pa.equalsWithEpsilon(p0, eps) && pb.equalsWithEpsilon(p2, eps)) {
      return 2;
    }
    return -1;
  };
  EdgesRenderer2.prototype._checkEdge = function(faceIndex, edge, faceNormals, p0, p1) {
    var needToCreateLine;
    if (edge === void 0) {
      needToCreateLine = true;
    } else {
      var dotProduct = Vector3.Dot(faceNormals[faceIndex], faceNormals[edge]);
      needToCreateLine = dotProduct < this._epsilon;
    }
    if (needToCreateLine) {
      this.createLine(p0, p1, this._linesPositions.length / 3);
    }
  };
  EdgesRenderer2.prototype.createLine = function(p0, p1, offset) {
    this._linesPositions.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z, p1.x, p1.y, p1.z, p1.x, p1.y, p1.z);
    this._linesNormals.push(p1.x, p1.y, p1.z, -1, p1.x, p1.y, p1.z, 1, p0.x, p0.y, p0.z, -1, p0.x, p0.y, p0.z, 1);
    this._linesIndices.push(offset, offset + 1, offset + 2, offset, offset + 2, offset + 3);
  };
  EdgesRenderer2.prototype._tessellateTriangle = function(edgePoints, indexTriangle, indices, remapVertexIndices) {
    var makePointList = function(edgePoints2, pointIndices, firstIndex) {
      if (firstIndex >= 0) {
        pointIndices.push(firstIndex);
      }
      for (var i2 = 0; i2 < edgePoints2.length; ++i2) {
        pointIndices.push(edgePoints2[i2][0]);
      }
    };
    var startEdge = 0;
    if (edgePoints[1].length >= edgePoints[0].length && edgePoints[1].length >= edgePoints[2].length) {
      startEdge = 1;
    } else if (edgePoints[2].length >= edgePoints[0].length && edgePoints[2].length >= edgePoints[1].length) {
      startEdge = 2;
    }
    for (var e = 0; e < 3; ++e) {
      if (e === startEdge) {
        edgePoints[e].sort(function(a, b) {
          return a[1] < b[1] ? -1 : a[1] > b[1] ? 1 : 0;
        });
      } else {
        edgePoints[e].sort(function(a, b) {
          return a[1] > b[1] ? -1 : a[1] < b[1] ? 1 : 0;
        });
      }
    }
    var mainPointIndices = [], otherPointIndices = [];
    makePointList(edgePoints[startEdge], mainPointIndices, -1);
    var numMainPoints = mainPointIndices.length;
    for (var i = startEdge + 2; i >= startEdge + 1; --i) {
      makePointList(edgePoints[i % 3], otherPointIndices, i !== startEdge + 2 ? remapVertexIndices[indices[indexTriangle + (i + 1) % 3]] : -1);
    }
    var numOtherPoints = otherPointIndices.length;
    var idxMain = 0;
    var idxOther = 0;
    indices.push(remapVertexIndices[indices[indexTriangle + startEdge]], mainPointIndices[0], otherPointIndices[0]);
    indices.push(remapVertexIndices[indices[indexTriangle + (startEdge + 1) % 3]], otherPointIndices[numOtherPoints - 1], mainPointIndices[numMainPoints - 1]);
    var bucketIsMain = numMainPoints <= numOtherPoints;
    var bucketStep = bucketIsMain ? numMainPoints : numOtherPoints;
    var bucketLimit = bucketIsMain ? numOtherPoints : numMainPoints;
    var bucketIdxLimit = bucketIsMain ? numMainPoints - 1 : numOtherPoints - 1;
    var winding = bucketIsMain ? 0 : 1;
    var numTris = numMainPoints + numOtherPoints - 2;
    var bucketIdx = bucketIsMain ? idxMain : idxOther;
    var nbucketIdx = bucketIsMain ? idxOther : idxMain;
    var bucketPoints = bucketIsMain ? mainPointIndices : otherPointIndices;
    var nbucketPoints = bucketIsMain ? otherPointIndices : mainPointIndices;
    var bucket = 0;
    while (numTris-- > 0) {
      if (winding) {
        indices.push(bucketPoints[bucketIdx], nbucketPoints[nbucketIdx]);
      } else {
        indices.push(nbucketPoints[nbucketIdx], bucketPoints[bucketIdx]);
      }
      bucket += bucketStep;
      var lastIdx = void 0;
      if (bucket >= bucketLimit && bucketIdx < bucketIdxLimit) {
        lastIdx = bucketPoints[++bucketIdx];
        bucket -= bucketLimit;
      } else {
        lastIdx = nbucketPoints[++nbucketIdx];
      }
      indices.push(lastIdx);
    }
    indices[indexTriangle + 0] = indices[indices.length - 3];
    indices[indexTriangle + 1] = indices[indices.length - 2];
    indices[indexTriangle + 2] = indices[indices.length - 1];
    indices.length = indices.length - 3;
  };
  EdgesRenderer2.prototype._generateEdgesLinesAlternate = function() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    var positions = this._source.getVerticesData(VertexBuffer.PositionKind);
    var indices = this._source.getIndices();
    if (!indices || !positions) {
      return;
    }
    if (!Array.isArray(indices)) {
      indices = Tools.SliceToArray(indices);
    }
    var useFastVertexMerger = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.useFastVertexMerger) !== null && _b !== void 0 ? _b : true;
    var epsVertexMerge = useFastVertexMerger ? Math.round(-Math.log((_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.epsilonVertexMerge) !== null && _d !== void 0 ? _d : 1e-6) / Math.log(10)) : (_f = (_e = this._options) === null || _e === void 0 ? void 0 : _e.epsilonVertexMerge) !== null && _f !== void 0 ? _f : 1e-6;
    var remapVertexIndices = [];
    var uniquePositions = [];
    if (useFastVertexMerger) {
      var mapVertices = {};
      for (var v1 = 0; v1 < positions.length; v1 += 3) {
        var x1 = positions[v1 + 0], y1 = positions[v1 + 1], z1 = positions[v1 + 2];
        var key = x1.toFixed(epsVertexMerge) + "|" + y1.toFixed(epsVertexMerge) + "|" + z1.toFixed(epsVertexMerge);
        if (mapVertices[key] !== void 0) {
          remapVertexIndices.push(mapVertices[key]);
        } else {
          var idx = v1 / 3;
          mapVertices[key] = idx;
          remapVertexIndices.push(idx);
          uniquePositions.push(idx);
        }
      }
    } else {
      for (var v1 = 0; v1 < positions.length; v1 += 3) {
        var x1 = positions[v1 + 0], y1 = positions[v1 + 1], z1 = positions[v1 + 2];
        var found = false;
        for (var v2 = 0; v2 < v1 && !found; v2 += 3) {
          var x2 = positions[v2 + 0], y2 = positions[v2 + 1], z2 = positions[v2 + 2];
          if (Math.abs(x1 - x2) < epsVertexMerge && Math.abs(y1 - y2) < epsVertexMerge && Math.abs(z1 - z2) < epsVertexMerge) {
            remapVertexIndices.push(v2 / 3);
            found = true;
            break;
          }
        }
        if (!found) {
          remapVertexIndices.push(v1 / 3);
          uniquePositions.push(v1 / 3);
        }
      }
    }
    if ((_g = this._options) === null || _g === void 0 ? void 0 : _g.applyTessellation) {
      var epsVertexAligned = (_j = (_h = this._options) === null || _h === void 0 ? void 0 : _h.epsilonVertexAligned) !== null && _j !== void 0 ? _j : 1e-6;
      var mustTesselate = [];
      for (var index = 0; index < indices.length; index += 3) {
        var triangleToTessellate = void 0;
        for (var i = 0; i < 3; ++i) {
          var p0Index = remapVertexIndices[indices[index + i]];
          var p1Index = remapVertexIndices[indices[index + (i + 1) % 3]];
          var p2Index = remapVertexIndices[indices[index + (i + 2) % 3]];
          if (p0Index === p1Index) {
            continue;
          }
          var p0x = positions[p0Index * 3 + 0], p0y = positions[p0Index * 3 + 1], p0z = positions[p0Index * 3 + 2];
          var p1x = positions[p1Index * 3 + 0], p1y = positions[p1Index * 3 + 1], p1z = positions[p1Index * 3 + 2];
          var p0p1 = Math.sqrt((p1x - p0x) * (p1x - p0x) + (p1y - p0y) * (p1y - p0y) + (p1z - p0z) * (p1z - p0z));
          for (var v = 0; v < uniquePositions.length - 1; v++) {
            var vIndex = uniquePositions[v];
            if (vIndex === p0Index || vIndex === p1Index || vIndex === p2Index) {
              continue;
            }
            var x = positions[vIndex * 3 + 0], y = positions[vIndex * 3 + 1], z = positions[vIndex * 3 + 2];
            var p0p = Math.sqrt((x - p0x) * (x - p0x) + (y - p0y) * (y - p0y) + (z - p0z) * (z - p0z));
            var pp1 = Math.sqrt((x - p1x) * (x - p1x) + (y - p1y) * (y - p1y) + (z - p1z) * (z - p1z));
            if (Math.abs(p0p + pp1 - p0p1) < epsVertexAligned) {
              if (!triangleToTessellate) {
                triangleToTessellate = {
                  index,
                  edgesPoints: [[], [], []]
                };
                mustTesselate.push(triangleToTessellate);
              }
              triangleToTessellate.edgesPoints[i].push([vIndex, p0p]);
            }
          }
        }
      }
      for (var t = 0; t < mustTesselate.length; ++t) {
        var triangle = mustTesselate[t];
        this._tessellateTriangle(triangle.edgesPoints, triangle.index, indices, remapVertexIndices);
      }
      mustTesselate = null;
    }
    var edges = {};
    for (var index = 0; index < indices.length; index += 3) {
      var faceNormal = void 0;
      for (var i = 0; i < 3; ++i) {
        var p0Index = remapVertexIndices[indices[index + i]];
        var p1Index = remapVertexIndices[indices[index + (i + 1) % 3]];
        var p2Index = remapVertexIndices[indices[index + (i + 2) % 3]];
        if (p0Index === p1Index) {
          continue;
        }
        TmpVectors.Vector3[0].copyFromFloats(positions[p0Index * 3 + 0], positions[p0Index * 3 + 1], positions[p0Index * 3 + 2]);
        TmpVectors.Vector3[1].copyFromFloats(positions[p1Index * 3 + 0], positions[p1Index * 3 + 1], positions[p1Index * 3 + 2]);
        TmpVectors.Vector3[2].copyFromFloats(positions[p2Index * 3 + 0], positions[p2Index * 3 + 1], positions[p2Index * 3 + 2]);
        if (!faceNormal) {
          TmpVectors.Vector3[1].subtractToRef(TmpVectors.Vector3[0], TmpVectors.Vector3[3]);
          TmpVectors.Vector3[2].subtractToRef(TmpVectors.Vector3[1], TmpVectors.Vector3[4]);
          faceNormal = Vector3.Cross(TmpVectors.Vector3[3], TmpVectors.Vector3[4]);
          faceNormal.normalize();
        }
        if (p0Index > p1Index) {
          var tmp = p0Index;
          p0Index = p1Index;
          p1Index = tmp;
        }
        var key = p0Index + "_" + p1Index;
        var ei = edges[key];
        if (ei) {
          if (!ei.done) {
            var dotProduct = Vector3.Dot(faceNormal, ei.normal);
            if (dotProduct < this._epsilon) {
              this.createLine(TmpVectors.Vector3[0], TmpVectors.Vector3[1], this._linesPositions.length / 3);
            }
            ei.done = true;
          }
        } else {
          edges[key] = { normal: faceNormal, done: false, index, i };
        }
      }
    }
    for (var key in edges) {
      var ei = edges[key];
      if (!ei.done) {
        var p0Index = remapVertexIndices[indices[ei.index + ei.i]];
        var p1Index = remapVertexIndices[indices[ei.index + (ei.i + 1) % 3]];
        TmpVectors.Vector3[0].copyFromFloats(positions[p0Index * 3 + 0], positions[p0Index * 3 + 1], positions[p0Index * 3 + 2]);
        TmpVectors.Vector3[1].copyFromFloats(positions[p1Index * 3 + 0], positions[p1Index * 3 + 1], positions[p1Index * 3 + 2]);
        this.createLine(TmpVectors.Vector3[0], TmpVectors.Vector3[1], this._linesPositions.length / 3);
      }
    }
    var engine = this._source.getScene().getEngine();
    this._buffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, this._linesPositions, VertexBuffer.PositionKind, false);
    this._buffers[VertexBuffer.NormalKind] = new VertexBuffer(engine, this._linesNormals, VertexBuffer.NormalKind, false, false, 4);
    this._buffersForInstances[VertexBuffer.PositionKind] = this._buffers[VertexBuffer.PositionKind];
    this._buffersForInstances[VertexBuffer.NormalKind] = this._buffers[VertexBuffer.NormalKind];
    this._ib = engine.createIndexBuffer(this._linesIndices);
    this._indicesCount = this._linesIndices.length;
  };
  EdgesRenderer2.prototype._generateEdgesLines = function() {
    var positions = this._source.getVerticesData(VertexBuffer.PositionKind);
    var indices = this._source.getIndices();
    if (!indices || !positions) {
      return;
    }
    var adjacencies = new Array();
    var faceNormals = new Array();
    var index;
    var faceAdjacencies;
    for (index = 0; index < indices.length; index += 3) {
      faceAdjacencies = new FaceAdjacencies();
      var p0Index = indices[index];
      var p1Index = indices[index + 1];
      var p2Index = indices[index + 2];
      faceAdjacencies.p0 = new Vector3(positions[p0Index * 3], positions[p0Index * 3 + 1], positions[p0Index * 3 + 2]);
      faceAdjacencies.p1 = new Vector3(positions[p1Index * 3], positions[p1Index * 3 + 1], positions[p1Index * 3 + 2]);
      faceAdjacencies.p2 = new Vector3(positions[p2Index * 3], positions[p2Index * 3 + 1], positions[p2Index * 3 + 2]);
      var faceNormal = Vector3.Cross(faceAdjacencies.p1.subtract(faceAdjacencies.p0), faceAdjacencies.p2.subtract(faceAdjacencies.p1));
      faceNormal.normalize();
      faceNormals.push(faceNormal);
      adjacencies.push(faceAdjacencies);
    }
    for (index = 0; index < adjacencies.length; index++) {
      faceAdjacencies = adjacencies[index];
      for (var otherIndex = index + 1; otherIndex < adjacencies.length; otherIndex++) {
        var otherFaceAdjacencies = adjacencies[otherIndex];
        if (faceAdjacencies.edgesConnectedCount === 3) {
          break;
        }
        if (otherFaceAdjacencies.edgesConnectedCount === 3) {
          continue;
        }
        var otherP0 = indices[otherIndex * 3];
        var otherP1 = indices[otherIndex * 3 + 1];
        var otherP2 = indices[otherIndex * 3 + 2];
        for (var edgeIndex = 0; edgeIndex < 3; edgeIndex++) {
          var otherEdgeIndex = 0;
          if (faceAdjacencies.edges[edgeIndex] !== void 0) {
            continue;
          }
          switch (edgeIndex) {
            case 0:
              if (this._checkVerticesInsteadOfIndices) {
                otherEdgeIndex = this._processEdgeForAdjacenciesWithVertices(faceAdjacencies.p0, faceAdjacencies.p1, otherFaceAdjacencies.p0, otherFaceAdjacencies.p1, otherFaceAdjacencies.p2);
              } else {
                otherEdgeIndex = this._processEdgeForAdjacencies(indices[index * 3], indices[index * 3 + 1], otherP0, otherP1, otherP2);
              }
              break;
            case 1:
              if (this._checkVerticesInsteadOfIndices) {
                otherEdgeIndex = this._processEdgeForAdjacenciesWithVertices(faceAdjacencies.p1, faceAdjacencies.p2, otherFaceAdjacencies.p0, otherFaceAdjacencies.p1, otherFaceAdjacencies.p2);
              } else {
                otherEdgeIndex = this._processEdgeForAdjacencies(indices[index * 3 + 1], indices[index * 3 + 2], otherP0, otherP1, otherP2);
              }
              break;
            case 2:
              if (this._checkVerticesInsteadOfIndices) {
                otherEdgeIndex = this._processEdgeForAdjacenciesWithVertices(faceAdjacencies.p2, faceAdjacencies.p0, otherFaceAdjacencies.p0, otherFaceAdjacencies.p1, otherFaceAdjacencies.p2);
              } else {
                otherEdgeIndex = this._processEdgeForAdjacencies(indices[index * 3 + 2], indices[index * 3], otherP0, otherP1, otherP2);
              }
              break;
          }
          if (otherEdgeIndex === -1) {
            continue;
          }
          faceAdjacencies.edges[edgeIndex] = otherIndex;
          otherFaceAdjacencies.edges[otherEdgeIndex] = index;
          faceAdjacencies.edgesConnectedCount++;
          otherFaceAdjacencies.edgesConnectedCount++;
          if (faceAdjacencies.edgesConnectedCount === 3) {
            break;
          }
        }
      }
    }
    for (index = 0; index < adjacencies.length; index++) {
      var current = adjacencies[index];
      this._checkEdge(index, current.edges[0], faceNormals, current.p0, current.p1);
      this._checkEdge(index, current.edges[1], faceNormals, current.p1, current.p2);
      this._checkEdge(index, current.edges[2], faceNormals, current.p2, current.p0);
    }
    var engine = this._source.getScene().getEngine();
    this._buffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, this._linesPositions, VertexBuffer.PositionKind, false);
    this._buffers[VertexBuffer.NormalKind] = new VertexBuffer(engine, this._linesNormals, VertexBuffer.NormalKind, false, false, 4);
    this._buffersForInstances[VertexBuffer.PositionKind] = this._buffers[VertexBuffer.PositionKind];
    this._buffersForInstances[VertexBuffer.NormalKind] = this._buffers[VertexBuffer.NormalKind];
    this._ib = engine.createIndexBuffer(this._linesIndices);
    this._indicesCount = this._linesIndices.length;
  };
  EdgesRenderer2.prototype.isReady = function() {
    return this._lineShader.isReady(this._source, this._source.hasInstances && this.customInstances.length > 0 || this._source.hasThinInstances);
  };
  EdgesRenderer2.prototype.render = function() {
    var scene = this._source.getScene();
    if (!this.isReady() || !scene.activeCamera) {
      return;
    }
    var engine = scene.getEngine();
    this._lineShader._preBind();
    if (this._source.edgesColor.a !== 1) {
      engine.setAlphaMode(2);
    } else {
      engine.setAlphaMode(0);
    }
    var hasInstances = this._source.hasInstances && this.customInstances.length > 0;
    var useBuffersWithInstances = hasInstances || this._source.hasThinInstances;
    var instanceCount = 0;
    if (useBuffersWithInstances) {
      this._buffersForInstances["world0"] = this._source.getVertexBuffer("world0");
      this._buffersForInstances["world1"] = this._source.getVertexBuffer("world1");
      this._buffersForInstances["world2"] = this._source.getVertexBuffer("world2");
      this._buffersForInstances["world3"] = this._source.getVertexBuffer("world3");
      if (hasInstances) {
        var instanceStorage = this._source._instanceDataStorage;
        instanceCount = this.customInstances.length;
        if (!instanceStorage.isFrozen) {
          var offset = 0;
          for (var i = 0; i < instanceCount; ++i) {
            this.customInstances.data[i].copyToArray(instanceStorage.instancesData, offset);
            offset += 16;
          }
          instanceStorage.instancesBuffer.updateDirectly(instanceStorage.instancesData, 0, instanceCount);
        }
      } else {
        instanceCount = this._source.thinInstanceCount;
      }
    }
    engine.bindBuffers(useBuffersWithInstances ? this._buffersForInstances : this._buffers, this._ib, this._lineShader.getEffect());
    scene.resetCachedMaterial();
    this._lineShader.setColor4("color", this._source.edgesColor);
    if (scene.activeCamera.mode === Camera.ORTHOGRAPHIC_CAMERA) {
      this._lineShader.setFloat("width", this._source.edgesWidth / this.edgesWidthScalerForOrthographic);
    } else {
      this._lineShader.setFloat("width", this._source.edgesWidth / this.edgesWidthScalerForPerspective);
    }
    this._lineShader.setFloat("aspectRatio", engine.getAspectRatio(scene.activeCamera));
    this._lineShader.bind(this._source.getWorldMatrix());
    engine.drawElementsType(Material.TriangleFillMode, 0, this._indicesCount, instanceCount);
    this._lineShader.unbind();
    if (useBuffersWithInstances) {
      engine.unbindInstanceAttributes();
    }
    if (!this._source.getScene()._activeMeshesFrozen) {
      this.customInstances.reset();
    }
  };
  return EdgesRenderer2;
}();
var LineEdgesRenderer = function(_super) {
  __extends(LineEdgesRenderer2, _super);
  function LineEdgesRenderer2(source, epsilon, checkVerticesInsteadOfIndices) {
    if (epsilon === void 0) {
      epsilon = 0.95;
    }
    if (checkVerticesInsteadOfIndices === void 0) {
      checkVerticesInsteadOfIndices = false;
    }
    var _this = _super.call(this, source, epsilon, checkVerticesInsteadOfIndices, false) || this;
    _this._generateEdgesLines();
    return _this;
  }
  LineEdgesRenderer2.prototype._generateEdgesLines = function() {
    var positions = this._source.getVerticesData(VertexBuffer.PositionKind);
    var indices = this._source.getIndices();
    if (!indices || !positions) {
      return;
    }
    var p0 = TmpVectors.Vector3[0];
    var p1 = TmpVectors.Vector3[1];
    var len = indices.length - 1;
    for (var i = 0, offset = 0; i < len; i += 2, offset += 4) {
      Vector3.FromArrayToRef(positions, 3 * indices[i], p0);
      Vector3.FromArrayToRef(positions, 3 * indices[i + 1], p1);
      this.createLine(p0, p1, offset);
    }
    var engine = this._source.getScene().getEngine();
    this._buffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, this._linesPositions, VertexBuffer.PositionKind, false);
    this._buffers[VertexBuffer.NormalKind] = new VertexBuffer(engine, this._linesNormals, VertexBuffer.NormalKind, false, false, 4);
    this._ib = engine.createIndexBuffer(this._linesIndices);
    this._indicesCount = this._linesIndices.length;
  };
  return LineEdgesRenderer2;
}(EdgesRenderer);

// node_modules/@babylonjs/core/Rendering/prePassRenderer.js
var PrePassRenderer = function() {
  function PrePassRenderer2(scene) {
    this._textureFormats = [
      {
        type: 0,
        format: 2
      },
      {
        type: 1,
        format: 2
      },
      {
        type: 2,
        format: 2
      },
      {
        type: 3,
        format: 0
      },
      {
        type: 4,
        format: 2
      },
      {
        type: 5,
        format: 2
      },
      {
        type: 6,
        format: 0
      }
    ];
    this.excludedSkinnedMesh = [];
    this.excludedMaterials = [];
    this._textureIndices = [];
    this._isDirty = false;
    this.mrtCount = 0;
    this._postProcesses = [];
    this._clearColor = new Color4(0, 0, 0, 0);
    this._effectConfigurations = [];
    this._mrtFormats = [];
    this._enabled = false;
    this._useGeometryBufferFallback = false;
    this.disableGammaTransform = false;
    this._scene = scene;
    this._engine = scene.getEngine();
    PrePassRenderer2._SceneComponentInitialization(this._scene);
    this._resetLayout();
  }
  Object.defineProperty(PrePassRenderer2.prototype, "enabled", {
    get: function() {
      return this._enabled;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PrePassRenderer2.prototype, "samples", {
    get: function() {
      return this.prePassRT.samples;
    },
    set: function(n) {
      if (!this.imageProcessingPostProcess) {
        this._createCompositionEffect();
      }
      this.prePassRT.samples = n;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PrePassRenderer2.prototype, "useGeometryBufferFallback", {
    get: function() {
      return this._useGeometryBufferFallback;
    },
    set: function(value) {
      this._useGeometryBufferFallback = value;
      if (value) {
        this._geometryBuffer = this._scene.enableGeometryBufferRenderer();
        if (!this._geometryBuffer) {
          this._useGeometryBufferFallback = false;
          return;
        }
        this._geometryBuffer.renderList = [];
        this._geometryBuffer._linkPrePassRenderer(this);
        this._updateGeometryBufferLayout();
      } else {
        if (this._geometryBuffer) {
          this._geometryBuffer._unlinkPrePassRenderer();
        }
        this._geometryBuffer = null;
        this._scene.disableGeometryBufferRenderer();
      }
    },
    enumerable: false,
    configurable: true
  });
  PrePassRenderer2.prototype._initializeAttachments = function() {
    var multiRenderLayout = [];
    var clearLayout = [false];
    var defaultLayout = [true];
    for (var i = 0; i < this.mrtCount; i++) {
      multiRenderLayout.push(true);
      if (i > 0) {
        clearLayout.push(true);
        defaultLayout.push(false);
      }
    }
    this._multiRenderAttachments = this._engine.buildTextureLayout(multiRenderLayout);
    this._clearAttachments = this._engine.buildTextureLayout(clearLayout);
    this._defaultAttachments = this._engine.buildTextureLayout(defaultLayout);
  };
  PrePassRenderer2.prototype._createCompositionEffect = function() {
    this.prePassRT = new MultiRenderTarget("sceneprePassRT", { width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() }, this.mrtCount, this._scene, { generateMipMaps: false, generateDepthTexture: true, defaultType: 0, types: this._mrtFormats });
    this.prePassRT.samples = 1;
    this._initializeAttachments();
    if (this._useGeometryBufferFallback && !this._geometryBuffer) {
      this.useGeometryBufferFallback = true;
    }
    this.imageProcessingPostProcess = new ImageProcessingPostProcess("sceneCompositionPass", 1, null, void 0, this._engine);
    this.imageProcessingPostProcess.autoClear = false;
  };
  Object.defineProperty(PrePassRenderer2.prototype, "isSupported", {
    get: function() {
      return this._engine.webGLVersion > 1 || this._scene.getEngine().getCaps().drawBuffersExtension;
    },
    enumerable: false,
    configurable: true
  });
  PrePassRenderer2.prototype.bindAttachmentsForEffect = function(effect, subMesh) {
    if (this.enabled) {
      if (effect._multiTarget) {
        this._engine.bindAttachments(this._multiRenderAttachments);
      } else {
        this._engine.bindAttachments(this._defaultAttachments);
        if (this._geometryBuffer) {
          var material = subMesh.getMaterial();
          if (material && this.excludedMaterials.indexOf(material) === -1) {
            this._geometryBuffer.renderList.push(subMesh.getRenderingMesh());
          }
        }
      }
    }
  };
  PrePassRenderer2.prototype.restoreAttachments = function() {
    if (this.enabled && this._defaultAttachments) {
      this._engine.bindAttachments(this._defaultAttachments);
    }
  };
  PrePassRenderer2.prototype._beforeCameraDraw = function() {
    if (this._isDirty) {
      this._update();
    }
    if (this._geometryBuffer) {
      this._geometryBuffer.renderList.length = 0;
    }
    this._bindFrameBuffer();
  };
  PrePassRenderer2.prototype._afterCameraDraw = function() {
    if (this._enabled) {
      var firstCameraPP = this._scene.activeCamera && this._scene.activeCamera._getFirstPostProcess();
      if (firstCameraPP && this._postProcesses.length) {
        this._scene.postProcessManager._prepareFrame();
      }
      this._scene.postProcessManager.directRender(this._postProcesses, firstCameraPP ? firstCameraPP.inputTexture : null);
    }
  };
  PrePassRenderer2.prototype._checkRTSize = function() {
    var requiredWidth = this._engine.getRenderWidth(true);
    var requiredHeight = this._engine.getRenderHeight(true);
    var width = this.prePassRT.getRenderWidth();
    var height = this.prePassRT.getRenderHeight();
    if (width !== requiredWidth || height !== requiredHeight) {
      this.prePassRT.resize({ width: requiredWidth, height: requiredHeight });
      this._updateGeometryBufferLayout();
      this._bindPostProcessChain();
    }
  };
  PrePassRenderer2.prototype._bindFrameBuffer = function() {
    if (this._enabled) {
      this._checkRTSize();
      var internalTexture = this.prePassRT.getInternalTexture();
      if (internalTexture) {
        this._engine.bindFramebuffer(internalTexture);
      }
    }
  };
  PrePassRenderer2.prototype.clear = function() {
    if (this._enabled) {
      this._bindFrameBuffer();
      this._engine.clear(this._scene.clearColor, this._scene.autoClear || this._scene.forceWireframe || this._scene.forcePointsCloud, this._scene.autoClearDepthAndStencil, this._scene.autoClearDepthAndStencil);
      this._engine.bindAttachments(this._clearAttachments);
      this._engine.clear(this._clearColor, true, false, false);
      this._engine.bindAttachments(this._defaultAttachments);
    }
  };
  PrePassRenderer2.prototype._setState = function(enabled) {
    this._enabled = enabled;
    this._scene.prePass = enabled;
    if (this.imageProcessingPostProcess) {
      this.imageProcessingPostProcess.imageProcessingConfiguration.applyByPostProcess = enabled;
    }
  };
  PrePassRenderer2.prototype._updateGeometryBufferLayout = function() {
    if (this._geometryBuffer) {
      this._geometryBuffer._resetLayout();
      var texturesActivated = [];
      for (var i = 0; i < this._mrtLayout.length; i++) {
        texturesActivated.push(false);
      }
      this._geometryBuffer._linkInternalTexture(this.prePassRT.getInternalTexture());
      var matches = [
        {
          prePassConstant: 5,
          geometryBufferConstant: GeometryBufferRenderer.DEPTHNORMAL_TEXTURE_TYPE
        },
        {
          prePassConstant: 1,
          geometryBufferConstant: GeometryBufferRenderer.POSITION_TEXTURE_TYPE
        },
        {
          prePassConstant: 3,
          geometryBufferConstant: GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE
        },
        {
          prePassConstant: 2,
          geometryBufferConstant: GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE
        }
      ];
      for (var i = 0; i < matches.length; i++) {
        var index = this._mrtLayout.indexOf(matches[i].prePassConstant);
        if (index !== -1) {
          this._geometryBuffer._forceTextureType(matches[i].geometryBufferConstant, index);
          texturesActivated[index] = true;
        }
      }
      this._geometryBuffer._setAttachments(this._engine.buildTextureLayout(texturesActivated));
    }
  };
  PrePassRenderer2.prototype.addEffectConfiguration = function(cfg) {
    for (var i = 0; i < this._effectConfigurations.length; i++) {
      if (this._effectConfigurations[i].name === cfg.name) {
        return this._effectConfigurations[i];
      }
    }
    this._effectConfigurations.push(cfg);
    return cfg;
  };
  PrePassRenderer2.prototype.getIndex = function(type) {
    return this._textureIndices[type];
  };
  PrePassRenderer2.prototype._enable = function() {
    var _a, _b;
    var previousMrtCount = this.mrtCount;
    for (var i = 0; i < this._effectConfigurations.length; i++) {
      if (this._effectConfigurations[i].enabled) {
        this._enableTextures(this._effectConfigurations[i].texturesRequired);
      }
    }
    if (this.prePassRT && this.mrtCount !== previousMrtCount) {
      this.prePassRT.updateCount(this.mrtCount, { types: this._mrtFormats });
    }
    this._updateGeometryBufferLayout();
    this._resetPostProcessChain();
    for (var i = 0; i < this._effectConfigurations.length; i++) {
      if (this._effectConfigurations[i].enabled) {
        if (!this._effectConfigurations[i].postProcess && this._effectConfigurations[i].createPostProcess) {
          this._effectConfigurations[i].createPostProcess();
        }
        if (this._effectConfigurations[i].postProcess) {
          this._postProcesses.push(this._effectConfigurations[i].postProcess);
        }
      }
    }
    this._initializeAttachments();
    if (!this.imageProcessingPostProcess) {
      this._createCompositionEffect();
    }
    var isIPPAlreadyPresent = false;
    if ((_a = this._scene.activeCamera) === null || _a === void 0 ? void 0 : _a._postProcesses) {
      for (var i = 0; i < this._scene.activeCamera._postProcesses.length; i++) {
        if (((_b = this._scene.activeCamera._postProcesses[i]) === null || _b === void 0 ? void 0 : _b.getClassName()) === "ImageProcessingPostProcess") {
          isIPPAlreadyPresent = true;
        }
      }
    }
    if (!isIPPAlreadyPresent && !this.disableGammaTransform) {
      this._postProcesses.push(this.imageProcessingPostProcess);
    }
    this._bindPostProcessChain();
    this._setState(true);
  };
  PrePassRenderer2.prototype._disable = function() {
    this._setState(false);
    this._resetLayout();
    for (var i = 0; i < this._effectConfigurations.length; i++) {
      this._effectConfigurations[i].enabled = false;
    }
  };
  PrePassRenderer2.prototype._resetLayout = function() {
    for (var i = 0; i < this._textureFormats.length; i++) {
      this._textureIndices[this._textureFormats[i].type] = -1;
    }
    this._textureIndices[4] = 0;
    this._mrtLayout = [4];
    this._mrtFormats = [2];
    this.mrtCount = 1;
  };
  PrePassRenderer2.prototype._resetPostProcessChain = function() {
    this._postProcesses = [];
    if (this.imageProcessingPostProcess) {
      this.imageProcessingPostProcess.restoreDefaultInputTexture();
    }
    for (var i = 0; i < this._effectConfigurations.length; i++) {
      if (this._effectConfigurations[i].postProcess) {
        this._effectConfigurations[i].postProcess.restoreDefaultInputTexture();
      }
    }
  };
  PrePassRenderer2.prototype._bindPostProcessChain = function() {
    var _a;
    if (this._postProcesses.length) {
      this._postProcesses[0].inputTexture = this.prePassRT.getInternalTexture();
    } else {
      var pp = (_a = this._scene.activeCamera) === null || _a === void 0 ? void 0 : _a._getFirstPostProcess();
      if (pp) {
        pp.inputTexture = this.prePassRT.getInternalTexture();
      }
    }
  };
  PrePassRenderer2.prototype.markAsDirty = function() {
    this._isDirty = true;
  };
  PrePassRenderer2.prototype._enableTextures = function(types) {
    for (var i = 0; i < types.length; i++) {
      var type = types[i];
      if (this._textureIndices[type] === -1) {
        this._textureIndices[type] = this._mrtLayout.length;
        this._mrtLayout.push(type);
        this._mrtFormats.push(this._textureFormats[type].format);
        this.mrtCount++;
      }
    }
  };
  PrePassRenderer2.prototype._update = function() {
    this._disable();
    var enablePrePass = false;
    for (var i = 0; i < this._scene.materials.length; i++) {
      if (this._scene.materials[i].setPrePassRenderer(this)) {
        enablePrePass = true;
      }
    }
    var camera = this._scene.activeCamera;
    if (!camera) {
      return;
    }
    var postProcesses = camera._postProcesses.filter(function(pp) {
      return pp != null;
    });
    if (postProcesses) {
      for (var i = 0; i < postProcesses.length; i++) {
        if (postProcesses[i].setPrePassRenderer(this)) {
          enablePrePass = true;
        }
      }
    }
    this._markAllMaterialsAsPrePassDirty();
    this._isDirty = false;
    if (enablePrePass) {
      this._enable();
    }
    if (!this.enabled) {
      this._engine.restoreDefaultFramebuffer();
      this._engine.restoreSingleAttachment();
    }
  };
  PrePassRenderer2.prototype._markAllMaterialsAsPrePassDirty = function() {
    var materials = this._scene.materials;
    for (var i = 0; i < materials.length; i++) {
      materials[i].markAsDirty(Material.PrePassDirtyFlag);
    }
  };
  PrePassRenderer2.prototype.dispose = function() {
    for (var i = 0; i < this._effectConfigurations.length; i++) {
      if (this._effectConfigurations[i].dispose) {
        this._effectConfigurations[i].dispose();
      }
    }
    this.imageProcessingPostProcess.dispose();
    this.prePassRT.dispose();
  };
  PrePassRenderer2._SceneComponentInitialization = function(_) {
    throw _DevTools.WarnImport("PrePassRendererSceneComponent");
  };
  return PrePassRenderer2;
}();

// node_modules/@babylonjs/core/Rendering/prePassRendererSceneComponent.js
Object.defineProperty(Scene.prototype, "prePassRenderer", {
  get: function() {
    return this._prePassRenderer;
  },
  set: function(value) {
    if (value && value.isSupported) {
      this._prePassRenderer = value;
    }
  },
  enumerable: true,
  configurable: true
});
Scene.prototype.enablePrePassRenderer = function() {
  if (this._prePassRenderer) {
    return this._prePassRenderer;
  }
  this._prePassRenderer = new PrePassRenderer(this);
  if (!this._prePassRenderer.isSupported) {
    this._prePassRenderer = null;
    Logger.Error("PrePassRenderer needs WebGL 2 support.\nMaybe you tried to use the following features that need the PrePassRenderer :\n + Subsurface Scattering");
  }
  return this._prePassRenderer;
};
Scene.prototype.disablePrePassRenderer = function() {
  if (!this._prePassRenderer) {
    return;
  }
  this._prePassRenderer.dispose();
  this._prePassRenderer = null;
};
var PrePassRendererSceneComponent = function() {
  function PrePassRendererSceneComponent2(scene) {
    this.name = SceneComponentConstants.NAME_PREPASSRENDERER;
    this.scene = scene;
  }
  PrePassRendererSceneComponent2.prototype.register = function() {
    this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_PREPASS, this, this._beforeCameraDraw);
    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS, this, this._afterCameraDraw);
    this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEARSTAGE_PREPASS, this, this._beforeClearStage);
    this.scene._beforeRenderingMeshStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERINGMESH_PREPASS, this, this._beforeRenderingMeshStage);
    this.scene._afterRenderingMeshStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGMESH_PREPASS, this, this._afterRenderingMeshStage);
  };
  PrePassRendererSceneComponent2.prototype._beforeCameraDraw = function() {
    if (this.scene.prePassRenderer) {
      this.scene.prePassRenderer._beforeCameraDraw();
    }
  };
  PrePassRendererSceneComponent2.prototype._afterCameraDraw = function() {
    if (this.scene.prePassRenderer) {
      this.scene.prePassRenderer._afterCameraDraw();
    }
  };
  PrePassRendererSceneComponent2.prototype._beforeClearStage = function() {
    if (this.scene.prePassRenderer) {
      this.scene.prePassRenderer.clear();
    }
  };
  PrePassRendererSceneComponent2.prototype._beforeRenderingMeshStage = function(mesh, subMesh, batch, effect) {
    if (!effect) {
      return;
    }
    var scene = mesh.getScene();
    if (scene.prePassRenderer) {
      scene.prePassRenderer.bindAttachmentsForEffect(effect, subMesh);
    }
  };
  PrePassRendererSceneComponent2.prototype._afterRenderingMeshStage = function(mesh) {
    var scene = mesh.getScene();
    if (scene.prePassRenderer) {
      scene.prePassRenderer.restoreAttachments();
    }
  };
  PrePassRendererSceneComponent2.prototype.rebuild = function() {
  };
  PrePassRendererSceneComponent2.prototype.dispose = function() {
  };
  return PrePassRendererSceneComponent2;
}();
PrePassRenderer._SceneComponentInitialization = function(scene) {
  var component = scene._getComponent(SceneComponentConstants.NAME_PREPASSRENDERER);
  if (!component) {
    component = new PrePassRendererSceneComponent(scene);
    scene._addComponent(component);
  }
};

// node_modules/@babylonjs/core/Shaders/ShadersInclude/fibonacci.js
var name88 = "fibonacci";
var shader88 = "#define rcp(x) 1./x\n#define GOLDEN_RATIO 1.618033988749895\n#define TWO_PI 6.2831855\n\n\nvec2 Golden2dSeq(int i,float n)\n{\n\n\nreturn vec2(float(i)/n+(0.5/n),fract(float(i)*rcp(GOLDEN_RATIO)));\n}\nvec2 SampleDiskGolden(int i,int sampleCount)\n{\nvec2 f=Golden2dSeq(i,float(sampleCount));\nreturn vec2(sqrt(f.x),TWO_PI*f.y);\n}";
Effect.IncludesShadersStore[name88] = shader88;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/diffusionProfile.js
var name89 = "diffusionProfile";
var shader89 = "uniform vec3 diffusionS[5];\nuniform float diffusionD[5];\nuniform float filterRadii[5];";
Effect.IncludesShadersStore[name89] = shader89;

// node_modules/@babylonjs/core/Shaders/subSurfaceScattering.fragment.js
var name90 = "subSurfaceScatteringPixelShader";
var shader90 = "\n#include<fibonacci>\n#include<helperFunctions>\n#include<subSurfaceScatteringFunctions>\n#include<diffusionProfile>\nvarying vec2 vUV;\nuniform vec2 texelSize;\nuniform sampler2D textureSampler;\nuniform sampler2D irradianceSampler;\nuniform sampler2D depthSampler;\nuniform sampler2D albedoSampler;\nuniform vec2 viewportSize;\nuniform float metersPerUnit;\nconst float LOG2_E=1.4426950408889634;\nconst float SSS_PIXELS_PER_SAMPLE=4.;\nconst int _SssSampleBudget=40;\n#define rcp(x) 1./x\n#define Sq(x) x*x\n#define SSS_BILATERAL_FILTER true\n\n\nvec3 EvalBurleyDiffusionProfile(float r,vec3 S)\n{\nvec3 exp_13=exp2(((LOG2_E*(-1.0/3.0))*r)*S);\nvec3 expSum=exp_13*(1.+exp_13*exp_13);\nreturn (S*rcp(8.*PI))*expSum;\n}\n\n\n\n\n\n\nvec2 SampleBurleyDiffusionProfile(float u,float rcpS)\n{\nu=1.-u;\nfloat g=1.+(4.*u)*(2.*u+sqrt(1.+(4.*u)*u));\nfloat n=exp2(log2(g)*(-1.0/3.0));\nfloat p=(g*n)*n;\nfloat c=1.+p+n;\nfloat d=(3./LOG2_E*2.)+(3./LOG2_E)*log2(u);\nfloat x=(3./LOG2_E)*log2(c)-d;\n\n\n\n\n\n\nfloat rcpExp=((c*c)*c)*rcp((4.*u)*((c*c)+(4.*u)*(4.*u)));\nfloat r=x*rcpS;\nfloat rcpPdf=(8.*PI*rcpS)*rcpExp;\nreturn vec2(r,rcpPdf);\n}\n\n\nvec3 ComputeBilateralWeight(float xy2,float z,float mmPerUnit,vec3 S,float rcpPdf)\n{\n#ifndef SSS_BILATERAL_FILTER\nz=0.;\n#endif\n\n\n\nfloat r=sqrt(xy2+(z*mmPerUnit)*(z*mmPerUnit));\nfloat area=rcpPdf;\n#if SSS_CLAMP_ARTIFACT\nreturn clamp(EvalBurleyDiffusionProfile(r,S)*area,0.0,1.0);\n#else\nreturn EvalBurleyDiffusionProfile(r,S)*area;\n#endif\n}\nvoid EvaluateSample(int i,int n,vec3 S,float d,vec3 centerPosVS,float mmPerUnit,float pixelsPerMm,\nfloat phase,inout vec3 totalIrradiance,inout vec3 totalWeight)\n{\n\nfloat scale=rcp(float(n));\nfloat offset=rcp(float(n))*0.5;\n\nfloat sinPhase,cosPhase;\nsinPhase=sin(phase);\ncosPhase=cos(phase);\nvec2 bdp=SampleBurleyDiffusionProfile(float(i)*scale+offset,d);\nfloat r=bdp.x;\nfloat rcpPdf=bdp.y;\nfloat phi=SampleDiskGolden(i,n).y;\nfloat sinPhi,cosPhi;\nsinPhi=sin(phi);\ncosPhi=cos(phi);\nfloat sinPsi=cosPhase*sinPhi+sinPhase*cosPhi;\nfloat cosPsi=cosPhase*cosPhi-sinPhase*sinPhi;\nvec2 vec=r*vec2(cosPsi,sinPsi);\n\nvec2 position;\nfloat xy2;\nposition=vUV+round((pixelsPerMm*r)*vec2(cosPsi,sinPsi))*texelSize;\nxy2=r*r;\nvec4 textureSample=texture2D(irradianceSampler,position);\nfloat viewZ=texture2D(depthSampler,position).r;\nvec3 irradiance=textureSample.rgb;\nif (testLightingForSSS(textureSample.a))\n{\n\nfloat relZ=viewZ-centerPosVS.z;\nvec3 weight=ComputeBilateralWeight(xy2,relZ,mmPerUnit,S,rcpPdf);\ntotalIrradiance+=weight*irradiance;\ntotalWeight+=weight;\n}\nelse\n{\n\n\n\n\n\n\n}\n}\nvoid main(void)\n{\nvec4 irradianceAndDiffusionProfile=texture2D(irradianceSampler,vUV);\nvec3 centerIrradiance=irradianceAndDiffusionProfile.rgb;\nint diffusionProfileIndex=int(round(irradianceAndDiffusionProfile.a*255.));\nfloat centerDepth=0.;\nvec4 inputColor=texture2D(textureSampler,vUV);\nbool passedStencilTest=testLightingForSSS(irradianceAndDiffusionProfile.a);\nif (passedStencilTest)\n{\ncenterDepth=texture2D(depthSampler,vUV).r;\n}\nif (!passedStencilTest) {\ngl_FragColor=inputColor;\nreturn;\n}\nfloat distScale=1.;\nvec3 S=diffusionS[diffusionProfileIndex];\nfloat d=diffusionD[diffusionProfileIndex];\nfloat filterRadius=filterRadii[diffusionProfileIndex];\n\nvec2 centerPosNDC=vUV;\nvec2 cornerPosNDC=vUV+0.5*texelSize;\nvec3 centerPosVS=vec3(centerPosNDC*viewportSize,1.0)*centerDepth;\nvec3 cornerPosVS=vec3(cornerPosNDC*viewportSize,1.0)*centerDepth;\n\nfloat mmPerUnit=1000.*(metersPerUnit*rcp(distScale));\nfloat unitsPerMm=rcp(mmPerUnit);\n\n\nfloat unitsPerPixel=2.*abs(cornerPosVS.x-centerPosVS.x);\nfloat pixelsPerMm=rcp(unitsPerPixel)*unitsPerMm;\n\nfloat filterArea=PI*Sq(filterRadius*pixelsPerMm);\nint sampleCount=int(filterArea*rcp(SSS_PIXELS_PER_SAMPLE));\nint sampleBudget=_SssSampleBudget;\nint texturingMode=0;\nvec3 albedo=texture2D(albedoSampler,vUV).rgb;\nif (distScale == 0. || sampleCount<1)\n{\n#ifdef DEBUG_SSS_SAMPLES\nvec3 green=vec3(0.,1.,0.);\ngl_FragColor=vec4(green,1.0);\nreturn;\n#endif\ngl_FragColor=vec4(inputColor.rgb+albedo*centerIrradiance,1.0);\nreturn;\n}\n#ifdef DEBUG_SSS_SAMPLES\nvec3 red=vec3(1.,0.,0.);\nvec3 blue=vec3(0.,0.,1.);\ngl_FragColor=vec4(mix(blue,red,clamp(float(sampleCount)/float(sampleBudget),0.0,1.0)),1.0);\nreturn;\n#endif\n\nfloat phase=0.;\nint n=min(sampleCount,sampleBudget);\n\nvec3 centerWeight=vec3(0.);\nvec3 totalIrradiance=vec3(0.);\nvec3 totalWeight=vec3(0.);\nfor (int i=0; i<n; i++)\n{\n\nEvaluateSample(i,n,S,d,centerPosVS,mmPerUnit,pixelsPerMm,\nphase,totalIrradiance,totalWeight);\n}\n\ntotalWeight=max(totalWeight,HALF_MIN);\ngl_FragColor=vec4(inputColor.rgb+albedo*max(totalIrradiance/totalWeight,vec3(0.0)),1.);\n}";
Effect.ShadersStore[name90] = shader90;

// node_modules/@babylonjs/core/PostProcesses/subSurfaceScatteringPostProcess.js
var SubSurfaceScatteringPostProcess = function(_super) {
  __extends(SubSurfaceScatteringPostProcess2, _super);
  function SubSurfaceScatteringPostProcess2(name98, scene, options, camera, samplingMode, engine, reusable, textureType) {
    if (camera === void 0) {
      camera = null;
    }
    if (textureType === void 0) {
      textureType = 0;
    }
    var _this = _super.call(this, name98, "subSurfaceScattering", ["texelSize", "viewportSize", "metersPerUnit"], ["diffusionS", "diffusionD", "filterRadii", "irradianceSampler", "depthSampler", "albedoSampler"], options, camera, samplingMode || Texture.BILINEAR_SAMPLINGMODE, engine, reusable, null, textureType, "postprocess", void 0, true) || this;
    _this._scene = scene;
    _this.updateEffect();
    _this.onApplyObservable.add(function(effect) {
      if (!scene.prePassRenderer || !scene.subSurfaceConfiguration) {
        Logger.Error("PrePass and subsurface configuration needs to be enabled for subsurface scattering.");
        return;
      }
      var texelSize = _this.texelSize;
      effect.setFloat("metersPerUnit", scene.subSurfaceConfiguration.metersPerUnit);
      effect.setFloat2("texelSize", texelSize.x, texelSize.y);
      effect.setTexture("irradianceSampler", scene.prePassRenderer.prePassRT.textures[scene.prePassRenderer.getIndex(0)]);
      effect.setTexture("depthSampler", scene.prePassRenderer.prePassRT.textures[scene.prePassRenderer.getIndex(5)]);
      effect.setTexture("albedoSampler", scene.prePassRenderer.prePassRT.textures[scene.prePassRenderer.getIndex(6)]);
      effect.setFloat2("viewportSize", Math.tan(scene.activeCamera.fov / 2) * scene.getEngine().getAspectRatio(scene.activeCamera, true), Math.tan(scene.activeCamera.fov / 2));
      effect.setArray3("diffusionS", scene.subSurfaceConfiguration.ssDiffusionS);
      effect.setArray("diffusionD", scene.subSurfaceConfiguration.ssDiffusionD);
      effect.setArray("filterRadii", scene.subSurfaceConfiguration.ssFilterRadii);
    });
    return _this;
  }
  SubSurfaceScatteringPostProcess2.prototype.getClassName = function() {
    return "SubSurfaceScatteringPostProcess";
  };
  return SubSurfaceScatteringPostProcess2;
}(PostProcess);

// node_modules/@babylonjs/core/Rendering/subSurfaceConfiguration.js
var SubSurfaceConfiguration = function() {
  function SubSurfaceConfiguration2(scene) {
    this._ssDiffusionS = [];
    this._ssFilterRadii = [];
    this._ssDiffusionD = [];
    this.enabled = false;
    this.name = SceneComponentConstants.NAME_SUBSURFACE;
    this.ssDiffusionProfileColors = [];
    this.metersPerUnit = 1;
    this.texturesRequired = [
      5,
      6,
      4,
      0
    ];
    this.addDiffusionProfile(new Color3(1, 1, 1));
    this._scene = scene;
    SubSurfaceConfiguration2._SceneComponentInitialization(this._scene);
  }
  Object.defineProperty(SubSurfaceConfiguration2.prototype, "ssDiffusionS", {
    get: function() {
      return this._ssDiffusionS;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SubSurfaceConfiguration2.prototype, "ssDiffusionD", {
    get: function() {
      return this._ssDiffusionD;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SubSurfaceConfiguration2.prototype, "ssFilterRadii", {
    get: function() {
      return this._ssFilterRadii;
    },
    enumerable: false,
    configurable: true
  });
  SubSurfaceConfiguration2.prototype.addDiffusionProfile = function(color) {
    if (this.ssDiffusionD.length >= 5) {
      Logger.Error("You already reached the maximum number of diffusion profiles.");
      return 0;
    }
    for (var i = 0; i < this._ssDiffusionS.length / 3; i++) {
      if (this._ssDiffusionS[i * 3] === color.r && this._ssDiffusionS[i * 3 + 1] === color.g && this._ssDiffusionS[i * 3 + 2] === color.b) {
        return i;
      }
    }
    this._ssDiffusionS.push(color.r, color.b, color.g);
    this._ssDiffusionD.push(Math.max(Math.max(color.r, color.b), color.g));
    this._ssFilterRadii.push(this.getDiffusionProfileParameters(color));
    this.ssDiffusionProfileColors.push(color);
    return this._ssDiffusionD.length - 1;
  };
  SubSurfaceConfiguration2.prototype.createPostProcess = function() {
    this.postProcess = new SubSurfaceScatteringPostProcess("subSurfaceScattering", this._scene, 1, null, void 0, this._scene.getEngine());
    this.postProcess.autoClear = false;
    return this.postProcess;
  };
  SubSurfaceConfiguration2.prototype.clearAllDiffusionProfiles = function() {
    this._ssDiffusionD = [];
    this._ssDiffusionS = [];
    this._ssFilterRadii = [];
    this.ssDiffusionProfileColors = [];
  };
  SubSurfaceConfiguration2.prototype.dispose = function() {
    this.clearAllDiffusionProfiles();
    this.postProcess.dispose();
  };
  SubSurfaceConfiguration2.prototype.getDiffusionProfileParameters = function(color) {
    var cdf = 0.997;
    var maxScatteringDistance = Math.max(color.r, color.g, color.b);
    return this._sampleBurleyDiffusionProfile(cdf, maxScatteringDistance);
  };
  SubSurfaceConfiguration2.prototype._sampleBurleyDiffusionProfile = function(u, rcpS) {
    u = 1 - u;
    var g = 1 + 4 * u * (2 * u + Math.sqrt(1 + 4 * u * u));
    var n = Math.pow(g, -1 / 3);
    var p = g * n * n;
    var c = 1 + p + n;
    var x = 3 * Math.log(c / (4 * u));
    return x * rcpS;
  };
  SubSurfaceConfiguration2._SceneComponentInitialization = function(_) {
    throw _DevTools.WarnImport("PrePassRendererSceneComponent");
  };
  return SubSurfaceConfiguration2;
}();

// node_modules/@babylonjs/core/Rendering/subSurfaceSceneComponent.js
AbstractScene.AddParser(SceneComponentConstants.NAME_SUBSURFACE, function(parsedData, scene) {
  if (parsedData.ssDiffusionProfileColors !== void 0 && parsedData.ssDiffusionProfileColors !== null) {
    scene.enableSubSurfaceForPrePass();
    if (scene.subSurfaceConfiguration) {
      for (var index = 0, cache = parsedData.ssDiffusionProfileColors.length; index < cache; index++) {
        var color = parsedData.ssDiffusionProfileColors[index];
        scene.subSurfaceConfiguration.addDiffusionProfile(new Color3(color.r, color.g, color.b));
      }
    }
  }
});
Object.defineProperty(Scene.prototype, "subSurfaceConfiguration", {
  get: function() {
    return this._subSurfaceConfiguration;
  },
  set: function(value) {
    if (value) {
      if (this.enablePrePassRenderer()) {
        this._subSurfaceConfiguration = value;
      }
    }
  },
  enumerable: true,
  configurable: true
});
Scene.prototype.enableSubSurfaceForPrePass = function() {
  if (this._subSurfaceConfiguration) {
    return this._subSurfaceConfiguration;
  }
  var prePassRenderer = this.enablePrePassRenderer();
  if (prePassRenderer) {
    this._subSurfaceConfiguration = new SubSurfaceConfiguration(this);
    prePassRenderer.addEffectConfiguration(this._subSurfaceConfiguration);
    return this._subSurfaceConfiguration;
  }
  return null;
};
Scene.prototype.disableSubSurfaceForPrePass = function() {
  if (!this._subSurfaceConfiguration) {
    return;
  }
  this._subSurfaceConfiguration.dispose();
  this._subSurfaceConfiguration = null;
};
var SubSurfaceSceneComponent = function() {
  function SubSurfaceSceneComponent2(scene) {
    this.name = SceneComponentConstants.NAME_PREPASSRENDERER;
    this.scene = scene;
  }
  SubSurfaceSceneComponent2.prototype.register = function() {
  };
  SubSurfaceSceneComponent2.prototype.serialize = function(serializationObject) {
    if (!this.scene.subSurfaceConfiguration) {
      return;
    }
    var ssDiffusionProfileColors = this.scene.subSurfaceConfiguration.ssDiffusionProfileColors;
    serializationObject.ssDiffusionProfileColors = [];
    for (var i = 0; i < ssDiffusionProfileColors.length; i++) {
      serializationObject.ssDiffusionProfileColors.push({
        r: ssDiffusionProfileColors[i].r,
        g: ssDiffusionProfileColors[i].g,
        b: ssDiffusionProfileColors[i].b
      });
    }
  };
  SubSurfaceSceneComponent2.prototype.addFromContainer = function(container) {
  };
  SubSurfaceSceneComponent2.prototype.removeFromContainer = function(container, dispose) {
    if (!this.scene.prePassRenderer) {
      return;
    }
    if (this.scene.subSurfaceConfiguration) {
      this.scene.subSurfaceConfiguration.clearAllDiffusionProfiles();
    }
  };
  SubSurfaceSceneComponent2.prototype.rebuild = function() {
  };
  SubSurfaceSceneComponent2.prototype.dispose = function() {
  };
  return SubSurfaceSceneComponent2;
}();
SubSurfaceConfiguration._SceneComponentInitialization = function(scene) {
  var component = scene._getComponent(SceneComponentConstants.NAME_SUBSURFACE);
  if (!component) {
    component = new SubSurfaceSceneComponent(scene);
    scene._addComponent(component);
  }
};

// node_modules/@babylonjs/core/Shaders/outline.fragment.js
var name91 = "outlinePixelShader";
var shader91 = "#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\nuniform vec4 color;\n#ifdef ALPHATEST\nvarying vec2 vUV;\nuniform sampler2D diffuseSampler;\n#endif\n#include<logDepthDeclaration>\nvoid main(void) {\n#ifdef ALPHATEST\nif (texture2D(diffuseSampler,vUV).a<0.4)\ndiscard;\n#endif\n#include<logDepthFragment>\ngl_FragColor=color;\n}";
Effect.ShadersStore[name91] = shader91;

// node_modules/@babylonjs/core/Shaders/outline.vertex.js
var name92 = "outlineVertexShader";
var shader92 = "\nattribute vec3 position;\nattribute vec3 normal;\n#include<bonesDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n\nuniform float offset;\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\n#ifdef ALPHATEST\nvarying vec2 vUV;\nuniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\n#include<logDepthDeclaration>\nvoid main(void)\n{\nvec3 positionUpdated=position;\nvec3 normalUpdated=normal;\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\nvec3 offsetPosition=positionUpdated+(normalUpdated*offset);\n#include<instancesVertex>\n#include<bonesVertex>\ngl_Position=viewProjection*finalWorld*vec4(offsetPosition,1.0);\n#ifdef ALPHATEST\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n#include<logDepthVertex>\n}\n";
Effect.ShadersStore[name92] = shader92;

// node_modules/@babylonjs/core/Rendering/outlineRenderer.js
Scene.prototype.getOutlineRenderer = function() {
  if (!this._outlineRenderer) {
    this._outlineRenderer = new OutlineRenderer(this);
  }
  return this._outlineRenderer;
};
Object.defineProperty(Mesh.prototype, "renderOutline", {
  get: function() {
    return this._renderOutline;
  },
  set: function(value) {
    if (value) {
      this.getScene().getOutlineRenderer();
    }
    this._renderOutline = value;
  },
  enumerable: true,
  configurable: true
});
Object.defineProperty(Mesh.prototype, "renderOverlay", {
  get: function() {
    return this._renderOverlay;
  },
  set: function(value) {
    if (value) {
      this.getScene().getOutlineRenderer();
    }
    this._renderOverlay = value;
  },
  enumerable: true,
  configurable: true
});
var OutlineRenderer = function() {
  function OutlineRenderer2(scene) {
    this.name = SceneComponentConstants.NAME_OUTLINERENDERER;
    this.zOffset = 1;
    this.scene = scene;
    this._engine = scene.getEngine();
    this.scene._addComponent(this);
  }
  OutlineRenderer2.prototype.register = function() {
    this.scene._beforeRenderingMeshStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE, this, this._beforeRenderingMesh);
    this.scene._afterRenderingMeshStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE, this, this._afterRenderingMesh);
  };
  OutlineRenderer2.prototype.rebuild = function() {
  };
  OutlineRenderer2.prototype.dispose = function() {
  };
  OutlineRenderer2.prototype.render = function(subMesh, batch, useOverlay) {
    var _this = this;
    if (useOverlay === void 0) {
      useOverlay = false;
    }
    var scene = this.scene;
    var engine = scene.getEngine();
    var hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== void 0 || subMesh.getRenderingMesh().hasThinInstances);
    if (!this.isReady(subMesh, hardwareInstancedRendering)) {
      return;
    }
    var ownerMesh = subMesh.getMesh();
    var replacementMesh = ownerMesh._internalAbstractMeshDataInfo._actAsRegularMesh ? ownerMesh : null;
    var renderingMesh = subMesh.getRenderingMesh();
    var effectiveMesh = replacementMesh ? replacementMesh : renderingMesh;
    var material = subMesh.getMaterial();
    if (!material || !scene.activeCamera) {
      return;
    }
    engine.enableEffect(this._effect);
    if (material.useLogarithmicDepth) {
      this._effect.setFloat("logarithmicDepthConstant", 2 / (Math.log(scene.activeCamera.maxZ + 1) / Math.LN2));
    }
    this._effect.setFloat("offset", useOverlay ? 0 : renderingMesh.outlineWidth);
    this._effect.setColor4("color", useOverlay ? renderingMesh.overlayColor : renderingMesh.outlineColor, useOverlay ? renderingMesh.overlayAlpha : material.alpha);
    this._effect.setMatrix("viewProjection", scene.getTransformMatrix());
    this._effect.setMatrix("world", effectiveMesh.getWorldMatrix());
    if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {
      this._effect.setMatrices("mBones", renderingMesh.skeleton.getTransformMatrices(renderingMesh));
    }
    MaterialHelper.BindMorphTargetParameters(renderingMesh, this._effect);
    renderingMesh._bind(subMesh, this._effect, material.fillMode);
    if (material && material.needAlphaTesting()) {
      var alphaTexture = material.getAlphaTestTexture();
      if (alphaTexture) {
        this._effect.setTexture("diffuseSampler", alphaTexture);
        this._effect.setMatrix("diffuseMatrix", alphaTexture.getTextureMatrix());
      }
    }
    engine.setZOffset(-this.zOffset);
    renderingMesh._processRendering(effectiveMesh, subMesh, this._effect, material.fillMode, batch, hardwareInstancedRendering, function(isInstance, world) {
      _this._effect.setMatrix("world", world);
    });
    engine.setZOffset(0);
  };
  OutlineRenderer2.prototype.isReady = function(subMesh, useInstances) {
    var defines = [];
    var attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];
    var mesh = subMesh.getMesh();
    var material = subMesh.getMaterial();
    if (material) {
      if (material.needAlphaTesting()) {
        defines.push("#define ALPHATEST");
        if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
          attribs.push(VertexBuffer.UVKind);
          defines.push("#define UV1");
        }
        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
          attribs.push(VertexBuffer.UV2Kind);
          defines.push("#define UV2");
        }
      }
      if (material.useLogarithmicDepth) {
        defines.push("#define LOGARITHMICDEPTH");
      }
    }
    if (mesh.useBones && mesh.computeBonesUsingShaders) {
      attribs.push(VertexBuffer.MatricesIndicesKind);
      attribs.push(VertexBuffer.MatricesWeightsKind);
      if (mesh.numBoneInfluencers > 4) {
        attribs.push(VertexBuffer.MatricesIndicesExtraKind);
        attribs.push(VertexBuffer.MatricesWeightsExtraKind);
      }
      defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
      defines.push("#define BonesPerMesh " + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));
    } else {
      defines.push("#define NUM_BONE_INFLUENCERS 0");
    }
    var morphTargetManager = mesh.morphTargetManager;
    var numMorphInfluencers = 0;
    if (morphTargetManager) {
      if (morphTargetManager.numInfluencers > 0) {
        numMorphInfluencers = morphTargetManager.numInfluencers;
        defines.push("#define MORPHTARGETS");
        defines.push("#define NUM_MORPH_INFLUENCERS " + numMorphInfluencers);
        MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);
      }
    }
    if (useInstances) {
      defines.push("#define INSTANCES");
      MaterialHelper.PushAttributesForInstances(attribs);
      if (subMesh.getRenderingMesh().hasThinInstances) {
        defines.push("#define THIN_INSTANCES");
      }
    }
    var join = defines.join("\n");
    if (this._cachedDefines !== join) {
      this._cachedDefines = join;
      this._effect = this.scene.getEngine().createEffect("outline", attribs, ["world", "mBones", "viewProjection", "diffuseMatrix", "offset", "color", "logarithmicDepthConstant", "morphTargetInfluences"], ["diffuseSampler"], join, void 0, void 0, void 0, { maxSimultaneousMorphTargets: numMorphInfluencers });
    }
    return this._effect.isReady();
  };
  OutlineRenderer2.prototype._beforeRenderingMesh = function(mesh, subMesh, batch) {
    this._savedDepthWrite = this._engine.getDepthWrite();
    if (mesh.renderOutline) {
      var material = subMesh.getMaterial();
      if (material && material.needAlphaBlendingForMesh(mesh)) {
        this._engine.cacheStencilState();
        this._engine.setDepthWrite(false);
        this._engine.setColorWrite(false);
        this._engine.setStencilBuffer(true);
        this._engine.setStencilOperationPass(7681);
        this._engine.setStencilFunction(519);
        this._engine.setStencilMask(OutlineRenderer2._StencilReference);
        this._engine.setStencilFunctionReference(OutlineRenderer2._StencilReference);
        this.render(subMesh, batch, true);
        this._engine.setColorWrite(true);
        this._engine.setStencilFunction(517);
      }
      this._engine.setDepthWrite(false);
      this.render(subMesh, batch);
      this._engine.setDepthWrite(this._savedDepthWrite);
      if (material && material.needAlphaBlendingForMesh(mesh)) {
        this._engine.restoreStencilState();
      }
    }
  };
  OutlineRenderer2.prototype._afterRenderingMesh = function(mesh, subMesh, batch) {
    if (mesh.renderOverlay) {
      var currentMode = this._engine.getAlphaMode();
      var alphaBlendState = this._engine.alphaState.alphaBlend;
      this._engine.setAlphaMode(2);
      this.render(subMesh, batch, true);
      this._engine.setAlphaMode(currentMode);
      this._engine.setDepthWrite(this._savedDepthWrite);
      this._engine.alphaState.alphaBlend = alphaBlendState;
    }
    if (mesh.renderOutline && this._savedDepthWrite) {
      this._engine.setDepthWrite(true);
      this._engine.setColorWrite(false);
      this.render(subMesh, batch);
      this._engine.setColorWrite(true);
    }
  };
  OutlineRenderer2._StencilReference = 4;
  return OutlineRenderer2;
}();

// node_modules/@babylonjs/core/Sprites/thinSprite.js
var ThinSprite = function() {
  function ThinSprite2() {
    this.width = 1;
    this.height = 1;
    this.angle = 0;
    this.invertU = false;
    this.invertV = false;
    this.isVisible = true;
    this._animationStarted = false;
    this._loopAnimation = false;
    this._fromIndex = 0;
    this._toIndex = 0;
    this._delay = 0;
    this._direction = 1;
    this._time = 0;
    this._onBaseAnimationEnd = null;
    this.position = { x: 1, y: 1, z: 1 };
    this.color = { r: 1, g: 1, b: 1, a: 1 };
  }
  Object.defineProperty(ThinSprite2.prototype, "animationStarted", {
    get: function() {
      return this._animationStarted;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinSprite2.prototype, "fromIndex", {
    get: function() {
      return this._fromIndex;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinSprite2.prototype, "toIndex", {
    get: function() {
      return this._toIndex;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinSprite2.prototype, "loopAnimation", {
    get: function() {
      return this._loopAnimation;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinSprite2.prototype, "delay", {
    get: function() {
      return Math.max(this._delay, 1);
    },
    enumerable: false,
    configurable: true
  });
  ThinSprite2.prototype.playAnimation = function(from, to, loop, delay, onAnimationEnd) {
    this._fromIndex = from;
    this._toIndex = to;
    this._loopAnimation = loop;
    this._delay = delay || 1;
    this._animationStarted = true;
    this._onBaseAnimationEnd = onAnimationEnd;
    if (from < to) {
      this._direction = 1;
    } else {
      this._direction = -1;
      this._toIndex = from;
      this._fromIndex = to;
    }
    this.cellIndex = from;
    this._time = 0;
  };
  ThinSprite2.prototype.stopAnimation = function() {
    this._animationStarted = false;
  };
  ThinSprite2.prototype._animate = function(deltaTime) {
    if (!this._animationStarted) {
      return;
    }
    this._time += deltaTime;
    if (this._time > this._delay) {
      this._time = this._time % this._delay;
      this.cellIndex += this._direction;
      if (this._direction > 0 && this.cellIndex > this._toIndex || this._direction < 0 && this.cellIndex < this._fromIndex) {
        if (this._loopAnimation) {
          this.cellIndex = this._direction > 0 ? this._fromIndex : this._toIndex;
        } else {
          this.cellIndex = this._toIndex;
          this._animationStarted = false;
          if (this._onBaseAnimationEnd) {
            this._onBaseAnimationEnd();
          }
        }
      }
    }
  };
  return ThinSprite2;
}();

// node_modules/@babylonjs/core/Sprites/sprite.js
var Sprite = function(_super) {
  __extends(Sprite2, _super);
  function Sprite2(name98, manager) {
    var _this = _super.call(this) || this;
    _this.name = name98;
    _this.animations = new Array();
    _this.isPickable = false;
    _this.useAlphaForPicking = false;
    _this.onDisposeObservable = new Observable();
    _this._onAnimationEnd = null;
    _this._endAnimation = function() {
      if (_this._onAnimationEnd) {
        _this._onAnimationEnd();
      }
      if (_this.disposeWhenFinishedAnimating) {
        _this.dispose();
      }
    };
    _this.color = new Color4(1, 1, 1, 1);
    _this.position = Vector3.Zero();
    _this._manager = manager;
    _this._manager.sprites.push(_this);
    _this.uniqueId = _this._manager.scene.getUniqueId();
    return _this;
  }
  Object.defineProperty(Sprite2.prototype, "size", {
    get: function() {
      return this.width;
    },
    set: function(value) {
      this.width = value;
      this.height = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Sprite2.prototype, "manager", {
    get: function() {
      return this._manager;
    },
    enumerable: false,
    configurable: true
  });
  Sprite2.prototype.getClassName = function() {
    return "Sprite";
  };
  Object.defineProperty(Sprite2.prototype, "fromIndex", {
    get: function() {
      return this._fromIndex;
    },
    set: function(value) {
      this.playAnimation(value, this._toIndex, this._loopAnimation, this._delay, this._onAnimationEnd);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Sprite2.prototype, "toIndex", {
    get: function() {
      return this._toIndex;
    },
    set: function(value) {
      this.playAnimation(this._fromIndex, value, this._loopAnimation, this._delay, this._onAnimationEnd);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Sprite2.prototype, "loopAnimation", {
    get: function() {
      return this._loopAnimation;
    },
    set: function(value) {
      this.playAnimation(this._fromIndex, this._toIndex, value, this._delay, this._onAnimationEnd);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Sprite2.prototype, "delay", {
    get: function() {
      return Math.max(this._delay, 1);
    },
    set: function(value) {
      this.playAnimation(this._fromIndex, this._toIndex, this._loopAnimation, value, this._onAnimationEnd);
    },
    enumerable: false,
    configurable: true
  });
  Sprite2.prototype.playAnimation = function(from, to, loop, delay, onAnimationEnd) {
    if (onAnimationEnd === void 0) {
      onAnimationEnd = null;
    }
    this._onAnimationEnd = onAnimationEnd;
    _super.prototype.playAnimation.call(this, from, to, loop, delay, this._endAnimation);
  };
  Sprite2.prototype.dispose = function() {
    for (var i = 0; i < this._manager.sprites.length; i++) {
      if (this._manager.sprites[i] == this) {
        this._manager.sprites.splice(i, 1);
      }
    }
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
  };
  Sprite2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.name = this.name;
    serializationObject.position = this.position.asArray();
    serializationObject.color = this.color.asArray();
    serializationObject.width = this.width;
    serializationObject.height = this.height;
    serializationObject.angle = this.angle;
    serializationObject.cellIndex = this.cellIndex;
    serializationObject.cellRef = this.cellRef;
    serializationObject.invertU = this.invertU;
    serializationObject.invertV = this.invertV;
    serializationObject.disposeWhenFinishedAnimating = this.disposeWhenFinishedAnimating;
    serializationObject.isPickable = this.isPickable;
    serializationObject.isVisible = this.isVisible;
    serializationObject.useAlphaForPicking = this.useAlphaForPicking;
    serializationObject.animationStarted = this.animationStarted;
    serializationObject.fromIndex = this.fromIndex;
    serializationObject.toIndex = this.toIndex;
    serializationObject.loopAnimation = this.loopAnimation;
    serializationObject.delay = this.delay;
    return serializationObject;
  };
  Sprite2.Parse = function(parsedSprite, manager) {
    var sprite = new Sprite2(parsedSprite.name, manager);
    sprite.position = Vector3.FromArray(parsedSprite.position);
    sprite.color = Color4.FromArray(parsedSprite.color);
    sprite.width = parsedSprite.width;
    sprite.height = parsedSprite.height;
    sprite.angle = parsedSprite.angle;
    sprite.cellIndex = parsedSprite.cellIndex;
    sprite.cellRef = parsedSprite.cellRef;
    sprite.invertU = parsedSprite.invertU;
    sprite.invertV = parsedSprite.invertV;
    sprite.disposeWhenFinishedAnimating = parsedSprite.disposeWhenFinishedAnimating;
    sprite.isPickable = parsedSprite.isPickable;
    sprite.isVisible = parsedSprite.isVisible;
    sprite.useAlphaForPicking = parsedSprite.useAlphaForPicking;
    sprite.fromIndex = parsedSprite.fromIndex;
    sprite.toIndex = parsedSprite.toIndex;
    sprite.loopAnimation = parsedSprite.loopAnimation;
    sprite.delay = parsedSprite.delay;
    if (parsedSprite.animationStarted) {
      sprite.playAnimation(sprite.fromIndex, sprite.toIndex, sprite.loopAnimation, sprite.delay);
    }
    return sprite;
  };
  return Sprite2;
}(ThinSprite);

// node_modules/@babylonjs/core/Sprites/spriteSceneComponent.js
Scene.prototype._internalPickSprites = function(ray, predicate, fastCheck, camera) {
  if (!PickingInfo) {
    return null;
  }
  var pickingInfo = null;
  if (!camera) {
    if (!this.activeCamera) {
      return null;
    }
    camera = this.activeCamera;
  }
  if (this.spriteManagers.length > 0) {
    for (var spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {
      var spriteManager = this.spriteManagers[spriteIndex];
      if (!spriteManager.isPickable) {
        continue;
      }
      var result = spriteManager.intersects(ray, camera, predicate, fastCheck);
      if (!result || !result.hit) {
        continue;
      }
      if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {
        continue;
      }
      pickingInfo = result;
      if (fastCheck) {
        break;
      }
    }
  }
  return pickingInfo || new PickingInfo();
};
Scene.prototype._internalMultiPickSprites = function(ray, predicate, camera) {
  if (!PickingInfo) {
    return null;
  }
  var pickingInfos = new Array();
  if (!camera) {
    if (!this.activeCamera) {
      return null;
    }
    camera = this.activeCamera;
  }
  if (this.spriteManagers.length > 0) {
    for (var spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {
      var spriteManager = this.spriteManagers[spriteIndex];
      if (!spriteManager.isPickable) {
        continue;
      }
      var results = spriteManager.multiIntersects(ray, camera, predicate);
      if (results !== null) {
        pickingInfos = pickingInfos.concat(results);
      }
    }
  }
  return pickingInfos;
};
Scene.prototype.pickSprite = function(x, y, predicate, fastCheck, camera) {
  if (!this._tempSpritePickingRay) {
    return null;
  }
  this.createPickingRayInCameraSpaceToRef(x, y, this._tempSpritePickingRay, camera);
  return this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);
};
Scene.prototype.pickSpriteWithRay = function(ray, predicate, fastCheck, camera) {
  if (!this._tempSpritePickingRay) {
    return null;
  }
  if (!camera) {
    if (!this.activeCamera) {
      return null;
    }
    camera = this.activeCamera;
  }
  Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);
  return this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);
};
Scene.prototype.multiPickSprite = function(x, y, predicate, camera) {
  this.createPickingRayInCameraSpaceToRef(x, y, this._tempSpritePickingRay, camera);
  return this._internalMultiPickSprites(this._tempSpritePickingRay, predicate, camera);
};
Scene.prototype.multiPickSpriteWithRay = function(ray, predicate, camera) {
  if (!this._tempSpritePickingRay) {
    return null;
  }
  if (!camera) {
    if (!this.activeCamera) {
      return null;
    }
    camera = this.activeCamera;
  }
  Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);
  return this._internalMultiPickSprites(this._tempSpritePickingRay, predicate, camera);
};
Scene.prototype.setPointerOverSprite = function(sprite) {
  if (this._pointerOverSprite === sprite) {
    return;
  }
  if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {
    this._pointerOverSprite.actionManager.processTrigger(10, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));
  }
  this._pointerOverSprite = sprite;
  if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {
    this._pointerOverSprite.actionManager.processTrigger(9, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));
  }
};
Scene.prototype.getPointerOverSprite = function() {
  return this._pointerOverSprite;
};
var SpriteSceneComponent = function() {
  function SpriteSceneComponent2(scene) {
    this.name = SceneComponentConstants.NAME_SPRITE;
    this.scene = scene;
    this.scene.spriteManagers = new Array();
    this.scene._tempSpritePickingRay = Ray ? Ray.Zero() : null;
    this.scene.onBeforeSpritesRenderingObservable = new Observable();
    this.scene.onAfterSpritesRenderingObservable = new Observable();
    this._spritePredicate = function(sprite) {
      if (!sprite.actionManager) {
        return false;
      }
      return sprite.isPickable && sprite.actionManager.hasPointerTriggers;
    };
  }
  SpriteSceneComponent2.prototype.register = function() {
    this.scene._pointerMoveStage.registerStep(SceneComponentConstants.STEP_POINTERMOVE_SPRITE, this, this._pointerMove);
    this.scene._pointerDownStage.registerStep(SceneComponentConstants.STEP_POINTERDOWN_SPRITE, this, this._pointerDown);
    this.scene._pointerUpStage.registerStep(SceneComponentConstants.STEP_POINTERUP_SPRITE, this, this._pointerUp);
  };
  SpriteSceneComponent2.prototype.rebuild = function() {
  };
  SpriteSceneComponent2.prototype.dispose = function() {
    this.scene.onBeforeSpritesRenderingObservable.clear();
    this.scene.onAfterSpritesRenderingObservable.clear();
    var spriteManagers = this.scene.spriteManagers;
    while (spriteManagers.length) {
      spriteManagers[0].dispose();
    }
  };
  SpriteSceneComponent2.prototype._pickSpriteButKeepRay = function(originalPointerInfo, x, y, fastCheck, camera) {
    var result = this.scene.pickSprite(x, y, this._spritePredicate, fastCheck, camera);
    if (result) {
      result.ray = originalPointerInfo ? originalPointerInfo.ray : null;
    }
    return result;
  };
  SpriteSceneComponent2.prototype._pointerMove = function(unTranslatedPointerX, unTranslatedPointerY, pickResult, isMeshPicked, element) {
    var scene = this.scene;
    if (isMeshPicked) {
      scene.setPointerOverSprite(null);
    } else {
      pickResult = this._pickSpriteButKeepRay(pickResult, unTranslatedPointerX, unTranslatedPointerY, false, scene.cameraToUseForPointers || void 0);
      if (pickResult && pickResult.hit && pickResult.pickedSprite) {
        scene.setPointerOverSprite(pickResult.pickedSprite);
        if (!scene.doNotHandleCursors) {
          if (scene._pointerOverSprite && scene._pointerOverSprite.actionManager && scene._pointerOverSprite.actionManager.hoverCursor) {
            element.style.cursor = scene._pointerOverSprite.actionManager.hoverCursor;
          } else {
            element.style.cursor = scene.hoverCursor;
          }
        }
      } else {
        scene.setPointerOverSprite(null);
      }
    }
    return pickResult;
  };
  SpriteSceneComponent2.prototype._pointerDown = function(unTranslatedPointerX, unTranslatedPointerY, pickResult, evt) {
    var scene = this.scene;
    scene._pickedDownSprite = null;
    if (scene.spriteManagers.length > 0) {
      pickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || void 0);
      if (pickResult && pickResult.hit && pickResult.pickedSprite) {
        if (pickResult.pickedSprite.actionManager) {
          scene._pickedDownSprite = pickResult.pickedSprite;
          switch (evt.button) {
            case 0:
              pickResult.pickedSprite.actionManager.processTrigger(2, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));
              break;
            case 1:
              pickResult.pickedSprite.actionManager.processTrigger(4, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));
              break;
            case 2:
              pickResult.pickedSprite.actionManager.processTrigger(3, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));
              break;
          }
          if (pickResult.pickedSprite.actionManager) {
            pickResult.pickedSprite.actionManager.processTrigger(5, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));
          }
        }
      }
    }
    return pickResult;
  };
  SpriteSceneComponent2.prototype._pointerUp = function(unTranslatedPointerX, unTranslatedPointerY, pickResult, evt) {
    var scene = this.scene;
    if (scene.spriteManagers.length > 0) {
      var spritePickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || void 0);
      if (spritePickResult) {
        if (spritePickResult.hit && spritePickResult.pickedSprite) {
          if (spritePickResult.pickedSprite.actionManager) {
            spritePickResult.pickedSprite.actionManager.processTrigger(7, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));
            if (spritePickResult.pickedSprite.actionManager) {
              if (!this.scene._inputManager._isPointerSwiping()) {
                spritePickResult.pickedSprite.actionManager.processTrigger(1, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));
              }
            }
          }
        }
        if (scene._pickedDownSprite && scene._pickedDownSprite.actionManager && scene._pickedDownSprite !== spritePickResult.pickedSprite) {
          scene._pickedDownSprite.actionManager.processTrigger(16, ActionEvent.CreateNewFromSprite(scene._pickedDownSprite, scene, evt));
        }
      }
    }
    return pickResult;
  };
  return SpriteSceneComponent2;
}();

// node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingCompatibility.js
var name93 = "imageProcessingCompatibility";
var shader93 = "#ifdef IMAGEPROCESSINGPOSTPROCESS\ngl_FragColor.rgb=pow(gl_FragColor.rgb,vec3(2.2));\n#endif";
Effect.IncludesShadersStore[name93] = shader93;

// node_modules/@babylonjs/core/Shaders/sprites.fragment.js
var name94 = "spritesPixelShader";
var shader94 = "uniform bool alphaTest;\nvarying vec4 vColor;\n\nvarying vec2 vUV;\nuniform sampler2D diffuseSampler;\n\n#include<fogFragmentDeclaration>\nvoid main(void) {\nvec4 color=texture2D(diffuseSampler,vUV);\nif (alphaTest)\n{\nif (color.a<0.95)\ndiscard;\n}\ncolor*=vColor;\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n}";
Effect.ShadersStore[name94] = shader94;

// node_modules/@babylonjs/core/Shaders/sprites.vertex.js
var name95 = "spritesVertexShader";
var shader95 = "\nattribute vec4 position;\nattribute vec2 options;\nattribute vec2 offsets;\nattribute vec2 inverts;\nattribute vec4 cellInfo;\nattribute vec4 color;\n\nuniform mat4 view;\nuniform mat4 projection;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\n#include<fogVertexDeclaration>\nvoid main(void) {\nvec3 viewPos=(view*vec4(position.xyz,1.0)).xyz;\nvec2 cornerPos;\nfloat angle=position.w;\nvec2 size=vec2(options.x,options.y);\nvec2 offset=offsets.xy;\ncornerPos=vec2(offset.x-0.5,offset.y-0.5)*size;\n\nvec3 rotatedCorner;\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\nrotatedCorner.z=0.;\n\nviewPos+=rotatedCorner;\ngl_Position=projection*vec4(viewPos,1.0);\n\nvColor=color;\n\nvec2 uvOffset=vec2(abs(offset.x-inverts.x),abs(1.0-offset.y-inverts.y));\nvec2 uvPlace=cellInfo.xy;\nvec2 uvSize=cellInfo.zw;\nvUV.x=uvPlace.x+uvSize.x*uvOffset.x;\nvUV.y=uvPlace.y+uvSize.y*uvOffset.y;\n\n#ifdef FOG\nvFogDistance=viewPos;\n#endif\n}";
Effect.ShadersStore[name95] = shader95;

// node_modules/@babylonjs/core/Sprites/spriteRenderer.js
var SpriteRenderer = function() {
  function SpriteRenderer2(engine, capacity, epsilon, scene) {
    if (epsilon === void 0) {
      epsilon = 0.01;
    }
    if (scene === void 0) {
      scene = null;
    }
    this.blendMode = 2;
    this.autoResetAlpha = true;
    this.disableDepthWrite = false;
    this.fogEnabled = true;
    this._useVAO = false;
    this._useInstancing = false;
    this._vertexBuffers = {};
    this._capacity = capacity;
    this._epsilon = epsilon;
    this._engine = engine;
    this._useInstancing = engine.getCaps().instancedArrays;
    this._useVAO = engine.getCaps().vertexArrayObject && !engine.disableVertexArrayObjects;
    this._scene = scene;
    if (!this._useInstancing) {
      var indices = [];
      var index = 0;
      for (var count = 0; count < capacity; count++) {
        indices.push(index);
        indices.push(index + 1);
        indices.push(index + 2);
        indices.push(index);
        indices.push(index + 2);
        indices.push(index + 3);
        index += 4;
      }
      this._indexBuffer = engine.createIndexBuffer(indices);
    }
    this._vertexBufferSize = this._useInstancing ? 16 : 18;
    this._vertexData = new Float32Array(capacity * this._vertexBufferSize * (this._useInstancing ? 1 : 4));
    this._buffer = new Buffer(engine, this._vertexData, true, this._vertexBufferSize);
    var positions = this._buffer.createVertexBuffer(VertexBuffer.PositionKind, 0, 4, this._vertexBufferSize, this._useInstancing);
    var options = this._buffer.createVertexBuffer("options", 4, 2, this._vertexBufferSize, this._useInstancing);
    var offset = 6;
    var offsets;
    if (this._useInstancing) {
      var spriteData = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
      this._spriteBuffer = new Buffer(engine, spriteData, false, 2);
      offsets = this._spriteBuffer.createVertexBuffer("offsets", 0, 2);
    } else {
      offsets = this._buffer.createVertexBuffer("offsets", offset, 2, this._vertexBufferSize, this._useInstancing);
      offset += 2;
    }
    var inverts = this._buffer.createVertexBuffer("inverts", offset, 2, this._vertexBufferSize, this._useInstancing);
    var cellInfo = this._buffer.createVertexBuffer("cellInfo", offset + 2, 4, this._vertexBufferSize, this._useInstancing);
    var colors = this._buffer.createVertexBuffer(VertexBuffer.ColorKind, offset + 6, 4, this._vertexBufferSize, this._useInstancing);
    this._vertexBuffers[VertexBuffer.PositionKind] = positions;
    this._vertexBuffers["options"] = options;
    this._vertexBuffers["offsets"] = offsets;
    this._vertexBuffers["inverts"] = inverts;
    this._vertexBuffers["cellInfo"] = cellInfo;
    this._vertexBuffers[VertexBuffer.ColorKind] = colors;
    this._effectBase = this._engine.createEffect("sprites", [VertexBuffer.PositionKind, "options", "offsets", "inverts", "cellInfo", VertexBuffer.ColorKind], ["view", "projection", "textureInfos", "alphaTest"], ["diffuseSampler"], "");
    if (this._scene) {
      this._effectFog = this._scene.getEngine().createEffect("sprites", [VertexBuffer.PositionKind, "options", "offsets", "inverts", "cellInfo", VertexBuffer.ColorKind], ["view", "projection", "textureInfos", "alphaTest", "vFogInfos", "vFogColor"], ["diffuseSampler"], "#define FOG");
    }
  }
  Object.defineProperty(SpriteRenderer2.prototype, "capacity", {
    get: function() {
      return this._capacity;
    },
    enumerable: false,
    configurable: true
  });
  SpriteRenderer2.prototype.render = function(sprites, deltaTime, viewMatrix, projectionMatrix, customSpriteUpdate) {
    if (customSpriteUpdate === void 0) {
      customSpriteUpdate = null;
    }
    if (!this.texture || !this.texture.isReady() || !sprites.length) {
      return;
    }
    var effect = this._effectBase;
    var shouldRenderFog = false;
    if (this.fogEnabled && this._scene && this._scene.fogEnabled && this._scene.fogMode !== 0) {
      effect = this._effectFog;
      shouldRenderFog = true;
    }
    if (!effect.isReady()) {
      return;
    }
    var engine = this._engine;
    var useRightHandedSystem = !!(this._scene && this._scene.useRightHandedSystem);
    var baseSize = this.texture.getBaseSize();
    var max = Math.min(this._capacity, sprites.length);
    var offset = 0;
    var noSprite = true;
    for (var index = 0; index < max; index++) {
      var sprite = sprites[index];
      if (!sprite || !sprite.isVisible) {
        continue;
      }
      noSprite = false;
      sprite._animate(deltaTime);
      this._appendSpriteVertex(offset++, sprite, 0, 0, baseSize, useRightHandedSystem, customSpriteUpdate);
      if (!this._useInstancing) {
        this._appendSpriteVertex(offset++, sprite, 1, 0, baseSize, useRightHandedSystem, customSpriteUpdate);
        this._appendSpriteVertex(offset++, sprite, 1, 1, baseSize, useRightHandedSystem, customSpriteUpdate);
        this._appendSpriteVertex(offset++, sprite, 0, 1, baseSize, useRightHandedSystem, customSpriteUpdate);
      }
    }
    if (noSprite) {
      return;
    }
    this._buffer.update(this._vertexData);
    var culling = engine.depthCullingState.cull || true;
    var zOffset = engine.depthCullingState.zOffset;
    if (useRightHandedSystem) {
      this._scene.getEngine().setState(culling, zOffset, false, false);
    }
    engine.enableEffect(effect);
    effect.setTexture("diffuseSampler", this.texture);
    effect.setMatrix("view", viewMatrix);
    effect.setMatrix("projection", projectionMatrix);
    if (shouldRenderFog) {
      var scene = this._scene;
      effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);
      effect.setColor3("vFogColor", scene.fogColor);
    }
    if (this._useVAO) {
      if (!this._vertexArrayObject) {
        this._vertexArrayObject = engine.recordVertexArrayObject(this._vertexBuffers, this._indexBuffer, effect);
      }
      engine.bindVertexArrayObject(this._vertexArrayObject, this._indexBuffer);
    } else {
      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
    }
    engine.depthCullingState.depthFunc = 515;
    if (!this.disableDepthWrite) {
      effect.setBool("alphaTest", true);
      engine.setColorWrite(false);
      if (this._useInstancing) {
        engine.drawArraysType(8, 0, 4, offset);
      } else {
        engine.drawElementsType(0, 0, offset / 4 * 6);
      }
      engine.setColorWrite(true);
      effect.setBool("alphaTest", false);
    }
    engine.setAlphaMode(this.blendMode);
    if (this._useInstancing) {
      engine.drawArraysType(8, 0, 4, offset);
    } else {
      engine.drawElementsType(0, 0, offset / 4 * 6);
    }
    if (this.autoResetAlpha) {
      engine.setAlphaMode(0);
    }
    if (useRightHandedSystem) {
      this._scene.getEngine().setState(culling, zOffset, false, true);
    }
    engine.unbindInstanceAttributes();
  };
  SpriteRenderer2.prototype._appendSpriteVertex = function(index, sprite, offsetX, offsetY, baseSize, useRightHandedSystem, customSpriteUpdate) {
    var arrayOffset = index * this._vertexBufferSize;
    if (offsetX === 0) {
      offsetX = this._epsilon;
    } else if (offsetX === 1) {
      offsetX = 1 - this._epsilon;
    }
    if (offsetY === 0) {
      offsetY = this._epsilon;
    } else if (offsetY === 1) {
      offsetY = 1 - this._epsilon;
    }
    if (customSpriteUpdate) {
      customSpriteUpdate(sprite, baseSize);
    } else {
      if (!sprite.cellIndex) {
        sprite.cellIndex = 0;
      }
      var rowSize = baseSize.width / this.cellWidth;
      var offset = sprite.cellIndex / rowSize >> 0;
      sprite._xOffset = (sprite.cellIndex - offset * rowSize) * this.cellWidth / baseSize.width;
      sprite._yOffset = offset * this.cellHeight / baseSize.height;
      sprite._xSize = this.cellWidth;
      sprite._ySize = this.cellHeight;
    }
    this._vertexData[arrayOffset] = sprite.position.x;
    this._vertexData[arrayOffset + 1] = sprite.position.y;
    this._vertexData[arrayOffset + 2] = sprite.position.z;
    this._vertexData[arrayOffset + 3] = sprite.angle;
    this._vertexData[arrayOffset + 4] = sprite.width;
    this._vertexData[arrayOffset + 5] = sprite.height;
    if (!this._useInstancing) {
      this._vertexData[arrayOffset + 6] = offsetX;
      this._vertexData[arrayOffset + 7] = offsetY;
    } else {
      arrayOffset -= 2;
    }
    if (useRightHandedSystem) {
      this._vertexData[arrayOffset + 8] = sprite.invertU ? 0 : 1;
    } else {
      this._vertexData[arrayOffset + 8] = sprite.invertU ? 1 : 0;
    }
    this._vertexData[arrayOffset + 9] = sprite.invertV ? 1 : 0;
    this._vertexData[arrayOffset + 10] = sprite._xOffset;
    this._vertexData[arrayOffset + 11] = sprite._yOffset;
    this._vertexData[arrayOffset + 12] = sprite._xSize / baseSize.width;
    this._vertexData[arrayOffset + 13] = sprite._ySize / baseSize.height;
    this._vertexData[arrayOffset + 14] = sprite.color.r;
    this._vertexData[arrayOffset + 15] = sprite.color.g;
    this._vertexData[arrayOffset + 16] = sprite.color.b;
    this._vertexData[arrayOffset + 17] = sprite.color.a;
  };
  SpriteRenderer2.prototype.dispose = function() {
    if (this._buffer) {
      this._buffer.dispose();
      this._buffer = null;
    }
    if (this._spriteBuffer) {
      this._spriteBuffer.dispose();
      this._spriteBuffer = null;
    }
    if (this._indexBuffer) {
      this._engine._releaseBuffer(this._indexBuffer);
      this._indexBuffer = null;
    }
    if (this._vertexArrayObject) {
      this._engine.releaseVertexArrayObject(this._vertexArrayObject);
      this._vertexArrayObject = null;
    }
    if (this.texture) {
      this.texture.dispose();
      this.texture = null;
    }
  };
  return SpriteRenderer2;
}();

// node_modules/@babylonjs/core/Sprites/spriteManager.js
var SpriteManager = function() {
  function SpriteManager2(name98, imgUrl, capacity, cellSize, scene, epsilon, samplingMode, fromPacked, spriteJSON) {
    var _this = this;
    if (epsilon === void 0) {
      epsilon = 0.01;
    }
    if (samplingMode === void 0) {
      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;
    }
    if (fromPacked === void 0) {
      fromPacked = false;
    }
    if (spriteJSON === void 0) {
      spriteJSON = null;
    }
    this.name = name98;
    this.sprites = new Array();
    this.renderingGroupId = 0;
    this.layerMask = 268435455;
    this.isPickable = false;
    this.onDisposeObservable = new Observable();
    this.disableDepthWrite = false;
    this._packedAndReady = false;
    this._customUpdate = function(sprite, baseSize) {
      if (!sprite.cellRef) {
        sprite.cellIndex = 0;
      }
      var num = sprite.cellIndex;
      if (typeof num === "number" && isFinite(num) && Math.floor(num) === num) {
        sprite.cellRef = _this._spriteMap[sprite.cellIndex];
      }
      sprite._xOffset = _this._cellData[sprite.cellRef].frame.x / baseSize.width;
      sprite._yOffset = _this._cellData[sprite.cellRef].frame.y / baseSize.height;
      sprite._xSize = _this._cellData[sprite.cellRef].frame.w;
      sprite._ySize = _this._cellData[sprite.cellRef].frame.h;
    };
    if (!scene) {
      scene = Engine.LastCreatedScene;
    }
    if (!scene._getComponent(SceneComponentConstants.NAME_SPRITE)) {
      scene._addComponent(new SpriteSceneComponent(scene));
    }
    this._fromPacked = fromPacked;
    this._scene = scene;
    var engine = this._scene.getEngine();
    this._spriteRenderer = new SpriteRenderer(engine, capacity, epsilon, scene);
    if (cellSize.width && cellSize.height) {
      this.cellWidth = cellSize.width;
      this.cellHeight = cellSize.height;
    } else if (cellSize !== void 0) {
      this.cellWidth = cellSize;
      this.cellHeight = cellSize;
    } else {
      this._spriteRenderer = null;
      return;
    }
    this._scene.spriteManagers.push(this);
    this.uniqueId = this.scene.getUniqueId();
    if (imgUrl) {
      this.texture = new Texture(imgUrl, scene, true, false, samplingMode);
    }
    if (this._fromPacked) {
      this._makePacked(imgUrl, spriteJSON);
    }
  }
  Object.defineProperty(SpriteManager2.prototype, "onDispose", {
    set: function(callback) {
      if (this._onDisposeObserver) {
        this.onDisposeObservable.remove(this._onDisposeObserver);
      }
      this._onDisposeObserver = this.onDisposeObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SpriteManager2.prototype, "children", {
    get: function() {
      return this.sprites;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SpriteManager2.prototype, "scene", {
    get: function() {
      return this._scene;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SpriteManager2.prototype, "capacity", {
    get: function() {
      return this._spriteRenderer.capacity;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SpriteManager2.prototype, "texture", {
    get: function() {
      return this._spriteRenderer.texture;
    },
    set: function(value) {
      value.wrapU = Texture.CLAMP_ADDRESSMODE;
      value.wrapV = Texture.CLAMP_ADDRESSMODE;
      this._spriteRenderer.texture = value;
      this._textureContent = null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SpriteManager2.prototype, "cellWidth", {
    get: function() {
      return this._spriteRenderer.cellWidth;
    },
    set: function(value) {
      this._spriteRenderer.cellWidth = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SpriteManager2.prototype, "cellHeight", {
    get: function() {
      return this._spriteRenderer.cellHeight;
    },
    set: function(value) {
      this._spriteRenderer.cellHeight = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SpriteManager2.prototype, "fogEnabled", {
    get: function() {
      return this._spriteRenderer.fogEnabled;
    },
    set: function(value) {
      this._spriteRenderer.fogEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SpriteManager2.prototype, "blendMode", {
    get: function() {
      return this._spriteRenderer.blendMode;
    },
    set: function(blendMode) {
      this._spriteRenderer.blendMode = blendMode;
    },
    enumerable: false,
    configurable: true
  });
  SpriteManager2.prototype.getClassName = function() {
    return "SpriteManager";
  };
  SpriteManager2.prototype._makePacked = function(imgUrl, spriteJSON) {
    var _this = this;
    if (spriteJSON !== null) {
      try {
        var celldata = void 0;
        if (typeof spriteJSON === "string") {
          celldata = JSON.parse(spriteJSON);
        } else {
          celldata = spriteJSON;
        }
        if (celldata.frames.length) {
          var frametemp = {};
          for (var i = 0; i < celldata.frames.length; i++) {
            var _f = celldata.frames[i];
            if (typeof Object.keys(_f)[0] !== "string") {
              throw new Error("Invalid JSON Format.  Check the frame values and make sure the name is the first parameter.");
            }
            var name_1 = _f[Object.keys(_f)[0]];
            frametemp[name_1] = _f;
          }
          celldata.frames = frametemp;
        }
        var spritemap = Reflect.ownKeys(celldata.frames);
        this._spriteMap = spritemap;
        this._packedAndReady = true;
        this._cellData = celldata.frames;
      } catch (e) {
        this._fromPacked = false;
        this._packedAndReady = false;
        throw new Error("Invalid JSON from string. Spritesheet managed with constant cell size.");
      }
    } else {
      var re = /\./g;
      var li = void 0;
      do {
        li = re.lastIndex;
        re.test(imgUrl);
      } while (re.lastIndex > 0);
      var jsonUrl = imgUrl.substring(0, li - 1) + ".json";
      var xmlhttp_1 = new XMLHttpRequest();
      xmlhttp_1.open("GET", jsonUrl, true);
      xmlhttp_1.onerror = function() {
        Logger.Error("JSON ERROR: Unable to load JSON file.");
        _this._fromPacked = false;
        _this._packedAndReady = false;
      };
      xmlhttp_1.onload = function() {
        try {
          var celldata2 = JSON.parse(xmlhttp_1.response);
          var spritemap2 = Reflect.ownKeys(celldata2.frames);
          _this._spriteMap = spritemap2;
          _this._packedAndReady = true;
          _this._cellData = celldata2.frames;
        } catch (e) {
          _this._fromPacked = false;
          _this._packedAndReady = false;
          throw new Error("Invalid JSON format. Please check documentation for format specifications.");
        }
      };
      xmlhttp_1.send();
    }
  };
  SpriteManager2.prototype._checkTextureAlpha = function(sprite, ray, distance, min, max) {
    if (!sprite.useAlphaForPicking || !this.texture) {
      return true;
    }
    var textureSize = this.texture.getSize();
    if (!this._textureContent) {
      this._textureContent = new Uint8Array(textureSize.width * textureSize.height * 4);
      this.texture.readPixels(0, 0, this._textureContent);
    }
    var contactPoint = TmpVectors.Vector3[0];
    contactPoint.copyFrom(ray.direction);
    contactPoint.normalize();
    contactPoint.scaleInPlace(distance);
    contactPoint.addInPlace(ray.origin);
    var contactPointU = (contactPoint.x - min.x) / (max.x - min.x) - 0.5;
    var contactPointV = 1 - (contactPoint.y - min.y) / (max.y - min.y) - 0.5;
    var angle = sprite.angle;
    var rotatedU = 0.5 + (contactPointU * Math.cos(angle) - contactPointV * Math.sin(angle));
    var rotatedV = 0.5 + (contactPointU * Math.sin(angle) + contactPointV * Math.cos(angle));
    var u = sprite._xOffset * textureSize.width + rotatedU * sprite._xSize | 0;
    var v = sprite._yOffset * textureSize.height + rotatedV * sprite._ySize | 0;
    var alpha = this._textureContent[(u + v * textureSize.width) * 4 + 3];
    return alpha > 0.5;
  };
  SpriteManager2.prototype.intersects = function(ray, camera, predicate, fastCheck) {
    var count = Math.min(this.capacity, this.sprites.length);
    var min = Vector3.Zero();
    var max = Vector3.Zero();
    var distance = Number.MAX_VALUE;
    var currentSprite = null;
    var pickedPoint = TmpVectors.Vector3[0];
    var cameraSpacePosition = TmpVectors.Vector3[1];
    var cameraView = camera.getViewMatrix();
    for (var index = 0; index < count; index++) {
      var sprite = this.sprites[index];
      if (!sprite) {
        continue;
      }
      if (predicate) {
        if (!predicate(sprite)) {
          continue;
        }
      } else if (!sprite.isPickable) {
        continue;
      }
      Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);
      min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);
      max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);
      if (ray.intersectsBoxMinMax(min, max)) {
        var currentDistance = Vector3.Distance(cameraSpacePosition, ray.origin);
        if (distance > currentDistance) {
          if (!this._checkTextureAlpha(sprite, ray, currentDistance, min, max)) {
            continue;
          }
          distance = currentDistance;
          currentSprite = sprite;
          if (fastCheck) {
            break;
          }
        }
      }
    }
    if (currentSprite) {
      var result = new PickingInfo();
      cameraView.invertToRef(TmpVectors.Matrix[0]);
      result.hit = true;
      result.pickedSprite = currentSprite;
      result.distance = distance;
      var direction = TmpVectors.Vector3[2];
      direction.copyFrom(ray.direction);
      direction.normalize();
      direction.scaleInPlace(distance);
      ray.origin.addToRef(direction, pickedPoint);
      result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);
      return result;
    }
    return null;
  };
  SpriteManager2.prototype.multiIntersects = function(ray, camera, predicate) {
    var count = Math.min(this.capacity, this.sprites.length);
    var min = Vector3.Zero();
    var max = Vector3.Zero();
    var distance;
    var results = [];
    var pickedPoint = TmpVectors.Vector3[0].copyFromFloats(0, 0, 0);
    var cameraSpacePosition = TmpVectors.Vector3[1].copyFromFloats(0, 0, 0);
    var cameraView = camera.getViewMatrix();
    for (var index = 0; index < count; index++) {
      var sprite = this.sprites[index];
      if (!sprite) {
        continue;
      }
      if (predicate) {
        if (!predicate(sprite)) {
          continue;
        }
      } else if (!sprite.isPickable) {
        continue;
      }
      Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);
      min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);
      max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);
      if (ray.intersectsBoxMinMax(min, max)) {
        distance = Vector3.Distance(cameraSpacePosition, ray.origin);
        if (!this._checkTextureAlpha(sprite, ray, distance, min, max)) {
          continue;
        }
        var result = new PickingInfo();
        results.push(result);
        cameraView.invertToRef(TmpVectors.Matrix[0]);
        result.hit = true;
        result.pickedSprite = sprite;
        result.distance = distance;
        var direction = TmpVectors.Vector3[2];
        direction.copyFrom(ray.direction);
        direction.normalize();
        direction.scaleInPlace(distance);
        ray.origin.addToRef(direction, pickedPoint);
        result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);
      }
    }
    return results;
  };
  SpriteManager2.prototype.render = function() {
    if (this._fromPacked && (!this._packedAndReady || !this._spriteMap || !this._cellData)) {
      return;
    }
    var engine = this._scene.getEngine();
    var deltaTime = engine.getDeltaTime();
    if (this._packedAndReady) {
      this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix(), this._customUpdate);
    } else {
      this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix());
    }
  };
  SpriteManager2.prototype.dispose = function() {
    if (this._spriteRenderer) {
      this._spriteRenderer.dispose();
      this._spriteRenderer = null;
    }
    this._textureContent = null;
    var index = this._scene.spriteManagers.indexOf(this);
    this._scene.spriteManagers.splice(index, 1);
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
  };
  SpriteManager2.prototype.serialize = function(serializeTexture) {
    if (serializeTexture === void 0) {
      serializeTexture = false;
    }
    var serializationObject = {};
    serializationObject.name = this.name;
    serializationObject.capacity = this.capacity;
    serializationObject.cellWidth = this.cellWidth;
    serializationObject.cellHeight = this.cellHeight;
    if (this.texture) {
      if (serializeTexture) {
        serializationObject.texture = this.texture.serialize();
      } else {
        serializationObject.textureUrl = this.texture.name;
        serializationObject.invertY = this.texture._invertY;
      }
    }
    serializationObject.sprites = [];
    for (var _i = 0, _a = this.sprites; _i < _a.length; _i++) {
      var sprite = _a[_i];
      serializationObject.sprites.push(sprite.serialize());
    }
    return serializationObject;
  };
  SpriteManager2.Parse = function(parsedManager, scene, rootUrl) {
    var manager = new SpriteManager2(parsedManager.name, "", parsedManager.capacity, {
      width: parsedManager.cellWidth,
      height: parsedManager.cellHeight
    }, scene);
    if (parsedManager.texture) {
      manager.texture = Texture.Parse(parsedManager.texture, scene, rootUrl);
    } else if (parsedManager.textureName) {
      manager.texture = new Texture(rootUrl + parsedManager.textureUrl, scene, false, parsedManager.invertY !== void 0 ? parsedManager.invertY : true);
    }
    for (var _i = 0, _a = parsedManager.sprites; _i < _a.length; _i++) {
      var parsedSprite = _a[_i];
      Sprite.Parse(parsedSprite, manager);
    }
    return manager;
  };
  SpriteManager2.ParseFromFileAsync = function(name98, url, scene, rootUrl) {
    if (rootUrl === void 0) {
      rootUrl = "";
    }
    return new Promise(function(resolve, reject) {
      var request = new WebRequest();
      request.addEventListener("readystatechange", function() {
        if (request.readyState == 4) {
          if (request.status == 200) {
            var serializationObject = JSON.parse(request.responseText);
            var output = SpriteManager2.Parse(serializationObject, scene || Engine.LastCreatedScene, rootUrl);
            if (name98) {
              output.name = name98;
            }
            resolve(output);
          } else {
            reject("Unable to load the sprite manager");
          }
        }
      });
      request.open("GET", url);
      request.send();
    });
  };
  SpriteManager2.CreateFromSnippetAsync = function(snippetId, scene, rootUrl) {
    var _this = this;
    if (rootUrl === void 0) {
      rootUrl = "";
    }
    if (snippetId === "_BLANK") {
      return Promise.resolve(new SpriteManager2("Default sprite manager", "//playground.babylonjs.com/textures/player.png", 500, 64, scene));
    }
    return new Promise(function(resolve, reject) {
      var request = new WebRequest();
      request.addEventListener("readystatechange", function() {
        if (request.readyState == 4) {
          if (request.status == 200) {
            var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
            var serializationObject = JSON.parse(snippet.spriteManager);
            var output = SpriteManager2.Parse(serializationObject, scene || Engine.LastCreatedScene, rootUrl);
            output.snippetId = snippetId;
            resolve(output);
          } else {
            reject("Unable to load the snippet " + snippetId);
          }
        }
      });
      request.open("GET", _this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
      request.send();
    });
  };
  SpriteManager2.SnippetUrl = "https://snippet.babylonjs.com";
  return SpriteManager2;
}();

// node_modules/@babylonjs/core/Shaders/spriteMap.fragment.js
var name96 = "spriteMapPixelShader";
var shader96 = "precision highp float;\nvarying vec3 vPosition;\nvarying vec2 vUV;\nvarying vec2 tUV;\nuniform float time;\nuniform float spriteCount;\nuniform sampler2D spriteSheet;\nuniform vec2 spriteMapSize;\nuniform vec2 outputSize;\nuniform vec2 stageSize;\nuniform sampler2D frameMap;\nuniform sampler2D tileMaps[LAYERS];\nuniform sampler2D animationMap;\nuniform vec3 colorMul;\nfloat mt;\nconst float fdStep=1./4.;\nconst float aFrameSteps=1./MAX_ANIMATION_FRAMES;\nmat4 getFrameData(float frameID){\nfloat fX=frameID/spriteCount;\nreturn mat4(\ntexture2D(frameMap,vec2(fX,0.),0.),\ntexture2D(frameMap,vec2(fX,fdStep*1.),0.),\ntexture2D(frameMap,vec2(fX,fdStep*2.),0.),\nvec4(0.)\n);\n}\nvoid main(){\nvec4 color=vec4(0.);\nvec2 tileUV=fract(tUV);\n#ifdef FLIPU\ntileUV.y=1.0-tileUV.y;\n#endif\nvec2 tileID=floor(tUV);\nvec2 sheetUnits=1./spriteMapSize;\nfloat spriteUnits=1./spriteCount;\nvec2 stageUnits=1./stageSize;\nfor(int i=0; i<LAYERS; i++) {\nfloat frameID;\n#define LAYER_ID_SWITCH\nvec4 animationData=texture2D(animationMap,vec2((frameID+0.5)/spriteCount,0.),0.);\nif(animationData.y>0.) {\nmt=mod(time*animationData.z,1.0);\nfor(float f=0.; f<MAX_ANIMATION_FRAMES; f++){\nif(animationData.y>mt){\nframeID=animationData.x;\nbreak;\n}\nanimationData=texture2D(animationMap,vec2((frameID+0.5)/spriteCount,aFrameSteps*f),0.);\n}\n}\n\nmat4 frameData=getFrameData(frameID+0.5);\nvec2 frameSize=(frameData[0].wz)/spriteMapSize;\nvec2 offset=frameData[0].xy*sheetUnits;\nvec2 ratio=frameData[2].xy/frameData[0].wz;\n\nif (frameData[2].z == 1.){\ntileUV.xy=tileUV.yx;\n}\nif (i == 0){\ncolor=texture2D(spriteSheet,tileUV*frameSize+offset);\n} else {\nvec4 nc=texture2D(spriteSheet,tileUV*frameSize+offset);\nfloat alpha=min(color.a+nc.a,1.0);\nvec3 mixed=mix(color.xyz,nc.xyz,nc.a);\ncolor=vec4(mixed,alpha);\n}\n}\ncolor.xyz*=colorMul;\ngl_FragColor=color;\n}";
Effect.ShadersStore[name96] = shader96;

// node_modules/@babylonjs/core/Shaders/spriteMap.vertex.js
var name97 = "spriteMapVertexShader";
var shader97 = "precision highp float;\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\nvarying vec3 vPosition;\nvarying vec2 vUV;\nvarying vec2 tUV;\nvarying vec2 stageUnits;\nvarying vec2 levelUnits;\nvarying vec2 tileID;\n\nuniform float time;\nuniform mat4 worldViewProjection;\nuniform vec2 outputSize;\nuniform vec2 stageSize;\nuniform vec2 spriteMapSize;\nuniform float stageScale;\nvoid main() {\nvec4 p=vec4( position,1. );\nvPosition=p.xyz;\nvUV=uv;\ntUV=uv*stageSize;\ngl_Position=worldViewProjection*p;\n}";
Effect.ShadersStore[name97] = shader97;

// node_modules/@babylonjs/core/Sprites/spriteMap.js
var SpriteMap = function() {
  function SpriteMap2(name98, atlasJSON, spriteSheet, options, scene) {
    var _this = this;
    this.name = name98;
    this.sprites = [];
    this.atlasJSON = atlasJSON;
    this.sprites = this.atlasJSON["frames"];
    this.spriteSheet = spriteSheet;
    this.options = options;
    options.stageSize = options.stageSize || new Vector2(1, 1);
    options.outputSize = options.outputSize || options.stageSize;
    options.outputPosition = options.outputPosition || Vector3.Zero();
    options.outputRotation = options.outputRotation || Vector3.Zero();
    options.layerCount = options.layerCount || 1;
    options.maxAnimationFrames = options.maxAnimationFrames || 0;
    options.baseTile = options.baseTile || 0;
    options.flipU = options.flipU || false;
    options.colorMultiply = options.colorMultiply || new Vector3(1, 1, 1);
    this._scene = scene;
    this._frameMap = this._createFrameBuffer();
    this._tileMaps = new Array();
    for (var i = 0; i < options.layerCount; i++) {
      this._tileMaps.push(this._createTileBuffer(null, i));
    }
    this._animationMap = this._createTileAnimationBuffer(null);
    var defines = [];
    defines.push("#define LAYERS " + options.layerCount);
    if (options.flipU) {
      defines.push("#define FLIPU");
    }
    defines.push("#define MAX_ANIMATION_FRAMES " + options.maxAnimationFrames + ".0");
    var shaderString = Effect.ShadersStore["spriteMapPixelShader"];
    var layerSampleString;
    if (this._scene.getEngine().webGLVersion === 1) {
      layerSampleString = "";
      for (var i = 0; i < options.layerCount; i++) {
        layerSampleString += "if (" + i + " == i) { frameID = texture2D(tileMaps[" + i + "], (tileID + 0.5) / stageSize, 0.).x; }";
      }
    } else {
      layerSampleString = "switch(i) {";
      for (var i = 0; i < options.layerCount; i++) {
        layerSampleString += "case " + i + " : frameID = texture(tileMaps[" + i + "], (tileID + 0.5) / stageSize, 0.).x;";
        layerSampleString += "break;";
      }
      layerSampleString += "}";
    }
    Effect.ShadersStore["spriteMap" + this.name + "PixelShader"] = shaderString.replace("#define LAYER_ID_SWITCH", layerSampleString);
    this._material = new ShaderMaterial("spriteMap:" + this.name, this._scene, {
      vertex: "spriteMap",
      fragment: "spriteMap" + this.name
    }, {
      defines,
      attributes: ["position", "normal", "uv"],
      uniforms: [
        "worldViewProjection",
        "time",
        "stageSize",
        "outputSize",
        "spriteMapSize",
        "spriteCount",
        "time",
        "colorMul",
        "mousePosition",
        "curTile",
        "flipU"
      ],
      samplers: [
        "spriteSheet",
        "frameMap",
        "tileMaps",
        "animationMap"
      ],
      needAlphaBlending: true
    });
    this._time = 0;
    this._material.setFloat("spriteCount", this.spriteCount);
    this._material.setVector2("stageSize", options.stageSize);
    this._material.setVector2("outputSize", options.outputSize);
    this._material.setTexture("spriteSheet", this.spriteSheet);
    this._material.setVector2("spriteMapSize", new Vector2(1, 1));
    this._material.setVector3("colorMul", options.colorMultiply);
    var tickSave = 0;
    var bindSpriteTexture = function() {
      if (_this.spriteSheet && _this.spriteSheet.isReady()) {
        if (_this.spriteSheet._texture) {
          _this._material.setVector2("spriteMapSize", new Vector2(_this.spriteSheet._texture.baseWidth || 1, _this.spriteSheet._texture.baseHeight || 1));
          return;
        }
      }
      if (tickSave < 100) {
        setTimeout(function() {
          tickSave++;
          bindSpriteTexture();
        }, 100);
      }
    };
    bindSpriteTexture();
    this._material.setVector3("colorMul", options.colorMultiply);
    this._material.setTexture("frameMap", this._frameMap);
    this._material.setTextureArray("tileMaps", this._tileMaps);
    this._material.setTexture("animationMap", this._animationMap);
    this._material.setFloat("time", this._time);
    this._output = Mesh.CreatePlane(name98 + ":output", 1, scene, true);
    this._output.scaling.x = options.outputSize.x;
    this._output.scaling.y = options.outputSize.y;
    this.position = options.outputPosition;
    this.rotation = options.outputRotation;
    var obfunction = function() {
      _this._time += _this._scene.getEngine().getDeltaTime();
      _this._material.setFloat("time", _this._time);
    };
    this._scene.onBeforeRenderObservable.add(obfunction);
    this._output.material = this._material;
  }
  Object.defineProperty(SpriteMap2.prototype, "spriteCount", {
    get: function() {
      return this.sprites.length;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SpriteMap2.prototype, "position", {
    get: function() {
      return this._output.position;
    },
    set: function(v) {
      this._output.position = v;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SpriteMap2.prototype, "rotation", {
    get: function() {
      return this._output.rotation;
    },
    set: function(v) {
      this._output.rotation = v;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SpriteMap2.prototype, "animationMap", {
    get: function() {
      return this._animationMap;
    },
    set: function(v) {
      var buffer = v._texture._bufferView;
      var am = this._createTileAnimationBuffer(buffer);
      this._animationMap.dispose();
      this._animationMap = am;
      this._material.setTexture("animationMap", this._animationMap);
    },
    enumerable: false,
    configurable: true
  });
  SpriteMap2.prototype.getTileID = function() {
    var p = this.getMousePosition();
    p.multiplyInPlace(this.options.stageSize || Vector2.Zero());
    p.x = Math.floor(p.x);
    p.y = Math.floor(p.y);
    return p;
  };
  SpriteMap2.prototype.getMousePosition = function() {
    var out = this._output;
    var pickinfo = this._scene.pick(this._scene.pointerX, this._scene.pointerY, function(mesh) {
      if (mesh !== out) {
        return false;
      }
      return true;
    });
    if (!pickinfo || !pickinfo.hit || !pickinfo.getTextureCoordinates) {
      return new Vector2(-1, -1);
    }
    var coords = pickinfo.getTextureCoordinates();
    if (coords) {
      return coords;
    }
    return new Vector2(-1, -1);
  };
  SpriteMap2.prototype._createFrameBuffer = function() {
    var data = new Array();
    for (var i = 0; i < this.spriteCount; i++) {
      data.push(0, 0, 0, 0);
      data.push(0, 0, 0, 0);
      data.push(0, 0, 0, 0);
      data.push(0, 0, 0, 0);
    }
    for (var i = 0; i < this.spriteCount; i++) {
      var f = this.sprites[i]["frame"];
      var sss = this.sprites[i]["spriteSourceSize"];
      var ss = this.sprites[i]["sourceSize"];
      var r = this.sprites[i]["rotated"] ? 1 : 0;
      var t_1 = this.sprites[i]["trimmed"] ? 1 : 0;
      data[i * 4] = f.x;
      data[i * 4 + 1] = f.y;
      data[i * 4 + 2] = f.w;
      data[i * 4 + 3] = f.h;
      data[i * 4 + this.spriteCount * 4] = sss.x;
      data[i * 4 + 1 + this.spriteCount * 4] = sss.y;
      data[i * 4 + 3 + this.spriteCount * 4] = sss.h;
      data[i * 4 + this.spriteCount * 8] = ss.w;
      data[i * 4 + 1 + this.spriteCount * 8] = ss.h;
      data[i * 4 + 2 + this.spriteCount * 8] = r;
      data[i * 4 + 3 + this.spriteCount * 8] = t_1;
    }
    var floatArray = new Float32Array(data);
    var t = RawTexture.CreateRGBATexture(floatArray, this.spriteCount, 4, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);
    return t;
  };
  SpriteMap2.prototype._createTileBuffer = function(buffer, _layer) {
    if (_layer === void 0) {
      _layer = 0;
    }
    var data = new Array();
    var _ty = this.options.stageSize.y || 0;
    var _tx = this.options.stageSize.x || 0;
    if (!buffer) {
      var bt = this.options.baseTile;
      if (_layer != 0) {
        bt = 0;
      }
      for (var y = 0; y < _ty; y++) {
        for (var x = 0; x < _tx * 4; x += 4) {
          data.push(bt, 0, 0, 0);
        }
      }
    } else {
      data = buffer;
    }
    var floatArray = new Float32Array(data);
    var t = RawTexture.CreateRGBATexture(floatArray, _tx, _ty, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);
    return t;
  };
  SpriteMap2.prototype.changeTiles = function(_layer, pos, tile) {
    if (_layer === void 0) {
      _layer = 0;
    }
    if (tile === void 0) {
      tile = 0;
    }
    var buffer;
    buffer = this._tileMaps[_layer]._texture._bufferView;
    if (buffer === null) {
      return;
    }
    var p = new Array();
    if (pos instanceof Vector2) {
      p.push(pos);
    } else {
      p = pos;
    }
    var _tx = this.options.stageSize.x || 0;
    for (var i = 0; i < p.length; i++) {
      var _p = p[i];
      _p.x = Math.floor(_p.x);
      _p.y = Math.floor(_p.y);
      var id = _p.x * 4 + _p.y * (_tx * 4);
      buffer[id] = tile;
    }
    var t = this._createTileBuffer(buffer);
    this._tileMaps[_layer].dispose();
    this._tileMaps[_layer] = t;
    this._material.setTextureArray("tileMap", this._tileMaps);
  };
  SpriteMap2.prototype._createTileAnimationBuffer = function(buffer) {
    var data = new Array();
    var floatArray;
    if (!buffer) {
      for (var i = 0; i < this.spriteCount; i++) {
        data.push(0, 0, 0, 0);
        var count = 1;
        while (count < (this.options.maxAnimationFrames || 4)) {
          data.push(0, 0, 0, 0);
          count++;
        }
      }
      floatArray = new Float32Array(data);
    } else {
      floatArray = buffer;
    }
    var t = RawTexture.CreateRGBATexture(floatArray, this.spriteCount, this.options.maxAnimationFrames || 4, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);
    return t;
  };
  SpriteMap2.prototype.addAnimationToTile = function(cellID, _frame, toCell, time, speed) {
    if (cellID === void 0) {
      cellID = 0;
    }
    if (_frame === void 0) {
      _frame = 0;
    }
    if (toCell === void 0) {
      toCell = 0;
    }
    if (time === void 0) {
      time = 0;
    }
    if (speed === void 0) {
      speed = 1;
    }
    var buffer = this._animationMap._texture._bufferView;
    var id = cellID * 4 + this.spriteCount * 4 * _frame;
    if (!buffer) {
      return;
    }
    buffer[id] = toCell;
    buffer[id + 1] = time;
    buffer[id + 2] = speed;
    var t = this._createTileAnimationBuffer(buffer);
    this._animationMap.dispose();
    this._animationMap = t;
    this._material.setTexture("animationMap", this._animationMap);
  };
  SpriteMap2.prototype.saveTileMaps = function() {
    var maps = "";
    for (var i = 0; i < this._tileMaps.length; i++) {
      if (i > 0) {
        maps += "\n\r";
      }
      maps += this._tileMaps[i]._texture._bufferView.toString();
    }
    var hiddenElement = document.createElement("a");
    hiddenElement.href = "data:octet/stream;charset=utf-8," + encodeURI(maps);
    hiddenElement.target = "_blank";
    hiddenElement.download = this.name + ".tilemaps";
    hiddenElement.click();
    hiddenElement.remove();
  };
  SpriteMap2.prototype.loadTileMaps = function(url) {
    var _this = this;
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    var _lc = this.options.layerCount || 0;
    xhr.onload = function() {
      var data = xhr.response.split("\n\r");
      for (var i = 0; i < _lc; i++) {
        var d = data[i].split(",").map(Number);
        var t = _this._createTileBuffer(d);
        _this._tileMaps[i].dispose();
        _this._tileMaps[i] = t;
      }
      _this._material.setTextureArray("tileMap", _this._tileMaps);
    };
    xhr.send();
  };
  SpriteMap2.prototype.dispose = function() {
    this._output.dispose();
    this._material.dispose();
    this._animationMap.dispose();
    this._tileMaps.forEach(function(tm) {
      tm.dispose();
    });
    this._frameMap.dispose();
  };
  return SpriteMap2;
}();

// node_modules/@babylonjs/core/Sprites/spritePackedManager.js
var SpritePackedManager = function(_super) {
  __extends(SpritePackedManager2, _super);
  function SpritePackedManager2(name98, imgUrl, capacity, scene, spriteJSON, epsilon, samplingMode) {
    if (spriteJSON === void 0) {
      spriteJSON = null;
    }
    if (epsilon === void 0) {
      epsilon = 0.01;
    }
    if (samplingMode === void 0) {
      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;
    }
    var _this = _super.call(this, name98, imgUrl, capacity, 64, scene, epsilon, samplingMode, true, spriteJSON) || this;
    _this.name = name98;
    return _this;
  }
  return SpritePackedManager2;
}(SpriteManager);

// node_modules/@babylonjs/core/Misc/assetsManager.js
var AssetTaskState;
(function(AssetTaskState2) {
  AssetTaskState2[AssetTaskState2["INIT"] = 0] = "INIT";
  AssetTaskState2[AssetTaskState2["RUNNING"] = 1] = "RUNNING";
  AssetTaskState2[AssetTaskState2["DONE"] = 2] = "DONE";
  AssetTaskState2[AssetTaskState2["ERROR"] = 3] = "ERROR";
})(AssetTaskState || (AssetTaskState = {}));
var AbstractAssetTask = function() {
  function AbstractAssetTask2(name98) {
    this.name = name98;
    this._isCompleted = false;
    this._taskState = AssetTaskState.INIT;
  }
  Object.defineProperty(AbstractAssetTask2.prototype, "isCompleted", {
    get: function() {
      return this._isCompleted;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractAssetTask2.prototype, "taskState", {
    get: function() {
      return this._taskState;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractAssetTask2.prototype, "errorObject", {
    get: function() {
      return this._errorObject;
    },
    enumerable: false,
    configurable: true
  });
  AbstractAssetTask2.prototype._setErrorObject = function(message, exception) {
    if (this._errorObject) {
      return;
    }
    this._errorObject = {
      message,
      exception
    };
  };
  AbstractAssetTask2.prototype.run = function(scene, onSuccess, onError) {
    var _this = this;
    this._taskState = AssetTaskState.RUNNING;
    this.runTask(scene, function() {
      _this.onDoneCallback(onSuccess, onError);
    }, function(msg, exception) {
      _this.onErrorCallback(onError, msg, exception);
    });
  };
  AbstractAssetTask2.prototype.runTask = function(scene, onSuccess, onError) {
    throw new Error("runTask is not implemented");
  };
  AbstractAssetTask2.prototype.reset = function() {
    this._taskState = AssetTaskState.INIT;
  };
  AbstractAssetTask2.prototype.onErrorCallback = function(onError, message, exception) {
    this._taskState = AssetTaskState.ERROR;
    this._errorObject = {
      message,
      exception
    };
    if (this.onError) {
      this.onError(this, message, exception);
    }
    onError();
  };
  AbstractAssetTask2.prototype.onDoneCallback = function(onSuccess, onError) {
    try {
      this._taskState = AssetTaskState.DONE;
      this._isCompleted = true;
      if (this.onSuccess) {
        this.onSuccess(this);
      }
      onSuccess();
    } catch (e) {
      this.onErrorCallback(onError, "Task is done, error executing success callback(s)", e);
    }
  };
  return AbstractAssetTask2;
}();
var AssetsProgressEvent = function() {
  function AssetsProgressEvent2(remainingCount, totalCount, task) {
    this.remainingCount = remainingCount;
    this.totalCount = totalCount;
    this.task = task;
  }
  return AssetsProgressEvent2;
}();
var ContainerAssetTask = function(_super) {
  __extends(ContainerAssetTask2, _super);
  function ContainerAssetTask2(name98, meshesNames, rootUrl, sceneFilename) {
    var _this = _super.call(this, name98) || this;
    _this.name = name98;
    _this.meshesNames = meshesNames;
    _this.rootUrl = rootUrl;
    _this.sceneFilename = sceneFilename;
    return _this;
  }
  ContainerAssetTask2.prototype.runTask = function(scene, onSuccess, onError) {
    var _this = this;
    SceneLoader.LoadAssetContainer(this.rootUrl, this.sceneFilename, scene, function(container) {
      _this.loadedContainer = container;
      _this.loadedMeshes = container.meshes;
      _this.loadedParticleSystems = container.particleSystems;
      _this.loadedSkeletons = container.skeletons;
      _this.loadedAnimationGroups = container.animationGroups;
      onSuccess();
    }, null, function(scene2, message, exception) {
      onError(message, exception);
    });
  };
  return ContainerAssetTask2;
}(AbstractAssetTask);
var MeshAssetTask = function(_super) {
  __extends(MeshAssetTask2, _super);
  function MeshAssetTask2(name98, meshesNames, rootUrl, sceneFilename) {
    var _this = _super.call(this, name98) || this;
    _this.name = name98;
    _this.meshesNames = meshesNames;
    _this.rootUrl = rootUrl;
    _this.sceneFilename = sceneFilename;
    return _this;
  }
  MeshAssetTask2.prototype.runTask = function(scene, onSuccess, onError) {
    var _this = this;
    SceneLoader.ImportMesh(this.meshesNames, this.rootUrl, this.sceneFilename, scene, function(meshes, particleSystems, skeletons, animationGroups) {
      _this.loadedMeshes = meshes;
      _this.loadedParticleSystems = particleSystems;
      _this.loadedSkeletons = skeletons;
      _this.loadedAnimationGroups = animationGroups;
      onSuccess();
    }, null, function(scene2, message, exception) {
      onError(message, exception);
    });
  };
  return MeshAssetTask2;
}(AbstractAssetTask);
var TextFileAssetTask = function(_super) {
  __extends(TextFileAssetTask2, _super);
  function TextFileAssetTask2(name98, url) {
    var _this = _super.call(this, name98) || this;
    _this.name = name98;
    _this.url = url;
    return _this;
  }
  TextFileAssetTask2.prototype.runTask = function(scene, onSuccess, onError) {
    var _this = this;
    scene._loadFile(this.url, function(data) {
      _this.text = data;
      onSuccess();
    }, void 0, false, false, function(request, exception) {
      if (request) {
        onError(request.status + " " + request.statusText, exception);
      }
    });
  };
  return TextFileAssetTask2;
}(AbstractAssetTask);
var BinaryFileAssetTask = function(_super) {
  __extends(BinaryFileAssetTask2, _super);
  function BinaryFileAssetTask2(name98, url) {
    var _this = _super.call(this, name98) || this;
    _this.name = name98;
    _this.url = url;
    return _this;
  }
  BinaryFileAssetTask2.prototype.runTask = function(scene, onSuccess, onError) {
    var _this = this;
    scene._loadFile(this.url, function(data) {
      _this.data = data;
      onSuccess();
    }, void 0, true, true, function(request, exception) {
      if (request) {
        onError(request.status + " " + request.statusText, exception);
      }
    });
  };
  return BinaryFileAssetTask2;
}(AbstractAssetTask);
var ImageAssetTask = function(_super) {
  __extends(ImageAssetTask2, _super);
  function ImageAssetTask2(name98, url) {
    var _this = _super.call(this, name98) || this;
    _this.name = name98;
    _this.url = url;
    return _this;
  }
  ImageAssetTask2.prototype.runTask = function(scene, onSuccess, onError) {
    var _this = this;
    var img = new Image();
    Tools.SetCorsBehavior(this.url, img);
    img.onload = function() {
      _this.image = img;
      onSuccess();
    };
    img.onerror = function(err) {
      onError("Error loading image", err);
    };
    img.src = this.url;
  };
  return ImageAssetTask2;
}(AbstractAssetTask);
var TextureAssetTask = function(_super) {
  __extends(TextureAssetTask2, _super);
  function TextureAssetTask2(name98, url, noMipmap, invertY, samplingMode) {
    if (invertY === void 0) {
      invertY = true;
    }
    if (samplingMode === void 0) {
      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;
    }
    var _this = _super.call(this, name98) || this;
    _this.name = name98;
    _this.url = url;
    _this.noMipmap = noMipmap;
    _this.invertY = invertY;
    _this.samplingMode = samplingMode;
    return _this;
  }
  TextureAssetTask2.prototype.runTask = function(scene, onSuccess, onError) {
    var onload = function() {
      onSuccess();
    };
    var onerror = function(message, exception) {
      onError(message, exception);
    };
    this.texture = new Texture(this.url, scene, this.noMipmap, this.invertY, this.samplingMode, onload, onerror);
  };
  return TextureAssetTask2;
}(AbstractAssetTask);
var CubeTextureAssetTask = function(_super) {
  __extends(CubeTextureAssetTask2, _super);
  function CubeTextureAssetTask2(name98, url, extensions, noMipmap, files) {
    var _this = _super.call(this, name98) || this;
    _this.name = name98;
    _this.url = url;
    _this.extensions = extensions;
    _this.noMipmap = noMipmap;
    _this.files = files;
    return _this;
  }
  CubeTextureAssetTask2.prototype.runTask = function(scene, onSuccess, onError) {
    var onload = function() {
      onSuccess();
    };
    var onerror = function(message, exception) {
      onError(message, exception);
    };
    this.texture = new CubeTexture(this.url, scene, this.extensions, this.noMipmap, this.files, onload, onerror);
  };
  return CubeTextureAssetTask2;
}(AbstractAssetTask);
var HDRCubeTextureAssetTask = function(_super) {
  __extends(HDRCubeTextureAssetTask2, _super);
  function HDRCubeTextureAssetTask2(name98, url, size, noMipmap, generateHarmonics, gammaSpace, reserved) {
    if (noMipmap === void 0) {
      noMipmap = false;
    }
    if (generateHarmonics === void 0) {
      generateHarmonics = true;
    }
    if (gammaSpace === void 0) {
      gammaSpace = false;
    }
    if (reserved === void 0) {
      reserved = false;
    }
    var _this = _super.call(this, name98) || this;
    _this.name = name98;
    _this.url = url;
    _this.size = size;
    _this.noMipmap = noMipmap;
    _this.generateHarmonics = generateHarmonics;
    _this.gammaSpace = gammaSpace;
    _this.reserved = reserved;
    return _this;
  }
  HDRCubeTextureAssetTask2.prototype.runTask = function(scene, onSuccess, onError) {
    var onload = function() {
      onSuccess();
    };
    var onerror = function(message, exception) {
      onError(message, exception);
    };
    this.texture = new HDRCubeTexture(this.url, scene, this.size, this.noMipmap, this.generateHarmonics, this.gammaSpace, this.reserved, onload, onerror);
  };
  return HDRCubeTextureAssetTask2;
}(AbstractAssetTask);
var EquiRectangularCubeTextureAssetTask = function(_super) {
  __extends(EquiRectangularCubeTextureAssetTask2, _super);
  function EquiRectangularCubeTextureAssetTask2(name98, url, size, noMipmap, gammaSpace) {
    if (noMipmap === void 0) {
      noMipmap = false;
    }
    if (gammaSpace === void 0) {
      gammaSpace = true;
    }
    var _this = _super.call(this, name98) || this;
    _this.name = name98;
    _this.url = url;
    _this.size = size;
    _this.noMipmap = noMipmap;
    _this.gammaSpace = gammaSpace;
    return _this;
  }
  EquiRectangularCubeTextureAssetTask2.prototype.runTask = function(scene, onSuccess, onError) {
    var onload = function() {
      onSuccess();
    };
    var onerror = function(message, exception) {
      onError(message, exception);
    };
    this.texture = new EquiRectangularCubeTexture(this.url, scene, this.size, this.noMipmap, this.gammaSpace, onload, onerror);
  };
  return EquiRectangularCubeTextureAssetTask2;
}(AbstractAssetTask);
var AssetsManager = function() {
  function AssetsManager2(scene) {
    this._isLoading = false;
    this._tasks = new Array();
    this._waitingTasksCount = 0;
    this._totalTasksCount = 0;
    this.onTaskSuccessObservable = new Observable();
    this.onTaskErrorObservable = new Observable();
    this.onTasksDoneObservable = new Observable();
    this.onProgressObservable = new Observable();
    this.useDefaultLoadingScreen = true;
    this.autoHideLoadingUI = true;
    this._scene = scene;
  }
  AssetsManager2.prototype.addContainerTask = function(taskName, meshesNames, rootUrl, sceneFilename) {
    var task = new ContainerAssetTask(taskName, meshesNames, rootUrl, sceneFilename);
    this._tasks.push(task);
    return task;
  };
  AssetsManager2.prototype.addMeshTask = function(taskName, meshesNames, rootUrl, sceneFilename) {
    var task = new MeshAssetTask(taskName, meshesNames, rootUrl, sceneFilename);
    this._tasks.push(task);
    return task;
  };
  AssetsManager2.prototype.addTextFileTask = function(taskName, url) {
    var task = new TextFileAssetTask(taskName, url);
    this._tasks.push(task);
    return task;
  };
  AssetsManager2.prototype.addBinaryFileTask = function(taskName, url) {
    var task = new BinaryFileAssetTask(taskName, url);
    this._tasks.push(task);
    return task;
  };
  AssetsManager2.prototype.addImageTask = function(taskName, url) {
    var task = new ImageAssetTask(taskName, url);
    this._tasks.push(task);
    return task;
  };
  AssetsManager2.prototype.addTextureTask = function(taskName, url, noMipmap, invertY, samplingMode) {
    if (samplingMode === void 0) {
      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;
    }
    var task = new TextureAssetTask(taskName, url, noMipmap, invertY, samplingMode);
    this._tasks.push(task);
    return task;
  };
  AssetsManager2.prototype.addCubeTextureTask = function(taskName, url, extensions, noMipmap, files) {
    var task = new CubeTextureAssetTask(taskName, url, extensions, noMipmap, files);
    this._tasks.push(task);
    return task;
  };
  AssetsManager2.prototype.addHDRCubeTextureTask = function(taskName, url, size, noMipmap, generateHarmonics, gammaSpace, reserved) {
    if (noMipmap === void 0) {
      noMipmap = false;
    }
    if (generateHarmonics === void 0) {
      generateHarmonics = true;
    }
    if (gammaSpace === void 0) {
      gammaSpace = false;
    }
    if (reserved === void 0) {
      reserved = false;
    }
    var task = new HDRCubeTextureAssetTask(taskName, url, size, noMipmap, generateHarmonics, gammaSpace, reserved);
    this._tasks.push(task);
    return task;
  };
  AssetsManager2.prototype.addEquiRectangularCubeTextureAssetTask = function(taskName, url, size, noMipmap, gammaSpace) {
    if (noMipmap === void 0) {
      noMipmap = false;
    }
    if (gammaSpace === void 0) {
      gammaSpace = true;
    }
    var task = new EquiRectangularCubeTextureAssetTask(taskName, url, size, noMipmap, gammaSpace);
    this._tasks.push(task);
    return task;
  };
  AssetsManager2.prototype.removeTask = function(task) {
    var index = this._tasks.indexOf(task);
    if (index > -1) {
      this._tasks.splice(index, 1);
    }
  };
  AssetsManager2.prototype._decreaseWaitingTasksCount = function(task) {
    this._waitingTasksCount--;
    try {
      if (this.onProgress) {
        this.onProgress(this._waitingTasksCount, this._totalTasksCount, task);
      }
      this.onProgressObservable.notifyObservers(new AssetsProgressEvent(this._waitingTasksCount, this._totalTasksCount, task));
    } catch (e) {
      Logger.Error("Error running progress callbacks.");
      console.log(e);
    }
    if (this._waitingTasksCount === 0) {
      try {
        var currentTasks = this._tasks.slice();
        if (this.onFinish) {
          this.onFinish(currentTasks);
        }
        for (var _i = 0, currentTasks_1 = currentTasks; _i < currentTasks_1.length; _i++) {
          var task = currentTasks_1[_i];
          if (task.taskState === AssetTaskState.DONE) {
            var index = this._tasks.indexOf(task);
            if (index > -1) {
              this._tasks.splice(index, 1);
            }
          }
        }
        this.onTasksDoneObservable.notifyObservers(this._tasks);
      } catch (e) {
        Logger.Error("Error running tasks-done callbacks.");
        console.log(e);
      }
      this._isLoading = false;
      if (this.autoHideLoadingUI) {
        this._scene.getEngine().hideLoadingUI();
      }
    }
  };
  AssetsManager2.prototype._runTask = function(task) {
    var _this = this;
    var done = function() {
      try {
        if (_this.onTaskSuccess) {
          _this.onTaskSuccess(task);
        }
        _this.onTaskSuccessObservable.notifyObservers(task);
        _this._decreaseWaitingTasksCount(task);
      } catch (e) {
        error("Error executing task success callbacks", e);
      }
    };
    var error = function(message, exception) {
      task._setErrorObject(message, exception);
      if (_this.onTaskError) {
        _this.onTaskError(task);
      }
      _this.onTaskErrorObservable.notifyObservers(task);
      _this._decreaseWaitingTasksCount(task);
    };
    task.run(this._scene, done, error);
  };
  AssetsManager2.prototype.reset = function() {
    this._isLoading = false;
    this._tasks = new Array();
    return this;
  };
  AssetsManager2.prototype.load = function() {
    if (this._isLoading) {
      return this;
    }
    this._isLoading = true;
    this._waitingTasksCount = this._tasks.length;
    this._totalTasksCount = this._tasks.length;
    if (this._waitingTasksCount === 0) {
      this._isLoading = false;
      if (this.onFinish) {
        this.onFinish(this._tasks);
      }
      this.onTasksDoneObservable.notifyObservers(this._tasks);
      return this;
    }
    if (this.useDefaultLoadingScreen) {
      this._scene.getEngine().displayLoadingUI();
    }
    for (var index = 0; index < this._tasks.length; index++) {
      var task = this._tasks[index];
      if (task.taskState === AssetTaskState.INIT) {
        this._runTask(task);
      }
    }
    return this;
  };
  AssetsManager2.prototype.loadAsync = function() {
    var _this = this;
    return new Promise(function(resolve, reject) {
      if (_this._isLoading) {
        resolve();
        return;
      }
      _this.onTasksDoneObservable.addOnce(function(remainingTasks) {
        if (remainingTasks && remainingTasks.length) {
          reject(remainingTasks);
        } else {
          resolve();
        }
      });
      _this.load();
    });
  };
  return AssetsManager2;
}();

// node_modules/@babylonjs/core/Misc/meshExploder.js
var MeshExploder = function() {
  function MeshExploder2(meshes, centerMesh) {
    this._meshesOrigins = [];
    this._toCenterVectors = [];
    this._scaledDirection = Vector3.Zero();
    this._newPosition = Vector3.Zero();
    this._centerPosition = Vector3.Zero();
    this._meshes = meshes.slice();
    if (centerMesh) {
      this._centerMesh = centerMesh;
    } else {
      this._setCenterMesh();
    }
    var centerMeshIndex = this._meshes.indexOf(this._centerMesh);
    if (centerMeshIndex >= 0) {
      this._meshes.splice(centerMeshIndex, 1);
    }
    this._centerPosition = this._centerMesh.getAbsolutePosition().clone();
    for (var index = 0; index < this._meshes.length; index++) {
      if (this._meshes[index]) {
        var mesh = this._meshes[index];
        this._meshesOrigins[index] = mesh.getAbsolutePosition().clone();
        this._toCenterVectors[index] = Vector3.Zero();
        if (mesh._boundingInfo && this._centerMesh._boundingInfo) {
          mesh._boundingInfo.boundingBox.centerWorld.subtractToRef(this._centerMesh._boundingInfo.boundingBox.centerWorld, this._toCenterVectors[index]);
        }
      }
    }
  }
  MeshExploder2.prototype._setCenterMesh = function() {
    var averageCenter = Vector3.Zero();
    var totalCenters = Vector3.Zero();
    var shortestToCenter = Number.MAX_VALUE;
    for (var index = 0; index < this._meshes.length; index++) {
      if (this._meshes[index]) {
        var mesh = this._meshes[index];
        var boundingInfo = mesh.getBoundingInfo();
        if (boundingInfo) {
          totalCenters.addInPlace(boundingInfo.boundingBox.centerWorld);
        }
      }
    }
    averageCenter = totalCenters.scale(1 / this._meshes.length);
    for (var index = 0; index < this._meshes.length; index++) {
      if (this._meshes[index]) {
        var mesh = this._meshes[index];
        var boundingInfo = mesh.getBoundingInfo();
        if (boundingInfo) {
          var distanceToCenter = boundingInfo.boundingBox.centerWorld.subtract(averageCenter).lengthSquared();
          if (distanceToCenter < shortestToCenter) {
            this._centerMesh = mesh;
            shortestToCenter = distanceToCenter;
          }
        }
      }
    }
  };
  MeshExploder2.prototype.getClassName = function() {
    return "MeshExploder";
  };
  MeshExploder2.prototype.getMeshes = function() {
    var meshArray = this._meshes.slice();
    meshArray.unshift(this._centerMesh);
    return meshArray;
  };
  MeshExploder2.prototype.explode = function(direction) {
    if (direction === void 0) {
      direction = 1;
    }
    for (var index = 0; index < this._meshes.length; index++) {
      if (this._meshes[index] && this._meshesOrigins[index] && this._toCenterVectors[index]) {
        this._toCenterVectors[index].scaleToRef(direction, this._scaledDirection);
        this._meshesOrigins[index].addToRef(this._scaledDirection, this._newPosition);
        this._meshes[index].setAbsolutePosition(this._newPosition);
      }
    }
    this._centerMesh.setAbsolutePosition(this._centerPosition);
  };
  return MeshExploder2;
}();

// node_modules/@babylonjs/core/Misc/filesInput.js
var FilesInput = function() {
  function FilesInput2(engine, scene, sceneLoadedCallback, progressCallback, additionalRenderLoopLogicCallback, textureLoadingCallback, startingProcessingFilesCallback, onReloadCallback, errorCallback) {
    this.onProcessFileCallback = function() {
      return true;
    };
    this._engine = engine;
    this._currentScene = scene;
    this._sceneLoadedCallback = sceneLoadedCallback;
    this._progressCallback = progressCallback;
    this._additionalRenderLoopLogicCallback = additionalRenderLoopLogicCallback;
    this._textureLoadingCallback = textureLoadingCallback;
    this._startingProcessingFilesCallback = startingProcessingFilesCallback;
    this._onReloadCallback = onReloadCallback;
    this._errorCallback = errorCallback;
  }
  Object.defineProperty(FilesInput2, "FilesToLoad", {
    get: function() {
      return FilesInputStore.FilesToLoad;
    },
    enumerable: false,
    configurable: true
  });
  FilesInput2.prototype.monitorElementForDragNDrop = function(elementToMonitor) {
    var _this = this;
    if (elementToMonitor) {
      this._elementToMonitor = elementToMonitor;
      this._dragEnterHandler = function(e) {
        _this.drag(e);
      };
      this._dragOverHandler = function(e) {
        _this.drag(e);
      };
      this._dropHandler = function(e) {
        _this.drop(e);
      };
      this._elementToMonitor.addEventListener("dragenter", this._dragEnterHandler, false);
      this._elementToMonitor.addEventListener("dragover", this._dragOverHandler, false);
      this._elementToMonitor.addEventListener("drop", this._dropHandler, false);
    }
  };
  Object.defineProperty(FilesInput2.prototype, "filesToLoad", {
    get: function() {
      return this._filesToLoad;
    },
    enumerable: false,
    configurable: true
  });
  FilesInput2.prototype.dispose = function() {
    if (!this._elementToMonitor) {
      return;
    }
    this._elementToMonitor.removeEventListener("dragenter", this._dragEnterHandler);
    this._elementToMonitor.removeEventListener("dragover", this._dragOverHandler);
    this._elementToMonitor.removeEventListener("drop", this._dropHandler);
  };
  FilesInput2.prototype.renderFunction = function() {
    if (this._additionalRenderLoopLogicCallback) {
      this._additionalRenderLoopLogicCallback();
    }
    if (this._currentScene) {
      if (this._textureLoadingCallback) {
        var remaining = this._currentScene.getWaitingItemsCount();
        if (remaining > 0) {
          this._textureLoadingCallback(remaining);
        }
      }
      this._currentScene.render();
    }
  };
  FilesInput2.prototype.drag = function(e) {
    e.stopPropagation();
    e.preventDefault();
  };
  FilesInput2.prototype.drop = function(eventDrop) {
    eventDrop.stopPropagation();
    eventDrop.preventDefault();
    this.loadFiles(eventDrop);
  };
  FilesInput2.prototype._traverseFolder = function(folder, files, remaining, callback) {
    var _this = this;
    var reader = folder.createReader();
    var relativePath = folder.fullPath.replace(/^\//, "").replace(/(.+?)\/?$/, "$1/");
    reader.readEntries(function(entries) {
      remaining.count += entries.length;
      for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
        var entry = entries_1[_i];
        if (entry.isFile) {
          entry.file(function(file) {
            file.correctName = relativePath + file.name;
            files.push(file);
            if (--remaining.count === 0) {
              callback();
            }
          });
        } else if (entry.isDirectory) {
          _this._traverseFolder(entry, files, remaining, callback);
        }
      }
      if (--remaining.count === 0) {
        callback();
      }
    });
  };
  FilesInput2.prototype._processFiles = function(files) {
    for (var i = 0; i < files.length; i++) {
      var name98 = files[i].correctName.toLowerCase();
      var extension = name98.split(".").pop();
      if (!this.onProcessFileCallback(files[i], name98, extension)) {
        continue;
      }
      if (SceneLoader.IsPluginForExtensionAvailable("." + extension)) {
        this._sceneFileToLoad = files[i];
      }
      FilesInput2.FilesToLoad[name98] = files[i];
    }
  };
  FilesInput2.prototype.loadFiles = function(event) {
    var _this = this;
    if (event && event.dataTransfer && event.dataTransfer.files) {
      this._filesToLoad = event.dataTransfer.files;
    }
    if (event && event.target && event.target.files) {
      this._filesToLoad = event.target.files;
    }
    if (!this._filesToLoad || this._filesToLoad.length === 0) {
      return;
    }
    if (this._startingProcessingFilesCallback) {
      this._startingProcessingFilesCallback(this._filesToLoad);
    }
    if (this._filesToLoad && this._filesToLoad.length > 0) {
      var files_1 = new Array();
      var folders = [];
      var items = event.dataTransfer ? event.dataTransfer.items : null;
      for (var i = 0; i < this._filesToLoad.length; i++) {
        var fileToLoad = this._filesToLoad[i];
        var name_1 = fileToLoad.name.toLowerCase();
        var entry = void 0;
        fileToLoad.correctName = name_1;
        if (items) {
          var item = items[i];
          if (item.getAsEntry) {
            entry = item.getAsEntry();
          } else if (item.webkitGetAsEntry) {
            entry = item.webkitGetAsEntry();
          }
        }
        if (!entry) {
          files_1.push(fileToLoad);
        } else {
          if (entry.isDirectory) {
            folders.push(entry);
          } else {
            files_1.push(fileToLoad);
          }
        }
      }
      if (folders.length === 0) {
        this._processFiles(files_1);
        this._processReload();
      } else {
        var remaining = { count: folders.length };
        for (var _i = 0, folders_1 = folders; _i < folders_1.length; _i++) {
          var folder = folders_1[_i];
          this._traverseFolder(folder, files_1, remaining, function() {
            _this._processFiles(files_1);
            if (remaining.count === 0) {
              _this._processReload();
            }
          });
        }
      }
    }
  };
  FilesInput2.prototype._processReload = function() {
    if (this._onReloadCallback) {
      this._onReloadCallback(this._sceneFileToLoad);
    } else {
      this.reload();
    }
  };
  FilesInput2.prototype.reload = function() {
    var _this = this;
    if (this._sceneFileToLoad) {
      if (this._currentScene) {
        if (Logger.errorsCount > 0) {
          Logger.ClearLogCache();
        }
        this._engine.stopRenderLoop();
      }
      SceneLoader.ShowLoadingScreen = false;
      this._engine.displayLoadingUI();
      SceneLoader.LoadAsync("file:", this._sceneFileToLoad, this._engine, function(progress) {
        if (_this._progressCallback) {
          _this._progressCallback(progress);
        }
      }).then(function(scene) {
        if (_this._currentScene) {
          _this._currentScene.dispose();
        }
        _this._currentScene = scene;
        if (_this._sceneLoadedCallback) {
          _this._sceneLoadedCallback(_this._sceneFileToLoad, _this._currentScene);
        }
        _this._currentScene.executeWhenReady(function() {
          _this._engine.hideLoadingUI();
          _this._engine.runRenderLoop(function() {
            _this.renderFunction();
          });
        });
      }).catch(function(error) {
        _this._engine.hideLoadingUI();
        if (_this._errorCallback) {
          _this._errorCallback(_this._sceneFileToLoad, _this._currentScene, error.message);
        }
      });
    } else {
      Logger.Error("Please provide a valid .babylon file.");
    }
  };
  return FilesInput2;
}();

// node_modules/@babylonjs/core/Misc/sceneOptimizer.js
var SceneOptimization = function() {
  function SceneOptimization2(priority) {
    if (priority === void 0) {
      priority = 0;
    }
    this.priority = priority;
  }
  SceneOptimization2.prototype.getDescription = function() {
    return "";
  };
  SceneOptimization2.prototype.apply = function(scene, optimizer) {
    return true;
  };
  return SceneOptimization2;
}();
var TextureOptimization = function(_super) {
  __extends(TextureOptimization2, _super);
  function TextureOptimization2(priority, maximumSize, step) {
    if (priority === void 0) {
      priority = 0;
    }
    if (maximumSize === void 0) {
      maximumSize = 1024;
    }
    if (step === void 0) {
      step = 0.5;
    }
    var _this = _super.call(this, priority) || this;
    _this.priority = priority;
    _this.maximumSize = maximumSize;
    _this.step = step;
    return _this;
  }
  TextureOptimization2.prototype.getDescription = function() {
    return "Reducing render target texture size to " + this.maximumSize;
  };
  TextureOptimization2.prototype.apply = function(scene, optimizer) {
    var allDone = true;
    for (var index = 0; index < scene.textures.length; index++) {
      var texture = scene.textures[index];
      if (!texture.canRescale || texture.getContext) {
        continue;
      }
      var currentSize = texture.getSize();
      var maxDimension = Math.max(currentSize.width, currentSize.height);
      if (maxDimension > this.maximumSize) {
        texture.scale(this.step);
        allDone = false;
      }
    }
    return allDone;
  };
  return TextureOptimization2;
}(SceneOptimization);
var HardwareScalingOptimization = function(_super) {
  __extends(HardwareScalingOptimization2, _super);
  function HardwareScalingOptimization2(priority, maximumScale, step) {
    if (priority === void 0) {
      priority = 0;
    }
    if (maximumScale === void 0) {
      maximumScale = 2;
    }
    if (step === void 0) {
      step = 0.25;
    }
    var _this = _super.call(this, priority) || this;
    _this.priority = priority;
    _this.maximumScale = maximumScale;
    _this.step = step;
    _this._currentScale = -1;
    _this._directionOffset = 1;
    return _this;
  }
  HardwareScalingOptimization2.prototype.getDescription = function() {
    return "Setting hardware scaling level to " + this._currentScale;
  };
  HardwareScalingOptimization2.prototype.apply = function(scene, optimizer) {
    if (this._currentScale === -1) {
      this._currentScale = scene.getEngine().getHardwareScalingLevel();
      if (this._currentScale > this.maximumScale) {
        this._directionOffset = -1;
      }
    }
    this._currentScale += this._directionOffset * this.step;
    scene.getEngine().setHardwareScalingLevel(this._currentScale);
    return this._directionOffset === 1 ? this._currentScale >= this.maximumScale : this._currentScale <= this.maximumScale;
  };
  return HardwareScalingOptimization2;
}(SceneOptimization);
var ShadowsOptimization = function(_super) {
  __extends(ShadowsOptimization2, _super);
  function ShadowsOptimization2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ShadowsOptimization2.prototype.getDescription = function() {
    return "Turning shadows on/off";
  };
  ShadowsOptimization2.prototype.apply = function(scene, optimizer) {
    scene.shadowsEnabled = optimizer.isInImprovementMode;
    return true;
  };
  return ShadowsOptimization2;
}(SceneOptimization);
var PostProcessesOptimization = function(_super) {
  __extends(PostProcessesOptimization2, _super);
  function PostProcessesOptimization2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PostProcessesOptimization2.prototype.getDescription = function() {
    return "Turning post-processes on/off";
  };
  PostProcessesOptimization2.prototype.apply = function(scene, optimizer) {
    scene.postProcessesEnabled = optimizer.isInImprovementMode;
    return true;
  };
  return PostProcessesOptimization2;
}(SceneOptimization);
var LensFlaresOptimization = function(_super) {
  __extends(LensFlaresOptimization2, _super);
  function LensFlaresOptimization2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  LensFlaresOptimization2.prototype.getDescription = function() {
    return "Turning lens flares on/off";
  };
  LensFlaresOptimization2.prototype.apply = function(scene, optimizer) {
    scene.lensFlaresEnabled = optimizer.isInImprovementMode;
    return true;
  };
  return LensFlaresOptimization2;
}(SceneOptimization);
var CustomOptimization = function(_super) {
  __extends(CustomOptimization2, _super);
  function CustomOptimization2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CustomOptimization2.prototype.getDescription = function() {
    if (this.onGetDescription) {
      return this.onGetDescription();
    }
    return "Running user defined callback";
  };
  CustomOptimization2.prototype.apply = function(scene, optimizer) {
    if (this.onApply) {
      return this.onApply(scene, optimizer);
    }
    return true;
  };
  return CustomOptimization2;
}(SceneOptimization);
var ParticlesOptimization = function(_super) {
  __extends(ParticlesOptimization2, _super);
  function ParticlesOptimization2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ParticlesOptimization2.prototype.getDescription = function() {
    return "Turning particles on/off";
  };
  ParticlesOptimization2.prototype.apply = function(scene, optimizer) {
    scene.particlesEnabled = optimizer.isInImprovementMode;
    return true;
  };
  return ParticlesOptimization2;
}(SceneOptimization);
var RenderTargetsOptimization = function(_super) {
  __extends(RenderTargetsOptimization2, _super);
  function RenderTargetsOptimization2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  RenderTargetsOptimization2.prototype.getDescription = function() {
    return "Turning render targets off";
  };
  RenderTargetsOptimization2.prototype.apply = function(scene, optimizer) {
    scene.renderTargetsEnabled = optimizer.isInImprovementMode;
    return true;
  };
  return RenderTargetsOptimization2;
}(SceneOptimization);
var MergeMeshesOptimization = function(_super) {
  __extends(MergeMeshesOptimization2, _super);
  function MergeMeshesOptimization2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._canBeMerged = function(abstractMesh) {
      if (!(abstractMesh instanceof Mesh)) {
        return false;
      }
      var mesh = abstractMesh;
      if (mesh.isDisposed()) {
        return false;
      }
      if (!mesh.isVisible || !mesh.isEnabled()) {
        return false;
      }
      if (mesh.instances.length > 0) {
        return false;
      }
      if (mesh.skeleton || mesh.hasLODLevels) {
        return false;
      }
      return true;
    };
    return _this;
  }
  Object.defineProperty(MergeMeshesOptimization2, "UpdateSelectionTree", {
    get: function() {
      return MergeMeshesOptimization2._UpdateSelectionTree;
    },
    set: function(value) {
      MergeMeshesOptimization2._UpdateSelectionTree = value;
    },
    enumerable: false,
    configurable: true
  });
  MergeMeshesOptimization2.prototype.getDescription = function() {
    return "Merging similar meshes together";
  };
  MergeMeshesOptimization2.prototype.apply = function(scene, optimizer, updateSelectionTree) {
    var globalPool = scene.meshes.slice(0);
    var globalLength = globalPool.length;
    for (var index = 0; index < globalLength; index++) {
      var currentPool = new Array();
      var current = globalPool[index];
      if (!this._canBeMerged(current)) {
        continue;
      }
      currentPool.push(current);
      for (var subIndex = index + 1; subIndex < globalLength; subIndex++) {
        var otherMesh = globalPool[subIndex];
        if (!this._canBeMerged(otherMesh)) {
          continue;
        }
        if (otherMesh.material !== current.material) {
          continue;
        }
        if (otherMesh.checkCollisions !== current.checkCollisions) {
          continue;
        }
        currentPool.push(otherMesh);
        globalLength--;
        globalPool.splice(subIndex, 1);
        subIndex--;
      }
      if (currentPool.length < 2) {
        continue;
      }
      Mesh.MergeMeshes(currentPool, void 0, true);
    }
    var sceneAsAny = scene;
    if (sceneAsAny.createOrUpdateSelectionOctree) {
      if (updateSelectionTree != void 0) {
        if (updateSelectionTree) {
          sceneAsAny.createOrUpdateSelectionOctree();
        }
      } else if (MergeMeshesOptimization2.UpdateSelectionTree) {
        sceneAsAny.createOrUpdateSelectionOctree();
      }
    }
    return true;
  };
  MergeMeshesOptimization2._UpdateSelectionTree = false;
  return MergeMeshesOptimization2;
}(SceneOptimization);
var SceneOptimizerOptions = function() {
  function SceneOptimizerOptions2(targetFrameRate, trackerDuration) {
    if (targetFrameRate === void 0) {
      targetFrameRate = 60;
    }
    if (trackerDuration === void 0) {
      trackerDuration = 2e3;
    }
    this.targetFrameRate = targetFrameRate;
    this.trackerDuration = trackerDuration;
    this.optimizations = new Array();
  }
  SceneOptimizerOptions2.prototype.addOptimization = function(optimization) {
    this.optimizations.push(optimization);
    return this;
  };
  SceneOptimizerOptions2.prototype.addCustomOptimization = function(onApply, onGetDescription, priority) {
    if (priority === void 0) {
      priority = 0;
    }
    var optimization = new CustomOptimization(priority);
    optimization.onApply = onApply;
    optimization.onGetDescription = onGetDescription;
    this.optimizations.push(optimization);
    return this;
  };
  SceneOptimizerOptions2.LowDegradationAllowed = function(targetFrameRate) {
    var result = new SceneOptimizerOptions2(targetFrameRate);
    var priority = 0;
    result.addOptimization(new MergeMeshesOptimization(priority));
    result.addOptimization(new ShadowsOptimization(priority));
    result.addOptimization(new LensFlaresOptimization(priority));
    priority++;
    result.addOptimization(new PostProcessesOptimization(priority));
    result.addOptimization(new ParticlesOptimization(priority));
    priority++;
    result.addOptimization(new TextureOptimization(priority, 1024));
    return result;
  };
  SceneOptimizerOptions2.ModerateDegradationAllowed = function(targetFrameRate) {
    var result = new SceneOptimizerOptions2(targetFrameRate);
    var priority = 0;
    result.addOptimization(new MergeMeshesOptimization(priority));
    result.addOptimization(new ShadowsOptimization(priority));
    result.addOptimization(new LensFlaresOptimization(priority));
    priority++;
    result.addOptimization(new PostProcessesOptimization(priority));
    result.addOptimization(new ParticlesOptimization(priority));
    priority++;
    result.addOptimization(new TextureOptimization(priority, 512));
    priority++;
    result.addOptimization(new RenderTargetsOptimization(priority));
    priority++;
    result.addOptimization(new HardwareScalingOptimization(priority, 2));
    return result;
  };
  SceneOptimizerOptions2.HighDegradationAllowed = function(targetFrameRate) {
    var result = new SceneOptimizerOptions2(targetFrameRate);
    var priority = 0;
    result.addOptimization(new MergeMeshesOptimization(priority));
    result.addOptimization(new ShadowsOptimization(priority));
    result.addOptimization(new LensFlaresOptimization(priority));
    priority++;
    result.addOptimization(new PostProcessesOptimization(priority));
    result.addOptimization(new ParticlesOptimization(priority));
    priority++;
    result.addOptimization(new TextureOptimization(priority, 256));
    priority++;
    result.addOptimization(new RenderTargetsOptimization(priority));
    priority++;
    result.addOptimization(new HardwareScalingOptimization(priority, 4));
    return result;
  };
  return SceneOptimizerOptions2;
}();
var SceneOptimizer = function() {
  function SceneOptimizer2(scene, options, autoGeneratePriorities, improvementMode) {
    var _this = this;
    if (autoGeneratePriorities === void 0) {
      autoGeneratePriorities = true;
    }
    if (improvementMode === void 0) {
      improvementMode = false;
    }
    this._isRunning = false;
    this._currentPriorityLevel = 0;
    this._targetFrameRate = 60;
    this._trackerDuration = 2e3;
    this._currentFrameRate = 0;
    this._improvementMode = false;
    this.onSuccessObservable = new Observable();
    this.onNewOptimizationAppliedObservable = new Observable();
    this.onFailureObservable = new Observable();
    if (!options) {
      this._options = new SceneOptimizerOptions();
    } else {
      this._options = options;
    }
    if (this._options.targetFrameRate) {
      this._targetFrameRate = this._options.targetFrameRate;
    }
    if (this._options.trackerDuration) {
      this._trackerDuration = this._options.trackerDuration;
    }
    if (autoGeneratePriorities) {
      var priority = 0;
      for (var _i = 0, _a = this._options.optimizations; _i < _a.length; _i++) {
        var optim = _a[_i];
        optim.priority = priority++;
      }
    }
    this._improvementMode = improvementMode;
    this._scene = scene || EngineStore.LastCreatedScene;
    this._sceneDisposeObserver = this._scene.onDisposeObservable.add(function() {
      _this._sceneDisposeObserver = null;
      _this.dispose();
    });
  }
  Object.defineProperty(SceneOptimizer2.prototype, "isInImprovementMode", {
    get: function() {
      return this._improvementMode;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneOptimizer2.prototype, "currentPriorityLevel", {
    get: function() {
      return this._currentPriorityLevel;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneOptimizer2.prototype, "currentFrameRate", {
    get: function() {
      return this._currentFrameRate;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneOptimizer2.prototype, "targetFrameRate", {
    get: function() {
      return this._targetFrameRate;
    },
    set: function(value) {
      this._targetFrameRate = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneOptimizer2.prototype, "trackerDuration", {
    get: function() {
      return this._trackerDuration;
    },
    set: function(value) {
      this._trackerDuration = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneOptimizer2.prototype, "optimizations", {
    get: function() {
      return this._options.optimizations;
    },
    enumerable: false,
    configurable: true
  });
  SceneOptimizer2.prototype.stop = function() {
    this._isRunning = false;
  };
  SceneOptimizer2.prototype.reset = function() {
    this._currentPriorityLevel = 0;
  };
  SceneOptimizer2.prototype.start = function() {
    var _this = this;
    if (this._isRunning) {
      return;
    }
    this._isRunning = true;
    this._scene.executeWhenReady(function() {
      setTimeout(function() {
        _this._checkCurrentState();
      }, _this._trackerDuration);
    });
  };
  SceneOptimizer2.prototype._checkCurrentState = function() {
    var _this = this;
    if (!this._isRunning) {
      return;
    }
    var scene = this._scene;
    var options = this._options;
    this._currentFrameRate = Math.round(scene.getEngine().getFps());
    if (this._improvementMode && this._currentFrameRate <= this._targetFrameRate || !this._improvementMode && this._currentFrameRate >= this._targetFrameRate) {
      this._isRunning = false;
      this.onSuccessObservable.notifyObservers(this);
      return;
    }
    var allDone = true;
    var noOptimizationApplied = true;
    for (var index = 0; index < options.optimizations.length; index++) {
      var optimization = options.optimizations[index];
      if (optimization.priority === this._currentPriorityLevel) {
        noOptimizationApplied = false;
        allDone = allDone && optimization.apply(scene, this);
        this.onNewOptimizationAppliedObservable.notifyObservers(optimization);
      }
    }
    if (noOptimizationApplied) {
      this._isRunning = false;
      this.onFailureObservable.notifyObservers(this);
      return;
    }
    if (allDone) {
      this._currentPriorityLevel++;
    }
    scene.executeWhenReady(function() {
      setTimeout(function() {
        _this._checkCurrentState();
      }, _this._trackerDuration);
    });
  };
  SceneOptimizer2.prototype.dispose = function() {
    this.stop();
    this.onSuccessObservable.clear();
    this.onFailureObservable.clear();
    this.onNewOptimizationAppliedObservable.clear();
    if (this._sceneDisposeObserver) {
      this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);
    }
  };
  SceneOptimizer2.OptimizeAsync = function(scene, options, onSuccess, onFailure) {
    var optimizer = new SceneOptimizer2(scene, options || SceneOptimizerOptions.ModerateDegradationAllowed(), false);
    if (onSuccess) {
      optimizer.onSuccessObservable.add(function() {
        onSuccess();
      });
    }
    if (onFailure) {
      optimizer.onFailureObservable.add(function() {
        onFailure();
      });
    }
    optimizer.start();
    return optimizer;
  };
  return SceneOptimizer2;
}();

// node_modules/@babylonjs/core/Misc/sceneSerializer.js
var serializedGeometries = [];
var serializeGeometry = function(geometry, serializationGeometries) {
  if (serializedGeometries[geometry.id]) {
    return;
  }
  if (geometry.doNotSerialize) {
    return;
  }
  serializationGeometries.vertexData.push(geometry.serializeVerticeData());
  serializedGeometries[geometry.id] = true;
};
var serializeMesh = function(mesh, serializationScene) {
  var serializationObject = {};
  var geometry = mesh._geometry;
  if (geometry) {
    if (!mesh.getScene().getGeometryByID(geometry.id)) {
      serializeGeometry(geometry, serializationScene.geometries);
    }
  }
  if (mesh.serialize) {
    mesh.serialize(serializationObject);
  }
  return serializationObject;
};
var finalizeSingleMesh = function(mesh, serializationObject) {
  if (mesh.delayLoadState === 1 || mesh.delayLoadState === 0) {
    if (mesh.material && !mesh.material.doNotSerialize) {
      if (mesh.material instanceof MultiMaterial) {
        serializationObject.multiMaterials = serializationObject.multiMaterials || [];
        serializationObject.materials = serializationObject.materials || [];
        if (!serializationObject.multiMaterials.some(function(mat) {
          return mat.id === mesh.material.id;
        })) {
          serializationObject.multiMaterials.push(mesh.material.serialize());
          var _loop_1 = function(submaterial2) {
            if (submaterial2) {
              if (!serializationObject.materials.some(function(mat) {
                return mat.id === submaterial2.id;
              })) {
                serializationObject.materials.push(submaterial2.serialize());
              }
            }
          };
          for (var _i = 0, _a = mesh.material.subMaterials; _i < _a.length; _i++) {
            var submaterial = _a[_i];
            _loop_1(submaterial);
          }
        }
      } else {
        serializationObject.materials = serializationObject.materials || [];
        if (!serializationObject.materials.some(function(mat) {
          return mat.id === mesh.material.id;
        })) {
          serializationObject.materials.push(mesh.material.serialize());
        }
      }
    }
    var geometry = mesh._geometry;
    if (geometry) {
      if (!serializationObject.geometries) {
        serializationObject.geometries = {};
        serializationObject.geometries.boxes = [];
        serializationObject.geometries.spheres = [];
        serializationObject.geometries.cylinders = [];
        serializationObject.geometries.toruses = [];
        serializationObject.geometries.grounds = [];
        serializationObject.geometries.planes = [];
        serializationObject.geometries.torusKnots = [];
        serializationObject.geometries.vertexData = [];
      }
      serializeGeometry(geometry, serializationObject.geometries);
    }
    if (mesh.skeleton && !mesh.skeleton.doNotSerialize) {
      serializationObject.skeletons = serializationObject.skeletons || [];
      serializationObject.skeletons.push(mesh.skeleton.serialize());
    }
    serializationObject.meshes = serializationObject.meshes || [];
    serializationObject.meshes.push(serializeMesh(mesh, serializationObject));
  }
};
var SceneSerializer = function() {
  function SceneSerializer2() {
  }
  SceneSerializer2.ClearCache = function() {
    serializedGeometries = [];
  };
  SceneSerializer2.Serialize = function(scene) {
    var serializationObject = {};
    SceneSerializer2.ClearCache();
    serializationObject.useDelayedTextureLoading = scene.useDelayedTextureLoading;
    serializationObject.autoClear = scene.autoClear;
    serializationObject.clearColor = scene.clearColor.asArray();
    serializationObject.ambientColor = scene.ambientColor.asArray();
    serializationObject.gravity = scene.gravity.asArray();
    serializationObject.collisionsEnabled = scene.collisionsEnabled;
    if (scene.fogMode && scene.fogMode !== 0) {
      serializationObject.fogMode = scene.fogMode;
      serializationObject.fogColor = scene.fogColor.asArray();
      serializationObject.fogStart = scene.fogStart;
      serializationObject.fogEnd = scene.fogEnd;
      serializationObject.fogDensity = scene.fogDensity;
    }
    if (scene.isPhysicsEnabled()) {
      var physicEngine = scene.getPhysicsEngine();
      if (physicEngine) {
        serializationObject.physicsEnabled = true;
        serializationObject.physicsGravity = physicEngine.gravity.asArray();
        serializationObject.physicsEngine = physicEngine.getPhysicsPluginName();
      }
    }
    if (scene.metadata) {
      serializationObject.metadata = scene.metadata;
    }
    serializationObject.morphTargetManagers = [];
    for (var _i = 0, _a = scene.meshes; _i < _a.length; _i++) {
      var abstractMesh = _a[_i];
      var manager = abstractMesh.morphTargetManager;
      if (manager) {
        serializationObject.morphTargetManagers.push(manager.serialize());
      }
    }
    serializationObject.lights = [];
    var index;
    var light;
    for (index = 0; index < scene.lights.length; index++) {
      light = scene.lights[index];
      if (!light.doNotSerialize) {
        serializationObject.lights.push(light.serialize());
      }
    }
    serializationObject.cameras = [];
    for (index = 0; index < scene.cameras.length; index++) {
      var camera = scene.cameras[index];
      if (!camera.doNotSerialize) {
        serializationObject.cameras.push(camera.serialize());
      }
    }
    if (scene.activeCamera) {
      serializationObject.activeCameraID = scene.activeCamera.id;
    }
    SerializationHelper.AppendSerializedAnimations(scene, serializationObject);
    if (scene.animationGroups && scene.animationGroups.length > 0) {
      serializationObject.animationGroups = [];
      for (var animationGroupIndex = 0; animationGroupIndex < scene.animationGroups.length; animationGroupIndex++) {
        var animationGroup = scene.animationGroups[animationGroupIndex];
        serializationObject.animationGroups.push(animationGroup.serialize());
      }
    }
    if (scene.reflectionProbes && scene.reflectionProbes.length > 0) {
      serializationObject.reflectionProbes = [];
      for (index = 0; index < scene.reflectionProbes.length; index++) {
        var reflectionProbe = scene.reflectionProbes[index];
        serializationObject.reflectionProbes.push(reflectionProbe.serialize());
      }
    }
    serializationObject.materials = [];
    serializationObject.multiMaterials = [];
    var material;
    for (index = 0; index < scene.materials.length; index++) {
      material = scene.materials[index];
      if (!material.doNotSerialize) {
        serializationObject.materials.push(material.serialize());
      }
    }
    serializationObject.multiMaterials = [];
    for (index = 0; index < scene.multiMaterials.length; index++) {
      var multiMaterial = scene.multiMaterials[index];
      serializationObject.multiMaterials.push(multiMaterial.serialize());
    }
    if (scene.environmentTexture) {
      serializationObject.environmentTexture = scene.environmentTexture.name;
    }
    serializationObject.environmentIntensity = scene.environmentIntensity;
    serializationObject.skeletons = [];
    for (index = 0; index < scene.skeletons.length; index++) {
      var skeleton = scene.skeletons[index];
      if (!skeleton.doNotSerialize) {
        serializationObject.skeletons.push(skeleton.serialize());
      }
    }
    serializationObject.transformNodes = [];
    for (index = 0; index < scene.transformNodes.length; index++) {
      if (!scene.transformNodes[index].doNotSerialize) {
        serializationObject.transformNodes.push(scene.transformNodes[index].serialize());
      }
    }
    serializationObject.geometries = {};
    serializationObject.geometries.boxes = [];
    serializationObject.geometries.spheres = [];
    serializationObject.geometries.cylinders = [];
    serializationObject.geometries.toruses = [];
    serializationObject.geometries.grounds = [];
    serializationObject.geometries.planes = [];
    serializationObject.geometries.torusKnots = [];
    serializationObject.geometries.vertexData = [];
    serializedGeometries = [];
    var geometries = scene.getGeometries();
    for (index = 0; index < geometries.length; index++) {
      var geometry = geometries[index];
      if (geometry.isReady()) {
        serializeGeometry(geometry, serializationObject.geometries);
      }
    }
    serializationObject.meshes = [];
    for (index = 0; index < scene.meshes.length; index++) {
      var abstractMesh = scene.meshes[index];
      if (abstractMesh instanceof Mesh) {
        var mesh = abstractMesh;
        if (!mesh.doNotSerialize) {
          if (mesh.delayLoadState === 1 || mesh.delayLoadState === 0) {
            serializationObject.meshes.push(serializeMesh(mesh, serializationObject));
          }
        }
      }
    }
    serializationObject.particleSystems = [];
    for (index = 0; index < scene.particleSystems.length; index++) {
      serializationObject.particleSystems.push(scene.particleSystems[index].serialize(false));
    }
    serializationObject.postProcesses = [];
    for (index = 0; index < scene.postProcesses.length; index++) {
      serializationObject.postProcesses.push(scene.postProcesses[index].serialize());
    }
    if (scene.actionManager) {
      serializationObject.actions = scene.actionManager.serialize("scene");
    }
    for (var _b = 0, _c = scene._serializableComponents; _b < _c.length; _b++) {
      var component = _c[_b];
      component.serialize(serializationObject);
    }
    return serializationObject;
  };
  SceneSerializer2.SerializeMesh = function(toSerialize, withParents, withChildren) {
    if (withParents === void 0) {
      withParents = false;
    }
    if (withChildren === void 0) {
      withChildren = false;
    }
    var serializationObject = {};
    SceneSerializer2.ClearCache();
    toSerialize = toSerialize instanceof Array ? toSerialize : [toSerialize];
    if (withParents || withChildren) {
      for (var i = 0; i < toSerialize.length; ++i) {
        if (withChildren) {
          toSerialize[i].getDescendants().forEach(function(node) {
            if (node instanceof Mesh && toSerialize.indexOf(node) < 0 && !node.doNotSerialize) {
              toSerialize.push(node);
            }
          });
        }
        if (withParents && toSerialize[i].parent && toSerialize.indexOf(toSerialize[i].parent) < 0 && !toSerialize[i].parent.doNotSerialize) {
          toSerialize.push(toSerialize[i].parent);
        }
      }
    }
    toSerialize.forEach(function(mesh) {
      finalizeSingleMesh(mesh, serializationObject);
    });
    return serializationObject;
  };
  return SceneSerializer2;
}();

// node_modules/@babylonjs/core/Misc/textureTools.js
var TextureTools = function() {
  function TextureTools2() {
  }
  TextureTools2.CreateResizedCopy = function(texture, width, height, useBilinearMode) {
    if (useBilinearMode === void 0) {
      useBilinearMode = true;
    }
    var scene = texture.getScene();
    var engine = scene.getEngine();
    var rtt = new RenderTargetTexture("resized" + texture.name, { width, height }, scene, !texture.noMipmap, true, texture._texture.type, false, texture.samplingMode, false);
    rtt.wrapU = texture.wrapU;
    rtt.wrapV = texture.wrapV;
    rtt.uOffset = texture.uOffset;
    rtt.vOffset = texture.vOffset;
    rtt.uScale = texture.uScale;
    rtt.vScale = texture.vScale;
    rtt.uAng = texture.uAng;
    rtt.vAng = texture.vAng;
    rtt.wAng = texture.wAng;
    rtt.coordinatesIndex = texture.coordinatesIndex;
    rtt.level = texture.level;
    rtt.anisotropicFilteringLevel = texture.anisotropicFilteringLevel;
    rtt._texture.isReady = false;
    texture.wrapU = Texture.CLAMP_ADDRESSMODE;
    texture.wrapV = Texture.CLAMP_ADDRESSMODE;
    var passPostProcess = new PassPostProcess("pass", 1, null, useBilinearMode ? Texture.BILINEAR_SAMPLINGMODE : Texture.NEAREST_SAMPLINGMODE, engine, false, 0);
    passPostProcess.getEffect().executeWhenCompiled(function() {
      passPostProcess.onApply = function(effect) {
        effect.setTexture("textureSampler", texture);
      };
      var internalTexture = rtt.getInternalTexture();
      if (internalTexture) {
        scene.postProcessManager.directRender([passPostProcess], internalTexture);
        engine.unBindFramebuffer(internalTexture);
        rtt.disposeFramebufferObjects();
        passPostProcess.dispose();
        internalTexture.isReady = true;
      }
    });
    return rtt;
  };
  return TextureTools2;
}();

// node_modules/@babylonjs/core/Misc/videoRecorder.js
var VideoRecorder = function() {
  function VideoRecorder2(engine, options) {
    if (options === void 0) {
      options = null;
    }
    if (!VideoRecorder2.IsSupported(engine)) {
      throw "Your browser does not support recording so far.";
    }
    var canvas = engine.getRenderingCanvas();
    if (!canvas) {
      throw "The babylon engine must have a canvas to be recorded";
    }
    this._canvas = canvas;
    this._canvas.isRecording = false;
    this._options = __assign(__assign({}, VideoRecorder2._defaultOptions), options);
    var stream = this._canvas.captureStream(this._options.fps);
    if (this._options.audioTracks) {
      for (var _i = 0, _a = this._options.audioTracks; _i < _a.length; _i++) {
        var track = _a[_i];
        stream.addTrack(track);
      }
    }
    this._mediaRecorder = new MediaRecorder(stream, { mimeType: this._options.mimeType });
    this._mediaRecorder.ondataavailable = this._handleDataAvailable.bind(this);
    this._mediaRecorder.onerror = this._handleError.bind(this);
    this._mediaRecorder.onstop = this._handleStop.bind(this);
  }
  VideoRecorder2.IsSupported = function(engine) {
    var canvas = engine.getRenderingCanvas();
    return !!canvas && typeof canvas.captureStream === "function";
  };
  Object.defineProperty(VideoRecorder2.prototype, "isRecording", {
    get: function() {
      return !!this._canvas && this._canvas.isRecording;
    },
    enumerable: false,
    configurable: true
  });
  VideoRecorder2.prototype.stopRecording = function() {
    if (!this._canvas || !this._mediaRecorder) {
      return;
    }
    if (!this.isRecording) {
      return;
    }
    this._canvas.isRecording = false;
    this._mediaRecorder.stop();
  };
  VideoRecorder2.prototype.startRecording = function(fileName, maxDuration) {
    var _this = this;
    if (fileName === void 0) {
      fileName = "babylonjs.webm";
    }
    if (maxDuration === void 0) {
      maxDuration = 7;
    }
    if (!this._canvas || !this._mediaRecorder) {
      throw "Recorder has already been disposed";
    }
    if (this.isRecording) {
      throw "Recording already in progress";
    }
    if (maxDuration > 0) {
      setTimeout(function() {
        _this.stopRecording();
      }, maxDuration * 1e3);
    }
    this._fileName = fileName;
    this._recordedChunks = [];
    this._resolve = null;
    this._reject = null;
    this._canvas.isRecording = true;
    this._mediaRecorder.start(this._options.recordChunckSize);
    return new Promise(function(resolve, reject) {
      _this._resolve = resolve;
      _this._reject = reject;
    });
  };
  VideoRecorder2.prototype.dispose = function() {
    this._canvas = null;
    this._mediaRecorder = null;
    this._recordedChunks = [];
    this._fileName = null;
    this._resolve = null;
    this._reject = null;
  };
  VideoRecorder2.prototype._handleDataAvailable = function(event) {
    if (event.data.size > 0) {
      this._recordedChunks.push(event.data);
    }
  };
  VideoRecorder2.prototype._handleError = function(event) {
    this.stopRecording();
    if (this._reject) {
      this._reject(event.error);
    } else {
      throw new event.error();
    }
  };
  VideoRecorder2.prototype._handleStop = function() {
    this.stopRecording();
    var superBuffer = new Blob(this._recordedChunks);
    if (this._resolve) {
      this._resolve(superBuffer);
    }
    window.URL.createObjectURL(superBuffer);
    if (this._fileName) {
      Tools.Download(superBuffer, this._fileName);
    }
  };
  VideoRecorder2._defaultOptions = {
    mimeType: "video/webm",
    fps: 25,
    recordChunckSize: 3e3
  };
  return VideoRecorder2;
}();

// node_modules/@babylonjs/core/Misc/screenshotTools.js
var ScreenshotTools = function() {
  function ScreenshotTools2() {
  }
  ScreenshotTools2.CreateScreenshot = function(engine, camera, size, successCallback, mimeType) {
    if (mimeType === void 0) {
      mimeType = "image/png";
    }
    var _a = ScreenshotTools2._getScreenshotSize(engine, camera, size), height = _a.height, width = _a.width;
    if (!(height && width)) {
      Logger.Error("Invalid 'size' parameter !");
      return;
    }
    if (!Tools._ScreenshotCanvas) {
      Tools._ScreenshotCanvas = document.createElement("canvas");
    }
    Tools._ScreenshotCanvas.width = width;
    Tools._ScreenshotCanvas.height = height;
    var renderContext = Tools._ScreenshotCanvas.getContext("2d");
    var ratio = engine.getRenderWidth() / engine.getRenderHeight();
    var newWidth = width;
    var newHeight = newWidth / ratio;
    if (newHeight > height) {
      newHeight = height;
      newWidth = newHeight * ratio;
    }
    var offsetX = Math.max(0, width - newWidth) / 2;
    var offsetY = Math.max(0, height - newHeight) / 2;
    var renderingCanvas = engine.getRenderingCanvas();
    if (renderContext && renderingCanvas) {
      renderContext.drawImage(renderingCanvas, offsetX, offsetY, newWidth, newHeight);
    }
    Tools.EncodeScreenshotCanvasData(successCallback, mimeType);
  };
  ScreenshotTools2.CreateScreenshotAsync = function(engine, camera, size, mimeType) {
    if (mimeType === void 0) {
      mimeType = "image/png";
    }
    return new Promise(function(resolve, reject) {
      ScreenshotTools2.CreateScreenshot(engine, camera, size, function(data) {
        if (typeof data !== "undefined") {
          resolve(data);
        } else {
          reject(new Error("Data is undefined"));
        }
      }, mimeType);
    });
  };
  ScreenshotTools2.CreateScreenshotUsingRenderTarget = function(engine, camera, size, successCallback, mimeType, samples, antialiasing, fileName, renderSprites, enableStencilBuffer) {
    if (mimeType === void 0) {
      mimeType = "image/png";
    }
    if (samples === void 0) {
      samples = 1;
    }
    if (antialiasing === void 0) {
      antialiasing = false;
    }
    if (renderSprites === void 0) {
      renderSprites = false;
    }
    if (enableStencilBuffer === void 0) {
      enableStencilBuffer = false;
    }
    var _a = ScreenshotTools2._getScreenshotSize(engine, camera, size), height = _a.height, width = _a.width;
    var targetTextureSize = { width, height };
    if (!(height && width)) {
      Logger.Error("Invalid 'size' parameter !");
      return;
    }
    var renderCanvas = engine.getRenderingCanvas();
    if (!renderCanvas) {
      Logger.Error("No rendering canvas found !");
      return;
    }
    var originalSize = { width: renderCanvas.width, height: renderCanvas.height };
    engine.setSize(width, height);
    var scene = camera.getScene();
    var previousCamera = null;
    var previousCameras = scene.activeCameras;
    if (scene.activeCamera !== camera || scene.activeCameras && scene.activeCameras.length) {
      previousCamera = scene.activeCamera;
      scene.activeCamera = camera;
    }
    scene.render();
    var texture = new RenderTargetTexture("screenShot", targetTextureSize, scene, false, false, 0, false, Texture.NEAREST_SAMPLINGMODE, void 0, enableStencilBuffer);
    texture.renderList = null;
    texture.samples = samples;
    texture.renderSprites = renderSprites;
    texture.onAfterRenderObservable.add(function() {
      Tools.DumpFramebuffer(width, height, engine, successCallback, mimeType, fileName);
    });
    var renderToTexture = function() {
      scene.incrementRenderId();
      scene.resetCachedMaterial();
      texture.render(true);
      texture.dispose();
      if (previousCamera) {
        scene.activeCamera = previousCamera;
      }
      scene.activeCameras = previousCameras;
      engine.setSize(originalSize.width, originalSize.height);
      camera.getProjectionMatrix(true);
    };
    if (antialiasing) {
      var fxaaPostProcess = new FxaaPostProcess("antialiasing", 1, scene.activeCamera);
      texture.addPostProcess(fxaaPostProcess);
      if (!fxaaPostProcess.getEffect().isReady()) {
        fxaaPostProcess.getEffect().onCompiled = function() {
          renderToTexture();
        };
      } else {
        renderToTexture();
      }
    } else {
      renderToTexture();
    }
  };
  ScreenshotTools2.CreateScreenshotUsingRenderTargetAsync = function(engine, camera, size, mimeType, samples, antialiasing, fileName, renderSprites) {
    if (mimeType === void 0) {
      mimeType = "image/png";
    }
    if (samples === void 0) {
      samples = 1;
    }
    if (antialiasing === void 0) {
      antialiasing = false;
    }
    if (renderSprites === void 0) {
      renderSprites = false;
    }
    return new Promise(function(resolve, reject) {
      ScreenshotTools2.CreateScreenshotUsingRenderTarget(engine, camera, size, function(data) {
        if (typeof data !== "undefined") {
          resolve(data);
        } else {
          reject(new Error("Data is undefined"));
        }
      }, mimeType, samples, antialiasing, fileName, renderSprites);
    });
  };
  ScreenshotTools2._getScreenshotSize = function(engine, camera, size) {
    var height = 0;
    var width = 0;
    if (typeof size === "object") {
      var precision = size.precision ? Math.abs(size.precision) : 1;
      if (size.width && size.height) {
        height = size.height * precision;
        width = size.width * precision;
      } else if (size.width && !size.height) {
        width = size.width * precision;
        height = Math.round(width / engine.getAspectRatio(camera));
      } else if (size.height && !size.width) {
        height = size.height * precision;
        width = Math.round(height * engine.getAspectRatio(camera));
      } else {
        width = Math.round(engine.getRenderWidth() * precision);
        height = Math.round(width / engine.getAspectRatio(camera));
      }
    } else if (!isNaN(size)) {
      height = size;
      width = size;
    }
    if (width) {
      width = Math.floor(width);
    }
    if (height) {
      height = Math.floor(height);
    }
    return { height: height | 0, width: width | 0 };
  };
  return ScreenshotTools2;
}();
Tools.CreateScreenshot = ScreenshotTools.CreateScreenshot;
Tools.CreateScreenshotAsync = ScreenshotTools.CreateScreenshotAsync;
Tools.CreateScreenshotUsingRenderTarget = ScreenshotTools.CreateScreenshotUsingRenderTarget;
Tools.CreateScreenshotUsingRenderTargetAsync = ScreenshotTools.CreateScreenshotUsingRenderTargetAsync;

// node_modules/@babylonjs/core/Misc/iInspectable.js
var InspectableType;
(function(InspectableType2) {
  InspectableType2[InspectableType2["Checkbox"] = 0] = "Checkbox";
  InspectableType2[InspectableType2["Slider"] = 1] = "Slider";
  InspectableType2[InspectableType2["Vector3"] = 2] = "Vector3";
  InspectableType2[InspectableType2["Quaternion"] = 3] = "Quaternion";
  InspectableType2[InspectableType2["Color3"] = 4] = "Color3";
  InspectableType2[InspectableType2["String"] = 5] = "String";
})(InspectableType || (InspectableType = {}));

// node_modules/@babylonjs/core/Misc/dataStorage.js
var DataStorage = function() {
  function DataStorage2() {
  }
  DataStorage2._GetStorage = function() {
    try {
      localStorage.setItem("test", "");
      localStorage.removeItem("test");
      return localStorage;
    } catch (_a) {
      var inMemoryStorage_1 = {};
      return {
        getItem: function(key) {
          var value = inMemoryStorage_1[key];
          return value === void 0 ? null : value;
        },
        setItem: function(key, value) {
          inMemoryStorage_1[key] = value;
        }
      };
    }
  };
  DataStorage2.ReadString = function(key, defaultValue) {
    var value = this._Storage.getItem(key);
    return value !== null ? value : defaultValue;
  };
  DataStorage2.WriteString = function(key, value) {
    this._Storage.setItem(key, value);
  };
  DataStorage2.ReadBoolean = function(key, defaultValue) {
    var value = this._Storage.getItem(key);
    return value !== null ? value === "true" : defaultValue;
  };
  DataStorage2.WriteBoolean = function(key, value) {
    this._Storage.setItem(key, value ? "true" : "false");
  };
  DataStorage2.ReadNumber = function(key, defaultValue) {
    var value = this._Storage.getItem(key);
    return value !== null ? parseFloat(value) : defaultValue;
  };
  DataStorage2.WriteNumber = function(key, value) {
    this._Storage.setItem(key, value.toString());
  };
  DataStorage2._Storage = DataStorage2._GetStorage();
  return DataStorage2;
}();

// node_modules/@babylonjs/core/Misc/sceneRecorder.js
var SceneRecorder = function() {
  function SceneRecorder2() {
    this._trackedScene = null;
  }
  SceneRecorder2.prototype.track = function(scene) {
    this._trackedScene = scene;
    this._savedJSON = SceneSerializer.Serialize(scene);
  };
  SceneRecorder2.prototype.getDelta = function() {
    if (!this._trackedScene) {
      return null;
    }
    var newJSON = SceneSerializer.Serialize(this._trackedScene);
    var deltaJSON = {};
    for (var node in newJSON) {
      this._compareCollections(node, this._savedJSON[node], newJSON[node], deltaJSON);
    }
    return deltaJSON;
  };
  SceneRecorder2.prototype._compareArray = function(key, original, current, deltaJSON) {
    if (original.length === 0 && current.length === 0) {
      return true;
    }
    if (original.length && !isNaN(original[0]) || current.length && !isNaN(current[0])) {
      if (original.length !== current.length) {
        return false;
      }
      if (original.length === 0) {
        return true;
      }
      for (var index = 0; index < original.length; index++) {
        if (original[index] !== current[index]) {
          deltaJSON[key] = current;
          return false;
        }
      }
      return true;
    }
    var originalUniqueIds = [];
    var _loop_1 = function() {
      var originalObject = original[index];
      var originalUniqueId = originalObject.uniqueId;
      originalUniqueIds.push(originalUniqueId);
      var currentObjects = current.filter(function(c) {
        return c.uniqueId === originalUniqueId;
      });
      if (currentObjects.length) {
        var currentObject2 = currentObjects[0];
        var newObject = {};
        if (!this_1._compareObjects(originalObject, currentObject2, newObject)) {
          if (!deltaJSON[key]) {
            deltaJSON[key] = [];
          }
          newObject.__state = {
            id: currentObject2.id || currentObject2.name
          };
          deltaJSON[key].push(newObject);
        }
      } else {
        var newObject = {
          __state: {
            deleteId: originalObject.id || originalObject.name
          }
        };
        deltaJSON[key].push(newObject);
      }
    };
    var this_1 = this;
    for (var index = 0; index < original.length; index++) {
      _loop_1();
    }
    for (var index = 0; index < current.length; index++) {
      var currentObject = current[index];
      var currentUniqueId = currentObject.uniqueId;
      if (originalUniqueIds.indexOf(currentUniqueId) === -1) {
        if (!deltaJSON[key]) {
          deltaJSON[key] = [];
        }
        deltaJSON[key].push(currentObject);
      }
    }
    return true;
  };
  SceneRecorder2.prototype._compareObjects = function(originalObjet, currentObject, deltaJSON) {
    var aDifferenceWasFound = false;
    for (var prop in originalObjet) {
      if (!originalObjet.hasOwnProperty(prop)) {
        continue;
      }
      var originalValue = originalObjet[prop];
      var currentValue = currentObject[prop];
      var diffFound = false;
      if (Array.isArray(originalValue)) {
        diffFound = JSON.stringify(originalValue) !== JSON.stringify(currentValue);
      } else if (!isNaN(originalValue) || Object.prototype.toString.call(originalValue) == "[object String]") {
        diffFound = originalValue !== currentValue;
      }
      if (diffFound) {
        aDifferenceWasFound = true;
        deltaJSON[prop] = currentValue;
      }
    }
    return !aDifferenceWasFound;
  };
  SceneRecorder2.prototype._compareCollections = function(key, original, current, deltaJSON) {
    if (original === current) {
      return;
    }
    if (original && current) {
      if (Array.isArray(original) && Array.isArray(current)) {
        if (this._compareArray(key, original, current, deltaJSON)) {
          return;
        }
      } else if (typeof original === "object" && typeof current === "object") {
        var newObject = {};
        if (!this._compareObjects(original, current, newObject)) {
          deltaJSON[key] = newObject;
        }
        return;
      }
    }
  };
  SceneRecorder2.GetShadowGeneratorById = function(scene, id) {
    var generators = scene.lights.map(function(l) {
      return l.getShadowGenerator();
    });
    for (var _i = 0, generators_1 = generators; _i < generators_1.length; _i++) {
      var generator = generators_1[_i];
      if (generator && generator.id === id) {
        return generator;
      }
    }
    return null;
  };
  SceneRecorder2.ApplyDelta = function(deltaJSON, scene) {
    var _this = this;
    if (typeof deltaJSON === "string") {
      deltaJSON = JSON.parse(deltaJSON);
    }
    var anyScene = scene;
    for (var prop in deltaJSON) {
      var source = deltaJSON[prop];
      var property = anyScene[prop];
      if (Array.isArray(property) || prop === "shadowGenerators") {
        switch (prop) {
          case "cameras":
            this._ApplyDeltaForEntity(source, scene, scene.getCameraByID.bind(scene), function(data) {
              return Camera.Parse(data, scene);
            });
            break;
          case "lights":
            this._ApplyDeltaForEntity(source, scene, scene.getLightByID.bind(scene), function(data) {
              return Light.Parse(data, scene);
            });
            break;
          case "shadowGenerators":
            this._ApplyDeltaForEntity(source, scene, function(id) {
              return _this.GetShadowGeneratorById(scene, id);
            }, function(data) {
              return ShadowGenerator.Parse(data, scene);
            });
            break;
          case "meshes":
            this._ApplyDeltaForEntity(source, scene, scene.getMeshByID.bind(scene), function(data) {
              return Mesh.Parse(data, scene, "");
            });
            break;
          case "skeletons":
            this._ApplyDeltaForEntity(source, scene, scene.getSkeletonById.bind(scene), function(data) {
              return Skeleton.Parse(data, scene);
            });
            break;
          case "materials":
            this._ApplyDeltaForEntity(source, scene, scene.getMaterialByID.bind(scene), function(data) {
              return Material.Parse(data, scene, "");
            });
            break;
          case "multiMaterials":
            this._ApplyDeltaForEntity(source, scene, scene.getMaterialByID.bind(scene), function(data) {
              return MultiMaterial.Parse(data, scene, "");
            });
            break;
          case "transformNodes":
            this._ApplyDeltaForEntity(source, scene, scene.getTransformNodeByID.bind(scene), function(data) {
              return TransformNode.Parse(data, scene, "");
            });
            break;
          case "particleSystems":
            this._ApplyDeltaForEntity(source, scene, scene.getParticleSystemByID.bind(scene), function(data) {
              return ParticleSystem.Parse(data, scene, "");
            });
            break;
          case "morphTargetManagers":
            this._ApplyDeltaForEntity(source, scene, scene.getMorphTargetById.bind(scene), function(data) {
              return MorphTargetManager.Parse(data, scene);
            });
            break;
          case "postProcesses":
            this._ApplyDeltaForEntity(source, scene, scene.getPostProcessByName.bind(scene), function(data) {
              return PostProcess.Parse(data, scene, "");
            });
            break;
        }
      } else if (!isNaN(property)) {
        anyScene[prop] = source;
      } else if (property.fromArray) {
        property.fromArray(source);
      }
    }
  };
  SceneRecorder2._ApplyPropertiesToEntity = function(deltaJSON, entity) {
    for (var prop in deltaJSON) {
      var source = deltaJSON[prop];
      var property = entity[prop];
      if (property === void 0) {
        continue;
      }
      if (!isNaN(property) || Array.isArray(property)) {
        entity[prop] = source;
      } else if (property.fromArray) {
        property.fromArray(source);
      }
    }
  };
  SceneRecorder2._ApplyDeltaForEntity = function(sources, scene, finder, addNew) {
    for (var _i = 0, sources_1 = sources; _i < sources_1.length; _i++) {
      var source = sources_1[_i];
      if (source.__state && source.__state.id !== void 0) {
        var targetEntity = finder(source.__state.id);
        if (targetEntity) {
          this._ApplyPropertiesToEntity(source, targetEntity);
        }
      } else if (source.__state && source.__state.deleteId !== void 0) {
        var target = finder(source.__state.deleteId);
        target === null || target === void 0 ? void 0 : target.dispose();
      } else {
        addNew(source);
      }
    }
  };
  return SceneRecorder2;
}();

// node_modules/@babylonjs/core/Misc/trajectoryClassifier.js
var Levenshtein;
(function(Levenshtein2) {
  var Alphabet = function() {
    function Alphabet2(characters, charToInsertionCost, charToDeletionCost, charsToSubstitutionCost) {
      if (charToInsertionCost === void 0) {
        charToInsertionCost = null;
      }
      if (charToDeletionCost === void 0) {
        charToDeletionCost = null;
      }
      if (charsToSubstitutionCost === void 0) {
        charsToSubstitutionCost = null;
      }
      charToInsertionCost = charToInsertionCost !== null && charToInsertionCost !== void 0 ? charToInsertionCost : function() {
        return 1;
      };
      charToDeletionCost = charToDeletionCost !== null && charToDeletionCost !== void 0 ? charToDeletionCost : function() {
        return 1;
      };
      charsToSubstitutionCost = charsToSubstitutionCost !== null && charsToSubstitutionCost !== void 0 ? charsToSubstitutionCost : function(a, b) {
        return a === b ? 0 : 1;
      };
      this._characterToIdx = /* @__PURE__ */ new Map();
      this._insertionCosts = new Array(characters.length);
      this._deletionCosts = new Array(characters.length);
      this._substitutionCosts = new Array(characters.length);
      var c;
      for (var outerIdx = 0; outerIdx < characters.length; ++outerIdx) {
        c = characters[outerIdx];
        this._characterToIdx.set(c, outerIdx);
        this._insertionCosts[outerIdx] = charToInsertionCost(c);
        this._deletionCosts[outerIdx] = charToDeletionCost(c);
        this._substitutionCosts[outerIdx] = new Array(characters.length);
        for (var innerIdx = outerIdx; innerIdx < characters.length; ++innerIdx) {
          this._substitutionCosts[outerIdx][innerIdx] = charsToSubstitutionCost(c, characters[innerIdx]);
        }
      }
    }
    Alphabet2.prototype.serialize = function() {
      var jsonObject = {};
      var characters = new Array(this._characterToIdx.size);
      this._characterToIdx.forEach(function(v, k) {
        characters[v] = k;
      });
      jsonObject["characters"] = characters;
      jsonObject["insertionCosts"] = this._insertionCosts;
      jsonObject["deletionCosts"] = this._deletionCosts;
      jsonObject["substitutionCosts"] = this._substitutionCosts;
      return JSON.stringify(jsonObject);
    };
    Alphabet2.Deserialize = function(json) {
      var jsonObject = JSON.parse(json);
      var alphabet = new Alphabet2(jsonObject["characters"]);
      alphabet._insertionCosts = jsonObject["insertionCosts"];
      alphabet._deletionCosts = jsonObject["deletionCosts"];
      alphabet._substitutionCosts = jsonObject["substitutionCosts"];
      return alphabet;
    };
    Alphabet2.prototype.getCharacterIdx = function(char) {
      return this._characterToIdx.get(char);
    };
    Alphabet2.prototype.getInsertionCost = function(idx) {
      return this._insertionCosts[idx];
    };
    Alphabet2.prototype.getDeletionCost = function(idx) {
      return this._deletionCosts[idx];
    };
    Alphabet2.prototype.getSubstitutionCost = function(idx1, idx2) {
      var min = Math.min(idx1, idx2);
      var max = Math.max(idx1, idx2);
      return this._substitutionCosts[min][max];
    };
    return Alphabet2;
  }();
  Levenshtein2.Alphabet = Alphabet;
  var Sequence = function() {
    function Sequence2(characters, alphabet) {
      var _this = this;
      if (characters.length > Sequence2.MAX_SEQUENCE_LENGTH) {
        throw new Error("Sequences longer than " + Sequence2.MAX_SEQUENCE_LENGTH + " not supported.");
      }
      this._alphabet = alphabet;
      this._characters = characters.map(function(c) {
        return _this._alphabet.getCharacterIdx(c);
      });
    }
    Sequence2.prototype.serialize = function() {
      return JSON.stringify(this._characters);
    };
    Sequence2.Deserialize = function(json, alphabet) {
      var sequence = new Sequence2([], alphabet);
      sequence._characters = JSON.parse(json);
      return sequence;
    };
    Sequence2.prototype.distance = function(other) {
      return Sequence2._distance(this, other);
    };
    Sequence2._distance = function(a, b) {
      var alphabet = a._alphabet;
      if (alphabet !== b._alphabet) {
        throw new Error("Cannot Levenshtein compare Sequences built from different alphabets.");
      }
      var aChars = a._characters;
      var bChars = b._characters;
      var aLength = aChars.length;
      var bLength = bChars.length;
      var costMatrix = Sequence2._costMatrix;
      costMatrix[0][0] = 0;
      for (var idx = 0; idx < aLength; ++idx) {
        costMatrix[idx + 1][0] = costMatrix[idx][0] + alphabet.getInsertionCost(aChars[idx]);
      }
      for (var idx = 0; idx < bLength; ++idx) {
        costMatrix[0][idx + 1] = costMatrix[0][idx] + alphabet.getInsertionCost(bChars[idx]);
      }
      for (var aIdx = 0; aIdx < aLength; ++aIdx) {
        for (var bIdx = 0; bIdx < bLength; ++bIdx) {
          Sequence2._insertionCost = costMatrix[aIdx + 1][bIdx] + alphabet.getInsertionCost(bChars[bIdx]);
          Sequence2._deletionCost = costMatrix[aIdx][bIdx + 1] + alphabet.getDeletionCost(aChars[aIdx]);
          Sequence2._substitutionCost = costMatrix[aIdx][bIdx] + alphabet.getSubstitutionCost(aChars[aIdx], bChars[bIdx]);
          costMatrix[aIdx + 1][bIdx + 1] = Math.min(Sequence2._insertionCost, Sequence2._deletionCost, Sequence2._substitutionCost);
        }
      }
      return costMatrix[aLength][bLength];
    };
    Sequence2.MAX_SEQUENCE_LENGTH = 256;
    Sequence2._costMatrix = __spreadArrays(Array(Sequence2.MAX_SEQUENCE_LENGTH + 1)).map(function(n) {
      return new Array(Sequence2.MAX_SEQUENCE_LENGTH + 1);
    });
    return Sequence2;
  }();
  Levenshtein2.Sequence = Sequence;
})(Levenshtein || (Levenshtein = {}));
var Trajectory = function() {
  function Trajectory2(segmentLength) {
    if (segmentLength === void 0) {
      segmentLength = 0.01;
    }
    this._points = [];
    this._segmentLength = segmentLength;
  }
  Trajectory2.prototype.serialize = function() {
    return JSON.stringify(this);
  };
  Trajectory2.Deserialize = function(json) {
    var jsonObject = JSON.parse(json);
    var trajectory = new Trajectory2(jsonObject["_segmentLength"]);
    trajectory._points = jsonObject["_points"].map(function(pt) {
      return new Vector3(pt["_x"], pt["_y"], pt["_z"]);
    });
    return trajectory;
  };
  Trajectory2.prototype.getLength = function() {
    return this._points.length * this._segmentLength;
  };
  Trajectory2.prototype.add = function(point) {
    var _this = this;
    var numPoints = this._points.length;
    if (numPoints === 0) {
      this._points.push(point.clone());
    } else {
      var getT = function() {
        return _this._segmentLength / Vector3.Distance(_this._points[numPoints - 1], point);
      };
      for (var t = getT(); t <= 1; t = getT()) {
        var newPoint = this._points[numPoints - 1].scale(1 - t);
        point.scaleAndAddToRef(t, newPoint);
        this._points.push(newPoint);
        ++numPoints;
      }
    }
  };
  Trajectory2.prototype.resampleAtTargetResolution = function(targetResolution) {
    var resampled = new Trajectory2(this.getLength() / targetResolution);
    this._points.forEach(function(pt) {
      resampled.add(pt);
    });
    return resampled;
  };
  Trajectory2.prototype.tokenize = function(tokens) {
    var tokenization = [];
    var segmentDir = new Vector3();
    for (var idx = 2; idx < this._points.length; ++idx) {
      if (Trajectory2._transformSegmentDirToRef(this._points[idx - 2], this._points[idx - 1], this._points[idx], segmentDir)) {
        tokenization.push(Trajectory2._tokenizeSegment(segmentDir, tokens));
      }
    }
    return tokenization;
  };
  Trajectory2._transformSegmentDirToRef = function(priorVec, fromVec, toVec, result) {
    var DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD = 0.98;
    fromVec.subtractToRef(priorVec, Trajectory2._forwardDir);
    Trajectory2._forwardDir.normalize();
    fromVec.scaleToRef(-1, Trajectory2._inverseFromVec);
    Trajectory2._inverseFromVec.normalize();
    if (Math.abs(Vector3.Dot(Trajectory2._forwardDir, Trajectory2._inverseFromVec)) > DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD) {
      return false;
    }
    Vector3.CrossToRef(Trajectory2._forwardDir, Trajectory2._inverseFromVec, Trajectory2._upDir);
    Trajectory2._upDir.normalize();
    Matrix.LookAtLHToRef(priorVec, fromVec, Trajectory2._upDir, Trajectory2._lookMatrix);
    toVec.subtractToRef(fromVec, Trajectory2._fromToVec);
    Trajectory2._fromToVec.normalize();
    Vector3.TransformNormalToRef(Trajectory2._fromToVec, Trajectory2._lookMatrix, result);
    return true;
  };
  Trajectory2._tokenizeSegment = function(segment, tokens) {
    Trajectory2._bestMatch = 0;
    Trajectory2._score = Vector3.Dot(segment, tokens[0]);
    Trajectory2._bestScore = Trajectory2._score;
    for (var idx = 1; idx < tokens.length; ++idx) {
      Trajectory2._score = Vector3.Dot(segment, tokens[idx]);
      if (Trajectory2._score > Trajectory2._bestScore) {
        Trajectory2._bestMatch = idx;
        Trajectory2._bestScore = Trajectory2._score;
      }
    }
    return Trajectory2._bestMatch;
  };
  Trajectory2._forwardDir = new Vector3();
  Trajectory2._inverseFromVec = new Vector3();
  Trajectory2._upDir = new Vector3();
  Trajectory2._fromToVec = new Vector3();
  Trajectory2._lookMatrix = new Matrix();
  return Trajectory2;
}();
var Vector3Alphabet = function() {
  function Vector3Alphabet2(size) {
    this.chars = new Array(size);
  }
  Vector3Alphabet2.Generate = function(alphabetSize, iterations, startingStepSize, endingStepSize, fixedValues) {
    if (alphabetSize === void 0) {
      alphabetSize = 64;
    }
    if (iterations === void 0) {
      iterations = 256;
    }
    if (startingStepSize === void 0) {
      startingStepSize = 0.1;
    }
    if (endingStepSize === void 0) {
      endingStepSize = 1e-3;
    }
    if (fixedValues === void 0) {
      fixedValues = [];
    }
    var EPSILON = 1e-3;
    var EPSILON_SQUARED = EPSILON * EPSILON;
    var alphabet = new Vector3Alphabet2(alphabetSize);
    for (var idx = 0; idx < alphabetSize; ++idx) {
      alphabet.chars[idx] = new Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);
      alphabet.chars[idx].normalize();
    }
    for (var idx = 0; idx < fixedValues.length; ++idx) {
      alphabet.chars[idx].copyFrom(fixedValues[idx]);
    }
    var stepSize;
    var distSq;
    var force = new Vector3();
    var scratch = new Vector3();
    var lerp = function(l, r, t) {
      return (1 - t) * l + t * r;
    };
    for (var iteration = 0; iteration < iterations; ++iteration) {
      stepSize = lerp(startingStepSize, endingStepSize, iteration / (iterations - 1));
      var _loop_1 = function(idx2) {
        force.copyFromFloats(0, 0, 0);
        alphabet.chars.forEach(function(pt) {
          alphabet.chars[idx2].subtractToRef(pt, scratch);
          distSq = scratch.lengthSquared();
          if (distSq > EPSILON_SQUARED) {
            scratch.scaleAndAddToRef(1 / (scratch.lengthSquared() * distSq), force);
          }
        });
        force.scaleInPlace(stepSize);
        alphabet.chars[idx2].addInPlace(force);
        alphabet.chars[idx2].normalize();
      };
      for (var idx = fixedValues.length; idx < alphabet.chars.length; ++idx) {
        _loop_1(idx);
      }
    }
    return alphabet;
  };
  Vector3Alphabet2.prototype.serialize = function() {
    return JSON.stringify(this.chars);
  };
  Vector3Alphabet2.Deserialize = function(json) {
    var jsonObject = JSON.parse(json);
    var alphabet = new Vector3Alphabet2(jsonObject.length);
    for (var idx = 0; idx < jsonObject.length; ++idx) {
      alphabet.chars[idx] = new Vector3(jsonObject[idx]["_x"], jsonObject[idx]["_y"], jsonObject[idx]["_z"]);
    }
    return alphabet;
  };
  return Vector3Alphabet2;
}();
var TrajectoryDescriptor = function() {
  function TrajectoryDescriptor2() {
    this._sequences = [];
  }
  TrajectoryDescriptor2.prototype.serialize = function() {
    return JSON.stringify(this._sequences.map(function(sequence) {
      return sequence.serialize();
    }));
  };
  TrajectoryDescriptor2.Deserialize = function(json, alphabet) {
    var descriptor = new TrajectoryDescriptor2();
    descriptor._sequences = JSON.parse(json).map(function(s) {
      return Levenshtein.Sequence.Deserialize(s, alphabet);
    });
    return descriptor;
  };
  TrajectoryDescriptor2.CreateFromTrajectory = function(trajectory, vector3Alphabet, levenshteinAlphabet) {
    return TrajectoryDescriptor2.CreateFromTokenizationPyramid(TrajectoryDescriptor2._getTokenizationPyramid(trajectory, vector3Alphabet), levenshteinAlphabet);
  };
  TrajectoryDescriptor2.CreateFromTokenizationPyramid = function(pyramid, levenshteinAlphabet) {
    var descriptor = new TrajectoryDescriptor2();
    descriptor._sequences = pyramid.map(function(tokens) {
      return new Levenshtein.Sequence(tokens, levenshteinAlphabet);
    });
    return descriptor;
  };
  TrajectoryDescriptor2._getTokenizationPyramid = function(trajectory, alphabet, targetResolution) {
    if (targetResolution === void 0) {
      targetResolution = TrajectoryDescriptor2.FINEST_DESCRIPTOR_RESOLUTION;
    }
    var pyramid = [];
    for (var res = targetResolution; res > 4; res = Math.floor(res / 2)) {
      pyramid.push(trajectory.resampleAtTargetResolution(res).tokenize(alphabet.chars));
    }
    return pyramid;
  };
  TrajectoryDescriptor2.prototype.distance = function(other) {
    var totalDistance = 0;
    var weight;
    for (var idx = 0; idx < this._sequences.length; ++idx) {
      weight = Math.pow(2, idx);
      totalDistance += weight * this._sequences[idx].distance(other._sequences[idx]);
    }
    return totalDistance;
  };
  TrajectoryDescriptor2.FINEST_DESCRIPTOR_RESOLUTION = 32;
  return TrajectoryDescriptor2;
}();
var TrajectoryClass = function() {
  function TrajectoryClass2(descriptors) {
    if (descriptors === void 0) {
      descriptors = [];
    }
    this._descriptors = descriptors;
    this._centroidIdx = -1;
    this._averageDistance = 0;
    this._refreshDescription();
  }
  TrajectoryClass2.prototype.serialize = function() {
    var jsonObject = {};
    jsonObject.descriptors = this._descriptors.map(function(desc) {
      return desc.serialize();
    });
    jsonObject.centroidIdx = this._centroidIdx;
    jsonObject.averageDistance = this._averageDistance;
    return JSON.stringify(jsonObject);
  };
  TrajectoryClass2.Deserialize = function(json, alphabet) {
    var jsonObject = JSON.parse(json);
    var described = new TrajectoryClass2();
    described._descriptors = jsonObject.descriptors.map(function(s) {
      return TrajectoryDescriptor.Deserialize(s, alphabet);
    });
    described._centroidIdx = jsonObject.centroidIdx;
    described._averageDistance = jsonObject.averageDistance;
    return described;
  };
  TrajectoryClass2.prototype.add = function(descriptor) {
    this._descriptors.push(descriptor);
    this._refreshDescription();
  };
  TrajectoryClass2.prototype.getMatchCost = function(descriptor) {
    return descriptor.distance(this._descriptors[this._centroidIdx]) / this._averageDistance;
  };
  TrajectoryClass2.prototype.getMatchMinimumDistance = function(descriptor) {
    return Math.min.apply(Math, this._descriptors.map(function(desc) {
      return desc.distance(descriptor);
    }));
  };
  TrajectoryClass2.prototype._refreshDescription = function() {
    var _this = this;
    this._centroidIdx = -1;
    var sum;
    var distances = this._descriptors.map(function(a) {
      sum = 0;
      _this._descriptors.forEach(function(b) {
        sum += a.distance(b);
      });
      return sum;
    });
    for (var idx = 0; idx < distances.length; ++idx) {
      if (this._centroidIdx < 0 || distances[idx] < distances[this._centroidIdx]) {
        this._centroidIdx = idx;
      }
    }
    this._averageDistance = 0;
    this._descriptors.forEach(function(desc) {
      _this._averageDistance += desc.distance(_this._descriptors[_this._centroidIdx]);
    });
    if (this._descriptors.length > 0) {
      this._averageDistance = Math.max(this._averageDistance / this._descriptors.length, TrajectoryClass2.MIN_AVERAGE_DISTANCE);
    }
  };
  TrajectoryClass2.MIN_AVERAGE_DISTANCE = 1;
  return TrajectoryClass2;
}();
var TrajectoryClassifier = function() {
  function TrajectoryClassifier2() {
    this._maximumAllowableMatchCost = 4;
    this._nameToDescribedTrajectory = /* @__PURE__ */ new Map();
  }
  TrajectoryClassifier2.prototype.serialize = function() {
    var jsonObject = {};
    jsonObject.maximumAllowableMatchCost = this._maximumAllowableMatchCost;
    jsonObject.vector3Alphabet = this._vector3Alphabet.serialize();
    jsonObject.levenshteinAlphabet = this._levenshteinAlphabet.serialize();
    jsonObject.nameToDescribedTrajectory = [];
    this._nameToDescribedTrajectory.forEach(function(described, name98) {
      jsonObject.nameToDescribedTrajectory.push(name98);
      jsonObject.nameToDescribedTrajectory.push(described.serialize());
    });
    return JSON.stringify(jsonObject);
  };
  TrajectoryClassifier2.Deserialize = function(json) {
    var jsonObject = JSON.parse(json);
    var classifier = new TrajectoryClassifier2();
    classifier._maximumAllowableMatchCost = jsonObject.maximumAllowableMatchCost;
    classifier._vector3Alphabet = Vector3Alphabet.Deserialize(jsonObject.vector3Alphabet);
    classifier._levenshteinAlphabet = Levenshtein.Alphabet.Deserialize(jsonObject.levenshteinAlphabet);
    for (var idx = 0; idx < jsonObject.nameToDescribedTrajectory.length; idx += 2) {
      classifier._nameToDescribedTrajectory.set(jsonObject.nameToDescribedTrajectory[idx], TrajectoryClass.Deserialize(jsonObject.nameToDescribedTrajectory[idx + 1], classifier._levenshteinAlphabet));
    }
    return classifier;
  };
  TrajectoryClassifier2.Generate = function() {
    var vecs = Vector3Alphabet.Generate(64, 256, 0.1, 1e-3, [Vector3.Forward()]);
    var charIdxs = new Array(vecs.chars.length);
    for (var idx = 0; idx < charIdxs.length; ++idx) {
      charIdxs[idx] = idx;
    }
    var alphabet = new Levenshtein.Alphabet(charIdxs, function(idx2) {
      return idx2 === 0 ? 0 : 1;
    }, function(idx2) {
      return idx2 === 0 ? 0 : 1;
    }, function(a, b) {
      return Math.min(1 - Vector3.Dot(vecs.chars[a], vecs.chars[b]), 1);
    });
    var trajectorySet = new TrajectoryClassifier2();
    trajectorySet._vector3Alphabet = vecs;
    trajectorySet._levenshteinAlphabet = alphabet;
    return trajectorySet;
  };
  TrajectoryClassifier2.prototype.addTrajectoryToClassification = function(trajectory, classification) {
    if (!this._nameToDescribedTrajectory.has(classification)) {
      this._nameToDescribedTrajectory.set(classification, new TrajectoryClass());
    }
    this._nameToDescribedTrajectory.get(classification).add(TrajectoryDescriptor.CreateFromTrajectory(trajectory, this._vector3Alphabet, this._levenshteinAlphabet));
  };
  TrajectoryClassifier2.prototype.deleteClassification = function(classification) {
    return this._nameToDescribedTrajectory.delete(classification);
  };
  TrajectoryClassifier2.prototype.classifyTrajectory = function(trajectory) {
    var _this = this;
    var descriptor = TrajectoryDescriptor.CreateFromTrajectory(trajectory, this._vector3Alphabet, this._levenshteinAlphabet);
    var allowableMatches = [];
    this._nameToDescribedTrajectory.forEach(function(trajectoryClass, classification) {
      if (trajectoryClass.getMatchCost(descriptor) < _this._maximumAllowableMatchCost) {
        allowableMatches.push(classification);
      }
    });
    if (allowableMatches.length === 0) {
      return null;
    }
    var bestIdx = 0;
    var bestMatch = this._nameToDescribedTrajectory.get(allowableMatches[bestIdx]).getMatchMinimumDistance(descriptor);
    var match;
    for (var idx = 0; idx < allowableMatches.length; ++idx) {
      match = this._nameToDescribedTrajectory.get(allowableMatches[idx]).getMatchMinimumDistance(descriptor);
      if (match < bestMatch) {
        bestMatch = match;
        bestIdx = idx;
      }
    }
    return allowableMatches[bestIdx];
  };
  return TrajectoryClassifier2;
}();

// node_modules/@babylonjs/core/XR/features/WebXRHitTestLegacy.js
var WebXRHitTestLegacy = function(_super) {
  __extends(WebXRHitTestLegacy2, _super);
  function WebXRHitTestLegacy2(_xrSessionManager, options) {
    if (options === void 0) {
      options = {};
    }
    var _this = _super.call(this, _xrSessionManager) || this;
    _this.options = options;
    _this._direction = new Vector3(0, 0, -1);
    _this._mat = new Matrix();
    _this._onSelectEnabled = false;
    _this._origin = new Vector3(0, 0, 0);
    _this.lastNativeXRHitResults = [];
    _this.onHitTestResultObservable = new Observable();
    _this._onHitTestResults = function(xrResults) {
      var mats = xrResults.map(function(result) {
        var mat = Matrix.FromArray(result.hitMatrix);
        if (!_this._xrSessionManager.scene.useRightHandedSystem) {
          mat.toggleModelMatrixHandInPlace();
        }
        if (_this.options.worldParentNode) {
          mat.multiplyToRef(_this.options.worldParentNode.getWorldMatrix(), mat);
        }
        return {
          xrHitResult: result,
          transformationMatrix: mat
        };
      });
      _this.lastNativeXRHitResults = xrResults;
      _this.onHitTestResultObservable.notifyObservers(mats);
    };
    _this._onSelect = function(event) {
      if (!_this._onSelectEnabled) {
        return;
      }
      WebXRHitTestLegacy2.XRHitTestWithSelectEvent(event, _this._xrSessionManager.referenceSpace);
    };
    _this.xrNativeFeatureName = "hit-test";
    Tools.Warn("A newer version of this plugin is available");
    return _this;
  }
  WebXRHitTestLegacy2.XRHitTestWithRay = function(xrSession, xrRay, referenceSpace, filter) {
    return xrSession.requestHitTest(xrRay, referenceSpace).then(function(results) {
      var filterFunction = filter || function(result) {
        return !!result.hitMatrix;
      };
      return results.filter(filterFunction);
    });
  };
  WebXRHitTestLegacy2.XRHitTestWithSelectEvent = function(event, referenceSpace) {
    var targetRayPose = event.frame.getPose(event.inputSource.targetRaySpace, referenceSpace);
    if (!targetRayPose) {
      return Promise.resolve([]);
    }
    var targetRay = new XRRay(targetRayPose.transform);
    return this.XRHitTestWithRay(event.frame.session, targetRay, referenceSpace);
  };
  WebXRHitTestLegacy2.prototype.attach = function() {
    if (!_super.prototype.attach.call(this)) {
      return false;
    }
    if (this.options.testOnPointerDownOnly) {
      this._xrSessionManager.session.addEventListener("select", this._onSelect, false);
    }
    return true;
  };
  WebXRHitTestLegacy2.prototype.detach = function() {
    if (!_super.prototype.detach.call(this)) {
      return false;
    }
    this._onSelectEnabled = false;
    this._xrSessionManager.session.removeEventListener("select", this._onSelect);
    return true;
  };
  WebXRHitTestLegacy2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this.onHitTestResultObservable.clear();
  };
  WebXRHitTestLegacy2.prototype._onXRFrame = function(frame) {
    if (!this.attached || this.options.testOnPointerDownOnly) {
      return;
    }
    var pose = frame.getViewerPose(this._xrSessionManager.referenceSpace);
    if (!pose) {
      return;
    }
    Matrix.FromArrayToRef(pose.transform.matrix, 0, this._mat);
    Vector3.TransformCoordinatesFromFloatsToRef(0, 0, 0, this._mat, this._origin);
    Vector3.TransformCoordinatesFromFloatsToRef(0, 0, -1, this._mat, this._direction);
    this._direction.subtractInPlace(this._origin);
    this._direction.normalize();
    var ray = new XRRay({ x: this._origin.x, y: this._origin.y, z: this._origin.z, w: 0 }, { x: this._direction.x, y: this._direction.y, z: this._direction.z, w: 0 });
    WebXRHitTestLegacy2.XRHitTestWithRay(this._xrSessionManager.session, ray, this._xrSessionManager.referenceSpace).then(this._onHitTestResults);
  };
  WebXRHitTestLegacy2.Name = WebXRFeatureName.HIT_TEST;
  WebXRHitTestLegacy2.Version = 1;
  return WebXRHitTestLegacy2;
}(WebXRAbstractFeature);
WebXRFeaturesManager.AddWebXRFeature(WebXRHitTestLegacy.Name, function(xrSessionManager, options) {
  return function() {
    return new WebXRHitTestLegacy(xrSessionManager, options);
  };
}, WebXRHitTestLegacy.Version, false);

// node_modules/@babylonjs/core/XR/features/WebXRAnchorSystem.js
var anchorIdProvider = 0;
var WebXRAnchorSystem = function(_super) {
  __extends(WebXRAnchorSystem2, _super);
  function WebXRAnchorSystem2(_xrSessionManager, _options) {
    if (_options === void 0) {
      _options = {};
    }
    var _this = _super.call(this, _xrSessionManager) || this;
    _this._options = _options;
    _this._lastFrameDetected = /* @__PURE__ */ new Set();
    _this._trackedAnchors = [];
    _this._futureAnchors = [];
    _this.onAnchorAddedObservable = new Observable();
    _this.onAnchorRemovedObservable = new Observable();
    _this.onAnchorUpdatedObservable = new Observable();
    _this._tmpVector = new Vector3();
    _this._tmpQuaternion = new Quaternion();
    _this.xrNativeFeatureName = "anchors";
    return _this;
  }
  Object.defineProperty(WebXRAnchorSystem2.prototype, "referenceSpaceForFrameAnchors", {
    set: function(referenceSpace) {
      this._referenceSpaceForFrameAnchors = referenceSpace;
    },
    enumerable: false,
    configurable: true
  });
  WebXRAnchorSystem2.prototype._populateTmpTransformation = function(position, rotationQuaternion) {
    this._tmpVector.copyFrom(position);
    this._tmpQuaternion.copyFrom(rotationQuaternion);
    if (!this._xrSessionManager.scene.useRightHandedSystem) {
      this._tmpVector.z *= -1;
      this._tmpQuaternion.z *= -1;
      this._tmpQuaternion.w *= -1;
    }
    return {
      position: this._tmpVector,
      rotationQuaternion: this._tmpQuaternion
    };
  };
  WebXRAnchorSystem2.prototype.addAnchorPointUsingHitTestResultAsync = function(hitTestResult, position, rotationQuaternion) {
    if (position === void 0) {
      position = new Vector3();
    }
    if (rotationQuaternion === void 0) {
      rotationQuaternion = new Quaternion();
    }
    return __awaiter(this, void 0, void 0, function() {
      var m, nativeAnchor_1, error_1;
      var _this = this;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            this._populateTmpTransformation(position, rotationQuaternion);
            m = new XRRigidTransform({ x: this._tmpVector.x, y: this._tmpVector.y, z: this._tmpVector.z }, { x: this._tmpQuaternion.x, y: this._tmpQuaternion.y, z: this._tmpQuaternion.z, w: this._tmpQuaternion.w });
            if (!!hitTestResult.xrHitResult.createAnchor)
              return [3, 1];
            this.detach();
            throw new Error("Anchors not enabled in this environment/browser");
          case 1:
            _a.trys.push([1, 3, , 4]);
            return [4, hitTestResult.xrHitResult.createAnchor(m)];
          case 2:
            nativeAnchor_1 = _a.sent();
            return [2, new Promise(function(resolve, reject) {
              _this._futureAnchors.push({
                nativeAnchor: nativeAnchor_1,
                resolved: false,
                submitted: true,
                xrTransformation: m,
                resolve,
                reject
              });
            })];
          case 3:
            error_1 = _a.sent();
            throw new Error(error_1);
          case 4:
            return [2];
        }
      });
    });
  };
  WebXRAnchorSystem2.prototype.addAnchorAtPositionAndRotationAsync = function(position, rotationQuaternion, forceCreateInCurrentFrame) {
    if (rotationQuaternion === void 0) {
      rotationQuaternion = new Quaternion();
    }
    if (forceCreateInCurrentFrame === void 0) {
      forceCreateInCurrentFrame = false;
    }
    return __awaiter(this, void 0, void 0, function() {
      var xrTransformation, xrAnchor, _a;
      var _this = this;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            this._populateTmpTransformation(position, rotationQuaternion);
            xrTransformation = new XRRigidTransform({ x: this._tmpVector.x, y: this._tmpVector.y, z: this._tmpVector.z }, { x: this._tmpQuaternion.x, y: this._tmpQuaternion.y, z: this._tmpQuaternion.z, w: this._tmpQuaternion.w });
            if (!(forceCreateInCurrentFrame && this.attached && this._xrSessionManager.currentFrame))
              return [3, 2];
            return [4, this._createAnchorAtTransformation(xrTransformation, this._xrSessionManager.currentFrame)];
          case 1:
            _a = _b.sent();
            return [3, 3];
          case 2:
            _a = void 0;
            _b.label = 3;
          case 3:
            xrAnchor = _a;
            return [2, new Promise(function(resolve, reject) {
              _this._futureAnchors.push({
                nativeAnchor: xrAnchor,
                resolved: false,
                submitted: false,
                xrTransformation,
                resolve,
                reject
              });
            })];
        }
      });
    });
  };
  Object.defineProperty(WebXRAnchorSystem2.prototype, "anchors", {
    get: function() {
      return this._trackedAnchors;
    },
    enumerable: false,
    configurable: true
  });
  WebXRAnchorSystem2.prototype.detach = function() {
    if (!_super.prototype.detach.call(this)) {
      return false;
    }
    if (!this._options.doNotRemoveAnchorsOnSessionEnded) {
      while (this._trackedAnchors.length) {
        var toRemove = this._trackedAnchors.pop();
        if (toRemove) {
          try {
            toRemove.remove();
          } catch (e) {
          }
          this.onAnchorRemovedObservable.notifyObservers(toRemove);
        }
      }
    }
    return true;
  };
  WebXRAnchorSystem2.prototype.dispose = function() {
    this._futureAnchors.length = 0;
    _super.prototype.dispose.call(this);
    this.onAnchorAddedObservable.clear();
    this.onAnchorRemovedObservable.clear();
    this.onAnchorUpdatedObservable.clear();
  };
  WebXRAnchorSystem2.prototype._onXRFrame = function(frame) {
    var _this = this;
    if (!this.attached || !frame) {
      return;
    }
    var trackedAnchors = frame.trackedAnchors;
    if (trackedAnchors) {
      var toRemove = this._trackedAnchors.filter(function(anchor) {
        return !trackedAnchors.has(anchor.xrAnchor);
      }).map(function(anchor) {
        var index = _this._trackedAnchors.indexOf(anchor);
        return index;
      });
      var idxTracker_1 = 0;
      toRemove.forEach(function(index) {
        var anchor = _this._trackedAnchors.splice(index - idxTracker_1, 1)[0];
        _this.onAnchorRemovedObservable.notifyObservers(anchor);
        idxTracker_1++;
      });
      trackedAnchors.forEach(function(xrAnchor) {
        if (!_this._lastFrameDetected.has(xrAnchor)) {
          var newAnchor = {
            id: anchorIdProvider++,
            xrAnchor,
            remove: xrAnchor.delete
          };
          var anchor = _this._updateAnchorWithXRFrame(xrAnchor, newAnchor, frame);
          _this._trackedAnchors.push(anchor);
          _this.onAnchorAddedObservable.notifyObservers(anchor);
          var results = _this._futureAnchors.filter(function(futureAnchor) {
            return futureAnchor.nativeAnchor === xrAnchor;
          });
          var result = results[0];
          if (result) {
            result.resolve(anchor);
            result.resolved = true;
          }
        } else {
          var index = _this._findIndexInAnchorArray(xrAnchor);
          var anchor = _this._trackedAnchors[index];
          try {
            _this._updateAnchorWithXRFrame(xrAnchor, anchor, frame);
            if (anchor.attachedNode) {
              anchor.attachedNode.rotationQuaternion = anchor.attachedNode.rotationQuaternion || new Quaternion();
              anchor.transformationMatrix.decompose(anchor.attachedNode.scaling, anchor.attachedNode.rotationQuaternion, anchor.attachedNode.position);
            }
            _this.onAnchorUpdatedObservable.notifyObservers(anchor);
          } catch (e) {
            Tools.Warn("Anchor could not be updated");
          }
        }
      });
      this._lastFrameDetected = trackedAnchors;
    }
    this._futureAnchors.forEach(function(futureAnchor) {
      if (!futureAnchor.resolved && !futureAnchor.submitted) {
        _this._createAnchorAtTransformation(futureAnchor.xrTransformation, frame).then(function(nativeAnchor) {
          futureAnchor.nativeAnchor = nativeAnchor;
        }, function(error) {
          futureAnchor.resolved = true;
          futureAnchor.reject(error);
        });
        futureAnchor.submitted = true;
      }
    });
  };
  WebXRAnchorSystem2.prototype._findIndexInAnchorArray = function(xrAnchor) {
    for (var i = 0; i < this._trackedAnchors.length; ++i) {
      if (this._trackedAnchors[i].xrAnchor === xrAnchor) {
        return i;
      }
    }
    return -1;
  };
  WebXRAnchorSystem2.prototype._updateAnchorWithXRFrame = function(xrAnchor, anchor, xrFrame) {
    var pose = xrFrame.getPose(xrAnchor.anchorSpace, this._xrSessionManager.referenceSpace);
    if (pose) {
      var mat = anchor.transformationMatrix || new Matrix();
      Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);
      if (!this._xrSessionManager.scene.useRightHandedSystem) {
        mat.toggleModelMatrixHandInPlace();
      }
      anchor.transformationMatrix = mat;
      if (!this._options.worldParentNode) {
      } else {
        mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);
      }
    }
    return anchor;
  };
  WebXRAnchorSystem2.prototype._createAnchorAtTransformation = function(xrTransformation, xrFrame) {
    var _a;
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_b) {
        if (xrFrame.createAnchor) {
          try {
            return [2, xrFrame.createAnchor(xrTransformation, (_a = this._referenceSpaceForFrameAnchors) !== null && _a !== void 0 ? _a : this._xrSessionManager.referenceSpace)];
          } catch (error) {
            throw new Error(error);
          }
        } else {
          this.detach();
          throw new Error("Anchors are not enabled in your browser");
        }
        return [2];
      });
    });
  };
  WebXRAnchorSystem2.Name = WebXRFeatureName.ANCHOR_SYSTEM;
  WebXRAnchorSystem2.Version = 1;
  return WebXRAnchorSystem2;
}(WebXRAbstractFeature);
WebXRFeaturesManager.AddWebXRFeature(WebXRAnchorSystem.Name, function(xrSessionManager, options) {
  return function() {
    return new WebXRAnchorSystem(xrSessionManager, options);
  };
}, WebXRAnchorSystem.Version);

// node_modules/@babylonjs/core/XR/features/WebXRPlaneDetector.js
var planeIdProvider = 0;
var WebXRPlaneDetector = function(_super) {
  __extends(WebXRPlaneDetector2, _super);
  function WebXRPlaneDetector2(_xrSessionManager, _options) {
    if (_options === void 0) {
      _options = {};
    }
    var _this = _super.call(this, _xrSessionManager) || this;
    _this._options = _options;
    _this._detectedPlanes = [];
    _this._enabled = false;
    _this._lastFrameDetected = /* @__PURE__ */ new Set();
    _this.onPlaneAddedObservable = new Observable();
    _this.onPlaneRemovedObservable = new Observable();
    _this.onPlaneUpdatedObservable = new Observable();
    _this.xrNativeFeatureName = "plane-detection";
    if (_this._xrSessionManager.session) {
      _this._init();
    } else {
      _this._xrSessionManager.onXRSessionInit.addOnce(function() {
        _this._init();
      });
    }
    return _this;
  }
  WebXRPlaneDetector2.prototype.detach = function() {
    if (!_super.prototype.detach.call(this)) {
      return false;
    }
    if (!this._options.doNotRemovePlanesOnSessionEnded) {
      while (this._detectedPlanes.length) {
        var toRemove = this._detectedPlanes.pop();
        if (toRemove) {
          this.onPlaneRemovedObservable.notifyObservers(toRemove);
        }
      }
    }
    return true;
  };
  WebXRPlaneDetector2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this.onPlaneAddedObservable.clear();
    this.onPlaneRemovedObservable.clear();
    this.onPlaneUpdatedObservable.clear();
  };
  WebXRPlaneDetector2.prototype.isCompatible = function() {
    return typeof XRPlane !== "undefined";
  };
  WebXRPlaneDetector2.prototype._onXRFrame = function(frame) {
    var _this = this;
    if (!this.attached || !this._enabled || !frame) {
      return;
    }
    var detectedPlanes = frame.worldInformation.detectedPlanes;
    if (detectedPlanes) {
      var toRemove = this._detectedPlanes.filter(function(plane) {
        return !detectedPlanes.has(plane.xrPlane);
      }).map(function(plane) {
        return _this._detectedPlanes.indexOf(plane);
      });
      var idxTracker_1 = 0;
      toRemove.forEach(function(index) {
        var plane = _this._detectedPlanes.splice(index - idxTracker_1, 1)[0];
        _this.onPlaneRemovedObservable.notifyObservers(plane);
        idxTracker_1++;
      });
      detectedPlanes.forEach(function(xrPlane) {
        if (!_this._lastFrameDetected.has(xrPlane)) {
          var newPlane = {
            id: planeIdProvider++,
            xrPlane,
            polygonDefinition: []
          };
          var plane = _this._updatePlaneWithXRPlane(xrPlane, newPlane, frame);
          _this._detectedPlanes.push(plane);
          _this.onPlaneAddedObservable.notifyObservers(plane);
        } else {
          if (xrPlane.lastChangedTime === _this._xrSessionManager.currentTimestamp) {
            var index = _this.findIndexInPlaneArray(xrPlane);
            var plane = _this._detectedPlanes[index];
            _this._updatePlaneWithXRPlane(xrPlane, plane, frame);
            _this.onPlaneUpdatedObservable.notifyObservers(plane);
          }
        }
      });
      this._lastFrameDetected = detectedPlanes;
    }
  };
  WebXRPlaneDetector2.prototype._init = function() {
    var _this = this;
    var _a, _b;
    var internalInit = function() {
      _this._enabled = true;
      if (_this._detectedPlanes.length) {
        _this._detectedPlanes.length = 0;
      }
    };
    if (!this._xrSessionManager.session.updateWorldTrackingState) {
      var alreadyEnabled = (_b = (_a = this._xrSessionManager.session.worldTrackingState) === null || _a === void 0 ? void 0 : _a.planeDetectionState) === null || _b === void 0 ? void 0 : _b.enabled;
      if (alreadyEnabled) {
        internalInit();
      }
      return;
    }
    this._xrSessionManager.session.updateWorldTrackingState({ planeDetectionState: { enabled: true } });
    internalInit();
  };
  WebXRPlaneDetector2.prototype._updatePlaneWithXRPlane = function(xrPlane, plane, xrFrame) {
    var _this = this;
    plane.polygonDefinition = xrPlane.polygon.map(function(xrPoint) {
      var rightHandedSystem = _this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1;
      return new Vector3(xrPoint.x, xrPoint.y, xrPoint.z * rightHandedSystem);
    });
    var pose = xrFrame.getPose(xrPlane.planeSpace, this._xrSessionManager.referenceSpace);
    if (pose) {
      var mat = plane.transformationMatrix || new Matrix();
      Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);
      if (!this._xrSessionManager.scene.useRightHandedSystem) {
        mat.toggleModelMatrixHandInPlace();
      }
      plane.transformationMatrix = mat;
      if (this._options.worldParentNode) {
        mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);
      }
    }
    return plane;
  };
  WebXRPlaneDetector2.prototype.findIndexInPlaneArray = function(xrPlane) {
    for (var i = 0; i < this._detectedPlanes.length; ++i) {
      if (this._detectedPlanes[i].xrPlane === xrPlane) {
        return i;
      }
    }
    return -1;
  };
  WebXRPlaneDetector2.Name = WebXRFeatureName.PLANE_DETECTION;
  WebXRPlaneDetector2.Version = 1;
  return WebXRPlaneDetector2;
}(WebXRAbstractFeature);
WebXRFeaturesManager.AddWebXRFeature(WebXRPlaneDetector.Name, function(xrSessionManager, options) {
  return function() {
    return new WebXRPlaneDetector(xrSessionManager, options);
  };
}, WebXRPlaneDetector.Version);

// node_modules/@babylonjs/core/XR/features/WebXRBackgroundRemover.js
var WebXRBackgroundRemover = function(_super) {
  __extends(WebXRBackgroundRemover2, _super);
  function WebXRBackgroundRemover2(_xrSessionManager, options) {
    if (options === void 0) {
      options = {};
    }
    var _this = _super.call(this, _xrSessionManager) || this;
    _this.options = options;
    _this.onBackgroundStateChangedObservable = new Observable();
    return _this;
  }
  WebXRBackgroundRemover2.prototype.attach = function() {
    this._setBackgroundState(false);
    return _super.prototype.attach.call(this);
  };
  WebXRBackgroundRemover2.prototype.detach = function() {
    this._setBackgroundState(true);
    return _super.prototype.detach.call(this);
  };
  WebXRBackgroundRemover2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this.onBackgroundStateChangedObservable.clear();
  };
  WebXRBackgroundRemover2.prototype._onXRFrame = function(_xrFrame) {
  };
  WebXRBackgroundRemover2.prototype._setBackgroundState = function(newState) {
    var scene = this._xrSessionManager.scene;
    if (!this.options.ignoreEnvironmentHelper) {
      if (this.options.environmentHelperRemovalFlags) {
        if (this.options.environmentHelperRemovalFlags.skyBox) {
          var backgroundSkybox = scene.getMeshByName("BackgroundSkybox");
          if (backgroundSkybox) {
            backgroundSkybox.setEnabled(newState);
          }
        }
        if (this.options.environmentHelperRemovalFlags.ground) {
          var backgroundPlane = scene.getMeshByName("BackgroundPlane");
          if (backgroundPlane) {
            backgroundPlane.setEnabled(newState);
          }
        }
      } else {
        var backgroundHelper = scene.getMeshByName("BackgroundHelper");
        if (backgroundHelper) {
          backgroundHelper.setEnabled(newState);
        }
      }
    }
    if (this.options.backgroundMeshes) {
      this.options.backgroundMeshes.forEach(function(mesh) {
        return mesh.setEnabled(newState);
      });
    }
    this.onBackgroundStateChangedObservable.notifyObservers(newState);
  };
  WebXRBackgroundRemover2.Name = WebXRFeatureName.BACKGROUND_REMOVER;
  WebXRBackgroundRemover2.Version = 1;
  return WebXRBackgroundRemover2;
}(WebXRAbstractFeature);
WebXRFeaturesManager.AddWebXRFeature(WebXRBackgroundRemover.Name, function(xrSessionManager, options) {
  return function() {
    return new WebXRBackgroundRemover(xrSessionManager, options);
  };
}, WebXRBackgroundRemover.Version, true);

// node_modules/@babylonjs/core/XR/features/WebXRControllerPhysics.js
var IWebXRControllerPhysicsOptions = function() {
  function IWebXRControllerPhysicsOptions2() {
  }
  return IWebXRControllerPhysicsOptions2;
}();
var WebXRControllerPhysics = function(_super) {
  __extends(WebXRControllerPhysics2, _super);
  function WebXRControllerPhysics2(_xrSessionManager, _options) {
    var _this = _super.call(this, _xrSessionManager) || this;
    _this._options = _options;
    _this._attachController = function(xrController) {
      if (_this._controllers[xrController.uniqueId]) {
        return;
      }
      if (!_this._xrSessionManager.scene.isPhysicsEnabled()) {
        Logger.Warn("physics engine not enabled, skipped. Please add this controller manually.");
      }
      if (_this._options.physicsProperties.useControllerMesh && xrController.inputSource.gamepad) {
        xrController.onMotionControllerInitObservable.addOnce(function(motionController) {
          motionController.onModelLoadedObservable.addOnce(function() {
            var impostor2 = new PhysicsImpostor(motionController.rootMesh, PhysicsImpostor.MeshImpostor, __assign({ mass: 0 }, _this._options.physicsProperties));
            var controllerMesh2 = xrController.grip || xrController.pointer;
            _this._controllers[xrController.uniqueId] = {
              xrController,
              impostor: impostor2,
              oldPos: controllerMesh2.position.clone(),
              oldRotation: controllerMesh2.rotationQuaternion.clone()
            };
          });
        });
      } else {
        var impostorType = _this._options.physicsProperties.impostorType || PhysicsImpostor.SphereImpostor;
        var impostorSize = _this._options.physicsProperties.impostorSize || 0.1;
        var impostorMesh = SphereBuilder.CreateSphere("impostor-mesh-" + xrController.uniqueId, {
          diameterX: typeof impostorSize === "number" ? impostorSize : impostorSize.width,
          diameterY: typeof impostorSize === "number" ? impostorSize : impostorSize.height,
          diameterZ: typeof impostorSize === "number" ? impostorSize : impostorSize.depth
        });
        impostorMesh.isVisible = _this._debugMode;
        impostorMesh.isPickable = false;
        impostorMesh.rotationQuaternion = new Quaternion();
        var controllerMesh = xrController.grip || xrController.pointer;
        impostorMesh.position.copyFrom(controllerMesh.position);
        impostorMesh.rotationQuaternion.copyFrom(controllerMesh.rotationQuaternion);
        var impostor = new PhysicsImpostor(impostorMesh, impostorType, __assign({ mass: 0 }, _this._options.physicsProperties));
        _this._controllers[xrController.uniqueId] = {
          xrController,
          impostor,
          impostorMesh
        };
      }
    };
    _this._controllers = {};
    _this._debugMode = false;
    _this._delta = 0;
    _this._lastTimestamp = 0;
    _this._tmpQuaternion = new Quaternion();
    _this._tmpVector = new Vector3();
    if (!_this._options.physicsProperties) {
      _this._options.physicsProperties = {};
    }
    return _this;
  }
  WebXRControllerPhysics2.prototype._enablePhysicsDebug = function() {
    var _this = this;
    this._debugMode = true;
    Object.keys(this._controllers).forEach(function(controllerId) {
      var controllerData = _this._controllers[controllerId];
      if (controllerData.impostorMesh) {
        controllerData.impostorMesh.isVisible = true;
      }
    });
  };
  WebXRControllerPhysics2.prototype.addController = function(xrController) {
    this._attachController(xrController);
  };
  WebXRControllerPhysics2.prototype.attach = function() {
    var _this = this;
    if (!_super.prototype.attach.call(this)) {
      return false;
    }
    if (!this._options.xrInput) {
      return true;
    }
    this._options.xrInput.controllers.forEach(this._attachController);
    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);
    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, function(controller) {
      _this._detachController(controller.uniqueId);
    });
    if (this._options.enableHeadsetImpostor) {
      var params = this._options.headsetImpostorParams || {
        impostorType: PhysicsImpostor.SphereImpostor,
        restitution: 0.8,
        impostorSize: 0.3
      };
      var impostorSize = params.impostorSize || 0.3;
      this._headsetMesh = SphereBuilder.CreateSphere("headset-mesh", {
        diameterX: typeof impostorSize === "number" ? impostorSize : impostorSize.width,
        diameterY: typeof impostorSize === "number" ? impostorSize : impostorSize.height,
        diameterZ: typeof impostorSize === "number" ? impostorSize : impostorSize.depth
      });
      this._headsetMesh.rotationQuaternion = new Quaternion();
      this._headsetMesh.isVisible = false;
      this._headsetImpostor = new PhysicsImpostor(this._headsetMesh, params.impostorType, __assign({ mass: 0 }, params));
    }
    return true;
  };
  WebXRControllerPhysics2.prototype.detach = function() {
    var _this = this;
    if (!_super.prototype.detach.call(this)) {
      return false;
    }
    Object.keys(this._controllers).forEach(function(controllerId) {
      _this._detachController(controllerId);
    });
    if (this._headsetMesh) {
      this._headsetMesh.dispose();
    }
    return true;
  };
  WebXRControllerPhysics2.prototype.getHeadsetImpostor = function() {
    return this._headsetImpostor;
  };
  WebXRControllerPhysics2.prototype.getImpostorForController = function(controller) {
    var id = typeof controller === "string" ? controller : controller.uniqueId;
    if (this._controllers[id]) {
      return this._controllers[id].impostor;
    } else {
      return null;
    }
  };
  WebXRControllerPhysics2.prototype.setPhysicsProperties = function(newProperties) {
    this._options.physicsProperties = __assign(__assign({}, this._options.physicsProperties), newProperties);
  };
  WebXRControllerPhysics2.prototype._onXRFrame = function(_xrFrame) {
    var _this = this;
    this._delta = this._xrSessionManager.currentTimestamp - this._lastTimestamp;
    this._lastTimestamp = this._xrSessionManager.currentTimestamp;
    if (this._headsetMesh) {
      this._headsetMesh.position.copyFrom(this._options.xrInput.xrCamera.position);
      this._headsetMesh.rotationQuaternion.copyFrom(this._options.xrInput.xrCamera.rotationQuaternion);
    }
    Object.keys(this._controllers).forEach(function(controllerId) {
      var controllerData = _this._controllers[controllerId];
      var controllerMesh = controllerData.xrController.grip || controllerData.xrController.pointer;
      var comparedPosition = controllerData.oldPos || controllerData.impostorMesh.position;
      var comparedQuaternion = controllerData.oldRotation || controllerData.impostorMesh.rotationQuaternion;
      controllerMesh.position.subtractToRef(comparedPosition, _this._tmpVector);
      _this._tmpVector.scaleInPlace(1e3 / _this._delta);
      controllerData.impostor.setLinearVelocity(_this._tmpVector);
      if (_this._debugMode) {
        console.log(_this._tmpVector, "linear");
      }
      if (!comparedQuaternion.equalsWithEpsilon(controllerMesh.rotationQuaternion)) {
        comparedQuaternion.conjugateInPlace().multiplyToRef(controllerMesh.rotationQuaternion, _this._tmpQuaternion);
        var len = Math.sqrt(_this._tmpQuaternion.x * _this._tmpQuaternion.x + _this._tmpQuaternion.y * _this._tmpQuaternion.y + _this._tmpQuaternion.z * _this._tmpQuaternion.z);
        _this._tmpVector.set(_this._tmpQuaternion.x, _this._tmpQuaternion.y, _this._tmpQuaternion.z);
        if (len < 1e-3) {
          _this._tmpVector.scaleInPlace(2);
        } else {
          var angle = 2 * Math.atan2(len, _this._tmpQuaternion.w);
          _this._tmpVector.scaleInPlace(angle / (len * (_this._delta / 1e3)));
        }
        controllerData.impostor.setAngularVelocity(_this._tmpVector);
        if (_this._debugMode) {
          console.log(_this._tmpVector, _this._tmpQuaternion, "angular");
        }
      }
      comparedPosition.copyFrom(controllerMesh.position);
      comparedQuaternion.copyFrom(controllerMesh.rotationQuaternion);
    });
  };
  WebXRControllerPhysics2.prototype._detachController = function(xrControllerUniqueId) {
    var controllerData = this._controllers[xrControllerUniqueId];
    if (!controllerData) {
      return;
    }
    if (controllerData.impostorMesh) {
      controllerData.impostorMesh.dispose();
    }
    delete this._controllers[xrControllerUniqueId];
  };
  WebXRControllerPhysics2.Name = WebXRFeatureName.PHYSICS_CONTROLLERS;
  WebXRControllerPhysics2.Version = 1;
  return WebXRControllerPhysics2;
}(WebXRAbstractFeature);
WebXRFeaturesManager.AddWebXRFeature(WebXRControllerPhysics.Name, function(xrSessionManager, options) {
  return function() {
    return new WebXRControllerPhysics(xrSessionManager, options);
  };
}, WebXRControllerPhysics.Version, true);

// node_modules/@babylonjs/core/XR/features/WebXRHitTest.js
var WebXRHitTest = function(_super) {
  __extends(WebXRHitTest2, _super);
  function WebXRHitTest2(_xrSessionManager, options) {
    if (options === void 0) {
      options = {};
    }
    var _this = _super.call(this, _xrSessionManager) || this;
    _this.options = options;
    _this._tmpMat = new Matrix();
    _this._tmpPos = new Vector3();
    _this._tmpQuat = new Quaternion();
    _this.initHitTestSource = function(referenceSpace) {
      if (!referenceSpace) {
        return;
      }
      var offsetRay = new XRRay(_this.options.offsetRay || {});
      var hitTestOptions = {
        space: _this.options.useReferenceSpace ? referenceSpace : _this._xrSessionManager.viewerReferenceSpace,
        offsetRay
      };
      if (_this.options.entityTypes) {
        hitTestOptions.entityTypes = _this.options.entityTypes;
      }
      if (!hitTestOptions.space) {
        Tools.Warn("waiting for viewer reference space to initialize");
        return;
      }
      _this._xrSessionManager.session.requestHitTestSource(hitTestOptions).then(function(hitTestSource) {
        if (_this._xrHitTestSource) {
          _this._xrHitTestSource.cancel();
        }
        _this._xrHitTestSource = hitTestSource;
      });
    };
    _this.autoCloneTransformation = false;
    _this.onHitTestResultObservable = new Observable();
    _this.paused = false;
    _this.xrNativeFeatureName = "hit-test";
    Tools.Warn("Hit test is an experimental and unstable feature.");
    return _this;
  }
  WebXRHitTest2.prototype.attach = function() {
    var _this = this;
    if (!_super.prototype.attach.call(this)) {
      return false;
    }
    if (!this._xrSessionManager.session.requestHitTestSource) {
      return false;
    }
    if (!this.options.disablePermanentHitTest) {
      if (this._xrSessionManager.referenceSpace) {
        this.initHitTestSource(this._xrSessionManager.referenceSpace);
      }
      this._xrSessionManager.onXRReferenceSpaceChanged.add(this.initHitTestSource);
    }
    if (this.options.enableTransientHitTest) {
      var offsetRay = new XRRay(this.options.transientOffsetRay || {});
      this._xrSessionManager.session.requestHitTestSourceForTransientInput({
        profile: "generic-touchscreen",
        offsetRay,
        entityTypes: this.options.entityTypes
      }).then(function(hitSource) {
        _this._transientXrHitTestSource = hitSource;
      });
    }
    return true;
  };
  WebXRHitTest2.prototype.detach = function() {
    if (!_super.prototype.detach.call(this)) {
      return false;
    }
    if (this._xrHitTestSource) {
      this._xrHitTestSource.cancel();
      this._xrHitTestSource = null;
    }
    this._xrSessionManager.onXRReferenceSpaceChanged.removeCallback(this.initHitTestSource);
    if (this._transientXrHitTestSource) {
      this._transientXrHitTestSource.cancel();
      this._transientXrHitTestSource = null;
    }
    return true;
  };
  WebXRHitTest2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this.onHitTestResultObservable.clear();
  };
  WebXRHitTest2.prototype._onXRFrame = function(frame) {
    var _this = this;
    if (!this.attached || this.paused) {
      return;
    }
    if (this._xrHitTestSource) {
      var results = frame.getHitTestResults(this._xrHitTestSource);
      this._processWebXRHitTestResult(results);
    }
    if (this._transientXrHitTestSource) {
      var hitTestResultsPerInputSource = frame.getHitTestResultsForTransientInput(this._transientXrHitTestSource);
      hitTestResultsPerInputSource.forEach(function(resultsPerInputSource) {
        _this._processWebXRHitTestResult(resultsPerInputSource.results, resultsPerInputSource.inputSource);
      });
    }
  };
  WebXRHitTest2.prototype._processWebXRHitTestResult = function(hitTestResults, inputSource) {
    var _this = this;
    var results = [];
    hitTestResults.forEach(function(hitTestResult) {
      var pose = hitTestResult.getPose(_this._xrSessionManager.referenceSpace);
      if (!pose) {
        return;
      }
      var pos = pose.transform.position;
      var quat = pose.transform.orientation;
      _this._tmpPos.set(pos.x, pos.y, pos.z);
      _this._tmpQuat.set(quat.x, quat.y, quat.z, quat.w);
      Matrix.FromFloat32ArrayToRefScaled(pose.transform.matrix, 0, 1, _this._tmpMat);
      if (!_this._xrSessionManager.scene.useRightHandedSystem) {
        _this._tmpPos.z *= -1;
        _this._tmpQuat.z *= -1;
        _this._tmpQuat.w *= -1;
        _this._tmpMat.toggleModelMatrixHandInPlace();
      }
      var result = {
        position: _this.autoCloneTransformation ? _this._tmpPos.clone() : _this._tmpPos,
        rotationQuaternion: _this.autoCloneTransformation ? _this._tmpQuat.clone() : _this._tmpQuat,
        transformationMatrix: _this.autoCloneTransformation ? _this._tmpMat.clone() : _this._tmpMat,
        inputSource,
        isTransient: !!inputSource,
        xrHitResult: hitTestResult
      };
      results.push(result);
    });
    this.onHitTestResultObservable.notifyObservers(results);
  };
  WebXRHitTest2.Name = WebXRFeatureName.HIT_TEST;
  WebXRHitTest2.Version = 2;
  return WebXRHitTest2;
}(WebXRAbstractFeature);
WebXRFeaturesManager.AddWebXRFeature(WebXRHitTest.Name, function(xrSessionManager, options) {
  return function() {
    return new WebXRHitTest(xrSessionManager, options);
  };
}, WebXRHitTest.Version, false);

// node_modules/@babylonjs/core/XR/features/WebXRFeaturePointSystem.js
var WebXRFeaturePointSystem = function(_super) {
  __extends(WebXRFeaturePointSystem2, _super);
  function WebXRFeaturePointSystem2(_xrSessionManager) {
    var _this = _super.call(this, _xrSessionManager) || this;
    _this._enabled = false;
    _this._featurePointCloud = [];
    _this.onFeaturePointsAddedObservable = new Observable();
    _this.onFeaturePointsUpdatedObservable = new Observable();
    _this.xrNativeFeatureName = "bjsfeature-points";
    if (_this._xrSessionManager.session) {
      _this._init();
    } else {
      _this._xrSessionManager.onXRSessionInit.addOnce(function() {
        _this._init();
      });
    }
    return _this;
  }
  Object.defineProperty(WebXRFeaturePointSystem2.prototype, "featurePointCloud", {
    get: function() {
      return this._featurePointCloud;
    },
    enumerable: false,
    configurable: true
  });
  WebXRFeaturePointSystem2.prototype.detach = function() {
    if (!_super.prototype.detach.call(this)) {
      return false;
    }
    this.featurePointCloud.length = 0;
    return true;
  };
  WebXRFeaturePointSystem2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this._featurePointCloud.length = 0;
    this.onFeaturePointsUpdatedObservable.clear();
    this.onFeaturePointsAddedObservable.clear();
  };
  WebXRFeaturePointSystem2.prototype._onXRFrame = function(frame) {
    if (!this.attached || !this._enabled || !frame) {
      return;
    }
    var featurePointRawData = frame.featurePointCloud;
    if (!featurePointRawData || featurePointRawData.length === 0) {
      return;
    } else {
      if (featurePointRawData.length % 5 !== 0) {
        throw new Error("Received malformed feature point cloud of length: " + featurePointRawData.length);
      }
      var numberOfFeaturePoints = featurePointRawData.length / 5;
      var updatedFeaturePoints = new Array();
      var addedFeaturePoints = new Array();
      for (var i = 0; i < numberOfFeaturePoints; i++) {
        var rawIndex = i * 5;
        var id = featurePointRawData[rawIndex + 4];
        if (!this._featurePointCloud[id]) {
          this._featurePointCloud[id] = { position: new Vector3(), confidenceValue: 0 };
          addedFeaturePoints.push(id);
        } else {
          updatedFeaturePoints.push(id);
        }
        this._featurePointCloud[id].position.x = featurePointRawData[rawIndex];
        this._featurePointCloud[id].position.y = featurePointRawData[rawIndex + 1];
        this._featurePointCloud[id].position.z = featurePointRawData[rawIndex + 2];
        this._featurePointCloud[id].confidenceValue = featurePointRawData[rawIndex + 3];
      }
      if (addedFeaturePoints.length > 0) {
        this.onFeaturePointsAddedObservable.notifyObservers(addedFeaturePoints);
      }
      if (updatedFeaturePoints.length > 0) {
        this.onFeaturePointsUpdatedObservable.notifyObservers(updatedFeaturePoints);
      }
    }
  };
  WebXRFeaturePointSystem2.prototype._init = function() {
    if (!this._xrSessionManager.session.trySetFeaturePointCloudEnabled || !this._xrSessionManager.session.trySetFeaturePointCloudEnabled(true)) {
      return;
    }
    this._enabled = true;
  };
  WebXRFeaturePointSystem2.Name = WebXRFeatureName.FEATURE_POINTS;
  WebXRFeaturePointSystem2.Version = 1;
  return WebXRFeaturePointSystem2;
}(WebXRAbstractFeature);
WebXRFeaturesManager.AddWebXRFeature(WebXRFeaturePointSystem.Name, function(xrSessionManager) {
  return function() {
    return new WebXRFeaturePointSystem(xrSessionManager);
  };
}, WebXRFeaturePointSystem.Version);

// node_modules/@babylonjs/core/XR/features/WebXRHandTracking.js
var WebXRHand = function() {
  function WebXRHand2(xrController, trackedMeshes, _handMesh, _rigMapping, disableDefaultHandMesh) {
    this.xrController = xrController;
    this.trackedMeshes = trackedMeshes;
    this._handMesh = _handMesh;
    this._rigMapping = _rigMapping;
    this._defaultHandMesh = false;
    this._transformNodeMapping = [];
    this.handPartsDefinition = this.generateHandPartsDefinition(xrController.inputSource.hand);
    this._scene = trackedMeshes[0].getScene();
    if (this._handMesh && this._rigMapping) {
      this._defaultHandMesh = false;
    } else {
      if (!disableDefaultHandMesh) {
        this._generateDefaultHandMesh();
      }
    }
    if (this.xrController.motionController) {
      if (this.xrController.motionController.rootMesh) {
        this.xrController.motionController.rootMesh.setEnabled(false);
      } else {
        this.xrController.motionController.onModelLoadedObservable.add(function(controller) {
          if (controller.rootMesh) {
            controller.rootMesh.setEnabled(false);
          }
        });
      }
    }
    this.xrController.onMotionControllerInitObservable.add(function(motionController) {
      motionController.onModelLoadedObservable.add(function(controller) {
        if (controller.rootMesh) {
          controller.rootMesh.setEnabled(false);
        }
      });
      if (motionController.rootMesh) {
        motionController.rootMesh.setEnabled(false);
      }
    });
  }
  WebXRHand2.prototype.generateHandPartsDefinition = function(hand) {
    var _a;
    return _a = {}, _a["wrist"] = [hand.WRIST], _a["thumb"] = [hand.THUMB_METACARPAL, hand.THUMB_PHALANX_PROXIMAL, hand.THUMB_PHALANX_DISTAL, hand.THUMB_PHALANX_TIP], _a["index"] = [hand.INDEX_METACARPAL, hand.INDEX_PHALANX_PROXIMAL, hand.INDEX_PHALANX_INTERMEDIATE, hand.INDEX_PHALANX_DISTAL, hand.INDEX_PHALANX_TIP], _a["middle"] = [hand.MIDDLE_METACARPAL, hand.MIDDLE_PHALANX_PROXIMAL, hand.MIDDLE_PHALANX_INTERMEDIATE, hand.MIDDLE_PHALANX_DISTAL, hand.MIDDLE_PHALANX_TIP], _a["ring"] = [hand.RING_METACARPAL, hand.RING_PHALANX_PROXIMAL, hand.RING_PHALANX_INTERMEDIATE, hand.RING_PHALANX_DISTAL, hand.RING_PHALANX_TIP], _a["little"] = [hand.LITTLE_METACARPAL, hand.LITTLE_PHALANX_PROXIMAL, hand.LITTLE_PHALANX_INTERMEDIATE, hand.LITTLE_PHALANX_DISTAL, hand.LITTLE_PHALANX_TIP], _a;
  };
  WebXRHand2.prototype.updateFromXRFrame = function(xrFrame, referenceSpace, scaleFactor) {
    var _this = this;
    if (scaleFactor === void 0) {
      scaleFactor = 2;
    }
    var hand = this.xrController.inputSource.hand;
    if (!hand) {
      return;
    }
    this.trackedMeshes.forEach(function(mesh, idx) {
      var xrJoint = hand[idx];
      if (xrJoint) {
        var pose = xrFrame.getJointPose(xrJoint, referenceSpace);
        if (!pose || !pose.transform) {
          return;
        }
        var pos = pose.transform.position;
        var orientation_1 = pose.transform.orientation;
        mesh.position.set(pos.x, pos.y, pos.z);
        mesh.rotationQuaternion.set(orientation_1.x, orientation_1.y, orientation_1.z, orientation_1.w);
        var radius = (pose.radius || 8e-3) * scaleFactor;
        mesh.scaling.set(radius, radius, radius);
        if (_this._handMesh && _this._rigMapping) {
          if (_this._rigMapping[idx]) {
            _this._transformNodeMapping[idx] = _this._transformNodeMapping[idx] || _this._scene.getTransformNodeByName(_this._rigMapping[idx]);
            if (_this._transformNodeMapping[idx]) {
              _this._transformNodeMapping[idx].position.copyFrom(mesh.position);
              _this._transformNodeMapping[idx].rotationQuaternion.copyFrom(mesh.rotationQuaternion);
              mesh.isVisible = false;
            }
          }
        }
        if (!mesh.getScene().useRightHandedSystem) {
          mesh.position.z *= -1;
          mesh.rotationQuaternion.z *= -1;
          mesh.rotationQuaternion.w *= -1;
        }
      }
    });
  };
  WebXRHand2.prototype.getHandPartMeshes = function(part) {
    var _this = this;
    return this.handPartsDefinition[part].map(function(idx) {
      return _this.trackedMeshes[idx];
    });
  };
  WebXRHand2.prototype.dispose = function() {
    this.trackedMeshes.forEach(function(mesh) {
      return mesh.dispose();
    });
    if (this._defaultHandMesh && this._handMesh) {
      this._handMesh.dispose();
    }
  };
  WebXRHand2.prototype._generateDefaultHandMesh = function() {
    return __awaiter(this, void 0, void 0, function() {
      var handedness_1, filename, loaded, handColors, handShader, handNodes, tm, e_1;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            _a.trys.push([0, 3, , 4]);
            handedness_1 = this.xrController.inputSource.handedness === "right" ? "right" : "left";
            filename = (handedness_1 === "right" ? "r" : "l") + "_hand_" + (this._scene.useRightHandedSystem ? "r" : "l") + "hs.glb";
            return [4, SceneLoader.ImportMeshAsync("", "https://assets.babylonjs.com/meshes/HandMeshes/", filename, this._scene)];
          case 1:
            loaded = _a.sent();
            handColors = {
              base: Color3.FromInts(116, 63, 203),
              fresnel: Color3.FromInts(149, 102, 229),
              fingerColor: Color3.FromInts(177, 130, 255),
              tipFresnel: Color3.FromInts(220, 200, 255)
            };
            handShader = new NodeMaterial("leftHandShader", this._scene, { emitComments: false });
            return [4, handShader.loadAsync("https://patrickryanms.github.io/BabylonJStextures/Demos/xrHandMesh/handsShader.json")];
          case 2:
            _a.sent();
            handShader.build(false);
            handShader.needDepthPrePass = true;
            handShader.transparencyMode = Material.MATERIAL_ALPHABLEND;
            handShader.alphaMode = Engine.ALPHA_COMBINE;
            handNodes = {
              base: handShader.getBlockByName("baseColor"),
              fresnel: handShader.getBlockByName("fresnelColor"),
              fingerColor: handShader.getBlockByName("fingerColor"),
              tipFresnel: handShader.getBlockByName("tipFresnelColor")
            };
            handNodes.base.value = handColors.base;
            handNodes.fresnel.value = handColors.fresnel;
            handNodes.fingerColor.value = handColors.fingerColor;
            handNodes.tipFresnel.value = handColors.tipFresnel;
            loaded.meshes[1].material = handShader;
            this._defaultHandMesh = true;
            this._handMesh = loaded.meshes[0];
            this._rigMapping = [
              "wrist_",
              "thumb_metacarpal_",
              "thumb_proxPhalanx_",
              "thumb_distPhalanx_",
              "thumb_tip_",
              "index_metacarpal_",
              "index_proxPhalanx_",
              "index_intPhalanx_",
              "index_distPhalanx_",
              "index_tip_",
              "middle_metacarpal_",
              "middle_proxPhalanx_",
              "middle_intPhalanx_",
              "middle_distPhalanx_",
              "middle_tip_",
              "ring_metacarpal_",
              "ring_proxPhalanx_",
              "ring_intPhalanx_",
              "ring_distPhalanx_",
              "ring_tip_",
              "little_metacarpal_",
              "little_proxPhalanx_",
              "little_intPhalanx_",
              "little_distPhalanx_",
              "little_tip_"
            ].map(function(joint) {
              return "" + joint + (handedness_1 === "right" ? "R" : "L");
            });
            tm = this._scene.getTransformNodeByName(this._rigMapping[0]);
            if (!tm) {
              throw new Error("could not find the wrist node");
            } else {
              tm.parent && tm.parent.rotate(Axis.Y, Math.PI);
            }
            return [3, 4];
          case 3:
            e_1 = _a.sent();
            Tools.Error("error loading hand mesh");
            console.log(e_1);
            return [3, 4];
          case 4:
            return [2];
        }
      });
    });
  };
  return WebXRHand2;
}();
var WebXRHandTracking = function(_super) {
  __extends(WebXRHandTracking2, _super);
  function WebXRHandTracking2(_xrSessionManager, options) {
    var _this = _super.call(this, _xrSessionManager) || this;
    _this.options = options;
    _this.onHandAddedObservable = new Observable();
    _this.onHandRemovedObservable = new Observable();
    _this._hands = {};
    _this._attachHand = function(xrController) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      if (!xrController.inputSource.hand || _this._hands[xrController.uniqueId]) {
        return;
      }
      var hand = xrController.inputSource.hand;
      var trackedMeshes = [];
      var originalMesh = ((_a = _this.options.jointMeshes) === null || _a === void 0 ? void 0 : _a.sourceMesh) || SphereBuilder.CreateSphere("jointParent", { diameter: 1 });
      originalMesh.isVisible = !!((_b = _this.options.jointMeshes) === null || _b === void 0 ? void 0 : _b.keepOriginalVisible);
      for (var i = 0; i < hand.length; ++i) {
        var newInstance = originalMesh.createInstance(xrController.uniqueId + "-handJoint-" + i);
        if ((_c = _this.options.jointMeshes) === null || _c === void 0 ? void 0 : _c.onHandJointMeshGenerated) {
          var returnedMesh = _this.options.jointMeshes.onHandJointMeshGenerated(newInstance, i, xrController.uniqueId);
          if (returnedMesh) {
            if (returnedMesh !== newInstance) {
              newInstance.dispose();
              newInstance = returnedMesh;
            }
          }
        }
        newInstance.isPickable = false;
        if ((_d = _this.options.jointMeshes) === null || _d === void 0 ? void 0 : _d.enablePhysics) {
          var props = _this.options.jointMeshes.physicsProps || {};
          var type = props.impostorType !== void 0 ? props.impostorType : PhysicsImpostor.SphereImpostor;
          newInstance.physicsImpostor = new PhysicsImpostor(newInstance, type, __assign({ mass: 0 }, props));
        }
        newInstance.rotationQuaternion = new Quaternion();
        if ((_e = _this.options.jointMeshes) === null || _e === void 0 ? void 0 : _e.invisible) {
          newInstance.isVisible = false;
        }
        trackedMeshes.push(newInstance);
      }
      var handedness = xrController.inputSource.handedness === "right" ? "right" : "left";
      var handMesh = ((_f = _this.options.jointMeshes) === null || _f === void 0 ? void 0 : _f.handMeshes) && ((_g = _this.options.jointMeshes) === null || _g === void 0 ? void 0 : _g.handMeshes[handedness]);
      var rigMapping = ((_h = _this.options.jointMeshes) === null || _h === void 0 ? void 0 : _h.rigMapping) && ((_j = _this.options.jointMeshes) === null || _j === void 0 ? void 0 : _j.rigMapping[handedness]);
      var webxrHand = new WebXRHand(xrController, trackedMeshes, handMesh, rigMapping, (_k = _this.options.jointMeshes) === null || _k === void 0 ? void 0 : _k.disableDefaultHandMesh);
      _this._hands[xrController.uniqueId] = {
        handObject: webxrHand,
        id: WebXRHandTracking2._idCounter++
      };
      _this.onHandAddedObservable.notifyObservers(webxrHand);
    };
    _this.xrNativeFeatureName = "hand-tracking";
    return _this;
  }
  WebXRHandTracking2.prototype.isCompatible = function() {
    return typeof XRHand !== "undefined";
  };
  WebXRHandTracking2.prototype.attach = function() {
    var _this = this;
    if (!_super.prototype.attach.call(this)) {
      return false;
    }
    this.options.xrInput.controllers.forEach(this._attachHand);
    this._addNewAttachObserver(this.options.xrInput.onControllerAddedObservable, this._attachHand);
    this._addNewAttachObserver(this.options.xrInput.onControllerRemovedObservable, function(controller) {
      _this._detachHand(controller.uniqueId);
    });
    return true;
  };
  WebXRHandTracking2.prototype.detach = function() {
    var _this = this;
    if (!_super.prototype.detach.call(this)) {
      return false;
    }
    Object.keys(this._hands).forEach(function(controllerId) {
      _this._detachHand(controllerId);
    });
    return true;
  };
  WebXRHandTracking2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this.onHandAddedObservable.clear();
  };
  WebXRHandTracking2.prototype.getHandByControllerId = function(controllerId) {
    var _a;
    return ((_a = this._hands[controllerId]) === null || _a === void 0 ? void 0 : _a.handObject) || null;
  };
  WebXRHandTracking2.prototype.getHandByHandedness = function(handedness) {
    var _this = this;
    var handednesses = Object.keys(this._hands).map(function(key) {
      return _this._hands[key].handObject.xrController.inputSource.handedness;
    });
    var found = handednesses.indexOf(handedness);
    if (found !== -1) {
      return this._hands[found].handObject;
    }
    return null;
  };
  WebXRHandTracking2.prototype._onXRFrame = function(_xrFrame) {
    var _this = this;
    Object.keys(this._hands).forEach(function(id) {
      var _a;
      _this._hands[id].handObject.updateFromXRFrame(_xrFrame, _this._xrSessionManager.referenceSpace, (_a = _this.options.jointMeshes) === null || _a === void 0 ? void 0 : _a.scaleFactor);
    });
  };
  WebXRHandTracking2.prototype._detachHand = function(controllerId) {
    if (this._hands[controllerId]) {
      this.onHandRemovedObservable.notifyObservers(this._hands[controllerId].handObject);
      this._hands[controllerId].handObject.dispose();
    }
  };
  WebXRHandTracking2._idCounter = 0;
  WebXRHandTracking2.Name = WebXRFeatureName.HAND_TRACKING;
  WebXRHandTracking2.Version = 1;
  return WebXRHandTracking2;
}(WebXRAbstractFeature);
WebXRFeaturesManager.AddWebXRFeature(WebXRHandTracking.Name, function(xrSessionManager, options) {
  return function() {
    return new WebXRHandTracking(xrSessionManager, options);
  };
}, WebXRHandTracking.Version, false);

// node_modules/@babylonjs/core/XR/motionController/webXRMicrosoftMixedRealityController.js
var WebXRMicrosoftMixedRealityController = function(_super) {
  __extends(WebXRMicrosoftMixedRealityController2, _super);
  function WebXRMicrosoftMixedRealityController2(scene, gamepadObject, handedness) {
    var _this = _super.call(this, scene, MixedRealityProfile["left-right"], gamepadObject, handedness) || this;
    _this._mapping = {
      defaultButton: {
        valueNodeName: "VALUE",
        unpressedNodeName: "UNPRESSED",
        pressedNodeName: "PRESSED"
      },
      defaultAxis: {
        valueNodeName: "VALUE",
        minNodeName: "MIN",
        maxNodeName: "MAX"
      },
      buttons: {
        "xr-standard-trigger": {
          rootNodeName: "SELECT",
          componentProperty: "button",
          states: ["default", "touched", "pressed"]
        },
        "xr-standard-squeeze": {
          rootNodeName: "GRASP",
          componentProperty: "state",
          states: ["pressed"]
        },
        "xr-standard-touchpad": {
          rootNodeName: "TOUCHPAD_PRESS",
          labelAnchorNodeName: "squeeze-label",
          touchPointNodeName: "TOUCH"
        },
        "xr-standard-thumbstick": {
          rootNodeName: "THUMBSTICK_PRESS",
          componentProperty: "state",
          states: ["pressed"]
        }
      },
      axes: {
        "xr-standard-touchpad": {
          "x-axis": {
            rootNodeName: "TOUCHPAD_TOUCH_X"
          },
          "y-axis": {
            rootNodeName: "TOUCHPAD_TOUCH_Y"
          }
        },
        "xr-standard-thumbstick": {
          "x-axis": {
            rootNodeName: "THUMBSTICK_X"
          },
          "y-axis": {
            rootNodeName: "THUMBSTICK_Y"
          }
        }
      }
    };
    _this.profileId = "microsoft-mixed-reality";
    return _this;
  }
  WebXRMicrosoftMixedRealityController2.prototype._getFilenameAndPath = function() {
    var filename = "";
    if (this.handedness === "left") {
      filename = WebXRMicrosoftMixedRealityController2.MODEL_LEFT_FILENAME;
    } else {
      filename = WebXRMicrosoftMixedRealityController2.MODEL_RIGHT_FILENAME;
    }
    var device = "default";
    var path = WebXRMicrosoftMixedRealityController2.MODEL_BASE_URL + device + "/";
    return {
      filename,
      path
    };
  };
  WebXRMicrosoftMixedRealityController2.prototype._getModelLoadingConstraints = function() {
    var glbLoaded = SceneLoader.IsPluginForExtensionAvailable(".glb");
    if (!glbLoaded) {
      Logger.Warn("glTF / glb loaded was not registered, using generic controller instead");
    }
    return glbLoaded;
  };
  WebXRMicrosoftMixedRealityController2.prototype._processLoadedModel = function(_meshes) {
    var _this = this;
    if (!this.rootMesh) {
      return;
    }
    this.getComponentIds().forEach(function(id, i) {
      if (_this.disableAnimation) {
        return;
      }
      if (id && _this.rootMesh) {
        var buttonMap_1 = _this._mapping.buttons[id];
        var buttonMeshName = buttonMap_1.rootNodeName;
        if (!buttonMeshName) {
          Logger.Log("Skipping unknown button at index: " + i + " with mapped name: " + id);
          return;
        }
        var buttonMesh = _this._getChildByName(_this.rootMesh, buttonMeshName);
        if (!buttonMesh) {
          Logger.Warn("Missing button mesh with name: " + buttonMeshName);
          return;
        }
        buttonMap_1.valueMesh = _this._getImmediateChildByName(buttonMesh, _this._mapping.defaultButton.valueNodeName);
        buttonMap_1.pressedMesh = _this._getImmediateChildByName(buttonMesh, _this._mapping.defaultButton.pressedNodeName);
        buttonMap_1.unpressedMesh = _this._getImmediateChildByName(buttonMesh, _this._mapping.defaultButton.unpressedNodeName);
        if (buttonMap_1.valueMesh && buttonMap_1.pressedMesh && buttonMap_1.unpressedMesh) {
          var comp = _this.getComponent(id);
          if (comp) {
            comp.onButtonStateChangedObservable.add(function(component) {
              _this._lerpTransform(buttonMap_1, component.value);
            }, void 0, true);
          }
        } else {
          Logger.Warn("Missing button submesh under mesh with name: " + buttonMeshName);
        }
      }
    });
    this.getComponentIds().forEach(function(id, i) {
      var comp = _this.getComponent(id);
      if (!comp.isAxes()) {
        return;
      }
      ["x-axis", "y-axis"].forEach(function(axis) {
        if (!_this.rootMesh) {
          return;
        }
        var axisMap = _this._mapping.axes[id][axis];
        var axisMesh = _this._getChildByName(_this.rootMesh, axisMap.rootNodeName);
        if (!axisMesh) {
          Logger.Warn("Missing axis mesh with name: " + axisMap.rootNodeName);
          return;
        }
        axisMap.valueMesh = _this._getImmediateChildByName(axisMesh, _this._mapping.defaultAxis.valueNodeName);
        axisMap.minMesh = _this._getImmediateChildByName(axisMesh, _this._mapping.defaultAxis.minNodeName);
        axisMap.maxMesh = _this._getImmediateChildByName(axisMesh, _this._mapping.defaultAxis.maxNodeName);
        if (axisMap.valueMesh && axisMap.minMesh && axisMap.maxMesh) {
          if (comp) {
            comp.onAxisValueChangedObservable.add(function(axisValues) {
              var value = axis === "x-axis" ? axisValues.x : axisValues.y;
              _this._lerpTransform(axisMap, value, true);
            }, void 0, true);
          }
        } else {
          Logger.Warn("Missing axis submesh under mesh with name: " + axisMap.rootNodeName);
        }
      });
    });
  };
  WebXRMicrosoftMixedRealityController2.prototype._setRootMesh = function(meshes) {
    this.rootMesh = new Mesh(this.profileId + " " + this.handedness, this.scene);
    this.rootMesh.isPickable = false;
    var rootMesh;
    for (var i = 0; i < meshes.length; i++) {
      var mesh = meshes[i];
      mesh.isPickable = false;
      if (!mesh.parent) {
        rootMesh = mesh;
      }
    }
    if (rootMesh) {
      rootMesh.setParent(this.rootMesh);
    }
    if (!this.scene.useRightHandedSystem) {
      this.rootMesh.rotationQuaternion = Quaternion.FromEulerAngles(0, Math.PI, 0);
    }
  };
  WebXRMicrosoftMixedRealityController2.prototype._updateModel = function() {
  };
  WebXRMicrosoftMixedRealityController2.MODEL_BASE_URL = "https://controllers.babylonjs.com/microsoft/";
  WebXRMicrosoftMixedRealityController2.MODEL_LEFT_FILENAME = "left.glb";
  WebXRMicrosoftMixedRealityController2.MODEL_RIGHT_FILENAME = "right.glb";
  return WebXRMicrosoftMixedRealityController2;
}(WebXRAbstractMotionController);
WebXRMotionControllerManager.RegisterController("windows-mixed-reality", function(xrInput, scene) {
  return new WebXRMicrosoftMixedRealityController(scene, xrInput.gamepad, xrInput.handedness);
});
var MixedRealityProfile = {
  left: {
    selectComponentId: "xr-standard-trigger",
    components: {
      "xr-standard-trigger": {
        type: "trigger",
        gamepadIndices: {
          button: 0
        },
        rootNodeName: "xr_standard_trigger",
        visualResponses: {
          xr_standard_trigger_pressed: {
            componentProperty: "button",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_trigger_pressed_value",
            minNodeName: "xr_standard_trigger_pressed_min",
            maxNodeName: "xr_standard_trigger_pressed_max"
          }
        }
      },
      "xr-standard-squeeze": {
        type: "squeeze",
        gamepadIndices: {
          button: 1
        },
        rootNodeName: "xr_standard_squeeze",
        visualResponses: {
          xr_standard_squeeze_pressed: {
            componentProperty: "button",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_squeeze_pressed_value",
            minNodeName: "xr_standard_squeeze_pressed_min",
            maxNodeName: "xr_standard_squeeze_pressed_max"
          }
        }
      },
      "xr-standard-touchpad": {
        type: "touchpad",
        gamepadIndices: {
          button: 2,
          xAxis: 0,
          yAxis: 1
        },
        rootNodeName: "xr_standard_touchpad",
        visualResponses: {
          xr_standard_touchpad_pressed: {
            componentProperty: "button",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_touchpad_pressed_value",
            minNodeName: "xr_standard_touchpad_pressed_min",
            maxNodeName: "xr_standard_touchpad_pressed_max"
          },
          xr_standard_touchpad_xaxis_pressed: {
            componentProperty: "xAxis",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_touchpad_xaxis_pressed_value",
            minNodeName: "xr_standard_touchpad_xaxis_pressed_min",
            maxNodeName: "xr_standard_touchpad_xaxis_pressed_max"
          },
          xr_standard_touchpad_yaxis_pressed: {
            componentProperty: "yAxis",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_touchpad_yaxis_pressed_value",
            minNodeName: "xr_standard_touchpad_yaxis_pressed_min",
            maxNodeName: "xr_standard_touchpad_yaxis_pressed_max"
          },
          xr_standard_touchpad_xaxis_touched: {
            componentProperty: "xAxis",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_touchpad_xaxis_touched_value",
            minNodeName: "xr_standard_touchpad_xaxis_touched_min",
            maxNodeName: "xr_standard_touchpad_xaxis_touched_max"
          },
          xr_standard_touchpad_yaxis_touched: {
            componentProperty: "yAxis",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_touchpad_yaxis_touched_value",
            minNodeName: "xr_standard_touchpad_yaxis_touched_min",
            maxNodeName: "xr_standard_touchpad_yaxis_touched_max"
          },
          xr_standard_touchpad_axes_touched: {
            componentProperty: "state",
            states: ["touched", "pressed"],
            valueNodeProperty: "visibility",
            valueNodeName: "xr_standard_touchpad_axes_touched_value"
          }
        },
        touchPointNodeName: "xr_standard_touchpad_axes_touched_value"
      },
      "xr-standard-thumbstick": {
        type: "thumbstick",
        gamepadIndices: {
          button: 3,
          xAxis: 2,
          yAxis: 3
        },
        rootNodeName: "xr_standard_thumbstick",
        visualResponses: {
          xr_standard_thumbstick_pressed: {
            componentProperty: "button",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_thumbstick_pressed_value",
            minNodeName: "xr_standard_thumbstick_pressed_min",
            maxNodeName: "xr_standard_thumbstick_pressed_max"
          },
          xr_standard_thumbstick_xaxis_pressed: {
            componentProperty: "xAxis",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_thumbstick_xaxis_pressed_value",
            minNodeName: "xr_standard_thumbstick_xaxis_pressed_min",
            maxNodeName: "xr_standard_thumbstick_xaxis_pressed_max"
          },
          xr_standard_thumbstick_yaxis_pressed: {
            componentProperty: "yAxis",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_thumbstick_yaxis_pressed_value",
            minNodeName: "xr_standard_thumbstick_yaxis_pressed_min",
            maxNodeName: "xr_standard_thumbstick_yaxis_pressed_max"
          }
        }
      }
    },
    gamepadMapping: "xr-standard",
    rootNodeName: "microsoft-mixed-reality-left",
    assetPath: "left.glb"
  },
  right: {
    selectComponentId: "xr-standard-trigger",
    components: {
      "xr-standard-trigger": {
        type: "trigger",
        gamepadIndices: {
          button: 0
        },
        rootNodeName: "xr_standard_trigger",
        visualResponses: {
          xr_standard_trigger_pressed: {
            componentProperty: "button",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_trigger_pressed_value",
            minNodeName: "xr_standard_trigger_pressed_min",
            maxNodeName: "xr_standard_trigger_pressed_max"
          }
        }
      },
      "xr-standard-squeeze": {
        type: "squeeze",
        gamepadIndices: {
          button: 1
        },
        rootNodeName: "xr_standard_squeeze",
        visualResponses: {
          xr_standard_squeeze_pressed: {
            componentProperty: "button",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_squeeze_pressed_value",
            minNodeName: "xr_standard_squeeze_pressed_min",
            maxNodeName: "xr_standard_squeeze_pressed_max"
          }
        }
      },
      "xr-standard-touchpad": {
        type: "touchpad",
        gamepadIndices: {
          button: 2,
          xAxis: 0,
          yAxis: 1
        },
        rootNodeName: "xr_standard_touchpad",
        visualResponses: {
          xr_standard_touchpad_pressed: {
            componentProperty: "button",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_touchpad_pressed_value",
            minNodeName: "xr_standard_touchpad_pressed_min",
            maxNodeName: "xr_standard_touchpad_pressed_max"
          },
          xr_standard_touchpad_xaxis_pressed: {
            componentProperty: "xAxis",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_touchpad_xaxis_pressed_value",
            minNodeName: "xr_standard_touchpad_xaxis_pressed_min",
            maxNodeName: "xr_standard_touchpad_xaxis_pressed_max"
          },
          xr_standard_touchpad_yaxis_pressed: {
            componentProperty: "yAxis",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_touchpad_yaxis_pressed_value",
            minNodeName: "xr_standard_touchpad_yaxis_pressed_min",
            maxNodeName: "xr_standard_touchpad_yaxis_pressed_max"
          },
          xr_standard_touchpad_xaxis_touched: {
            componentProperty: "xAxis",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_touchpad_xaxis_touched_value",
            minNodeName: "xr_standard_touchpad_xaxis_touched_min",
            maxNodeName: "xr_standard_touchpad_xaxis_touched_max"
          },
          xr_standard_touchpad_yaxis_touched: {
            componentProperty: "yAxis",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_touchpad_yaxis_touched_value",
            minNodeName: "xr_standard_touchpad_yaxis_touched_min",
            maxNodeName: "xr_standard_touchpad_yaxis_touched_max"
          },
          xr_standard_touchpad_axes_touched: {
            componentProperty: "state",
            states: ["touched", "pressed"],
            valueNodeProperty: "visibility",
            valueNodeName: "xr_standard_touchpad_axes_touched_value"
          }
        },
        touchPointNodeName: "xr_standard_touchpad_axes_touched_value"
      },
      "xr-standard-thumbstick": {
        type: "thumbstick",
        gamepadIndices: {
          button: 3,
          xAxis: 2,
          yAxis: 3
        },
        rootNodeName: "xr_standard_thumbstick",
        visualResponses: {
          xr_standard_thumbstick_pressed: {
            componentProperty: "button",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_thumbstick_pressed_value",
            minNodeName: "xr_standard_thumbstick_pressed_min",
            maxNodeName: "xr_standard_thumbstick_pressed_max"
          },
          xr_standard_thumbstick_xaxis_pressed: {
            componentProperty: "xAxis",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_thumbstick_xaxis_pressed_value",
            minNodeName: "xr_standard_thumbstick_xaxis_pressed_min",
            maxNodeName: "xr_standard_thumbstick_xaxis_pressed_max"
          },
          xr_standard_thumbstick_yaxis_pressed: {
            componentProperty: "yAxis",
            states: ["default", "touched", "pressed"],
            valueNodeProperty: "transform",
            valueNodeName: "xr_standard_thumbstick_yaxis_pressed_value",
            minNodeName: "xr_standard_thumbstick_yaxis_pressed_min",
            maxNodeName: "xr_standard_thumbstick_yaxis_pressed_max"
          }
        }
      }
    },
    gamepadMapping: "xr-standard",
    rootNodeName: "microsoft-mixed-reality-right",
    assetPath: "right.glb"
  }
};

// node_modules/@babylonjs/core/XR/motionController/webXROculusTouchMotionController.js
var WebXROculusTouchMotionController = function(_super) {
  __extends(WebXROculusTouchMotionController2, _super);
  function WebXROculusTouchMotionController2(scene, gamepadObject, handedness, legacyMapping, _forceLegacyControllers) {
    if (legacyMapping === void 0) {
      legacyMapping = false;
    }
    if (_forceLegacyControllers === void 0) {
      _forceLegacyControllers = false;
    }
    var _this = _super.call(this, scene, OculusTouchLayouts[handedness], gamepadObject, handedness) || this;
    _this._forceLegacyControllers = _forceLegacyControllers;
    _this.profileId = "oculus-touch";
    return _this;
  }
  WebXROculusTouchMotionController2.prototype._getFilenameAndPath = function() {
    var filename = "";
    if (this.handedness === "left") {
      filename = WebXROculusTouchMotionController2.MODEL_LEFT_FILENAME;
    } else {
      filename = WebXROculusTouchMotionController2.MODEL_RIGHT_FILENAME;
    }
    var path = this._isQuest() ? WebXROculusTouchMotionController2.QUEST_MODEL_BASE_URL : WebXROculusTouchMotionController2.MODEL_BASE_URL;
    return {
      filename,
      path
    };
  };
  WebXROculusTouchMotionController2.prototype._getModelLoadingConstraints = function() {
    return true;
  };
  WebXROculusTouchMotionController2.prototype._processLoadedModel = function(_meshes) {
    var _this = this;
    var isQuest = this._isQuest();
    var triggerDirection = this.handedness === "right" ? -1 : 1;
    this.getComponentIds().forEach(function(id) {
      var comp = id && _this.getComponent(id);
      if (comp) {
        comp.onButtonStateChangedObservable.add(function(component) {
          if (!_this.rootMesh || _this.disableAnimation) {
            return;
          }
          switch (id) {
            case "xr-standard-trigger":
              if (!isQuest) {
                _this._modelRootNode.getChildren()[3].rotation.x = -component.value * 0.2;
                _this._modelRootNode.getChildren()[3].position.y = -component.value * 5e-3;
                _this._modelRootNode.getChildren()[3].position.z = -component.value * 5e-3;
              }
              return;
            case "xr-standard-squeeze":
              if (!isQuest) {
                _this._modelRootNode.getChildren()[4].position.x = triggerDirection * component.value * 35e-4;
              }
              return;
            case "xr-standard-thumbstick":
              return;
            case "a-button":
            case "x-button":
              if (!isQuest) {
                if (component.pressed) {
                  _this._modelRootNode.getChildren()[1].position.y = -1e-3;
                } else {
                  _this._modelRootNode.getChildren()[1].position.y = 0;
                }
              }
              return;
            case "b-button":
            case "y-button":
              if (!isQuest) {
                if (component.pressed) {
                  _this._modelRootNode.getChildren()[2].position.y = -1e-3;
                } else {
                  _this._modelRootNode.getChildren()[2].position.y = 0;
                }
              }
              return;
          }
        }, void 0, true);
      }
    });
  };
  WebXROculusTouchMotionController2.prototype._setRootMesh = function(meshes) {
    this.rootMesh = new Mesh(this.profileId + " " + this.handedness, this.scene);
    if (!this.scene.useRightHandedSystem) {
      this.rootMesh.rotationQuaternion = Quaternion.FromEulerAngles(0, Math.PI, 0);
    }
    meshes.forEach(function(mesh) {
      mesh.isPickable = false;
    });
    if (this._isQuest()) {
      this._modelRootNode = meshes[0];
    } else {
      this._modelRootNode = meshes[1];
      this.rootMesh.position.y = 0.034;
      this.rootMesh.position.z = 0.052;
    }
    this._modelRootNode.parent = this.rootMesh;
  };
  WebXROculusTouchMotionController2.prototype._updateModel = function() {
  };
  WebXROculusTouchMotionController2.prototype._isQuest = function() {
    return !!navigator.userAgent.match(/Quest/gi) && !this._forceLegacyControllers;
  };
  WebXROculusTouchMotionController2.MODEL_BASE_URL = "https://controllers.babylonjs.com/oculus/";
  WebXROculusTouchMotionController2.MODEL_LEFT_FILENAME = "left.babylon";
  WebXROculusTouchMotionController2.MODEL_RIGHT_FILENAME = "right.babylon";
  WebXROculusTouchMotionController2.QUEST_MODEL_BASE_URL = "https://controllers.babylonjs.com/oculusQuest/";
  return WebXROculusTouchMotionController2;
}(WebXRAbstractMotionController);
WebXRMotionControllerManager.RegisterController("oculus-touch", function(xrInput, scene) {
  return new WebXROculusTouchMotionController(scene, xrInput.gamepad, xrInput.handedness);
});
WebXRMotionControllerManager.RegisterController("oculus-touch-legacy", function(xrInput, scene) {
  return new WebXROculusTouchMotionController(scene, xrInput.gamepad, xrInput.handedness, true);
});
var OculusTouchLayouts = {
  left: {
    selectComponentId: "xr-standard-trigger",
    components: {
      "xr-standard-trigger": {
        type: "trigger",
        gamepadIndices: {
          button: 0
        },
        rootNodeName: "xr_standard_trigger",
        visualResponses: {}
      },
      "xr-standard-squeeze": {
        type: "squeeze",
        gamepadIndices: {
          button: 1
        },
        rootNodeName: "xr_standard_squeeze",
        visualResponses: {}
      },
      "xr-standard-thumbstick": {
        type: "thumbstick",
        gamepadIndices: {
          button: 3,
          xAxis: 2,
          yAxis: 3
        },
        rootNodeName: "xr_standard_thumbstick",
        visualResponses: {}
      },
      "x-button": {
        type: "button",
        gamepadIndices: {
          button: 4
        },
        rootNodeName: "x_button",
        visualResponses: {}
      },
      "y-button": {
        type: "button",
        gamepadIndices: {
          button: 5
        },
        rootNodeName: "y_button",
        visualResponses: {}
      },
      thumbrest: {
        type: "button",
        gamepadIndices: {
          button: 6
        },
        rootNodeName: "thumbrest",
        visualResponses: {}
      }
    },
    gamepadMapping: "xr-standard",
    rootNodeName: "oculus-touch-v2-left",
    assetPath: "left.glb"
  },
  right: {
    selectComponentId: "xr-standard-trigger",
    components: {
      "xr-standard-trigger": {
        type: "trigger",
        gamepadIndices: {
          button: 0
        },
        rootNodeName: "xr_standard_trigger",
        visualResponses: {}
      },
      "xr-standard-squeeze": {
        type: "squeeze",
        gamepadIndices: {
          button: 1
        },
        rootNodeName: "xr_standard_squeeze",
        visualResponses: {}
      },
      "xr-standard-thumbstick": {
        type: "thumbstick",
        gamepadIndices: {
          button: 3,
          xAxis: 2,
          yAxis: 3
        },
        rootNodeName: "xr_standard_thumbstick",
        visualResponses: {}
      },
      "a-button": {
        type: "button",
        gamepadIndices: {
          button: 4
        },
        rootNodeName: "a_button",
        visualResponses: {}
      },
      "b-button": {
        type: "button",
        gamepadIndices: {
          button: 5
        },
        rootNodeName: "b_button",
        visualResponses: {}
      },
      thumbrest: {
        type: "button",
        gamepadIndices: {
          button: 6
        },
        rootNodeName: "thumbrest",
        visualResponses: {}
      }
    },
    gamepadMapping: "xr-standard",
    rootNodeName: "oculus-touch-v2-right",
    assetPath: "right.glb"
  }
};

// node_modules/@babylonjs/core/XR/motionController/webXRHTCViveMotionController.js
var WebXRHTCViveMotionController = function(_super) {
  __extends(WebXRHTCViveMotionController2, _super);
  function WebXRHTCViveMotionController2(scene, gamepadObject, handedness) {
    var _this = _super.call(this, scene, HTCViveLayout[handedness], gamepadObject, handedness) || this;
    _this.profileId = "htc-vive";
    return _this;
  }
  WebXRHTCViveMotionController2.prototype._getFilenameAndPath = function() {
    var filename = WebXRHTCViveMotionController2.MODEL_FILENAME;
    var path = WebXRHTCViveMotionController2.MODEL_BASE_URL;
    return {
      filename,
      path
    };
  };
  WebXRHTCViveMotionController2.prototype._getModelLoadingConstraints = function() {
    return true;
  };
  WebXRHTCViveMotionController2.prototype._processLoadedModel = function(_meshes) {
    var _this = this;
    this.getComponentIds().forEach(function(id) {
      var comp = id && _this.getComponent(id);
      if (comp) {
        comp.onButtonStateChangedObservable.add(function(component) {
          if (!_this.rootMesh || _this.disableAnimation) {
            return;
          }
          switch (id) {
            case "xr-standard-trigger":
              _this._modelRootNode.getChildren()[6].rotation.x = -component.value * 0.15;
              return;
            case "xr-standard-touchpad":
              return;
            case "xr-standard-squeeze":
              return;
          }
        }, void 0, true);
      }
    });
  };
  WebXRHTCViveMotionController2.prototype._setRootMesh = function(meshes) {
    this.rootMesh = new Mesh(this.profileId + " " + this.handedness, this.scene);
    meshes.forEach(function(mesh) {
      mesh.isPickable = false;
    });
    this._modelRootNode = meshes[1];
    this._modelRootNode.parent = this.rootMesh;
    if (!this.scene.useRightHandedSystem) {
      this.rootMesh.rotationQuaternion = Quaternion.FromEulerAngles(0, Math.PI, 0);
    }
  };
  WebXRHTCViveMotionController2.prototype._updateModel = function() {
  };
  WebXRHTCViveMotionController2.MODEL_BASE_URL = "https://controllers.babylonjs.com/vive/";
  WebXRHTCViveMotionController2.MODEL_FILENAME = "wand.babylon";
  return WebXRHTCViveMotionController2;
}(WebXRAbstractMotionController);
WebXRMotionControllerManager.RegisterController("htc-vive", function(xrInput, scene) {
  return new WebXRHTCViveMotionController(scene, xrInput.gamepad, xrInput.handedness);
});
var HTCViveLayout = {
  left: {
    selectComponentId: "xr-standard-trigger",
    components: {
      "xr-standard-trigger": {
        type: "trigger",
        gamepadIndices: {
          button: 0
        },
        rootNodeName: "xr_standard_trigger",
        visualResponses: {}
      },
      "xr-standard-squeeze": {
        type: "squeeze",
        gamepadIndices: {
          button: 1
        },
        rootNodeName: "xr_standard_squeeze",
        visualResponses: {}
      },
      "xr-standard-touchpad": {
        type: "touchpad",
        gamepadIndices: {
          button: 2,
          xAxis: 0,
          yAxis: 1
        },
        rootNodeName: "xr_standard_touchpad",
        visualResponses: {}
      },
      menu: {
        type: "button",
        gamepadIndices: {
          button: 4
        },
        rootNodeName: "menu",
        visualResponses: {}
      }
    },
    gamepadMapping: "xr-standard",
    rootNodeName: "htc_vive_none",
    assetPath: "none.glb"
  },
  right: {
    selectComponentId: "xr-standard-trigger",
    components: {
      "xr-standard-trigger": {
        type: "trigger",
        gamepadIndices: {
          button: 0
        },
        rootNodeName: "xr_standard_trigger",
        visualResponses: {}
      },
      "xr-standard-squeeze": {
        type: "squeeze",
        gamepadIndices: {
          button: 1
        },
        rootNodeName: "xr_standard_squeeze",
        visualResponses: {}
      },
      "xr-standard-touchpad": {
        type: "touchpad",
        gamepadIndices: {
          button: 2,
          xAxis: 0,
          yAxis: 1
        },
        rootNodeName: "xr_standard_touchpad",
        visualResponses: {}
      },
      menu: {
        type: "button",
        gamepadIndices: {
          button: 4
        },
        rootNodeName: "menu",
        visualResponses: {}
      }
    },
    gamepadMapping: "xr-standard",
    rootNodeName: "htc_vive_none",
    assetPath: "none.glb"
  },
  none: {
    selectComponentId: "xr-standard-trigger",
    components: {
      "xr-standard-trigger": {
        type: "trigger",
        gamepadIndices: {
          button: 0
        },
        rootNodeName: "xr_standard_trigger",
        visualResponses: {}
      },
      "xr-standard-squeeze": {
        type: "squeeze",
        gamepadIndices: {
          button: 1
        },
        rootNodeName: "xr_standard_squeeze",
        visualResponses: {}
      },
      "xr-standard-touchpad": {
        type: "touchpad",
        gamepadIndices: {
          button: 2,
          xAxis: 0,
          yAxis: 1
        },
        rootNodeName: "xr_standard_touchpad",
        visualResponses: {}
      },
      menu: {
        type: "button",
        gamepadIndices: {
          button: 4
        },
        rootNodeName: "menu",
        visualResponses: {}
      }
    },
    gamepadMapping: "xr-standard",
    rootNodeName: "htc-vive-none",
    assetPath: "none.glb"
  }
};
export {
  AbstractActionManager,
  AbstractAssetTask,
  AbstractMesh,
  AbstractScene,
  Action,
  ActionEvent,
  ActionManager,
  AddBlock,
  AdvancedTimer,
  AlphaState,
  AmmoJSPlugin,
  AnaglyphArcRotateCamera,
  AnaglyphFreeCamera,
  AnaglyphGamepadCamera,
  AnaglyphPostProcess,
  AnaglyphUniversalCamera,
  Analyser,
  AndOrNotEvaluator,
  Angle,
  Animatable,
  AnimatedInputBlockTypes,
  Animation,
  AnimationEvent,
  AnimationGroup,
  AnimationKeyInterpolation,
  AnimationPropertiesOverride,
  AnimationRange,
  AnisotropyBlock,
  Arc2,
  ArcFollowCamera,
  ArcRotateCamera,
  ArcRotateCameraGamepadInput,
  ArcRotateCameraInputsManager,
  ArcRotateCameraKeyboardMoveInput,
  ArcRotateCameraMouseWheelInput,
  ArcRotateCameraPointersInput,
  ArcRotateCameraVRDeviceOrientationInput,
  ArcTan2Block,
  AssetContainer,
  AssetTaskState,
  AssetsManager,
  AssetsProgressEvent,
  AsyncLoop,
  AttachToBoxBehavior,
  AudioEngine,
  AudioSceneComponent,
  AutoRotationBehavior,
  AxesViewer,
  Axis,
  AxisDragGizmo,
  AxisScaleGizmo,
  BRDFTextureTools,
  BabylonFileLoaderConfiguration,
  BackEase,
  BackgroundMaterial,
  BaseParticleSystem,
  BaseTexture,
  BasisTools,
  BasisTranscodeConfiguration,
  BezierCurve,
  BezierCurveEase,
  BinaryFileAssetTask,
  BlackAndWhitePostProcess,
  BloomEffect,
  BloomMergePostProcess,
  BlurPostProcess,
  Bone,
  BoneAxesViewer,
  BoneIKController,
  BoneLookController,
  BonesBlock,
  BounceEase,
  BouncingBehavior,
  BoundingBox,
  BoundingBoxGizmo,
  BoundingBoxRenderer,
  BoundingInfo,
  BoundingSphere,
  BoxBuilder,
  BoxParticleEmitter,
  Buffer,
  CSG,
  Camera,
  CameraGizmo,
  CameraInputTypes,
  CameraInputsManager,
  CannonJSPlugin,
  CanvasGenerator,
  CapsuleBuilder,
  CascadedShadowGenerator,
  ChromaticAberrationPostProcess,
  CircleEase,
  CircleOfConfusionPostProcess,
  ClampBlock,
  ClearCoatBlock,
  ClipboardEventTypes,
  ClipboardInfo,
  CloudPoint,
  Collider,
  Color3,
  Color3Gradient,
  Color4,
  ColorCorrectionPostProcess,
  ColorCurves,
  ColorGradient,
  ColorGradingTexture,
  ColorMergerBlock,
  ColorSplitterBlock,
  CombineAction,
  Condition,
  ConeParticleEmitter,
  Constants,
  ContainerAssetTask,
  ConvolutionPostProcess,
  Coordinate,
  CopyTools,
  CrossBlock,
  CubeMapToSphericalPolynomialTools,
  CubeTexture,
  CubeTextureAssetTask,
  CubicEase,
  CurrentScreenBlock,
  Curve3,
  CustomOptimization,
  CustomParticleEmitter,
  CustomProceduralTexture,
  CylinderBuilder,
  CylinderDirectedParticleEmitter,
  CylinderParticleEmitter,
  DDSTools,
  DataBuffer,
  DataReader,
  DataStorage,
  Database,
  DaydreamController,
  DebugLayer,
  DebugLayerTab,
  DecalBuilder,
  DeepCopier,
  DefaultCollisionCoordinator,
  DefaultLoadingScreen,
  DefaultRenderingPipeline,
  Deferred,
  DepthCullingState,
  DepthOfFieldBlurPostProcess,
  DepthOfFieldEffect,
  DepthOfFieldEffectBlurLevel,
  DepthOfFieldMergePostProcess,
  DepthOfFieldMergePostProcessOptions,
  DepthReducer,
  DepthRenderer,
  DepthRendererSceneComponent,
  DepthSortedParticle,
  DerivativeBlock,
  DesaturateBlock,
  DeviceInputSystem,
  DeviceOrientationCamera,
  DeviceSource,
  DeviceSourceManager,
  DeviceType,
  DirectionalLight,
  DiscBuilder,
  DiscardBlock,
  DisplayPassPostProcess,
  DistanceBlock,
  DistanceJoint,
  DivideBlock,
  DoNothingAction,
  DotBlock,
  DracoCompression,
  DualShockButton,
  DualShockDpad,
  DualShockInput,
  DualShockPad,
  DynamicTexture,
  EasingFunction,
  EdgesRenderer,
  Effect,
  EffectFallbacks,
  EffectLayer,
  EffectLayerSceneComponent,
  EffectRenderer,
  EffectWrapper,
  ElasticEase,
  Engine,
  EngineInstrumentation,
  EngineStore,
  EngineView,
  EnvironmentHelper,
  EnvironmentTextureTools,
  Epsilon,
  EquiRectangularCubeTexture,
  EquiRectangularCubeTextureAssetTask,
  EventState,
  ExecuteCodeAction,
  ExponentialEase,
  ExtractHighlightsPostProcess,
  FactorGradient,
  FadeInOutBehavior,
  FileTools,
  FilesInput,
  FilesInputStore,
  FilterPostProcess,
  FlyCamera,
  FlyCameraInputsManager,
  FlyCameraKeyboardInput,
  FlyCameraMouseInput,
  FogBlock,
  FollowCamera,
  FollowCameraInputsManager,
  FollowCameraKeyboardMoveInput,
  FollowCameraMouseWheelInput,
  FollowCameraPointersInput,
  FragCoordBlock,
  FragmentOutputBlock,
  FramingBehavior,
  FreeCamera,
  FreeCameraDeviceOrientationInput,
  FreeCameraGamepadInput,
  FreeCameraInputsManager,
  FreeCameraKeyboardMoveInput,
  FreeCameraMouseInput,
  FreeCameraMouseWheelInput,
  FreeCameraTouchInput,
  FreeCameraVirtualJoystickInput,
  FresnelBlock,
  FresnelParameters,
  FrontFacingBlock,
  Frustum,
  FxaaPostProcess,
  GPUParticleSystem,
  Gamepad,
  GamepadCamera,
  GamepadManager,
  GamepadSystemSceneComponent,
  GearVRController,
  GenericController,
  GenericPad,
  Geometry,
  GeometryBufferRenderer,
  GeometryBufferRendererSceneComponent,
  Gizmo,
  GizmoManager,
  GlowLayer,
  GradientBlock,
  GradientBlockColorStep,
  GradientHelper,
  GrainPostProcess,
  GroundBuilder,
  GroundMesh,
  HDRCubeTexture,
  HDRCubeTextureAssetTask,
  HDRFiltering,
  HDRTools,
  HardwareScalingOptimization,
  HemisphereBuilder,
  HemisphericLight,
  HemisphericParticleEmitter,
  HighlightLayer,
  HighlightsPostProcess,
  Hinge2Joint,
  HingeJoint,
  HtmlElementTexture,
  IWebXRControllerPhysicsOptions,
  IcoSphereBuilder,
  ImageAssetTask,
  ImageProcessingBlock,
  ImageProcessingConfiguration,
  ImageProcessingConfigurationDefines,
  ImageProcessingPostProcess,
  IncrementValueAction,
  InputBlock,
  InspectableType,
  InstancedLinesMesh,
  InstancedMesh,
  InstancesBlock,
  InstantiatedEntries,
  InternalTexture,
  InternalTextureSource,
  InterpolateValueAction,
  IntersectionInfo,
  JoystickAxis,
  KeepAssets,
  KeyboardEventTypes,
  KeyboardInfo,
  KeyboardInfoPre,
  KhronosTextureContainer,
  KhronosTextureContainer2,
  LatheBuilder,
  Layer,
  LayerSceneComponent,
  LengthBlock,
  LensFlare,
  LensFlareSystem,
  LensFlareSystemSceneComponent,
  LensFlaresOptimization,
  LensRenderingPipeline,
  LerpBlock,
  Light,
  LightBlock,
  LightGizmo,
  LightInformationBlock,
  LineEdgesRenderer,
  LinesBuilder,
  LinesMesh,
  LoadFileError,
  Logger,
  Material,
  MaterialDefines,
  MaterialFlags,
  MaterialHelper,
  Matrix,
  MaxBlock,
  MergeMeshesOptimization,
  Mesh,
  MeshAssetTask,
  MeshBuilder,
  MeshExploder,
  MeshLODLevel,
  MeshParticleEmitter,
  MinBlock,
  MinMaxReducer,
  MirrorTexture,
  ModBlock,
  ModelShape,
  MorphTarget,
  MorphTargetManager,
  MorphTargetsBlock,
  MotionBlurPostProcess,
  MotorEnabledJoint,
  MultiMaterial,
  MultiObserver,
  MultiPointerScaleBehavior,
  MultiRenderTarget,
  MultiplyBlock,
  NLerpBlock,
  NativeEngine,
  NegateBlock,
  Node2 as Node,
  NodeMaterial,
  NodeMaterialBlock,
  NodeMaterialBlockConnectionPointMode,
  NodeMaterialBlockConnectionPointTypes,
  NodeMaterialBlockTargets,
  NodeMaterialConnectionPoint,
  NodeMaterialConnectionPointCompatibilityStates,
  NodeMaterialConnectionPointDirection,
  NodeMaterialDefines,
  NodeMaterialModes,
  NodeMaterialOptimizer,
  NodeMaterialSystemValues,
  NoiseProceduralTexture,
  NormalBlendBlock,
  NormalizeBlock,
  NullEngine,
  NullEngineOptions,
  Observable,
  Observer,
  Octree,
  OctreeBlock,
  OctreeSceneComponent,
  OculusTouchController,
  OimoJSPlugin,
  OnAfterEnteringVRObservableEvent,
  OneMinusBlock,
  Orientation,
  OutlineRenderer,
  PBRBaseMaterial,
  PBRBaseSimpleMaterial,
  PBRMaterial,
  PBRMaterialDefines,
  PBRMetallicRoughnessBlock,
  PBRMetallicRoughnessMaterial,
  PBRSpecularGlossinessMaterial,
  PanoramaToCubeMapTools,
  Particle,
  ParticleBlendMultiplyBlock,
  ParticleHelper,
  ParticleRampGradientBlock,
  ParticleSystem,
  ParticleSystemSet,
  ParticleTextureBlock,
  ParticlesOptimization,
  PassCubePostProcess,
  PassPostProcess,
  Path2,
  Path3D,
  PerfCounter,
  PerformanceConfigurator,
  PerformanceMonitor,
  PerturbNormalBlock,
  PhotoDome,
  PhysicsEngine,
  PhysicsEngineSceneComponent,
  PhysicsHelper,
  PhysicsImpostor,
  PhysicsJoint,
  PhysicsRadialExplosionEventOptions,
  PhysicsRadialImpulseFalloff,
  PhysicsUpdraftEventOptions,
  PhysicsUpdraftMode,
  PhysicsViewer,
  PhysicsVortexEventOptions,
  PickingInfo,
  PivotTools,
  Plane,
  PlaneBuilder,
  PlaneDragGizmo,
  PlaneRotationGizmo,
  PlayAnimationAction,
  PlaySoundAction,
  PointColor,
  PointLight,
  PointParticleEmitter,
  PointerDragBehavior,
  PointerEventTypes,
  PointerInfo,
  PointerInfoBase,
  PointerInfoPre,
  PointerInput,
  PointsCloudSystem,
  PointsGroup,
  Polygon2 as Polygon,
  PolygonBuilder,
  PolygonMeshBuilder,
  PolyhedronBuilder,
  PoseEnabledController,
  PoseEnabledControllerHelper,
  PoseEnabledControllerType,
  PositionGizmo,
  PositionNormalTextureVertex,
  PositionNormalVertex,
  PostProcess,
  PostProcessManager,
  PostProcessRenderEffect,
  PostProcessRenderPipeline,
  PostProcessRenderPipelineManager,
  PostProcessRenderPipelineManagerSceneComponent,
  PostProcessesOptimization,
  PosterizeBlock,
  PowBlock,
  PowerEase,
  PrePassRenderer,
  PrePassRendererSceneComponent,
  PrecisionDate,
  PredicateCondition,
  ProceduralTexture,
  ProceduralTextureSceneComponent,
  PromisePolyfill,
  PropertyTypeForEdition,
  PushMaterial,
  QuadraticEase,
  QuadraticErrorSimplification,
  QuarticEase,
  Quaternion,
  QuinticEase,
  RGBDTextureTools,
  RandomNumberBlock,
  RawCubeTexture,
  RawTexture,
  RawTexture2DArray,
  RawTexture3D,
  Ray,
  RayHelper,
  ReadFileError,
  RecastJSCrowd,
  RecastJSPlugin,
  ReciprocalBlock,
  ReflectBlock,
  ReflectionBlock,
  ReflectionProbe,
  ReflectionTextureBlock,
  RefractBlock,
  RefractionBlock,
  RefractionPostProcess,
  RefractionTexture,
  RemapBlock,
  RenderTargetTexture,
  RenderTargetsOptimization,
  RenderingGroup,
  RenderingGroupInfo,
  RenderingManager,
  ReplaceColorBlock,
  RequestFileError,
  RetryStrategy,
  RibbonBuilder,
  RollingAverage,
  Rotate2dBlock,
  RotationGizmo,
  RuntimeAnimation,
  SSAO2RenderingPipeline,
  SSAORenderingPipeline,
  Scalar,
  ScaleBlock,
  ScaleGizmo,
  Scene,
  SceneComponentConstants,
  SceneInstrumentation,
  SceneLoader,
  SceneLoaderAnimationGroupLoadingMode,
  SceneLoaderFlags,
  SceneOptimization,
  SceneOptimizer,
  SceneOptimizerOptions,
  SceneRecorder,
  SceneSerializer,
  ScreenSizeBlock,
  ScreenSpaceCurvaturePostProcess,
  ScreenSpaceReflectionPostProcess,
  ScreenshotTools,
  SerializationHelper,
  SetParentAction,
  SetStateAction,
  SetValueAction,
  ShaderCodeInliner,
  ShaderMaterial,
  ShadowDepthWrapper,
  ShadowGenerator,
  ShadowGeneratorSceneComponent,
  ShadowLight,
  ShadowsOptimization,
  ShapeBuilder,
  SharpenPostProcess,
  SheenBlock,
  SimplexPerlin3DBlock,
  SimplicationQueueSceneComponent,
  SimplificationQueue,
  SimplificationSettings,
  SimplificationType,
  SineEase,
  SixDofDragBehavior,
  Size,
  Skeleton,
  SkeletonViewer,
  SmartArray,
  SmartArrayNoDuplicate,
  SmoothStepBlock,
  SolidParticle,
  SolidParticleSystem,
  SolidParticleVertex,
  Sound,
  SoundTrack,
  Space,
  SphereBuilder,
  SphereDirectedParticleEmitter,
  SphereParticleEmitter,
  SphericalHarmonics,
  SphericalPolynomial,
  SpotLight,
  Sprite,
  SpriteManager,
  SpriteMap,
  SpritePackedManager,
  SpriteSceneComponent,
  Stage,
  StandardMaterial,
  StandardMaterialDefines,
  StandardRenderingPipeline,
  StateCondition,
  StencilState,
  StepBlock,
  StereoscopicArcRotateCamera,
  StereoscopicFreeCamera,
  StereoscopicGamepadCamera,
  StereoscopicInterlacePostProcess,
  StereoscopicInterlacePostProcessI,
  StereoscopicUniversalCamera,
  StickValues,
  StopAnimationAction,
  StopSoundAction,
  StringDictionary,
  StringTools,
  SubEmitter,
  SubEmitterType,
  SubMesh,
  SubSurfaceBlock,
  SubSurfaceSceneComponent,
  SubtractBlock,
  SwitchBooleanAction,
  SwitchInput,
  TGATools,
  Tags,
  TargetCamera,
  TargetedAnimation,
  TextFileAssetTask,
  Texture,
  TextureAssetTask,
  TextureBlock,
  TextureOptimization,
  TexturePacker,
  TexturePackerFrame,
  TextureTools,
  ThinEngine,
  ThinMaterialHelper,
  TiledBoxBuilder,
  TiledPlaneBuilder,
  TimerState,
  TmpColors,
  TmpVectors,
  ToGammaSpace,
  ToLinearSpace,
  TonemapPostProcess,
  TonemappingOperator,
  Tools,
  TorusBuilder,
  TorusKnotBuilder,
  TouchCamera,
  TrailMesh,
  Trajectory,
  TrajectoryClassifier,
  TransformBlock,
  TransformNode,
  TrigonometryBlock,
  TrigonometryBlockOperations,
  TubeBuilder,
  UniformBuffer,
  UniversalCamera,
  UtilityLayerRenderer,
  VRCameraMetrics,
  VRDeviceOrientationArcRotateCamera,
  VRDeviceOrientationFreeCamera,
  VRDeviceOrientationGamepadCamera,
  VRDistortionCorrectionPostProcess,
  VRExperienceHelper,
  VRMultiviewToSingleviewPostProcess,
  ValueCondition,
  Vector2,
  Vector3,
  Vector4,
  VectorMergerBlock,
  VectorSplitterBlock,
  VertexBuffer,
  VertexData,
  VertexOutputBlock,
  VideoDome,
  VideoRecorder,
  VideoTexture,
  ViewDirectionBlock,
  Viewport,
  VirtualJoystick,
  VirtualJoysticksCamera,
  ViveController,
  VolumetricLightScatteringPostProcess,
  WaveBlock,
  WaveBlockKind,
  WebGL2ShaderProcessor,
  WebGLDataBuffer,
  WebGLPipelineContext,
  WebRequest,
  WebVRController,
  WebVRFreeCamera,
  WebXRAbstractFeature,
  WebXRAbstractMotionController,
  WebXRAnchorSystem,
  WebXRBackgroundRemover,
  WebXRCamera,
  WebXRControllerComponent,
  WebXRControllerPhysics,
  WebXRControllerPointerSelection,
  WebXRDefaultExperience,
  WebXRDefaultExperienceOptions,
  WebXREnterExitUI,
  WebXREnterExitUIButton,
  WebXREnterExitUIOptions,
  WebXRExperienceHelper,
  WebXRFeatureName,
  WebXRFeaturePointSystem,
  WebXRFeaturesManager,
  WebXRGenericTriggerMotionController,
  WebXRHTCViveMotionController,
  WebXRHand,
  WebXRHandTracking,
  WebXRHitTest,
  WebXRHitTestLegacy,
  WebXRInput,
  WebXRInputSource,
  WebXRManagedOutputCanvas,
  WebXRManagedOutputCanvasOptions,
  WebXRMicrosoftMixedRealityController,
  WebXRMotionControllerManager,
  WebXRMotionControllerTeleportation,
  WebXROculusTouchMotionController,
  WebXRPlaneDetector,
  WebXRProfiledMotionController,
  WebXRSessionManager,
  WebXRState,
  WebXRTrackingState,
  WeightedSound,
  WindowsMotionController,
  WorkerPool,
  WorleyNoise3DBlock,
  XRWindowsMotionController,
  Xbox360Button,
  Xbox360Dpad,
  Xbox360Pad,
  XboxInput,
  _BabylonLoaderRegistered,
  _BasisTextureLoader,
  _CreationDataStorage,
  _DDSTextureLoader,
  _ENVTextureLoader,
  _IAnimationState,
  _InstancesBatch,
  _KTXTextureLoader,
  _MeshCollisionData,
  _OcclusionDataStorage,
  _TGATextureLoader,
  _TimeToken,
  _TypeStore,
  _forceSceneHelpersToBundle,
  _forceTransformFeedbackToBundle,
  className,
  editableInPropertyPage,
  expandToProperty,
  extractMinAndMax,
  extractMinAndMaxIndexed,
  serialize,
  serializeAsCameraReference,
  serializeAsColor3,
  serializeAsColor4,
  serializeAsColorCurves,
  serializeAsFresnelParameters,
  serializeAsImageProcessingConfiguration,
  serializeAsMatrix,
  serializeAsMeshReference,
  serializeAsQuaternion,
  serializeAsTexture,
  serializeAsVector2,
  serializeAsVector3,
  setAndStartTimer
};
//# sourceMappingURL=@babylonjs_core.js.map
