import {
  BoxBuilder,
  ClipboardEventTypes,
  ClipboardInfo,
  DynamicTexture,
  FadeInOutBehavior,
  Layer,
  PlaneBuilder,
  UtilityLayerRenderer
} from "./chunk-3NNWZ2WX.js";
import {
  AbstractMesh,
  Axis,
  Color3,
  Color4,
  Constants,
  Effect,
  EngineStore,
  Epsilon,
  HemisphericLight,
  KeyboardEventTypes,
  Logger,
  MaterialDefines,
  MaterialHelper,
  Matrix,
  Mesh,
  Observable,
  PerfCounter,
  PointerEventTypes,
  PushMaterial,
  SerializationHelper,
  Space,
  StandardMaterial,
  Texture,
  TmpVectors,
  Tools,
  TransformNode,
  Vector2,
  Vector3,
  Vector4,
  VertexBuffer,
  Viewport,
  _TypeStore,
  __decorate,
  __extends,
  __spreadArrays,
  expandToProperty,
  serialize,
  serializeAsColor3,
  serializeAsColor4,
  serializeAsTexture,
  serializeAsVector3
} from "./chunk-FSGEGJV4.js";

// node_modules/@babylonjs/gui/2D/valueAndUnit.js
var ValueAndUnit = function() {
  function ValueAndUnit2(value, unit, negativeValueAllowed) {
    if (unit === void 0) {
      unit = ValueAndUnit2.UNITMODE_PIXEL;
    }
    if (negativeValueAllowed === void 0) {
      negativeValueAllowed = true;
    }
    this.unit = unit;
    this.negativeValueAllowed = negativeValueAllowed;
    this._value = 1;
    this.ignoreAdaptiveScaling = false;
    this._value = value;
    this._originalUnit = unit;
  }
  Object.defineProperty(ValueAndUnit2.prototype, "isPercentage", {
    get: function() {
      return this.unit === ValueAndUnit2.UNITMODE_PERCENTAGE;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ValueAndUnit2.prototype, "isPixel", {
    get: function() {
      return this.unit === ValueAndUnit2.UNITMODE_PIXEL;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ValueAndUnit2.prototype, "internalValue", {
    get: function() {
      return this._value;
    },
    enumerable: false,
    configurable: true
  });
  ValueAndUnit2.prototype.getValueInPixel = function(host, refValue) {
    if (this.isPixel) {
      return this.getValue(host);
    }
    return this.getValue(host) * refValue;
  };
  ValueAndUnit2.prototype.updateInPlace = function(value, unit) {
    if (unit === void 0) {
      unit = ValueAndUnit2.UNITMODE_PIXEL;
    }
    this._value = value;
    this.unit = unit;
    return this;
  };
  ValueAndUnit2.prototype.getValue = function(host) {
    if (host && !this.ignoreAdaptiveScaling && this.unit !== ValueAndUnit2.UNITMODE_PERCENTAGE) {
      var width = 0;
      var height = 0;
      if (host.idealWidth) {
        width = this._value * host.getSize().width / host.idealWidth;
      }
      if (host.idealHeight) {
        height = this._value * host.getSize().height / host.idealHeight;
      }
      if (host.useSmallestIdeal && host.idealWidth && host.idealHeight) {
        return window.innerWidth < window.innerHeight ? width : height;
      }
      if (host.idealWidth) {
        return width;
      }
      if (host.idealHeight) {
        return height;
      }
    }
    return this._value;
  };
  ValueAndUnit2.prototype.toString = function(host, decimals) {
    switch (this.unit) {
      case ValueAndUnit2.UNITMODE_PERCENTAGE:
        var percentage = this.getValue(host) * 100;
        return (decimals ? percentage.toFixed(decimals) : percentage) + "%";
      case ValueAndUnit2.UNITMODE_PIXEL:
        var pixels = this.getValue(host);
        return (decimals ? pixels.toFixed(decimals) : pixels) + "px";
    }
    return this.unit.toString();
  };
  ValueAndUnit2.prototype.fromString = function(source) {
    var match = ValueAndUnit2._Regex.exec(source.toString());
    if (!match || match.length === 0) {
      return false;
    }
    var sourceValue = parseFloat(match[1]);
    var sourceUnit = this._originalUnit;
    if (!this.negativeValueAllowed) {
      if (sourceValue < 0) {
        sourceValue = 0;
      }
    }
    if (match.length === 4) {
      switch (match[3]) {
        case "px":
          sourceUnit = ValueAndUnit2.UNITMODE_PIXEL;
          break;
        case "%":
          sourceUnit = ValueAndUnit2.UNITMODE_PERCENTAGE;
          sourceValue /= 100;
          break;
      }
    }
    if (sourceValue === this._value && sourceUnit === this.unit) {
      return false;
    }
    this._value = sourceValue;
    this.unit = sourceUnit;
    return true;
  };
  Object.defineProperty(ValueAndUnit2, "UNITMODE_PERCENTAGE", {
    get: function() {
      return ValueAndUnit2._UNITMODE_PERCENTAGE;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ValueAndUnit2, "UNITMODE_PIXEL", {
    get: function() {
      return ValueAndUnit2._UNITMODE_PIXEL;
    },
    enumerable: false,
    configurable: true
  });
  ValueAndUnit2._Regex = /(^-?\d*(\.\d+)?)(%|px)?/;
  ValueAndUnit2._UNITMODE_PERCENTAGE = 0;
  ValueAndUnit2._UNITMODE_PIXEL = 1;
  return ValueAndUnit2;
}();

// node_modules/@babylonjs/gui/2D/measure.js
var tmpRect = [
  new Vector2(0, 0),
  new Vector2(0, 0),
  new Vector2(0, 0),
  new Vector2(0, 0)
];
var tmpRect2 = [
  new Vector2(0, 0),
  new Vector2(0, 0),
  new Vector2(0, 0),
  new Vector2(0, 0)
];
var tmpV1 = new Vector2(0, 0);
var tmpV2 = new Vector2(0, 0);
var Measure = function() {
  function Measure2(left, top, width, height) {
    this.left = left;
    this.top = top;
    this.width = width;
    this.height = height;
  }
  Measure2.prototype.copyFrom = function(other) {
    this.left = other.left;
    this.top = other.top;
    this.width = other.width;
    this.height = other.height;
  };
  Measure2.prototype.copyFromFloats = function(left, top, width, height) {
    this.left = left;
    this.top = top;
    this.width = width;
    this.height = height;
  };
  Measure2.CombineToRef = function(a, b, result) {
    var left = Math.min(a.left, b.left);
    var top = Math.min(a.top, b.top);
    var right = Math.max(a.left + a.width, b.left + b.width);
    var bottom = Math.max(a.top + a.height, b.top + b.height);
    result.left = left;
    result.top = top;
    result.width = right - left;
    result.height = bottom - top;
  };
  Measure2.prototype.addAndTransformToRef = function(transform, addX, addY, addWidth, addHeight, result) {
    var left = this.left + addX;
    var top = this.top + addY;
    var width = this.width + addWidth;
    var height = this.height + addHeight;
    tmpRect[0].copyFromFloats(left, top);
    tmpRect[1].copyFromFloats(left + width, top);
    tmpRect[2].copyFromFloats(left + width, top + height);
    tmpRect[3].copyFromFloats(left, top + height);
    tmpV1.copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE);
    tmpV2.copyFromFloats(0, 0);
    for (var i = 0; i < 4; i++) {
      transform.transformCoordinates(tmpRect[i].x, tmpRect[i].y, tmpRect2[i]);
      tmpV1.x = Math.floor(Math.min(tmpV1.x, tmpRect2[i].x));
      tmpV1.y = Math.floor(Math.min(tmpV1.y, tmpRect2[i].y));
      tmpV2.x = Math.ceil(Math.max(tmpV2.x, tmpRect2[i].x));
      tmpV2.y = Math.ceil(Math.max(tmpV2.y, tmpRect2[i].y));
    }
    result.left = tmpV1.x;
    result.top = tmpV1.y;
    result.width = tmpV2.x - tmpV1.x;
    result.height = tmpV2.y - tmpV1.y;
  };
  Measure2.prototype.transformToRef = function(transform, result) {
    this.addAndTransformToRef(transform, 0, 0, 0, 0, result);
  };
  Measure2.prototype.isEqualsTo = function(other) {
    if (this.left !== other.left) {
      return false;
    }
    if (this.top !== other.top) {
      return false;
    }
    if (this.width !== other.width) {
      return false;
    }
    if (this.height !== other.height) {
      return false;
    }
    return true;
  };
  Measure2.Empty = function() {
    return new Measure2(0, 0, 0, 0);
  };
  return Measure2;
}();

// node_modules/@babylonjs/gui/2D/math2D.js
var Vector2WithInfo = function(_super) {
  __extends(Vector2WithInfo2, _super);
  function Vector2WithInfo2(source, buttonIndex) {
    if (buttonIndex === void 0) {
      buttonIndex = 0;
    }
    var _this = _super.call(this, source.x, source.y) || this;
    _this.buttonIndex = buttonIndex;
    return _this;
  }
  return Vector2WithInfo2;
}(Vector2);
var Matrix2D = function() {
  function Matrix2D2(m00, m01, m10, m11, m20, m21) {
    this.m = new Float32Array(6);
    this.fromValues(m00, m01, m10, m11, m20, m21);
  }
  Matrix2D2.prototype.fromValues = function(m00, m01, m10, m11, m20, m21) {
    this.m[0] = m00;
    this.m[1] = m01;
    this.m[2] = m10;
    this.m[3] = m11;
    this.m[4] = m20;
    this.m[5] = m21;
    return this;
  };
  Matrix2D2.prototype.determinant = function() {
    return this.m[0] * this.m[3] - this.m[1] * this.m[2];
  };
  Matrix2D2.prototype.invertToRef = function(result) {
    var l0 = this.m[0];
    var l1 = this.m[1];
    var l2 = this.m[2];
    var l3 = this.m[3];
    var l4 = this.m[4];
    var l5 = this.m[5];
    var det = this.determinant();
    if (det < Epsilon * Epsilon) {
      result.m[0] = 0;
      result.m[1] = 0;
      result.m[2] = 0;
      result.m[3] = 0;
      result.m[4] = 0;
      result.m[5] = 0;
      return this;
    }
    var detDiv = 1 / det;
    var det4 = l2 * l5 - l3 * l4;
    var det5 = l1 * l4 - l0 * l5;
    result.m[0] = l3 * detDiv;
    result.m[1] = -l1 * detDiv;
    result.m[2] = -l2 * detDiv;
    result.m[3] = l0 * detDiv;
    result.m[4] = det4 * detDiv;
    result.m[5] = det5 * detDiv;
    return this;
  };
  Matrix2D2.prototype.multiplyToRef = function(other, result) {
    var l0 = this.m[0];
    var l1 = this.m[1];
    var l2 = this.m[2];
    var l3 = this.m[3];
    var l4 = this.m[4];
    var l5 = this.m[5];
    var r0 = other.m[0];
    var r1 = other.m[1];
    var r2 = other.m[2];
    var r3 = other.m[3];
    var r4 = other.m[4];
    var r5 = other.m[5];
    result.m[0] = l0 * r0 + l1 * r2;
    result.m[1] = l0 * r1 + l1 * r3;
    result.m[2] = l2 * r0 + l3 * r2;
    result.m[3] = l2 * r1 + l3 * r3;
    result.m[4] = l4 * r0 + l5 * r2 + r4;
    result.m[5] = l4 * r1 + l5 * r3 + r5;
    return this;
  };
  Matrix2D2.prototype.transformCoordinates = function(x, y, result) {
    result.x = x * this.m[0] + y * this.m[2] + this.m[4];
    result.y = x * this.m[1] + y * this.m[3] + this.m[5];
    return this;
  };
  Matrix2D2.Identity = function() {
    return new Matrix2D2(1, 0, 0, 1, 0, 0);
  };
  Matrix2D2.TranslationToRef = function(x, y, result) {
    result.fromValues(1, 0, 0, 1, x, y);
  };
  Matrix2D2.ScalingToRef = function(x, y, result) {
    result.fromValues(x, 0, 0, y, 0, 0);
  };
  Matrix2D2.RotationToRef = function(angle, result) {
    var s = Math.sin(angle);
    var c = Math.cos(angle);
    result.fromValues(c, s, -s, c, 0, 0);
  };
  Matrix2D2.ComposeToRef = function(tx, ty, angle, scaleX, scaleY, parentMatrix, result) {
    Matrix2D2.TranslationToRef(tx, ty, Matrix2D2._TempPreTranslationMatrix);
    Matrix2D2.ScalingToRef(scaleX, scaleY, Matrix2D2._TempScalingMatrix);
    Matrix2D2.RotationToRef(angle, Matrix2D2._TempRotationMatrix);
    Matrix2D2.TranslationToRef(-tx, -ty, Matrix2D2._TempPostTranslationMatrix);
    Matrix2D2._TempPreTranslationMatrix.multiplyToRef(Matrix2D2._TempScalingMatrix, Matrix2D2._TempCompose0);
    Matrix2D2._TempCompose0.multiplyToRef(Matrix2D2._TempRotationMatrix, Matrix2D2._TempCompose1);
    if (parentMatrix) {
      Matrix2D2._TempCompose1.multiplyToRef(Matrix2D2._TempPostTranslationMatrix, Matrix2D2._TempCompose2);
      Matrix2D2._TempCompose2.multiplyToRef(parentMatrix, result);
    } else {
      Matrix2D2._TempCompose1.multiplyToRef(Matrix2D2._TempPostTranslationMatrix, result);
    }
  };
  Matrix2D2._TempPreTranslationMatrix = Matrix2D2.Identity();
  Matrix2D2._TempPostTranslationMatrix = Matrix2D2.Identity();
  Matrix2D2._TempRotationMatrix = Matrix2D2.Identity();
  Matrix2D2._TempScalingMatrix = Matrix2D2.Identity();
  Matrix2D2._TempCompose0 = Matrix2D2.Identity();
  Matrix2D2._TempCompose1 = Matrix2D2.Identity();
  Matrix2D2._TempCompose2 = Matrix2D2.Identity();
  return Matrix2D2;
}();

// node_modules/@babylonjs/gui/2D/controls/control.js
var Control = function() {
  function Control2(name4) {
    this.name = name4;
    this._alpha = 1;
    this._alphaSet = false;
    this._zIndex = 0;
    this._currentMeasure = Measure.Empty();
    this._fontFamily = "Arial";
    this._fontStyle = "";
    this._fontWeight = "";
    this._fontSize = new ValueAndUnit(18, ValueAndUnit.UNITMODE_PIXEL, false);
    this._width = new ValueAndUnit(1, ValueAndUnit.UNITMODE_PERCENTAGE, false);
    this._height = new ValueAndUnit(1, ValueAndUnit.UNITMODE_PERCENTAGE, false);
    this._color = "";
    this._style = null;
    this._horizontalAlignment = Control2.HORIZONTAL_ALIGNMENT_CENTER;
    this._verticalAlignment = Control2.VERTICAL_ALIGNMENT_CENTER;
    this._isDirty = true;
    this._wasDirty = false;
    this._tempParentMeasure = Measure.Empty();
    this._prevCurrentMeasureTransformedIntoGlobalSpace = Measure.Empty();
    this._cachedParentMeasure = Measure.Empty();
    this._paddingLeft = new ValueAndUnit(0);
    this._paddingRight = new ValueAndUnit(0);
    this._paddingTop = new ValueAndUnit(0);
    this._paddingBottom = new ValueAndUnit(0);
    this._left = new ValueAndUnit(0);
    this._top = new ValueAndUnit(0);
    this._scaleX = 1;
    this._scaleY = 1;
    this._rotation = 0;
    this._transformCenterX = 0.5;
    this._transformCenterY = 0.5;
    this._transformMatrix = Matrix2D.Identity();
    this._invertTransformMatrix = Matrix2D.Identity();
    this._transformedPosition = Vector2.Zero();
    this._isMatrixDirty = true;
    this._isVisible = true;
    this._isHighlighted = false;
    this._fontSet = false;
    this._dummyVector2 = Vector2.Zero();
    this._downCount = 0;
    this._enterCount = -1;
    this._doNotRender = false;
    this._downPointerIds = {};
    this._isEnabled = true;
    this._disabledColor = "#9a9a9a";
    this._disabledColorItem = "#6a6a6a";
    this._rebuildLayout = false;
    this._customData = {};
    this._isClipped = false;
    this._automaticSize = false;
    this.metadata = null;
    this.isHitTestVisible = true;
    this.isPointerBlocker = false;
    this.isFocusInvisible = false;
    this.clipChildren = true;
    this.clipContent = true;
    this.useBitmapCache = false;
    this._shadowOffsetX = 0;
    this._shadowOffsetY = 0;
    this._shadowBlur = 0;
    this._shadowColor = "black";
    this.hoverCursor = "";
    this._linkOffsetX = new ValueAndUnit(0);
    this._linkOffsetY = new ValueAndUnit(0);
    this.onWheelObservable = new Observable();
    this.onPointerMoveObservable = new Observable();
    this.onPointerOutObservable = new Observable();
    this.onPointerDownObservable = new Observable();
    this.onPointerUpObservable = new Observable();
    this.onPointerClickObservable = new Observable();
    this.onPointerEnterObservable = new Observable();
    this.onDirtyObservable = new Observable();
    this.onBeforeDrawObservable = new Observable();
    this.onAfterDrawObservable = new Observable();
    this.onDisposeObservable = new Observable();
    this.fixedRatio = 0;
    this._fixedRatioMasterIsWidth = true;
    this._tmpMeasureA = new Measure(0, 0, 0, 0);
  }
  Object.defineProperty(Control2.prototype, "shadowOffsetX", {
    get: function() {
      return this._shadowOffsetX;
    },
    set: function(value) {
      if (this._shadowOffsetX === value) {
        return;
      }
      this._shadowOffsetX = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "shadowOffsetY", {
    get: function() {
      return this._shadowOffsetY;
    },
    set: function(value) {
      if (this._shadowOffsetY === value) {
        return;
      }
      this._shadowOffsetY = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "shadowBlur", {
    get: function() {
      return this._shadowBlur;
    },
    set: function(value) {
      if (this._shadowBlur === value) {
        return;
      }
      this._shadowBlur = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "shadowColor", {
    get: function() {
      return this._shadowColor;
    },
    set: function(value) {
      if (this._shadowColor === value) {
        return;
      }
      this._shadowColor = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "typeName", {
    get: function() {
      return this._getTypeName();
    },
    enumerable: false,
    configurable: true
  });
  Control2.prototype.getClassName = function() {
    return this._getTypeName();
  };
  Object.defineProperty(Control2.prototype, "host", {
    get: function() {
      return this._host;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "fontOffset", {
    get: function() {
      return this._fontOffset;
    },
    set: function(offset) {
      this._fontOffset = offset;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "alpha", {
    get: function() {
      return this._alpha;
    },
    set: function(value) {
      if (this._alpha === value) {
        return;
      }
      this._alphaSet = true;
      this._alpha = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "isHighlighted", {
    get: function() {
      return this._isHighlighted;
    },
    set: function(value) {
      if (this._isHighlighted === value) {
        return;
      }
      this._isHighlighted = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "scaleX", {
    get: function() {
      return this._scaleX;
    },
    set: function(value) {
      if (this._scaleX === value) {
        return;
      }
      this._scaleX = value;
      this._markAsDirty();
      this._markMatrixAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "scaleY", {
    get: function() {
      return this._scaleY;
    },
    set: function(value) {
      if (this._scaleY === value) {
        return;
      }
      this._scaleY = value;
      this._markAsDirty();
      this._markMatrixAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "rotation", {
    get: function() {
      return this._rotation;
    },
    set: function(value) {
      if (this._rotation === value) {
        return;
      }
      this._rotation = value;
      this._markAsDirty();
      this._markMatrixAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "transformCenterY", {
    get: function() {
      return this._transformCenterY;
    },
    set: function(value) {
      if (this._transformCenterY === value) {
        return;
      }
      this._transformCenterY = value;
      this._markAsDirty();
      this._markMatrixAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "transformCenterX", {
    get: function() {
      return this._transformCenterX;
    },
    set: function(value) {
      if (this._transformCenterX === value) {
        return;
      }
      this._transformCenterX = value;
      this._markAsDirty();
      this._markMatrixAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "horizontalAlignment", {
    get: function() {
      return this._horizontalAlignment;
    },
    set: function(value) {
      if (this._horizontalAlignment === value) {
        return;
      }
      this._horizontalAlignment = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "verticalAlignment", {
    get: function() {
      return this._verticalAlignment;
    },
    set: function(value) {
      if (this._verticalAlignment === value) {
        return;
      }
      this._verticalAlignment = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "width", {
    get: function() {
      return this._width.toString(this._host);
    },
    set: function(value) {
      this._fixedRatioMasterIsWidth = true;
      if (this._width.toString(this._host) === value) {
        return;
      }
      if (this._width.fromString(value)) {
        this._markAsDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "widthInPixels", {
    get: function() {
      return this._width.getValueInPixel(this._host, this._cachedParentMeasure.width);
    },
    set: function(value) {
      if (isNaN(value)) {
        return;
      }
      this._fixedRatioMasterIsWidth = true;
      this.width = value + "px";
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "height", {
    get: function() {
      return this._height.toString(this._host);
    },
    set: function(value) {
      this._fixedRatioMasterIsWidth = false;
      if (this._height.toString(this._host) === value) {
        return;
      }
      if (this._height.fromString(value)) {
        this._markAsDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "heightInPixels", {
    get: function() {
      return this._height.getValueInPixel(this._host, this._cachedParentMeasure.height);
    },
    set: function(value) {
      if (isNaN(value)) {
        return;
      }
      this._fixedRatioMasterIsWidth = false;
      this.height = value + "px";
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "fontFamily", {
    get: function() {
      if (!this._fontSet) {
        return "";
      }
      return this._fontFamily;
    },
    set: function(value) {
      if (this._fontFamily === value) {
        return;
      }
      this._fontFamily = value;
      this._resetFontCache();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "fontStyle", {
    get: function() {
      return this._fontStyle;
    },
    set: function(value) {
      if (this._fontStyle === value) {
        return;
      }
      this._fontStyle = value;
      this._resetFontCache();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "fontWeight", {
    get: function() {
      return this._fontWeight;
    },
    set: function(value) {
      if (this._fontWeight === value) {
        return;
      }
      this._fontWeight = value;
      this._resetFontCache();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "style", {
    get: function() {
      return this._style;
    },
    set: function(value) {
      var _this = this;
      if (this._style) {
        this._style.onChangedObservable.remove(this._styleObserver);
        this._styleObserver = null;
      }
      this._style = value;
      if (this._style) {
        this._styleObserver = this._style.onChangedObservable.add(function() {
          _this._markAsDirty();
          _this._resetFontCache();
        });
      }
      this._markAsDirty();
      this._resetFontCache();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "_isFontSizeInPercentage", {
    get: function() {
      return this._fontSize.isPercentage;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "fontSizeInPixels", {
    get: function() {
      var fontSizeToUse = this._style ? this._style._fontSize : this._fontSize;
      if (fontSizeToUse.isPixel) {
        return fontSizeToUse.getValue(this._host);
      }
      return fontSizeToUse.getValueInPixel(this._host, this._tempParentMeasure.height || this._cachedParentMeasure.height);
    },
    set: function(value) {
      if (isNaN(value)) {
        return;
      }
      this.fontSize = value + "px";
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "fontSize", {
    get: function() {
      return this._fontSize.toString(this._host);
    },
    set: function(value) {
      if (this._fontSize.toString(this._host) === value) {
        return;
      }
      if (this._fontSize.fromString(value)) {
        this._markAsDirty();
        this._resetFontCache();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "color", {
    get: function() {
      return this._color;
    },
    set: function(value) {
      if (this._color === value) {
        return;
      }
      this._color = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "zIndex", {
    get: function() {
      return this._zIndex;
    },
    set: function(value) {
      if (this.zIndex === value) {
        return;
      }
      this._zIndex = value;
      if (this.parent) {
        this.parent._reOrderControl(this);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "notRenderable", {
    get: function() {
      return this._doNotRender;
    },
    set: function(value) {
      if (this._doNotRender === value) {
        return;
      }
      this._doNotRender = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "isVisible", {
    get: function() {
      return this._isVisible;
    },
    set: function(value) {
      if (this._isVisible === value) {
        return;
      }
      this._isVisible = value;
      this._markAsDirty(true);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "isDirty", {
    get: function() {
      return this._isDirty;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "linkedMesh", {
    get: function() {
      return this._linkedMesh;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "paddingLeft", {
    get: function() {
      return this._paddingLeft.toString(this._host);
    },
    set: function(value) {
      if (this._paddingLeft.fromString(value)) {
        this._markAsDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "paddingLeftInPixels", {
    get: function() {
      return this._paddingLeft.getValueInPixel(this._host, this._cachedParentMeasure.width);
    },
    set: function(value) {
      if (isNaN(value)) {
        return;
      }
      this.paddingLeft = value + "px";
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "paddingRight", {
    get: function() {
      return this._paddingRight.toString(this._host);
    },
    set: function(value) {
      if (this._paddingRight.fromString(value)) {
        this._markAsDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "paddingRightInPixels", {
    get: function() {
      return this._paddingRight.getValueInPixel(this._host, this._cachedParentMeasure.width);
    },
    set: function(value) {
      if (isNaN(value)) {
        return;
      }
      this.paddingRight = value + "px";
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "paddingTop", {
    get: function() {
      return this._paddingTop.toString(this._host);
    },
    set: function(value) {
      if (this._paddingTop.fromString(value)) {
        this._markAsDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "paddingTopInPixels", {
    get: function() {
      return this._paddingTop.getValueInPixel(this._host, this._cachedParentMeasure.height);
    },
    set: function(value) {
      if (isNaN(value)) {
        return;
      }
      this.paddingTop = value + "px";
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "paddingBottom", {
    get: function() {
      return this._paddingBottom.toString(this._host);
    },
    set: function(value) {
      if (this._paddingBottom.fromString(value)) {
        this._markAsDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "paddingBottomInPixels", {
    get: function() {
      return this._paddingBottom.getValueInPixel(this._host, this._cachedParentMeasure.height);
    },
    set: function(value) {
      if (isNaN(value)) {
        return;
      }
      this.paddingBottom = value + "px";
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "left", {
    get: function() {
      return this._left.toString(this._host);
    },
    set: function(value) {
      if (this._left.fromString(value)) {
        this._markAsDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "leftInPixels", {
    get: function() {
      return this._left.getValueInPixel(this._host, this._cachedParentMeasure.width);
    },
    set: function(value) {
      if (isNaN(value)) {
        return;
      }
      this.left = value + "px";
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "top", {
    get: function() {
      return this._top.toString(this._host);
    },
    set: function(value) {
      if (this._top.fromString(value)) {
        this._markAsDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "topInPixels", {
    get: function() {
      return this._top.getValueInPixel(this._host, this._cachedParentMeasure.height);
    },
    set: function(value) {
      if (isNaN(value)) {
        return;
      }
      this.top = value + "px";
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "linkOffsetX", {
    get: function() {
      return this._linkOffsetX.toString(this._host);
    },
    set: function(value) {
      if (this._linkOffsetX.fromString(value)) {
        this._markAsDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "linkOffsetXInPixels", {
    get: function() {
      return this._linkOffsetX.getValueInPixel(this._host, this._cachedParentMeasure.width);
    },
    set: function(value) {
      if (isNaN(value)) {
        return;
      }
      this.linkOffsetX = value + "px";
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "linkOffsetY", {
    get: function() {
      return this._linkOffsetY.toString(this._host);
    },
    set: function(value) {
      if (this._linkOffsetY.fromString(value)) {
        this._markAsDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "linkOffsetYInPixels", {
    get: function() {
      return this._linkOffsetY.getValueInPixel(this._host, this._cachedParentMeasure.height);
    },
    set: function(value) {
      if (isNaN(value)) {
        return;
      }
      this.linkOffsetY = value + "px";
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "centerX", {
    get: function() {
      return this._currentMeasure.left + this._currentMeasure.width / 2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "centerY", {
    get: function() {
      return this._currentMeasure.top + this._currentMeasure.height / 2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "isEnabled", {
    get: function() {
      return this._isEnabled;
    },
    set: function(value) {
      if (this._isEnabled === value) {
        return;
      }
      this._isEnabled = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "disabledColor", {
    get: function() {
      return this._disabledColor;
    },
    set: function(value) {
      if (this._disabledColor === value) {
        return;
      }
      this._disabledColor = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2.prototype, "disabledColorItem", {
    get: function() {
      return this._disabledColorItem;
    },
    set: function(value) {
      if (this._disabledColorItem === value) {
        return;
      }
      this._disabledColorItem = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Control2.prototype._getTypeName = function() {
    return "Control";
  };
  Control2.prototype.getAscendantOfClass = function(className) {
    if (!this.parent) {
      return null;
    }
    if (this.parent.getClassName() === className) {
      return this.parent;
    }
    return this.parent.getAscendantOfClass(className);
  };
  Control2.prototype._resetFontCache = function() {
    this._fontSet = true;
    this._markAsDirty();
  };
  Control2.prototype.isAscendant = function(container) {
    if (!this.parent) {
      return false;
    }
    if (this.parent === container) {
      return true;
    }
    return this.parent.isAscendant(container);
  };
  Control2.prototype.getLocalCoordinates = function(globalCoordinates) {
    var result = Vector2.Zero();
    this.getLocalCoordinatesToRef(globalCoordinates, result);
    return result;
  };
  Control2.prototype.getLocalCoordinatesToRef = function(globalCoordinates, result) {
    result.x = globalCoordinates.x - this._currentMeasure.left;
    result.y = globalCoordinates.y - this._currentMeasure.top;
    return this;
  };
  Control2.prototype.getParentLocalCoordinates = function(globalCoordinates) {
    var result = Vector2.Zero();
    result.x = globalCoordinates.x - this._cachedParentMeasure.left;
    result.y = globalCoordinates.y - this._cachedParentMeasure.top;
    return result;
  };
  Control2.prototype.moveToVector3 = function(position, scene) {
    if (!this._host || this.parent !== this._host._rootContainer) {
      Tools.Error("Cannot move a control to a vector3 if the control is not at root level");
      return;
    }
    this.horizontalAlignment = Control2.HORIZONTAL_ALIGNMENT_LEFT;
    this.verticalAlignment = Control2.VERTICAL_ALIGNMENT_TOP;
    var globalViewport = this._host._getGlobalViewport(scene);
    var projectedPosition = Vector3.Project(position, Matrix.Identity(), scene.getTransformMatrix(), globalViewport);
    this._moveToProjectedPosition(projectedPosition);
    if (projectedPosition.z < 0 || projectedPosition.z > 1) {
      this.notRenderable = true;
      return;
    }
    this.notRenderable = false;
  };
  Control2.prototype.getDescendantsToRef = function(results, directDescendantsOnly, predicate) {
    if (directDescendantsOnly === void 0) {
      directDescendantsOnly = false;
    }
  };
  Control2.prototype.getDescendants = function(directDescendantsOnly, predicate) {
    var results = new Array();
    this.getDescendantsToRef(results, directDescendantsOnly, predicate);
    return results;
  };
  Control2.prototype.linkWithMesh = function(mesh) {
    if (!this._host || this.parent && this.parent !== this._host._rootContainer) {
      if (mesh) {
        Tools.Error("Cannot link a control to a mesh if the control is not at root level");
      }
      return;
    }
    var index = this._host._linkedControls.indexOf(this);
    if (index !== -1) {
      this._linkedMesh = mesh;
      if (!mesh) {
        this._host._linkedControls.splice(index, 1);
      }
      return;
    } else if (!mesh) {
      return;
    }
    this.horizontalAlignment = Control2.HORIZONTAL_ALIGNMENT_LEFT;
    this.verticalAlignment = Control2.VERTICAL_ALIGNMENT_TOP;
    this._linkedMesh = mesh;
    this._host._linkedControls.push(this);
  };
  Control2.prototype._moveToProjectedPosition = function(projectedPosition) {
    var oldLeft = this._left.getValue(this._host);
    var oldTop = this._top.getValue(this._host);
    var newLeft = projectedPosition.x + this._linkOffsetX.getValue(this._host) - this._currentMeasure.width / 2;
    var newTop = projectedPosition.y + this._linkOffsetY.getValue(this._host) - this._currentMeasure.height / 2;
    if (this._left.ignoreAdaptiveScaling && this._top.ignoreAdaptiveScaling) {
      if (Math.abs(newLeft - oldLeft) < 0.5) {
        newLeft = oldLeft;
      }
      if (Math.abs(newTop - oldTop) < 0.5) {
        newTop = oldTop;
      }
    }
    this.left = newLeft + "px";
    this.top = newTop + "px";
    this._left.ignoreAdaptiveScaling = true;
    this._top.ignoreAdaptiveScaling = true;
    this._markAsDirty();
  };
  Control2.prototype._offsetLeft = function(offset) {
    this._isDirty = true;
    this._currentMeasure.left += offset;
  };
  Control2.prototype._offsetTop = function(offset) {
    this._isDirty = true;
    this._currentMeasure.top += offset;
  };
  Control2.prototype._markMatrixAsDirty = function() {
    this._isMatrixDirty = true;
    this._flagDescendantsAsMatrixDirty();
  };
  Control2.prototype._flagDescendantsAsMatrixDirty = function() {
  };
  Control2.prototype._intersectsRect = function(rect) {
    this._currentMeasure.transformToRef(this._transformMatrix, this._tmpMeasureA);
    if (this._tmpMeasureA.left >= rect.left + rect.width) {
      return false;
    }
    if (this._tmpMeasureA.top >= rect.top + rect.height) {
      return false;
    }
    if (this._tmpMeasureA.left + this._tmpMeasureA.width <= rect.left) {
      return false;
    }
    if (this._tmpMeasureA.top + this._tmpMeasureA.height <= rect.top) {
      return false;
    }
    return true;
  };
  Control2.prototype.invalidateRect = function() {
    this._transform();
    if (this.host && this.host.useInvalidateRectOptimization) {
      this._currentMeasure.transformToRef(this._transformMatrix, this._tmpMeasureA);
      Measure.CombineToRef(this._tmpMeasureA, this._prevCurrentMeasureTransformedIntoGlobalSpace, this._tmpMeasureA);
      if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {
        var shadowOffsetX = this.shadowOffsetX;
        var shadowOffsetY = this.shadowOffsetY;
        var shadowBlur = this.shadowBlur;
        var leftShadowOffset = Math.min(Math.min(shadowOffsetX, 0) - shadowBlur * 2, 0);
        var rightShadowOffset = Math.max(Math.max(shadowOffsetX, 0) + shadowBlur * 2, 0);
        var topShadowOffset = Math.min(Math.min(shadowOffsetY, 0) - shadowBlur * 2, 0);
        var bottomShadowOffset = Math.max(Math.max(shadowOffsetY, 0) + shadowBlur * 2, 0);
        this.host.invalidateRect(Math.floor(this._tmpMeasureA.left + leftShadowOffset), Math.floor(this._tmpMeasureA.top + topShadowOffset), Math.ceil(this._tmpMeasureA.left + this._tmpMeasureA.width + rightShadowOffset), Math.ceil(this._tmpMeasureA.top + this._tmpMeasureA.height + bottomShadowOffset));
      } else {
        this.host.invalidateRect(Math.floor(this._tmpMeasureA.left), Math.floor(this._tmpMeasureA.top), Math.ceil(this._tmpMeasureA.left + this._tmpMeasureA.width), Math.ceil(this._tmpMeasureA.top + this._tmpMeasureA.height));
      }
    }
  };
  Control2.prototype._markAsDirty = function(force) {
    if (force === void 0) {
      force = false;
    }
    if (!this._isVisible && !force) {
      return;
    }
    this._isDirty = true;
    if (this._host) {
      this._host.markAsDirty();
    }
  };
  Control2.prototype._markAllAsDirty = function() {
    this._markAsDirty();
    if (this._font) {
      this._prepareFont();
    }
  };
  Control2.prototype._link = function(host) {
    this._host = host;
    if (this._host) {
      this.uniqueId = this._host.getScene().getUniqueId();
    }
  };
  Control2.prototype._transform = function(context) {
    if (!this._isMatrixDirty && this._scaleX === 1 && this._scaleY === 1 && this._rotation === 0) {
      return;
    }
    var offsetX = this._currentMeasure.width * this._transformCenterX + this._currentMeasure.left;
    var offsetY = this._currentMeasure.height * this._transformCenterY + this._currentMeasure.top;
    if (context) {
      context.translate(offsetX, offsetY);
      context.rotate(this._rotation);
      context.scale(this._scaleX, this._scaleY);
      context.translate(-offsetX, -offsetY);
    }
    if (this._isMatrixDirty || this._cachedOffsetX !== offsetX || this._cachedOffsetY !== offsetY) {
      this._cachedOffsetX = offsetX;
      this._cachedOffsetY = offsetY;
      this._isMatrixDirty = false;
      this._flagDescendantsAsMatrixDirty();
      Matrix2D.ComposeToRef(-offsetX, -offsetY, this._rotation, this._scaleX, this._scaleY, this.parent ? this.parent._transformMatrix : null, this._transformMatrix);
      this._transformMatrix.invertToRef(this._invertTransformMatrix);
    }
  };
  Control2.prototype._renderHighlight = function(context) {
    if (!this.isHighlighted) {
      return;
    }
    context.save();
    context.strokeStyle = "#4affff";
    context.lineWidth = 2;
    this._renderHighlightSpecific(context);
    context.restore();
  };
  Control2.prototype._renderHighlightSpecific = function(context) {
    context.strokeRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);
  };
  Control2.prototype._applyStates = function(context) {
    if (this._isFontSizeInPercentage) {
      this._fontSet = true;
    }
    if (this._fontSet) {
      this._prepareFont();
      this._fontSet = false;
    }
    if (this._font) {
      context.font = this._font;
    }
    if (this._color) {
      context.fillStyle = this._color;
    }
    if (Control2.AllowAlphaInheritance) {
      context.globalAlpha *= this._alpha;
    } else if (this._alphaSet) {
      context.globalAlpha = this.parent ? this.parent.alpha * this._alpha : this._alpha;
    }
  };
  Control2.prototype._layout = function(parentMeasure, context) {
    if (!this.isDirty && (!this.isVisible || this.notRenderable)) {
      return false;
    }
    if (this._isDirty || !this._cachedParentMeasure.isEqualsTo(parentMeasure)) {
      this.host._numLayoutCalls++;
      this._currentMeasure.addAndTransformToRef(this._transformMatrix, -this.paddingLeftInPixels | 0, -this.paddingTopInPixels | 0, this.paddingRightInPixels | 0, this.paddingBottomInPixels | 0, this._prevCurrentMeasureTransformedIntoGlobalSpace);
      context.save();
      this._applyStates(context);
      var rebuildCount = 0;
      do {
        this._rebuildLayout = false;
        this._processMeasures(parentMeasure, context);
        rebuildCount++;
      } while (this._rebuildLayout && rebuildCount < 3);
      if (rebuildCount >= 3) {
        Logger.Error("Layout cycle detected in GUI (Control name=" + this.name + ", uniqueId=" + this.uniqueId + ")");
      }
      context.restore();
      this.invalidateRect();
      this._evaluateClippingState(parentMeasure);
    }
    this._wasDirty = this._isDirty;
    this._isDirty = false;
    return true;
  };
  Control2.prototype._processMeasures = function(parentMeasure, context) {
    this._currentMeasure.copyFrom(parentMeasure);
    this._preMeasure(parentMeasure, context);
    this._measure();
    this._computeAlignment(parentMeasure, context);
    this._currentMeasure.left = this._currentMeasure.left | 0;
    this._currentMeasure.top = this._currentMeasure.top | 0;
    this._currentMeasure.width = this._currentMeasure.width | 0;
    this._currentMeasure.height = this._currentMeasure.height | 0;
    this._additionalProcessing(parentMeasure, context);
    this._cachedParentMeasure.copyFrom(parentMeasure);
    if (this.onDirtyObservable.hasObservers()) {
      this.onDirtyObservable.notifyObservers(this);
    }
  };
  Control2.prototype._evaluateClippingState = function(parentMeasure) {
    if (this.parent && this.parent.clipChildren) {
      if (this._currentMeasure.left > parentMeasure.left + parentMeasure.width) {
        this._isClipped = true;
        return;
      }
      if (this._currentMeasure.left + this._currentMeasure.width < parentMeasure.left) {
        this._isClipped = true;
        return;
      }
      if (this._currentMeasure.top > parentMeasure.top + parentMeasure.height) {
        this._isClipped = true;
        return;
      }
      if (this._currentMeasure.top + this._currentMeasure.height < parentMeasure.top) {
        this._isClipped = true;
        return;
      }
    }
    this._isClipped = false;
  };
  Control2.prototype._measure = function() {
    if (this._width.isPixel) {
      this._currentMeasure.width = this._width.getValue(this._host);
    } else {
      this._currentMeasure.width *= this._width.getValue(this._host);
    }
    if (this._height.isPixel) {
      this._currentMeasure.height = this._height.getValue(this._host);
    } else {
      this._currentMeasure.height *= this._height.getValue(this._host);
    }
    if (this.fixedRatio !== 0) {
      if (this._fixedRatioMasterIsWidth) {
        this._currentMeasure.height = this._currentMeasure.width * this.fixedRatio;
      } else {
        this._currentMeasure.width = this._currentMeasure.height * this.fixedRatio;
      }
    }
  };
  Control2.prototype._computeAlignment = function(parentMeasure, context) {
    var width = this._currentMeasure.width;
    var height = this._currentMeasure.height;
    var parentWidth = parentMeasure.width;
    var parentHeight = parentMeasure.height;
    var x = 0;
    var y = 0;
    switch (this.horizontalAlignment) {
      case Control2.HORIZONTAL_ALIGNMENT_LEFT:
        x = 0;
        break;
      case Control2.HORIZONTAL_ALIGNMENT_RIGHT:
        x = parentWidth - width;
        break;
      case Control2.HORIZONTAL_ALIGNMENT_CENTER:
        x = (parentWidth - width) / 2;
        break;
    }
    switch (this.verticalAlignment) {
      case Control2.VERTICAL_ALIGNMENT_TOP:
        y = 0;
        break;
      case Control2.VERTICAL_ALIGNMENT_BOTTOM:
        y = parentHeight - height;
        break;
      case Control2.VERTICAL_ALIGNMENT_CENTER:
        y = (parentHeight - height) / 2;
        break;
    }
    if (this._paddingLeft.isPixel) {
      this._currentMeasure.left += this._paddingLeft.getValue(this._host);
      this._currentMeasure.width -= this._paddingLeft.getValue(this._host);
    } else {
      this._currentMeasure.left += parentWidth * this._paddingLeft.getValue(this._host);
      this._currentMeasure.width -= parentWidth * this._paddingLeft.getValue(this._host);
    }
    if (this._paddingRight.isPixel) {
      this._currentMeasure.width -= this._paddingRight.getValue(this._host);
    } else {
      this._currentMeasure.width -= parentWidth * this._paddingRight.getValue(this._host);
    }
    if (this._paddingTop.isPixel) {
      this._currentMeasure.top += this._paddingTop.getValue(this._host);
      this._currentMeasure.height -= this._paddingTop.getValue(this._host);
    } else {
      this._currentMeasure.top += parentHeight * this._paddingTop.getValue(this._host);
      this._currentMeasure.height -= parentHeight * this._paddingTop.getValue(this._host);
    }
    if (this._paddingBottom.isPixel) {
      this._currentMeasure.height -= this._paddingBottom.getValue(this._host);
    } else {
      this._currentMeasure.height -= parentHeight * this._paddingBottom.getValue(this._host);
    }
    if (this._left.isPixel) {
      this._currentMeasure.left += this._left.getValue(this._host);
    } else {
      this._currentMeasure.left += parentWidth * this._left.getValue(this._host);
    }
    if (this._top.isPixel) {
      this._currentMeasure.top += this._top.getValue(this._host);
    } else {
      this._currentMeasure.top += parentHeight * this._top.getValue(this._host);
    }
    this._currentMeasure.left += x;
    this._currentMeasure.top += y;
  };
  Control2.prototype._preMeasure = function(parentMeasure, context) {
  };
  Control2.prototype._additionalProcessing = function(parentMeasure, context) {
  };
  Control2.prototype._clipForChildren = function(context) {
  };
  Control2.prototype._clip = function(context, invalidatedRectangle) {
    context.beginPath();
    Control2._ClipMeasure.copyFrom(this._currentMeasure);
    if (invalidatedRectangle) {
      invalidatedRectangle.transformToRef(this._invertTransformMatrix, this._tmpMeasureA);
      var intersection = new Measure(0, 0, 0, 0);
      intersection.left = Math.max(this._tmpMeasureA.left, this._currentMeasure.left);
      intersection.top = Math.max(this._tmpMeasureA.top, this._currentMeasure.top);
      intersection.width = Math.min(this._tmpMeasureA.left + this._tmpMeasureA.width, this._currentMeasure.left + this._currentMeasure.width) - intersection.left;
      intersection.height = Math.min(this._tmpMeasureA.top + this._tmpMeasureA.height, this._currentMeasure.top + this._currentMeasure.height) - intersection.top;
      Control2._ClipMeasure.copyFrom(intersection);
    }
    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {
      var shadowOffsetX = this.shadowOffsetX;
      var shadowOffsetY = this.shadowOffsetY;
      var shadowBlur = this.shadowBlur;
      var leftShadowOffset = Math.min(Math.min(shadowOffsetX, 0) - shadowBlur * 2, 0);
      var rightShadowOffset = Math.max(Math.max(shadowOffsetX, 0) + shadowBlur * 2, 0);
      var topShadowOffset = Math.min(Math.min(shadowOffsetY, 0) - shadowBlur * 2, 0);
      var bottomShadowOffset = Math.max(Math.max(shadowOffsetY, 0) + shadowBlur * 2, 0);
      context.rect(Control2._ClipMeasure.left + leftShadowOffset, Control2._ClipMeasure.top + topShadowOffset, Control2._ClipMeasure.width + rightShadowOffset - leftShadowOffset, Control2._ClipMeasure.height + bottomShadowOffset - topShadowOffset);
    } else {
      context.rect(Control2._ClipMeasure.left, Control2._ClipMeasure.top, Control2._ClipMeasure.width, Control2._ClipMeasure.height);
    }
    context.clip();
  };
  Control2.prototype._render = function(context, invalidatedRectangle) {
    if (!this.isVisible || this.notRenderable || this._isClipped) {
      this._isDirty = false;
      return false;
    }
    this.host._numRenderCalls++;
    context.save();
    this._applyStates(context);
    this._transform(context);
    if (this.clipContent) {
      this._clip(context, invalidatedRectangle);
    }
    if (this.onBeforeDrawObservable.hasObservers()) {
      this.onBeforeDrawObservable.notifyObservers(this);
    }
    if (this.useBitmapCache && !this._wasDirty && this._cacheData) {
      context.putImageData(this._cacheData, this._currentMeasure.left, this._currentMeasure.top);
    } else {
      this._draw(context, invalidatedRectangle);
    }
    if (this.useBitmapCache && this._wasDirty) {
      this._cacheData = context.getImageData(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);
    }
    this._renderHighlight(context);
    if (this.onAfterDrawObservable.hasObservers()) {
      this.onAfterDrawObservable.notifyObservers(this);
    }
    context.restore();
    return true;
  };
  Control2.prototype._draw = function(context, invalidatedRectangle) {
  };
  Control2.prototype.contains = function(x, y) {
    this._invertTransformMatrix.transformCoordinates(x, y, this._transformedPosition);
    x = this._transformedPosition.x;
    y = this._transformedPosition.y;
    if (x < this._currentMeasure.left) {
      return false;
    }
    if (x > this._currentMeasure.left + this._currentMeasure.width) {
      return false;
    }
    if (y < this._currentMeasure.top) {
      return false;
    }
    if (y > this._currentMeasure.top + this._currentMeasure.height) {
      return false;
    }
    if (this.isPointerBlocker) {
      this._host._shouldBlockPointer = true;
    }
    return true;
  };
  Control2.prototype._processPicking = function(x, y, pi, type, pointerId, buttonIndex, deltaX, deltaY) {
    if (!this._isEnabled) {
      return false;
    }
    if (!this.isHitTestVisible || !this.isVisible || this._doNotRender) {
      return false;
    }
    if (!this.contains(x, y)) {
      return false;
    }
    this._processObservables(type, x, y, pi, pointerId, buttonIndex, deltaX, deltaY);
    return true;
  };
  Control2.prototype._onPointerMove = function(target, coordinates, pointerId, pi) {
    var canNotify = this.onPointerMoveObservable.notifyObservers(coordinates, -1, target, this, pi);
    if (canNotify && this.parent != null) {
      this.parent._onPointerMove(target, coordinates, pointerId, pi);
    }
  };
  Control2.prototype._onPointerEnter = function(target, pi) {
    if (!this._isEnabled) {
      return false;
    }
    if (this._enterCount > 0) {
      return false;
    }
    if (this._enterCount === -1) {
      this._enterCount = 0;
    }
    this._enterCount++;
    var canNotify = this.onPointerEnterObservable.notifyObservers(this, -1, target, this, pi);
    if (canNotify && this.parent != null) {
      this.parent._onPointerEnter(target, pi);
    }
    return true;
  };
  Control2.prototype._onPointerOut = function(target, pi, force) {
    if (force === void 0) {
      force = false;
    }
    if (!force && (!this._isEnabled || target === this)) {
      return;
    }
    this._enterCount = 0;
    var canNotify = true;
    if (!target.isAscendant(this)) {
      canNotify = this.onPointerOutObservable.notifyObservers(this, -1, target, this, pi);
    }
    if (canNotify && this.parent != null) {
      this.parent._onPointerOut(target, pi, force);
    }
  };
  Control2.prototype._onPointerDown = function(target, coordinates, pointerId, buttonIndex, pi) {
    this._onPointerEnter(this, pi);
    if (this._downCount !== 0) {
      return false;
    }
    this._downCount++;
    this._downPointerIds[pointerId] = true;
    var canNotify = this.onPointerDownObservable.notifyObservers(new Vector2WithInfo(coordinates, buttonIndex), -1, target, this, pi);
    if (canNotify && this.parent != null) {
      this.parent._onPointerDown(target, coordinates, pointerId, buttonIndex, pi);
    }
    return true;
  };
  Control2.prototype._onPointerUp = function(target, coordinates, pointerId, buttonIndex, notifyClick, pi) {
    if (!this._isEnabled) {
      return;
    }
    this._downCount = 0;
    delete this._downPointerIds[pointerId];
    var canNotifyClick = notifyClick;
    if (notifyClick && (this._enterCount > 0 || this._enterCount === -1)) {
      canNotifyClick = this.onPointerClickObservable.notifyObservers(new Vector2WithInfo(coordinates, buttonIndex), -1, target, this, pi);
    }
    var canNotify = this.onPointerUpObservable.notifyObservers(new Vector2WithInfo(coordinates, buttonIndex), -1, target, this, pi);
    if (canNotify && this.parent != null) {
      this.parent._onPointerUp(target, coordinates, pointerId, buttonIndex, canNotifyClick, pi);
    }
  };
  Control2.prototype._forcePointerUp = function(pointerId) {
    if (pointerId === void 0) {
      pointerId = null;
    }
    if (pointerId !== null) {
      this._onPointerUp(this, Vector2.Zero(), pointerId, 0, true);
    } else {
      for (var key in this._downPointerIds) {
        this._onPointerUp(this, Vector2.Zero(), +key, 0, true);
      }
    }
  };
  Control2.prototype._onWheelScroll = function(deltaX, deltaY) {
    if (!this._isEnabled) {
      return;
    }
    var canNotify = this.onWheelObservable.notifyObservers(new Vector2(deltaX, deltaY));
    if (canNotify && this.parent != null) {
      this.parent._onWheelScroll(deltaX, deltaY);
    }
  };
  Control2.prototype._onCanvasBlur = function() {
  };
  Control2.prototype._processObservables = function(type, x, y, pi, pointerId, buttonIndex, deltaX, deltaY) {
    if (!this._isEnabled) {
      return false;
    }
    this._dummyVector2.copyFromFloats(x, y);
    if (type === PointerEventTypes.POINTERMOVE) {
      this._onPointerMove(this, this._dummyVector2, pointerId, pi);
      var previousControlOver = this._host._lastControlOver[pointerId];
      if (previousControlOver && previousControlOver !== this) {
        previousControlOver._onPointerOut(this, pi);
      }
      if (previousControlOver !== this) {
        this._onPointerEnter(this, pi);
      }
      this._host._lastControlOver[pointerId] = this;
      return true;
    }
    if (type === PointerEventTypes.POINTERDOWN) {
      this._onPointerDown(this, this._dummyVector2, pointerId, buttonIndex, pi);
      this._host._registerLastControlDown(this, pointerId);
      this._host._lastPickedControl = this;
      return true;
    }
    if (type === PointerEventTypes.POINTERUP) {
      if (this._host._lastControlDown[pointerId]) {
        this._host._lastControlDown[pointerId]._onPointerUp(this, this._dummyVector2, pointerId, buttonIndex, true, pi);
      }
      delete this._host._lastControlDown[pointerId];
      return true;
    }
    if (type === PointerEventTypes.POINTERWHEEL) {
      if (this._host._lastControlOver[pointerId]) {
        this._host._lastControlOver[pointerId]._onWheelScroll(deltaX, deltaY);
        return true;
      }
    }
    return false;
  };
  Control2.prototype._prepareFont = function() {
    if (!this._font && !this._fontSet) {
      return;
    }
    if (this._style) {
      this._font = this._style.fontStyle + " " + this._style.fontWeight + " " + this.fontSizeInPixels + "px " + this._style.fontFamily;
    } else {
      this._font = this._fontStyle + " " + this._fontWeight + " " + this.fontSizeInPixels + "px " + this._fontFamily;
    }
    this._fontOffset = Control2._GetFontOffset(this._font);
  };
  Control2.prototype.dispose = function() {
    this.onDirtyObservable.clear();
    this.onBeforeDrawObservable.clear();
    this.onAfterDrawObservable.clear();
    this.onPointerDownObservable.clear();
    this.onPointerEnterObservable.clear();
    this.onPointerMoveObservable.clear();
    this.onPointerOutObservable.clear();
    this.onPointerUpObservable.clear();
    this.onPointerClickObservable.clear();
    this.onWheelObservable.clear();
    if (this._styleObserver && this._style) {
      this._style.onChangedObservable.remove(this._styleObserver);
      this._styleObserver = null;
    }
    if (this.parent) {
      this.parent.removeControl(this);
      this.parent = null;
    }
    if (this._host) {
      var index = this._host._linkedControls.indexOf(this);
      if (index > -1) {
        this.linkWithMesh(null);
      }
    }
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
  };
  Object.defineProperty(Control2, "HORIZONTAL_ALIGNMENT_LEFT", {
    get: function() {
      return Control2._HORIZONTAL_ALIGNMENT_LEFT;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2, "HORIZONTAL_ALIGNMENT_RIGHT", {
    get: function() {
      return Control2._HORIZONTAL_ALIGNMENT_RIGHT;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2, "HORIZONTAL_ALIGNMENT_CENTER", {
    get: function() {
      return Control2._HORIZONTAL_ALIGNMENT_CENTER;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2, "VERTICAL_ALIGNMENT_TOP", {
    get: function() {
      return Control2._VERTICAL_ALIGNMENT_TOP;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2, "VERTICAL_ALIGNMENT_BOTTOM", {
    get: function() {
      return Control2._VERTICAL_ALIGNMENT_BOTTOM;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control2, "VERTICAL_ALIGNMENT_CENTER", {
    get: function() {
      return Control2._VERTICAL_ALIGNMENT_CENTER;
    },
    enumerable: false,
    configurable: true
  });
  Control2._GetFontOffset = function(font) {
    if (Control2._FontHeightSizes[font]) {
      return Control2._FontHeightSizes[font];
    }
    var text = document.createElement("span");
    text.innerHTML = "Hg";
    text.style.font = font;
    var block = document.createElement("div");
    block.style.display = "inline-block";
    block.style.width = "1px";
    block.style.height = "0px";
    block.style.verticalAlign = "bottom";
    var div = document.createElement("div");
    div.style.whiteSpace = "nowrap";
    div.appendChild(text);
    div.appendChild(block);
    document.body.appendChild(div);
    var fontAscent = 0;
    var fontHeight = 0;
    try {
      fontHeight = block.getBoundingClientRect().top - text.getBoundingClientRect().top;
      block.style.verticalAlign = "baseline";
      fontAscent = block.getBoundingClientRect().top - text.getBoundingClientRect().top;
    } finally {
      document.body.removeChild(div);
    }
    var result = { ascent: fontAscent, height: fontHeight, descent: fontHeight - fontAscent };
    Control2._FontHeightSizes[font] = result;
    return result;
  };
  Control2.drawEllipse = function(x, y, width, height, context) {
    context.translate(x, y);
    context.scale(width, height);
    context.beginPath();
    context.arc(0, 0, 1, 0, 2 * Math.PI);
    context.closePath();
    context.scale(1 / width, 1 / height);
    context.translate(-x, -y);
  };
  Control2.AllowAlphaInheritance = false;
  Control2._ClipMeasure = new Measure(0, 0, 0, 0);
  Control2._HORIZONTAL_ALIGNMENT_LEFT = 0;
  Control2._HORIZONTAL_ALIGNMENT_RIGHT = 1;
  Control2._HORIZONTAL_ALIGNMENT_CENTER = 2;
  Control2._VERTICAL_ALIGNMENT_TOP = 0;
  Control2._VERTICAL_ALIGNMENT_BOTTOM = 1;
  Control2._VERTICAL_ALIGNMENT_CENTER = 2;
  Control2._FontHeightSizes = {};
  Control2.AddHeader = function() {
  };
  return Control2;
}();
_TypeStore.RegisteredTypes["BABYLON.GUI.Control"] = Control;

// node_modules/@babylonjs/gui/2D/controls/container.js
var Container = function(_super) {
  __extends(Container2, _super);
  function Container2(name4) {
    var _this = _super.call(this, name4) || this;
    _this.name = name4;
    _this._children = new Array();
    _this._measureForChildren = Measure.Empty();
    _this._background = "";
    _this._adaptWidthToChildren = false;
    _this._adaptHeightToChildren = false;
    _this.logLayoutCycleErrors = false;
    _this.maxLayoutCycle = 3;
    return _this;
  }
  Object.defineProperty(Container2.prototype, "adaptHeightToChildren", {
    get: function() {
      return this._adaptHeightToChildren;
    },
    set: function(value) {
      if (this._adaptHeightToChildren === value) {
        return;
      }
      this._adaptHeightToChildren = value;
      if (value) {
        this.height = "100%";
      }
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Container2.prototype, "adaptWidthToChildren", {
    get: function() {
      return this._adaptWidthToChildren;
    },
    set: function(value) {
      if (this._adaptWidthToChildren === value) {
        return;
      }
      this._adaptWidthToChildren = value;
      if (value) {
        this.width = "100%";
      }
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Container2.prototype, "background", {
    get: function() {
      return this._background;
    },
    set: function(value) {
      if (this._background === value) {
        return;
      }
      this._background = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Container2.prototype, "children", {
    get: function() {
      return this._children;
    },
    enumerable: false,
    configurable: true
  });
  Container2.prototype._getTypeName = function() {
    return "Container";
  };
  Container2.prototype._flagDescendantsAsMatrixDirty = function() {
    for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
      var child = _a[_i];
      child._markMatrixAsDirty();
    }
  };
  Container2.prototype.getChildByName = function(name4) {
    for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
      var child = _a[_i];
      if (child.name === name4) {
        return child;
      }
    }
    return null;
  };
  Container2.prototype.getChildByType = function(name4, type) {
    for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
      var child = _a[_i];
      if (child.typeName === type) {
        return child;
      }
    }
    return null;
  };
  Container2.prototype.containsControl = function(control) {
    return this.children.indexOf(control) !== -1;
  };
  Container2.prototype.addControl = function(control) {
    if (!control) {
      return this;
    }
    var index = this._children.indexOf(control);
    if (index !== -1) {
      return this;
    }
    control._link(this._host);
    control._markAllAsDirty();
    this._reOrderControl(control);
    this._markAsDirty();
    return this;
  };
  Container2.prototype.clearControls = function() {
    var children = this.children.slice();
    for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
      var child = children_1[_i];
      this.removeControl(child);
    }
    return this;
  };
  Container2.prototype.removeControl = function(control) {
    var index = this._children.indexOf(control);
    if (index !== -1) {
      this._children.splice(index, 1);
      control.parent = null;
    }
    control.linkWithMesh(null);
    if (this._host) {
      this._host._cleanControlAfterRemoval(control);
    }
    this._markAsDirty();
    return this;
  };
  Container2.prototype._reOrderControl = function(control) {
    this.removeControl(control);
    var wasAdded = false;
    for (var index = 0; index < this._children.length; index++) {
      if (this._children[index].zIndex > control.zIndex) {
        this._children.splice(index, 0, control);
        wasAdded = true;
        break;
      }
    }
    if (!wasAdded) {
      this._children.push(control);
    }
    control.parent = this;
    this._markAsDirty();
  };
  Container2.prototype._offsetLeft = function(offset) {
    _super.prototype._offsetLeft.call(this, offset);
    for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
      var child = _a[_i];
      child._offsetLeft(offset);
    }
  };
  Container2.prototype._offsetTop = function(offset) {
    _super.prototype._offsetTop.call(this, offset);
    for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
      var child = _a[_i];
      child._offsetTop(offset);
    }
  };
  Container2.prototype._markAllAsDirty = function() {
    _super.prototype._markAllAsDirty.call(this);
    for (var index = 0; index < this._children.length; index++) {
      this._children[index]._markAllAsDirty();
    }
  };
  Container2.prototype._localDraw = function(context) {
    if (this._background) {
      context.save();
      if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {
        context.shadowColor = this.shadowColor;
        context.shadowBlur = this.shadowBlur;
        context.shadowOffsetX = this.shadowOffsetX;
        context.shadowOffsetY = this.shadowOffsetY;
      }
      context.fillStyle = this._background;
      context.fillRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);
      context.restore();
    }
  };
  Container2.prototype._link = function(host) {
    _super.prototype._link.call(this, host);
    for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
      var child = _a[_i];
      child._link(host);
    }
  };
  Container2.prototype._beforeLayout = function() {
  };
  Container2.prototype._processMeasures = function(parentMeasure, context) {
    if (this._isDirty || !this._cachedParentMeasure.isEqualsTo(parentMeasure)) {
      _super.prototype._processMeasures.call(this, parentMeasure, context);
      this._evaluateClippingState(parentMeasure);
    }
  };
  Container2.prototype._layout = function(parentMeasure, context) {
    if (!this.isDirty && (!this.isVisible || this.notRenderable)) {
      return false;
    }
    this.host._numLayoutCalls++;
    if (this._isDirty) {
      this._currentMeasure.transformToRef(this._transformMatrix, this._prevCurrentMeasureTransformedIntoGlobalSpace);
    }
    var rebuildCount = 0;
    context.save();
    this._applyStates(context);
    this._beforeLayout();
    do {
      var computedWidth = -1;
      var computedHeight = -1;
      this._rebuildLayout = false;
      this._processMeasures(parentMeasure, context);
      if (!this._isClipped) {
        for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
          var child = _a[_i];
          child._tempParentMeasure.copyFrom(this._measureForChildren);
          if (child._layout(this._measureForChildren, context)) {
            if (this.adaptWidthToChildren && child._width.isPixel) {
              computedWidth = Math.max(computedWidth, child._currentMeasure.width + child.paddingLeftInPixels + child.paddingRightInPixels);
            }
            if (this.adaptHeightToChildren && child._height.isPixel) {
              computedHeight = Math.max(computedHeight, child._currentMeasure.height + child.paddingTopInPixels + child.paddingBottomInPixels);
            }
          }
        }
        if (this.adaptWidthToChildren && computedWidth >= 0) {
          computedWidth += this.paddingLeftInPixels + this.paddingRightInPixels;
          if (this.width !== computedWidth + "px") {
            this.width = computedWidth + "px";
            this._rebuildLayout = true;
          }
        }
        if (this.adaptHeightToChildren && computedHeight >= 0) {
          computedHeight += this.paddingTopInPixels + this.paddingBottomInPixels;
          if (this.height !== computedHeight + "px") {
            this.height = computedHeight + "px";
            this._rebuildLayout = true;
          }
        }
        this._postMeasure();
      }
      rebuildCount++;
    } while (this._rebuildLayout && rebuildCount < this.maxLayoutCycle);
    if (rebuildCount >= 3 && this.logLayoutCycleErrors) {
      Logger.Error("Layout cycle detected in GUI (Container name=" + this.name + ", uniqueId=" + this.uniqueId + ")");
    }
    context.restore();
    if (this._isDirty) {
      this.invalidateRect();
      this._isDirty = false;
    }
    return true;
  };
  Container2.prototype._postMeasure = function() {
  };
  Container2.prototype._draw = function(context, invalidatedRectangle) {
    this._localDraw(context);
    if (this.clipChildren) {
      this._clipForChildren(context);
    }
    for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
      var child = _a[_i];
      if (invalidatedRectangle) {
        if (!child._intersectsRect(invalidatedRectangle)) {
          continue;
        }
      }
      child._render(context, invalidatedRectangle);
    }
  };
  Container2.prototype.getDescendantsToRef = function(results, directDescendantsOnly, predicate) {
    if (directDescendantsOnly === void 0) {
      directDescendantsOnly = false;
    }
    if (!this.children) {
      return;
    }
    for (var index = 0; index < this.children.length; index++) {
      var item = this.children[index];
      if (!predicate || predicate(item)) {
        results.push(item);
      }
      if (!directDescendantsOnly) {
        item.getDescendantsToRef(results, false, predicate);
      }
    }
  };
  Container2.prototype._processPicking = function(x, y, pi, type, pointerId, buttonIndex, deltaX, deltaY) {
    if (!this._isEnabled || !this.isVisible || this.notRenderable) {
      return false;
    }
    if (!_super.prototype.contains.call(this, x, y)) {
      return false;
    }
    for (var index = this._children.length - 1; index >= 0; index--) {
      var child = this._children[index];
      if (child._processPicking(x, y, pi, type, pointerId, buttonIndex, deltaX, deltaY)) {
        if (child.hoverCursor) {
          this._host._changeCursor(child.hoverCursor);
        }
        return true;
      }
    }
    if (!this.isHitTestVisible) {
      return false;
    }
    return this._processObservables(type, x, y, pi, pointerId, buttonIndex, deltaX, deltaY);
  };
  Container2.prototype._additionalProcessing = function(parentMeasure, context) {
    _super.prototype._additionalProcessing.call(this, parentMeasure, context);
    this._measureForChildren.copyFrom(this._currentMeasure);
  };
  Container2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    for (var index = this.children.length - 1; index >= 0; index--) {
      this.children[index].dispose();
    }
  };
  return Container2;
}(Control);
_TypeStore.RegisteredTypes["BABYLON.GUI.Container"] = Container;

// node_modules/@babylonjs/gui/2D/controls/rectangle.js
var Rectangle = function(_super) {
  __extends(Rectangle2, _super);
  function Rectangle2(name4) {
    var _this = _super.call(this, name4) || this;
    _this.name = name4;
    _this._thickness = 1;
    _this._cornerRadius = 0;
    return _this;
  }
  Object.defineProperty(Rectangle2.prototype, "thickness", {
    get: function() {
      return this._thickness;
    },
    set: function(value) {
      if (this._thickness === value) {
        return;
      }
      this._thickness = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Rectangle2.prototype, "cornerRadius", {
    get: function() {
      return this._cornerRadius;
    },
    set: function(value) {
      if (value < 0) {
        value = 0;
      }
      if (this._cornerRadius === value) {
        return;
      }
      this._cornerRadius = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Rectangle2.prototype._getTypeName = function() {
    return "Rectangle";
  };
  Rectangle2.prototype._localDraw = function(context) {
    context.save();
    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {
      context.shadowColor = this.shadowColor;
      context.shadowBlur = this.shadowBlur;
      context.shadowOffsetX = this.shadowOffsetX;
      context.shadowOffsetY = this.shadowOffsetY;
    }
    if (this._background) {
      context.fillStyle = this._background;
      if (this._cornerRadius) {
        this._drawRoundedRect(context, this._thickness / 2);
        context.fill();
      } else {
        context.fillRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);
      }
    }
    if (this._thickness) {
      if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {
        context.shadowBlur = 0;
        context.shadowOffsetX = 0;
        context.shadowOffsetY = 0;
      }
      if (this.color) {
        context.strokeStyle = this.color;
      }
      context.lineWidth = this._thickness;
      if (this._cornerRadius) {
        this._drawRoundedRect(context, this._thickness / 2);
        context.stroke();
      } else {
        context.strokeRect(this._currentMeasure.left + this._thickness / 2, this._currentMeasure.top + this._thickness / 2, this._currentMeasure.width - this._thickness, this._currentMeasure.height - this._thickness);
      }
    }
    context.restore();
  };
  Rectangle2.prototype._additionalProcessing = function(parentMeasure, context) {
    _super.prototype._additionalProcessing.call(this, parentMeasure, context);
    this._measureForChildren.width -= 2 * this._thickness;
    this._measureForChildren.height -= 2 * this._thickness;
    this._measureForChildren.left += this._thickness;
    this._measureForChildren.top += this._thickness;
  };
  Rectangle2.prototype._drawRoundedRect = function(context, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    var x = this._currentMeasure.left + offset;
    var y = this._currentMeasure.top + offset;
    var width = this._currentMeasure.width - offset * 2;
    var height = this._currentMeasure.height - offset * 2;
    var radius = Math.min(height / 2 - 2, Math.min(width / 2 - 2, this._cornerRadius));
    context.beginPath();
    context.moveTo(x + radius, y);
    context.lineTo(x + width - radius, y);
    context.quadraticCurveTo(x + width, y, x + width, y + radius);
    context.lineTo(x + width, y + height - radius);
    context.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    context.lineTo(x + radius, y + height);
    context.quadraticCurveTo(x, y + height, x, y + height - radius);
    context.lineTo(x, y + radius);
    context.quadraticCurveTo(x, y, x + radius, y);
    context.closePath();
  };
  Rectangle2.prototype._clipForChildren = function(context) {
    if (this._cornerRadius) {
      this._drawRoundedRect(context, this._thickness);
      context.clip();
    }
  };
  return Rectangle2;
}(Container);
_TypeStore.RegisteredTypes["BABYLON.GUI.Rectangle"] = Rectangle;

// node_modules/@babylonjs/gui/2D/controls/textBlock.js
var TextWrapping;
(function(TextWrapping2) {
  TextWrapping2[TextWrapping2["Clip"] = 0] = "Clip";
  TextWrapping2[TextWrapping2["WordWrap"] = 1] = "WordWrap";
  TextWrapping2[TextWrapping2["Ellipsis"] = 2] = "Ellipsis";
})(TextWrapping || (TextWrapping = {}));
var TextBlock = function(_super) {
  __extends(TextBlock2, _super);
  function TextBlock2(name4, text) {
    if (text === void 0) {
      text = "";
    }
    var _this = _super.call(this, name4) || this;
    _this.name = name4;
    _this._text = "";
    _this._textWrapping = TextWrapping.Clip;
    _this._textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    _this._textVerticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;
    _this._resizeToFit = false;
    _this._lineSpacing = new ValueAndUnit(0);
    _this._outlineWidth = 0;
    _this._outlineColor = "white";
    _this._underline = false;
    _this._lineThrough = false;
    _this.onTextChangedObservable = new Observable();
    _this.onLinesReadyObservable = new Observable();
    _this.text = text;
    return _this;
  }
  Object.defineProperty(TextBlock2.prototype, "lines", {
    get: function() {
      return this._lines;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextBlock2.prototype, "resizeToFit", {
    get: function() {
      return this._resizeToFit;
    },
    set: function(value) {
      if (this._resizeToFit === value) {
        return;
      }
      this._resizeToFit = value;
      if (this._resizeToFit) {
        this._width.ignoreAdaptiveScaling = true;
        this._height.ignoreAdaptiveScaling = true;
      }
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextBlock2.prototype, "textWrapping", {
    get: function() {
      return this._textWrapping;
    },
    set: function(value) {
      if (this._textWrapping === value) {
        return;
      }
      this._textWrapping = +value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextBlock2.prototype, "text", {
    get: function() {
      return this._text;
    },
    set: function(value) {
      if (this._text === value) {
        return;
      }
      this._text = value;
      this._markAsDirty();
      this.onTextChangedObservable.notifyObservers(this);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextBlock2.prototype, "textHorizontalAlignment", {
    get: function() {
      return this._textHorizontalAlignment;
    },
    set: function(value) {
      if (this._textHorizontalAlignment === value) {
        return;
      }
      this._textHorizontalAlignment = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextBlock2.prototype, "textVerticalAlignment", {
    get: function() {
      return this._textVerticalAlignment;
    },
    set: function(value) {
      if (this._textVerticalAlignment === value) {
        return;
      }
      this._textVerticalAlignment = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextBlock2.prototype, "lineSpacing", {
    get: function() {
      return this._lineSpacing.toString(this._host);
    },
    set: function(value) {
      if (this._lineSpacing.fromString(value)) {
        this._markAsDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextBlock2.prototype, "outlineWidth", {
    get: function() {
      return this._outlineWidth;
    },
    set: function(value) {
      if (this._outlineWidth === value) {
        return;
      }
      this._outlineWidth = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextBlock2.prototype, "underline", {
    get: function() {
      return this._underline;
    },
    set: function(value) {
      if (this._underline === value) {
        return;
      }
      this._underline = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextBlock2.prototype, "lineThrough", {
    get: function() {
      return this._lineThrough;
    },
    set: function(value) {
      if (this._lineThrough === value) {
        return;
      }
      this._lineThrough = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextBlock2.prototype, "outlineColor", {
    get: function() {
      return this._outlineColor;
    },
    set: function(value) {
      if (this._outlineColor === value) {
        return;
      }
      this._outlineColor = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  TextBlock2.prototype._getTypeName = function() {
    return "TextBlock";
  };
  TextBlock2.prototype._processMeasures = function(parentMeasure, context) {
    if (!this._fontOffset) {
      this._fontOffset = Control._GetFontOffset(context.font);
    }
    _super.prototype._processMeasures.call(this, parentMeasure, context);
    this._lines = this._breakLines(this._currentMeasure.width, context);
    this.onLinesReadyObservable.notifyObservers(this);
    var maxLineWidth = 0;
    for (var i = 0; i < this._lines.length; i++) {
      var line = this._lines[i];
      if (line.width > maxLineWidth) {
        maxLineWidth = line.width;
      }
    }
    if (this._resizeToFit) {
      if (this._textWrapping === TextWrapping.Clip) {
        var newWidth = this.paddingLeftInPixels + this.paddingRightInPixels + maxLineWidth | 0;
        if (newWidth !== this._width.internalValue) {
          this._width.updateInPlace(newWidth, ValueAndUnit.UNITMODE_PIXEL);
          this._rebuildLayout = true;
        }
      }
      var newHeight = this.paddingTopInPixels + this.paddingBottomInPixels + this._fontOffset.height * this._lines.length | 0;
      if (this._lines.length > 0 && this._lineSpacing.internalValue !== 0) {
        var lineSpacing = 0;
        if (this._lineSpacing.isPixel) {
          lineSpacing = this._lineSpacing.getValue(this._host);
        } else {
          lineSpacing = this._lineSpacing.getValue(this._host) * this._height.getValueInPixel(this._host, this._cachedParentMeasure.height);
        }
        newHeight += (this._lines.length - 1) * lineSpacing;
      }
      if (newHeight !== this._height.internalValue) {
        this._height.updateInPlace(newHeight, ValueAndUnit.UNITMODE_PIXEL);
        this._rebuildLayout = true;
      }
    }
  };
  TextBlock2.prototype._drawText = function(text, textWidth, y, context) {
    var width = this._currentMeasure.width;
    var x = 0;
    switch (this._textHorizontalAlignment) {
      case Control.HORIZONTAL_ALIGNMENT_LEFT:
        x = 0;
        break;
      case Control.HORIZONTAL_ALIGNMENT_RIGHT:
        x = width - textWidth;
        break;
      case Control.HORIZONTAL_ALIGNMENT_CENTER:
        x = (width - textWidth) / 2;
        break;
    }
    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {
      context.shadowColor = this.shadowColor;
      context.shadowBlur = this.shadowBlur;
      context.shadowOffsetX = this.shadowOffsetX;
      context.shadowOffsetY = this.shadowOffsetY;
    }
    if (this.outlineWidth) {
      context.strokeText(text, this._currentMeasure.left + x, y);
    }
    context.fillText(text, this._currentMeasure.left + x, y);
    if (this._underline) {
      context.beginPath();
      context.lineWidth = Math.round(this.fontSizeInPixels * 0.05);
      context.moveTo(this._currentMeasure.left + x, y + 3);
      context.lineTo(this._currentMeasure.left + x + textWidth, y + 3);
      context.stroke();
      context.closePath();
    }
    if (this._lineThrough) {
      context.beginPath();
      context.lineWidth = Math.round(this.fontSizeInPixels * 0.05);
      context.moveTo(this._currentMeasure.left + x, y - this.fontSizeInPixels / 3);
      context.lineTo(this._currentMeasure.left + x + textWidth, y - this.fontSizeInPixels / 3);
      context.stroke();
      context.closePath();
    }
  };
  TextBlock2.prototype._draw = function(context, invalidatedRectangle) {
    context.save();
    this._applyStates(context);
    this._renderLines(context);
    context.restore();
  };
  TextBlock2.prototype._applyStates = function(context) {
    _super.prototype._applyStates.call(this, context);
    if (this.outlineWidth) {
      context.lineWidth = this.outlineWidth;
      context.strokeStyle = this.outlineColor;
      context.lineJoin = "miter";
      context.miterLimit = 2;
    }
  };
  TextBlock2.prototype._breakLines = function(refWidth, context) {
    var lines = [];
    var _lines = this.text.split("\n");
    if (this._textWrapping === TextWrapping.Ellipsis) {
      for (var _i = 0, _lines_1 = _lines; _i < _lines_1.length; _i++) {
        var _line = _lines_1[_i];
        lines.push(this._parseLineEllipsis(_line, refWidth, context));
      }
    } else if (this._textWrapping === TextWrapping.WordWrap) {
      for (var _a = 0, _lines_2 = _lines; _a < _lines_2.length; _a++) {
        var _line = _lines_2[_a];
        lines.push.apply(lines, this._parseLineWordWrap(_line, refWidth, context));
      }
    } else {
      for (var _b = 0, _lines_3 = _lines; _b < _lines_3.length; _b++) {
        var _line = _lines_3[_b];
        lines.push(this._parseLine(_line, context));
      }
    }
    return lines;
  };
  TextBlock2.prototype._parseLine = function(line, context) {
    if (line === void 0) {
      line = "";
    }
    return { text: line, width: context.measureText(line).width };
  };
  TextBlock2.prototype._parseLineEllipsis = function(line, width, context) {
    if (line === void 0) {
      line = "";
    }
    var lineWidth = context.measureText(line).width;
    if (lineWidth > width) {
      line += "\u2026";
    }
    var characters = Array.from && Array.from(line);
    if (!characters) {
      while (line.length > 2 && lineWidth > width) {
        line = line.slice(0, -2) + "\u2026";
        lineWidth = context.measureText(line).width;
      }
    } else {
      while (characters.length && lineWidth > width) {
        characters.pop();
        line = characters.join("") + "...";
        lineWidth = context.measureText(line).width;
      }
    }
    return { text: line, width: lineWidth };
  };
  TextBlock2.prototype._parseLineWordWrap = function(line, width, context) {
    if (line === void 0) {
      line = "";
    }
    var lines = [];
    var words = this.wordSplittingFunction ? this.wordSplittingFunction(line) : line.split(" ");
    var lineWidth = 0;
    for (var n = 0; n < words.length; n++) {
      var testLine = n > 0 ? line + " " + words[n] : words[0];
      var metrics = context.measureText(testLine);
      var testWidth = metrics.width;
      if (testWidth > width && n > 0) {
        lines.push({ text: line, width: lineWidth });
        line = words[n];
        lineWidth = context.measureText(line).width;
      } else {
        lineWidth = testWidth;
        line = testLine;
      }
    }
    lines.push({ text: line, width: lineWidth });
    return lines;
  };
  TextBlock2.prototype._renderLines = function(context) {
    var height = this._currentMeasure.height;
    var rootY = 0;
    switch (this._textVerticalAlignment) {
      case Control.VERTICAL_ALIGNMENT_TOP:
        rootY = this._fontOffset.ascent;
        break;
      case Control.VERTICAL_ALIGNMENT_BOTTOM:
        rootY = height - this._fontOffset.height * (this._lines.length - 1) - this._fontOffset.descent;
        break;
      case Control.VERTICAL_ALIGNMENT_CENTER:
        rootY = this._fontOffset.ascent + (height - this._fontOffset.height * this._lines.length) / 2;
        break;
    }
    rootY += this._currentMeasure.top;
    for (var i = 0; i < this._lines.length; i++) {
      var line = this._lines[i];
      if (i !== 0 && this._lineSpacing.internalValue !== 0) {
        if (this._lineSpacing.isPixel) {
          rootY += this._lineSpacing.getValue(this._host);
        } else {
          rootY = rootY + this._lineSpacing.getValue(this._host) * this._height.getValueInPixel(this._host, this._cachedParentMeasure.height);
        }
      }
      this._drawText(line.text, line.width, rootY, context);
      rootY += this._fontOffset.height;
    }
  };
  TextBlock2.prototype.computeExpectedHeight = function() {
    if (this.text && this.widthInPixels) {
      var context_1 = document.createElement("canvas").getContext("2d");
      if (context_1) {
        this._applyStates(context_1);
        if (!this._fontOffset) {
          this._fontOffset = Control._GetFontOffset(context_1.font);
        }
        var lines = this._lines ? this._lines : this._breakLines(this.widthInPixels - this.paddingLeftInPixels - this.paddingRightInPixels, context_1);
        var newHeight = this.paddingTopInPixels + this.paddingBottomInPixels + this._fontOffset.height * lines.length;
        if (lines.length > 0 && this._lineSpacing.internalValue !== 0) {
          var lineSpacing = 0;
          if (this._lineSpacing.isPixel) {
            lineSpacing = this._lineSpacing.getValue(this._host);
          } else {
            lineSpacing = this._lineSpacing.getValue(this._host) * this._height.getValueInPixel(this._host, this._cachedParentMeasure.height);
          }
          newHeight += (lines.length - 1) * lineSpacing;
        }
        return newHeight;
      }
    }
    return 0;
  };
  TextBlock2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this.onTextChangedObservable.clear();
  };
  return TextBlock2;
}(Control);
_TypeStore.RegisteredTypes["BABYLON.GUI.TextBlock"] = TextBlock;

// node_modules/@babylonjs/gui/2D/controls/image.js
var Image = function(_super) {
  __extends(Image2, _super);
  function Image2(name4, url) {
    if (url === void 0) {
      url = null;
    }
    var _this = _super.call(this, name4) || this;
    _this.name = name4;
    _this._workingCanvas = null;
    _this._loaded = false;
    _this._stretch = Image2.STRETCH_FILL;
    _this._autoScale = false;
    _this._sourceLeft = 0;
    _this._sourceTop = 0;
    _this._sourceWidth = 0;
    _this._sourceHeight = 0;
    _this._svgAttributesComputationCompleted = false;
    _this._isSVG = false;
    _this._cellWidth = 0;
    _this._cellHeight = 0;
    _this._cellId = -1;
    _this._populateNinePatchSlicesFromImage = false;
    _this._imageDataCache = { data: null, key: "" };
    _this.onImageLoadedObservable = new Observable();
    _this.onSVGAttributesComputedObservable = new Observable();
    _this.source = url;
    return _this;
  }
  Object.defineProperty(Image2.prototype, "isLoaded", {
    get: function() {
      return this._loaded;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Image2.prototype, "populateNinePatchSlicesFromImage", {
    get: function() {
      return this._populateNinePatchSlicesFromImage;
    },
    set: function(value) {
      if (this._populateNinePatchSlicesFromImage === value) {
        return;
      }
      this._populateNinePatchSlicesFromImage = value;
      if (this._populateNinePatchSlicesFromImage && this._loaded) {
        this._extractNinePatchSliceDataFromImage();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Image2.prototype, "detectPointerOnOpaqueOnly", {
    get: function() {
      return this._detectPointerOnOpaqueOnly;
    },
    set: function(value) {
      if (this._detectPointerOnOpaqueOnly === value) {
        return;
      }
      this._detectPointerOnOpaqueOnly = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Image2.prototype, "sliceLeft", {
    get: function() {
      return this._sliceLeft;
    },
    set: function(value) {
      if (this._sliceLeft === value) {
        return;
      }
      this._sliceLeft = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Image2.prototype, "sliceRight", {
    get: function() {
      return this._sliceRight;
    },
    set: function(value) {
      if (this._sliceRight === value) {
        return;
      }
      this._sliceRight = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Image2.prototype, "sliceTop", {
    get: function() {
      return this._sliceTop;
    },
    set: function(value) {
      if (this._sliceTop === value) {
        return;
      }
      this._sliceTop = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Image2.prototype, "sliceBottom", {
    get: function() {
      return this._sliceBottom;
    },
    set: function(value) {
      if (this._sliceBottom === value) {
        return;
      }
      this._sliceBottom = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Image2.prototype, "sourceLeft", {
    get: function() {
      return this._sourceLeft;
    },
    set: function(value) {
      if (this._sourceLeft === value) {
        return;
      }
      this._sourceLeft = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Image2.prototype, "sourceTop", {
    get: function() {
      return this._sourceTop;
    },
    set: function(value) {
      if (this._sourceTop === value) {
        return;
      }
      this._sourceTop = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Image2.prototype, "sourceWidth", {
    get: function() {
      return this._sourceWidth;
    },
    set: function(value) {
      if (this._sourceWidth === value) {
        return;
      }
      this._sourceWidth = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Image2.prototype, "sourceHeight", {
    get: function() {
      return this._sourceHeight;
    },
    set: function(value) {
      if (this._sourceHeight === value) {
        return;
      }
      this._sourceHeight = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Image2.prototype, "isSVG", {
    get: function() {
      return this._isSVG;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Image2.prototype, "svgAttributesComputationCompleted", {
    get: function() {
      return this._svgAttributesComputationCompleted;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Image2.prototype, "autoScale", {
    get: function() {
      return this._autoScale;
    },
    set: function(value) {
      if (this._autoScale === value) {
        return;
      }
      this._autoScale = value;
      if (value && this._loaded) {
        this.synchronizeSizeWithContent();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Image2.prototype, "stretch", {
    get: function() {
      return this._stretch;
    },
    set: function(value) {
      if (this._stretch === value) {
        return;
      }
      this._stretch = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Image2.prototype._rotate90 = function(n, preserveProperties) {
    if (preserveProperties === void 0) {
      preserveProperties = false;
    }
    var canvas = document.createElement("canvas");
    var context = canvas.getContext("2d");
    var width = this._domImage.width;
    var height = this._domImage.height;
    canvas.width = height;
    canvas.height = width;
    context.translate(canvas.width / 2, canvas.height / 2);
    context.rotate(n * Math.PI / 2);
    context.drawImage(this._domImage, 0, 0, width, height, -width / 2, -height / 2, width, height);
    var dataUrl = canvas.toDataURL("image/jpg");
    var rotatedImage = new Image2(this.name + "rotated", dataUrl);
    if (preserveProperties) {
      rotatedImage._stretch = this._stretch;
      rotatedImage._autoScale = this._autoScale;
      rotatedImage._cellId = this._cellId;
      rotatedImage._cellWidth = n % 1 ? this._cellHeight : this._cellWidth;
      rotatedImage._cellHeight = n % 1 ? this._cellWidth : this._cellHeight;
    }
    this._handleRotationForSVGImage(this, rotatedImage, n);
    this._imageDataCache.data = null;
    return rotatedImage;
  };
  Image2.prototype._handleRotationForSVGImage = function(srcImage, dstImage, n) {
    var _this = this;
    if (!srcImage._isSVG) {
      return;
    }
    if (srcImage._svgAttributesComputationCompleted) {
      this._rotate90SourceProperties(srcImage, dstImage, n);
      this._markAsDirty();
    } else {
      srcImage.onSVGAttributesComputedObservable.addOnce(function() {
        _this._rotate90SourceProperties(srcImage, dstImage, n);
        _this._markAsDirty();
      });
    }
  };
  Image2.prototype._rotate90SourceProperties = function(srcImage, dstImage, n) {
    var _a, _b;
    var srcLeft = srcImage.sourceLeft, srcTop = srcImage.sourceTop, srcWidth = srcImage.domImage.width, srcHeight = srcImage.domImage.height;
    var dstLeft = srcLeft, dstTop = srcTop, dstWidth = srcImage.sourceWidth, dstHeight = srcImage.sourceHeight;
    if (n != 0) {
      var mult = n < 0 ? -1 : 1;
      n = n % 4;
      for (var i = 0; i < Math.abs(n); ++i) {
        dstLeft = -(srcTop - srcHeight / 2) * mult + srcHeight / 2;
        dstTop = (srcLeft - srcWidth / 2) * mult + srcWidth / 2;
        _a = [dstHeight, dstWidth], dstWidth = _a[0], dstHeight = _a[1];
        if (n < 0) {
          dstTop -= dstHeight;
        } else {
          dstLeft -= dstWidth;
        }
        srcLeft = dstLeft;
        srcTop = dstTop;
        _b = [srcHeight, srcWidth], srcWidth = _b[0], srcHeight = _b[1];
      }
    }
    dstImage.sourceLeft = dstLeft;
    dstImage.sourceTop = dstTop;
    dstImage.sourceWidth = dstWidth;
    dstImage.sourceHeight = dstHeight;
  };
  Object.defineProperty(Image2.prototype, "domImage", {
    get: function() {
      return this._domImage;
    },
    set: function(value) {
      var _this = this;
      this._domImage = value;
      this._loaded = false;
      this._imageDataCache.data = null;
      if (this._domImage.width) {
        this._onImageLoaded();
      } else {
        this._domImage.onload = function() {
          _this._onImageLoaded();
        };
      }
    },
    enumerable: false,
    configurable: true
  });
  Image2.prototype._onImageLoaded = function() {
    this._imageDataCache.data = null;
    this._imageWidth = this._domImage.width;
    this._imageHeight = this._domImage.height;
    this._loaded = true;
    if (this._populateNinePatchSlicesFromImage) {
      this._extractNinePatchSliceDataFromImage();
    }
    if (this._autoScale) {
      this.synchronizeSizeWithContent();
    }
    this.onImageLoadedObservable.notifyObservers(this);
    this._markAsDirty();
  };
  Image2.prototype._extractNinePatchSliceDataFromImage = function() {
    if (!this._workingCanvas) {
      this._workingCanvas = document.createElement("canvas");
    }
    var canvas = this._workingCanvas;
    var context = canvas.getContext("2d");
    var width = this._domImage.width;
    var height = this._domImage.height;
    canvas.width = width;
    canvas.height = height;
    context.drawImage(this._domImage, 0, 0, width, height);
    var imageData = context.getImageData(0, 0, width, height);
    this._sliceLeft = -1;
    this._sliceRight = -1;
    for (var x = 0; x < width; x++) {
      var alpha = imageData.data[x * 4 + 3];
      if (alpha > 127 && this._sliceLeft === -1) {
        this._sliceLeft = x;
        continue;
      }
      if (alpha < 127 && this._sliceLeft > -1) {
        this._sliceRight = x;
        break;
      }
    }
    this._sliceTop = -1;
    this._sliceBottom = -1;
    for (var y = 0; y < height; y++) {
      var alpha = imageData.data[y * width * 4 + 3];
      if (alpha > 127 && this._sliceTop === -1) {
        this._sliceTop = y;
        continue;
      }
      if (alpha < 127 && this._sliceTop > -1) {
        this._sliceBottom = y;
        break;
      }
    }
  };
  Object.defineProperty(Image2.prototype, "source", {
    set: function(value) {
      var _this = this;
      if (this._source === value) {
        return;
      }
      this._loaded = false;
      this._source = value;
      this._imageDataCache.data = null;
      if (value) {
        value = this._svgCheck(value);
      }
      this._domImage = document.createElement("img");
      this._domImage.onload = function() {
        _this._onImageLoaded();
      };
      if (value) {
        Tools.SetCorsBehavior(value, this._domImage);
        this._domImage.src = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Image2.prototype._svgCheck = function(value) {
    var _this = this;
    if (window.SVGSVGElement && value.search(/.svg#/gi) !== -1 && value.indexOf("#") === value.lastIndexOf("#")) {
      this._isSVG = true;
      var svgsrc = value.split("#")[0];
      var elemid = value.split("#")[1];
      var svgExist = document.body.querySelector('object[data="' + svgsrc + '"]');
      if (svgExist) {
        var svgDoc = svgExist.contentDocument;
        if (svgDoc && svgDoc.documentElement) {
          var vb = svgDoc.documentElement.getAttribute("viewBox");
          var docwidth = Number(svgDoc.documentElement.getAttribute("width"));
          var docheight = Number(svgDoc.documentElement.getAttribute("height"));
          var elem = svgDoc.getElementById(elemid);
          if (elem && vb && docwidth && docheight) {
            this._getSVGAttribs(svgExist, elemid);
            return value;
          }
        }
        svgExist.addEventListener("load", function() {
          _this._getSVGAttribs(svgExist, elemid);
        });
      } else {
        var svgImage = document.createElement("object");
        svgImage.data = svgsrc;
        svgImage.type = "image/svg+xml";
        svgImage.width = "0%";
        svgImage.height = "0%";
        document.body.appendChild(svgImage);
        svgImage.onload = function() {
          var svgobj = document.body.querySelector('object[data="' + svgsrc + '"]');
          if (svgobj) {
            _this._getSVGAttribs(svgobj, elemid);
          }
        };
      }
      return svgsrc;
    } else {
      return value;
    }
  };
  Image2.prototype._getSVGAttribs = function(svgsrc, elemid) {
    var svgDoc = svgsrc.contentDocument;
    if (svgDoc && svgDoc.documentElement) {
      var vb = svgDoc.documentElement.getAttribute("viewBox");
      var docwidth = Number(svgDoc.documentElement.getAttribute("width"));
      var docheight = Number(svgDoc.documentElement.getAttribute("height"));
      var elem = svgDoc.getElementById(elemid);
      if (vb && docwidth && docheight && elem) {
        var vb_width = Number(vb.split(" ")[2]);
        var vb_height = Number(vb.split(" ")[3]);
        var elem_bbox = elem.getBBox();
        var elem_matrix_a = 1;
        var elem_matrix_d = 1;
        var elem_matrix_e = 0;
        var elem_matrix_f = 0;
        if (elem.transform && elem.transform.baseVal.consolidate()) {
          elem_matrix_a = elem.transform.baseVal.consolidate().matrix.a;
          elem_matrix_d = elem.transform.baseVal.consolidate().matrix.d;
          elem_matrix_e = elem.transform.baseVal.consolidate().matrix.e;
          elem_matrix_f = elem.transform.baseVal.consolidate().matrix.f;
        }
        this.sourceLeft = (elem_matrix_a * elem_bbox.x + elem_matrix_e) * docwidth / vb_width;
        this.sourceTop = (elem_matrix_d * elem_bbox.y + elem_matrix_f) * docheight / vb_height;
        this.sourceWidth = elem_bbox.width * elem_matrix_a * (docwidth / vb_width);
        this.sourceHeight = elem_bbox.height * elem_matrix_d * (docheight / vb_height);
        this._svgAttributesComputationCompleted = true;
        this.onSVGAttributesComputedObservable.notifyObservers(this);
      }
    }
  };
  Object.defineProperty(Image2.prototype, "cellWidth", {
    get: function() {
      return this._cellWidth;
    },
    set: function(value) {
      if (this._cellWidth === value) {
        return;
      }
      this._cellWidth = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Image2.prototype, "cellHeight", {
    get: function() {
      return this._cellHeight;
    },
    set: function(value) {
      if (this._cellHeight === value) {
        return;
      }
      this._cellHeight = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Image2.prototype, "cellId", {
    get: function() {
      return this._cellId;
    },
    set: function(value) {
      if (this._cellId === value) {
        return;
      }
      this._cellId = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Image2.prototype.contains = function(x, y) {
    if (!_super.prototype.contains.call(this, x, y)) {
      return false;
    }
    if (!this._detectPointerOnOpaqueOnly || !this._workingCanvas) {
      return true;
    }
    var width = this._currentMeasure.width | 0;
    var height = this._currentMeasure.height | 0;
    var key = width + "_" + height;
    var imageData = this._imageDataCache.data;
    if (!imageData || this._imageDataCache.key !== key) {
      var canvas = this._workingCanvas;
      var context_1 = canvas.getContext("2d");
      this._imageDataCache.data = imageData = context_1.getImageData(0, 0, width, height).data;
      this._imageDataCache.key = key;
    }
    x = x - this._currentMeasure.left | 0;
    y = y - this._currentMeasure.top | 0;
    var pickedPixel = imageData[(x + y * width) * 4 + 3];
    return pickedPixel > 0;
  };
  Image2.prototype._getTypeName = function() {
    return "Image";
  };
  Image2.prototype.synchronizeSizeWithContent = function() {
    if (!this._loaded) {
      return;
    }
    this.width = this._domImage.width + "px";
    this.height = this._domImage.height + "px";
  };
  Image2.prototype._processMeasures = function(parentMeasure, context) {
    if (this._loaded) {
      switch (this._stretch) {
        case Image2.STRETCH_NONE:
          break;
        case Image2.STRETCH_FILL:
          break;
        case Image2.STRETCH_UNIFORM:
          break;
        case Image2.STRETCH_NINE_PATCH:
          break;
        case Image2.STRETCH_EXTEND:
          if (this._autoScale) {
            this.synchronizeSizeWithContent();
          }
          if (this.parent && this.parent.parent) {
            this.parent.adaptWidthToChildren = true;
            this.parent.adaptHeightToChildren = true;
          }
          break;
      }
    }
    _super.prototype._processMeasures.call(this, parentMeasure, context);
  };
  Image2.prototype._prepareWorkingCanvasForOpaqueDetection = function() {
    if (!this._detectPointerOnOpaqueOnly) {
      return;
    }
    if (!this._workingCanvas) {
      this._workingCanvas = document.createElement("canvas");
    }
    var canvas = this._workingCanvas;
    var width = this._currentMeasure.width;
    var height = this._currentMeasure.height;
    var context = canvas.getContext("2d");
    canvas.width = width;
    canvas.height = height;
    context.clearRect(0, 0, width, height);
  };
  Image2.prototype._drawImage = function(context, sx, sy, sw, sh, tx, ty, tw, th) {
    context.drawImage(this._domImage, sx, sy, sw, sh, tx, ty, tw, th);
    if (!this._detectPointerOnOpaqueOnly) {
      return;
    }
    var canvas = this._workingCanvas;
    context = canvas.getContext("2d");
    context.drawImage(this._domImage, sx, sy, sw, sh, tx - this._currentMeasure.left, ty - this._currentMeasure.top, tw, th);
  };
  Image2.prototype._draw = function(context) {
    context.save();
    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {
      context.shadowColor = this.shadowColor;
      context.shadowBlur = this.shadowBlur;
      context.shadowOffsetX = this.shadowOffsetX;
      context.shadowOffsetY = this.shadowOffsetY;
    }
    var x, y, width, height;
    if (this.cellId == -1) {
      x = this._sourceLeft;
      y = this._sourceTop;
      width = this._sourceWidth ? this._sourceWidth : this._imageWidth;
      height = this._sourceHeight ? this._sourceHeight : this._imageHeight;
    } else {
      var rowCount = this._domImage.naturalWidth / this.cellWidth;
      var column = this.cellId / rowCount >> 0;
      var row = this.cellId % rowCount;
      x = this.cellWidth * row;
      y = this.cellHeight * column;
      width = this.cellWidth;
      height = this.cellHeight;
    }
    this._prepareWorkingCanvasForOpaqueDetection();
    this._applyStates(context);
    if (this._loaded) {
      switch (this._stretch) {
        case Image2.STRETCH_NONE:
          this._drawImage(context, x, y, width, height, this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);
          break;
        case Image2.STRETCH_FILL:
          this._drawImage(context, x, y, width, height, this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);
          break;
        case Image2.STRETCH_UNIFORM:
          var hRatio = this._currentMeasure.width / width;
          var vRatio = this._currentMeasure.height / height;
          var ratio = Math.min(hRatio, vRatio);
          var centerX = (this._currentMeasure.width - width * ratio) / 2;
          var centerY = (this._currentMeasure.height - height * ratio) / 2;
          this._drawImage(context, x, y, width, height, this._currentMeasure.left + centerX, this._currentMeasure.top + centerY, width * ratio, height * ratio);
          break;
        case Image2.STRETCH_EXTEND:
          this._drawImage(context, x, y, width, height, this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);
          break;
        case Image2.STRETCH_NINE_PATCH:
          this._renderNinePatch(context);
          break;
      }
    }
    context.restore();
  };
  Image2.prototype._renderCornerPatch = function(context, x, y, width, height, targetX, targetY) {
    this._drawImage(context, x, y, width, height, this._currentMeasure.left + targetX, this._currentMeasure.top + targetY, width, height);
  };
  Image2.prototype._renderNinePatch = function(context) {
    var height = this._imageHeight;
    var leftWidth = this._sliceLeft;
    var topHeight = this._sliceTop;
    var bottomHeight = this._imageHeight - this._sliceBottom;
    var rightWidth = this._imageWidth - this._sliceRight;
    var left = 0;
    var top = 0;
    if (this._populateNinePatchSlicesFromImage) {
      left = 1;
      top = 1;
      height -= 2;
      leftWidth -= 1;
      topHeight -= 1;
      bottomHeight -= 1;
      rightWidth -= 1;
    }
    var centerWidth = this._sliceRight - this._sliceLeft;
    var targetCenterWidth = this._currentMeasure.width - rightWidth - this.sliceLeft;
    var targetTopHeight = this._currentMeasure.height - height + this._sliceBottom;
    this._renderCornerPatch(context, left, top, leftWidth, topHeight, 0, 0);
    this._renderCornerPatch(context, left, this._sliceBottom, leftWidth, height - this._sliceBottom, 0, targetTopHeight);
    this._renderCornerPatch(context, this._sliceRight, top, rightWidth, topHeight, this._currentMeasure.width - rightWidth, 0);
    this._renderCornerPatch(context, this._sliceRight, this._sliceBottom, rightWidth, height - this._sliceBottom, this._currentMeasure.width - rightWidth, targetTopHeight);
    this._drawImage(context, this._sliceLeft, this._sliceTop, centerWidth, this._sliceBottom - this._sliceTop, this._currentMeasure.left + leftWidth, this._currentMeasure.top + topHeight, targetCenterWidth, targetTopHeight - topHeight);
    this._drawImage(context, left, this._sliceTop, leftWidth, this._sliceBottom - this._sliceTop, this._currentMeasure.left, this._currentMeasure.top + topHeight, leftWidth, targetTopHeight - topHeight);
    this._drawImage(context, this._sliceRight, this._sliceTop, leftWidth, this._sliceBottom - this._sliceTop, this._currentMeasure.left + this._currentMeasure.width - rightWidth, this._currentMeasure.top + topHeight, leftWidth, targetTopHeight - topHeight);
    this._drawImage(context, this._sliceLeft, top, centerWidth, topHeight, this._currentMeasure.left + leftWidth, this._currentMeasure.top, targetCenterWidth, topHeight);
    this._drawImage(context, this._sliceLeft, this._sliceBottom, centerWidth, bottomHeight, this._currentMeasure.left + leftWidth, this._currentMeasure.top + targetTopHeight, targetCenterWidth, bottomHeight);
  };
  Image2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this.onImageLoadedObservable.clear();
    this.onSVGAttributesComputedObservable.clear();
  };
  Image2.STRETCH_NONE = 0;
  Image2.STRETCH_FILL = 1;
  Image2.STRETCH_UNIFORM = 2;
  Image2.STRETCH_EXTEND = 3;
  Image2.STRETCH_NINE_PATCH = 4;
  return Image2;
}(Control);
_TypeStore.RegisteredTypes["BABYLON.GUI.Image"] = Image;

// node_modules/@babylonjs/gui/2D/controls/button.js
var Button = function(_super) {
  __extends(Button2, _super);
  function Button2(name4) {
    var _this = _super.call(this, name4) || this;
    _this.name = name4;
    _this.delegatePickingToChildren = false;
    _this.thickness = 1;
    _this.isPointerBlocker = true;
    var alphaStore = null;
    _this.pointerEnterAnimation = function() {
      alphaStore = _this.alpha;
      _this.alpha -= 0.1;
    };
    _this.pointerOutAnimation = function() {
      if (alphaStore !== null) {
        _this.alpha = alphaStore;
      }
    };
    _this.pointerDownAnimation = function() {
      _this.scaleX -= 0.05;
      _this.scaleY -= 0.05;
    };
    _this.pointerUpAnimation = function() {
      _this.scaleX += 0.05;
      _this.scaleY += 0.05;
    };
    return _this;
  }
  Object.defineProperty(Button2.prototype, "image", {
    get: function() {
      return this._image;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Button2.prototype, "textBlock", {
    get: function() {
      return this._textBlock;
    },
    enumerable: false,
    configurable: true
  });
  Button2.prototype._getTypeName = function() {
    return "Button";
  };
  Button2.prototype._processPicking = function(x, y, pi, type, pointerId, buttonIndex, deltaX, deltaY) {
    if (!this._isEnabled || !this.isHitTestVisible || !this.isVisible || this.notRenderable) {
      return false;
    }
    if (!_super.prototype.contains.call(this, x, y)) {
      return false;
    }
    if (this.delegatePickingToChildren) {
      var contains = false;
      for (var index = this._children.length - 1; index >= 0; index--) {
        var child = this._children[index];
        if (child.isEnabled && child.isHitTestVisible && child.isVisible && !child.notRenderable && child.contains(x, y)) {
          contains = true;
          break;
        }
      }
      if (!contains) {
        return false;
      }
    }
    this._processObservables(type, x, y, pi, pointerId, buttonIndex, deltaX, deltaY);
    return true;
  };
  Button2.prototype._onPointerEnter = function(target, pi) {
    if (!_super.prototype._onPointerEnter.call(this, target, pi)) {
      return false;
    }
    if (this.pointerEnterAnimation) {
      this.pointerEnterAnimation();
    }
    return true;
  };
  Button2.prototype._onPointerOut = function(target, pi, force) {
    if (force === void 0) {
      force = false;
    }
    if (this.pointerOutAnimation) {
      this.pointerOutAnimation();
    }
    _super.prototype._onPointerOut.call(this, target, pi, force);
  };
  Button2.prototype._onPointerDown = function(target, coordinates, pointerId, buttonIndex, pi) {
    if (!_super.prototype._onPointerDown.call(this, target, coordinates, pointerId, buttonIndex, pi)) {
      return false;
    }
    if (this.pointerDownAnimation) {
      this.pointerDownAnimation();
    }
    return true;
  };
  Button2.prototype._onPointerUp = function(target, coordinates, pointerId, buttonIndex, notifyClick, pi) {
    if (this.pointerUpAnimation) {
      this.pointerUpAnimation();
    }
    _super.prototype._onPointerUp.call(this, target, coordinates, pointerId, buttonIndex, notifyClick, pi);
  };
  Button2.CreateImageButton = function(name4, text, imageUrl) {
    var result = new Button2(name4);
    var textBlock = new TextBlock(name4 + "_button", text);
    textBlock.textWrapping = true;
    textBlock.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    textBlock.paddingLeft = "20%";
    result.addControl(textBlock);
    var iconImage = new Image(name4 + "_icon", imageUrl);
    iconImage.width = "20%";
    iconImage.stretch = Image.STRETCH_UNIFORM;
    iconImage.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    result.addControl(iconImage);
    result._image = iconImage;
    result._textBlock = textBlock;
    return result;
  };
  Button2.CreateImageOnlyButton = function(name4, imageUrl) {
    var result = new Button2(name4);
    var iconImage = new Image(name4 + "_icon", imageUrl);
    iconImage.stretch = Image.STRETCH_FILL;
    iconImage.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    result.addControl(iconImage);
    result._image = iconImage;
    return result;
  };
  Button2.CreateSimpleButton = function(name4, text) {
    var result = new Button2(name4);
    var textBlock = new TextBlock(name4 + "_button", text);
    textBlock.textWrapping = true;
    textBlock.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    result.addControl(textBlock);
    result._textBlock = textBlock;
    return result;
  };
  Button2.CreateImageWithCenterTextButton = function(name4, text, imageUrl) {
    var result = new Button2(name4);
    var iconImage = new Image(name4 + "_icon", imageUrl);
    iconImage.stretch = Image.STRETCH_FILL;
    result.addControl(iconImage);
    var textBlock = new TextBlock(name4 + "_button", text);
    textBlock.textWrapping = true;
    textBlock.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    result.addControl(textBlock);
    result._image = iconImage;
    result._textBlock = textBlock;
    return result;
  };
  return Button2;
}(Rectangle);
_TypeStore.RegisteredTypes["BABYLON.GUI.Button"] = Button;

// node_modules/@babylonjs/gui/2D/controls/stackPanel.js
var StackPanel = function(_super) {
  __extends(StackPanel2, _super);
  function StackPanel2(name4) {
    var _this = _super.call(this, name4) || this;
    _this.name = name4;
    _this._isVertical = true;
    _this._manualWidth = false;
    _this._manualHeight = false;
    _this._doNotTrackManualChanges = false;
    _this.ignoreLayoutWarnings = false;
    return _this;
  }
  Object.defineProperty(StackPanel2.prototype, "isVertical", {
    get: function() {
      return this._isVertical;
    },
    set: function(value) {
      if (this._isVertical === value) {
        return;
      }
      this._isVertical = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StackPanel2.prototype, "width", {
    get: function() {
      return this._width.toString(this._host);
    },
    set: function(value) {
      if (!this._doNotTrackManualChanges) {
        this._manualWidth = true;
      }
      if (this._width.toString(this._host) === value) {
        return;
      }
      if (this._width.fromString(value)) {
        this._markAsDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StackPanel2.prototype, "height", {
    get: function() {
      return this._height.toString(this._host);
    },
    set: function(value) {
      if (!this._doNotTrackManualChanges) {
        this._manualHeight = true;
      }
      if (this._height.toString(this._host) === value) {
        return;
      }
      if (this._height.fromString(value)) {
        this._markAsDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  StackPanel2.prototype._getTypeName = function() {
    return "StackPanel";
  };
  StackPanel2.prototype._preMeasure = function(parentMeasure, context) {
    for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
      var child = _a[_i];
      if (this._isVertical) {
        child.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
      } else {
        child.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
      }
    }
    _super.prototype._preMeasure.call(this, parentMeasure, context);
  };
  StackPanel2.prototype._additionalProcessing = function(parentMeasure, context) {
    _super.prototype._additionalProcessing.call(this, parentMeasure, context);
    this._measureForChildren.copyFrom(parentMeasure);
    this._measureForChildren.left = this._currentMeasure.left;
    this._measureForChildren.top = this._currentMeasure.top;
    if (!this.isVertical || this._manualWidth) {
      this._measureForChildren.width = this._currentMeasure.width;
    }
    if (this.isVertical || this._manualHeight) {
      this._measureForChildren.height = this._currentMeasure.height;
    }
  };
  StackPanel2.prototype._postMeasure = function() {
    var stackWidth = 0;
    var stackHeight = 0;
    for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
      var child = _a[_i];
      if (!child.isVisible || child.notRenderable) {
        continue;
      }
      if (this._isVertical) {
        if (child.top !== stackHeight + "px") {
          child.top = stackHeight + "px";
          this._rebuildLayout = true;
          child._top.ignoreAdaptiveScaling = true;
        }
        if (child._height.isPercentage && !child._automaticSize) {
          if (!this.ignoreLayoutWarnings) {
            Tools.Warn("Control (Name:" + child.name + ", UniqueId:" + child.uniqueId + ") is using height in percentage mode inside a vertical StackPanel");
          }
        } else {
          stackHeight += child._currentMeasure.height + child.paddingTopInPixels + child.paddingBottomInPixels;
        }
      } else {
        if (child.left !== stackWidth + "px") {
          child.left = stackWidth + "px";
          this._rebuildLayout = true;
          child._left.ignoreAdaptiveScaling = true;
        }
        if (child._width.isPercentage && !child._automaticSize) {
          if (!this.ignoreLayoutWarnings) {
            Tools.Warn("Control (Name:" + child.name + ", UniqueId:" + child.uniqueId + ") is using width in percentage mode inside a horizontal StackPanel");
          }
        } else {
          stackWidth += child._currentMeasure.width + child.paddingLeftInPixels + child.paddingRightInPixels;
        }
      }
    }
    stackWidth += this.paddingLeftInPixels + this.paddingRightInPixels;
    stackHeight += this.paddingTopInPixels + this.paddingBottomInPixels;
    this._doNotTrackManualChanges = true;
    var panelWidthChanged = false;
    var panelHeightChanged = false;
    if (!this._manualHeight && this._isVertical) {
      var previousHeight = this.height;
      this.height = stackHeight + "px";
      panelHeightChanged = previousHeight !== this.height || !this._height.ignoreAdaptiveScaling;
    }
    if (!this._manualWidth && !this._isVertical) {
      var previousWidth = this.width;
      this.width = stackWidth + "px";
      panelWidthChanged = previousWidth !== this.width || !this._width.ignoreAdaptiveScaling;
    }
    if (panelHeightChanged) {
      this._height.ignoreAdaptiveScaling = true;
    }
    if (panelWidthChanged) {
      this._width.ignoreAdaptiveScaling = true;
    }
    this._doNotTrackManualChanges = false;
    if (panelWidthChanged || panelHeightChanged) {
      this._rebuildLayout = true;
    }
    _super.prototype._postMeasure.call(this);
  };
  return StackPanel2;
}(Container);
_TypeStore.RegisteredTypes["BABYLON.GUI.StackPanel"] = StackPanel;

// node_modules/@babylonjs/gui/2D/controls/checkbox.js
var Checkbox = function(_super) {
  __extends(Checkbox2, _super);
  function Checkbox2(name4) {
    var _this = _super.call(this, name4) || this;
    _this.name = name4;
    _this._isChecked = false;
    _this._background = "black";
    _this._checkSizeRatio = 0.8;
    _this._thickness = 1;
    _this.onIsCheckedChangedObservable = new Observable();
    _this.isPointerBlocker = true;
    return _this;
  }
  Object.defineProperty(Checkbox2.prototype, "thickness", {
    get: function() {
      return this._thickness;
    },
    set: function(value) {
      if (this._thickness === value) {
        return;
      }
      this._thickness = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Checkbox2.prototype, "checkSizeRatio", {
    get: function() {
      return this._checkSizeRatio;
    },
    set: function(value) {
      value = Math.max(Math.min(1, value), 0);
      if (this._checkSizeRatio === value) {
        return;
      }
      this._checkSizeRatio = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Checkbox2.prototype, "background", {
    get: function() {
      return this._background;
    },
    set: function(value) {
      if (this._background === value) {
        return;
      }
      this._background = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Checkbox2.prototype, "isChecked", {
    get: function() {
      return this._isChecked;
    },
    set: function(value) {
      if (this._isChecked === value) {
        return;
      }
      this._isChecked = value;
      this._markAsDirty();
      this.onIsCheckedChangedObservable.notifyObservers(value);
    },
    enumerable: false,
    configurable: true
  });
  Checkbox2.prototype._getTypeName = function() {
    return "Checkbox";
  };
  Checkbox2.prototype._draw = function(context, invalidatedRectangle) {
    context.save();
    this._applyStates(context);
    var actualWidth = this._currentMeasure.width - this._thickness;
    var actualHeight = this._currentMeasure.height - this._thickness;
    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {
      context.shadowColor = this.shadowColor;
      context.shadowBlur = this.shadowBlur;
      context.shadowOffsetX = this.shadowOffsetX;
      context.shadowOffsetY = this.shadowOffsetY;
    }
    context.fillStyle = this._isEnabled ? this._background : this._disabledColor;
    context.fillRect(this._currentMeasure.left + this._thickness / 2, this._currentMeasure.top + this._thickness / 2, actualWidth, actualHeight);
    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {
      context.shadowBlur = 0;
      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
    }
    if (this._isChecked) {
      context.fillStyle = this._isEnabled ? this.color : this._disabledColorItem;
      var offsetWidth = actualWidth * this._checkSizeRatio;
      var offseHeight = actualHeight * this._checkSizeRatio;
      context.fillRect(this._currentMeasure.left + this._thickness / 2 + (actualWidth - offsetWidth) / 2, this._currentMeasure.top + this._thickness / 2 + (actualHeight - offseHeight) / 2, offsetWidth, offseHeight);
    }
    context.strokeStyle = this.color;
    context.lineWidth = this._thickness;
    context.strokeRect(this._currentMeasure.left + this._thickness / 2, this._currentMeasure.top + this._thickness / 2, actualWidth, actualHeight);
    context.restore();
  };
  Checkbox2.prototype._onPointerDown = function(target, coordinates, pointerId, buttonIndex, pi) {
    if (!_super.prototype._onPointerDown.call(this, target, coordinates, pointerId, buttonIndex, pi)) {
      return false;
    }
    this.isChecked = !this.isChecked;
    return true;
  };
  Checkbox2.AddCheckBoxWithHeader = function(title, onValueChanged) {
    var panel = new StackPanel();
    panel.isVertical = false;
    panel.height = "30px";
    var checkbox = new Checkbox2();
    checkbox.width = "20px";
    checkbox.height = "20px";
    checkbox.isChecked = true;
    checkbox.color = "green";
    checkbox.onIsCheckedChangedObservable.add(onValueChanged);
    panel.addControl(checkbox);
    var header = new TextBlock();
    header.text = title;
    header.width = "180px";
    header.paddingLeft = "5px";
    header.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    header.color = "white";
    panel.addControl(header);
    return panel;
  };
  return Checkbox2;
}(Control);
_TypeStore.RegisteredTypes["BABYLON.GUI.Checkbox"] = Checkbox;

// node_modules/@babylonjs/gui/2D/controls/textWrapper.js
var TextWrapper = function() {
  function TextWrapper2() {
  }
  Object.defineProperty(TextWrapper2.prototype, "text", {
    get: function() {
      return this._characters ? this._characters.join("") : this._text;
    },
    set: function(txt) {
      this._text = txt;
      this._characters = Array.from && Array.from(txt);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextWrapper2.prototype, "length", {
    get: function() {
      return this._characters ? this._characters.length : this._text.length;
    },
    enumerable: false,
    configurable: true
  });
  TextWrapper2.prototype.removePart = function(idxStart, idxEnd, insertTxt) {
    var _a;
    this._text = this._text.slice(0, idxStart) + (insertTxt ? insertTxt : "") + this._text.slice(idxEnd);
    if (this._characters) {
      var newCharacters = insertTxt ? Array.from(insertTxt) : [];
      (_a = this._characters).splice.apply(_a, __spreadArrays([idxStart, idxEnd - idxStart], newCharacters));
    }
  };
  TextWrapper2.prototype.charAt = function(idx) {
    return this._characters ? this._characters[idx] : this._text.charAt(idx);
  };
  TextWrapper2.prototype.substr = function(from, length) {
    if (this._characters) {
      if (isNaN(from)) {
        from = 0;
      } else if (from >= 0) {
        from = Math.min(from, this._characters.length);
      } else {
        from = this._characters.length + Math.max(from, -this._characters.length);
      }
      if (length === void 0) {
        length = this._characters.length - from;
      } else if (isNaN(length)) {
        length = 0;
      } else if (length < 0) {
        length = 0;
      }
      var temp = [];
      while (--length >= 0) {
        temp[length] = this._characters[from + length];
      }
      return temp.join("");
    }
    return this._text.substr(from, length);
  };
  TextWrapper2.prototype.substring = function(from, to) {
    if (this._characters) {
      if (isNaN(from)) {
        from = 0;
      } else if (from > this._characters.length) {
        from = this._characters.length;
      } else if (from < 0) {
        from = 0;
      }
      if (to === void 0) {
        to = this._characters.length;
      } else if (isNaN(to)) {
        to = 0;
      } else if (to > this._characters.length) {
        to = this._characters.length;
      } else if (to < 0) {
        to = 0;
      }
      var temp = [];
      var idx = 0;
      while (from < to) {
        temp[idx++] = this._characters[from++];
      }
      return temp.join("");
    }
    return this._text.substring(from, to);
  };
  TextWrapper2.prototype.isWord = function(index) {
    var rWord = /\w/g;
    return this._characters ? this._characters[index].search(rWord) !== -1 : this._text.search(rWord) !== -1;
  };
  return TextWrapper2;
}();

// node_modules/@babylonjs/gui/2D/controls/inputText.js
var InputText = function(_super) {
  __extends(InputText2, _super);
  function InputText2(name4, text) {
    if (text === void 0) {
      text = "";
    }
    var _this = _super.call(this, name4) || this;
    _this.name = name4;
    _this._placeholderText = "";
    _this._background = "#222222";
    _this._focusedBackground = "#000000";
    _this._focusedColor = "white";
    _this._placeholderColor = "gray";
    _this._thickness = 1;
    _this._margin = new ValueAndUnit(10, ValueAndUnit.UNITMODE_PIXEL);
    _this._autoStretchWidth = true;
    _this._maxWidth = new ValueAndUnit(1, ValueAndUnit.UNITMODE_PERCENTAGE, false);
    _this._isFocused = false;
    _this._blinkIsEven = false;
    _this._cursorOffset = 0;
    _this._deadKey = false;
    _this._addKey = true;
    _this._currentKey = "";
    _this._isTextHighlightOn = false;
    _this._textHighlightColor = "#d5e0ff";
    _this._highligherOpacity = 0.4;
    _this._highlightedText = "";
    _this._startHighlightIndex = 0;
    _this._endHighlightIndex = 0;
    _this._cursorIndex = -1;
    _this._onFocusSelectAll = false;
    _this._isPointerDown = false;
    _this.promptMessage = "Please enter text:";
    _this.disableMobilePrompt = false;
    _this.onTextChangedObservable = new Observable();
    _this.onBeforeKeyAddObservable = new Observable();
    _this.onFocusObservable = new Observable();
    _this.onBlurObservable = new Observable();
    _this.onTextHighlightObservable = new Observable();
    _this.onTextCopyObservable = new Observable();
    _this.onTextCutObservable = new Observable();
    _this.onTextPasteObservable = new Observable();
    _this.onKeyboardEventProcessedObservable = new Observable();
    _this.text = text;
    _this.isPointerBlocker = true;
    return _this;
  }
  Object.defineProperty(InputText2.prototype, "maxWidth", {
    get: function() {
      return this._maxWidth.toString(this._host);
    },
    set: function(value) {
      if (this._maxWidth.toString(this._host) === value) {
        return;
      }
      if (this._maxWidth.fromString(value)) {
        this._markAsDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputText2.prototype, "maxWidthInPixels", {
    get: function() {
      return this._maxWidth.getValueInPixel(this._host, this._cachedParentMeasure.width);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputText2.prototype, "highligherOpacity", {
    get: function() {
      return this._highligherOpacity;
    },
    set: function(value) {
      if (this._highligherOpacity === value) {
        return;
      }
      this._highligherOpacity = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputText2.prototype, "onFocusSelectAll", {
    get: function() {
      return this._onFocusSelectAll;
    },
    set: function(value) {
      if (this._onFocusSelectAll === value) {
        return;
      }
      this._onFocusSelectAll = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputText2.prototype, "textHighlightColor", {
    get: function() {
      return this._textHighlightColor;
    },
    set: function(value) {
      if (this._textHighlightColor === value) {
        return;
      }
      this._textHighlightColor = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputText2.prototype, "margin", {
    get: function() {
      return this._margin.toString(this._host);
    },
    set: function(value) {
      if (this._margin.toString(this._host) === value) {
        return;
      }
      if (this._margin.fromString(value)) {
        this._markAsDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputText2.prototype, "marginInPixels", {
    get: function() {
      return this._margin.getValueInPixel(this._host, this._cachedParentMeasure.width);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputText2.prototype, "autoStretchWidth", {
    get: function() {
      return this._autoStretchWidth;
    },
    set: function(value) {
      if (this._autoStretchWidth === value) {
        return;
      }
      this._autoStretchWidth = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputText2.prototype, "thickness", {
    get: function() {
      return this._thickness;
    },
    set: function(value) {
      if (this._thickness === value) {
        return;
      }
      this._thickness = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputText2.prototype, "focusedBackground", {
    get: function() {
      return this._focusedBackground;
    },
    set: function(value) {
      if (this._focusedBackground === value) {
        return;
      }
      this._focusedBackground = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputText2.prototype, "focusedColor", {
    get: function() {
      return this._focusedColor;
    },
    set: function(value) {
      if (this._focusedColor === value) {
        return;
      }
      this._focusedColor = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputText2.prototype, "background", {
    get: function() {
      return this._background;
    },
    set: function(value) {
      if (this._background === value) {
        return;
      }
      this._background = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputText2.prototype, "placeholderColor", {
    get: function() {
      return this._placeholderColor;
    },
    set: function(value) {
      if (this._placeholderColor === value) {
        return;
      }
      this._placeholderColor = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputText2.prototype, "placeholderText", {
    get: function() {
      return this._placeholderText;
    },
    set: function(value) {
      if (this._placeholderText === value) {
        return;
      }
      this._placeholderText = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputText2.prototype, "deadKey", {
    get: function() {
      return this._deadKey;
    },
    set: function(flag) {
      this._deadKey = flag;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputText2.prototype, "highlightedText", {
    get: function() {
      return this._highlightedText;
    },
    set: function(text) {
      if (this._highlightedText === text) {
        return;
      }
      this._highlightedText = text;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputText2.prototype, "addKey", {
    get: function() {
      return this._addKey;
    },
    set: function(flag) {
      this._addKey = flag;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputText2.prototype, "currentKey", {
    get: function() {
      return this._currentKey;
    },
    set: function(key) {
      this._currentKey = key;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputText2.prototype, "text", {
    get: function() {
      return this._textWrapper.text;
    },
    set: function(value) {
      var valueAsString = value.toString();
      if (!this._textWrapper) {
        this._textWrapper = new TextWrapper();
      }
      if (this._textWrapper.text === valueAsString) {
        return;
      }
      this._textWrapper.text = valueAsString;
      this._textHasChanged();
    },
    enumerable: false,
    configurable: true
  });
  InputText2.prototype._textHasChanged = function() {
    this._markAsDirty();
    this.onTextChangedObservable.notifyObservers(this);
  };
  Object.defineProperty(InputText2.prototype, "width", {
    get: function() {
      return this._width.toString(this._host);
    },
    set: function(value) {
      if (this._width.toString(this._host) === value) {
        return;
      }
      if (this._width.fromString(value)) {
        this._markAsDirty();
      }
      this.autoStretchWidth = false;
    },
    enumerable: false,
    configurable: true
  });
  InputText2.prototype.onBlur = function() {
    this._isFocused = false;
    this._scrollLeft = null;
    this._cursorOffset = 0;
    clearTimeout(this._blinkTimeout);
    this._markAsDirty();
    this.onBlurObservable.notifyObservers(this);
    this._host.unRegisterClipboardEvents();
    if (this._onClipboardObserver) {
      this._host.onClipboardObservable.remove(this._onClipboardObserver);
    }
    var scene = this._host.getScene();
    if (this._onPointerDblTapObserver && scene) {
      scene.onPointerObservable.remove(this._onPointerDblTapObserver);
    }
  };
  InputText2.prototype.onFocus = function() {
    var _this = this;
    if (!this._isEnabled) {
      return;
    }
    this._scrollLeft = null;
    this._isFocused = true;
    this._blinkIsEven = false;
    this._cursorOffset = 0;
    this._markAsDirty();
    this.onFocusObservable.notifyObservers(this);
    if (navigator.userAgent.indexOf("Mobile") !== -1 && !this.disableMobilePrompt) {
      var value = prompt(this.promptMessage);
      if (value !== null) {
        this.text = value;
      }
      this._host.focusedControl = null;
      return;
    }
    this._host.registerClipboardEvents();
    this._onClipboardObserver = this._host.onClipboardObservable.add(function(clipboardInfo) {
      switch (clipboardInfo.type) {
        case ClipboardEventTypes.COPY:
          _this._onCopyText(clipboardInfo.event);
          _this.onTextCopyObservable.notifyObservers(_this);
          break;
        case ClipboardEventTypes.CUT:
          _this._onCutText(clipboardInfo.event);
          _this.onTextCutObservable.notifyObservers(_this);
          break;
        case ClipboardEventTypes.PASTE:
          _this._onPasteText(clipboardInfo.event);
          _this.onTextPasteObservable.notifyObservers(_this);
          break;
        default:
          return;
      }
    });
    var scene = this._host.getScene();
    if (scene) {
      this._onPointerDblTapObserver = scene.onPointerObservable.add(function(pointerInfo) {
        if (!_this._isFocused) {
          return;
        }
        if (pointerInfo.type === PointerEventTypes.POINTERDOUBLETAP) {
          _this._processDblClick(pointerInfo);
        }
      });
    }
    if (this._onFocusSelectAll) {
      this._selectAllText();
    }
  };
  InputText2.prototype._getTypeName = function() {
    return "InputText";
  };
  InputText2.prototype.keepsFocusWith = function() {
    if (!this._connectedVirtualKeyboard) {
      return null;
    }
    return [this._connectedVirtualKeyboard];
  };
  InputText2.prototype.processKey = function(keyCode, key, evt) {
    if (evt && (evt.ctrlKey || evt.metaKey) && (keyCode === 67 || keyCode === 86 || keyCode === 88)) {
      return;
    }
    if (evt && (evt.ctrlKey || evt.metaKey) && keyCode === 65) {
      this._selectAllText();
      evt.preventDefault();
      return;
    }
    switch (keyCode) {
      case 32:
        key = " ";
        break;
      case 191:
        if (evt) {
          evt.preventDefault();
        }
        break;
      case 8:
        if (this._textWrapper.text && this._textWrapper.length > 0) {
          if (this._isTextHighlightOn) {
            this._textWrapper.removePart(this._startHighlightIndex, this._endHighlightIndex);
            this._textHasChanged();
            this._isTextHighlightOn = false;
            this._cursorOffset = this._textWrapper.length - this._startHighlightIndex;
            this._blinkIsEven = false;
            if (evt) {
              evt.preventDefault();
            }
            return;
          }
          if (this._cursorOffset === 0) {
            this.text = this._textWrapper.substr(0, this._textWrapper.length - 1);
          } else {
            var deletePosition = this._textWrapper.length - this._cursorOffset;
            if (deletePosition > 0) {
              this._textWrapper.removePart(deletePosition - 1, deletePosition);
              this._textHasChanged();
            }
          }
        }
        if (evt) {
          evt.preventDefault();
        }
        return;
      case 46:
        if (this._isTextHighlightOn) {
          this._textWrapper.removePart(this._startHighlightIndex, this._endHighlightIndex);
          this._textHasChanged();
          this._isTextHighlightOn = false;
          this._cursorOffset = this._textWrapper.length - this._startHighlightIndex;
          if (evt) {
            evt.preventDefault();
          }
          return;
        }
        if (this._textWrapper.text && this._textWrapper.length > 0 && this._cursorOffset > 0) {
          var deletePosition = this._textWrapper.length - this._cursorOffset;
          this._textWrapper.removePart(deletePosition, deletePosition + 1);
          this._textHasChanged();
          this._cursorOffset--;
        }
        if (evt) {
          evt.preventDefault();
        }
        return;
      case 13:
        this._host.focusedControl = null;
        this._isTextHighlightOn = false;
        return;
      case 35:
        this._cursorOffset = 0;
        this._blinkIsEven = false;
        this._isTextHighlightOn = false;
        this._markAsDirty();
        return;
      case 36:
        this._cursorOffset = this._textWrapper.length;
        this._blinkIsEven = false;
        this._isTextHighlightOn = false;
        this._markAsDirty();
        return;
      case 37:
        this._cursorOffset++;
        if (this._cursorOffset > this._textWrapper.length) {
          this._cursorOffset = this._textWrapper.length;
        }
        if (evt && evt.shiftKey) {
          this._blinkIsEven = false;
          if (evt.ctrlKey || evt.metaKey) {
            if (!this._isTextHighlightOn) {
              if (this._textWrapper.length === this._cursorOffset) {
                return;
              } else {
                this._endHighlightIndex = this._textWrapper.length - this._cursorOffset + 1;
              }
            }
            this._startHighlightIndex = 0;
            this._cursorIndex = this._textWrapper.length - this._endHighlightIndex;
            this._cursorOffset = this._textWrapper.length;
            this._isTextHighlightOn = true;
            this._markAsDirty();
            return;
          }
          if (!this._isTextHighlightOn) {
            this._isTextHighlightOn = true;
            this._cursorIndex = this._cursorOffset >= this._textWrapper.length ? this._textWrapper.length : this._cursorOffset - 1;
          } else if (this._cursorIndex === -1) {
            this._cursorIndex = this._textWrapper.length - this._endHighlightIndex;
            this._cursorOffset = this._startHighlightIndex === 0 ? this._textWrapper.length : this._textWrapper.length - this._startHighlightIndex + 1;
          }
          if (this._cursorIndex < this._cursorOffset) {
            this._endHighlightIndex = this._textWrapper.length - this._cursorIndex;
            this._startHighlightIndex = this._textWrapper.length - this._cursorOffset;
          } else if (this._cursorIndex > this._cursorOffset) {
            this._endHighlightIndex = this._textWrapper.length - this._cursorOffset;
            this._startHighlightIndex = this._textWrapper.length - this._cursorIndex;
          } else {
            this._isTextHighlightOn = false;
          }
          this._markAsDirty();
          return;
        }
        if (this._isTextHighlightOn) {
          this._cursorOffset = this._textWrapper.length - this._startHighlightIndex;
          this._isTextHighlightOn = false;
        }
        if (evt && (evt.ctrlKey || evt.metaKey)) {
          this._cursorOffset = this._textWrapper.length;
          evt.preventDefault();
        }
        this._blinkIsEven = false;
        this._isTextHighlightOn = false;
        this._cursorIndex = -1;
        this._markAsDirty();
        return;
      case 39:
        this._cursorOffset--;
        if (this._cursorOffset < 0) {
          this._cursorOffset = 0;
        }
        if (evt && evt.shiftKey) {
          this._blinkIsEven = false;
          if (evt.ctrlKey || evt.metaKey) {
            if (!this._isTextHighlightOn) {
              if (this._cursorOffset === 0) {
                return;
              } else {
                this._startHighlightIndex = this._textWrapper.length - this._cursorOffset - 1;
              }
            }
            this._endHighlightIndex = this._textWrapper.length;
            this._isTextHighlightOn = true;
            this._cursorIndex = this._textWrapper.length - this._startHighlightIndex;
            this._cursorOffset = 0;
            this._markAsDirty();
            return;
          }
          if (!this._isTextHighlightOn) {
            this._isTextHighlightOn = true;
            this._cursorIndex = this._cursorOffset <= 0 ? 0 : this._cursorOffset + 1;
          } else if (this._cursorIndex === -1) {
            this._cursorIndex = this._textWrapper.length - this._startHighlightIndex;
            this._cursorOffset = this._textWrapper.length === this._endHighlightIndex ? 0 : this._textWrapper.length - this._endHighlightIndex - 1;
          }
          if (this._cursorIndex < this._cursorOffset) {
            this._endHighlightIndex = this._textWrapper.length - this._cursorIndex;
            this._startHighlightIndex = this._textWrapper.length - this._cursorOffset;
          } else if (this._cursorIndex > this._cursorOffset) {
            this._endHighlightIndex = this._textWrapper.length - this._cursorOffset;
            this._startHighlightIndex = this._textWrapper.length - this._cursorIndex;
          } else {
            this._isTextHighlightOn = false;
          }
          this._markAsDirty();
          return;
        }
        if (this._isTextHighlightOn) {
          this._cursorOffset = this._textWrapper.length - this._endHighlightIndex;
          this._isTextHighlightOn = false;
        }
        if (evt && (evt.ctrlKey || evt.metaKey)) {
          this._cursorOffset = 0;
          evt.preventDefault();
        }
        this._blinkIsEven = false;
        this._isTextHighlightOn = false;
        this._cursorIndex = -1;
        this._markAsDirty();
        return;
      case 222:
        if (evt) {
          evt.preventDefault();
        }
        this._cursorIndex = -1;
        this.deadKey = true;
        break;
    }
    if (key && (keyCode === -1 || keyCode === 32 || keyCode > 47 && keyCode < 64 || keyCode > 64 && keyCode < 91 || keyCode > 159 && keyCode < 193 || keyCode > 218 && keyCode < 223 || keyCode > 95 && keyCode < 112)) {
      this._currentKey = key;
      this.onBeforeKeyAddObservable.notifyObservers(this);
      key = this._currentKey;
      if (this._addKey) {
        if (this._isTextHighlightOn) {
          this._textWrapper.removePart(this._startHighlightIndex, this._endHighlightIndex, key);
          this._textHasChanged();
          this._cursorOffset = this._textWrapper.length - (this._startHighlightIndex + 1);
          this._isTextHighlightOn = false;
          this._blinkIsEven = false;
          this._markAsDirty();
        } else if (this._cursorOffset === 0) {
          this.text += key;
        } else {
          var insertPosition = this._textWrapper.length - this._cursorOffset;
          this._textWrapper.removePart(insertPosition, insertPosition, key);
          this._textHasChanged();
        }
      }
    }
  };
  InputText2.prototype._updateValueFromCursorIndex = function(offset) {
    this._blinkIsEven = false;
    if (this._cursorIndex === -1) {
      this._cursorIndex = offset;
    } else {
      if (this._cursorIndex < this._cursorOffset) {
        this._endHighlightIndex = this._textWrapper.length - this._cursorIndex;
        this._startHighlightIndex = this._textWrapper.length - this._cursorOffset;
      } else if (this._cursorIndex > this._cursorOffset) {
        this._endHighlightIndex = this._textWrapper.length - this._cursorOffset;
        this._startHighlightIndex = this._textWrapper.length - this._cursorIndex;
      } else {
        this._isTextHighlightOn = false;
        this._markAsDirty();
        return;
      }
    }
    this._isTextHighlightOn = true;
    this._markAsDirty();
  };
  InputText2.prototype._processDblClick = function(evt) {
    this._startHighlightIndex = this._textWrapper.length - this._cursorOffset;
    this._endHighlightIndex = this._startHighlightIndex;
    var moveLeft, moveRight;
    do {
      moveRight = this._endHighlightIndex < this._textWrapper.length && this._textWrapper.isWord(this._endHighlightIndex) ? ++this._endHighlightIndex : 0;
      moveLeft = this._startHighlightIndex > 0 && this._textWrapper.isWord(this._startHighlightIndex - 1) ? --this._startHighlightIndex : 0;
    } while (moveLeft || moveRight);
    this._cursorOffset = this._textWrapper.length - this._startHighlightIndex;
    this.onTextHighlightObservable.notifyObservers(this);
    this._isTextHighlightOn = true;
    this._clickedCoordinate = null;
    this._blinkIsEven = true;
    this._cursorIndex = -1;
    this._markAsDirty();
  };
  InputText2.prototype._selectAllText = function() {
    this._blinkIsEven = true;
    this._isTextHighlightOn = true;
    this._startHighlightIndex = 0;
    this._endHighlightIndex = this._textWrapper.length;
    this._cursorOffset = this._textWrapper.length;
    this._cursorIndex = -1;
    this._markAsDirty();
  };
  InputText2.prototype.processKeyboard = function(evt) {
    this.processKey(evt.keyCode, evt.key, evt);
    this.onKeyboardEventProcessedObservable.notifyObservers(evt);
  };
  InputText2.prototype._onCopyText = function(ev) {
    this._isTextHighlightOn = false;
    try {
      ev.clipboardData && ev.clipboardData.setData("text/plain", this._highlightedText);
    } catch (_a) {
    }
    this._host.clipboardData = this._highlightedText;
  };
  InputText2.prototype._onCutText = function(ev) {
    if (!this._highlightedText) {
      return;
    }
    this._textWrapper.removePart(this._startHighlightIndex, this._endHighlightIndex);
    this._textHasChanged();
    this._isTextHighlightOn = false;
    this._cursorOffset = this._textWrapper.length - this._startHighlightIndex;
    try {
      ev.clipboardData && ev.clipboardData.setData("text/plain", this._highlightedText);
    } catch (_a) {
    }
    this._host.clipboardData = this._highlightedText;
    this._highlightedText = "";
  };
  InputText2.prototype._onPasteText = function(ev) {
    var data = "";
    if (ev.clipboardData && ev.clipboardData.types.indexOf("text/plain") !== -1) {
      data = ev.clipboardData.getData("text/plain");
    } else {
      data = this._host.clipboardData;
    }
    var insertPosition = this._textWrapper.length - this._cursorOffset;
    this._textWrapper.removePart(insertPosition, insertPosition, data);
    this._textHasChanged();
  };
  InputText2.prototype._draw = function(context, invalidatedRectangle) {
    var _this = this;
    context.save();
    this._applyStates(context);
    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {
      context.shadowColor = this.shadowColor;
      context.shadowBlur = this.shadowBlur;
      context.shadowOffsetX = this.shadowOffsetX;
      context.shadowOffsetY = this.shadowOffsetY;
    }
    if (this._isFocused) {
      if (this._focusedBackground) {
        context.fillStyle = this._isEnabled ? this._focusedBackground : this._disabledColor;
        context.fillRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);
      }
    } else if (this._background) {
      context.fillStyle = this._isEnabled ? this._background : this._disabledColor;
      context.fillRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);
    }
    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {
      context.shadowBlur = 0;
      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
    }
    if (!this._fontOffset) {
      this._fontOffset = Control._GetFontOffset(context.font);
    }
    var clipTextLeft = this._currentMeasure.left + this._margin.getValueInPixel(this._host, this._tempParentMeasure.width);
    if (this.color) {
      context.fillStyle = this.color;
    }
    var text = this._beforeRenderText(this._textWrapper);
    if (!this._isFocused && !this._textWrapper.text && this._placeholderText) {
      text = new TextWrapper();
      text.text = this._placeholderText;
      if (this._placeholderColor) {
        context.fillStyle = this._placeholderColor;
      }
    }
    this._textWidth = context.measureText(text.text).width;
    var marginWidth = this._margin.getValueInPixel(this._host, this._tempParentMeasure.width) * 2;
    if (this._autoStretchWidth) {
      this.width = Math.min(this._maxWidth.getValueInPixel(this._host, this._tempParentMeasure.width), this._textWidth + marginWidth) + "px";
    }
    var rootY = this._fontOffset.ascent + (this._currentMeasure.height - this._fontOffset.height) / 2;
    var availableWidth = this._width.getValueInPixel(this._host, this._tempParentMeasure.width) - marginWidth;
    context.save();
    context.beginPath();
    context.rect(clipTextLeft, this._currentMeasure.top + (this._currentMeasure.height - this._fontOffset.height) / 2, availableWidth + 2, this._currentMeasure.height);
    context.clip();
    if (this._isFocused && this._textWidth > availableWidth) {
      var textLeft = clipTextLeft - this._textWidth + availableWidth;
      if (!this._scrollLeft) {
        this._scrollLeft = textLeft;
      }
    } else {
      this._scrollLeft = clipTextLeft;
    }
    context.fillText(text.text, this._scrollLeft, this._currentMeasure.top + rootY);
    if (this._isFocused) {
      if (this._clickedCoordinate) {
        var rightPosition = this._scrollLeft + this._textWidth;
        var absoluteCursorPosition = rightPosition - this._clickedCoordinate;
        var currentSize = 0;
        this._cursorOffset = 0;
        var previousDist = 0;
        do {
          if (this._cursorOffset) {
            previousDist = Math.abs(absoluteCursorPosition - currentSize);
          }
          this._cursorOffset++;
          currentSize = context.measureText(text.substr(text.length - this._cursorOffset, this._cursorOffset)).width;
        } while (currentSize < absoluteCursorPosition && text.length >= this._cursorOffset);
        if (Math.abs(absoluteCursorPosition - currentSize) > previousDist) {
          this._cursorOffset--;
        }
        this._blinkIsEven = false;
        this._clickedCoordinate = null;
      }
      if (!this._blinkIsEven) {
        var cursorOffsetText = text.substr(text.length - this._cursorOffset);
        var cursorOffsetWidth = context.measureText(cursorOffsetText).width;
        var cursorLeft = this._scrollLeft + this._textWidth - cursorOffsetWidth;
        if (cursorLeft < clipTextLeft) {
          this._scrollLeft += clipTextLeft - cursorLeft;
          cursorLeft = clipTextLeft;
          this._markAsDirty();
        } else if (cursorLeft > clipTextLeft + availableWidth) {
          this._scrollLeft += clipTextLeft + availableWidth - cursorLeft;
          cursorLeft = clipTextLeft + availableWidth;
          this._markAsDirty();
        }
        if (!this._isTextHighlightOn) {
          context.fillRect(cursorLeft, this._currentMeasure.top + (this._currentMeasure.height - this._fontOffset.height) / 2, 2, this._fontOffset.height);
        }
      }
      clearTimeout(this._blinkTimeout);
      this._blinkTimeout = setTimeout(function() {
        _this._blinkIsEven = !_this._blinkIsEven;
        _this._markAsDirty();
      }, 500);
      if (this._isTextHighlightOn) {
        clearTimeout(this._blinkTimeout);
        var highlightCursorOffsetWidth = context.measureText(text.substring(this._startHighlightIndex)).width;
        var highlightCursorLeft = this._scrollLeft + this._textWidth - highlightCursorOffsetWidth;
        this._highlightedText = text.substring(this._startHighlightIndex, this._endHighlightIndex);
        var width = context.measureText(text.substring(this._startHighlightIndex, this._endHighlightIndex)).width;
        if (highlightCursorLeft < clipTextLeft) {
          width = width - (clipTextLeft - highlightCursorLeft);
          if (!width) {
            width = context.measureText(text.charAt(text.length - this._cursorOffset)).width;
          }
          highlightCursorLeft = clipTextLeft;
        }
        context.globalAlpha = this._highligherOpacity;
        context.fillStyle = this._textHighlightColor;
        context.fillRect(highlightCursorLeft, this._currentMeasure.top + (this._currentMeasure.height - this._fontOffset.height) / 2, width, this._fontOffset.height);
        context.globalAlpha = 1;
      }
    }
    context.restore();
    if (this._thickness) {
      if (this._isFocused) {
        if (this.focusedColor) {
          context.strokeStyle = this.focusedColor;
        }
      } else {
        if (this.color) {
          context.strokeStyle = this.color;
        }
      }
      context.lineWidth = this._thickness;
      context.strokeRect(this._currentMeasure.left + this._thickness / 2, this._currentMeasure.top + this._thickness / 2, this._currentMeasure.width - this._thickness, this._currentMeasure.height - this._thickness);
    }
    context.restore();
  };
  InputText2.prototype._onPointerDown = function(target, coordinates, pointerId, buttonIndex, pi) {
    if (!_super.prototype._onPointerDown.call(this, target, coordinates, pointerId, buttonIndex, pi)) {
      return false;
    }
    this._clickedCoordinate = coordinates.x;
    this._isTextHighlightOn = false;
    this._highlightedText = "";
    this._cursorIndex = -1;
    this._isPointerDown = true;
    this._host._capturingControl[pointerId] = this;
    if (this._host.focusedControl === this) {
      clearTimeout(this._blinkTimeout);
      this._markAsDirty();
      return true;
    }
    if (!this._isEnabled) {
      return false;
    }
    this._host.focusedControl = this;
    return true;
  };
  InputText2.prototype._onPointerMove = function(target, coordinates, pointerId, pi) {
    if (this._host.focusedControl === this && this._isPointerDown) {
      this._clickedCoordinate = coordinates.x;
      this._markAsDirty();
      this._updateValueFromCursorIndex(this._cursorOffset);
    }
    _super.prototype._onPointerMove.call(this, target, coordinates, pointerId, pi);
  };
  InputText2.prototype._onPointerUp = function(target, coordinates, pointerId, buttonIndex, notifyClick) {
    this._isPointerDown = false;
    delete this._host._capturingControl[pointerId];
    _super.prototype._onPointerUp.call(this, target, coordinates, pointerId, buttonIndex, notifyClick);
  };
  InputText2.prototype._beforeRenderText = function(textWrapper) {
    return textWrapper;
  };
  InputText2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this.onBlurObservable.clear();
    this.onFocusObservable.clear();
    this.onTextChangedObservable.clear();
    this.onTextCopyObservable.clear();
    this.onTextCutObservable.clear();
    this.onTextPasteObservable.clear();
    this.onTextHighlightObservable.clear();
    this.onKeyboardEventProcessedObservable.clear();
  };
  return InputText2;
}(Control);
_TypeStore.RegisteredTypes["BABYLON.GUI.InputText"] = InputText;

// node_modules/@babylonjs/gui/2D/controls/grid.js
var Grid = function(_super) {
  __extends(Grid2, _super);
  function Grid2(name4) {
    var _this = _super.call(this, name4) || this;
    _this.name = name4;
    _this._rowDefinitions = new Array();
    _this._columnDefinitions = new Array();
    _this._cells = {};
    _this._childControls = new Array();
    return _this;
  }
  Object.defineProperty(Grid2.prototype, "columnCount", {
    get: function() {
      return this._columnDefinitions.length;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Grid2.prototype, "rowCount", {
    get: function() {
      return this._rowDefinitions.length;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Grid2.prototype, "children", {
    get: function() {
      return this._childControls;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Grid2.prototype, "cells", {
    get: function() {
      return this._cells;
    },
    enumerable: false,
    configurable: true
  });
  Grid2.prototype.getRowDefinition = function(index) {
    if (index < 0 || index >= this._rowDefinitions.length) {
      return null;
    }
    return this._rowDefinitions[index];
  };
  Grid2.prototype.getColumnDefinition = function(index) {
    if (index < 0 || index >= this._columnDefinitions.length) {
      return null;
    }
    return this._columnDefinitions[index];
  };
  Grid2.prototype.addRowDefinition = function(height, isPixel) {
    if (isPixel === void 0) {
      isPixel = false;
    }
    this._rowDefinitions.push(new ValueAndUnit(height, isPixel ? ValueAndUnit.UNITMODE_PIXEL : ValueAndUnit.UNITMODE_PERCENTAGE));
    this._markAsDirty();
    return this;
  };
  Grid2.prototype.addColumnDefinition = function(width, isPixel) {
    if (isPixel === void 0) {
      isPixel = false;
    }
    this._columnDefinitions.push(new ValueAndUnit(width, isPixel ? ValueAndUnit.UNITMODE_PIXEL : ValueAndUnit.UNITMODE_PERCENTAGE));
    this._markAsDirty();
    return this;
  };
  Grid2.prototype.setRowDefinition = function(index, height, isPixel) {
    if (isPixel === void 0) {
      isPixel = false;
    }
    if (index < 0 || index >= this._rowDefinitions.length) {
      return this;
    }
    var current = this._rowDefinitions[index];
    if (current && current.isPixel === isPixel && current.internalValue === height) {
      return this;
    }
    this._rowDefinitions[index] = new ValueAndUnit(height, isPixel ? ValueAndUnit.UNITMODE_PIXEL : ValueAndUnit.UNITMODE_PERCENTAGE);
    this._markAsDirty();
    return this;
  };
  Grid2.prototype.setColumnDefinition = function(index, width, isPixel) {
    if (isPixel === void 0) {
      isPixel = false;
    }
    if (index < 0 || index >= this._columnDefinitions.length) {
      return this;
    }
    var current = this._columnDefinitions[index];
    if (current && current.isPixel === isPixel && current.internalValue === width) {
      return this;
    }
    this._columnDefinitions[index] = new ValueAndUnit(width, isPixel ? ValueAndUnit.UNITMODE_PIXEL : ValueAndUnit.UNITMODE_PERCENTAGE);
    this._markAsDirty();
    return this;
  };
  Grid2.prototype.getChildrenAt = function(row, column) {
    var cell = this._cells[row + ":" + column];
    if (!cell) {
      return null;
    }
    return cell.children;
  };
  Grid2.prototype.getChildCellInfo = function(child) {
    return child._tag;
  };
  Grid2.prototype._removeCell = function(cell, key) {
    if (!cell) {
      return;
    }
    _super.prototype.removeControl.call(this, cell);
    for (var _i = 0, _a = cell.children; _i < _a.length; _i++) {
      var control = _a[_i];
      var childIndex = this._childControls.indexOf(control);
      if (childIndex !== -1) {
        this._childControls.splice(childIndex, 1);
      }
    }
    delete this._cells[key];
  };
  Grid2.prototype._offsetCell = function(previousKey, key) {
    if (!this._cells[key]) {
      return;
    }
    this._cells[previousKey] = this._cells[key];
    for (var _i = 0, _a = this._cells[previousKey].children; _i < _a.length; _i++) {
      var control = _a[_i];
      control._tag = previousKey;
    }
    delete this._cells[key];
  };
  Grid2.prototype.removeColumnDefinition = function(index) {
    if (index < 0 || index >= this._columnDefinitions.length) {
      return this;
    }
    for (var x = 0; x < this._rowDefinitions.length; x++) {
      var key = x + ":" + index;
      var cell = this._cells[key];
      this._removeCell(cell, key);
    }
    for (var x = 0; x < this._rowDefinitions.length; x++) {
      for (var y = index + 1; y < this._columnDefinitions.length; y++) {
        var previousKey = x + ":" + (y - 1);
        var key = x + ":" + y;
        this._offsetCell(previousKey, key);
      }
    }
    this._columnDefinitions.splice(index, 1);
    this._markAsDirty();
    return this;
  };
  Grid2.prototype.removeRowDefinition = function(index) {
    if (index < 0 || index >= this._rowDefinitions.length) {
      return this;
    }
    for (var y = 0; y < this._columnDefinitions.length; y++) {
      var key = index + ":" + y;
      var cell = this._cells[key];
      this._removeCell(cell, key);
    }
    for (var y = 0; y < this._columnDefinitions.length; y++) {
      for (var x = index + 1; x < this._rowDefinitions.length; x++) {
        var previousKey = x - 1 + ":" + y;
        var key = x + ":" + y;
        this._offsetCell(previousKey, key);
      }
    }
    this._rowDefinitions.splice(index, 1);
    this._markAsDirty();
    return this;
  };
  Grid2.prototype.addControl = function(control, row, column) {
    if (row === void 0) {
      row = 0;
    }
    if (column === void 0) {
      column = 0;
    }
    if (this._rowDefinitions.length === 0) {
      this.addRowDefinition(1, false);
    }
    if (this._columnDefinitions.length === 0) {
      this.addColumnDefinition(1, false);
    }
    if (this._childControls.indexOf(control) !== -1) {
      Tools.Warn("Control (Name:" + control.name + ", UniqueId:" + control.uniqueId + ") is already associated with this grid. You must remove it before reattaching it");
      return this;
    }
    var x = Math.min(row, this._rowDefinitions.length - 1);
    var y = Math.min(column, this._columnDefinitions.length - 1);
    var key = x + ":" + y;
    var goodContainer = this._cells[key];
    if (!goodContainer) {
      goodContainer = new Container(key);
      this._cells[key] = goodContainer;
      goodContainer.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
      goodContainer.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
      _super.prototype.addControl.call(this, goodContainer);
    }
    goodContainer.addControl(control);
    this._childControls.push(control);
    control._tag = key;
    control.parent = this;
    this._markAsDirty();
    return this;
  };
  Grid2.prototype.removeControl = function(control) {
    var index = this._childControls.indexOf(control);
    if (index !== -1) {
      this._childControls.splice(index, 1);
    }
    var cell = this._cells[control._tag];
    if (cell) {
      cell.removeControl(control);
      control._tag = null;
    }
    this._markAsDirty();
    return this;
  };
  Grid2.prototype._getTypeName = function() {
    return "Grid";
  };
  Grid2.prototype._getGridDefinitions = function(definitionCallback) {
    var widths = [];
    var heights = [];
    var lefts = [];
    var tops = [];
    var availableWidth = this._currentMeasure.width;
    var globalWidthPercentage = 0;
    var availableHeight = this._currentMeasure.height;
    var globalHeightPercentage = 0;
    var index = 0;
    for (var _i = 0, _a = this._rowDefinitions; _i < _a.length; _i++) {
      var value = _a[_i];
      if (value.isPixel) {
        var height = value.getValue(this._host);
        availableHeight -= height;
        heights[index] = height;
      } else {
        globalHeightPercentage += value.internalValue;
      }
      index++;
    }
    var top = 0;
    index = 0;
    for (var _b = 0, _c = this._rowDefinitions; _b < _c.length; _b++) {
      var value = _c[_b];
      tops.push(top);
      if (!value.isPixel) {
        var height = value.internalValue / globalHeightPercentage * availableHeight;
        top += height;
        heights[index] = height;
      } else {
        top += value.getValue(this._host);
      }
      index++;
    }
    index = 0;
    for (var _d = 0, _e = this._columnDefinitions; _d < _e.length; _d++) {
      var value = _e[_d];
      if (value.isPixel) {
        var width = value.getValue(this._host);
        availableWidth -= width;
        widths[index] = width;
      } else {
        globalWidthPercentage += value.internalValue;
      }
      index++;
    }
    var left = 0;
    index = 0;
    for (var _f = 0, _g = this._columnDefinitions; _f < _g.length; _f++) {
      var value = _g[_f];
      lefts.push(left);
      if (!value.isPixel) {
        var width = value.internalValue / globalWidthPercentage * availableWidth;
        left += width;
        widths[index] = width;
      } else {
        left += value.getValue(this._host);
      }
      index++;
    }
    definitionCallback(lefts, tops, widths, heights);
  };
  Grid2.prototype._additionalProcessing = function(parentMeasure, context) {
    var _this = this;
    this._getGridDefinitions(function(lefts, tops, widths, heights) {
      for (var key in _this._cells) {
        if (!_this._cells.hasOwnProperty(key)) {
          continue;
        }
        var split = key.split(":");
        var x = parseInt(split[0]);
        var y = parseInt(split[1]);
        var cell = _this._cells[key];
        cell.left = lefts[y] + "px";
        cell.top = tops[x] + "px";
        cell.width = widths[y] + "px";
        cell.height = heights[x] + "px";
        cell._left.ignoreAdaptiveScaling = true;
        cell._top.ignoreAdaptiveScaling = true;
        cell._width.ignoreAdaptiveScaling = true;
        cell._height.ignoreAdaptiveScaling = true;
      }
    });
    _super.prototype._additionalProcessing.call(this, parentMeasure, context);
  };
  Grid2.prototype._flagDescendantsAsMatrixDirty = function() {
    for (var key in this._cells) {
      if (!this._cells.hasOwnProperty(key)) {
        continue;
      }
      var child = this._cells[key];
      child._markMatrixAsDirty();
    }
  };
  Grid2.prototype._renderHighlightSpecific = function(context) {
    var _this = this;
    _super.prototype._renderHighlightSpecific.call(this, context);
    this._getGridDefinitions(function(lefts, tops, widths, heights) {
      for (var index = 0; index < lefts.length; index++) {
        var left = _this._currentMeasure.left + lefts[index] + widths[index];
        context.beginPath();
        context.moveTo(left, _this._currentMeasure.top);
        context.lineTo(left, _this._currentMeasure.top + _this._currentMeasure.height);
        context.stroke();
      }
      for (var index = 0; index < tops.length; index++) {
        var top_1 = _this._currentMeasure.top + tops[index] + heights[index];
        context.beginPath();
        context.moveTo(_this._currentMeasure.left, top_1);
        context.lineTo(_this._currentMeasure.left + _this._currentMeasure.width, top_1);
        context.stroke();
      }
    });
    context.restore();
  };
  Grid2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    for (var _i = 0, _a = this._childControls; _i < _a.length; _i++) {
      var control = _a[_i];
      control.dispose();
    }
    this._childControls = [];
  };
  return Grid2;
}(Container);
_TypeStore.RegisteredTypes["BABYLON.GUI.Grid"] = Grid;

// node_modules/@babylonjs/gui/2D/controls/colorpicker.js
var ColorPicker = function(_super) {
  __extends(ColorPicker2, _super);
  function ColorPicker2(name4) {
    var _this = _super.call(this, name4) || this;
    _this.name = name4;
    _this._value = Color3.Red();
    _this._tmpColor = new Color3();
    _this._pointerStartedOnSquare = false;
    _this._pointerStartedOnWheel = false;
    _this._squareLeft = 0;
    _this._squareTop = 0;
    _this._squareSize = 0;
    _this._h = 360;
    _this._s = 1;
    _this._v = 1;
    _this._lastPointerDownID = -1;
    _this.onValueChangedObservable = new Observable();
    _this._pointerIsDown = false;
    _this.value = new Color3(0.88, 0.1, 0.1);
    _this.size = "200px";
    _this.isPointerBlocker = true;
    return _this;
  }
  Object.defineProperty(ColorPicker2.prototype, "value", {
    get: function() {
      return this._value;
    },
    set: function(value) {
      if (this._value.equals(value)) {
        return;
      }
      this._value.copyFrom(value);
      this._value.toHSVToRef(this._tmpColor);
      this._h = this._tmpColor.r;
      this._s = Math.max(this._tmpColor.g, 1e-5);
      this._v = Math.max(this._tmpColor.b, 1e-5);
      this._markAsDirty();
      if (this._value.r <= ColorPicker2._Epsilon) {
        this._value.r = 0;
      }
      if (this._value.g <= ColorPicker2._Epsilon) {
        this._value.g = 0;
      }
      if (this._value.b <= ColorPicker2._Epsilon) {
        this._value.b = 0;
      }
      if (this._value.r >= 1 - ColorPicker2._Epsilon) {
        this._value.r = 1;
      }
      if (this._value.g >= 1 - ColorPicker2._Epsilon) {
        this._value.g = 1;
      }
      if (this._value.b >= 1 - ColorPicker2._Epsilon) {
        this._value.b = 1;
      }
      this.onValueChangedObservable.notifyObservers(this._value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorPicker2.prototype, "width", {
    get: function() {
      return this._width.toString(this._host);
    },
    set: function(value) {
      if (this._width.toString(this._host) === value) {
        return;
      }
      if (this._width.fromString(value)) {
        this._height.fromString(value);
        this._markAsDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorPicker2.prototype, "height", {
    get: function() {
      return this._height.toString(this._host);
    },
    set: function(value) {
      if (this._height.toString(this._host) === value) {
        return;
      }
      if (this._height.fromString(value)) {
        this._width.fromString(value);
        this._markAsDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorPicker2.prototype, "size", {
    get: function() {
      return this.width;
    },
    set: function(value) {
      this.width = value;
    },
    enumerable: false,
    configurable: true
  });
  ColorPicker2.prototype._getTypeName = function() {
    return "ColorPicker";
  };
  ColorPicker2.prototype._preMeasure = function(parentMeasure, context) {
    if (parentMeasure.width < parentMeasure.height) {
      this._currentMeasure.height = parentMeasure.width;
    } else {
      this._currentMeasure.width = parentMeasure.height;
    }
  };
  ColorPicker2.prototype._updateSquareProps = function() {
    var radius = Math.min(this._currentMeasure.width, this._currentMeasure.height) * 0.5;
    var wheelThickness = radius * 0.2;
    var innerDiameter = (radius - wheelThickness) * 2;
    var squareSize = innerDiameter / Math.sqrt(2);
    var offset = radius - squareSize * 0.5;
    this._squareLeft = this._currentMeasure.left + offset;
    this._squareTop = this._currentMeasure.top + offset;
    this._squareSize = squareSize;
  };
  ColorPicker2.prototype._drawGradientSquare = function(hueValue, left, top, width, height, context) {
    var lgh = context.createLinearGradient(left, top, width + left, top);
    lgh.addColorStop(0, "#fff");
    lgh.addColorStop(1, "hsl(" + hueValue + ", 100%, 50%)");
    context.fillStyle = lgh;
    context.fillRect(left, top, width, height);
    var lgv = context.createLinearGradient(left, top, left, height + top);
    lgv.addColorStop(0, "rgba(0,0,0,0)");
    lgv.addColorStop(1, "#000");
    context.fillStyle = lgv;
    context.fillRect(left, top, width, height);
  };
  ColorPicker2.prototype._drawCircle = function(centerX, centerY, radius, context) {
    context.beginPath();
    context.arc(centerX, centerY, radius + 1, 0, 2 * Math.PI, false);
    context.lineWidth = 3;
    context.strokeStyle = "#333333";
    context.stroke();
    context.beginPath();
    context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
    context.lineWidth = 3;
    context.strokeStyle = "#ffffff";
    context.stroke();
  };
  ColorPicker2.prototype._createColorWheelCanvas = function(radius, thickness) {
    var canvas = document.createElement("canvas");
    canvas.width = radius * 2;
    canvas.height = radius * 2;
    var context = canvas.getContext("2d");
    var image = context.getImageData(0, 0, radius * 2, radius * 2);
    var data = image.data;
    var color = this._tmpColor;
    var maxDistSq = radius * radius;
    var innerRadius = radius - thickness;
    var minDistSq = innerRadius * innerRadius;
    for (var x = -radius; x < radius; x++) {
      for (var y = -radius; y < radius; y++) {
        var distSq = x * x + y * y;
        if (distSq > maxDistSq || distSq < minDistSq) {
          continue;
        }
        var dist = Math.sqrt(distSq);
        var ang = Math.atan2(y, x);
        Color3.HSVtoRGBToRef(ang * 180 / Math.PI + 180, dist / radius, 1, color);
        var index = (x + radius + (y + radius) * 2 * radius) * 4;
        data[index] = color.r * 255;
        data[index + 1] = color.g * 255;
        data[index + 2] = color.b * 255;
        var alphaRatio = (dist - innerRadius) / (radius - innerRadius);
        var alphaAmount = 0.2;
        var maxAlpha = 0.2;
        var minAlpha = 0.04;
        var lowerRadius = 50;
        var upperRadius = 150;
        if (radius < lowerRadius) {
          alphaAmount = maxAlpha;
        } else if (radius > upperRadius) {
          alphaAmount = minAlpha;
        } else {
          alphaAmount = (minAlpha - maxAlpha) * (radius - lowerRadius) / (upperRadius - lowerRadius) + maxAlpha;
        }
        var alphaRatio = (dist - innerRadius) / (radius - innerRadius);
        if (alphaRatio < alphaAmount) {
          data[index + 3] = 255 * (alphaRatio / alphaAmount);
        } else if (alphaRatio > 1 - alphaAmount) {
          data[index + 3] = 255 * (1 - (alphaRatio - (1 - alphaAmount)) / alphaAmount);
        } else {
          data[index + 3] = 255;
        }
      }
    }
    context.putImageData(image, 0, 0);
    return canvas;
  };
  ColorPicker2.prototype._draw = function(context) {
    context.save();
    this._applyStates(context);
    var radius = Math.min(this._currentMeasure.width, this._currentMeasure.height) * 0.5;
    var wheelThickness = radius * 0.2;
    var left = this._currentMeasure.left;
    var top = this._currentMeasure.top;
    if (!this._colorWheelCanvas || this._colorWheelCanvas.width != radius * 2) {
      this._colorWheelCanvas = this._createColorWheelCanvas(radius, wheelThickness);
    }
    this._updateSquareProps();
    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {
      context.shadowColor = this.shadowColor;
      context.shadowBlur = this.shadowBlur;
      context.shadowOffsetX = this.shadowOffsetX;
      context.shadowOffsetY = this.shadowOffsetY;
      context.fillRect(this._squareLeft, this._squareTop, this._squareSize, this._squareSize);
    }
    context.drawImage(this._colorWheelCanvas, left, top);
    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {
      context.shadowBlur = 0;
      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
    }
    this._drawGradientSquare(this._h, this._squareLeft, this._squareTop, this._squareSize, this._squareSize, context);
    var cx = this._squareLeft + this._squareSize * this._s;
    var cy = this._squareTop + this._squareSize * (1 - this._v);
    this._drawCircle(cx, cy, radius * 0.04, context);
    var dist = radius - wheelThickness * 0.5;
    cx = left + radius + Math.cos((this._h - 180) * Math.PI / 180) * dist;
    cy = top + radius + Math.sin((this._h - 180) * Math.PI / 180) * dist;
    this._drawCircle(cx, cy, wheelThickness * 0.35, context);
    context.restore();
  };
  ColorPicker2.prototype._updateValueFromPointer = function(x, y) {
    if (this._pointerStartedOnWheel) {
      var radius = Math.min(this._currentMeasure.width, this._currentMeasure.height) * 0.5;
      var centerX = radius + this._currentMeasure.left;
      var centerY = radius + this._currentMeasure.top;
      this._h = Math.atan2(y - centerY, x - centerX) * 180 / Math.PI + 180;
    } else if (this._pointerStartedOnSquare) {
      this._updateSquareProps();
      this._s = (x - this._squareLeft) / this._squareSize;
      this._v = 1 - (y - this._squareTop) / this._squareSize;
      this._s = Math.min(this._s, 1);
      this._s = Math.max(this._s, ColorPicker2._Epsilon);
      this._v = Math.min(this._v, 1);
      this._v = Math.max(this._v, ColorPicker2._Epsilon);
    }
    Color3.HSVtoRGBToRef(this._h, this._s, this._v, this._tmpColor);
    this.value = this._tmpColor;
  };
  ColorPicker2.prototype._isPointOnSquare = function(x, y) {
    this._updateSquareProps();
    var left = this._squareLeft;
    var top = this._squareTop;
    var size = this._squareSize;
    if (x >= left && x <= left + size && y >= top && y <= top + size) {
      return true;
    }
    return false;
  };
  ColorPicker2.prototype._isPointOnWheel = function(x, y) {
    var radius = Math.min(this._currentMeasure.width, this._currentMeasure.height) * 0.5;
    var centerX = radius + this._currentMeasure.left;
    var centerY = radius + this._currentMeasure.top;
    var wheelThickness = radius * 0.2;
    var innerRadius = radius - wheelThickness;
    var radiusSq = radius * radius;
    var innerRadiusSq = innerRadius * innerRadius;
    var dx = x - centerX;
    var dy = y - centerY;
    var distSq = dx * dx + dy * dy;
    if (distSq <= radiusSq && distSq >= innerRadiusSq) {
      return true;
    }
    return false;
  };
  ColorPicker2.prototype._onPointerDown = function(target, coordinates, pointerId, buttonIndex, pi) {
    if (!_super.prototype._onPointerDown.call(this, target, coordinates, pointerId, buttonIndex, pi)) {
      return false;
    }
    this._pointerIsDown = true;
    this._pointerStartedOnSquare = false;
    this._pointerStartedOnWheel = false;
    this._invertTransformMatrix.transformCoordinates(coordinates.x, coordinates.y, this._transformedPosition);
    var x = this._transformedPosition.x;
    var y = this._transformedPosition.y;
    if (this._isPointOnSquare(x, y)) {
      this._pointerStartedOnSquare = true;
    } else if (this._isPointOnWheel(x, y)) {
      this._pointerStartedOnWheel = true;
    }
    this._updateValueFromPointer(x, y);
    this._host._capturingControl[pointerId] = this;
    this._lastPointerDownID = pointerId;
    return true;
  };
  ColorPicker2.prototype._onPointerMove = function(target, coordinates, pointerId, pi) {
    if (pointerId != this._lastPointerDownID) {
      return;
    }
    this._invertTransformMatrix.transformCoordinates(coordinates.x, coordinates.y, this._transformedPosition);
    var x = this._transformedPosition.x;
    var y = this._transformedPosition.y;
    if (this._pointerIsDown) {
      this._updateValueFromPointer(x, y);
    }
    _super.prototype._onPointerMove.call(this, target, coordinates, pointerId, pi);
  };
  ColorPicker2.prototype._onPointerUp = function(target, coordinates, pointerId, buttonIndex, notifyClick, pi) {
    this._pointerIsDown = false;
    delete this._host._capturingControl[pointerId];
    _super.prototype._onPointerUp.call(this, target, coordinates, pointerId, buttonIndex, notifyClick, pi);
  };
  ColorPicker2.prototype._onCanvasBlur = function() {
    this._forcePointerUp();
    _super.prototype._onCanvasBlur.call(this);
  };
  ColorPicker2.ShowPickerDialogAsync = function(advancedTexture, options) {
    return new Promise(function(resolve, reject) {
      options.pickerWidth = options.pickerWidth || "640px";
      options.pickerHeight = options.pickerHeight || "400px";
      options.headerHeight = options.headerHeight || "35px";
      options.lastColor = options.lastColor || "#000000";
      options.swatchLimit = options.swatchLimit || 20;
      options.numSwatchesPerLine = options.numSwatchesPerLine || 10;
      var drawerMaxRows = options.swatchLimit / options.numSwatchesPerLine;
      var rawSwatchSize = parseFloat(options.pickerWidth) / options.numSwatchesPerLine;
      var gutterSize = Math.floor(rawSwatchSize * 0.25);
      var colGutters = gutterSize * (options.numSwatchesPerLine + 1);
      var swatchSize = Math.floor((parseFloat(options.pickerWidth) - colGutters) / options.numSwatchesPerLine);
      var drawerMaxSize = swatchSize * drawerMaxRows + gutterSize * (drawerMaxRows + 1);
      var containerSize = (parseInt(options.pickerHeight) + drawerMaxSize + Math.floor(swatchSize * 0.25)).toString() + "px";
      var buttonColor = "#c0c0c0";
      var buttonBackgroundColor = "#535353";
      var buttonBackgroundHoverColor = "#414141";
      var buttonBackgroundClickColor = "515151";
      var buttonDisabledColor = "#555555";
      var buttonDisabledBackgroundColor = "#454545";
      var currentSwatchesOutlineColor = "#404040";
      var luminanceLimitColor = Color3.FromHexString("#dddddd");
      var luminanceLimit = luminanceLimitColor.r + luminanceLimitColor.g + luminanceLimitColor.b;
      var iconColorDark = "#aaaaaa";
      var iconColorLight = "#ffffff";
      var closeIconColor;
      var buttonFontSize;
      var butEdit;
      var buttonWidth;
      var buttonHeight;
      var inputFieldLabels = ["R", "G", "B"];
      var inputTextBackgroundColor = "#454545";
      var inputTextColor = "#f0f0f0";
      var currentColor;
      var swatchNumber;
      var swatchDrawer;
      var editSwatchMode = false;
      var picker;
      var rValInt;
      var gValInt;
      var bValInt;
      var rValDec;
      var gValDec;
      var bValDec;
      var hexVal;
      var newSwatch;
      var lastVal;
      var activeField;
      function updateValues(value, inputField) {
        activeField = inputField;
        var pickedColor = value.toHexString();
        newSwatch.background = pickedColor;
        if (rValInt.name != activeField) {
          rValInt.text = Math.floor(value.r * 255).toString();
        }
        if (gValInt.name != activeField) {
          gValInt.text = Math.floor(value.g * 255).toString();
        }
        if (bValInt.name != activeField) {
          bValInt.text = Math.floor(value.b * 255).toString();
        }
        if (rValDec.name != activeField) {
          rValDec.text = value.r.toString();
        }
        if (gValDec.name != activeField) {
          gValDec.text = value.g.toString();
        }
        if (bValDec.name != activeField) {
          bValDec.text = value.b.toString();
        }
        if (hexVal.name != activeField) {
          var minusPound2 = pickedColor.split("#");
          hexVal.text = minusPound2[1];
        }
        if (picker.name != activeField) {
          picker.value = value;
        }
      }
      function updateInt(field, channel) {
        var newValue = field.text;
        var checkVal = /[^0-9]/g.test(newValue);
        if (checkVal) {
          field.text = lastVal;
          return;
        } else {
          if (newValue != "") {
            if (Math.floor(parseInt(newValue)) < 0) {
              newValue = "0";
            } else if (Math.floor(parseInt(newValue)) > 255) {
              newValue = "255";
            } else if (isNaN(parseInt(newValue))) {
              newValue = "0";
            }
          }
          if (activeField == field.name) {
            lastVal = newValue;
          }
        }
        if (newValue != "") {
          newValue = parseInt(newValue).toString();
          field.text = newValue;
          var newSwatchRGB = Color3.FromHexString(newSwatch.background);
          if (activeField == field.name) {
            if (channel == "r") {
              updateValues(new Color3(parseInt(newValue) / 255, newSwatchRGB.g, newSwatchRGB.b), field.name);
            } else if (channel == "g") {
              updateValues(new Color3(newSwatchRGB.r, parseInt(newValue) / 255, newSwatchRGB.b), field.name);
            } else {
              updateValues(new Color3(newSwatchRGB.r, newSwatchRGB.g, parseInt(newValue) / 255), field.name);
            }
          }
        }
      }
      function updateFloat(field, channel) {
        var newValue = field.text;
        var checkVal = /[^0-9\.]/g.test(newValue);
        if (checkVal) {
          field.text = lastVal;
          return;
        } else {
          if (newValue != "" && newValue != "." && parseFloat(newValue) != 0) {
            if (parseFloat(newValue) < 0) {
              newValue = "0.0";
            } else if (parseFloat(newValue) > 1) {
              newValue = "1.0";
            } else if (isNaN(parseFloat(newValue))) {
              newValue = "0.0";
            }
          }
          if (activeField == field.name) {
            lastVal = newValue;
          }
        }
        if (newValue != "" && newValue != "." && parseFloat(newValue) != 0) {
          newValue = parseFloat(newValue).toString();
          field.text = newValue;
        } else {
          newValue = "0.0";
        }
        var newSwatchRGB = Color3.FromHexString(newSwatch.background);
        if (activeField == field.name) {
          if (channel == "r") {
            updateValues(new Color3(parseFloat(newValue), newSwatchRGB.g, newSwatchRGB.b), field.name);
          } else if (channel == "g") {
            updateValues(new Color3(newSwatchRGB.r, parseFloat(newValue), newSwatchRGB.b), field.name);
          } else {
            updateValues(new Color3(newSwatchRGB.r, newSwatchRGB.g, parseFloat(newValue)), field.name);
          }
        }
      }
      function deleteSwatch(index) {
        if (options.savedColors) {
          options.savedColors.splice(index, 1);
        }
        if (options.savedColors && options.savedColors.length == 0) {
          setEditButtonVisibility(false);
          editSwatchMode = false;
        }
      }
      function createSwatch() {
        if (options.savedColors && options.savedColors[swatchNumber]) {
          if (editSwatchMode) {
            var icon = "b";
          } else {
            var icon = "";
          }
          var swatch = Button.CreateSimpleButton("Swatch_" + swatchNumber, icon);
          swatch.fontFamily = "BabylonJSglyphs";
          var swatchColor = Color3.FromHexString(options.savedColors[swatchNumber]);
          var swatchLuminence = swatchColor.r + swatchColor.g + swatchColor.b;
          if (swatchLuminence > luminanceLimit) {
            swatch.color = iconColorDark;
          } else {
            swatch.color = iconColorLight;
          }
          swatch.fontSize = Math.floor(swatchSize * 0.7);
          swatch.textBlock.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;
          swatch.height = swatch.width = swatchSize.toString() + "px";
          swatch.background = options.savedColors[swatchNumber];
          swatch.thickness = 2;
          var metadata_1 = swatchNumber;
          swatch.pointerDownAnimation = function() {
            swatch.thickness = 4;
          };
          swatch.pointerUpAnimation = function() {
            swatch.thickness = 3;
          };
          swatch.pointerEnterAnimation = function() {
            swatch.thickness = 3;
          };
          swatch.pointerOutAnimation = function() {
            swatch.thickness = 2;
          };
          swatch.onPointerClickObservable.add(function() {
            if (!editSwatchMode) {
              if (options.savedColors) {
                updateValues(Color3.FromHexString(options.savedColors[metadata_1]), swatch.name);
              }
            } else {
              deleteSwatch(metadata_1);
              updateSwatches("", butSave);
            }
          });
          return swatch;
        } else {
          return null;
        }
      }
      function editSwatches(mode) {
        if (mode !== void 0) {
          editSwatchMode = mode;
        }
        if (editSwatchMode) {
          for (var i2 = 0; i2 < swatchDrawer.children.length; i2++) {
            var thisButton = swatchDrawer.children[i2];
            thisButton.textBlock.text = "b";
          }
          if (butEdit !== void 0) {
            butEdit.textBlock.text = "Done";
          }
        } else {
          for (var i2 = 0; i2 < swatchDrawer.children.length; i2++) {
            var thisButton = swatchDrawer.children[i2];
            thisButton.textBlock.text = "";
          }
          if (butEdit !== void 0) {
            butEdit.textBlock.text = "Edit";
          }
        }
      }
      function updateSwatches(color, button) {
        if (options.savedColors) {
          if (color != "") {
            options.savedColors.push(color);
          }
          swatchNumber = 0;
          swatchDrawer.clearControls();
          var rowCount = Math.ceil(options.savedColors.length / options.numSwatchesPerLine);
          if (rowCount == 0) {
            var gutterCount2 = 0;
          } else {
            var gutterCount2 = rowCount + 1;
          }
          if (swatchDrawer.rowCount != rowCount + gutterCount2) {
            var currentRows = swatchDrawer.rowCount;
            for (var i2 = 0; i2 < currentRows; i2++) {
              swatchDrawer.removeRowDefinition(0);
            }
            for (var i2 = 0; i2 < rowCount + gutterCount2; i2++) {
              if (i2 % 2) {
                swatchDrawer.addRowDefinition(swatchSize, true);
              } else {
                swatchDrawer.addRowDefinition(gutterSize, true);
              }
            }
          }
          swatchDrawer.height = (swatchSize * rowCount + gutterCount2 * gutterSize).toString() + "px";
          for (var y = 1, thisRow = 1; y < rowCount + gutterCount2; y += 2, thisRow++) {
            if (options.savedColors.length > thisRow * options.numSwatchesPerLine) {
              var totalButtonsThisRow = options.numSwatchesPerLine;
            } else {
              var totalButtonsThisRow = options.savedColors.length - (thisRow - 1) * options.numSwatchesPerLine;
            }
            var buttonIterations = Math.min(Math.max(totalButtonsThisRow, 0), options.numSwatchesPerLine);
            for (var x = 0, w = 1; x < buttonIterations; x++) {
              if (x > options.numSwatchesPerLine) {
                continue;
              }
              var swatch = createSwatch();
              if (swatch != null) {
                swatchDrawer.addControl(swatch, y, w);
                w += 2;
                swatchNumber++;
              } else {
                continue;
              }
            }
          }
          if (options.savedColors.length >= options.swatchLimit) {
            disableButton(button, true);
          } else {
            disableButton(button, false);
          }
        }
      }
      function setEditButtonVisibility(enableButton) {
        if (enableButton) {
          butEdit = Button.CreateSimpleButton("butEdit", "Edit");
          butEdit.width = buttonWidth;
          butEdit.height = buttonHeight;
          butEdit.left = Math.floor(parseInt(buttonWidth) * 0.1).toString() + "px";
          butEdit.top = (parseFloat(butEdit.left) * -1).toString() + "px";
          butEdit.verticalAlignment = Control.VERTICAL_ALIGNMENT_BOTTOM;
          butEdit.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
          butEdit.thickness = 2;
          butEdit.color = buttonColor;
          butEdit.fontSize = buttonFontSize;
          butEdit.background = buttonBackgroundColor;
          butEdit.onPointerEnterObservable.add(function() {
            butEdit.background = buttonBackgroundHoverColor;
          });
          butEdit.onPointerOutObservable.add(function() {
            butEdit.background = buttonBackgroundColor;
          });
          butEdit.pointerDownAnimation = function() {
            butEdit.background = buttonBackgroundClickColor;
          };
          butEdit.pointerUpAnimation = function() {
            butEdit.background = buttonBackgroundHoverColor;
          };
          butEdit.onPointerClickObservable.add(function() {
            if (editSwatchMode) {
              editSwatchMode = false;
            } else {
              editSwatchMode = true;
            }
            editSwatches();
          });
          pickerGrid.addControl(butEdit, 1, 0);
        } else {
          pickerGrid.removeControl(butEdit);
        }
      }
      function disableButton(button, disabled) {
        if (disabled) {
          button.color = buttonDisabledColor;
          button.background = buttonDisabledBackgroundColor;
        } else {
          button.color = buttonColor;
          button.background = buttonBackgroundColor;
        }
      }
      function closePicker(color) {
        if (options.savedColors && options.savedColors.length > 0) {
          resolve({
            savedColors: options.savedColors,
            pickedColor: color
          });
        } else {
          resolve({
            pickedColor: color
          });
        }
        advancedTexture.removeControl(dialogContainer);
      }
      var dialogContainer = new Grid();
      dialogContainer.name = "Dialog Container";
      dialogContainer.width = options.pickerWidth;
      if (options.savedColors) {
        dialogContainer.height = containerSize;
        var topRow = parseInt(options.pickerHeight) / parseInt(containerSize);
        dialogContainer.addRowDefinition(topRow, false);
        dialogContainer.addRowDefinition(1 - topRow, false);
      } else {
        dialogContainer.height = options.pickerHeight;
        dialogContainer.addRowDefinition(1, false);
      }
      advancedTexture.addControl(dialogContainer);
      if (options.savedColors) {
        swatchDrawer = new Grid();
        swatchDrawer.name = "Swatch Drawer";
        swatchDrawer.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
        swatchDrawer.background = buttonBackgroundColor;
        swatchDrawer.width = options.pickerWidth;
        var initialRows = options.savedColors.length / options.numSwatchesPerLine;
        if (initialRows == 0) {
          var gutterCount = 0;
        } else {
          var gutterCount = initialRows + 1;
        }
        swatchDrawer.height = (swatchSize * initialRows + gutterCount * gutterSize).toString() + "px";
        swatchDrawer.top = Math.floor(swatchSize * 0.25).toString() + "px";
        for (var i = 0; i < Math.ceil(options.savedColors.length / options.numSwatchesPerLine) * 2 + 1; i++) {
          if (i % 2 != 0) {
            swatchDrawer.addRowDefinition(swatchSize, true);
          } else {
            swatchDrawer.addRowDefinition(gutterSize, true);
          }
        }
        for (var i = 0; i < options.numSwatchesPerLine * 2 + 1; i++) {
          if (i % 2 != 0) {
            swatchDrawer.addColumnDefinition(swatchSize, true);
          } else {
            swatchDrawer.addColumnDefinition(gutterSize, true);
          }
        }
        dialogContainer.addControl(swatchDrawer, 1, 0);
      }
      var pickerPanel = new Grid();
      pickerPanel.name = "Picker Panel";
      pickerPanel.height = options.pickerHeight;
      var panelHead = parseInt(options.headerHeight) / parseInt(options.pickerHeight);
      var pickerPanelRows = [panelHead, 1 - panelHead];
      pickerPanel.addRowDefinition(pickerPanelRows[0], false);
      pickerPanel.addRowDefinition(pickerPanelRows[1], false);
      dialogContainer.addControl(pickerPanel, 0, 0);
      var header = new Rectangle();
      header.name = "Dialogue Header Bar";
      header.background = "#cccccc";
      header.thickness = 0;
      pickerPanel.addControl(header, 0, 0);
      var closeButton = Button.CreateSimpleButton("closeButton", "a");
      closeButton.fontFamily = "BabylonJSglyphs";
      var headerColor3 = Color3.FromHexString(header.background);
      closeIconColor = new Color3(1 - headerColor3.r, 1 - headerColor3.g, 1 - headerColor3.b);
      closeButton.color = closeIconColor.toHexString();
      closeButton.fontSize = Math.floor(parseInt(options.headerHeight) * 0.6);
      closeButton.textBlock.textVerticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;
      closeButton.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_RIGHT;
      closeButton.height = closeButton.width = options.headerHeight;
      closeButton.background = header.background;
      closeButton.thickness = 0;
      closeButton.pointerDownAnimation = function() {
      };
      closeButton.pointerUpAnimation = function() {
        closeButton.background = header.background;
      };
      closeButton.pointerEnterAnimation = function() {
        closeButton.color = header.background;
        closeButton.background = "red";
      };
      closeButton.pointerOutAnimation = function() {
        closeButton.color = closeIconColor.toHexString();
        closeButton.background = header.background;
      };
      closeButton.onPointerClickObservable.add(function() {
        closePicker(currentSwatch.background);
      });
      pickerPanel.addControl(closeButton, 0, 0);
      var dialogBody = new Grid();
      dialogBody.name = "Dialogue Body";
      dialogBody.background = buttonBackgroundColor;
      var dialogBodyCols = [0.4375, 0.5625];
      dialogBody.addRowDefinition(1, false);
      dialogBody.addColumnDefinition(dialogBodyCols[0], false);
      dialogBody.addColumnDefinition(dialogBodyCols[1], false);
      pickerPanel.addControl(dialogBody, 1, 0);
      var pickerGrid = new Grid();
      pickerGrid.name = "Picker Grid";
      pickerGrid.addRowDefinition(0.85, false);
      pickerGrid.addRowDefinition(0.15, false);
      dialogBody.addControl(pickerGrid, 0, 0);
      picker = new ColorPicker2();
      picker.name = "GUI Color Picker";
      if (options.pickerHeight < options.pickerWidth) {
        picker.width = 0.89;
      } else {
        picker.height = 0.89;
      }
      picker.value = Color3.FromHexString(options.lastColor);
      picker.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
      picker.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;
      picker.onPointerDownObservable.add(function() {
        activeField = picker.name;
        lastVal = "";
        editSwatches(false);
      });
      picker.onValueChangedObservable.add(function(value) {
        if (activeField == picker.name) {
          updateValues(value, picker.name);
        }
      });
      pickerGrid.addControl(picker, 0, 0);
      var pickerBodyRight = new Grid();
      pickerBodyRight.name = "Dialogue Right Half";
      pickerBodyRight.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
      var pickerBodyRightRows = [0.514, 0.486];
      pickerBodyRight.addRowDefinition(pickerBodyRightRows[0], false);
      pickerBodyRight.addRowDefinition(pickerBodyRightRows[1], false);
      dialogBody.addControl(pickerBodyRight, 1, 1);
      var pickerSwatchesButtons = new Grid();
      pickerSwatchesButtons.name = "Swatches and Buttons";
      var pickerButtonsCol = [0.417, 0.583];
      pickerSwatchesButtons.addRowDefinition(1, false);
      pickerSwatchesButtons.addColumnDefinition(pickerButtonsCol[0], false);
      pickerSwatchesButtons.addColumnDefinition(pickerButtonsCol[1], false);
      pickerBodyRight.addControl(pickerSwatchesButtons, 0, 0);
      var pickerSwatches = new Grid();
      pickerSwatches.name = "New and Current Swatches";
      var pickeSwatchesRows = [0.04, 0.16, 0.64, 0.16];
      pickerSwatches.addRowDefinition(pickeSwatchesRows[0], false);
      pickerSwatches.addRowDefinition(pickeSwatchesRows[1], false);
      pickerSwatches.addRowDefinition(pickeSwatchesRows[2], false);
      pickerSwatches.addRowDefinition(pickeSwatchesRows[3], false);
      pickerSwatchesButtons.addControl(pickerSwatches, 0, 0);
      var activeSwatches = new Grid();
      activeSwatches.name = "Active Swatches";
      activeSwatches.width = 0.67;
      activeSwatches.addRowDefinition(0.5, false);
      activeSwatches.addRowDefinition(0.5, false);
      pickerSwatches.addControl(activeSwatches, 2, 0);
      var labelWidth = Math.floor(parseInt(options.pickerWidth) * dialogBodyCols[1] * pickerButtonsCol[0] * 0.11);
      var labelHeight = Math.floor(parseInt(options.pickerHeight) * pickerPanelRows[1] * pickerBodyRightRows[0] * pickeSwatchesRows[1] * 0.5);
      if (options.pickerWidth > options.pickerHeight) {
        var labelTextSize = labelHeight;
      } else {
        var labelTextSize = labelWidth;
      }
      var newText = new TextBlock();
      newText.text = "new";
      newText.name = "New Color Label";
      newText.color = buttonColor;
      newText.fontSize = labelTextSize;
      pickerSwatches.addControl(newText, 1, 0);
      newSwatch = new Rectangle();
      newSwatch.name = "New Color Swatch";
      newSwatch.background = options.lastColor;
      newSwatch.thickness = 0;
      activeSwatches.addControl(newSwatch, 0, 0);
      var currentSwatch = Button.CreateSimpleButton("currentSwatch", "");
      currentSwatch.background = options.lastColor;
      currentSwatch.thickness = 0;
      currentSwatch.onPointerClickObservable.add(function() {
        var revertColor = Color3.FromHexString(currentSwatch.background);
        updateValues(revertColor, currentSwatch.name);
        editSwatches(false);
      });
      currentSwatch.pointerDownAnimation = function() {
      };
      currentSwatch.pointerUpAnimation = function() {
      };
      currentSwatch.pointerEnterAnimation = function() {
      };
      currentSwatch.pointerOutAnimation = function() {
      };
      activeSwatches.addControl(currentSwatch, 1, 0);
      var swatchOutline = new Rectangle();
      swatchOutline.name = "Swatch Outline";
      swatchOutline.width = 0.67;
      swatchOutline.thickness = 2;
      swatchOutline.color = currentSwatchesOutlineColor;
      swatchOutline.isHitTestVisible = false;
      pickerSwatches.addControl(swatchOutline, 2, 0);
      var currentText = new TextBlock();
      currentText.name = "Current Color Label";
      currentText.text = "current";
      currentText.color = buttonColor;
      currentText.fontSize = labelTextSize;
      pickerSwatches.addControl(currentText, 3, 0);
      var buttonGrid = new Grid();
      buttonGrid.name = "Button Grid";
      buttonGrid.height = 0.8;
      var buttonGridRows = 1 / 3;
      buttonGrid.addRowDefinition(buttonGridRows, false);
      buttonGrid.addRowDefinition(buttonGridRows, false);
      buttonGrid.addRowDefinition(buttonGridRows, false);
      pickerSwatchesButtons.addControl(buttonGrid, 0, 1);
      buttonWidth = Math.floor(parseInt(options.pickerWidth) * dialogBodyCols[1] * pickerButtonsCol[1] * 0.67).toString() + "px";
      buttonHeight = Math.floor(parseInt(options.pickerHeight) * pickerPanelRows[1] * pickerBodyRightRows[0] * (parseFloat(buttonGrid.height.toString()) / 100) * buttonGridRows * 0.7).toString() + "px";
      if (parseFloat(buttonWidth) > parseFloat(buttonHeight)) {
        buttonFontSize = Math.floor(parseFloat(buttonHeight) * 0.45);
      } else {
        buttonFontSize = Math.floor(parseFloat(buttonWidth) * 0.11);
      }
      var butOK = Button.CreateSimpleButton("butOK", "OK");
      butOK.width = buttonWidth;
      butOK.height = buttonHeight;
      butOK.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;
      butOK.thickness = 2;
      butOK.color = buttonColor;
      butOK.fontSize = buttonFontSize;
      butOK.background = buttonBackgroundColor;
      butOK.onPointerEnterObservable.add(function() {
        butOK.background = buttonBackgroundHoverColor;
      });
      butOK.onPointerOutObservable.add(function() {
        butOK.background = buttonBackgroundColor;
      });
      butOK.pointerDownAnimation = function() {
        butOK.background = buttonBackgroundClickColor;
      };
      butOK.pointerUpAnimation = function() {
        butOK.background = buttonBackgroundHoverColor;
      };
      butOK.onPointerClickObservable.add(function() {
        editSwatches(false);
        closePicker(newSwatch.background);
      });
      buttonGrid.addControl(butOK, 0, 0);
      var butCancel = Button.CreateSimpleButton("butCancel", "Cancel");
      butCancel.width = buttonWidth;
      butCancel.height = buttonHeight;
      butCancel.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;
      butCancel.thickness = 2;
      butCancel.color = buttonColor;
      butCancel.fontSize = buttonFontSize;
      butCancel.background = buttonBackgroundColor;
      butCancel.onPointerEnterObservable.add(function() {
        butCancel.background = buttonBackgroundHoverColor;
      });
      butCancel.onPointerOutObservable.add(function() {
        butCancel.background = buttonBackgroundColor;
      });
      butCancel.pointerDownAnimation = function() {
        butCancel.background = buttonBackgroundClickColor;
      };
      butCancel.pointerUpAnimation = function() {
        butCancel.background = buttonBackgroundHoverColor;
      };
      butCancel.onPointerClickObservable.add(function() {
        editSwatches(false);
        closePicker(currentSwatch.background);
      });
      buttonGrid.addControl(butCancel, 1, 0);
      if (options.savedColors) {
        var butSave = Button.CreateSimpleButton("butSave", "Save");
        butSave.width = buttonWidth;
        butSave.height = buttonHeight;
        butSave.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;
        butSave.thickness = 2;
        butSave.fontSize = buttonFontSize;
        if (options.savedColors.length < options.swatchLimit) {
          butSave.color = buttonColor;
          butSave.background = buttonBackgroundColor;
        } else {
          disableButton(butSave, true);
        }
        butSave.onPointerEnterObservable.add(function() {
          if (options.savedColors) {
            if (options.savedColors.length < options.swatchLimit) {
              butSave.background = buttonBackgroundHoverColor;
            }
          }
        });
        butSave.onPointerOutObservable.add(function() {
          if (options.savedColors) {
            if (options.savedColors.length < options.swatchLimit) {
              butSave.background = buttonBackgroundColor;
            }
          }
        });
        butSave.pointerDownAnimation = function() {
          if (options.savedColors) {
            if (options.savedColors.length < options.swatchLimit) {
              butSave.background = buttonBackgroundClickColor;
            }
          }
        };
        butSave.pointerUpAnimation = function() {
          if (options.savedColors) {
            if (options.savedColors.length < options.swatchLimit) {
              butSave.background = buttonBackgroundHoverColor;
            }
          }
        };
        butSave.onPointerClickObservable.add(function() {
          if (options.savedColors) {
            if (options.savedColors.length == 0) {
              setEditButtonVisibility(true);
            }
            if (options.savedColors.length < options.swatchLimit) {
              updateSwatches(newSwatch.background, butSave);
            }
            editSwatches(false);
          }
        });
        if (options.savedColors.length > 0) {
          setEditButtonVisibility(true);
        }
        buttonGrid.addControl(butSave, 2, 0);
      }
      var pickerColorValues = new Grid();
      pickerColorValues.name = "Dialog Lower Right";
      pickerColorValues.addRowDefinition(0.02, false);
      pickerColorValues.addRowDefinition(0.63, false);
      pickerColorValues.addRowDefinition(0.21, false);
      pickerColorValues.addRowDefinition(0.14, false);
      pickerBodyRight.addControl(pickerColorValues, 1, 0);
      currentColor = Color3.FromHexString(options.lastColor);
      var rgbValuesQuadrant = new Grid();
      rgbValuesQuadrant.name = "RGB Values";
      rgbValuesQuadrant.width = 0.82;
      rgbValuesQuadrant.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;
      rgbValuesQuadrant.addRowDefinition(1 / 3, false);
      rgbValuesQuadrant.addRowDefinition(1 / 3, false);
      rgbValuesQuadrant.addRowDefinition(1 / 3, false);
      rgbValuesQuadrant.addColumnDefinition(0.1, false);
      rgbValuesQuadrant.addColumnDefinition(0.2, false);
      rgbValuesQuadrant.addColumnDefinition(0.7, false);
      pickerColorValues.addControl(rgbValuesQuadrant, 1, 0);
      for (var i = 0; i < inputFieldLabels.length; i++) {
        var labelText = new TextBlock();
        labelText.text = inputFieldLabels[i];
        labelText.color = buttonColor;
        labelText.fontSize = buttonFontSize;
        rgbValuesQuadrant.addControl(labelText, i, 0);
      }
      rValInt = new InputText();
      rValInt.width = 0.83;
      rValInt.height = 0.72;
      rValInt.name = "rIntField";
      rValInt.fontSize = buttonFontSize;
      rValInt.text = (currentColor.r * 255).toString();
      rValInt.color = inputTextColor;
      rValInt.background = inputTextBackgroundColor;
      rValInt.onFocusObservable.add(function() {
        activeField = rValInt.name;
        lastVal = rValInt.text;
        editSwatches(false);
      });
      rValInt.onBlurObservable.add(function() {
        if (rValInt.text == "") {
          rValInt.text = "0";
        }
        updateInt(rValInt, "r");
        if (activeField == rValInt.name) {
          activeField = "";
        }
      });
      rValInt.onTextChangedObservable.add(function() {
        if (activeField == rValInt.name) {
          updateInt(rValInt, "r");
        }
      });
      rgbValuesQuadrant.addControl(rValInt, 0, 1);
      gValInt = new InputText();
      gValInt.width = 0.83;
      gValInt.height = 0.72;
      gValInt.name = "gIntField";
      gValInt.fontSize = buttonFontSize;
      gValInt.text = (currentColor.g * 255).toString();
      gValInt.color = inputTextColor;
      gValInt.background = inputTextBackgroundColor;
      gValInt.onFocusObservable.add(function() {
        activeField = gValInt.name;
        lastVal = gValInt.text;
        editSwatches(false);
      });
      gValInt.onBlurObservable.add(function() {
        if (gValInt.text == "") {
          gValInt.text = "0";
        }
        updateInt(gValInt, "g");
        if (activeField == gValInt.name) {
          activeField = "";
        }
      });
      gValInt.onTextChangedObservable.add(function() {
        if (activeField == gValInt.name) {
          updateInt(gValInt, "g");
        }
      });
      rgbValuesQuadrant.addControl(gValInt, 1, 1);
      bValInt = new InputText();
      bValInt.width = 0.83;
      bValInt.height = 0.72;
      bValInt.name = "bIntField";
      bValInt.fontSize = buttonFontSize;
      bValInt.text = (currentColor.b * 255).toString();
      bValInt.color = inputTextColor;
      bValInt.background = inputTextBackgroundColor;
      bValInt.onFocusObservable.add(function() {
        activeField = bValInt.name;
        lastVal = bValInt.text;
        editSwatches(false);
      });
      bValInt.onBlurObservable.add(function() {
        if (bValInt.text == "") {
          bValInt.text = "0";
        }
        updateInt(bValInt, "b");
        if (activeField == bValInt.name) {
          activeField = "";
        }
      });
      bValInt.onTextChangedObservable.add(function() {
        if (activeField == bValInt.name) {
          updateInt(bValInt, "b");
        }
      });
      rgbValuesQuadrant.addControl(bValInt, 2, 1);
      rValDec = new InputText();
      rValDec.width = 0.95;
      rValDec.height = 0.72;
      rValDec.name = "rDecField";
      rValDec.fontSize = buttonFontSize;
      rValDec.text = currentColor.r.toString();
      rValDec.color = inputTextColor;
      rValDec.background = inputTextBackgroundColor;
      rValDec.onFocusObservable.add(function() {
        activeField = rValDec.name;
        lastVal = rValDec.text;
        editSwatches(false);
      });
      rValDec.onBlurObservable.add(function() {
        if (parseFloat(rValDec.text) == 0 || rValDec.text == "") {
          rValDec.text = "0";
          updateFloat(rValDec, "r");
        }
        if (activeField == rValDec.name) {
          activeField = "";
        }
      });
      rValDec.onTextChangedObservable.add(function() {
        if (activeField == rValDec.name) {
          updateFloat(rValDec, "r");
        }
      });
      rgbValuesQuadrant.addControl(rValDec, 0, 2);
      gValDec = new InputText();
      gValDec.width = 0.95;
      gValDec.height = 0.72;
      gValDec.name = "gDecField";
      gValDec.fontSize = buttonFontSize;
      gValDec.text = currentColor.g.toString();
      gValDec.color = inputTextColor;
      gValDec.background = inputTextBackgroundColor;
      gValDec.onFocusObservable.add(function() {
        activeField = gValDec.name;
        lastVal = gValDec.text;
        editSwatches(false);
      });
      gValDec.onBlurObservable.add(function() {
        if (parseFloat(gValDec.text) == 0 || gValDec.text == "") {
          gValDec.text = "0";
          updateFloat(gValDec, "g");
        }
        if (activeField == gValDec.name) {
          activeField = "";
        }
      });
      gValDec.onTextChangedObservable.add(function() {
        if (activeField == gValDec.name) {
          updateFloat(gValDec, "g");
        }
      });
      rgbValuesQuadrant.addControl(gValDec, 1, 2);
      bValDec = new InputText();
      bValDec.width = 0.95;
      bValDec.height = 0.72;
      bValDec.name = "bDecField";
      bValDec.fontSize = buttonFontSize;
      bValDec.text = currentColor.b.toString();
      bValDec.color = inputTextColor;
      bValDec.background = inputTextBackgroundColor;
      bValDec.onFocusObservable.add(function() {
        activeField = bValDec.name;
        lastVal = bValDec.text;
        editSwatches(false);
      });
      bValDec.onBlurObservable.add(function() {
        if (parseFloat(bValDec.text) == 0 || bValDec.text == "") {
          bValDec.text = "0";
          updateFloat(bValDec, "b");
        }
        if (activeField == bValDec.name) {
          activeField = "";
        }
      });
      bValDec.onTextChangedObservable.add(function() {
        if (activeField == bValDec.name) {
          updateFloat(bValDec, "b");
        }
      });
      rgbValuesQuadrant.addControl(bValDec, 2, 2);
      var hexValueQuadrant = new Grid();
      hexValueQuadrant.name = "Hex Value";
      hexValueQuadrant.width = 0.82;
      hexValueQuadrant.addRowDefinition(1, false);
      hexValueQuadrant.addColumnDefinition(0.1, false);
      hexValueQuadrant.addColumnDefinition(0.9, false);
      pickerColorValues.addControl(hexValueQuadrant, 2, 0);
      var labelText = new TextBlock();
      labelText.text = "#";
      labelText.color = buttonColor;
      labelText.fontSize = buttonFontSize;
      hexValueQuadrant.addControl(labelText, 0, 0);
      hexVal = new InputText();
      hexVal.width = 0.96;
      hexVal.height = 0.72;
      hexVal.name = "hexField";
      hexVal.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
      hexVal.fontSize = buttonFontSize;
      var minusPound = options.lastColor.split("#");
      hexVal.text = minusPound[1];
      hexVal.color = inputTextColor;
      hexVal.background = inputTextBackgroundColor;
      hexVal.onFocusObservable.add(function() {
        activeField = hexVal.name;
        lastVal = hexVal.text;
        editSwatches(false);
      });
      hexVal.onBlurObservable.add(function() {
        if (hexVal.text.length == 3) {
          var val = hexVal.text.split("");
          hexVal.text = val[0] + val[0] + val[1] + val[1] + val[2] + val[2];
        }
        if (hexVal.text == "") {
          hexVal.text = "000000";
          updateValues(Color3.FromHexString(hexVal.text), "b");
        }
        if (activeField == hexVal.name) {
          activeField = "";
        }
      });
      hexVal.onTextChangedObservable.add(function() {
        var newHexValue = hexVal.text;
        var checkHex = /[^0-9A-F]/i.test(newHexValue);
        if ((hexVal.text.length > 6 || checkHex) && activeField == hexVal.name) {
          hexVal.text = lastVal;
        } else {
          if (hexVal.text.length < 6) {
            var leadingZero = 6 - hexVal.text.length;
            for (var i2 = 0; i2 < leadingZero; i2++) {
              newHexValue = "0" + newHexValue;
            }
          }
          if (hexVal.text.length == 3) {
            var val = hexVal.text.split("");
            newHexValue = val[0] + val[0] + val[1] + val[1] + val[2] + val[2];
          }
          newHexValue = "#" + newHexValue;
          if (activeField == hexVal.name) {
            lastVal = hexVal.text;
            updateValues(Color3.FromHexString(newHexValue), hexVal.name);
          }
        }
      });
      hexValueQuadrant.addControl(hexVal, 0, 1);
      if (options.savedColors && options.savedColors.length > 0) {
        updateSwatches("", butSave);
      }
    });
  };
  ColorPicker2._Epsilon = 1e-6;
  return ColorPicker2;
}(Control);
_TypeStore.RegisteredTypes["BABYLON.GUI.ColorPicker"] = ColorPicker;

// node_modules/@babylonjs/gui/2D/controls/ellipse.js
var Ellipse = function(_super) {
  __extends(Ellipse2, _super);
  function Ellipse2(name4) {
    var _this = _super.call(this, name4) || this;
    _this.name = name4;
    _this._thickness = 1;
    return _this;
  }
  Object.defineProperty(Ellipse2.prototype, "thickness", {
    get: function() {
      return this._thickness;
    },
    set: function(value) {
      if (this._thickness === value) {
        return;
      }
      this._thickness = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Ellipse2.prototype._getTypeName = function() {
    return "Ellipse";
  };
  Ellipse2.prototype._localDraw = function(context) {
    context.save();
    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {
      context.shadowColor = this.shadowColor;
      context.shadowBlur = this.shadowBlur;
      context.shadowOffsetX = this.shadowOffsetX;
      context.shadowOffsetY = this.shadowOffsetY;
    }
    Control.drawEllipse(this._currentMeasure.left + this._currentMeasure.width / 2, this._currentMeasure.top + this._currentMeasure.height / 2, this._currentMeasure.width / 2 - this._thickness / 2, this._currentMeasure.height / 2 - this._thickness / 2, context);
    if (this._background) {
      context.fillStyle = this._background;
      context.fill();
    }
    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {
      context.shadowBlur = 0;
      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
    }
    if (this._thickness) {
      if (this.color) {
        context.strokeStyle = this.color;
      }
      context.lineWidth = this._thickness;
      context.stroke();
    }
    context.restore();
  };
  Ellipse2.prototype._additionalProcessing = function(parentMeasure, context) {
    _super.prototype._additionalProcessing.call(this, parentMeasure, context);
    this._measureForChildren.width -= 2 * this._thickness;
    this._measureForChildren.height -= 2 * this._thickness;
    this._measureForChildren.left += this._thickness;
    this._measureForChildren.top += this._thickness;
  };
  Ellipse2.prototype._clipForChildren = function(context) {
    Control.drawEllipse(this._currentMeasure.left + this._currentMeasure.width / 2, this._currentMeasure.top + this._currentMeasure.height / 2, this._currentMeasure.width / 2, this._currentMeasure.height / 2, context);
    context.clip();
  };
  return Ellipse2;
}(Container);
_TypeStore.RegisteredTypes["BABYLON.GUI.Ellipse"] = Ellipse;

// node_modules/@babylonjs/gui/2D/controls/inputPassword.js
var InputPassword = function(_super) {
  __extends(InputPassword2, _super);
  function InputPassword2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  InputPassword2.prototype._beforeRenderText = function(textWrapper) {
    var pwdTextWrapper = new TextWrapper();
    var txt = "";
    for (var i = 0; i < textWrapper.length; i++) {
      txt += "\u2022";
    }
    pwdTextWrapper.text = txt;
    return pwdTextWrapper;
  };
  return InputPassword2;
}(InputText);
_TypeStore.RegisteredTypes["BABYLON.GUI.InputPassword"] = InputPassword;

// node_modules/@babylonjs/gui/2D/controls/line.js
var Line = function(_super) {
  __extends(Line2, _super);
  function Line2(name4) {
    var _this = _super.call(this, name4) || this;
    _this.name = name4;
    _this._lineWidth = 1;
    _this._x1 = new ValueAndUnit(0);
    _this._y1 = new ValueAndUnit(0);
    _this._x2 = new ValueAndUnit(0);
    _this._y2 = new ValueAndUnit(0);
    _this._dash = new Array();
    _this._automaticSize = true;
    _this.isHitTestVisible = false;
    _this._horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    _this._verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
    return _this;
  }
  Object.defineProperty(Line2.prototype, "dash", {
    get: function() {
      return this._dash;
    },
    set: function(value) {
      if (this._dash === value) {
        return;
      }
      this._dash = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Line2.prototype, "connectedControl", {
    get: function() {
      return this._connectedControl;
    },
    set: function(value) {
      var _this = this;
      if (this._connectedControl === value) {
        return;
      }
      if (this._connectedControlDirtyObserver && this._connectedControl) {
        this._connectedControl.onDirtyObservable.remove(this._connectedControlDirtyObserver);
        this._connectedControlDirtyObserver = null;
      }
      if (value) {
        this._connectedControlDirtyObserver = value.onDirtyObservable.add(function() {
          return _this._markAsDirty();
        });
      }
      this._connectedControl = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Line2.prototype, "x1", {
    get: function() {
      return this._x1.toString(this._host);
    },
    set: function(value) {
      if (this._x1.toString(this._host) === value) {
        return;
      }
      if (this._x1.fromString(value)) {
        this._markAsDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Line2.prototype, "y1", {
    get: function() {
      return this._y1.toString(this._host);
    },
    set: function(value) {
      if (this._y1.toString(this._host) === value) {
        return;
      }
      if (this._y1.fromString(value)) {
        this._markAsDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Line2.prototype, "x2", {
    get: function() {
      return this._x2.toString(this._host);
    },
    set: function(value) {
      if (this._x2.toString(this._host) === value) {
        return;
      }
      if (this._x2.fromString(value)) {
        this._markAsDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Line2.prototype, "y2", {
    get: function() {
      return this._y2.toString(this._host);
    },
    set: function(value) {
      if (this._y2.toString(this._host) === value) {
        return;
      }
      if (this._y2.fromString(value)) {
        this._markAsDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Line2.prototype, "lineWidth", {
    get: function() {
      return this._lineWidth;
    },
    set: function(value) {
      if (this._lineWidth === value) {
        return;
      }
      this._lineWidth = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Line2.prototype, "horizontalAlignment", {
    set: function(value) {
      return;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Line2.prototype, "verticalAlignment", {
    set: function(value) {
      return;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Line2.prototype, "_effectiveX2", {
    get: function() {
      return (this._connectedControl ? this._connectedControl.centerX : 0) + this._x2.getValue(this._host);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Line2.prototype, "_effectiveY2", {
    get: function() {
      return (this._connectedControl ? this._connectedControl.centerY : 0) + this._y2.getValue(this._host);
    },
    enumerable: false,
    configurable: true
  });
  Line2.prototype._getTypeName = function() {
    return "Line";
  };
  Line2.prototype._draw = function(context) {
    context.save();
    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {
      context.shadowColor = this.shadowColor;
      context.shadowBlur = this.shadowBlur;
      context.shadowOffsetX = this.shadowOffsetX;
      context.shadowOffsetY = this.shadowOffsetY;
    }
    this._applyStates(context);
    context.strokeStyle = this.color;
    context.lineWidth = this._lineWidth;
    context.setLineDash(this._dash);
    context.beginPath();
    context.moveTo(this._cachedParentMeasure.left + this._x1.getValue(this._host), this._cachedParentMeasure.top + this._y1.getValue(this._host));
    context.lineTo(this._cachedParentMeasure.left + this._effectiveX2, this._cachedParentMeasure.top + this._effectiveY2);
    context.stroke();
    context.restore();
  };
  Line2.prototype._measure = function() {
    this._currentMeasure.width = Math.abs(this._x1.getValue(this._host) - this._effectiveX2) + this._lineWidth;
    this._currentMeasure.height = Math.abs(this._y1.getValue(this._host) - this._effectiveY2) + this._lineWidth;
  };
  Line2.prototype._computeAlignment = function(parentMeasure, context) {
    this._currentMeasure.left = parentMeasure.left + Math.min(this._x1.getValue(this._host), this._effectiveX2) - this._lineWidth / 2;
    this._currentMeasure.top = parentMeasure.top + Math.min(this._y1.getValue(this._host), this._effectiveY2) - this._lineWidth / 2;
  };
  Line2.prototype.moveToVector3 = function(position, scene, end) {
    if (end === void 0) {
      end = false;
    }
    if (!this._host || this.parent !== this._host._rootContainer) {
      Tools.Error("Cannot move a control to a vector3 if the control is not at root level");
      return;
    }
    var globalViewport = this._host._getGlobalViewport(scene);
    var projectedPosition = Vector3.Project(position, Matrix.Identity(), scene.getTransformMatrix(), globalViewport);
    this._moveToProjectedPosition(projectedPosition, end);
    if (projectedPosition.z < 0 || projectedPosition.z > 1) {
      this.notRenderable = true;
      return;
    }
    this.notRenderable = false;
  };
  Line2.prototype._moveToProjectedPosition = function(projectedPosition, end) {
    if (end === void 0) {
      end = false;
    }
    var x = projectedPosition.x + this._linkOffsetX.getValue(this._host) + "px";
    var y = projectedPosition.y + this._linkOffsetY.getValue(this._host) + "px";
    if (end) {
      this.x2 = x;
      this.y2 = y;
      this._x2.ignoreAdaptiveScaling = true;
      this._y2.ignoreAdaptiveScaling = true;
    } else {
      this.x1 = x;
      this.y1 = y;
      this._x1.ignoreAdaptiveScaling = true;
      this._y1.ignoreAdaptiveScaling = true;
    }
  };
  return Line2;
}(Control);
_TypeStore.RegisteredTypes["BABYLON.GUI.Line"] = Line;

// node_modules/@babylonjs/gui/2D/multiLinePoint.js
var MultiLinePoint = function() {
  function MultiLinePoint2(multiLine) {
    this._multiLine = multiLine;
    this._x = new ValueAndUnit(0);
    this._y = new ValueAndUnit(0);
    this._point = new Vector3(0, 0, 0);
  }
  Object.defineProperty(MultiLinePoint2.prototype, "x", {
    get: function() {
      return this._x.toString(this._multiLine._host);
    },
    set: function(value) {
      if (this._x.toString(this._multiLine._host) === value) {
        return;
      }
      if (this._x.fromString(value)) {
        this._multiLine._markAsDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MultiLinePoint2.prototype, "y", {
    get: function() {
      return this._y.toString(this._multiLine._host);
    },
    set: function(value) {
      if (this._y.toString(this._multiLine._host) === value) {
        return;
      }
      if (this._y.fromString(value)) {
        this._multiLine._markAsDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MultiLinePoint2.prototype, "control", {
    get: function() {
      return this._control;
    },
    set: function(value) {
      if (this._control === value) {
        return;
      }
      if (this._control && this._controlObserver) {
        this._control.onDirtyObservable.remove(this._controlObserver);
        this._controlObserver = null;
      }
      this._control = value;
      if (this._control) {
        this._controlObserver = this._control.onDirtyObservable.add(this._multiLine.onPointUpdate);
      }
      this._multiLine._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MultiLinePoint2.prototype, "mesh", {
    get: function() {
      return this._mesh;
    },
    set: function(value) {
      if (this._mesh === value) {
        return;
      }
      if (this._mesh && this._meshObserver) {
        this._mesh.getScene().onAfterCameraRenderObservable.remove(this._meshObserver);
      }
      this._mesh = value;
      if (this._mesh) {
        this._meshObserver = this._mesh.getScene().onAfterCameraRenderObservable.add(this._multiLine.onPointUpdate);
      }
      this._multiLine._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  MultiLinePoint2.prototype.resetLinks = function() {
    this.control = null;
    this.mesh = null;
  };
  MultiLinePoint2.prototype.translate = function() {
    this._point = this._translatePoint();
    return this._point;
  };
  MultiLinePoint2.prototype._translatePoint = function() {
    if (this._mesh != null) {
      return this._multiLine._host.getProjectedPositionWithZ(this._mesh.getBoundingInfo().boundingSphere.center, this._mesh.getWorldMatrix());
    } else if (this._control != null) {
      return new Vector3(this._control.centerX, this._control.centerY, 1 - Epsilon);
    } else {
      var host = this._multiLine._host;
      var xValue = this._x.getValueInPixel(host, Number(host._canvas.width));
      var yValue = this._y.getValueInPixel(host, Number(host._canvas.height));
      return new Vector3(xValue, yValue, 1 - Epsilon);
    }
  };
  MultiLinePoint2.prototype.dispose = function() {
    this.resetLinks();
  };
  return MultiLinePoint2;
}();

// node_modules/@babylonjs/gui/2D/controls/multiLine.js
var MultiLine = function(_super) {
  __extends(MultiLine2, _super);
  function MultiLine2(name4) {
    var _this = _super.call(this, name4) || this;
    _this.name = name4;
    _this._lineWidth = 1;
    _this.onPointUpdate = function() {
      _this._markAsDirty();
    };
    _this._automaticSize = true;
    _this.isHitTestVisible = false;
    _this._horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    _this._verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
    _this._dash = [];
    _this._points = [];
    return _this;
  }
  Object.defineProperty(MultiLine2.prototype, "dash", {
    get: function() {
      return this._dash;
    },
    set: function(value) {
      if (this._dash === value) {
        return;
      }
      this._dash = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  MultiLine2.prototype.getAt = function(index) {
    if (!this._points[index]) {
      this._points[index] = new MultiLinePoint(this);
    }
    return this._points[index];
  };
  MultiLine2.prototype.add = function() {
    var _this = this;
    var items = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      items[_i] = arguments[_i];
    }
    return items.map(function(item) {
      return _this.push(item);
    });
  };
  MultiLine2.prototype.push = function(item) {
    var point = this.getAt(this._points.length);
    if (item == null) {
      return point;
    }
    if (item instanceof AbstractMesh) {
      point.mesh = item;
    } else if (item instanceof Control) {
      point.control = item;
    } else if (item.x != null && item.y != null) {
      point.x = item.x;
      point.y = item.y;
    }
    return point;
  };
  MultiLine2.prototype.remove = function(value) {
    var index;
    if (value instanceof MultiLinePoint) {
      index = this._points.indexOf(value);
      if (index === -1) {
        return;
      }
    } else {
      index = value;
    }
    var point = this._points[index];
    if (!point) {
      return;
    }
    point.dispose();
    this._points.splice(index, 1);
  };
  MultiLine2.prototype.reset = function() {
    while (this._points.length > 0) {
      this.remove(this._points.length - 1);
    }
  };
  MultiLine2.prototype.resetLinks = function() {
    this._points.forEach(function(point) {
      if (point != null) {
        point.resetLinks();
      }
    });
  };
  Object.defineProperty(MultiLine2.prototype, "lineWidth", {
    get: function() {
      return this._lineWidth;
    },
    set: function(value) {
      if (this._lineWidth === value) {
        return;
      }
      this._lineWidth = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MultiLine2.prototype, "horizontalAlignment", {
    set: function(value) {
      return;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MultiLine2.prototype, "verticalAlignment", {
    set: function(value) {
      return;
    },
    enumerable: false,
    configurable: true
  });
  MultiLine2.prototype._getTypeName = function() {
    return "MultiLine";
  };
  MultiLine2.prototype._draw = function(context, invalidatedRectangle) {
    context.save();
    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {
      context.shadowColor = this.shadowColor;
      context.shadowBlur = this.shadowBlur;
      context.shadowOffsetX = this.shadowOffsetX;
      context.shadowOffsetY = this.shadowOffsetY;
    }
    this._applyStates(context);
    context.strokeStyle = this.color;
    context.lineWidth = this._lineWidth;
    context.setLineDash(this._dash);
    context.beginPath();
    var first = true;
    var previousPoint;
    this._points.forEach(function(point) {
      if (!point) {
        return;
      }
      if (first) {
        context.moveTo(point._point.x, point._point.y);
        first = false;
      } else {
        if (point._point.z < 1 && previousPoint.z < 1) {
          context.lineTo(point._point.x, point._point.y);
        } else {
          context.moveTo(point._point.x, point._point.y);
        }
      }
      previousPoint = point._point;
    });
    context.stroke();
    context.restore();
  };
  MultiLine2.prototype._additionalProcessing = function(parentMeasure, context) {
    var _this = this;
    this._minX = null;
    this._minY = null;
    this._maxX = null;
    this._maxY = null;
    this._points.forEach(function(point, index) {
      if (!point) {
        return;
      }
      point.translate();
      if (_this._minX == null || point._point.x < _this._minX) {
        _this._minX = point._point.x;
      }
      if (_this._minY == null || point._point.y < _this._minY) {
        _this._minY = point._point.y;
      }
      if (_this._maxX == null || point._point.x > _this._maxX) {
        _this._maxX = point._point.x;
      }
      if (_this._maxY == null || point._point.y > _this._maxY) {
        _this._maxY = point._point.y;
      }
    });
    if (this._minX == null) {
      this._minX = 0;
    }
    if (this._minY == null) {
      this._minY = 0;
    }
    if (this._maxX == null) {
      this._maxX = 0;
    }
    if (this._maxY == null) {
      this._maxY = 0;
    }
  };
  MultiLine2.prototype._measure = function() {
    if (this._minX == null || this._maxX == null || this._minY == null || this._maxY == null) {
      return;
    }
    this._currentMeasure.width = Math.abs(this._maxX - this._minX) + this._lineWidth;
    this._currentMeasure.height = Math.abs(this._maxY - this._minY) + this._lineWidth;
  };
  MultiLine2.prototype._computeAlignment = function(parentMeasure, context) {
    if (this._minX == null || this._minY == null) {
      return;
    }
    this._currentMeasure.left = this._minX - this._lineWidth / 2;
    this._currentMeasure.top = this._minY - this._lineWidth / 2;
  };
  MultiLine2.prototype.dispose = function() {
    this.reset();
    _super.prototype.dispose.call(this);
  };
  return MultiLine2;
}(Control);
_TypeStore.RegisteredTypes["BABYLON.GUI.MultiLine"] = MultiLine;

// node_modules/@babylonjs/gui/2D/controls/radioButton.js
var RadioButton = function(_super) {
  __extends(RadioButton2, _super);
  function RadioButton2(name4) {
    var _this = _super.call(this, name4) || this;
    _this.name = name4;
    _this._isChecked = false;
    _this._background = "black";
    _this._checkSizeRatio = 0.8;
    _this._thickness = 1;
    _this.group = "";
    _this.onIsCheckedChangedObservable = new Observable();
    _this.isPointerBlocker = true;
    return _this;
  }
  Object.defineProperty(RadioButton2.prototype, "thickness", {
    get: function() {
      return this._thickness;
    },
    set: function(value) {
      if (this._thickness === value) {
        return;
      }
      this._thickness = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RadioButton2.prototype, "checkSizeRatio", {
    get: function() {
      return this._checkSizeRatio;
    },
    set: function(value) {
      value = Math.max(Math.min(1, value), 0);
      if (this._checkSizeRatio === value) {
        return;
      }
      this._checkSizeRatio = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RadioButton2.prototype, "background", {
    get: function() {
      return this._background;
    },
    set: function(value) {
      if (this._background === value) {
        return;
      }
      this._background = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RadioButton2.prototype, "isChecked", {
    get: function() {
      return this._isChecked;
    },
    set: function(value) {
      var _this = this;
      if (this._isChecked === value) {
        return;
      }
      this._isChecked = value;
      this._markAsDirty();
      this.onIsCheckedChangedObservable.notifyObservers(value);
      if (this._isChecked && this._host) {
        this._host.executeOnAllControls(function(control) {
          if (control === _this) {
            return;
          }
          if (control.group === void 0) {
            return;
          }
          var childRadio = control;
          if (childRadio.group === _this.group) {
            childRadio.isChecked = false;
          }
        });
      }
    },
    enumerable: false,
    configurable: true
  });
  RadioButton2.prototype._getTypeName = function() {
    return "RadioButton";
  };
  RadioButton2.prototype._draw = function(context) {
    context.save();
    this._applyStates(context);
    var actualWidth = this._currentMeasure.width - this._thickness;
    var actualHeight = this._currentMeasure.height - this._thickness;
    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {
      context.shadowColor = this.shadowColor;
      context.shadowBlur = this.shadowBlur;
      context.shadowOffsetX = this.shadowOffsetX;
      context.shadowOffsetY = this.shadowOffsetY;
    }
    Control.drawEllipse(this._currentMeasure.left + this._currentMeasure.width / 2, this._currentMeasure.top + this._currentMeasure.height / 2, this._currentMeasure.width / 2 - this._thickness / 2, this._currentMeasure.height / 2 - this._thickness / 2, context);
    context.fillStyle = this._isEnabled ? this._background : this._disabledColor;
    context.fill();
    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {
      context.shadowBlur = 0;
      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
    }
    context.strokeStyle = this.color;
    context.lineWidth = this._thickness;
    context.stroke();
    if (this._isChecked) {
      context.fillStyle = this._isEnabled ? this.color : this._disabledColor;
      var offsetWidth = actualWidth * this._checkSizeRatio;
      var offseHeight = actualHeight * this._checkSizeRatio;
      Control.drawEllipse(this._currentMeasure.left + this._currentMeasure.width / 2, this._currentMeasure.top + this._currentMeasure.height / 2, offsetWidth / 2 - this._thickness / 2, offseHeight / 2 - this._thickness / 2, context);
      context.fill();
    }
    context.restore();
  };
  RadioButton2.prototype._onPointerDown = function(target, coordinates, pointerId, buttonIndex, pi) {
    if (!_super.prototype._onPointerDown.call(this, target, coordinates, pointerId, buttonIndex, pi)) {
      return false;
    }
    if (!this.isChecked) {
      this.isChecked = true;
    }
    return true;
  };
  RadioButton2.AddRadioButtonWithHeader = function(title, group, isChecked, onValueChanged) {
    var panel = new StackPanel();
    panel.isVertical = false;
    panel.height = "30px";
    var radio = new RadioButton2();
    radio.width = "20px";
    radio.height = "20px";
    radio.isChecked = isChecked;
    radio.color = "green";
    radio.group = group;
    radio.onIsCheckedChangedObservable.add(function(value) {
      return onValueChanged(radio, value);
    });
    panel.addControl(radio);
    var header = new TextBlock();
    header.text = title;
    header.width = "180px";
    header.paddingLeft = "5px";
    header.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    header.color = "white";
    panel.addControl(header);
    return panel;
  };
  return RadioButton2;
}(Control);
_TypeStore.RegisteredTypes["BABYLON.GUI.RadioButton"] = RadioButton;

// node_modules/@babylonjs/gui/2D/controls/sliders/baseSlider.js
var BaseSlider = function(_super) {
  __extends(BaseSlider2, _super);
  function BaseSlider2(name4) {
    var _this = _super.call(this, name4) || this;
    _this.name = name4;
    _this._thumbWidth = new ValueAndUnit(20, ValueAndUnit.UNITMODE_PIXEL, false);
    _this._minimum = 0;
    _this._maximum = 100;
    _this._value = 50;
    _this._isVertical = false;
    _this._barOffset = new ValueAndUnit(5, ValueAndUnit.UNITMODE_PIXEL, false);
    _this._isThumbClamped = false;
    _this._displayThumb = true;
    _this._step = 0;
    _this._lastPointerDownID = -1;
    _this._effectiveBarOffset = 0;
    _this.onValueChangedObservable = new Observable();
    _this._pointerIsDown = false;
    _this.isPointerBlocker = true;
    return _this;
  }
  Object.defineProperty(BaseSlider2.prototype, "displayThumb", {
    get: function() {
      return this._displayThumb;
    },
    set: function(value) {
      if (this._displayThumb === value) {
        return;
      }
      this._displayThumb = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseSlider2.prototype, "step", {
    get: function() {
      return this._step;
    },
    set: function(value) {
      if (this._step === value) {
        return;
      }
      this._step = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseSlider2.prototype, "barOffset", {
    get: function() {
      return this._barOffset.toString(this._host);
    },
    set: function(value) {
      if (this._barOffset.toString(this._host) === value) {
        return;
      }
      if (this._barOffset.fromString(value)) {
        this._markAsDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseSlider2.prototype, "barOffsetInPixels", {
    get: function() {
      return this._barOffset.getValueInPixel(this._host, this._cachedParentMeasure.width);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseSlider2.prototype, "thumbWidth", {
    get: function() {
      return this._thumbWidth.toString(this._host);
    },
    set: function(value) {
      if (this._thumbWidth.toString(this._host) === value) {
        return;
      }
      if (this._thumbWidth.fromString(value)) {
        this._markAsDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseSlider2.prototype, "thumbWidthInPixels", {
    get: function() {
      return this._thumbWidth.getValueInPixel(this._host, this._cachedParentMeasure.width);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseSlider2.prototype, "minimum", {
    get: function() {
      return this._minimum;
    },
    set: function(value) {
      if (this._minimum === value) {
        return;
      }
      this._minimum = value;
      this._markAsDirty();
      this.value = Math.max(Math.min(this.value, this._maximum), this._minimum);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseSlider2.prototype, "maximum", {
    get: function() {
      return this._maximum;
    },
    set: function(value) {
      if (this._maximum === value) {
        return;
      }
      this._maximum = value;
      this._markAsDirty();
      this.value = Math.max(Math.min(this.value, this._maximum), this._minimum);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseSlider2.prototype, "value", {
    get: function() {
      return this._value;
    },
    set: function(value) {
      value = Math.max(Math.min(value, this._maximum), this._minimum);
      if (this._value === value) {
        return;
      }
      this._value = value;
      this._markAsDirty();
      this.onValueChangedObservable.notifyObservers(this._value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseSlider2.prototype, "isVertical", {
    get: function() {
      return this._isVertical;
    },
    set: function(value) {
      if (this._isVertical === value) {
        return;
      }
      this._isVertical = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseSlider2.prototype, "isThumbClamped", {
    get: function() {
      return this._isThumbClamped;
    },
    set: function(value) {
      if (this._isThumbClamped === value) {
        return;
      }
      this._isThumbClamped = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  BaseSlider2.prototype._getTypeName = function() {
    return "BaseSlider";
  };
  BaseSlider2.prototype._getThumbPosition = function() {
    if (this.isVertical) {
      return (this.maximum - this.value) / (this.maximum - this.minimum) * this._backgroundBoxLength;
    }
    return (this.value - this.minimum) / (this.maximum - this.minimum) * this._backgroundBoxLength;
  };
  BaseSlider2.prototype._getThumbThickness = function(type) {
    var thumbThickness = 0;
    switch (type) {
      case "circle":
        if (this._thumbWidth.isPixel) {
          thumbThickness = Math.max(this._thumbWidth.getValue(this._host), this._backgroundBoxThickness);
        } else {
          thumbThickness = this._backgroundBoxThickness * this._thumbWidth.getValue(this._host);
        }
        break;
      case "rectangle":
        if (this._thumbWidth.isPixel) {
          thumbThickness = Math.min(this._thumbWidth.getValue(this._host), this._backgroundBoxThickness);
        } else {
          thumbThickness = this._backgroundBoxThickness * this._thumbWidth.getValue(this._host);
        }
    }
    return thumbThickness;
  };
  BaseSlider2.prototype._prepareRenderingData = function(type) {
    this._effectiveBarOffset = 0;
    this._renderLeft = this._currentMeasure.left;
    this._renderTop = this._currentMeasure.top;
    this._renderWidth = this._currentMeasure.width;
    this._renderHeight = this._currentMeasure.height;
    this._backgroundBoxLength = Math.max(this._currentMeasure.width, this._currentMeasure.height);
    this._backgroundBoxThickness = Math.min(this._currentMeasure.width, this._currentMeasure.height);
    this._effectiveThumbThickness = this._getThumbThickness(type);
    if (this.displayThumb) {
      this._backgroundBoxLength -= this._effectiveThumbThickness;
    }
    if (this.isVertical && this._currentMeasure.height < this._currentMeasure.width) {
      console.error("Height should be greater than width");
      return;
    }
    if (this._barOffset.isPixel) {
      this._effectiveBarOffset = Math.min(this._barOffset.getValue(this._host), this._backgroundBoxThickness);
    } else {
      this._effectiveBarOffset = this._backgroundBoxThickness * this._barOffset.getValue(this._host);
    }
    this._backgroundBoxThickness -= this._effectiveBarOffset * 2;
    if (this.isVertical) {
      this._renderLeft += this._effectiveBarOffset;
      if (!this.isThumbClamped && this.displayThumb) {
        this._renderTop += this._effectiveThumbThickness / 2;
      }
      this._renderHeight = this._backgroundBoxLength;
      this._renderWidth = this._backgroundBoxThickness;
    } else {
      this._renderTop += this._effectiveBarOffset;
      if (!this.isThumbClamped && this.displayThumb) {
        this._renderLeft += this._effectiveThumbThickness / 2;
      }
      this._renderHeight = this._backgroundBoxThickness;
      this._renderWidth = this._backgroundBoxLength;
    }
  };
  BaseSlider2.prototype._updateValueFromPointer = function(x, y) {
    if (this.rotation != 0) {
      this._invertTransformMatrix.transformCoordinates(x, y, this._transformedPosition);
      x = this._transformedPosition.x;
      y = this._transformedPosition.y;
    }
    var value;
    if (this._isVertical) {
      value = this._minimum + (1 - (y - this._currentMeasure.top) / this._currentMeasure.height) * (this._maximum - this._minimum);
    } else {
      value = this._minimum + (x - this._currentMeasure.left) / this._currentMeasure.width * (this._maximum - this._minimum);
    }
    var mult = 1 / this._step | 0;
    this.value = this._step ? (value * mult | 0) / mult : value;
  };
  BaseSlider2.prototype._onPointerDown = function(target, coordinates, pointerId, buttonIndex, pi) {
    if (!_super.prototype._onPointerDown.call(this, target, coordinates, pointerId, buttonIndex, pi)) {
      return false;
    }
    this._pointerIsDown = true;
    this._updateValueFromPointer(coordinates.x, coordinates.y);
    this._host._capturingControl[pointerId] = this;
    this._lastPointerDownID = pointerId;
    return true;
  };
  BaseSlider2.prototype._onPointerMove = function(target, coordinates, pointerId, pi) {
    if (pointerId != this._lastPointerDownID) {
      return;
    }
    if (this._pointerIsDown) {
      this._updateValueFromPointer(coordinates.x, coordinates.y);
    }
    _super.prototype._onPointerMove.call(this, target, coordinates, pointerId, pi);
  };
  BaseSlider2.prototype._onPointerUp = function(target, coordinates, pointerId, buttonIndex, notifyClick) {
    this._pointerIsDown = false;
    delete this._host._capturingControl[pointerId];
    _super.prototype._onPointerUp.call(this, target, coordinates, pointerId, buttonIndex, notifyClick);
  };
  BaseSlider2.prototype._onCanvasBlur = function() {
    this._forcePointerUp();
    _super.prototype._onCanvasBlur.call(this);
  };
  return BaseSlider2;
}(Control);

// node_modules/@babylonjs/gui/2D/controls/sliders/slider.js
var Slider = function(_super) {
  __extends(Slider2, _super);
  function Slider2(name4) {
    var _this = _super.call(this, name4) || this;
    _this.name = name4;
    _this._background = "black";
    _this._borderColor = "white";
    _this._thumbColor = "";
    _this._isThumbCircle = false;
    _this._displayValueBar = true;
    return _this;
  }
  Object.defineProperty(Slider2.prototype, "displayValueBar", {
    get: function() {
      return this._displayValueBar;
    },
    set: function(value) {
      if (this._displayValueBar === value) {
        return;
      }
      this._displayValueBar = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Slider2.prototype, "borderColor", {
    get: function() {
      return this._borderColor;
    },
    set: function(value) {
      if (this._borderColor === value) {
        return;
      }
      this._borderColor = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Slider2.prototype, "background", {
    get: function() {
      return this._background;
    },
    set: function(value) {
      if (this._background === value) {
        return;
      }
      this._background = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Slider2.prototype, "thumbColor", {
    get: function() {
      return this._thumbColor;
    },
    set: function(value) {
      if (this._thumbColor === value) {
        return;
      }
      this._thumbColor = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Slider2.prototype, "isThumbCircle", {
    get: function() {
      return this._isThumbCircle;
    },
    set: function(value) {
      if (this._isThumbCircle === value) {
        return;
      }
      this._isThumbCircle = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Slider2.prototype._getTypeName = function() {
    return "Slider";
  };
  Slider2.prototype._draw = function(context, invalidatedRectangle) {
    context.save();
    this._applyStates(context);
    this._prepareRenderingData(this.isThumbCircle ? "circle" : "rectangle");
    var left = this._renderLeft;
    var top = this._renderTop;
    var width = this._renderWidth;
    var height = this._renderHeight;
    var radius = 0;
    if (this.isThumbClamped && this.isThumbCircle) {
      if (this.isVertical) {
        top += this._effectiveThumbThickness / 2;
      } else {
        left += this._effectiveThumbThickness / 2;
      }
      radius = this._backgroundBoxThickness / 2;
    } else {
      radius = (this._effectiveThumbThickness - this._effectiveBarOffset) / 2;
    }
    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {
      context.shadowColor = this.shadowColor;
      context.shadowBlur = this.shadowBlur;
      context.shadowOffsetX = this.shadowOffsetX;
      context.shadowOffsetY = this.shadowOffsetY;
    }
    var thumbPosition = this._getThumbPosition();
    context.fillStyle = this._background;
    if (this.isVertical) {
      if (this.isThumbClamped) {
        if (this.isThumbCircle) {
          context.beginPath();
          context.arc(left + this._backgroundBoxThickness / 2, top, radius, Math.PI, 2 * Math.PI);
          context.fill();
          context.fillRect(left, top, width, height);
        } else {
          context.fillRect(left, top, width, height + this._effectiveThumbThickness);
        }
      } else {
        context.fillRect(left, top, width, height);
      }
    } else {
      if (this.isThumbClamped) {
        if (this.isThumbCircle) {
          context.beginPath();
          context.arc(left + this._backgroundBoxLength, top + this._backgroundBoxThickness / 2, radius, 0, 2 * Math.PI);
          context.fill();
          context.fillRect(left, top, width, height);
        } else {
          context.fillRect(left, top, width + this._effectiveThumbThickness, height);
        }
      } else {
        context.fillRect(left, top, width, height);
      }
    }
    if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {
      context.shadowBlur = 0;
      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
    }
    context.fillStyle = this.color;
    if (this._displayValueBar) {
      if (this.isVertical) {
        if (this.isThumbClamped) {
          if (this.isThumbCircle) {
            context.beginPath();
            context.arc(left + this._backgroundBoxThickness / 2, top + this._backgroundBoxLength, radius, 0, 2 * Math.PI);
            context.fill();
            context.fillRect(left, top + thumbPosition, width, height - thumbPosition);
          } else {
            context.fillRect(left, top + thumbPosition, width, height - thumbPosition + this._effectiveThumbThickness);
          }
        } else {
          context.fillRect(left, top + thumbPosition, width, height - thumbPosition);
        }
      } else {
        if (this.isThumbClamped) {
          if (this.isThumbCircle) {
            context.beginPath();
            context.arc(left, top + this._backgroundBoxThickness / 2, radius, 0, 2 * Math.PI);
            context.fill();
            context.fillRect(left, top, thumbPosition, height);
          } else {
            context.fillRect(left, top, thumbPosition, height);
          }
        } else {
          context.fillRect(left, top, thumbPosition, height);
        }
      }
    }
    context.fillStyle = this._thumbColor || this.color;
    if (this.displayThumb) {
      if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {
        context.shadowColor = this.shadowColor;
        context.shadowBlur = this.shadowBlur;
        context.shadowOffsetX = this.shadowOffsetX;
        context.shadowOffsetY = this.shadowOffsetY;
      }
      if (this._isThumbCircle) {
        context.beginPath();
        if (this.isVertical) {
          context.arc(left + this._backgroundBoxThickness / 2, top + thumbPosition, radius, 0, 2 * Math.PI);
        } else {
          context.arc(left + thumbPosition, top + this._backgroundBoxThickness / 2, radius, 0, 2 * Math.PI);
        }
        context.fill();
        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {
          context.shadowBlur = 0;
          context.shadowOffsetX = 0;
          context.shadowOffsetY = 0;
        }
        context.strokeStyle = this._borderColor;
        context.stroke();
      } else {
        if (this.isVertical) {
          context.fillRect(left - this._effectiveBarOffset, this._currentMeasure.top + thumbPosition, this._currentMeasure.width, this._effectiveThumbThickness);
        } else {
          context.fillRect(this._currentMeasure.left + thumbPosition, this._currentMeasure.top, this._effectiveThumbThickness, this._currentMeasure.height);
        }
        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {
          context.shadowBlur = 0;
          context.shadowOffsetX = 0;
          context.shadowOffsetY = 0;
        }
        context.strokeStyle = this._borderColor;
        if (this.isVertical) {
          context.strokeRect(left - this._effectiveBarOffset, this._currentMeasure.top + thumbPosition, this._currentMeasure.width, this._effectiveThumbThickness);
        } else {
          context.strokeRect(this._currentMeasure.left + thumbPosition, this._currentMeasure.top, this._effectiveThumbThickness, this._currentMeasure.height);
        }
      }
    }
    context.restore();
  };
  return Slider2;
}(BaseSlider);
_TypeStore.RegisteredTypes["BABYLON.GUI.Slider"] = Slider;

// node_modules/@babylonjs/gui/2D/controls/selector.js
var SelectorGroup = function() {
  function SelectorGroup2(name4) {
    this.name = name4;
    this._groupPanel = new StackPanel();
    this._selectors = new Array();
    this._groupPanel.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
    this._groupPanel.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    this._groupHeader = this._addGroupHeader(name4);
  }
  Object.defineProperty(SelectorGroup2.prototype, "groupPanel", {
    get: function() {
      return this._groupPanel;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SelectorGroup2.prototype, "selectors", {
    get: function() {
      return this._selectors;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SelectorGroup2.prototype, "header", {
    get: function() {
      return this._groupHeader.text;
    },
    set: function(label) {
      if (this._groupHeader.text === "label") {
        return;
      }
      this._groupHeader.text = label;
    },
    enumerable: false,
    configurable: true
  });
  SelectorGroup2.prototype._addGroupHeader = function(text) {
    var groupHeading = new TextBlock("groupHead", text);
    groupHeading.width = 0.9;
    groupHeading.height = "30px";
    groupHeading.textWrapping = true;
    groupHeading.color = "black";
    groupHeading.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    groupHeading.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    groupHeading.left = "2px";
    this._groupPanel.addControl(groupHeading);
    return groupHeading;
  };
  SelectorGroup2.prototype._getSelector = function(selectorNb) {
    if (selectorNb < 0 || selectorNb >= this._selectors.length) {
      return;
    }
    return this._selectors[selectorNb];
  };
  SelectorGroup2.prototype.removeSelector = function(selectorNb) {
    if (selectorNb < 0 || selectorNb >= this._selectors.length) {
      return;
    }
    this._groupPanel.removeControl(this._selectors[selectorNb]);
    this._selectors.splice(selectorNb, 1);
  };
  return SelectorGroup2;
}();
var CheckboxGroup = function(_super) {
  __extends(CheckboxGroup2, _super);
  function CheckboxGroup2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CheckboxGroup2.prototype.addCheckbox = function(text, func, checked) {
    if (func === void 0) {
      func = function(s) {
      };
    }
    if (checked === void 0) {
      checked = false;
    }
    var checked = checked || false;
    var button = new Checkbox();
    button.width = "20px";
    button.height = "20px";
    button.color = "#364249";
    button.background = "#CCCCCC";
    button.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    button.onIsCheckedChangedObservable.add(function(state) {
      func(state);
    });
    var _selector = Control.AddHeader(button, text, "200px", { isHorizontal: true, controlFirst: true });
    _selector.height = "30px";
    _selector.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    _selector.left = "4px";
    this.groupPanel.addControl(_selector);
    this.selectors.push(_selector);
    button.isChecked = checked;
    if (this.groupPanel.parent && this.groupPanel.parent.parent) {
      button.color = this.groupPanel.parent.parent.buttonColor;
      button.background = this.groupPanel.parent.parent.buttonBackground;
    }
  };
  CheckboxGroup2.prototype._setSelectorLabel = function(selectorNb, label) {
    this.selectors[selectorNb].children[1].text = label;
  };
  CheckboxGroup2.prototype._setSelectorLabelColor = function(selectorNb, color) {
    this.selectors[selectorNb].children[1].color = color;
  };
  CheckboxGroup2.prototype._setSelectorButtonColor = function(selectorNb, color) {
    this.selectors[selectorNb].children[0].color = color;
  };
  CheckboxGroup2.prototype._setSelectorButtonBackground = function(selectorNb, color) {
    this.selectors[selectorNb].children[0].background = color;
  };
  return CheckboxGroup2;
}(SelectorGroup);
var RadioGroup = function(_super) {
  __extends(RadioGroup2, _super);
  function RadioGroup2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._selectNb = 0;
    return _this;
  }
  RadioGroup2.prototype.addRadio = function(label, func, checked) {
    if (func === void 0) {
      func = function(n) {
      };
    }
    if (checked === void 0) {
      checked = false;
    }
    var nb = this._selectNb++;
    var button = new RadioButton();
    button.name = label;
    button.width = "20px";
    button.height = "20px";
    button.color = "#364249";
    button.background = "#CCCCCC";
    button.group = this.name;
    button.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    button.onIsCheckedChangedObservable.add(function(state) {
      if (state) {
        func(nb);
      }
    });
    var _selector = Control.AddHeader(button, label, "200px", { isHorizontal: true, controlFirst: true });
    _selector.height = "30px";
    _selector.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    _selector.left = "4px";
    this.groupPanel.addControl(_selector);
    this.selectors.push(_selector);
    button.isChecked = checked;
    if (this.groupPanel.parent && this.groupPanel.parent.parent) {
      button.color = this.groupPanel.parent.parent.buttonColor;
      button.background = this.groupPanel.parent.parent.buttonBackground;
    }
  };
  RadioGroup2.prototype._setSelectorLabel = function(selectorNb, label) {
    this.selectors[selectorNb].children[1].text = label;
  };
  RadioGroup2.prototype._setSelectorLabelColor = function(selectorNb, color) {
    this.selectors[selectorNb].children[1].color = color;
  };
  RadioGroup2.prototype._setSelectorButtonColor = function(selectorNb, color) {
    this.selectors[selectorNb].children[0].color = color;
  };
  RadioGroup2.prototype._setSelectorButtonBackground = function(selectorNb, color) {
    this.selectors[selectorNb].children[0].background = color;
  };
  return RadioGroup2;
}(SelectorGroup);
var SliderGroup = function(_super) {
  __extends(SliderGroup2, _super);
  function SliderGroup2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SliderGroup2.prototype.addSlider = function(label, func, unit, min, max, value, onValueChange) {
    if (func === void 0) {
      func = function(v) {
      };
    }
    if (unit === void 0) {
      unit = "Units";
    }
    if (min === void 0) {
      min = 0;
    }
    if (max === void 0) {
      max = 0;
    }
    if (value === void 0) {
      value = 0;
    }
    if (onValueChange === void 0) {
      onValueChange = function(v) {
        return v | 0;
      };
    }
    var button = new Slider();
    button.name = unit;
    button.value = value;
    button.minimum = min;
    button.maximum = max;
    button.width = 0.9;
    button.height = "20px";
    button.color = "#364249";
    button.background = "#CCCCCC";
    button.borderColor = "black";
    button.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    button.left = "4px";
    button.paddingBottom = "4px";
    button.onValueChangedObservable.add(function(value2) {
      button.parent.children[0].text = button.parent.children[0].name + ": " + onValueChange(value2) + " " + button.name;
      func(value2);
    });
    var _selector = Control.AddHeader(button, label + ": " + onValueChange(value) + " " + unit, "30px", { isHorizontal: false, controlFirst: false });
    _selector.height = "60px";
    _selector.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    _selector.left = "4px";
    _selector.children[0].name = label;
    this.groupPanel.addControl(_selector);
    this.selectors.push(_selector);
    if (this.groupPanel.parent && this.groupPanel.parent.parent) {
      button.color = this.groupPanel.parent.parent.buttonColor;
      button.background = this.groupPanel.parent.parent.buttonBackground;
    }
  };
  SliderGroup2.prototype._setSelectorLabel = function(selectorNb, label) {
    this.selectors[selectorNb].children[0].name = label;
    this.selectors[selectorNb].children[0].text = label + ": " + this.selectors[selectorNb].children[1].value + " " + this.selectors[selectorNb].children[1].name;
  };
  SliderGroup2.prototype._setSelectorLabelColor = function(selectorNb, color) {
    this.selectors[selectorNb].children[0].color = color;
  };
  SliderGroup2.prototype._setSelectorButtonColor = function(selectorNb, color) {
    this.selectors[selectorNb].children[1].color = color;
  };
  SliderGroup2.prototype._setSelectorButtonBackground = function(selectorNb, color) {
    this.selectors[selectorNb].children[1].background = color;
  };
  return SliderGroup2;
}(SelectorGroup);
var SelectionPanel = function(_super) {
  __extends(SelectionPanel2, _super);
  function SelectionPanel2(name4, groups) {
    if (groups === void 0) {
      groups = [];
    }
    var _this = _super.call(this, name4) || this;
    _this.name = name4;
    _this.groups = groups;
    _this._buttonColor = "#364249";
    _this._buttonBackground = "#CCCCCC";
    _this._headerColor = "black";
    _this._barColor = "white";
    _this._barHeight = "2px";
    _this._spacerHeight = "20px";
    _this._bars = new Array();
    _this._groups = groups;
    _this.thickness = 2;
    _this._panel = new StackPanel();
    _this._panel.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
    _this._panel.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    _this._panel.top = 5;
    _this._panel.left = 5;
    _this._panel.width = 0.95;
    if (groups.length > 0) {
      for (var i = 0; i < groups.length - 1; i++) {
        _this._panel.addControl(groups[i].groupPanel);
        _this._addSpacer();
      }
      _this._panel.addControl(groups[groups.length - 1].groupPanel);
    }
    _this.addControl(_this._panel);
    return _this;
  }
  SelectionPanel2.prototype._getTypeName = function() {
    return "SelectionPanel";
  };
  Object.defineProperty(SelectionPanel2.prototype, "panel", {
    get: function() {
      return this._panel;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SelectionPanel2.prototype, "headerColor", {
    get: function() {
      return this._headerColor;
    },
    set: function(color) {
      if (this._headerColor === color) {
        return;
      }
      this._headerColor = color;
      this._setHeaderColor();
    },
    enumerable: false,
    configurable: true
  });
  SelectionPanel2.prototype._setHeaderColor = function() {
    for (var i = 0; i < this._groups.length; i++) {
      this._groups[i].groupPanel.children[0].color = this._headerColor;
    }
  };
  Object.defineProperty(SelectionPanel2.prototype, "buttonColor", {
    get: function() {
      return this._buttonColor;
    },
    set: function(color) {
      if (this._buttonColor === color) {
        return;
      }
      this._buttonColor = color;
      this._setbuttonColor();
    },
    enumerable: false,
    configurable: true
  });
  SelectionPanel2.prototype._setbuttonColor = function() {
    for (var i = 0; i < this._groups.length; i++) {
      for (var j = 0; j < this._groups[i].selectors.length; j++) {
        this._groups[i]._setSelectorButtonColor(j, this._buttonColor);
      }
    }
  };
  Object.defineProperty(SelectionPanel2.prototype, "labelColor", {
    get: function() {
      return this._labelColor;
    },
    set: function(color) {
      if (this._labelColor === color) {
        return;
      }
      this._labelColor = color;
      this._setLabelColor();
    },
    enumerable: false,
    configurable: true
  });
  SelectionPanel2.prototype._setLabelColor = function() {
    for (var i = 0; i < this._groups.length; i++) {
      for (var j = 0; j < this._groups[i].selectors.length; j++) {
        this._groups[i]._setSelectorLabelColor(j, this._labelColor);
      }
    }
  };
  Object.defineProperty(SelectionPanel2.prototype, "buttonBackground", {
    get: function() {
      return this._buttonBackground;
    },
    set: function(color) {
      if (this._buttonBackground === color) {
        return;
      }
      this._buttonBackground = color;
      this._setButtonBackground();
    },
    enumerable: false,
    configurable: true
  });
  SelectionPanel2.prototype._setButtonBackground = function() {
    for (var i = 0; i < this._groups.length; i++) {
      for (var j = 0; j < this._groups[i].selectors.length; j++) {
        this._groups[i]._setSelectorButtonBackground(j, this._buttonBackground);
      }
    }
  };
  Object.defineProperty(SelectionPanel2.prototype, "barColor", {
    get: function() {
      return this._barColor;
    },
    set: function(color) {
      if (this._barColor === color) {
        return;
      }
      this._barColor = color;
      this._setBarColor();
    },
    enumerable: false,
    configurable: true
  });
  SelectionPanel2.prototype._setBarColor = function() {
    for (var i = 0; i < this._bars.length; i++) {
      this._bars[i].children[0].background = this._barColor;
    }
  };
  Object.defineProperty(SelectionPanel2.prototype, "barHeight", {
    get: function() {
      return this._barHeight;
    },
    set: function(value) {
      if (this._barHeight === value) {
        return;
      }
      this._barHeight = value;
      this._setBarHeight();
    },
    enumerable: false,
    configurable: true
  });
  SelectionPanel2.prototype._setBarHeight = function() {
    for (var i = 0; i < this._bars.length; i++) {
      this._bars[i].children[0].height = this._barHeight;
    }
  };
  Object.defineProperty(SelectionPanel2.prototype, "spacerHeight", {
    get: function() {
      return this._spacerHeight;
    },
    set: function(value) {
      if (this._spacerHeight === value) {
        return;
      }
      this._spacerHeight = value;
      this._setSpacerHeight();
    },
    enumerable: false,
    configurable: true
  });
  SelectionPanel2.prototype._setSpacerHeight = function() {
    for (var i = 0; i < this._bars.length; i++) {
      this._bars[i].height = this._spacerHeight;
    }
  };
  SelectionPanel2.prototype._addSpacer = function() {
    var separator = new Container();
    separator.width = 1;
    separator.height = this._spacerHeight;
    separator.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    var bar = new Rectangle();
    bar.width = 1;
    bar.height = this._barHeight;
    bar.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    bar.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;
    bar.background = this._barColor;
    bar.color = "transparent";
    separator.addControl(bar);
    this._panel.addControl(separator);
    this._bars.push(separator);
  };
  SelectionPanel2.prototype.addGroup = function(group) {
    if (this._groups.length > 0) {
      this._addSpacer();
    }
    this._panel.addControl(group.groupPanel);
    this._groups.push(group);
    group.groupPanel.children[0].color = this._headerColor;
    for (var j = 0; j < group.selectors.length; j++) {
      group._setSelectorButtonColor(j, this._buttonColor);
      group._setSelectorButtonBackground(j, this._buttonBackground);
    }
  };
  SelectionPanel2.prototype.removeGroup = function(groupNb) {
    if (groupNb < 0 || groupNb >= this._groups.length) {
      return;
    }
    var group = this._groups[groupNb];
    this._panel.removeControl(group.groupPanel);
    this._groups.splice(groupNb, 1);
    if (groupNb < this._bars.length) {
      this._panel.removeControl(this._bars[groupNb]);
      this._bars.splice(groupNb, 1);
    }
  };
  SelectionPanel2.prototype.setHeaderName = function(label, groupNb) {
    if (groupNb < 0 || groupNb >= this._groups.length) {
      return;
    }
    var group = this._groups[groupNb];
    group.groupPanel.children[0].text = label;
  };
  SelectionPanel2.prototype.relabel = function(label, groupNb, selectorNb) {
    if (groupNb < 0 || groupNb >= this._groups.length) {
      return;
    }
    var group = this._groups[groupNb];
    if (selectorNb < 0 || selectorNb >= group.selectors.length) {
      return;
    }
    group._setSelectorLabel(selectorNb, label);
  };
  SelectionPanel2.prototype.removeFromGroupSelector = function(groupNb, selectorNb) {
    if (groupNb < 0 || groupNb >= this._groups.length) {
      return;
    }
    var group = this._groups[groupNb];
    if (selectorNb < 0 || selectorNb >= group.selectors.length) {
      return;
    }
    group.removeSelector(selectorNb);
  };
  SelectionPanel2.prototype.addToGroupCheckbox = function(groupNb, label, func, checked) {
    if (func === void 0) {
      func = function() {
      };
    }
    if (checked === void 0) {
      checked = false;
    }
    if (groupNb < 0 || groupNb >= this._groups.length) {
      return;
    }
    var group = this._groups[groupNb];
    group.addCheckbox(label, func, checked);
  };
  SelectionPanel2.prototype.addToGroupRadio = function(groupNb, label, func, checked) {
    if (func === void 0) {
      func = function() {
      };
    }
    if (checked === void 0) {
      checked = false;
    }
    if (groupNb < 0 || groupNb >= this._groups.length) {
      return;
    }
    var group = this._groups[groupNb];
    group.addRadio(label, func, checked);
  };
  SelectionPanel2.prototype.addToGroupSlider = function(groupNb, label, func, unit, min, max, value, onVal) {
    if (func === void 0) {
      func = function() {
      };
    }
    if (unit === void 0) {
      unit = "Units";
    }
    if (min === void 0) {
      min = 0;
    }
    if (max === void 0) {
      max = 0;
    }
    if (value === void 0) {
      value = 0;
    }
    if (onVal === void 0) {
      onVal = function(v) {
        return v | 0;
      };
    }
    if (groupNb < 0 || groupNb >= this._groups.length) {
      return;
    }
    var group = this._groups[groupNb];
    group.addSlider(label, func, unit, min, max, value, onVal);
  };
  return SelectionPanel2;
}(Rectangle);

// node_modules/@babylonjs/gui/2D/controls/scrollViewers/scrollViewerWindow.js
var _ScrollViewerWindow = function(_super) {
  __extends(_ScrollViewerWindow2, _super);
  function _ScrollViewerWindow2(name4) {
    var _this = _super.call(this, name4) || this;
    _this._freezeControls = false;
    _this._bucketWidth = 0;
    _this._bucketHeight = 0;
    _this._buckets = {};
    return _this;
  }
  Object.defineProperty(_ScrollViewerWindow2.prototype, "freezeControls", {
    get: function() {
      return this._freezeControls;
    },
    set: function(value) {
      if (this._freezeControls === value) {
        return;
      }
      if (!value) {
        this._restoreMeasures();
      }
      this._freezeControls = false;
      var textureSize = this.host.getSize();
      var renderWidth = textureSize.width;
      var renderHeight = textureSize.height;
      var context = this.host.getContext();
      var measure = new Measure(0, 0, renderWidth, renderHeight);
      this.host._numLayoutCalls = 0;
      this.host._rootContainer._layout(measure, context);
      if (value) {
        this._updateMeasures();
        if (this._useBuckets()) {
          this._makeBuckets();
        }
      }
      this._freezeControls = value;
      this.host.markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(_ScrollViewerWindow2.prototype, "bucketWidth", {
    get: function() {
      return this._bucketWidth;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(_ScrollViewerWindow2.prototype, "bucketHeight", {
    get: function() {
      return this._bucketHeight;
    },
    enumerable: false,
    configurable: true
  });
  _ScrollViewerWindow2.prototype.setBucketSizes = function(width, height) {
    this._bucketWidth = width;
    this._bucketHeight = height;
    if (this._useBuckets()) {
      if (this._freezeControls) {
        this._makeBuckets();
      }
    } else {
      this._buckets = {};
    }
  };
  _ScrollViewerWindow2.prototype._useBuckets = function() {
    return this._bucketWidth > 0 && this._bucketHeight > 0;
  };
  _ScrollViewerWindow2.prototype._makeBuckets = function() {
    this._buckets = {};
    this._bucketLen = Math.ceil(this.widthInPixels / this._bucketWidth);
    this._dispatchInBuckets(this._children);
    this._oldLeft = null;
    this._oldTop = null;
  };
  _ScrollViewerWindow2.prototype._dispatchInBuckets = function(children) {
    for (var i = 0; i < children.length; ++i) {
      var child = children[i];
      var bStartX = Math.max(0, Math.floor((child._customData._origLeft - this._customData.origLeft) / this._bucketWidth)), bEndX = Math.floor((child._customData._origLeft - this._customData.origLeft + child._currentMeasure.width - 1) / this._bucketWidth), bStartY = Math.max(0, Math.floor((child._customData._origTop - this._customData.origTop) / this._bucketHeight)), bEndY = Math.floor((child._customData._origTop - this._customData.origTop + child._currentMeasure.height - 1) / this._bucketHeight);
      while (bStartY <= bEndY) {
        for (var x = bStartX; x <= bEndX; ++x) {
          var bucket = bStartY * this._bucketLen + x, lstc = this._buckets[bucket];
          if (!lstc) {
            lstc = [];
            this._buckets[bucket] = lstc;
          }
          lstc.push(child);
        }
        bStartY++;
      }
      if (child instanceof Container && child._children.length > 0) {
        this._dispatchInBuckets(child._children);
      }
    }
  };
  _ScrollViewerWindow2.prototype._updateMeasures = function() {
    var left = this.leftInPixels | 0, top = this.topInPixels | 0;
    this._measureForChildren.left -= left;
    this._measureForChildren.top -= top;
    this._currentMeasure.left -= left;
    this._currentMeasure.top -= top;
    this._customData.origLeftForChildren = this._measureForChildren.left;
    this._customData.origTopForChildren = this._measureForChildren.top;
    this._customData.origLeft = this._currentMeasure.left;
    this._customData.origTop = this._currentMeasure.top;
    this._updateChildrenMeasures(this._children, left, top);
  };
  _ScrollViewerWindow2.prototype._updateChildrenMeasures = function(children, left, top) {
    for (var i = 0; i < children.length; ++i) {
      var child = children[i];
      child._currentMeasure.left -= left;
      child._currentMeasure.top -= top;
      child._customData._origLeft = child._currentMeasure.left;
      child._customData._origTop = child._currentMeasure.top;
      if (child instanceof Container && child._children.length > 0) {
        this._updateChildrenMeasures(child._children, left, top);
      }
    }
  };
  _ScrollViewerWindow2.prototype._restoreMeasures = function() {
    var left = this.leftInPixels | 0, top = this.topInPixels | 0;
    this._measureForChildren.left = this._customData.origLeftForChildren + left;
    this._measureForChildren.top = this._customData.origTopForChildren + top;
    this._currentMeasure.left = this._customData.origLeft + left;
    this._currentMeasure.top = this._customData.origTop + top;
  };
  _ScrollViewerWindow2.prototype._getTypeName = function() {
    return "ScrollViewerWindow";
  };
  _ScrollViewerWindow2.prototype._additionalProcessing = function(parentMeasure, context) {
    _super.prototype._additionalProcessing.call(this, parentMeasure, context);
    this._parentMeasure = parentMeasure;
    this._measureForChildren.left = this._currentMeasure.left;
    this._measureForChildren.top = this._currentMeasure.top;
    this._measureForChildren.width = parentMeasure.width;
    this._measureForChildren.height = parentMeasure.height;
  };
  _ScrollViewerWindow2.prototype._layout = function(parentMeasure, context) {
    if (this._freezeControls) {
      this.invalidateRect();
      return false;
    }
    return _super.prototype._layout.call(this, parentMeasure, context);
  };
  _ScrollViewerWindow2.prototype._scrollChildren = function(children, left, top) {
    for (var i = 0; i < children.length; ++i) {
      var child = children[i];
      child._currentMeasure.left = child._customData._origLeft + left;
      child._currentMeasure.top = child._customData._origTop + top;
      child._isClipped = false;
      if (child instanceof Container && child._children.length > 0) {
        this._scrollChildren(child._children, left, top);
      }
    }
  };
  _ScrollViewerWindow2.prototype._scrollChildrenWithBuckets = function(left, top, scrollLeft, scrollTop) {
    var bStartX = Math.max(0, Math.floor(-left / this._bucketWidth)), bEndX = Math.floor((-left + this._parentMeasure.width - 1) / this._bucketWidth), bStartY = Math.max(0, Math.floor(-top / this._bucketHeight)), bEndY = Math.floor((-top + this._parentMeasure.height - 1) / this._bucketHeight);
    while (bStartY <= bEndY) {
      for (var x = bStartX; x <= bEndX; ++x) {
        var bucket = bStartY * this._bucketLen + x, lstc = this._buckets[bucket];
        if (lstc) {
          for (var i = 0; i < lstc.length; ++i) {
            var child = lstc[i];
            child._currentMeasure.left = child._customData._origLeft + scrollLeft;
            child._currentMeasure.top = child._customData._origTop + scrollTop;
            child._isClipped = false;
          }
        }
      }
      bStartY++;
    }
  };
  _ScrollViewerWindow2.prototype._draw = function(context, invalidatedRectangle) {
    if (!this._freezeControls) {
      _super.prototype._draw.call(this, context, invalidatedRectangle);
      return;
    }
    this._localDraw(context);
    if (this.clipChildren) {
      this._clipForChildren(context);
    }
    var left = this.leftInPixels | 0, top = this.topInPixels | 0;
    if (this._useBuckets()) {
      if (this._oldLeft !== null && this._oldTop !== null) {
        this._scrollChildrenWithBuckets(this._oldLeft, this._oldTop, left, top);
        this._scrollChildrenWithBuckets(left, top, left, top);
      } else {
        this._scrollChildren(this._children, left, top);
      }
    } else {
      this._scrollChildren(this._children, left, top);
    }
    this._oldLeft = left;
    this._oldTop = top;
    for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
      var child = _a[_i];
      if (!child._intersectsRect(this._parentMeasure)) {
        continue;
      }
      child._render(context, this._parentMeasure);
    }
  };
  _ScrollViewerWindow2.prototype._postMeasure = function() {
    if (this._freezeControls) {
      _super.prototype._postMeasure.call(this);
      return;
    }
    var maxWidth = this.parentClientWidth;
    var maxHeight = this.parentClientHeight;
    for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
      var child = _a[_i];
      if (!child.isVisible || child.notRenderable) {
        continue;
      }
      if (child.horizontalAlignment === Control.HORIZONTAL_ALIGNMENT_CENTER) {
        child._offsetLeft(this._currentMeasure.left - child._currentMeasure.left);
      }
      if (child.verticalAlignment === Control.VERTICAL_ALIGNMENT_CENTER) {
        child._offsetTop(this._currentMeasure.top - child._currentMeasure.top);
      }
      maxWidth = Math.max(maxWidth, child._currentMeasure.left - this._currentMeasure.left + child._currentMeasure.width + child.paddingRightInPixels);
      maxHeight = Math.max(maxHeight, child._currentMeasure.top - this._currentMeasure.top + child._currentMeasure.height + child.paddingBottomInPixels);
    }
    if (this._currentMeasure.width !== maxWidth) {
      this._width.updateInPlace(maxWidth, ValueAndUnit.UNITMODE_PIXEL);
      this._currentMeasure.width = maxWidth;
      this._rebuildLayout = true;
      this._isDirty = true;
    }
    if (this._currentMeasure.height !== maxHeight) {
      this._height.updateInPlace(maxHeight, ValueAndUnit.UNITMODE_PIXEL);
      this._currentMeasure.height = maxHeight;
      this._rebuildLayout = true;
      this._isDirty = true;
    }
    _super.prototype._postMeasure.call(this);
  };
  return _ScrollViewerWindow2;
}(Container);

// node_modules/@babylonjs/gui/2D/controls/sliders/scrollBar.js
var ScrollBar = function(_super) {
  __extends(ScrollBar2, _super);
  function ScrollBar2(name4) {
    var _this = _super.call(this, name4) || this;
    _this.name = name4;
    _this._background = "black";
    _this._borderColor = "white";
    _this._tempMeasure = new Measure(0, 0, 0, 0);
    return _this;
  }
  Object.defineProperty(ScrollBar2.prototype, "borderColor", {
    get: function() {
      return this._borderColor;
    },
    set: function(value) {
      if (this._borderColor === value) {
        return;
      }
      this._borderColor = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScrollBar2.prototype, "background", {
    get: function() {
      return this._background;
    },
    set: function(value) {
      if (this._background === value) {
        return;
      }
      this._background = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  ScrollBar2.prototype._getTypeName = function() {
    return "Scrollbar";
  };
  ScrollBar2.prototype._getThumbThickness = function() {
    var thumbThickness = 0;
    if (this._thumbWidth.isPixel) {
      thumbThickness = this._thumbWidth.getValue(this._host);
    } else {
      thumbThickness = this._backgroundBoxThickness * this._thumbWidth.getValue(this._host);
    }
    return thumbThickness;
  };
  ScrollBar2.prototype._draw = function(context) {
    context.save();
    this._applyStates(context);
    this._prepareRenderingData("rectangle");
    var left = this._renderLeft;
    var thumbPosition = this._getThumbPosition();
    context.fillStyle = this._background;
    context.fillRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);
    context.fillStyle = this.color;
    if (this.isVertical) {
      this._tempMeasure.left = left - this._effectiveBarOffset;
      this._tempMeasure.top = this._currentMeasure.top + thumbPosition;
      this._tempMeasure.width = this._currentMeasure.width;
      this._tempMeasure.height = this._effectiveThumbThickness;
    } else {
      this._tempMeasure.left = this._currentMeasure.left + thumbPosition;
      this._tempMeasure.top = this._currentMeasure.top;
      this._tempMeasure.width = this._effectiveThumbThickness;
      this._tempMeasure.height = this._currentMeasure.height;
    }
    context.fillRect(this._tempMeasure.left, this._tempMeasure.top, this._tempMeasure.width, this._tempMeasure.height);
    context.restore();
  };
  ScrollBar2.prototype._updateValueFromPointer = function(x, y) {
    if (this.rotation != 0) {
      this._invertTransformMatrix.transformCoordinates(x, y, this._transformedPosition);
      x = this._transformedPosition.x;
      y = this._transformedPosition.y;
    }
    if (this._first) {
      this._first = false;
      this._originX = x;
      this._originY = y;
      if (x < this._tempMeasure.left || x > this._tempMeasure.left + this._tempMeasure.width || y < this._tempMeasure.top || y > this._tempMeasure.top + this._tempMeasure.height) {
        if (this.isVertical) {
          this.value = this.minimum + (1 - (y - this._currentMeasure.top) / this._currentMeasure.height) * (this.maximum - this.minimum);
        } else {
          this.value = this.minimum + (x - this._currentMeasure.left) / this._currentMeasure.width * (this.maximum - this.minimum);
        }
      }
    }
    var delta = 0;
    if (this.isVertical) {
      delta = -((y - this._originY) / (this._currentMeasure.height - this._effectiveThumbThickness));
    } else {
      delta = (x - this._originX) / (this._currentMeasure.width - this._effectiveThumbThickness);
    }
    this.value += delta * (this.maximum - this.minimum);
    this._originX = x;
    this._originY = y;
  };
  ScrollBar2.prototype._onPointerDown = function(target, coordinates, pointerId, buttonIndex, pi) {
    this._first = true;
    return _super.prototype._onPointerDown.call(this, target, coordinates, pointerId, buttonIndex, pi);
  };
  return ScrollBar2;
}(BaseSlider);

// node_modules/@babylonjs/gui/2D/controls/sliders/imageScrollBar.js
var ImageScrollBar = function(_super) {
  __extends(ImageScrollBar2, _super);
  function ImageScrollBar2(name4) {
    var _this = _super.call(this, name4) || this;
    _this.name = name4;
    _this._thumbLength = 0.5;
    _this._thumbHeight = 1;
    _this._barImageHeight = 1;
    _this._tempMeasure = new Measure(0, 0, 0, 0);
    _this.num90RotationInVerticalMode = 1;
    return _this;
  }
  Object.defineProperty(ImageScrollBar2.prototype, "backgroundImage", {
    get: function() {
      return this._backgroundBaseImage;
    },
    set: function(value) {
      var _this = this;
      if (this._backgroundBaseImage === value) {
        return;
      }
      this._backgroundBaseImage = value;
      if (this.isVertical && this.num90RotationInVerticalMode !== 0) {
        if (!value.isLoaded) {
          value.onImageLoadedObservable.addOnce(function() {
            var rotatedValue = value._rotate90(_this.num90RotationInVerticalMode, true);
            _this._backgroundImage = rotatedValue;
            if (!rotatedValue.isLoaded) {
              rotatedValue.onImageLoadedObservable.addOnce(function() {
                _this._markAsDirty();
              });
            }
            _this._markAsDirty();
          });
        } else {
          this._backgroundImage = value._rotate90(this.num90RotationInVerticalMode, true);
          this._markAsDirty();
        }
      } else {
        this._backgroundImage = value;
        if (value && !value.isLoaded) {
          value.onImageLoadedObservable.addOnce(function() {
            _this._markAsDirty();
          });
        }
        this._markAsDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageScrollBar2.prototype, "thumbImage", {
    get: function() {
      return this._thumbBaseImage;
    },
    set: function(value) {
      var _this = this;
      if (this._thumbBaseImage === value) {
        return;
      }
      this._thumbBaseImage = value;
      if (this.isVertical && this.num90RotationInVerticalMode !== 0) {
        if (!value.isLoaded) {
          value.onImageLoadedObservable.addOnce(function() {
            var rotatedValue = value._rotate90(-_this.num90RotationInVerticalMode, true);
            _this._thumbImage = rotatedValue;
            if (!rotatedValue.isLoaded) {
              rotatedValue.onImageLoadedObservable.addOnce(function() {
                _this._markAsDirty();
              });
            }
            _this._markAsDirty();
          });
        } else {
          this._thumbImage = value._rotate90(-this.num90RotationInVerticalMode, true);
          this._markAsDirty();
        }
      } else {
        this._thumbImage = value;
        if (value && !value.isLoaded) {
          value.onImageLoadedObservable.addOnce(function() {
            _this._markAsDirty();
          });
        }
        this._markAsDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageScrollBar2.prototype, "thumbLength", {
    get: function() {
      return this._thumbLength;
    },
    set: function(value) {
      if (this._thumbLength === value) {
        return;
      }
      this._thumbLength = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageScrollBar2.prototype, "thumbHeight", {
    get: function() {
      return this._thumbHeight;
    },
    set: function(value) {
      if (this._thumbLength === value) {
        return;
      }
      this._thumbHeight = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageScrollBar2.prototype, "barImageHeight", {
    get: function() {
      return this._barImageHeight;
    },
    set: function(value) {
      if (this._barImageHeight === value) {
        return;
      }
      this._barImageHeight = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  ImageScrollBar2.prototype._getTypeName = function() {
    return "ImageScrollBar";
  };
  ImageScrollBar2.prototype._getThumbThickness = function() {
    var thumbThickness = 0;
    if (this._thumbWidth.isPixel) {
      thumbThickness = this._thumbWidth.getValue(this._host);
    } else {
      thumbThickness = this._backgroundBoxThickness * this._thumbWidth.getValue(this._host);
    }
    return thumbThickness;
  };
  ImageScrollBar2.prototype._draw = function(context) {
    context.save();
    this._applyStates(context);
    this._prepareRenderingData("rectangle");
    var thumbPosition = this._getThumbPosition();
    var left = this._renderLeft;
    var top = this._renderTop;
    var width = this._renderWidth;
    var height = this._renderHeight;
    if (this._backgroundImage) {
      this._tempMeasure.copyFromFloats(left, top, width, height);
      if (this.isVertical) {
        this._tempMeasure.copyFromFloats(left + width * (1 - this._barImageHeight) * 0.5, this._currentMeasure.top, width * this._barImageHeight, height);
        this._tempMeasure.height += this._effectiveThumbThickness;
        this._backgroundImage._currentMeasure.copyFrom(this._tempMeasure);
      } else {
        this._tempMeasure.copyFromFloats(this._currentMeasure.left, top + height * (1 - this._barImageHeight) * 0.5, width, height * this._barImageHeight);
        this._tempMeasure.width += this._effectiveThumbThickness;
        this._backgroundImage._currentMeasure.copyFrom(this._tempMeasure);
      }
      this._backgroundImage._draw(context);
    }
    if (this.isVertical) {
      this._tempMeasure.copyFromFloats(left - this._effectiveBarOffset + this._currentMeasure.width * (1 - this._thumbHeight) * 0.5, this._currentMeasure.top + thumbPosition, this._currentMeasure.width * this._thumbHeight, this._effectiveThumbThickness);
    } else {
      this._tempMeasure.copyFromFloats(this._currentMeasure.left + thumbPosition, this._currentMeasure.top + this._currentMeasure.height * (1 - this._thumbHeight) * 0.5, this._effectiveThumbThickness, this._currentMeasure.height * this._thumbHeight);
    }
    if (this._thumbImage) {
      this._thumbImage._currentMeasure.copyFrom(this._tempMeasure);
      this._thumbImage._draw(context);
    }
    context.restore();
  };
  ImageScrollBar2.prototype._updateValueFromPointer = function(x, y) {
    if (this.rotation != 0) {
      this._invertTransformMatrix.transformCoordinates(x, y, this._transformedPosition);
      x = this._transformedPosition.x;
      y = this._transformedPosition.y;
    }
    if (this._first) {
      this._first = false;
      this._originX = x;
      this._originY = y;
      if (x < this._tempMeasure.left || x > this._tempMeasure.left + this._tempMeasure.width || y < this._tempMeasure.top || y > this._tempMeasure.top + this._tempMeasure.height) {
        if (this.isVertical) {
          this.value = this.minimum + (1 - (y - this._currentMeasure.top) / this._currentMeasure.height) * (this.maximum - this.minimum);
        } else {
          this.value = this.minimum + (x - this._currentMeasure.left) / this._currentMeasure.width * (this.maximum - this.minimum);
        }
      }
    }
    var delta = 0;
    if (this.isVertical) {
      delta = -((y - this._originY) / (this._currentMeasure.height - this._effectiveThumbThickness));
    } else {
      delta = (x - this._originX) / (this._currentMeasure.width - this._effectiveThumbThickness);
    }
    this.value += delta * (this.maximum - this.minimum);
    this._originX = x;
    this._originY = y;
  };
  ImageScrollBar2.prototype._onPointerDown = function(target, coordinates, pointerId, buttonIndex, pi) {
    this._first = true;
    return _super.prototype._onPointerDown.call(this, target, coordinates, pointerId, buttonIndex, pi);
  };
  return ImageScrollBar2;
}(BaseSlider);

// node_modules/@babylonjs/gui/2D/controls/scrollViewers/scrollViewer.js
var ScrollViewer = function(_super) {
  __extends(ScrollViewer2, _super);
  function ScrollViewer2(name4, isImageBased) {
    var _this = _super.call(this, name4) || this;
    _this._barSize = 20;
    _this._pointerIsOver = false;
    _this._wheelPrecision = 0.05;
    _this._thumbLength = 0.5;
    _this._thumbHeight = 1;
    _this._barImageHeight = 1;
    _this._horizontalBarImageHeight = 1;
    _this._verticalBarImageHeight = 1;
    _this._oldWindowContentsWidth = 0;
    _this._oldWindowContentsHeight = 0;
    _this._forceHorizontalBar = false;
    _this._forceVerticalBar = false;
    _this._useImageBar = isImageBased ? isImageBased : false;
    _this.onDirtyObservable.add(function() {
      _this._horizontalBarSpace.color = _this.color;
      _this._verticalBarSpace.color = _this.color;
      _this._dragSpace.color = _this.color;
    });
    _this.onPointerEnterObservable.add(function() {
      _this._pointerIsOver = true;
    });
    _this.onPointerOutObservable.add(function() {
      _this._pointerIsOver = false;
    });
    _this._grid = new Grid();
    if (_this._useImageBar) {
      _this._horizontalBar = new ImageScrollBar();
      _this._verticalBar = new ImageScrollBar();
    } else {
      _this._horizontalBar = new ScrollBar();
      _this._verticalBar = new ScrollBar();
    }
    _this._window = new _ScrollViewerWindow("scrollViewer_window");
    _this._window.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    _this._window.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
    _this._grid.addColumnDefinition(1);
    _this._grid.addColumnDefinition(0, true);
    _this._grid.addRowDefinition(1);
    _this._grid.addRowDefinition(0, true);
    _super.prototype.addControl.call(_this, _this._grid);
    _this._grid.addControl(_this._window, 0, 0);
    _this._verticalBarSpace = new Rectangle();
    _this._verticalBarSpace.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    _this._verticalBarSpace.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
    _this._verticalBarSpace.thickness = 1;
    _this._grid.addControl(_this._verticalBarSpace, 0, 1);
    _this._addBar(_this._verticalBar, _this._verticalBarSpace, true, Math.PI);
    _this._horizontalBarSpace = new Rectangle();
    _this._horizontalBarSpace.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    _this._horizontalBarSpace.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
    _this._horizontalBarSpace.thickness = 1;
    _this._grid.addControl(_this._horizontalBarSpace, 1, 0);
    _this._addBar(_this._horizontalBar, _this._horizontalBarSpace, false, 0);
    _this._dragSpace = new Rectangle();
    _this._dragSpace.thickness = 1;
    _this._grid.addControl(_this._dragSpace, 1, 1);
    if (!_this._useImageBar) {
      _this.barColor = "grey";
      _this.barBackground = "transparent";
    }
    return _this;
  }
  Object.defineProperty(ScrollViewer2.prototype, "horizontalBar", {
    get: function() {
      return this._horizontalBar;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScrollViewer2.prototype, "verticalBar", {
    get: function() {
      return this._verticalBar;
    },
    enumerable: false,
    configurable: true
  });
  ScrollViewer2.prototype.addControl = function(control) {
    if (!control) {
      return this;
    }
    this._window.addControl(control);
    return this;
  };
  ScrollViewer2.prototype.removeControl = function(control) {
    this._window.removeControl(control);
    return this;
  };
  Object.defineProperty(ScrollViewer2.prototype, "children", {
    get: function() {
      return this._window.children;
    },
    enumerable: false,
    configurable: true
  });
  ScrollViewer2.prototype._flagDescendantsAsMatrixDirty = function() {
    for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
      var child = _a[_i];
      child._markMatrixAsDirty();
    }
  };
  Object.defineProperty(ScrollViewer2.prototype, "freezeControls", {
    get: function() {
      return this._window.freezeControls;
    },
    set: function(value) {
      this._window.freezeControls = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScrollViewer2.prototype, "bucketWidth", {
    get: function() {
      return this._window.bucketWidth;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScrollViewer2.prototype, "bucketHeight", {
    get: function() {
      return this._window.bucketHeight;
    },
    enumerable: false,
    configurable: true
  });
  ScrollViewer2.prototype.setBucketSizes = function(width, height) {
    this._window.setBucketSizes(width, height);
  };
  Object.defineProperty(ScrollViewer2.prototype, "forceHorizontalBar", {
    get: function() {
      return this._forceHorizontalBar;
    },
    set: function(value) {
      this._grid.setRowDefinition(1, value ? this._barSize : 0, true);
      this._horizontalBar.isVisible = value;
      this._forceHorizontalBar = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScrollViewer2.prototype, "forceVerticalBar", {
    get: function() {
      return this._forceVerticalBar;
    },
    set: function(value) {
      this._grid.setColumnDefinition(1, value ? this._barSize : 0, true);
      this._verticalBar.isVisible = value;
      this._forceVerticalBar = value;
    },
    enumerable: false,
    configurable: true
  });
  ScrollViewer2.prototype.resetWindow = function() {
    this._window.width = "100%";
    this._window.height = "100%";
  };
  ScrollViewer2.prototype._getTypeName = function() {
    return "ScrollViewer";
  };
  ScrollViewer2.prototype._buildClientSizes = function() {
    var ratio = this.host.idealRatio;
    this._window.parentClientWidth = this._currentMeasure.width - (this._verticalBar.isVisible || this.forceVerticalBar ? this._barSize * ratio : 0) - 2 * this.thickness;
    this._window.parentClientHeight = this._currentMeasure.height - (this._horizontalBar.isVisible || this.forceHorizontalBar ? this._barSize * ratio : 0) - 2 * this.thickness;
    this._clientWidth = this._window.parentClientWidth;
    this._clientHeight = this._window.parentClientHeight;
  };
  ScrollViewer2.prototype._additionalProcessing = function(parentMeasure, context) {
    _super.prototype._additionalProcessing.call(this, parentMeasure, context);
    this._buildClientSizes();
  };
  ScrollViewer2.prototype._postMeasure = function() {
    _super.prototype._postMeasure.call(this);
    this._updateScroller();
    this._setWindowPosition(false);
  };
  Object.defineProperty(ScrollViewer2.prototype, "wheelPrecision", {
    get: function() {
      return this._wheelPrecision;
    },
    set: function(value) {
      if (this._wheelPrecision === value) {
        return;
      }
      if (value < 0) {
        value = 0;
      }
      if (value > 1) {
        value = 1;
      }
      this._wheelPrecision = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScrollViewer2.prototype, "scrollBackground", {
    get: function() {
      return this._horizontalBarSpace.background;
    },
    set: function(color) {
      if (this._horizontalBarSpace.background === color) {
        return;
      }
      this._horizontalBarSpace.background = color;
      this._verticalBarSpace.background = color;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScrollViewer2.prototype, "barColor", {
    get: function() {
      return this._barColor;
    },
    set: function(color) {
      if (this._barColor === color) {
        return;
      }
      this._barColor = color;
      this._horizontalBar.color = color;
      this._verticalBar.color = color;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScrollViewer2.prototype, "thumbImage", {
    get: function() {
      return this._barImage;
    },
    set: function(value) {
      if (this._barImage === value) {
        return;
      }
      this._barImage = value;
      var hb = this._horizontalBar;
      var vb = this._verticalBar;
      hb.thumbImage = value;
      vb.thumbImage = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScrollViewer2.prototype, "horizontalThumbImage", {
    get: function() {
      return this._horizontalBarImage;
    },
    set: function(value) {
      if (this._horizontalBarImage === value) {
        return;
      }
      this._horizontalBarImage = value;
      var hb = this._horizontalBar;
      hb.thumbImage = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScrollViewer2.prototype, "verticalThumbImage", {
    get: function() {
      return this._verticalBarImage;
    },
    set: function(value) {
      if (this._verticalBarImage === value) {
        return;
      }
      this._verticalBarImage = value;
      var vb = this._verticalBar;
      vb.thumbImage = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScrollViewer2.prototype, "barSize", {
    get: function() {
      return this._barSize;
    },
    set: function(value) {
      if (this._barSize === value) {
        return;
      }
      this._barSize = value;
      this._markAsDirty();
      if (this._horizontalBar.isVisible) {
        this._grid.setRowDefinition(1, this._barSize, true);
      }
      if (this._verticalBar.isVisible) {
        this._grid.setColumnDefinition(1, this._barSize, true);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScrollViewer2.prototype, "thumbLength", {
    get: function() {
      return this._thumbLength;
    },
    set: function(value) {
      if (this._thumbLength === value) {
        return;
      }
      if (value <= 0) {
        value = 0.1;
      }
      if (value > 1) {
        value = 1;
      }
      this._thumbLength = value;
      var hb = this._horizontalBar;
      var vb = this._verticalBar;
      hb.thumbLength = value;
      vb.thumbLength = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScrollViewer2.prototype, "thumbHeight", {
    get: function() {
      return this._thumbHeight;
    },
    set: function(value) {
      if (this._thumbHeight === value) {
        return;
      }
      if (value <= 0) {
        value = 0.1;
      }
      if (value > 1) {
        value = 1;
      }
      this._thumbHeight = value;
      var hb = this._horizontalBar;
      var vb = this._verticalBar;
      hb.thumbHeight = value;
      vb.thumbHeight = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScrollViewer2.prototype, "barImageHeight", {
    get: function() {
      return this._barImageHeight;
    },
    set: function(value) {
      if (this._barImageHeight === value) {
        return;
      }
      if (value <= 0) {
        value = 0.1;
      }
      if (value > 1) {
        value = 1;
      }
      this._barImageHeight = value;
      var hb = this._horizontalBar;
      var vb = this._verticalBar;
      hb.barImageHeight = value;
      vb.barImageHeight = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScrollViewer2.prototype, "horizontalBarImageHeight", {
    get: function() {
      return this._horizontalBarImageHeight;
    },
    set: function(value) {
      if (this._horizontalBarImageHeight === value) {
        return;
      }
      if (value <= 0) {
        value = 0.1;
      }
      if (value > 1) {
        value = 1;
      }
      this._horizontalBarImageHeight = value;
      var hb = this._horizontalBar;
      hb.barImageHeight = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScrollViewer2.prototype, "verticalBarImageHeight", {
    get: function() {
      return this._verticalBarImageHeight;
    },
    set: function(value) {
      if (this._verticalBarImageHeight === value) {
        return;
      }
      if (value <= 0) {
        value = 0.1;
      }
      if (value > 1) {
        value = 1;
      }
      this._verticalBarImageHeight = value;
      var vb = this._verticalBar;
      vb.barImageHeight = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScrollViewer2.prototype, "barBackground", {
    get: function() {
      return this._barBackground;
    },
    set: function(color) {
      if (this._barBackground === color) {
        return;
      }
      this._barBackground = color;
      var hb = this._horizontalBar;
      var vb = this._verticalBar;
      hb.background = color;
      vb.background = color;
      this._dragSpace.background = color;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScrollViewer2.prototype, "barImage", {
    get: function() {
      return this._barBackgroundImage;
    },
    set: function(value) {
      if (this._barBackgroundImage === value) {
      }
      this._barBackgroundImage = value;
      var hb = this._horizontalBar;
      var vb = this._verticalBar;
      hb.backgroundImage = value;
      vb.backgroundImage = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScrollViewer2.prototype, "horizontalBarImage", {
    get: function() {
      return this._horizontalBarBackgroundImage;
    },
    set: function(value) {
      if (this._horizontalBarBackgroundImage === value) {
      }
      this._horizontalBarBackgroundImage = value;
      var hb = this._horizontalBar;
      hb.backgroundImage = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScrollViewer2.prototype, "verticalBarImage", {
    get: function() {
      return this._verticalBarBackgroundImage;
    },
    set: function(value) {
      if (this._verticalBarBackgroundImage === value) {
      }
      this._verticalBarBackgroundImage = value;
      var vb = this._verticalBar;
      vb.backgroundImage = value;
    },
    enumerable: false,
    configurable: true
  });
  ScrollViewer2.prototype._setWindowPosition = function(force) {
    if (force === void 0) {
      force = true;
    }
    var ratio = this.host.idealRatio;
    var windowContentsWidth = this._window._currentMeasure.width;
    var windowContentsHeight = this._window._currentMeasure.height;
    if (!force && this._oldWindowContentsWidth === windowContentsWidth && this._oldWindowContentsHeight === windowContentsHeight) {
      return;
    }
    this._oldWindowContentsWidth = windowContentsWidth;
    this._oldWindowContentsHeight = windowContentsHeight;
    var _endLeft = this._clientWidth - windowContentsWidth;
    var _endTop = this._clientHeight - windowContentsHeight;
    var newLeft = this._horizontalBar.value / ratio * _endLeft + "px";
    var newTop = this._verticalBar.value / ratio * _endTop + "px";
    if (newLeft !== this._window.left) {
      this._window.left = newLeft;
      if (!this.freezeControls) {
        this._rebuildLayout = true;
      }
    }
    if (newTop !== this._window.top) {
      this._window.top = newTop;
      if (!this.freezeControls) {
        this._rebuildLayout = true;
      }
    }
  };
  ScrollViewer2.prototype._updateScroller = function() {
    var windowContentsWidth = this._window._currentMeasure.width;
    var windowContentsHeight = this._window._currentMeasure.height;
    if (this._horizontalBar.isVisible && windowContentsWidth <= this._clientWidth && !this.forceHorizontalBar) {
      this._grid.setRowDefinition(1, 0, true);
      this._horizontalBar.isVisible = false;
      this._horizontalBar.value = 0;
      this._rebuildLayout = true;
    } else if (!this._horizontalBar.isVisible && (windowContentsWidth > this._clientWidth || this.forceHorizontalBar)) {
      this._grid.setRowDefinition(1, this._barSize, true);
      this._horizontalBar.isVisible = true;
      this._rebuildLayout = true;
    }
    if (this._verticalBar.isVisible && windowContentsHeight <= this._clientHeight && !this.forceVerticalBar) {
      this._grid.setColumnDefinition(1, 0, true);
      this._verticalBar.isVisible = false;
      this._verticalBar.value = 0;
      this._rebuildLayout = true;
    } else if (!this._verticalBar.isVisible && (windowContentsHeight > this._clientHeight || this.forceVerticalBar)) {
      this._grid.setColumnDefinition(1, this._barSize, true);
      this._verticalBar.isVisible = true;
      this._rebuildLayout = true;
    }
    this._buildClientSizes();
    var ratio = this.host.idealRatio;
    this._horizontalBar.thumbWidth = this._thumbLength * 0.9 * (this._clientWidth / ratio) + "px";
    this._verticalBar.thumbWidth = this._thumbLength * 0.9 * (this._clientHeight / ratio) + "px";
  };
  ScrollViewer2.prototype._link = function(host) {
    _super.prototype._link.call(this, host);
    this._attachWheel();
  };
  ScrollViewer2.prototype._addBar = function(barControl, barContainer, isVertical, rotation) {
    var _this = this;
    barControl.paddingLeft = 0;
    barControl.width = "100%";
    barControl.height = "100%";
    barControl.barOffset = 0;
    barControl.value = 0;
    barControl.maximum = 1;
    barControl.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    barControl.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;
    barControl.isVertical = isVertical;
    barControl.rotation = rotation;
    barControl.isVisible = false;
    barContainer.addControl(barControl);
    barControl.onValueChangedObservable.add(function(value) {
      _this._setWindowPosition();
    });
  };
  ScrollViewer2.prototype._attachWheel = function() {
    var _this = this;
    if (!this._host || this._onWheelObserver) {
      return;
    }
    this._onWheelObserver = this.onWheelObservable.add(function(pi) {
      if (!_this._pointerIsOver) {
        return;
      }
      if (_this._verticalBar.isVisible == true) {
        if (pi.y < 0 && _this._verticalBar.value > 0) {
          _this._verticalBar.value -= _this._wheelPrecision;
        } else if (pi.y > 0 && _this._verticalBar.value < _this._verticalBar.maximum) {
          _this._verticalBar.value += _this._wheelPrecision;
        }
      }
      if (_this._horizontalBar.isVisible == true) {
        if (pi.x < 0 && _this._horizontalBar.value < _this._horizontalBar.maximum) {
          _this._horizontalBar.value += _this._wheelPrecision;
        } else if (pi.x > 0 && _this._horizontalBar.value > 0) {
          _this._horizontalBar.value -= _this._wheelPrecision;
        }
      }
    });
  };
  ScrollViewer2.prototype._renderHighlightSpecific = function(context) {
    if (!this.isHighlighted) {
      return;
    }
    _super.prototype._renderHighlightSpecific.call(this, context);
    this._grid._renderHighlightSpecific(context);
    context.restore();
  };
  ScrollViewer2.prototype.dispose = function() {
    this.onWheelObservable.remove(this._onWheelObserver);
    this._onWheelObserver = null;
    _super.prototype.dispose.call(this);
  };
  return ScrollViewer2;
}(Rectangle);
_TypeStore.RegisteredTypes["BABYLON.GUI.ScrollViewer"] = ScrollViewer;

// node_modules/@babylonjs/gui/2D/controls/virtualKeyboard.js
var KeyPropertySet = function() {
  function KeyPropertySet2() {
  }
  return KeyPropertySet2;
}();
var VirtualKeyboard = function(_super) {
  __extends(VirtualKeyboard2, _super);
  function VirtualKeyboard2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.onKeyPressObservable = new Observable();
    _this.defaultButtonWidth = "40px";
    _this.defaultButtonHeight = "40px";
    _this.defaultButtonPaddingLeft = "2px";
    _this.defaultButtonPaddingRight = "2px";
    _this.defaultButtonPaddingTop = "2px";
    _this.defaultButtonPaddingBottom = "2px";
    _this.defaultButtonColor = "#DDD";
    _this.defaultButtonBackground = "#070707";
    _this.shiftButtonColor = "#7799FF";
    _this.selectedShiftThickness = 1;
    _this.shiftState = 0;
    _this._currentlyConnectedInputText = null;
    _this._connectedInputTexts = [];
    _this._onKeyPressObserver = null;
    return _this;
  }
  VirtualKeyboard2.prototype._getTypeName = function() {
    return "VirtualKeyboard";
  };
  VirtualKeyboard2.prototype._createKey = function(key, propertySet) {
    var _this = this;
    var button = Button.CreateSimpleButton(key, key);
    button.width = propertySet && propertySet.width ? propertySet.width : this.defaultButtonWidth;
    button.height = propertySet && propertySet.height ? propertySet.height : this.defaultButtonHeight;
    button.color = propertySet && propertySet.color ? propertySet.color : this.defaultButtonColor;
    button.background = propertySet && propertySet.background ? propertySet.background : this.defaultButtonBackground;
    button.paddingLeft = propertySet && propertySet.paddingLeft ? propertySet.paddingLeft : this.defaultButtonPaddingLeft;
    button.paddingRight = propertySet && propertySet.paddingRight ? propertySet.paddingRight : this.defaultButtonPaddingRight;
    button.paddingTop = propertySet && propertySet.paddingTop ? propertySet.paddingTop : this.defaultButtonPaddingTop;
    button.paddingBottom = propertySet && propertySet.paddingBottom ? propertySet.paddingBottom : this.defaultButtonPaddingBottom;
    button.thickness = 0;
    button.isFocusInvisible = true;
    button.shadowColor = this.shadowColor;
    button.shadowBlur = this.shadowBlur;
    button.shadowOffsetX = this.shadowOffsetX;
    button.shadowOffsetY = this.shadowOffsetY;
    button.onPointerUpObservable.add(function() {
      _this.onKeyPressObservable.notifyObservers(key);
    });
    return button;
  };
  VirtualKeyboard2.prototype.addKeysRow = function(keys, propertySets) {
    var panel = new StackPanel();
    panel.isVertical = false;
    panel.isFocusInvisible = true;
    var maxKey = null;
    for (var i = 0; i < keys.length; i++) {
      var properties = null;
      if (propertySets && propertySets.length === keys.length) {
        properties = propertySets[i];
      }
      var key = this._createKey(keys[i], properties);
      if (!maxKey || key.heightInPixels > maxKey.heightInPixels) {
        maxKey = key;
      }
      panel.addControl(key);
    }
    panel.height = maxKey ? maxKey.height : this.defaultButtonHeight;
    this.addControl(panel);
  };
  VirtualKeyboard2.prototype.applyShiftState = function(shiftState) {
    if (!this.children) {
      return;
    }
    for (var i = 0; i < this.children.length; i++) {
      var row = this.children[i];
      if (!row || !row.children) {
        continue;
      }
      var rowContainer = row;
      for (var j = 0; j < rowContainer.children.length; j++) {
        var button = rowContainer.children[j];
        if (!button || !button.children[0]) {
          continue;
        }
        var button_tblock = button.children[0];
        if (button_tblock.text === "\u21E7") {
          button.color = shiftState ? this.shiftButtonColor : this.defaultButtonColor;
          button.thickness = shiftState > 1 ? this.selectedShiftThickness : 0;
        }
        button_tblock.text = shiftState > 0 ? button_tblock.text.toUpperCase() : button_tblock.text.toLowerCase();
      }
    }
  };
  Object.defineProperty(VirtualKeyboard2.prototype, "connectedInputText", {
    get: function() {
      return this._currentlyConnectedInputText;
    },
    enumerable: false,
    configurable: true
  });
  VirtualKeyboard2.prototype.connect = function(input) {
    var _this = this;
    var inputTextAlreadyConnected = this._connectedInputTexts.some(function(a) {
      return a.input === input;
    });
    if (inputTextAlreadyConnected) {
      return;
    }
    if (this._onKeyPressObserver === null) {
      this._onKeyPressObserver = this.onKeyPressObservable.add(function(key) {
        if (!_this._currentlyConnectedInputText) {
          return;
        }
        _this._currentlyConnectedInputText._host.focusedControl = _this._currentlyConnectedInputText;
        switch (key) {
          case "\u21E7":
            _this.shiftState++;
            if (_this.shiftState > 2) {
              _this.shiftState = 0;
            }
            _this.applyShiftState(_this.shiftState);
            return;
          case "\u2190":
            _this._currentlyConnectedInputText.processKey(8);
            return;
          case "\u21B5":
            _this._currentlyConnectedInputText.processKey(13);
            return;
        }
        _this._currentlyConnectedInputText.processKey(-1, _this.shiftState ? key.toUpperCase() : key);
        if (_this.shiftState === 1) {
          _this.shiftState = 0;
          _this.applyShiftState(_this.shiftState);
        }
      });
    }
    this.isVisible = false;
    this._currentlyConnectedInputText = input;
    input._connectedVirtualKeyboard = this;
    var onFocusObserver = input.onFocusObservable.add(function() {
      _this._currentlyConnectedInputText = input;
      input._connectedVirtualKeyboard = _this;
      _this.isVisible = true;
    });
    var onBlurObserver = input.onBlurObservable.add(function() {
      input._connectedVirtualKeyboard = null;
      _this._currentlyConnectedInputText = null;
      _this.isVisible = false;
    });
    this._connectedInputTexts.push({
      input,
      onBlurObserver,
      onFocusObserver
    });
  };
  VirtualKeyboard2.prototype.disconnect = function(input) {
    var _this = this;
    if (input) {
      var filtered = this._connectedInputTexts.filter(function(a) {
        return a.input === input;
      });
      if (filtered.length === 1) {
        this._removeConnectedInputObservables(filtered[0]);
        this._connectedInputTexts = this._connectedInputTexts.filter(function(a) {
          return a.input !== input;
        });
        if (this._currentlyConnectedInputText === input) {
          this._currentlyConnectedInputText = null;
        }
      }
    } else {
      this._connectedInputTexts.forEach(function(connectedInputText) {
        _this._removeConnectedInputObservables(connectedInputText);
      });
      this._connectedInputTexts = [];
    }
    if (this._connectedInputTexts.length === 0) {
      this._currentlyConnectedInputText = null;
      this.onKeyPressObservable.remove(this._onKeyPressObserver);
      this._onKeyPressObserver = null;
    }
  };
  VirtualKeyboard2.prototype._removeConnectedInputObservables = function(connectedInputText) {
    connectedInputText.input._connectedVirtualKeyboard = null;
    connectedInputText.input.onFocusObservable.remove(connectedInputText.onFocusObserver);
    connectedInputText.input.onBlurObservable.remove(connectedInputText.onBlurObserver);
  };
  VirtualKeyboard2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this.disconnect();
  };
  VirtualKeyboard2.CreateDefaultLayout = function(name4) {
    var returnValue = new VirtualKeyboard2(name4);
    returnValue.addKeysRow(["1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "\u2190"]);
    returnValue.addKeysRow(["q", "w", "e", "r", "t", "y", "u", "i", "o", "p"]);
    returnValue.addKeysRow(["a", "s", "d", "f", "g", "h", "j", "k", "l", ";", "'", "\u21B5"]);
    returnValue.addKeysRow(["\u21E7", "z", "x", "c", "v", "b", "n", "m", ",", ".", "/"]);
    returnValue.addKeysRow([" "], [{ width: "200px" }]);
    return returnValue;
  };
  return VirtualKeyboard2;
}(StackPanel);
_TypeStore.RegisteredTypes["BABYLON.GUI.VirtualKeyboard"] = VirtualKeyboard;

// node_modules/@babylonjs/gui/2D/controls/displayGrid.js
var DisplayGrid = function(_super) {
  __extends(DisplayGrid2, _super);
  function DisplayGrid2(name4) {
    var _this = _super.call(this, name4) || this;
    _this.name = name4;
    _this._cellWidth = 20;
    _this._cellHeight = 20;
    _this._minorLineTickness = 1;
    _this._minorLineColor = "DarkGray";
    _this._majorLineTickness = 2;
    _this._majorLineColor = "White";
    _this._majorLineFrequency = 5;
    _this._background = "Black";
    _this._displayMajorLines = true;
    _this._displayMinorLines = true;
    return _this;
  }
  Object.defineProperty(DisplayGrid2.prototype, "displayMinorLines", {
    get: function() {
      return this._displayMinorLines;
    },
    set: function(value) {
      if (this._displayMinorLines === value) {
        return;
      }
      this._displayMinorLines = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayGrid2.prototype, "displayMajorLines", {
    get: function() {
      return this._displayMajorLines;
    },
    set: function(value) {
      if (this._displayMajorLines === value) {
        return;
      }
      this._displayMajorLines = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayGrid2.prototype, "background", {
    get: function() {
      return this._background;
    },
    set: function(value) {
      if (this._background === value) {
        return;
      }
      this._background = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayGrid2.prototype, "cellWidth", {
    get: function() {
      return this._cellWidth;
    },
    set: function(value) {
      this._cellWidth = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayGrid2.prototype, "cellHeight", {
    get: function() {
      return this._cellHeight;
    },
    set: function(value) {
      this._cellHeight = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayGrid2.prototype, "minorLineTickness", {
    get: function() {
      return this._minorLineTickness;
    },
    set: function(value) {
      this._minorLineTickness = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayGrid2.prototype, "minorLineColor", {
    get: function() {
      return this._minorLineColor;
    },
    set: function(value) {
      this._minorLineColor = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayGrid2.prototype, "majorLineTickness", {
    get: function() {
      return this._majorLineTickness;
    },
    set: function(value) {
      this._majorLineTickness = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayGrid2.prototype, "majorLineColor", {
    get: function() {
      return this._majorLineColor;
    },
    set: function(value) {
      this._majorLineColor = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayGrid2.prototype, "majorLineFrequency", {
    get: function() {
      return this._majorLineFrequency;
    },
    set: function(value) {
      this._majorLineFrequency = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  DisplayGrid2.prototype._draw = function(context, invalidatedRectangle) {
    context.save();
    this._applyStates(context);
    if (this._isEnabled) {
      if (this._background) {
        context.fillStyle = this._background;
        context.fillRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);
      }
      var cellCountX = this._currentMeasure.width / this._cellWidth;
      var cellCountY = this._currentMeasure.height / this._cellHeight;
      var left = this._currentMeasure.left + this._currentMeasure.width / 2;
      var top_1 = this._currentMeasure.top + this._currentMeasure.height / 2;
      if (this._displayMinorLines) {
        context.strokeStyle = this._minorLineColor;
        context.lineWidth = this._minorLineTickness;
        for (var x = -cellCountX / 2; x < cellCountX / 2; x++) {
          var cellX = left + x * this.cellWidth;
          context.beginPath();
          context.moveTo(cellX, this._currentMeasure.top);
          context.lineTo(cellX, this._currentMeasure.top + this._currentMeasure.height);
          context.stroke();
        }
        for (var y = -cellCountY / 2; y < cellCountY / 2; y++) {
          var cellY = top_1 + y * this.cellHeight;
          context.beginPath();
          context.moveTo(this._currentMeasure.left, cellY);
          context.lineTo(this._currentMeasure.left + this._currentMeasure.width, cellY);
          context.stroke();
        }
      }
      if (this._displayMajorLines) {
        context.strokeStyle = this._majorLineColor;
        context.lineWidth = this._majorLineTickness;
        for (var x = -cellCountX / 2 + this._majorLineFrequency; x < cellCountX / 2; x += this._majorLineFrequency) {
          var cellX = left + x * this.cellWidth;
          context.beginPath();
          context.moveTo(cellX, this._currentMeasure.top);
          context.lineTo(cellX, this._currentMeasure.top + this._currentMeasure.height);
          context.stroke();
        }
        for (var y = -cellCountY / 2 + this._majorLineFrequency; y < cellCountY / 2; y += this._majorLineFrequency) {
          var cellY = top_1 + y * this.cellHeight;
          context.moveTo(this._currentMeasure.left, cellY);
          context.lineTo(this._currentMeasure.left + this._currentMeasure.width, cellY);
          context.closePath();
          context.stroke();
        }
      }
    }
    context.restore();
  };
  DisplayGrid2.prototype._getTypeName = function() {
    return "DisplayGrid";
  };
  return DisplayGrid2;
}(Control);
_TypeStore.RegisteredTypes["BABYLON.GUI.DisplayGrid"] = DisplayGrid;

// node_modules/@babylonjs/gui/2D/controls/sliders/imageBasedSlider.js
var ImageBasedSlider = function(_super) {
  __extends(ImageBasedSlider2, _super);
  function ImageBasedSlider2(name4) {
    var _this = _super.call(this, name4) || this;
    _this.name = name4;
    _this._tempMeasure = new Measure(0, 0, 0, 0);
    return _this;
  }
  Object.defineProperty(ImageBasedSlider2.prototype, "displayThumb", {
    get: function() {
      return this._displayThumb && this.thumbImage != null;
    },
    set: function(value) {
      if (this._displayThumb === value) {
        return;
      }
      this._displayThumb = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageBasedSlider2.prototype, "backgroundImage", {
    get: function() {
      return this._backgroundImage;
    },
    set: function(value) {
      var _this = this;
      if (this._backgroundImage === value) {
        return;
      }
      this._backgroundImage = value;
      if (value && !value.isLoaded) {
        value.onImageLoadedObservable.addOnce(function() {
          return _this._markAsDirty();
        });
      }
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageBasedSlider2.prototype, "valueBarImage", {
    get: function() {
      return this._valueBarImage;
    },
    set: function(value) {
      var _this = this;
      if (this._valueBarImage === value) {
        return;
      }
      this._valueBarImage = value;
      if (value && !value.isLoaded) {
        value.onImageLoadedObservable.addOnce(function() {
          return _this._markAsDirty();
        });
      }
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageBasedSlider2.prototype, "thumbImage", {
    get: function() {
      return this._thumbImage;
    },
    set: function(value) {
      var _this = this;
      if (this._thumbImage === value) {
        return;
      }
      this._thumbImage = value;
      if (value && !value.isLoaded) {
        value.onImageLoadedObservable.addOnce(function() {
          return _this._markAsDirty();
        });
      }
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  ImageBasedSlider2.prototype._getTypeName = function() {
    return "ImageBasedSlider";
  };
  ImageBasedSlider2.prototype._draw = function(context, invalidatedRectangle) {
    context.save();
    this._applyStates(context);
    this._prepareRenderingData("rectangle");
    var thumbPosition = this._getThumbPosition();
    var left = this._renderLeft;
    var top = this._renderTop;
    var width = this._renderWidth;
    var height = this._renderHeight;
    if (this._backgroundImage) {
      this._tempMeasure.copyFromFloats(left, top, width, height);
      if (this.isThumbClamped && this.displayThumb) {
        if (this.isVertical) {
          this._tempMeasure.height += this._effectiveThumbThickness;
        } else {
          this._tempMeasure.width += this._effectiveThumbThickness;
        }
      }
      this._backgroundImage._currentMeasure.copyFrom(this._tempMeasure);
      this._backgroundImage._draw(context);
    }
    if (this._valueBarImage) {
      if (this.isVertical) {
        if (this.isThumbClamped && this.displayThumb) {
          this._tempMeasure.copyFromFloats(left, top + thumbPosition, width, height - thumbPosition + this._effectiveThumbThickness);
        } else {
          this._tempMeasure.copyFromFloats(left, top + thumbPosition, width, height - thumbPosition);
        }
      } else {
        if (this.isThumbClamped && this.displayThumb) {
          this._tempMeasure.copyFromFloats(left, top, thumbPosition + this._effectiveThumbThickness / 2, height);
        } else {
          this._tempMeasure.copyFromFloats(left, top, thumbPosition, height);
        }
      }
      this._valueBarImage._currentMeasure.copyFrom(this._tempMeasure);
      this._valueBarImage._draw(context);
    }
    if (this.displayThumb) {
      if (this.isVertical) {
        this._tempMeasure.copyFromFloats(left - this._effectiveBarOffset, this._currentMeasure.top + thumbPosition, this._currentMeasure.width, this._effectiveThumbThickness);
      } else {
        this._tempMeasure.copyFromFloats(this._currentMeasure.left + thumbPosition, this._currentMeasure.top, this._effectiveThumbThickness, this._currentMeasure.height);
      }
      this._thumbImage._currentMeasure.copyFrom(this._tempMeasure);
      this._thumbImage._draw(context);
    }
    context.restore();
  };
  return ImageBasedSlider2;
}(BaseSlider);
_TypeStore.RegisteredTypes["BABYLON.GUI.ImageBasedSlider"] = ImageBasedSlider;

// node_modules/@babylonjs/gui/2D/controls/statics.js
var name = "Statics";
Control.AddHeader = function(control, text, size, options) {
  var panel = new StackPanel("panel");
  var isHorizontal = options ? options.isHorizontal : true;
  var controlFirst = options ? options.controlFirst : true;
  panel.isVertical = !isHorizontal;
  var header = new TextBlock("header");
  header.text = text;
  header.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
  if (isHorizontal) {
    header.width = size;
  } else {
    header.height = size;
  }
  if (controlFirst) {
    panel.addControl(control);
    panel.addControl(header);
    header.paddingLeft = "5px";
  } else {
    panel.addControl(header);
    panel.addControl(control);
    header.paddingRight = "5px";
  }
  header.shadowBlur = control.shadowBlur;
  header.shadowColor = control.shadowColor;
  header.shadowOffsetX = control.shadowOffsetX;
  header.shadowOffsetY = control.shadowOffsetY;
  return panel;
};

// node_modules/@babylonjs/gui/2D/style.js
var Style = function() {
  function Style2(host) {
    this._fontFamily = "Arial";
    this._fontStyle = "";
    this._fontWeight = "";
    this._fontSize = new ValueAndUnit(18, ValueAndUnit.UNITMODE_PIXEL, false);
    this.onChangedObservable = new Observable();
    this._host = host;
  }
  Object.defineProperty(Style2.prototype, "fontSize", {
    get: function() {
      return this._fontSize.toString(this._host);
    },
    set: function(value) {
      if (this._fontSize.toString(this._host) === value) {
        return;
      }
      if (this._fontSize.fromString(value)) {
        this.onChangedObservable.notifyObservers(this);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Style2.prototype, "fontFamily", {
    get: function() {
      return this._fontFamily;
    },
    set: function(value) {
      if (this._fontFamily === value) {
        return;
      }
      this._fontFamily = value;
      this.onChangedObservable.notifyObservers(this);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Style2.prototype, "fontStyle", {
    get: function() {
      return this._fontStyle;
    },
    set: function(value) {
      if (this._fontStyle === value) {
        return;
      }
      this._fontStyle = value;
      this.onChangedObservable.notifyObservers(this);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Style2.prototype, "fontWeight", {
    get: function() {
      return this._fontWeight;
    },
    set: function(value) {
      if (this._fontWeight === value) {
        return;
      }
      this._fontWeight = value;
      this.onChangedObservable.notifyObservers(this);
    },
    enumerable: false,
    configurable: true
  });
  Style2.prototype.dispose = function() {
    this.onChangedObservable.clear();
  };
  return Style2;
}();

// node_modules/@babylonjs/gui/2D/advancedDynamicTexture.js
var AdvancedDynamicTexture = function(_super) {
  __extends(AdvancedDynamicTexture2, _super);
  function AdvancedDynamicTexture2(name4, width, height, scene, generateMipMaps, samplingMode, invertY) {
    if (width === void 0) {
      width = 0;
    }
    if (height === void 0) {
      height = 0;
    }
    if (generateMipMaps === void 0) {
      generateMipMaps = false;
    }
    if (samplingMode === void 0) {
      samplingMode = Texture.NEAREST_SAMPLINGMODE;
    }
    var _this = _super.call(this, name4, { width, height }, scene, generateMipMaps, samplingMode, Constants.TEXTUREFORMAT_RGBA, invertY) || this;
    _this._isDirty = false;
    _this._rootContainer = new Container("root");
    _this._lastControlOver = {};
    _this._lastControlDown = {};
    _this._capturingControl = {};
    _this._linkedControls = new Array();
    _this._isFullscreen = false;
    _this._fullscreenViewport = new Viewport(0, 0, 1, 1);
    _this._idealWidth = 0;
    _this._idealHeight = 0;
    _this._useSmallestIdeal = false;
    _this._renderAtIdealSize = false;
    _this._blockNextFocusCheck = false;
    _this._renderScale = 1;
    _this._cursorChanged = false;
    _this._defaultMousePointerId = 0;
    _this._numLayoutCalls = 0;
    _this._numRenderCalls = 0;
    _this._clipboardData = "";
    _this.onClipboardObservable = new Observable();
    _this.onControlPickedObservable = new Observable();
    _this.onBeginLayoutObservable = new Observable();
    _this.onEndLayoutObservable = new Observable();
    _this.onBeginRenderObservable = new Observable();
    _this.onEndRenderObservable = new Observable();
    _this.premulAlpha = false;
    _this.applyYInversionOnUpdate = true;
    _this._useInvalidateRectOptimization = true;
    _this._invalidatedRectangle = null;
    _this._clearMeasure = new Measure(0, 0, 0, 0);
    _this.onClipboardCopy = function(rawEvt) {
      var evt = rawEvt;
      var ev = new ClipboardInfo(ClipboardEventTypes.COPY, evt);
      _this.onClipboardObservable.notifyObservers(ev);
      evt.preventDefault();
    };
    _this.onClipboardCut = function(rawEvt) {
      var evt = rawEvt;
      var ev = new ClipboardInfo(ClipboardEventTypes.CUT, evt);
      _this.onClipboardObservable.notifyObservers(ev);
      evt.preventDefault();
    };
    _this.onClipboardPaste = function(rawEvt) {
      var evt = rawEvt;
      var ev = new ClipboardInfo(ClipboardEventTypes.PASTE, evt);
      _this.onClipboardObservable.notifyObservers(ev);
      evt.preventDefault();
    };
    scene = _this.getScene();
    if (!scene || !_this._texture) {
      return _this;
    }
    _this._rootElement = scene.getEngine().getInputElement();
    _this._renderObserver = scene.onBeforeCameraRenderObservable.add(function(camera) {
      return _this._checkUpdate(camera);
    });
    _this._preKeyboardObserver = scene.onPreKeyboardObservable.add(function(info) {
      if (!_this._focusedControl) {
        return;
      }
      if (info.type === KeyboardEventTypes.KEYDOWN) {
        _this._focusedControl.processKeyboard(info.event);
      }
      info.skipOnPointerObservable = true;
    });
    _this._rootContainer._link(_this);
    _this.hasAlpha = true;
    if (!width || !height) {
      _this._resizeObserver = scene.getEngine().onResizeObservable.add(function() {
        return _this._onResize();
      });
      _this._onResize();
    }
    _this._texture.isReady = true;
    return _this;
  }
  Object.defineProperty(AdvancedDynamicTexture2.prototype, "numLayoutCalls", {
    get: function() {
      return this._numLayoutCalls;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AdvancedDynamicTexture2.prototype, "numRenderCalls", {
    get: function() {
      return this._numRenderCalls;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AdvancedDynamicTexture2.prototype, "renderScale", {
    get: function() {
      return this._renderScale;
    },
    set: function(value) {
      if (value === this._renderScale) {
        return;
      }
      this._renderScale = value;
      this._onResize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AdvancedDynamicTexture2.prototype, "background", {
    get: function() {
      return this._background;
    },
    set: function(value) {
      if (this._background === value) {
        return;
      }
      this._background = value;
      this.markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AdvancedDynamicTexture2.prototype, "idealWidth", {
    get: function() {
      return this._idealWidth;
    },
    set: function(value) {
      if (this._idealWidth === value) {
        return;
      }
      this._idealWidth = value;
      this.markAsDirty();
      this._rootContainer._markAllAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AdvancedDynamicTexture2.prototype, "idealHeight", {
    get: function() {
      return this._idealHeight;
    },
    set: function(value) {
      if (this._idealHeight === value) {
        return;
      }
      this._idealHeight = value;
      this.markAsDirty();
      this._rootContainer._markAllAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AdvancedDynamicTexture2.prototype, "useSmallestIdeal", {
    get: function() {
      return this._useSmallestIdeal;
    },
    set: function(value) {
      if (this._useSmallestIdeal === value) {
        return;
      }
      this._useSmallestIdeal = value;
      this.markAsDirty();
      this._rootContainer._markAllAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AdvancedDynamicTexture2.prototype, "renderAtIdealSize", {
    get: function() {
      return this._renderAtIdealSize;
    },
    set: function(value) {
      if (this._renderAtIdealSize === value) {
        return;
      }
      this._renderAtIdealSize = value;
      this._onResize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AdvancedDynamicTexture2.prototype, "idealRatio", {
    get: function() {
      var rwidth = 0;
      var rheight = 0;
      if (this._idealWidth) {
        rwidth = this.getSize().width / this._idealWidth;
      }
      if (this._idealHeight) {
        rheight = this.getSize().height / this._idealHeight;
      }
      if (this._useSmallestIdeal && this._idealWidth && this._idealHeight) {
        return window.innerWidth < window.innerHeight ? rwidth : rheight;
      }
      if (this._idealWidth) {
        return rwidth;
      }
      if (this._idealHeight) {
        return rheight;
      }
      return 1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AdvancedDynamicTexture2.prototype, "layer", {
    get: function() {
      return this._layerToDispose;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AdvancedDynamicTexture2.prototype, "rootContainer", {
    get: function() {
      return this._rootContainer;
    },
    enumerable: false,
    configurable: true
  });
  AdvancedDynamicTexture2.prototype.getChildren = function() {
    return [this._rootContainer];
  };
  AdvancedDynamicTexture2.prototype.getDescendants = function(directDescendantsOnly, predicate) {
    return this._rootContainer.getDescendants(directDescendantsOnly, predicate);
  };
  Object.defineProperty(AdvancedDynamicTexture2.prototype, "focusedControl", {
    get: function() {
      return this._focusedControl;
    },
    set: function(control) {
      if (this._focusedControl == control) {
        return;
      }
      if (this._focusedControl) {
        this._focusedControl.onBlur();
      }
      if (control) {
        control.onFocus();
      }
      this._focusedControl = control;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AdvancedDynamicTexture2.prototype, "isForeground", {
    get: function() {
      if (!this.layer) {
        return true;
      }
      return !this.layer.isBackground;
    },
    set: function(value) {
      if (!this.layer) {
        return;
      }
      if (this.layer.isBackground === !value) {
        return;
      }
      this.layer.isBackground = !value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AdvancedDynamicTexture2.prototype, "clipboardData", {
    get: function() {
      return this._clipboardData;
    },
    set: function(value) {
      this._clipboardData = value;
    },
    enumerable: false,
    configurable: true
  });
  AdvancedDynamicTexture2.prototype.getClassName = function() {
    return "AdvancedDynamicTexture";
  };
  AdvancedDynamicTexture2.prototype.executeOnAllControls = function(func, container) {
    if (!container) {
      container = this._rootContainer;
    }
    func(container);
    for (var _i = 0, _a = container.children; _i < _a.length; _i++) {
      var child = _a[_i];
      if (child.children) {
        this.executeOnAllControls(func, child);
        continue;
      }
      func(child);
    }
  };
  Object.defineProperty(AdvancedDynamicTexture2.prototype, "useInvalidateRectOptimization", {
    get: function() {
      return this._useInvalidateRectOptimization;
    },
    set: function(value) {
      this._useInvalidateRectOptimization = value;
    },
    enumerable: false,
    configurable: true
  });
  AdvancedDynamicTexture2.prototype.invalidateRect = function(invalidMinX, invalidMinY, invalidMaxX, invalidMaxY) {
    if (!this._useInvalidateRectOptimization) {
      return;
    }
    if (!this._invalidatedRectangle) {
      this._invalidatedRectangle = new Measure(invalidMinX, invalidMinY, invalidMaxX - invalidMinX + 1, invalidMaxY - invalidMinY + 1);
    } else {
      var maxX = Math.ceil(Math.max(this._invalidatedRectangle.left + this._invalidatedRectangle.width - 1, invalidMaxX));
      var maxY = Math.ceil(Math.max(this._invalidatedRectangle.top + this._invalidatedRectangle.height - 1, invalidMaxY));
      this._invalidatedRectangle.left = Math.floor(Math.min(this._invalidatedRectangle.left, invalidMinX));
      this._invalidatedRectangle.top = Math.floor(Math.min(this._invalidatedRectangle.top, invalidMinY));
      this._invalidatedRectangle.width = maxX - this._invalidatedRectangle.left + 1;
      this._invalidatedRectangle.height = maxY - this._invalidatedRectangle.top + 1;
    }
  };
  AdvancedDynamicTexture2.prototype.markAsDirty = function() {
    this._isDirty = true;
  };
  AdvancedDynamicTexture2.prototype.createStyle = function() {
    return new Style(this);
  };
  AdvancedDynamicTexture2.prototype.addControl = function(control) {
    this._rootContainer.addControl(control);
    return this;
  };
  AdvancedDynamicTexture2.prototype.removeControl = function(control) {
    this._rootContainer.removeControl(control);
    return this;
  };
  AdvancedDynamicTexture2.prototype.dispose = function() {
    var scene = this.getScene();
    if (!scene) {
      return;
    }
    this._rootElement = null;
    scene.onBeforeCameraRenderObservable.remove(this._renderObserver);
    if (this._resizeObserver) {
      scene.getEngine().onResizeObservable.remove(this._resizeObserver);
    }
    if (this._pointerMoveObserver) {
      scene.onPrePointerObservable.remove(this._pointerMoveObserver);
    }
    if (this._pointerObserver) {
      scene.onPointerObservable.remove(this._pointerObserver);
    }
    if (this._preKeyboardObserver) {
      scene.onPreKeyboardObservable.remove(this._preKeyboardObserver);
    }
    if (this._canvasPointerOutObserver) {
      scene.getEngine().onCanvasPointerOutObservable.remove(this._canvasPointerOutObserver);
    }
    if (this._canvasBlurObserver) {
      scene.getEngine().onCanvasBlurObservable.remove(this._canvasBlurObserver);
    }
    if (this._layerToDispose) {
      this._layerToDispose.texture = null;
      this._layerToDispose.dispose();
      this._layerToDispose = null;
    }
    this._rootContainer.dispose();
    this.onClipboardObservable.clear();
    this.onControlPickedObservable.clear();
    this.onBeginRenderObservable.clear();
    this.onEndRenderObservable.clear();
    this.onBeginLayoutObservable.clear();
    this.onEndLayoutObservable.clear();
    _super.prototype.dispose.call(this);
  };
  AdvancedDynamicTexture2.prototype._onResize = function() {
    var scene = this.getScene();
    if (!scene) {
      return;
    }
    var engine = scene.getEngine();
    var textureSize = this.getSize();
    var renderWidth = engine.getRenderWidth() * this._renderScale;
    var renderHeight = engine.getRenderHeight() * this._renderScale;
    if (this._renderAtIdealSize) {
      if (this._idealWidth) {
        renderHeight = renderHeight * this._idealWidth / renderWidth;
        renderWidth = this._idealWidth;
      } else if (this._idealHeight) {
        renderWidth = renderWidth * this._idealHeight / renderHeight;
        renderHeight = this._idealHeight;
      }
    }
    if (textureSize.width !== renderWidth || textureSize.height !== renderHeight) {
      this.scaleTo(renderWidth, renderHeight);
      this.markAsDirty();
      if (this._idealWidth || this._idealHeight) {
        this._rootContainer._markAllAsDirty();
      }
    }
    this.invalidateRect(0, 0, textureSize.width - 1, textureSize.height - 1);
  };
  AdvancedDynamicTexture2.prototype._getGlobalViewport = function(scene) {
    var engine = scene.getEngine();
    return this._fullscreenViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());
  };
  AdvancedDynamicTexture2.prototype.getProjectedPosition = function(position, worldMatrix) {
    var scene = this.getScene();
    if (!scene) {
      return Vector2.Zero();
    }
    var globalViewport = this._getGlobalViewport(scene);
    var projectedPosition = Vector3.Project(position, worldMatrix, scene.getTransformMatrix(), globalViewport);
    projectedPosition.scaleInPlace(this.renderScale);
    return new Vector2(projectedPosition.x, projectedPosition.y);
  };
  AdvancedDynamicTexture2.prototype.getProjectedPositionWithZ = function(position, worldMatrix) {
    var scene = this.getScene();
    if (!scene) {
      return Vector3.Zero();
    }
    var globalViewport = this._getGlobalViewport(scene);
    var projectedPosition = Vector3.Project(position, worldMatrix, scene.getTransformMatrix(), globalViewport);
    projectedPosition.scaleInPlace(this.renderScale);
    return new Vector3(projectedPosition.x, projectedPosition.y, projectedPosition.z);
  };
  AdvancedDynamicTexture2.prototype._checkUpdate = function(camera) {
    if (this._layerToDispose) {
      if ((camera.layerMask & this._layerToDispose.layerMask) === 0) {
        return;
      }
    }
    if (this._isFullscreen && this._linkedControls.length) {
      var scene = this.getScene();
      if (!scene) {
        return;
      }
      var globalViewport = this._getGlobalViewport(scene);
      var _loop_1 = function(control2) {
        if (!control2.isVisible) {
          return "continue";
        }
        var mesh = control2._linkedMesh;
        if (!mesh || mesh.isDisposed()) {
          Tools.SetImmediate(function() {
            control2.linkWithMesh(null);
          });
          return "continue";
        }
        var position = mesh.getBoundingInfo ? mesh.getBoundingInfo().boundingSphere.center : Vector3.ZeroReadOnly;
        var projectedPosition = Vector3.Project(position, mesh.getWorldMatrix(), scene.getTransformMatrix(), globalViewport);
        if (projectedPosition.z < 0 || projectedPosition.z > 1) {
          control2.notRenderable = true;
          return "continue";
        }
        control2.notRenderable = false;
        projectedPosition.scaleInPlace(this_1.renderScale);
        control2._moveToProjectedPosition(projectedPosition);
      };
      var this_1 = this;
      for (var _i = 0, _a = this._linkedControls; _i < _a.length; _i++) {
        var control = _a[_i];
        _loop_1(control);
      }
    }
    if (!this._isDirty && !this._rootContainer.isDirty) {
      return;
    }
    this._isDirty = false;
    this._render();
    this.update(this.applyYInversionOnUpdate, this.premulAlpha);
  };
  AdvancedDynamicTexture2.prototype._render = function() {
    var textureSize = this.getSize();
    var renderWidth = textureSize.width;
    var renderHeight = textureSize.height;
    var context = this.getContext();
    context.font = "18px Arial";
    context.strokeStyle = "white";
    this.onBeginLayoutObservable.notifyObservers(this);
    var measure = new Measure(0, 0, renderWidth, renderHeight);
    this._numLayoutCalls = 0;
    this._rootContainer._layout(measure, context);
    this.onEndLayoutObservable.notifyObservers(this);
    this._isDirty = false;
    if (this._invalidatedRectangle) {
      this._clearMeasure.copyFrom(this._invalidatedRectangle);
    } else {
      this._clearMeasure.copyFromFloats(0, 0, renderWidth, renderHeight);
    }
    context.clearRect(this._clearMeasure.left, this._clearMeasure.top, this._clearMeasure.width, this._clearMeasure.height);
    if (this._background) {
      context.save();
      context.fillStyle = this._background;
      context.fillRect(this._clearMeasure.left, this._clearMeasure.top, this._clearMeasure.width, this._clearMeasure.height);
      context.restore();
    }
    this.onBeginRenderObservable.notifyObservers(this);
    this._numRenderCalls = 0;
    this._rootContainer._render(context, this._invalidatedRectangle);
    this.onEndRenderObservable.notifyObservers(this);
    this._invalidatedRectangle = null;
  };
  AdvancedDynamicTexture2.prototype._changeCursor = function(cursor) {
    if (this._rootElement) {
      this._rootElement.style.cursor = cursor;
      this._cursorChanged = true;
    }
  };
  AdvancedDynamicTexture2.prototype._registerLastControlDown = function(control, pointerId) {
    this._lastControlDown[pointerId] = control;
    this.onControlPickedObservable.notifyObservers(control);
  };
  AdvancedDynamicTexture2.prototype._doPicking = function(x, y, pi, type, pointerId, buttonIndex, deltaX, deltaY) {
    var scene = this.getScene();
    if (!scene) {
      return;
    }
    var engine = scene.getEngine();
    var textureSize = this.getSize();
    if (this._isFullscreen) {
      var camera = scene.cameraToUseForPointers || scene.activeCamera;
      var viewport = camera.viewport;
      x = x * (textureSize.width / (engine.getRenderWidth() * viewport.width));
      y = y * (textureSize.height / (engine.getRenderHeight() * viewport.height));
    }
    if (this._capturingControl[pointerId]) {
      this._capturingControl[pointerId]._processObservables(type, x, y, pi, pointerId, buttonIndex);
      return;
    }
    this._cursorChanged = false;
    if (!this._rootContainer._processPicking(x, y, pi, type, pointerId, buttonIndex, deltaX, deltaY)) {
      this._changeCursor("");
      if (type === PointerEventTypes.POINTERMOVE) {
        if (this._lastControlOver[pointerId]) {
          this._lastControlOver[pointerId]._onPointerOut(this._lastControlOver[pointerId], pi);
          delete this._lastControlOver[pointerId];
        }
      }
    }
    if (!this._cursorChanged) {
      this._changeCursor("");
    }
    this._manageFocus();
  };
  AdvancedDynamicTexture2.prototype._cleanControlAfterRemovalFromList = function(list, control) {
    for (var pointerId in list) {
      if (!list.hasOwnProperty(pointerId)) {
        continue;
      }
      var lastControlOver = list[pointerId];
      if (lastControlOver === control) {
        delete list[pointerId];
      }
    }
  };
  AdvancedDynamicTexture2.prototype._cleanControlAfterRemoval = function(control) {
    this._cleanControlAfterRemovalFromList(this._lastControlDown, control);
    this._cleanControlAfterRemovalFromList(this._lastControlOver, control);
  };
  AdvancedDynamicTexture2.prototype.attach = function() {
    var _this = this;
    var scene = this.getScene();
    if (!scene) {
      return;
    }
    var tempViewport = new Viewport(0, 0, 0, 0);
    this._pointerMoveObserver = scene.onPrePointerObservable.add(function(pi, state) {
      if (scene.isPointerCaptured(pi.event.pointerId)) {
        return;
      }
      if (pi.type !== PointerEventTypes.POINTERMOVE && pi.type !== PointerEventTypes.POINTERUP && pi.type !== PointerEventTypes.POINTERDOWN && pi.type !== PointerEventTypes.POINTERWHEEL) {
        return;
      }
      if (!scene) {
        return;
      }
      if (pi.type === PointerEventTypes.POINTERMOVE && pi.event.pointerId) {
        _this._defaultMousePointerId = pi.event.pointerId;
      }
      var camera = scene.cameraToUseForPointers || scene.activeCamera;
      var engine = scene.getEngine();
      if (!camera) {
        tempViewport.x = 0;
        tempViewport.y = 0;
        tempViewport.width = engine.getRenderWidth();
        tempViewport.height = engine.getRenderHeight();
      } else {
        camera.viewport.toGlobalToRef(engine.getRenderWidth(), engine.getRenderHeight(), tempViewport);
      }
      var x = scene.pointerX / engine.getHardwareScalingLevel() - tempViewport.x;
      var y = scene.pointerY / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - tempViewport.y - tempViewport.height);
      _this._shouldBlockPointer = false;
      var pointerId = pi.event.pointerId || _this._defaultMousePointerId;
      _this._doPicking(x, y, pi, pi.type, pointerId, pi.event.button, pi.event.deltaX, pi.event.deltaY);
      if (_this._shouldBlockPointer) {
        pi.skipOnPointerObservable = _this._shouldBlockPointer;
      }
    });
    this._attachToOnPointerOut(scene);
    this._attachToOnBlur(scene);
  };
  AdvancedDynamicTexture2.prototype.registerClipboardEvents = function() {
    self.addEventListener("copy", this.onClipboardCopy, false);
    self.addEventListener("cut", this.onClipboardCut, false);
    self.addEventListener("paste", this.onClipboardPaste, false);
  };
  AdvancedDynamicTexture2.prototype.unRegisterClipboardEvents = function() {
    self.removeEventListener("copy", this.onClipboardCopy);
    self.removeEventListener("cut", this.onClipboardCut);
    self.removeEventListener("paste", this.onClipboardPaste);
  };
  AdvancedDynamicTexture2.prototype.attachToMesh = function(mesh, supportPointerMove) {
    var _this = this;
    if (supportPointerMove === void 0) {
      supportPointerMove = true;
    }
    var scene = this.getScene();
    if (!scene) {
      return;
    }
    this._pointerObserver = scene.onPointerObservable.add(function(pi, state) {
      if (pi.type !== PointerEventTypes.POINTERMOVE && pi.type !== PointerEventTypes.POINTERUP && pi.type !== PointerEventTypes.POINTERDOWN) {
        return;
      }
      var pointerId = pi.event.pointerId || _this._defaultMousePointerId;
      if (pi.pickInfo && pi.pickInfo.hit && pi.pickInfo.pickedMesh === mesh) {
        var uv = pi.pickInfo.getTextureCoordinates();
        if (uv) {
          var size = _this.getSize();
          _this._doPicking(uv.x * size.width, (_this.applyYInversionOnUpdate ? 1 - uv.y : uv.y) * size.height, pi, pi.type, pointerId, pi.event.button);
        }
      } else if (pi.type === PointerEventTypes.POINTERUP) {
        if (_this._lastControlDown[pointerId]) {
          _this._lastControlDown[pointerId]._forcePointerUp(pointerId);
        }
        delete _this._lastControlDown[pointerId];
        if (_this.focusedControl) {
          var friendlyControls = _this.focusedControl.keepsFocusWith();
          var canMoveFocus = true;
          if (friendlyControls) {
            for (var _i = 0, friendlyControls_1 = friendlyControls; _i < friendlyControls_1.length; _i++) {
              var control = friendlyControls_1[_i];
              if (_this === control._host) {
                continue;
              }
              var otherHost = control._host;
              if (otherHost._lastControlOver[pointerId] && otherHost._lastControlOver[pointerId].isAscendant(control)) {
                canMoveFocus = false;
                break;
              }
            }
          }
          if (canMoveFocus) {
            _this.focusedControl = null;
          }
        }
      } else if (pi.type === PointerEventTypes.POINTERMOVE) {
        if (_this._lastControlOver[pointerId]) {
          _this._lastControlOver[pointerId]._onPointerOut(_this._lastControlOver[pointerId], pi, true);
        }
        delete _this._lastControlOver[pointerId];
      }
    });
    mesh.enablePointerMoveEvents = supportPointerMove;
    this._attachToOnPointerOut(scene);
    this._attachToOnBlur(scene);
  };
  AdvancedDynamicTexture2.prototype.moveFocusToControl = function(control) {
    this.focusedControl = control;
    this._lastPickedControl = control;
    this._blockNextFocusCheck = true;
  };
  AdvancedDynamicTexture2.prototype._manageFocus = function() {
    if (this._blockNextFocusCheck) {
      this._blockNextFocusCheck = false;
      this._lastPickedControl = this._focusedControl;
      return;
    }
    if (this._focusedControl) {
      if (this._focusedControl !== this._lastPickedControl) {
        if (this._lastPickedControl.isFocusInvisible) {
          return;
        }
        this.focusedControl = null;
      }
    }
  };
  AdvancedDynamicTexture2.prototype._attachToOnPointerOut = function(scene) {
    var _this = this;
    this._canvasPointerOutObserver = scene.getEngine().onCanvasPointerOutObservable.add(function(pointerEvent) {
      if (_this._lastControlOver[pointerEvent.pointerId]) {
        _this._lastControlOver[pointerEvent.pointerId]._onPointerOut(_this._lastControlOver[pointerEvent.pointerId], null);
      }
      delete _this._lastControlOver[pointerEvent.pointerId];
      if (_this._lastControlDown[pointerEvent.pointerId] && _this._lastControlDown[pointerEvent.pointerId] !== _this._capturingControl[pointerEvent.pointerId]) {
        _this._lastControlDown[pointerEvent.pointerId]._forcePointerUp();
        delete _this._lastControlDown[pointerEvent.pointerId];
      }
    });
  };
  AdvancedDynamicTexture2.prototype._attachToOnBlur = function(scene) {
    var _this = this;
    this._canvasBlurObserver = scene.getEngine().onCanvasBlurObservable.add(function(pointerEvent) {
      Object.entries(_this._lastControlDown).forEach(function(_a) {
        var key = _a[0], value = _a[1];
        value._onCanvasBlur();
      });
      _this._lastControlDown = {};
    });
  };
  AdvancedDynamicTexture2.CreateForMesh = function(mesh, width, height, supportPointerMove, onlyAlphaTesting, invertY) {
    if (width === void 0) {
      width = 1024;
    }
    if (height === void 0) {
      height = 1024;
    }
    if (supportPointerMove === void 0) {
      supportPointerMove = true;
    }
    if (onlyAlphaTesting === void 0) {
      onlyAlphaTesting = false;
    }
    var result = new AdvancedDynamicTexture2(mesh.name + " AdvancedDynamicTexture", width, height, mesh.getScene(), true, Texture.TRILINEAR_SAMPLINGMODE, invertY);
    var material = new StandardMaterial("AdvancedDynamicTextureMaterial", mesh.getScene());
    material.backFaceCulling = false;
    material.diffuseColor = Color3.Black();
    material.specularColor = Color3.Black();
    if (onlyAlphaTesting) {
      material.diffuseTexture = result;
      material.emissiveTexture = result;
      result.hasAlpha = true;
    } else {
      material.emissiveTexture = result;
      material.opacityTexture = result;
    }
    mesh.material = material;
    result.attachToMesh(mesh, supportPointerMove);
    return result;
  };
  AdvancedDynamicTexture2.CreateForMeshTexture = function(mesh, width, height, supportPointerMove, invertY) {
    if (width === void 0) {
      width = 1024;
    }
    if (height === void 0) {
      height = 1024;
    }
    if (supportPointerMove === void 0) {
      supportPointerMove = true;
    }
    var result = new AdvancedDynamicTexture2(mesh.name + " AdvancedDynamicTexture", width, height, mesh.getScene(), true, Texture.TRILINEAR_SAMPLINGMODE, invertY);
    result.attachToMesh(mesh, supportPointerMove);
    return result;
  };
  AdvancedDynamicTexture2.CreateFullscreenUI = function(name4, foreground, scene, sampling) {
    if (foreground === void 0) {
      foreground = true;
    }
    if (scene === void 0) {
      scene = null;
    }
    if (sampling === void 0) {
      sampling = Texture.BILINEAR_SAMPLINGMODE;
    }
    var result = new AdvancedDynamicTexture2(name4, 0, 0, scene, false, sampling);
    var layer = new Layer(name4 + "_layer", null, scene, !foreground);
    layer.texture = result;
    result._layerToDispose = layer;
    result._isFullscreen = true;
    result.attach();
    return result;
  };
  return AdvancedDynamicTexture2;
}(DynamicTexture);

// node_modules/@babylonjs/gui/2D/adtInstrumentation.js
var AdvancedDynamicTextureInstrumentation = function() {
  function AdvancedDynamicTextureInstrumentation2(texture) {
    this.texture = texture;
    this._captureRenderTime = false;
    this._renderTime = new PerfCounter();
    this._captureLayoutTime = false;
    this._layoutTime = new PerfCounter();
    this._onBeginRenderObserver = null;
    this._onEndRenderObserver = null;
    this._onBeginLayoutObserver = null;
    this._onEndLayoutObserver = null;
  }
  Object.defineProperty(AdvancedDynamicTextureInstrumentation2.prototype, "renderTimeCounter", {
    get: function() {
      return this._renderTime;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AdvancedDynamicTextureInstrumentation2.prototype, "layoutTimeCounter", {
    get: function() {
      return this._layoutTime;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AdvancedDynamicTextureInstrumentation2.prototype, "captureRenderTime", {
    get: function() {
      return this._captureRenderTime;
    },
    set: function(value) {
      var _this = this;
      if (value === this._captureRenderTime) {
        return;
      }
      this._captureRenderTime = value;
      if (value) {
        this._onBeginRenderObserver = this.texture.onBeginRenderObservable.add(function() {
          _this._renderTime.beginMonitoring();
        });
        this._onEndRenderObserver = this.texture.onEndRenderObservable.add(function() {
          _this._renderTime.endMonitoring(true);
        });
      } else {
        this.texture.onBeginRenderObservable.remove(this._onBeginRenderObserver);
        this._onBeginRenderObserver = null;
        this.texture.onEndRenderObservable.remove(this._onEndRenderObserver);
        this._onEndRenderObserver = null;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AdvancedDynamicTextureInstrumentation2.prototype, "captureLayoutTime", {
    get: function() {
      return this._captureLayoutTime;
    },
    set: function(value) {
      var _this = this;
      if (value === this._captureLayoutTime) {
        return;
      }
      this._captureLayoutTime = value;
      if (value) {
        this._onBeginLayoutObserver = this.texture.onBeginLayoutObservable.add(function() {
          _this._layoutTime.beginMonitoring();
        });
        this._onEndLayoutObserver = this.texture.onEndLayoutObservable.add(function() {
          _this._layoutTime.endMonitoring(true);
        });
      } else {
        this.texture.onBeginLayoutObservable.remove(this._onBeginLayoutObserver);
        this._onBeginLayoutObserver = null;
        this.texture.onEndLayoutObservable.remove(this._onEndLayoutObserver);
        this._onEndLayoutObserver = null;
      }
    },
    enumerable: false,
    configurable: true
  });
  AdvancedDynamicTextureInstrumentation2.prototype.dispose = function() {
    this.texture.onBeginRenderObservable.remove(this._onBeginRenderObserver);
    this._onBeginRenderObserver = null;
    this.texture.onEndRenderObservable.remove(this._onEndRenderObserver);
    this._onEndRenderObserver = null;
    this.texture.onBeginLayoutObservable.remove(this._onBeginLayoutObserver);
    this._onBeginLayoutObserver = null;
    this.texture.onEndLayoutObservable.remove(this._onEndLayoutObserver);
    this._onEndLayoutObserver = null;
    this.texture = null;
  };
  return AdvancedDynamicTextureInstrumentation2;
}();

// node_modules/@babylonjs/gui/2D/xmlLoader.js
var XmlLoader = function() {
  function XmlLoader2(parentClass) {
    if (parentClass === void 0) {
      parentClass = null;
    }
    this._nodes = {};
    this._nodeTypes = {
      element: 1,
      attribute: 2,
      text: 3
    };
    this._isLoaded = false;
    this._objectAttributes = {
      "textHorizontalAlignment": 1,
      "textVerticalAlignment": 2,
      "horizontalAlignment": 3,
      "verticalAlignment": 4,
      "stretch": 5
    };
    if (parentClass) {
      this._parentClass = parentClass;
    }
  }
  XmlLoader2.prototype._getChainElement = function(attributeValue) {
    var element = window;
    if (this._parentClass) {
      element = this._parentClass;
    }
    var value = attributeValue;
    value = value.split(".");
    for (var i = 0; i < value.length; i++) {
      element = element[value[i]];
    }
    return element;
  };
  XmlLoader2.prototype._getClassAttribute = function(attributeName) {
    var attribute = attributeName.split(".");
    var className = _TypeStore.GetClass("BABYLON.GUI." + attribute[0]);
    return className[attribute[1]];
  };
  XmlLoader2.prototype._createGuiElement = function(node, parent, linkParent) {
    if (linkParent === void 0) {
      linkParent = true;
    }
    try {
      var className = _TypeStore.GetClass("BABYLON.GUI." + node.nodeName);
      var guiNode = new className();
      if (parent && linkParent) {
        parent.addControl(guiNode);
      }
      for (var i = 0; i < node.attributes.length; i++) {
        if (node.attributes[i].name.toLowerCase().includes("datasource")) {
          continue;
        }
        if (node.attributes[i].name.toLowerCase().includes("observable")) {
          var element = this._getChainElement(node.attributes[i].value);
          guiNode[node.attributes[i].name].add(element);
          continue;
        } else if (node.attributes[i].name == "linkWithMesh") {
          if (this._parentClass) {
            guiNode.linkWithMesh(this._parentClass[node.attributes[i].value]);
          } else {
            guiNode.linkWithMesh(window[node.attributes[i].value]);
          }
        } else if (node.attributes[i].value.startsWith("{{") && node.attributes[i].value.endsWith("}}")) {
          var element = this._getChainElement(node.attributes[i].value.substring(2, node.attributes[i].value.length - 2));
          guiNode[node.attributes[i].name] = element;
        } else if (!this._objectAttributes[node.attributes[i].name]) {
          if (node.attributes[i].value == "true" || node.attributes[i].value == "false") {
            guiNode[node.attributes[i].name] = node.attributes[i].value == "true";
          } else {
            guiNode[node.attributes[i].name] = !isNaN(Number(node.attributes[i].value)) ? Number(node.attributes[i].value) : node.attributes[i].value;
          }
        } else {
          guiNode[node.attributes[i].name] = this._getClassAttribute(node.attributes[i].value);
        }
      }
      if (!node.attributes.getNamedItem("id")) {
        this._nodes[node.nodeName + Object.keys(this._nodes).length + "_gen"] = guiNode;
        return guiNode;
      }
      var id = node.attributes.getNamedItem("id").value;
      if (id.startsWith("{{") && id.endsWith("}}")) {
        id = this._getChainElement(id.substring(2, id.length - 2));
      }
      if (!this._nodes[id]) {
        this._nodes[id] = guiNode;
      } else {
        throw "XmlLoader Exception : Duplicate ID, every element should have an unique ID attribute";
      }
      return guiNode;
    } catch (e) {
      throw "XmlLoader Exception : Error parsing Control " + node.nodeName + "," + e + ".";
    }
  };
  XmlLoader2.prototype._parseGrid = function(node, guiNode, parent) {
    var width;
    var height;
    var columns;
    var rows = node.children;
    var cells;
    var isPixel = false;
    var cellNode;
    var rowNumber = -1;
    var columnNumber = -1;
    var totalColumnsNumber = 0;
    for (var i = 0; i < rows.length; i++) {
      if (rows[i].nodeType != this._nodeTypes.element) {
        continue;
      }
      if (rows[i].nodeName != "Row") {
        throw "XmlLoader Exception : Expecting Row node, received " + rows[i].nodeName;
      }
      rowNumber += 1;
      columns = rows[i].children;
      if (!rows[i].attributes.getNamedItem("height")) {
        throw "XmlLoader Exception : Height must be defined for grid rows";
      }
      height = Number(rows[i].attributes.getNamedItem("height").nodeValue);
      isPixel = rows[i].attributes.getNamedItem("isPixel") ? JSON.parse(rows[i].attributes.getNamedItem("isPixel").nodeValue) : false;
      guiNode.addRowDefinition(height, isPixel);
      for (var j = 0; j < columns.length; j++) {
        if (columns[j].nodeType != this._nodeTypes.element) {
          continue;
        }
        if (columns[j].nodeName != "Column") {
          throw "XmlLoader Exception : Expecting Column node, received " + columns[j].nodeName;
        }
        columnNumber += 1;
        if (rowNumber > 0 && columnNumber > totalColumnsNumber) {
          throw "XmlLoader Exception : In the Grid element, the number of columns is defined in the first row, do not add more columns in the subsequent rows.";
        }
        if (rowNumber == 0) {
          if (!columns[j].attributes.getNamedItem("width")) {
            throw "XmlLoader Exception : Width must be defined for all the grid columns in the first row";
          }
          width = Number(columns[j].attributes.getNamedItem("width").nodeValue);
          isPixel = columns[j].attributes.getNamedItem("isPixel") ? JSON.parse(columns[j].attributes.getNamedItem("isPixel").nodeValue) : false;
          guiNode.addColumnDefinition(width, isPixel);
        }
        cells = columns[j].children;
        for (var k = 0; k < cells.length; k++) {
          if (cells[k].nodeType != this._nodeTypes.element) {
            continue;
          }
          cellNode = this._createGuiElement(cells[k], guiNode, false);
          guiNode.addControl(cellNode, rowNumber, columnNumber);
          if (cells[k].firstChild) {
            this._parseXml(cells[k].firstChild, cellNode);
          }
        }
      }
      if (rowNumber == 0) {
        totalColumnsNumber = columnNumber;
      }
      columnNumber = -1;
    }
    if (node.nextSibling) {
      this._parseXml(node.nextSibling, parent);
    }
  };
  XmlLoader2.prototype._parseElement = function(node, guiNode, parent) {
    if (node.firstChild) {
      this._parseXml(node.firstChild, guiNode);
    }
    if (node.nextSibling) {
      this._parseXml(node.nextSibling, parent);
    }
  };
  XmlLoader2.prototype._prepareSourceElement = function(node, guiNode, variable, source, iterator) {
    if (this._parentClass) {
      this._parentClass[variable] = source[iterator];
    } else {
      window[variable] = source[iterator];
    }
    if (node.firstChild) {
      this._parseXml(node.firstChild, guiNode, true);
    }
  };
  XmlLoader2.prototype._parseElementsFromSource = function(node, guiNode, parent) {
    var dataSource = node.attributes.getNamedItem("dataSource").value;
    if (!dataSource.includes(" in ")) {
      throw "XmlLoader Exception : Malformed XML, Data Source must include an in";
    } else {
      var isArray = true;
      var splittedSource = dataSource.split(" in ");
      if (splittedSource.length < 2) {
        throw "XmlLoader Exception : Malformed XML, Data Source must an iterator and a source";
      }
      var source = splittedSource[1];
      if (source.startsWith("{") && source.endsWith("}")) {
        isArray = false;
      }
      if (!isArray || source.startsWith("[") && source.endsWith("]")) {
        source = source.substring(1, source.length - 1);
      }
      if (this._parentClass) {
        source = this._parentClass[source];
      } else {
        source = window[source];
      }
      if (isArray) {
        for (var i = 0; i < source.length; i++) {
          this._prepareSourceElement(node, guiNode, splittedSource[0], source, i);
        }
      } else {
        for (var i in source) {
          this._prepareSourceElement(node, guiNode, splittedSource[0], source, i);
        }
      }
      if (node.nextSibling) {
        this._parseXml(node.nextSibling, parent);
      }
    }
  };
  XmlLoader2.prototype._parseXml = function(node, parent, generated) {
    if (generated === void 0) {
      generated = false;
    }
    if (node.nodeType != this._nodeTypes.element) {
      if (node.nextSibling) {
        this._parseXml(node.nextSibling, parent, generated);
      }
      return;
    }
    if (generated) {
      node.setAttribute("id", parent.id + (parent._children.length + 1));
    }
    var guiNode = this._createGuiElement(node, parent);
    if (node.nodeName == "Grid") {
      this._parseGrid(node, guiNode, parent);
    } else if (!node.attributes.getNamedItem("dataSource")) {
      this._parseElement(node, guiNode, parent);
    } else {
      this._parseElementsFromSource(node, guiNode, parent);
    }
  };
  XmlLoader2.prototype.isLoaded = function() {
    return this._isLoaded;
  };
  XmlLoader2.prototype.getNodeById = function(id) {
    return this._nodes[id];
  };
  XmlLoader2.prototype.getNodes = function() {
    return this._nodes;
  };
  XmlLoader2.prototype.loadLayout = function(xmlFile, rootNode, callback) {
    var xhttp = new XMLHttpRequest();
    xhttp.onreadystatechange = function() {
      if (xhttp.readyState == 4 && xhttp.status == 200) {
        if (!xhttp.responseXML) {
          throw "XmlLoader Exception : XML file is malformed or corrupted.";
        }
        var xmlDoc = xhttp.responseXML.documentElement;
        this._parseXml(xmlDoc.firstChild, rootNode);
        this._isLoaded = true;
        if (callback) {
          callback();
        }
      }
    }.bind(this);
    xhttp.open("GET", xmlFile, true);
    xhttp.send();
  };
  return XmlLoader2;
}();

// node_modules/@babylonjs/gui/3D/vector3WithInfo.js
var Vector3WithInfo = function(_super) {
  __extends(Vector3WithInfo2, _super);
  function Vector3WithInfo2(source, buttonIndex) {
    if (buttonIndex === void 0) {
      buttonIndex = 0;
    }
    var _this = _super.call(this, source.x, source.y, source.z) || this;
    _this.buttonIndex = buttonIndex;
    return _this;
  }
  return Vector3WithInfo2;
}(Vector3);

// node_modules/@babylonjs/gui/3D/controls/control3D.js
var Control3D = function() {
  function Control3D2(name4) {
    this.name = name4;
    this._downCount = 0;
    this._enterCount = -1;
    this._downPointerIds = {};
    this._isVisible = true;
    this.onPointerMoveObservable = new Observable();
    this.onPointerOutObservable = new Observable();
    this.onPointerDownObservable = new Observable();
    this.onPointerUpObservable = new Observable();
    this.onPointerClickObservable = new Observable();
    this.onPointerEnterObservable = new Observable();
    this._behaviors = new Array();
  }
  Object.defineProperty(Control3D2.prototype, "position", {
    get: function() {
      if (!this._node) {
        return Vector3.Zero();
      }
      return this._node.position;
    },
    set: function(value) {
      if (!this._node) {
        return;
      }
      this._node.position = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control3D2.prototype, "scaling", {
    get: function() {
      if (!this._node) {
        return new Vector3(1, 1, 1);
      }
      return this._node.scaling;
    },
    set: function(value) {
      if (!this._node) {
        return;
      }
      this._node.scaling = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control3D2.prototype, "behaviors", {
    get: function() {
      return this._behaviors;
    },
    enumerable: false,
    configurable: true
  });
  Control3D2.prototype.addBehavior = function(behavior) {
    var _this = this;
    var index = this._behaviors.indexOf(behavior);
    if (index !== -1) {
      return this;
    }
    behavior.init();
    var scene = this._host.scene;
    if (scene.isLoading) {
      scene.onDataLoadedObservable.addOnce(function() {
        behavior.attach(_this);
      });
    } else {
      behavior.attach(this);
    }
    this._behaviors.push(behavior);
    return this;
  };
  Control3D2.prototype.removeBehavior = function(behavior) {
    var index = this._behaviors.indexOf(behavior);
    if (index === -1) {
      return this;
    }
    this._behaviors[index].detach();
    this._behaviors.splice(index, 1);
    return this;
  };
  Control3D2.prototype.getBehaviorByName = function(name4) {
    for (var _i = 0, _a = this._behaviors; _i < _a.length; _i++) {
      var behavior = _a[_i];
      if (behavior.name === name4) {
        return behavior;
      }
    }
    return null;
  };
  Object.defineProperty(Control3D2.prototype, "isVisible", {
    get: function() {
      return this._isVisible;
    },
    set: function(value) {
      if (this._isVisible === value) {
        return;
      }
      this._isVisible = value;
      var mesh = this.mesh;
      if (mesh) {
        mesh.setEnabled(value);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control3D2.prototype, "typeName", {
    get: function() {
      return this._getTypeName();
    },
    enumerable: false,
    configurable: true
  });
  Control3D2.prototype.getClassName = function() {
    return this._getTypeName();
  };
  Control3D2.prototype._getTypeName = function() {
    return "Control3D";
  };
  Object.defineProperty(Control3D2.prototype, "node", {
    get: function() {
      return this._node;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Control3D2.prototype, "mesh", {
    get: function() {
      if (this._node instanceof AbstractMesh) {
        return this._node;
      }
      return null;
    },
    enumerable: false,
    configurable: true
  });
  Control3D2.prototype.linkToTransformNode = function(node) {
    if (this._node) {
      this._node.parent = node;
    }
    return this;
  };
  Control3D2.prototype._prepareNode = function(scene) {
    if (!this._node) {
      this._node = this._createNode(scene);
      if (!this.node) {
        return;
      }
      this._node.metadata = this;
      this._node.position = this.position;
      this._node.scaling = this.scaling;
      var mesh = this.mesh;
      if (mesh) {
        mesh.isPickable = true;
        this._affectMaterial(mesh);
      }
    }
  };
  Control3D2.prototype._createNode = function(scene) {
    return null;
  };
  Control3D2.prototype._affectMaterial = function(mesh) {
    mesh.material = null;
  };
  Control3D2.prototype._onPointerMove = function(target, coordinates) {
    this.onPointerMoveObservable.notifyObservers(coordinates, -1, target, this);
  };
  Control3D2.prototype._onPointerEnter = function(target) {
    if (this._enterCount > 0) {
      return false;
    }
    if (this._enterCount === -1) {
      this._enterCount = 0;
    }
    this._enterCount++;
    this.onPointerEnterObservable.notifyObservers(this, -1, target, this);
    if (this.pointerEnterAnimation) {
      this.pointerEnterAnimation();
    }
    return true;
  };
  Control3D2.prototype._onPointerOut = function(target) {
    this._enterCount = 0;
    this.onPointerOutObservable.notifyObservers(this, -1, target, this);
    if (this.pointerOutAnimation) {
      this.pointerOutAnimation();
    }
  };
  Control3D2.prototype._onPointerDown = function(target, coordinates, pointerId, buttonIndex) {
    if (this._downCount !== 0) {
      this._downCount++;
      return false;
    }
    this._downCount++;
    this._downPointerIds[pointerId] = true;
    this.onPointerDownObservable.notifyObservers(new Vector3WithInfo(coordinates, buttonIndex), -1, target, this);
    if (this.pointerDownAnimation) {
      this.pointerDownAnimation();
    }
    return true;
  };
  Control3D2.prototype._onPointerUp = function(target, coordinates, pointerId, buttonIndex, notifyClick) {
    this._downCount--;
    delete this._downPointerIds[pointerId];
    if (this._downCount < 0) {
      this._downCount = 0;
      return;
    }
    if (this._downCount == 0) {
      if (notifyClick && (this._enterCount > 0 || this._enterCount === -1)) {
        this.onPointerClickObservable.notifyObservers(new Vector3WithInfo(coordinates, buttonIndex), -1, target, this);
      }
      this.onPointerUpObservable.notifyObservers(new Vector3WithInfo(coordinates, buttonIndex), -1, target, this);
      if (this.pointerUpAnimation) {
        this.pointerUpAnimation();
      }
    }
  };
  Control3D2.prototype.forcePointerUp = function(pointerId) {
    if (pointerId === void 0) {
      pointerId = null;
    }
    if (pointerId !== null) {
      this._onPointerUp(this, Vector3.Zero(), pointerId, 0, true);
    } else {
      for (var key in this._downPointerIds) {
        this._onPointerUp(this, Vector3.Zero(), +key, 0, true);
      }
      if (this._downCount > 0) {
        this._downCount = 1;
        this._onPointerUp(this, Vector3.Zero(), 0, 0, true);
      }
    }
  };
  Control3D2.prototype._processObservables = function(type, pickedPoint, pointerId, buttonIndex) {
    if (type === PointerEventTypes.POINTERMOVE) {
      this._onPointerMove(this, pickedPoint);
      var previousControlOver = this._host._lastControlOver[pointerId];
      if (previousControlOver && previousControlOver !== this) {
        previousControlOver._onPointerOut(this);
      }
      if (previousControlOver !== this) {
        this._onPointerEnter(this);
      }
      this._host._lastControlOver[pointerId] = this;
      return true;
    }
    if (type === PointerEventTypes.POINTERDOWN) {
      this._onPointerDown(this, pickedPoint, pointerId, buttonIndex);
      this._host._lastControlDown[pointerId] = this;
      this._host._lastPickedControl = this;
      return true;
    }
    if (type === PointerEventTypes.POINTERUP || type === PointerEventTypes.POINTERDOUBLETAP) {
      if (this._host._lastControlDown[pointerId]) {
        this._host._lastControlDown[pointerId]._onPointerUp(this, pickedPoint, pointerId, buttonIndex, true);
      }
      delete this._host._lastControlDown[pointerId];
      return true;
    }
    return false;
  };
  Control3D2.prototype._disposeNode = function() {
    if (this._node) {
      this._node.dispose();
      this._node = null;
    }
  };
  Control3D2.prototype.dispose = function() {
    this.onPointerDownObservable.clear();
    this.onPointerEnterObservable.clear();
    this.onPointerMoveObservable.clear();
    this.onPointerOutObservable.clear();
    this.onPointerUpObservable.clear();
    this.onPointerClickObservable.clear();
    this._disposeNode();
    for (var _i = 0, _a = this._behaviors; _i < _a.length; _i++) {
      var behavior = _a[_i];
      behavior.detach();
    }
  };
  return Control3D2;
}();

// node_modules/@babylonjs/gui/3D/controls/abstractButton3D.js
var AbstractButton3D = function(_super) {
  __extends(AbstractButton3D2, _super);
  function AbstractButton3D2(name4) {
    return _super.call(this, name4) || this;
  }
  AbstractButton3D2.prototype._getTypeName = function() {
    return "AbstractButton3D";
  };
  AbstractButton3D2.prototype._createNode = function(scene) {
    return new TransformNode("button" + this.name);
  };
  return AbstractButton3D2;
}(Control3D);

// node_modules/@babylonjs/gui/3D/controls/button3D.js
var Button3D = function(_super) {
  __extends(Button3D2, _super);
  function Button3D2(name4) {
    var _this = _super.call(this, name4) || this;
    _this._contentResolution = 512;
    _this._contentScaleRatio = 2;
    _this.pointerEnterAnimation = function() {
      if (!_this.mesh) {
        return;
      }
      _this._currentMaterial.emissiveColor = Color3.Red();
    };
    _this.pointerOutAnimation = function() {
      _this._currentMaterial.emissiveColor = Color3.Black();
    };
    _this.pointerDownAnimation = function() {
      if (!_this.mesh) {
        return;
      }
      _this.mesh.scaling.scaleInPlace(0.95);
    };
    _this.pointerUpAnimation = function() {
      if (!_this.mesh) {
        return;
      }
      _this.mesh.scaling.scaleInPlace(1 / 0.95);
    };
    return _this;
  }
  Object.defineProperty(Button3D2.prototype, "contentResolution", {
    get: function() {
      return this._contentResolution;
    },
    set: function(value) {
      if (this._contentResolution === value) {
        return;
      }
      this._contentResolution = value;
      this._resetContent();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Button3D2.prototype, "contentScaleRatio", {
    get: function() {
      return this._contentScaleRatio;
    },
    set: function(value) {
      if (this._contentScaleRatio === value) {
        return;
      }
      this._contentScaleRatio = value;
      this._resetContent();
    },
    enumerable: false,
    configurable: true
  });
  Button3D2.prototype._disposeFacadeTexture = function() {
    if (this._facadeTexture) {
      this._facadeTexture.dispose();
      this._facadeTexture = null;
    }
  };
  Button3D2.prototype._resetContent = function() {
    this._disposeFacadeTexture();
    this.content = this._content;
  };
  Object.defineProperty(Button3D2.prototype, "content", {
    get: function() {
      return this._content;
    },
    set: function(value) {
      this._content = value;
      if (!this._host || !this._host.utilityLayer) {
        return;
      }
      if (!this._facadeTexture) {
        this._facadeTexture = new AdvancedDynamicTexture("Facade", this._contentResolution, this._contentResolution, this._host.utilityLayer.utilityLayerScene, true, Texture.TRILINEAR_SAMPLINGMODE);
        this._facadeTexture.rootContainer.scaleX = this._contentScaleRatio;
        this._facadeTexture.rootContainer.scaleY = this._contentScaleRatio;
        this._facadeTexture.premulAlpha = true;
      } else {
        this._facadeTexture.rootContainer.clearControls();
      }
      this._facadeTexture.addControl(value);
      this._applyFacade(this._facadeTexture);
    },
    enumerable: false,
    configurable: true
  });
  Button3D2.prototype._applyFacade = function(facadeTexture) {
    this._currentMaterial.emissiveTexture = facadeTexture;
  };
  Button3D2.prototype._getTypeName = function() {
    return "Button3D";
  };
  Button3D2.prototype._createNode = function(scene) {
    var faceUV = new Array(6);
    for (var i = 0; i < 6; i++) {
      faceUV[i] = new Vector4(0, 0, 0, 0);
    }
    faceUV[1] = new Vector4(0, 0, 1, 1);
    var mesh = BoxBuilder.CreateBox(this.name + "_rootMesh", {
      width: 1,
      height: 1,
      depth: 0.08,
      faceUV
    }, scene);
    return mesh;
  };
  Button3D2.prototype._affectMaterial = function(mesh) {
    var material = new StandardMaterial(this.name + "Material", mesh.getScene());
    material.specularColor = Color3.Black();
    mesh.material = material;
    this._currentMaterial = material;
    this._resetContent();
  };
  Button3D2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this._disposeFacadeTexture();
    if (this._currentMaterial) {
      this._currentMaterial.dispose();
    }
  };
  return Button3D2;
}(AbstractButton3D);

// node_modules/@babylonjs/gui/3D/controls/container3D.js
var Container3D = function(_super) {
  __extends(Container3D2, _super);
  function Container3D2(name4) {
    var _this = _super.call(this, name4) || this;
    _this._blockLayout = false;
    _this._children = new Array();
    return _this;
  }
  Object.defineProperty(Container3D2.prototype, "children", {
    get: function() {
      return this._children;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Container3D2.prototype, "blockLayout", {
    get: function() {
      return this._blockLayout;
    },
    set: function(value) {
      if (this._blockLayout === value) {
        return;
      }
      this._blockLayout = value;
      if (!this._blockLayout) {
        this._arrangeChildren();
      }
    },
    enumerable: false,
    configurable: true
  });
  Container3D2.prototype.updateLayout = function() {
    this._arrangeChildren();
    return this;
  };
  Container3D2.prototype.containsControl = function(control) {
    return this._children.indexOf(control) !== -1;
  };
  Container3D2.prototype.addControl = function(control) {
    var index = this._children.indexOf(control);
    if (index !== -1) {
      return this;
    }
    control.parent = this;
    control._host = this._host;
    this._children.push(control);
    if (this._host.utilityLayer) {
      control._prepareNode(this._host.utilityLayer.utilityLayerScene);
      if (control.node) {
        control.node.parent = this.node;
      }
      if (!this.blockLayout) {
        this._arrangeChildren();
      }
    }
    return this;
  };
  Container3D2.prototype._arrangeChildren = function() {
  };
  Container3D2.prototype._createNode = function(scene) {
    return new TransformNode("ContainerNode", scene);
  };
  Container3D2.prototype.removeControl = function(control) {
    var index = this._children.indexOf(control);
    if (index !== -1) {
      this._children.splice(index, 1);
      control.parent = null;
      control._disposeNode();
    }
    return this;
  };
  Container3D2.prototype._getTypeName = function() {
    return "Container3D";
  };
  Container3D2.prototype.dispose = function() {
    for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
      var control = _a[_i];
      control.dispose();
    }
    this._children = [];
    _super.prototype.dispose.call(this);
  };
  Container3D2.UNSET_ORIENTATION = 0;
  Container3D2.FACEORIGIN_ORIENTATION = 1;
  Container3D2.FACEORIGINREVERSED_ORIENTATION = 2;
  Container3D2.FACEFORWARD_ORIENTATION = 3;
  Container3D2.FACEFORWARDREVERSED_ORIENTATION = 4;
  return Container3D2;
}(Control3D);

// node_modules/@babylonjs/gui/3D/controls/volumeBasedPanel.js
var VolumeBasedPanel = function(_super) {
  __extends(VolumeBasedPanel2, _super);
  function VolumeBasedPanel2() {
    var _this = _super.call(this) || this;
    _this._columns = 10;
    _this._rows = 0;
    _this._rowThenColum = true;
    _this._orientation = Container3D.FACEORIGIN_ORIENTATION;
    _this.margin = 0;
    return _this;
  }
  Object.defineProperty(VolumeBasedPanel2.prototype, "orientation", {
    get: function() {
      return this._orientation;
    },
    set: function(value) {
      var _this = this;
      if (this._orientation === value) {
        return;
      }
      this._orientation = value;
      Tools.SetImmediate(function() {
        _this._arrangeChildren();
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VolumeBasedPanel2.prototype, "columns", {
    get: function() {
      return this._columns;
    },
    set: function(value) {
      var _this = this;
      if (this._columns === value) {
        return;
      }
      this._columns = value;
      this._rowThenColum = true;
      Tools.SetImmediate(function() {
        _this._arrangeChildren();
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VolumeBasedPanel2.prototype, "rows", {
    get: function() {
      return this._rows;
    },
    set: function(value) {
      var _this = this;
      if (this._rows === value) {
        return;
      }
      this._rows = value;
      this._rowThenColum = false;
      Tools.SetImmediate(function() {
        _this._arrangeChildren();
      });
    },
    enumerable: false,
    configurable: true
  });
  VolumeBasedPanel2.prototype._arrangeChildren = function() {
    this._cellWidth = 0;
    this._cellHeight = 0;
    var rows = 0;
    var columns = 0;
    var controlCount = 0;
    var currentInverseWorld = Matrix.Invert(this.node.computeWorldMatrix(true));
    for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
      var child = _a[_i];
      if (!child.mesh) {
        continue;
      }
      controlCount++;
      child.mesh.computeWorldMatrix(true);
      var boundingBox = child.mesh.getHierarchyBoundingVectors();
      var extendSize = TmpVectors.Vector3[0];
      var diff = TmpVectors.Vector3[1];
      boundingBox.max.subtractToRef(boundingBox.min, diff);
      diff.scaleInPlace(0.5);
      Vector3.TransformNormalToRef(diff, currentInverseWorld, extendSize);
      this._cellWidth = Math.max(this._cellWidth, extendSize.x * 2);
      this._cellHeight = Math.max(this._cellHeight, extendSize.y * 2);
    }
    this._cellWidth += this.margin * 2;
    this._cellHeight += this.margin * 2;
    if (this._rowThenColum) {
      columns = this._columns;
      rows = Math.ceil(controlCount / this._columns);
    } else {
      rows = this._rows;
      columns = Math.ceil(controlCount / this._rows);
    }
    var startOffsetX = columns * 0.5 * this._cellWidth;
    var startOffsetY = rows * 0.5 * this._cellHeight;
    var nodeGrid = [];
    var cellCounter = 0;
    if (this._rowThenColum) {
      for (var r = 0; r < rows; r++) {
        for (var c = 0; c < columns; c++) {
          nodeGrid.push(new Vector3(c * this._cellWidth - startOffsetX + this._cellWidth / 2, r * this._cellHeight - startOffsetY + this._cellHeight / 2, 0));
          cellCounter++;
          if (cellCounter > controlCount) {
            break;
          }
        }
      }
    } else {
      for (var c = 0; c < columns; c++) {
        for (var r = 0; r < rows; r++) {
          nodeGrid.push(new Vector3(c * this._cellWidth - startOffsetX + this._cellWidth / 2, r * this._cellHeight - startOffsetY + this._cellHeight / 2, 0));
          cellCounter++;
          if (cellCounter > controlCount) {
            break;
          }
        }
      }
    }
    cellCounter = 0;
    for (var _b = 0, _c = this._children; _b < _c.length; _b++) {
      var child = _c[_b];
      if (!child.mesh) {
        continue;
      }
      this._mapGridNode(child, nodeGrid[cellCounter]);
      cellCounter++;
    }
    this._finalProcessing();
  };
  VolumeBasedPanel2.prototype._finalProcessing = function() {
  };
  return VolumeBasedPanel2;
}(Container3D);

// node_modules/@babylonjs/gui/3D/controls/cylinderPanel.js
var CylinderPanel = function(_super) {
  __extends(CylinderPanel2, _super);
  function CylinderPanel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._radius = 5;
    return _this;
  }
  Object.defineProperty(CylinderPanel2.prototype, "radius", {
    get: function() {
      return this._radius;
    },
    set: function(value) {
      var _this = this;
      if (this._radius === value) {
        return;
      }
      this._radius = value;
      Tools.SetImmediate(function() {
        _this._arrangeChildren();
      });
    },
    enumerable: false,
    configurable: true
  });
  CylinderPanel2.prototype._mapGridNode = function(control, nodePosition) {
    var mesh = control.mesh;
    if (!mesh) {
      return;
    }
    var newPos = this._cylindricalMapping(nodePosition);
    control.position = newPos;
    switch (this.orientation) {
      case Container3D.FACEORIGIN_ORIENTATION:
        mesh.lookAt(new Vector3(2 * newPos.x, newPos.y, 2 * newPos.z));
        break;
      case Container3D.FACEORIGINREVERSED_ORIENTATION:
        mesh.lookAt(new Vector3(-newPos.x, newPos.y, -newPos.z));
        break;
      case Container3D.FACEFORWARD_ORIENTATION:
        break;
      case Container3D.FACEFORWARDREVERSED_ORIENTATION:
        mesh.rotate(Axis.Y, Math.PI, Space.LOCAL);
        break;
    }
  };
  CylinderPanel2.prototype._cylindricalMapping = function(source) {
    var newPos = new Vector3(0, source.y, this._radius);
    var yAngle = source.x / this._radius;
    Matrix.RotationYawPitchRollToRef(yAngle, 0, 0, TmpVectors.Matrix[0]);
    return Vector3.TransformNormal(newPos, TmpVectors.Matrix[0]);
  };
  return CylinderPanel2;
}(VolumeBasedPanel);

// node_modules/@babylonjs/gui/3D/materials/shaders/fluent.vertex.js
var name2 = "fluentVertexShader";
var shader = "precision highp float;\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\nuniform mat4 world;\nuniform mat4 viewProjection;\nvarying vec2 vUV;\n#ifdef BORDER\nvarying vec2 scaleInfo;\nuniform float borderWidth;\nuniform vec3 scaleFactor;\n#endif\n#ifdef HOVERLIGHT\nvarying vec3 worldPosition;\n#endif\nvoid main(void) {\nvUV=uv;\n#ifdef BORDER\nvec3 scale=scaleFactor;\nfloat minScale=min(min(scale.x,scale.y),scale.z);\nfloat maxScale=max(max(scale.x,scale.y),scale.z);\nfloat minOverMiddleScale=minScale/(scale.x+scale.y+scale.z-minScale-maxScale);\nfloat areaYZ=scale.y*scale.z;\nfloat areaXZ=scale.x*scale.z;\nfloat areaXY=scale.x*scale.y;\nfloat scaledBorderWidth=borderWidth;\nif (abs(normal.x) == 1.0)\n{\nscale.x=scale.y;\nscale.y=scale.z;\nif (areaYZ>areaXZ && areaYZ>areaXY)\n{\nscaledBorderWidth*=minOverMiddleScale;\n}\n}\nelse if (abs(normal.y) == 1.0)\n{\nscale.x=scale.z;\nif (areaXZ>areaXY && areaXZ>areaYZ)\n{\nscaledBorderWidth*=minOverMiddleScale;\n}\n}\nelse\n{\nif (areaXY>areaYZ && areaXY>areaXZ)\n{\nscaledBorderWidth*=minOverMiddleScale;\n}\n}\nfloat scaleRatio=min(scale.x,scale.y)/max(scale.x,scale.y);\nif (scale.x>scale.y)\n{\nscaleInfo.x=1.0-(scaledBorderWidth*scaleRatio);\nscaleInfo.y=1.0-scaledBorderWidth;\n}\nelse\n{\nscaleInfo.x=1.0-scaledBorderWidth;\nscaleInfo.y=1.0-(scaledBorderWidth*scaleRatio);\n}\n#endif\nvec4 worldPos=world*vec4(position,1.0);\n#ifdef HOVERLIGHT\nworldPosition=worldPos.xyz;\n#endif\ngl_Position=viewProjection*worldPos;\n}\n";
Effect.ShadersStore[name2] = shader;

// node_modules/@babylonjs/gui/3D/materials/shaders/fluent.fragment.js
var name3 = "fluentPixelShader";
var shader2 = "precision highp float;\nvarying vec2 vUV;\nuniform vec4 albedoColor;\n#ifdef INNERGLOW\nuniform vec4 innerGlowColor;\n#endif\n#ifdef BORDER\nvarying vec2 scaleInfo;\nuniform float edgeSmoothingValue;\nuniform float borderMinValue;\n#endif\n#ifdef HOVERLIGHT\nvarying vec3 worldPosition;\nuniform vec3 hoverPosition;\nuniform vec4 hoverColor;\nuniform float hoverRadius;\n#endif\n#ifdef TEXTURE\nuniform sampler2D albedoSampler;\n#endif\nvoid main(void) {\nvec3 albedo=albedoColor.rgb;\nfloat alpha=albedoColor.a;\n#ifdef TEXTURE\nalbedo=texture2D(albedoSampler,vUV).rgb;\n#endif\n#ifdef HOVERLIGHT\nfloat pointToHover=(1.0-clamp(length(hoverPosition-worldPosition)/hoverRadius,0.,1.))*hoverColor.a;\nalbedo=clamp(albedo+hoverColor.rgb*pointToHover,0.,1.);\n#else\nfloat pointToHover=1.0;\n#endif\n#ifdef BORDER\nfloat borderPower=10.0;\nfloat inverseBorderPower=1.0/borderPower;\nvec3 borderColor=albedo*borderPower;\nvec2 distanceToEdge;\ndistanceToEdge.x=abs(vUV.x-0.5)*2.0;\ndistanceToEdge.y=abs(vUV.y-0.5)*2.0;\nfloat borderValue=max(smoothstep(scaleInfo.x-edgeSmoothingValue,scaleInfo.x+edgeSmoothingValue,distanceToEdge.x),\nsmoothstep(scaleInfo.y-edgeSmoothingValue,scaleInfo.y+edgeSmoothingValue,distanceToEdge.y));\nborderColor=borderColor*borderValue*max(borderMinValue*inverseBorderPower,pointToHover);\nalbedo+=borderColor;\nalpha=max(alpha,borderValue);\n#endif\n#ifdef INNERGLOW\n\nvec2 uvGlow=(vUV-vec2(0.5,0.5))*(innerGlowColor.a*2.0);\nuvGlow=uvGlow*uvGlow;\nuvGlow=uvGlow*uvGlow;\nalbedo+=mix(vec3(0.0,0.0,0.0),innerGlowColor.rgb,uvGlow.x+uvGlow.y);\n#endif\ngl_FragColor=vec4(albedo,alpha);\n}";
Effect.ShadersStore[name3] = shader2;

// node_modules/@babylonjs/gui/3D/materials/fluentMaterial.js
var FluentMaterialDefines = function(_super) {
  __extends(FluentMaterialDefines2, _super);
  function FluentMaterialDefines2() {
    var _this = _super.call(this) || this;
    _this.INNERGLOW = false;
    _this.BORDER = false;
    _this.HOVERLIGHT = false;
    _this.TEXTURE = false;
    _this.rebuild();
    return _this;
  }
  return FluentMaterialDefines2;
}(MaterialDefines);
var FluentMaterial = function(_super) {
  __extends(FluentMaterial2, _super);
  function FluentMaterial2(name4, scene) {
    var _this = _super.call(this, name4, scene) || this;
    _this.innerGlowColorIntensity = 0.5;
    _this.innerGlowColor = new Color3(1, 1, 1);
    _this.albedoColor = new Color3(0.3, 0.35, 0.4);
    _this.renderBorders = false;
    _this.borderWidth = 0.5;
    _this.edgeSmoothingValue = 0.02;
    _this.borderMinValue = 0.1;
    _this.renderHoverLight = false;
    _this.hoverRadius = 1;
    _this.hoverColor = new Color4(0.3, 0.3, 0.3, 1);
    _this.hoverPosition = Vector3.Zero();
    return _this;
  }
  FluentMaterial2.prototype.needAlphaBlending = function() {
    return this.alpha !== 1;
  };
  FluentMaterial2.prototype.needAlphaTesting = function() {
    return false;
  };
  FluentMaterial2.prototype.getAlphaTestTexture = function() {
    return null;
  };
  FluentMaterial2.prototype.isReadyForSubMesh = function(mesh, subMesh, useInstances) {
    if (this.isFrozen) {
      if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {
        return true;
      }
    }
    if (!subMesh._materialDefines) {
      subMesh._materialDefines = new FluentMaterialDefines();
    }
    var scene = this.getScene();
    var defines = subMesh._materialDefines;
    if (!this.checkReadyOnEveryCall && subMesh.effect) {
      if (defines._renderId === scene.getRenderId()) {
        return true;
      }
    }
    if (defines._areTexturesDirty) {
      defines.INNERGLOW = this.innerGlowColorIntensity > 0;
      defines.BORDER = this.renderBorders;
      defines.HOVERLIGHT = this.renderHoverLight;
      if (this._albedoTexture) {
        if (!this._albedoTexture.isReadyOrNotBlocking()) {
          return false;
        } else {
          defines.TEXTURE = true;
        }
      } else {
        defines.TEXTURE = false;
      }
    }
    var engine = scene.getEngine();
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      var attribs = [VertexBuffer.PositionKind];
      attribs.push(VertexBuffer.NormalKind);
      attribs.push(VertexBuffer.UVKind);
      var shaderName = "fluent";
      var uniforms = [
        "world",
        "viewProjection",
        "innerGlowColor",
        "albedoColor",
        "borderWidth",
        "edgeSmoothingValue",
        "scaleFactor",
        "borderMinValue",
        "hoverColor",
        "hoverPosition",
        "hoverRadius"
      ];
      var samplers = ["albedoSampler"];
      var uniformBuffers = new Array();
      MaterialHelper.PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: 4
      });
      var join = defines.toString();
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks: null,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: 4 }
      }, engine));
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    subMesh.effect._wasPreviouslyReady = true;
    return true;
  };
  FluentMaterial2.prototype.bindForSubMesh = function(world, mesh, subMesh) {
    var scene = this.getScene();
    var defines = subMesh._materialDefines;
    if (!defines) {
      return;
    }
    var effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", scene.getTransformMatrix());
    if (this._mustRebind(scene, effect)) {
      this._activeEffect.setColor4("albedoColor", this.albedoColor, this.alpha);
      if (defines.INNERGLOW) {
        this._activeEffect.setColor4("innerGlowColor", this.innerGlowColor, this.innerGlowColorIntensity);
      }
      if (defines.BORDER) {
        this._activeEffect.setFloat("borderWidth", this.borderWidth);
        this._activeEffect.setFloat("edgeSmoothingValue", this.edgeSmoothingValue);
        this._activeEffect.setFloat("borderMinValue", this.borderMinValue);
        mesh.getBoundingInfo().boundingBox.extendSize.multiplyToRef(mesh.scaling, TmpVectors.Vector3[0]);
        this._activeEffect.setVector3("scaleFactor", TmpVectors.Vector3[0]);
      }
      if (defines.HOVERLIGHT) {
        this._activeEffect.setDirectColor4("hoverColor", this.hoverColor);
        this._activeEffect.setFloat("hoverRadius", this.hoverRadius);
        this._activeEffect.setVector3("hoverPosition", this.hoverPosition);
      }
      if (defines.TEXTURE) {
        this._activeEffect.setTexture("albedoSampler", this._albedoTexture);
      }
    }
    this._afterBind(mesh, this._activeEffect);
  };
  FluentMaterial2.prototype.getActiveTextures = function() {
    var activeTextures = _super.prototype.getActiveTextures.call(this);
    return activeTextures;
  };
  FluentMaterial2.prototype.hasTexture = function(texture) {
    if (_super.prototype.hasTexture.call(this, texture)) {
      return true;
    }
    return false;
  };
  FluentMaterial2.prototype.dispose = function(forceDisposeEffect) {
    _super.prototype.dispose.call(this, forceDisposeEffect);
  };
  FluentMaterial2.prototype.clone = function(name4) {
    var _this = this;
    return SerializationHelper.Clone(function() {
      return new FluentMaterial2(name4, _this.getScene());
    }, this);
  };
  FluentMaterial2.prototype.serialize = function() {
    var serializationObject = SerializationHelper.Serialize(this);
    serializationObject.customType = "BABYLON.GUI.FluentMaterial";
    return serializationObject;
  };
  FluentMaterial2.prototype.getClassName = function() {
    return "FluentMaterial";
  };
  FluentMaterial2.Parse = function(source, scene, rootUrl) {
    return SerializationHelper.Parse(function() {
      return new FluentMaterial2(source.name, scene);
    }, source, scene, rootUrl);
  };
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], FluentMaterial2.prototype, "innerGlowColorIntensity", void 0);
  __decorate([
    serializeAsColor3()
  ], FluentMaterial2.prototype, "innerGlowColor", void 0);
  __decorate([
    serializeAsColor3()
  ], FluentMaterial2.prototype, "albedoColor", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], FluentMaterial2.prototype, "renderBorders", void 0);
  __decorate([
    serialize()
  ], FluentMaterial2.prototype, "borderWidth", void 0);
  __decorate([
    serialize()
  ], FluentMaterial2.prototype, "edgeSmoothingValue", void 0);
  __decorate([
    serialize()
  ], FluentMaterial2.prototype, "borderMinValue", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], FluentMaterial2.prototype, "renderHoverLight", void 0);
  __decorate([
    serialize()
  ], FluentMaterial2.prototype, "hoverRadius", void 0);
  __decorate([
    serializeAsColor4()
  ], FluentMaterial2.prototype, "hoverColor", void 0);
  __decorate([
    serializeAsVector3()
  ], FluentMaterial2.prototype, "hoverPosition", void 0);
  __decorate([
    serializeAsTexture("albedoTexture")
  ], FluentMaterial2.prototype, "_albedoTexture", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
  ], FluentMaterial2.prototype, "albedoTexture", void 0);
  return FluentMaterial2;
}(PushMaterial);
_TypeStore.RegisteredTypes["BABYLON.GUI.FluentMaterial"] = FluentMaterial;

// node_modules/@babylonjs/gui/3D/controls/holographicButton.js
var HolographicButton = function(_super) {
  __extends(HolographicButton2, _super);
  function HolographicButton2(name4, shareMaterials) {
    if (shareMaterials === void 0) {
      shareMaterials = true;
    }
    var _this = _super.call(this, name4) || this;
    _this._shareMaterials = true;
    _this._shareMaterials = shareMaterials;
    _this.pointerEnterAnimation = function() {
      if (!_this.mesh) {
        return;
      }
      _this._frontPlate.setEnabled(true);
    };
    _this.pointerOutAnimation = function() {
      if (!_this.mesh) {
        return;
      }
      _this._frontPlate.setEnabled(false);
    };
    return _this;
  }
  HolographicButton2.prototype._disposeTooltip = function() {
    this._tooltipFade = null;
    if (this._tooltipTextBlock) {
      this._tooltipTextBlock.dispose();
    }
    if (this._tooltipTexture) {
      this._tooltipTexture.dispose();
    }
    if (this._tooltipMesh) {
      this._tooltipMesh.dispose();
    }
    this.onPointerEnterObservable.remove(this._tooltipHoverObserver);
    this.onPointerOutObservable.remove(this._tooltipOutObserver);
  };
  Object.defineProperty(HolographicButton2.prototype, "renderingGroupId", {
    get: function() {
      return this._backPlate.renderingGroupId;
    },
    set: function(id) {
      this._backPlate.renderingGroupId = id;
      this._textPlate.renderingGroupId = id;
      this._frontPlate.renderingGroupId = id;
      if (this._tooltipMesh) {
        this._tooltipMesh.renderingGroupId = id;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(HolographicButton2.prototype, "tooltipText", {
    get: function() {
      if (this._tooltipTextBlock) {
        return this._tooltipTextBlock.text;
      }
      return null;
    },
    set: function(text) {
      var _this = this;
      if (!text) {
        this._disposeTooltip();
        return;
      }
      if (!this._tooltipFade) {
        this._tooltipMesh = PlaneBuilder.CreatePlane("", { size: 1 }, this._backPlate._scene);
        var tooltipBackground = PlaneBuilder.CreatePlane("", { size: 1, sideOrientation: Mesh.DOUBLESIDE }, this._backPlate._scene);
        var mat = new StandardMaterial("", this._backPlate._scene);
        mat.diffuseColor = Color3.FromHexString("#212121");
        tooltipBackground.material = mat;
        tooltipBackground.isPickable = false;
        this._tooltipMesh.addChild(tooltipBackground);
        tooltipBackground.position.z = 0.05;
        this._tooltipMesh.scaling.y = 1 / 3;
        this._tooltipMesh.position.y = 0.7;
        this._tooltipMesh.position.z = -0.15;
        this._tooltipMesh.isPickable = false;
        this._tooltipMesh.parent = this._backPlate;
        this._tooltipTexture = AdvancedDynamicTexture.CreateForMesh(this._tooltipMesh);
        this._tooltipTextBlock = new TextBlock();
        this._tooltipTextBlock.scaleY = 3;
        this._tooltipTextBlock.color = "white";
        this._tooltipTextBlock.fontSize = 130;
        this._tooltipTexture.addControl(this._tooltipTextBlock);
        this._tooltipFade = new FadeInOutBehavior();
        this._tooltipFade.delay = 500;
        this._tooltipMesh.addBehavior(this._tooltipFade);
        this._tooltipHoverObserver = this.onPointerEnterObservable.add(function() {
          if (_this._tooltipFade) {
            _this._tooltipFade.fadeIn(true);
          }
        });
        this._tooltipOutObserver = this.onPointerOutObservable.add(function() {
          if (_this._tooltipFade) {
            _this._tooltipFade.fadeIn(false);
          }
        });
      }
      if (this._tooltipTextBlock) {
        this._tooltipTextBlock.text = text;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(HolographicButton2.prototype, "text", {
    get: function() {
      return this._text;
    },
    set: function(value) {
      if (this._text === value) {
        return;
      }
      this._text = value;
      this._rebuildContent();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(HolographicButton2.prototype, "imageUrl", {
    get: function() {
      return this._imageUrl;
    },
    set: function(value) {
      if (this._imageUrl === value) {
        return;
      }
      this._imageUrl = value;
      this._rebuildContent();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(HolographicButton2.prototype, "backMaterial", {
    get: function() {
      return this._backMaterial;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(HolographicButton2.prototype, "frontMaterial", {
    get: function() {
      return this._frontMaterial;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(HolographicButton2.prototype, "plateMaterial", {
    get: function() {
      return this._plateMaterial;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(HolographicButton2.prototype, "shareMaterials", {
    get: function() {
      return this._shareMaterials;
    },
    enumerable: false,
    configurable: true
  });
  HolographicButton2.prototype._getTypeName = function() {
    return "HolographicButton";
  };
  HolographicButton2.prototype._rebuildContent = function() {
    this._disposeFacadeTexture();
    var panel = new StackPanel();
    panel.isVertical = true;
    if (this._imageUrl) {
      var image = new Image();
      image.source = this._imageUrl;
      image.paddingTop = "40px";
      image.height = "180px";
      image.width = "100px";
      image.paddingBottom = "40px";
      panel.addControl(image);
    }
    if (this._text) {
      var text = new TextBlock();
      text.text = this._text;
      text.color = "white";
      text.height = "30px";
      text.fontSize = 24;
      panel.addControl(text);
    }
    if (this._frontPlate) {
      this.content = panel;
    }
  };
  HolographicButton2.prototype._createNode = function(scene) {
    this._backPlate = BoxBuilder.CreateBox(this.name + "BackMesh", {
      width: 1,
      height: 1,
      depth: 0.08
    }, scene);
    this._frontPlate = BoxBuilder.CreateBox(this.name + "FrontMesh", {
      width: 1,
      height: 1,
      depth: 0.08
    }, scene);
    this._frontPlate.parent = this._backPlate;
    this._frontPlate.position.z = -0.08;
    this._frontPlate.isPickable = false;
    this._frontPlate.setEnabled(false);
    this._textPlate = _super.prototype._createNode.call(this, scene);
    this._textPlate.parent = this._backPlate;
    this._textPlate.position.z = -0.08;
    this._textPlate.isPickable = false;
    return this._backPlate;
  };
  HolographicButton2.prototype._applyFacade = function(facadeTexture) {
    this._plateMaterial.emissiveTexture = facadeTexture;
    this._plateMaterial.opacityTexture = facadeTexture;
  };
  HolographicButton2.prototype._createBackMaterial = function(mesh) {
    var _this = this;
    this._backMaterial = new FluentMaterial(this.name + "Back Material", mesh.getScene());
    this._backMaterial.renderHoverLight = true;
    this._pickedPointObserver = this._host.onPickedPointChangedObservable.add(function(pickedPoint) {
      if (pickedPoint) {
        _this._backMaterial.hoverPosition = pickedPoint;
        _this._backMaterial.hoverColor.a = 1;
      } else {
        _this._backMaterial.hoverColor.a = 0;
      }
    });
  };
  HolographicButton2.prototype._createFrontMaterial = function(mesh) {
    this._frontMaterial = new FluentMaterial(this.name + "Front Material", mesh.getScene());
    this._frontMaterial.innerGlowColorIntensity = 0;
    this._frontMaterial.alpha = 0.5;
    this._frontMaterial.renderBorders = true;
  };
  HolographicButton2.prototype._createPlateMaterial = function(mesh) {
    this._plateMaterial = new StandardMaterial(this.name + "Plate Material", mesh.getScene());
    this._plateMaterial.specularColor = Color3.Black();
  };
  HolographicButton2.prototype._affectMaterial = function(mesh) {
    if (this._shareMaterials) {
      if (!this._host._sharedMaterials["backFluentMaterial"]) {
        this._createBackMaterial(mesh);
        this._host._sharedMaterials["backFluentMaterial"] = this._backMaterial;
      } else {
        this._backMaterial = this._host._sharedMaterials["backFluentMaterial"];
      }
      if (!this._host._sharedMaterials["frontFluentMaterial"]) {
        this._createFrontMaterial(mesh);
        this._host._sharedMaterials["frontFluentMaterial"] = this._frontMaterial;
      } else {
        this._frontMaterial = this._host._sharedMaterials["frontFluentMaterial"];
      }
    } else {
      this._createBackMaterial(mesh);
      this._createFrontMaterial(mesh);
    }
    this._createPlateMaterial(mesh);
    this._backPlate.material = this._backMaterial;
    this._frontPlate.material = this._frontMaterial;
    this._textPlate.material = this._plateMaterial;
    this._rebuildContent();
  };
  HolographicButton2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this._disposeTooltip();
    if (!this.shareMaterials) {
      this._backMaterial.dispose();
      this._frontMaterial.dispose();
      this._plateMaterial.dispose();
      if (this._pickedPointObserver) {
        this._host.onPickedPointChangedObservable.remove(this._pickedPointObserver);
        this._pickedPointObserver = null;
      }
    }
  };
  return HolographicButton2;
}(Button3D);

// node_modules/@babylonjs/gui/3D/controls/meshButton3D.js
var MeshButton3D = function(_super) {
  __extends(MeshButton3D2, _super);
  function MeshButton3D2(mesh, name4) {
    var _this = _super.call(this, name4) || this;
    _this._currentMesh = mesh;
    _this.pointerEnterAnimation = function() {
      if (!_this.mesh) {
        return;
      }
      _this.mesh.scaling.scaleInPlace(1.1);
    };
    _this.pointerOutAnimation = function() {
      if (!_this.mesh) {
        return;
      }
      _this.mesh.scaling.scaleInPlace(1 / 1.1);
    };
    _this.pointerDownAnimation = function() {
      if (!_this.mesh) {
        return;
      }
      _this.mesh.scaling.scaleInPlace(0.95);
    };
    _this.pointerUpAnimation = function() {
      if (!_this.mesh) {
        return;
      }
      _this.mesh.scaling.scaleInPlace(1 / 0.95);
    };
    return _this;
  }
  MeshButton3D2.prototype._getTypeName = function() {
    return "MeshButton3D";
  };
  MeshButton3D2.prototype._createNode = function(scene) {
    var _this = this;
    this._currentMesh.getChildMeshes().forEach(function(mesh) {
      mesh.metadata = _this;
    });
    return this._currentMesh;
  };
  MeshButton3D2.prototype._affectMaterial = function(mesh) {
  };
  return MeshButton3D2;
}(Button3D);

// node_modules/@babylonjs/gui/3D/controls/planePanel.js
var PlanePanel = function(_super) {
  __extends(PlanePanel2, _super);
  function PlanePanel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PlanePanel2.prototype._mapGridNode = function(control, nodePosition) {
    var mesh = control.mesh;
    if (!mesh) {
      return;
    }
    control.position = nodePosition.clone();
    var target = TmpVectors.Vector3[0];
    target.copyFrom(nodePosition);
    switch (this.orientation) {
      case Container3D.FACEORIGIN_ORIENTATION:
      case Container3D.FACEFORWARD_ORIENTATION:
        target.addInPlace(new Vector3(0, 0, 1));
        mesh.lookAt(target);
        break;
      case Container3D.FACEFORWARDREVERSED_ORIENTATION:
      case Container3D.FACEORIGINREVERSED_ORIENTATION:
        target.addInPlace(new Vector3(0, 0, -1));
        mesh.lookAt(target);
        break;
    }
  };
  return PlanePanel2;
}(VolumeBasedPanel);

// node_modules/@babylonjs/gui/3D/controls/scatterPanel.js
var ScatterPanel = function(_super) {
  __extends(ScatterPanel2, _super);
  function ScatterPanel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._iteration = 100;
    return _this;
  }
  Object.defineProperty(ScatterPanel2.prototype, "iteration", {
    get: function() {
      return this._iteration;
    },
    set: function(value) {
      var _this = this;
      if (this._iteration === value) {
        return;
      }
      this._iteration = value;
      Tools.SetImmediate(function() {
        _this._arrangeChildren();
      });
    },
    enumerable: false,
    configurable: true
  });
  ScatterPanel2.prototype._mapGridNode = function(control, nodePosition) {
    var mesh = control.mesh;
    var newPos = this._scatterMapping(nodePosition);
    if (!mesh) {
      return;
    }
    switch (this.orientation) {
      case Container3D.FACEORIGIN_ORIENTATION:
      case Container3D.FACEFORWARD_ORIENTATION:
        mesh.lookAt(new Vector3(0, 0, 1));
        break;
      case Container3D.FACEFORWARDREVERSED_ORIENTATION:
      case Container3D.FACEORIGINREVERSED_ORIENTATION:
        mesh.lookAt(new Vector3(0, 0, -1));
        break;
    }
    control.position = newPos;
  };
  ScatterPanel2.prototype._scatterMapping = function(source) {
    source.x = (1 - Math.random() * 2) * this._cellWidth;
    source.y = (1 - Math.random() * 2) * this._cellHeight;
    return source;
  };
  ScatterPanel2.prototype._finalProcessing = function() {
    var meshes = [];
    for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
      var child = _a[_i];
      if (!child.mesh) {
        continue;
      }
      meshes.push(child.mesh);
    }
    for (var count = 0; count < this._iteration; count++) {
      meshes.sort(function(a, b) {
        var distance1 = a.position.lengthSquared();
        var distance2 = b.position.lengthSquared();
        if (distance1 < distance2) {
          return 1;
        } else if (distance1 > distance2) {
          return -1;
        }
        return 0;
      });
      var radiusPaddingSquared = Math.pow(this.margin, 2);
      var cellSize = Math.max(this._cellWidth, this._cellHeight);
      var difference2D = TmpVectors.Vector2[0];
      var difference = TmpVectors.Vector3[0];
      for (var i = 0; i < meshes.length - 1; i++) {
        for (var j = i + 1; j < meshes.length; j++) {
          if (i != j) {
            meshes[j].position.subtractToRef(meshes[i].position, difference);
            difference2D.x = difference.x;
            difference2D.y = difference.y;
            var combinedRadius = cellSize;
            var distance = difference2D.lengthSquared() - radiusPaddingSquared;
            var minSeparation = Math.min(distance, radiusPaddingSquared);
            distance -= minSeparation;
            if (distance < Math.pow(combinedRadius, 2)) {
              difference2D.normalize();
              difference.scaleInPlace((combinedRadius - Math.sqrt(distance)) * 0.5);
              meshes[j].position.addInPlace(difference);
              meshes[i].position.subtractInPlace(difference);
            }
          }
        }
      }
    }
  };
  return ScatterPanel2;
}(VolumeBasedPanel);

// node_modules/@babylonjs/gui/3D/controls/spherePanel.js
var SpherePanel = function(_super) {
  __extends(SpherePanel2, _super);
  function SpherePanel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._radius = 5;
    return _this;
  }
  Object.defineProperty(SpherePanel2.prototype, "radius", {
    get: function() {
      return this._radius;
    },
    set: function(value) {
      var _this = this;
      if (this._radius === value) {
        return;
      }
      this._radius = value;
      Tools.SetImmediate(function() {
        _this._arrangeChildren();
      });
    },
    enumerable: false,
    configurable: true
  });
  SpherePanel2.prototype._mapGridNode = function(control, nodePosition) {
    var mesh = control.mesh;
    if (!mesh) {
      return;
    }
    var newPos = this._sphericalMapping(nodePosition);
    control.position = newPos;
    switch (this.orientation) {
      case Container3D.FACEORIGIN_ORIENTATION:
        mesh.lookAt(new Vector3(2 * newPos.x, 2 * newPos.y, 2 * newPos.z));
        break;
      case Container3D.FACEORIGINREVERSED_ORIENTATION:
        mesh.lookAt(new Vector3(-newPos.x, -newPos.y, -newPos.z));
        break;
      case Container3D.FACEFORWARD_ORIENTATION:
        break;
      case Container3D.FACEFORWARDREVERSED_ORIENTATION:
        mesh.rotate(Axis.Y, Math.PI, Space.LOCAL);
        break;
    }
  };
  SpherePanel2.prototype._sphericalMapping = function(source) {
    var newPos = new Vector3(0, 0, this._radius);
    var xAngle = source.y / this._radius;
    var yAngle = -(source.x / this._radius);
    Matrix.RotationYawPitchRollToRef(yAngle, xAngle, 0, TmpVectors.Matrix[0]);
    return Vector3.TransformNormal(newPos, TmpVectors.Matrix[0]);
  };
  return SpherePanel2;
}(VolumeBasedPanel);

// node_modules/@babylonjs/gui/3D/controls/stackPanel3D.js
var StackPanel3D = function(_super) {
  __extends(StackPanel3D2, _super);
  function StackPanel3D2(isVertical) {
    if (isVertical === void 0) {
      isVertical = false;
    }
    var _this = _super.call(this) || this;
    _this._isVertical = false;
    _this.margin = 0.1;
    _this._isVertical = isVertical;
    return _this;
  }
  Object.defineProperty(StackPanel3D2.prototype, "isVertical", {
    get: function() {
      return this._isVertical;
    },
    set: function(value) {
      var _this = this;
      if (this._isVertical === value) {
        return;
      }
      this._isVertical = value;
      Tools.SetImmediate(function() {
        _this._arrangeChildren();
      });
    },
    enumerable: false,
    configurable: true
  });
  StackPanel3D2.prototype._arrangeChildren = function() {
    var width = 0;
    var height = 0;
    var controlCount = 0;
    var extendSizes = [];
    var currentInverseWorld = Matrix.Invert(this.node.computeWorldMatrix(true));
    for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
      var child = _a[_i];
      if (!child.mesh) {
        continue;
      }
      controlCount++;
      child.mesh.computeWorldMatrix(true);
      child.mesh.getWorldMatrix().multiplyToRef(currentInverseWorld, TmpVectors.Matrix[0]);
      var boundingBox = child.mesh.getBoundingInfo().boundingBox;
      var extendSize = Vector3.TransformNormal(boundingBox.extendSize, TmpVectors.Matrix[0]);
      extendSizes.push(extendSize);
      if (this._isVertical) {
        height += extendSize.y;
      } else {
        width += extendSize.x;
      }
    }
    if (this._isVertical) {
      height += (controlCount - 1) * this.margin / 2;
    } else {
      width += (controlCount - 1) * this.margin / 2;
    }
    var offset;
    if (this._isVertical) {
      offset = -height;
    } else {
      offset = -width;
    }
    var index = 0;
    for (var _b = 0, _c = this._children; _b < _c.length; _b++) {
      var child = _c[_b];
      if (!child.mesh) {
        continue;
      }
      controlCount--;
      var extendSize = extendSizes[index++];
      if (this._isVertical) {
        child.position.y = offset + extendSize.y;
        child.position.x = 0;
        offset += extendSize.y * 2;
      } else {
        child.position.x = offset + extendSize.x;
        child.position.y = 0;
        offset += extendSize.x * 2;
      }
      offset += controlCount > 0 ? this.margin : 0;
    }
  };
  return StackPanel3D2;
}(Container3D);

// node_modules/@babylonjs/gui/3D/gui3DManager.js
var GUI3DManager = function() {
  function GUI3DManager2(scene) {
    var _this = this;
    this._lastControlOver = {};
    this._lastControlDown = {};
    this.onPickedPointChangedObservable = new Observable();
    this._sharedMaterials = {};
    this._scene = scene || EngineStore.LastCreatedScene;
    this._sceneDisposeObserver = this._scene.onDisposeObservable.add(function() {
      _this._sceneDisposeObserver = null;
      _this._utilityLayer = null;
      _this.dispose();
    });
    this._utilityLayer = new UtilityLayerRenderer(this._scene);
    this._utilityLayer.onlyCheckPointerDownEvents = false;
    this._utilityLayer.pickUtilitySceneFirst = false;
    this._utilityLayer.mainSceneTrackerPredicate = function(mesh) {
      return mesh && mesh.metadata && mesh.metadata._node;
    };
    this._rootContainer = new Container3D("RootContainer");
    this._rootContainer._host = this;
    var utilityLayerScene = this._utilityLayer.utilityLayerScene;
    this._pointerOutObserver = this._utilityLayer.onPointerOutObservable.add(function(pointerId) {
      _this._handlePointerOut(pointerId, true);
    });
    this._pointerObserver = utilityLayerScene.onPointerObservable.add(function(pi, state) {
      _this._doPicking(pi);
    });
    this._utilityLayer.utilityLayerScene.autoClear = false;
    this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;
    new HemisphericLight("hemi", Vector3.Up(), this._utilityLayer.utilityLayerScene);
  }
  Object.defineProperty(GUI3DManager2.prototype, "scene", {
    get: function() {
      return this._scene;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GUI3DManager2.prototype, "utilityLayer", {
    get: function() {
      return this._utilityLayer;
    },
    enumerable: false,
    configurable: true
  });
  GUI3DManager2.prototype._handlePointerOut = function(pointerId, isPointerUp) {
    var previousControlOver = this._lastControlOver[pointerId];
    if (previousControlOver) {
      previousControlOver._onPointerOut(previousControlOver);
      delete this._lastControlOver[pointerId];
    }
    if (isPointerUp) {
      if (this._lastControlDown[pointerId]) {
        this._lastControlDown[pointerId].forcePointerUp();
        delete this._lastControlDown[pointerId];
      }
    }
    this.onPickedPointChangedObservable.notifyObservers(null);
  };
  GUI3DManager2.prototype._doPicking = function(pi) {
    if (!this._utilityLayer || !this._utilityLayer.shouldRender || !this._utilityLayer.utilityLayerScene.activeCamera) {
      return false;
    }
    var pointerEvent = pi.event;
    var pointerId = pointerEvent.pointerId || 0;
    var buttonIndex = pointerEvent.button;
    var pickingInfo = pi.pickInfo;
    if (!pickingInfo || !pickingInfo.hit) {
      this._handlePointerOut(pointerId, pi.type === PointerEventTypes.POINTERUP);
      return false;
    }
    var control = pickingInfo.pickedMesh.metadata;
    if (pickingInfo.pickedPoint) {
      this.onPickedPointChangedObservable.notifyObservers(pickingInfo.pickedPoint);
    }
    if (!control._processObservables(pi.type, pickingInfo.pickedPoint, pointerId, buttonIndex)) {
      if (pi.type === PointerEventTypes.POINTERMOVE) {
        if (this._lastControlOver[pointerId]) {
          this._lastControlOver[pointerId]._onPointerOut(this._lastControlOver[pointerId]);
        }
        delete this._lastControlOver[pointerId];
      }
    }
    if (pi.type === PointerEventTypes.POINTERUP) {
      if (this._lastControlDown[pointerEvent.pointerId]) {
        this._lastControlDown[pointerEvent.pointerId].forcePointerUp();
        delete this._lastControlDown[pointerEvent.pointerId];
      }
      if (pointerEvent.pointerType === "touch") {
        this._handlePointerOut(pointerId, false);
      }
    }
    return true;
  };
  Object.defineProperty(GUI3DManager2.prototype, "rootContainer", {
    get: function() {
      return this._rootContainer;
    },
    enumerable: false,
    configurable: true
  });
  GUI3DManager2.prototype.containsControl = function(control) {
    return this._rootContainer.containsControl(control);
  };
  GUI3DManager2.prototype.addControl = function(control) {
    this._rootContainer.addControl(control);
    return this;
  };
  GUI3DManager2.prototype.removeControl = function(control) {
    this._rootContainer.removeControl(control);
    return this;
  };
  GUI3DManager2.prototype.dispose = function() {
    this._rootContainer.dispose();
    for (var materialName in this._sharedMaterials) {
      if (!this._sharedMaterials.hasOwnProperty(materialName)) {
        continue;
      }
      this._sharedMaterials[materialName].dispose();
    }
    this._sharedMaterials = {};
    if (this._pointerOutObserver && this._utilityLayer) {
      this._utilityLayer.onPointerOutObservable.remove(this._pointerOutObserver);
      this._pointerOutObserver = null;
    }
    this.onPickedPointChangedObservable.clear();
    var utilityLayerScene = this._utilityLayer ? this._utilityLayer.utilityLayerScene : null;
    if (utilityLayerScene) {
      if (this._pointerObserver) {
        utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
        this._pointerObserver = null;
      }
    }
    if (this._scene) {
      if (this._sceneDisposeObserver) {
        this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);
        this._sceneDisposeObserver = null;
      }
    }
    if (this._utilityLayer) {
      this._utilityLayer.dispose();
    }
  };
  return GUI3DManager2;
}();
export {
  AbstractButton3D,
  AdvancedDynamicTexture,
  AdvancedDynamicTextureInstrumentation,
  BaseSlider,
  Button,
  Button3D,
  Checkbox,
  CheckboxGroup,
  ColorPicker,
  Container,
  Container3D,
  Control,
  Control3D,
  CylinderPanel,
  DisplayGrid,
  Ellipse,
  FluentMaterial,
  FluentMaterialDefines,
  GUI3DManager,
  Grid,
  HolographicButton,
  Image,
  ImageBasedSlider,
  ImageScrollBar,
  InputPassword,
  InputText,
  KeyPropertySet,
  Line,
  Matrix2D,
  Measure,
  MeshButton3D,
  MultiLine,
  MultiLinePoint,
  PlanePanel,
  RadioButton,
  RadioGroup,
  Rectangle,
  ScatterPanel,
  ScrollBar,
  ScrollViewer,
  SelectionPanel,
  SelectorGroup,
  Slider,
  SliderGroup,
  SpherePanel,
  StackPanel,
  StackPanel3D,
  Style,
  TextBlock,
  TextWrapper,
  TextWrapping,
  ValueAndUnit,
  Vector2WithInfo,
  Vector3WithInfo,
  VirtualKeyboard,
  VolumeBasedPanel,
  XmlLoader,
  name
};
//# sourceMappingURL=@babylonjs_gui.js.map
