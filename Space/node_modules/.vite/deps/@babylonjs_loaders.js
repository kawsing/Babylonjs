import {
  Animation,
  AnimationEvent,
  AnimationGroup,
  AnimationKeyInterpolation,
  AssetContainer,
  Bone,
  DataReader,
  Deferred,
  DirectionalLight,
  DracoCompression,
  FreeCamera,
  MorphTarget,
  MorphTargetManager,
  PBRMaterial,
  PointLight,
  RawCubeTexture,
  RenderTargetTexture,
  SceneLoader,
  ShaderMaterial,
  Skeleton,
  Sound,
  SphericalHarmonics,
  SphericalPolynomial,
  SpotLight,
  WeightedSound
} from "./chunk-KAF3XFTO.js";
import {
  AbstractMesh,
  BoundingInfo,
  Buffer,
  Camera,
  Color3,
  Color4,
  Constants,
  Effect,
  Geometry,
  HemisphericLight,
  Light,
  LoadFileError,
  Logger,
  Material,
  Matrix,
  Mesh,
  MultiMaterial,
  Observable,
  Quaternion,
  Scalar,
  StandardMaterial,
  StringTools,
  SubMesh,
  Texture,
  TmpVectors,
  Tools,
  TransformNode,
  Vector2,
  Vector3,
  Vector4,
  VertexBuffer,
  VertexData,
  __assign,
  __export,
  __extends
} from "./chunk-FSGEGJV4.js";

// node_modules/@babylonjs/loaders/glTF/glTFValidation.js
function validateAsync(data, rootUrl, fileName, getExternalResource) {
  var options = {
    externalResourceFunction: function(uri) {
      return getExternalResource(uri).then(function(value) {
        return new Uint8Array(value);
      });
    }
  };
  if (fileName) {
    options.uri = rootUrl === "file:" ? fileName : rootUrl + fileName;
  }
  return data instanceof ArrayBuffer ? GLTFValidator.validateBytes(new Uint8Array(data), options) : GLTFValidator.validateString(data, options);
}
function workerFunc() {
  var pendingExternalResources = [];
  onmessage = function(message) {
    var data = message.data;
    switch (data.id) {
      case "init": {
        importScripts(data.url);
        break;
      }
      case "validate": {
        validateAsync(data.data, data.rootUrl, data.fileName, function(uri) {
          return new Promise(function(resolve, reject) {
            var index = pendingExternalResources.length;
            pendingExternalResources.push({ resolve, reject });
            postMessage({ id: "getExternalResource", index, uri });
          });
        }).then(function(value) {
          postMessage({ id: "validate.resolve", value });
        }, function(reason) {
          postMessage({ id: "validate.reject", reason });
        });
        break;
      }
      case "getExternalResource.resolve": {
        pendingExternalResources[data.index].resolve(data.value);
        break;
      }
      case "getExternalResource.reject": {
        pendingExternalResources[data.index].reject(data.reason);
        break;
      }
    }
  };
}
var GLTFValidation = function() {
  function GLTFValidation2() {
  }
  GLTFValidation2.ValidateAsync = function(data, rootUrl, fileName, getExternalResource) {
    var _this = this;
    if (typeof Worker === "function") {
      return new Promise(function(resolve, reject) {
        var workerContent = validateAsync + "(" + workerFunc + ")()";
        var workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: "application/javascript" }));
        var worker = new Worker(workerBlobUrl);
        var onError = function(error) {
          worker.removeEventListener("error", onError);
          worker.removeEventListener("message", onMessage);
          reject(error);
        };
        var onMessage = function(message) {
          var data2 = message.data;
          switch (data2.id) {
            case "getExternalResource": {
              getExternalResource(data2.uri).then(function(value) {
                worker.postMessage({ id: "getExternalResource.resolve", index: data2.index, value }, [value]);
              }, function(reason) {
                worker.postMessage({ id: "getExternalResource.reject", index: data2.index, reason });
              });
              break;
            }
            case "validate.resolve": {
              worker.removeEventListener("error", onError);
              worker.removeEventListener("message", onMessage);
              resolve(data2.value);
              break;
            }
            case "validate.reject": {
              worker.removeEventListener("error", onError);
              worker.removeEventListener("message", onMessage);
              reject(data2.reason);
            }
          }
        };
        worker.addEventListener("error", onError);
        worker.addEventListener("message", onMessage);
        worker.postMessage({ id: "init", url: Tools.GetAbsoluteUrl(_this.Configuration.url) });
        worker.postMessage({ id: "validate", data, rootUrl, fileName });
      });
    } else {
      if (!this._LoadScriptPromise) {
        this._LoadScriptPromise = Tools.LoadScriptAsync(this.Configuration.url);
      }
      return this._LoadScriptPromise.then(function() {
        return validateAsync(data, rootUrl, fileName, getExternalResource);
      });
    }
  };
  GLTFValidation2.Configuration = {
    url: "https://preview.babylonjs.com/gltf_validator.js"
  };
  return GLTFValidation2;
}();

// node_modules/@babylonjs/loaders/glTF/glTFFileLoader.js
var GLTFLoaderCoordinateSystemMode;
(function(GLTFLoaderCoordinateSystemMode2) {
  GLTFLoaderCoordinateSystemMode2[GLTFLoaderCoordinateSystemMode2["AUTO"] = 0] = "AUTO";
  GLTFLoaderCoordinateSystemMode2[GLTFLoaderCoordinateSystemMode2["FORCE_RIGHT_HANDED"] = 1] = "FORCE_RIGHT_HANDED";
})(GLTFLoaderCoordinateSystemMode || (GLTFLoaderCoordinateSystemMode = {}));
var GLTFLoaderAnimationStartMode;
(function(GLTFLoaderAnimationStartMode2) {
  GLTFLoaderAnimationStartMode2[GLTFLoaderAnimationStartMode2["NONE"] = 0] = "NONE";
  GLTFLoaderAnimationStartMode2[GLTFLoaderAnimationStartMode2["FIRST"] = 1] = "FIRST";
  GLTFLoaderAnimationStartMode2[GLTFLoaderAnimationStartMode2["ALL"] = 2] = "ALL";
})(GLTFLoaderAnimationStartMode || (GLTFLoaderAnimationStartMode = {}));
var GLTFLoaderState;
(function(GLTFLoaderState2) {
  GLTFLoaderState2[GLTFLoaderState2["LOADING"] = 0] = "LOADING";
  GLTFLoaderState2[GLTFLoaderState2["READY"] = 1] = "READY";
  GLTFLoaderState2[GLTFLoaderState2["COMPLETE"] = 2] = "COMPLETE";
})(GLTFLoaderState || (GLTFLoaderState = {}));
var GLTFFileLoader = function() {
  function GLTFFileLoader2() {
    this.onParsedObservable = new Observable();
    this.coordinateSystemMode = GLTFLoaderCoordinateSystemMode.AUTO;
    this.animationStartMode = GLTFLoaderAnimationStartMode.FIRST;
    this.compileMaterials = false;
    this.useClipPlane = false;
    this.compileShadowGenerators = false;
    this.transparencyAsCoverage = false;
    this.useRangeRequests = false;
    this.createInstances = true;
    this.alwaysComputeBoundingBox = false;
    this.loadAllMaterials = false;
    this.preprocessUrlAsync = function(url) {
      return Promise.resolve(url);
    };
    this.onMeshLoadedObservable = new Observable();
    this.onTextureLoadedObservable = new Observable();
    this.onMaterialLoadedObservable = new Observable();
    this.onCameraLoadedObservable = new Observable();
    this.onCompleteObservable = new Observable();
    this.onErrorObservable = new Observable();
    this.onDisposeObservable = new Observable();
    this.onExtensionLoadedObservable = new Observable();
    this.validate = false;
    this.onValidatedObservable = new Observable();
    this._loader = null;
    this._requests = new Array();
    this.name = "gltf";
    this.extensions = {
      ".gltf": { isBinary: false },
      ".glb": { isBinary: true }
    };
    this._logIndentLevel = 0;
    this._loggingEnabled = false;
    this._log = this._logDisabled;
    this._capturePerformanceCounters = false;
    this._startPerformanceCounter = this._startPerformanceCounterDisabled;
    this._endPerformanceCounter = this._endPerformanceCounterDisabled;
  }
  Object.defineProperty(GLTFFileLoader2.prototype, "onParsed", {
    set: function(callback) {
      if (this._onParsedObserver) {
        this.onParsedObservable.remove(this._onParsedObserver);
      }
      this._onParsedObserver = this.onParsedObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GLTFFileLoader2.prototype, "onMeshLoaded", {
    set: function(callback) {
      if (this._onMeshLoadedObserver) {
        this.onMeshLoadedObservable.remove(this._onMeshLoadedObserver);
      }
      this._onMeshLoadedObserver = this.onMeshLoadedObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GLTFFileLoader2.prototype, "onTextureLoaded", {
    set: function(callback) {
      if (this._onTextureLoadedObserver) {
        this.onTextureLoadedObservable.remove(this._onTextureLoadedObserver);
      }
      this._onTextureLoadedObserver = this.onTextureLoadedObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GLTFFileLoader2.prototype, "onMaterialLoaded", {
    set: function(callback) {
      if (this._onMaterialLoadedObserver) {
        this.onMaterialLoadedObservable.remove(this._onMaterialLoadedObserver);
      }
      this._onMaterialLoadedObserver = this.onMaterialLoadedObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GLTFFileLoader2.prototype, "onCameraLoaded", {
    set: function(callback) {
      if (this._onCameraLoadedObserver) {
        this.onCameraLoadedObservable.remove(this._onCameraLoadedObserver);
      }
      this._onCameraLoadedObserver = this.onCameraLoadedObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GLTFFileLoader2.prototype, "onComplete", {
    set: function(callback) {
      if (this._onCompleteObserver) {
        this.onCompleteObservable.remove(this._onCompleteObserver);
      }
      this._onCompleteObserver = this.onCompleteObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GLTFFileLoader2.prototype, "onError", {
    set: function(callback) {
      if (this._onErrorObserver) {
        this.onErrorObservable.remove(this._onErrorObserver);
      }
      this._onErrorObserver = this.onErrorObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GLTFFileLoader2.prototype, "onDispose", {
    set: function(callback) {
      if (this._onDisposeObserver) {
        this.onDisposeObservable.remove(this._onDisposeObserver);
      }
      this._onDisposeObserver = this.onDisposeObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GLTFFileLoader2.prototype, "onExtensionLoaded", {
    set: function(callback) {
      if (this._onExtensionLoadedObserver) {
        this.onExtensionLoadedObservable.remove(this._onExtensionLoadedObserver);
      }
      this._onExtensionLoadedObserver = this.onExtensionLoadedObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GLTFFileLoader2.prototype, "loggingEnabled", {
    get: function() {
      return this._loggingEnabled;
    },
    set: function(value) {
      if (this._loggingEnabled === value) {
        return;
      }
      this._loggingEnabled = value;
      if (this._loggingEnabled) {
        this._log = this._logEnabled;
      } else {
        this._log = this._logDisabled;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GLTFFileLoader2.prototype, "capturePerformanceCounters", {
    get: function() {
      return this._capturePerformanceCounters;
    },
    set: function(value) {
      if (this._capturePerformanceCounters === value) {
        return;
      }
      this._capturePerformanceCounters = value;
      if (this._capturePerformanceCounters) {
        this._startPerformanceCounter = this._startPerformanceCounterEnabled;
        this._endPerformanceCounter = this._endPerformanceCounterEnabled;
      } else {
        this._startPerformanceCounter = this._startPerformanceCounterDisabled;
        this._endPerformanceCounter = this._endPerformanceCounterDisabled;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GLTFFileLoader2.prototype, "onValidated", {
    set: function(callback) {
      if (this._onValidatedObserver) {
        this.onValidatedObservable.remove(this._onValidatedObserver);
      }
      this._onValidatedObserver = this.onValidatedObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  GLTFFileLoader2.prototype.dispose = function() {
    if (this._loader) {
      this._loader.dispose();
      this._loader = null;
    }
    for (var _i = 0, _a = this._requests; _i < _a.length; _i++) {
      var request = _a[_i];
      request.abort();
    }
    this._requests.length = 0;
    delete this._progressCallback;
    this.preprocessUrlAsync = function(url) {
      return Promise.resolve(url);
    };
    this.onMeshLoadedObservable.clear();
    this.onTextureLoadedObservable.clear();
    this.onMaterialLoadedObservable.clear();
    this.onCameraLoadedObservable.clear();
    this.onCompleteObservable.clear();
    this.onExtensionLoadedObservable.clear();
    this.onDisposeObservable.notifyObservers(void 0);
    this.onDisposeObservable.clear();
  };
  GLTFFileLoader2.prototype.requestFile = function(scene, url, onSuccess, onProgress, useArrayBuffer, onError) {
    var _this = this;
    this._progressCallback = onProgress;
    if (useArrayBuffer) {
      if (this.useRangeRequests) {
        if (this.validate) {
          Logger.Warn("glTF validation is not supported when range requests are enabled");
        }
        var fileRequest_1 = {
          abort: function() {
          },
          onCompleteObservable: new Observable()
        };
        var dataBuffer = {
          readAsync: function(byteOffset, byteLength) {
            return new Promise(function(resolve, reject) {
              _this._requestFile(url, scene, function(data) {
                resolve(new Uint8Array(data));
              }, true, function(error) {
                reject(error);
              }, function(webRequest) {
                webRequest.setRequestHeader("Range", "bytes=" + byteOffset + "-" + (byteOffset + byteLength - 1));
              });
            });
          },
          byteLength: 0
        };
        this._unpackBinaryAsync(new DataReader(dataBuffer)).then(function(loaderData) {
          fileRequest_1.onCompleteObservable.notifyObservers(fileRequest_1);
          onSuccess(loaderData);
        }, onError);
        return fileRequest_1;
      }
      return this._requestFile(url, scene, function(data, request) {
        var arrayBuffer = data;
        _this._unpackBinaryAsync(new DataReader({
          readAsync: function(byteOffset, byteLength) {
            return Promise.resolve(new Uint8Array(arrayBuffer, byteOffset, byteLength));
          },
          byteLength: arrayBuffer.byteLength
        })).then(function(loaderData) {
          onSuccess(loaderData, request);
        }, onError);
      }, true, onError);
    }
    return this._requestFile(url, scene, function(data, request) {
      _this._validate(scene, data, Tools.GetFolderPath(url), Tools.GetFilename(url));
      onSuccess({ json: _this._parseJson(data) }, request);
    }, useArrayBuffer, onError);
  };
  GLTFFileLoader2.prototype.readFile = function(scene, file, onSuccess, onProgress, useArrayBuffer, onError) {
    var _this = this;
    return scene._readFile(file, function(data) {
      _this._validate(scene, data, "file:", file.name);
      if (useArrayBuffer) {
        var arrayBuffer_1 = data;
        _this._unpackBinaryAsync(new DataReader({
          readAsync: function(byteOffset, byteLength) {
            return Promise.resolve(new Uint8Array(arrayBuffer_1, byteOffset, byteLength));
          },
          byteLength: arrayBuffer_1.byteLength
        })).then(onSuccess, onError);
      } else {
        onSuccess({ json: _this._parseJson(data) });
      }
    }, onProgress, useArrayBuffer, onError);
  };
  GLTFFileLoader2.prototype.importMeshAsync = function(meshesNames, scene, data, rootUrl, onProgress, fileName) {
    var _this = this;
    return Promise.resolve().then(function() {
      _this.onParsedObservable.notifyObservers(data);
      _this.onParsedObservable.clear();
      _this._log("Loading " + (fileName || ""));
      _this._loader = _this._getLoader(data);
      return _this._loader.importMeshAsync(meshesNames, scene, false, data, rootUrl, onProgress, fileName);
    });
  };
  GLTFFileLoader2.prototype.loadAsync = function(scene, data, rootUrl, onProgress, fileName) {
    var _this = this;
    return Promise.resolve().then(function() {
      _this.onParsedObservable.notifyObservers(data);
      _this.onParsedObservable.clear();
      _this._log("Loading " + (fileName || ""));
      _this._loader = _this._getLoader(data);
      return _this._loader.loadAsync(scene, data, rootUrl, onProgress, fileName);
    });
  };
  GLTFFileLoader2.prototype.loadAssetContainerAsync = function(scene, data, rootUrl, onProgress, fileName) {
    var _this = this;
    return Promise.resolve().then(function() {
      _this.onParsedObservable.notifyObservers(data);
      _this.onParsedObservable.clear();
      _this._log("Loading " + (fileName || ""));
      _this._loader = _this._getLoader(data);
      var container = new AssetContainer(scene);
      var materials = [];
      _this.onMaterialLoadedObservable.add(function(material) {
        materials.push(material);
        material.onDisposeObservable.addOnce(function() {
          var index = container.materials.indexOf(material);
          if (index > -1) {
            container.materials.splice(index, 1);
          }
          index = materials.indexOf(material);
          if (index > -1) {
            materials.splice(index, 1);
          }
        });
      });
      var textures = [];
      _this.onTextureLoadedObservable.add(function(texture) {
        textures.push(texture);
        texture.onDisposeObservable.addOnce(function() {
          var index = container.textures.indexOf(texture);
          if (index > -1) {
            container.textures.splice(index, 1);
          }
          index = textures.indexOf(texture);
          if (index > -1) {
            textures.splice(index, 1);
          }
        });
      });
      var cameras = [];
      _this.onCameraLoadedObservable.add(function(camera) {
        cameras.push(camera);
      });
      return _this._loader.importMeshAsync(null, scene, true, data, rootUrl, onProgress, fileName).then(function(result) {
        Array.prototype.push.apply(container.geometries, result.geometries);
        Array.prototype.push.apply(container.meshes, result.meshes);
        Array.prototype.push.apply(container.particleSystems, result.particleSystems);
        Array.prototype.push.apply(container.skeletons, result.skeletons);
        Array.prototype.push.apply(container.animationGroups, result.animationGroups);
        Array.prototype.push.apply(container.materials, materials);
        Array.prototype.push.apply(container.textures, textures);
        Array.prototype.push.apply(container.lights, result.lights);
        Array.prototype.push.apply(container.transformNodes, result.transformNodes);
        Array.prototype.push.apply(container.cameras, cameras);
        return container;
      });
    });
  };
  GLTFFileLoader2.prototype.canDirectLoad = function(data) {
    return data.indexOf("asset") !== -1 && data.indexOf("version") !== -1 || StringTools.StartsWith(data, "data:base64," + GLTFFileLoader2.magicBase64Encoded) || StringTools.StartsWith(data, "data:application/octet-stream;base64," + GLTFFileLoader2.magicBase64Encoded) || StringTools.StartsWith(data, "data:model/gltf-binary;base64," + GLTFFileLoader2.magicBase64Encoded);
  };
  GLTFFileLoader2.prototype.directLoad = function(scene, data) {
    if (StringTools.StartsWith(data, "base64," + GLTFFileLoader2.magicBase64Encoded) || StringTools.StartsWith(data, "application/octet-stream;base64," + GLTFFileLoader2.magicBase64Encoded) || StringTools.StartsWith(data, "model/gltf-binary;base64," + GLTFFileLoader2.magicBase64Encoded)) {
      var arrayBuffer_2 = Tools.DecodeBase64(data);
      this._validate(scene, arrayBuffer_2);
      return this._unpackBinaryAsync(new DataReader({
        readAsync: function(byteOffset, byteLength) {
          return Promise.resolve(new Uint8Array(arrayBuffer_2, byteOffset, byteLength));
        },
        byteLength: arrayBuffer_2.byteLength
      }));
    }
    this._validate(scene, data);
    return Promise.resolve({ json: this._parseJson(data) });
  };
  GLTFFileLoader2.prototype.createPlugin = function() {
    return new GLTFFileLoader2();
  };
  Object.defineProperty(GLTFFileLoader2.prototype, "loaderState", {
    get: function() {
      return this._loader ? this._loader.state : null;
    },
    enumerable: false,
    configurable: true
  });
  GLTFFileLoader2.prototype.whenCompleteAsync = function() {
    var _this = this;
    return new Promise(function(resolve, reject) {
      _this.onCompleteObservable.addOnce(function() {
        resolve();
      });
      _this.onErrorObservable.addOnce(function(reason) {
        reject(reason);
      });
    });
  };
  GLTFFileLoader2.prototype._loadFile = function(url, scene, onSuccess, useArrayBuffer, onError) {
    var _this = this;
    var request = scene._loadFile(url, onSuccess, function(event) {
      _this._onProgress(event, request);
    }, void 0, useArrayBuffer, onError);
    request.onCompleteObservable.add(function(request2) {
      _this._requests.splice(_this._requests.indexOf(request2), 1);
    });
    this._requests.push(request);
    return request;
  };
  GLTFFileLoader2.prototype._requestFile = function(url, scene, onSuccess, useArrayBuffer, onError, onOpened) {
    var _this = this;
    var request = scene._requestFile(url, onSuccess, function(event) {
      _this._onProgress(event, request);
    }, void 0, useArrayBuffer, onError, onOpened);
    request.onCompleteObservable.add(function(request2) {
      _this._requests.splice(_this._requests.indexOf(request2), 1);
    });
    this._requests.push(request);
    return request;
  };
  GLTFFileLoader2.prototype._onProgress = function(event, request) {
    if (!this._progressCallback) {
      return;
    }
    request._lengthComputable = event.lengthComputable;
    request._loaded = event.loaded;
    request._total = event.total;
    var lengthComputable = true;
    var loaded = 0;
    var total = 0;
    for (var _i = 0, _a = this._requests; _i < _a.length; _i++) {
      var request_1 = _a[_i];
      if (request_1._lengthComputable === void 0 || request_1._loaded === void 0 || request_1._total === void 0) {
        return;
      }
      lengthComputable = lengthComputable && request_1._lengthComputable;
      loaded += request_1._loaded;
      total += request_1._total;
    }
    this._progressCallback({
      lengthComputable,
      loaded,
      total: lengthComputable ? total : 0
    });
  };
  GLTFFileLoader2.prototype._validate = function(scene, data, rootUrl, fileName) {
    var _this = this;
    if (rootUrl === void 0) {
      rootUrl = "";
    }
    if (fileName === void 0) {
      fileName = "";
    }
    if (!this.validate) {
      return;
    }
    this._startPerformanceCounter("Validate JSON");
    GLTFValidation.ValidateAsync(data, rootUrl, fileName, function(uri) {
      return _this.preprocessUrlAsync(rootUrl + uri).then(function(url) {
        return scene._loadFileAsync(url, void 0, true, true);
      });
    }).then(function(result) {
      _this._endPerformanceCounter("Validate JSON");
      _this.onValidatedObservable.notifyObservers(result);
      _this.onValidatedObservable.clear();
    }, function(reason) {
      _this._endPerformanceCounter("Validate JSON");
      Tools.Warn("Failed to validate: " + reason.message);
      _this.onValidatedObservable.clear();
    });
  };
  GLTFFileLoader2.prototype._getLoader = function(loaderData) {
    var asset = loaderData.json.asset || {};
    this._log("Asset version: " + asset.version);
    asset.minVersion && this._log("Asset minimum version: " + asset.minVersion);
    asset.generator && this._log("Asset generator: " + asset.generator);
    var version = GLTFFileLoader2._parseVersion(asset.version);
    if (!version) {
      throw new Error("Invalid version: " + asset.version);
    }
    if (asset.minVersion !== void 0) {
      var minVersion = GLTFFileLoader2._parseVersion(asset.minVersion);
      if (!minVersion) {
        throw new Error("Invalid minimum version: " + asset.minVersion);
      }
      if (GLTFFileLoader2._compareVersion(minVersion, { major: 2, minor: 0 }) > 0) {
        throw new Error("Incompatible minimum version: " + asset.minVersion);
      }
    }
    var createLoaders = {
      1: GLTFFileLoader2._CreateGLTF1Loader,
      2: GLTFFileLoader2._CreateGLTF2Loader
    };
    var createLoader = createLoaders[version.major];
    if (!createLoader) {
      throw new Error("Unsupported version: " + asset.version);
    }
    return createLoader(this);
  };
  GLTFFileLoader2.prototype._parseJson = function(json) {
    this._startPerformanceCounter("Parse JSON");
    this._log("JSON length: " + json.length);
    var parsed = JSON.parse(json);
    this._endPerformanceCounter("Parse JSON");
    return parsed;
  };
  GLTFFileLoader2.prototype._unpackBinaryAsync = function(dataReader) {
    var _this = this;
    this._startPerformanceCounter("Unpack Binary");
    return dataReader.loadAsync(20).then(function() {
      var Binary = {
        Magic: 1179937895
      };
      var magic = dataReader.readUint32();
      if (magic !== Binary.Magic) {
        throw new Error("Unexpected magic: " + magic);
      }
      var version = dataReader.readUint32();
      if (_this.loggingEnabled) {
        _this._log("Binary version: " + version);
      }
      var length = dataReader.readUint32();
      if (dataReader.buffer.byteLength !== 0 && length !== dataReader.buffer.byteLength) {
        throw new Error("Length in header does not match actual data length: " + length + " != " + dataReader.buffer.byteLength);
      }
      var unpacked;
      switch (version) {
        case 1: {
          unpacked = _this._unpackBinaryV1Async(dataReader, length);
          break;
        }
        case 2: {
          unpacked = _this._unpackBinaryV2Async(dataReader, length);
          break;
        }
        default: {
          throw new Error("Unsupported version: " + version);
        }
      }
      _this._endPerformanceCounter("Unpack Binary");
      return unpacked;
    });
  };
  GLTFFileLoader2.prototype._unpackBinaryV1Async = function(dataReader, length) {
    var ContentFormat = {
      JSON: 0
    };
    var contentLength = dataReader.readUint32();
    var contentFormat = dataReader.readUint32();
    if (contentFormat !== ContentFormat.JSON) {
      throw new Error("Unexpected content format: " + contentFormat);
    }
    var bodyLength = length - dataReader.byteOffset;
    var data = { json: this._parseJson(dataReader.readString(contentLength)), bin: null };
    if (bodyLength !== 0) {
      var startByteOffset_1 = dataReader.byteOffset;
      data.bin = {
        readAsync: function(byteOffset, byteLength) {
          return dataReader.buffer.readAsync(startByteOffset_1 + byteOffset, byteLength);
        },
        byteLength: bodyLength
      };
    }
    return Promise.resolve(data);
  };
  GLTFFileLoader2.prototype._unpackBinaryV2Async = function(dataReader, length) {
    var _this = this;
    var ChunkFormat = {
      JSON: 1313821514,
      BIN: 5130562
    };
    var chunkLength = dataReader.readUint32();
    var chunkFormat = dataReader.readUint32();
    if (chunkFormat !== ChunkFormat.JSON) {
      throw new Error("First chunk format is not JSON");
    }
    if (dataReader.byteOffset + chunkLength === length) {
      return dataReader.loadAsync(chunkLength).then(function() {
        return { json: _this._parseJson(dataReader.readString(chunkLength)), bin: null };
      });
    }
    return dataReader.loadAsync(chunkLength + 8).then(function() {
      var data = { json: _this._parseJson(dataReader.readString(chunkLength)), bin: null };
      var readAsync = function() {
        var chunkLength2 = dataReader.readUint32();
        var chunkFormat2 = dataReader.readUint32();
        switch (chunkFormat2) {
          case ChunkFormat.JSON: {
            throw new Error("Unexpected JSON chunk");
          }
          case ChunkFormat.BIN: {
            var startByteOffset_2 = dataReader.byteOffset;
            data.bin = {
              readAsync: function(byteOffset, byteLength) {
                return dataReader.buffer.readAsync(startByteOffset_2 + byteOffset, byteLength);
              },
              byteLength: chunkLength2
            };
            dataReader.skipBytes(chunkLength2);
            break;
          }
          default: {
            dataReader.skipBytes(chunkLength2);
            break;
          }
        }
        if (dataReader.byteOffset !== length) {
          return dataReader.loadAsync(8).then(readAsync);
        }
        return Promise.resolve(data);
      };
      return readAsync();
    });
  };
  GLTFFileLoader2._parseVersion = function(version) {
    if (version === "1.0" || version === "1.0.1") {
      return {
        major: 1,
        minor: 0
      };
    }
    var match = (version + "").match(/^(\d+)\.(\d+)/);
    if (!match) {
      return null;
    }
    return {
      major: parseInt(match[1]),
      minor: parseInt(match[2])
    };
  };
  GLTFFileLoader2._compareVersion = function(a, b) {
    if (a.major > b.major) {
      return 1;
    }
    if (a.major < b.major) {
      return -1;
    }
    if (a.minor > b.minor) {
      return 1;
    }
    if (a.minor < b.minor) {
      return -1;
    }
    return 0;
  };
  GLTFFileLoader2.prototype._logOpen = function(message) {
    this._log(message);
    this._logIndentLevel++;
  };
  GLTFFileLoader2.prototype._logClose = function() {
    --this._logIndentLevel;
  };
  GLTFFileLoader2.prototype._logEnabled = function(message) {
    var spaces = GLTFFileLoader2._logSpaces.substr(0, this._logIndentLevel * 2);
    Logger.Log("" + spaces + message);
  };
  GLTFFileLoader2.prototype._logDisabled = function(message) {
  };
  GLTFFileLoader2.prototype._startPerformanceCounterEnabled = function(counterName) {
    Tools.StartPerformanceCounter(counterName);
  };
  GLTFFileLoader2.prototype._startPerformanceCounterDisabled = function(counterName) {
  };
  GLTFFileLoader2.prototype._endPerformanceCounterEnabled = function(counterName) {
    Tools.EndPerformanceCounter(counterName);
  };
  GLTFFileLoader2.prototype._endPerformanceCounterDisabled = function(counterName) {
  };
  GLTFFileLoader2.IncrementalLoading = true;
  GLTFFileLoader2.HomogeneousCoordinates = false;
  GLTFFileLoader2.magicBase64Encoded = "Z2xURg";
  GLTFFileLoader2._logSpaces = "                                ";
  return GLTFFileLoader2;
}();
if (SceneLoader) {
  SceneLoader.RegisterPlugin(new GLTFFileLoader());
}

// node_modules/@babylonjs/loaders/glTF/1.0/index.js
var __exports = {};
__export(__exports, {
  EBlendingFunction: () => EBlendingFunction,
  EComponentType: () => EComponentType,
  ECullingType: () => ECullingType,
  EParameterType: () => EParameterType,
  EShaderType: () => EShaderType,
  ETextureFilterType: () => ETextureFilterType,
  ETextureFormat: () => ETextureFormat,
  ETextureWrapMode: () => ETextureWrapMode,
  GLTFBinaryExtension: () => GLTFBinaryExtension,
  GLTFLoader: () => GLTFLoader,
  GLTFLoaderBase: () => GLTFLoaderBase,
  GLTFLoaderExtension: () => GLTFLoaderExtension,
  GLTFMaterialsCommonExtension: () => GLTFMaterialsCommonExtension,
  GLTFUtils: () => GLTFUtils
});

// node_modules/@babylonjs/loaders/glTF/1.0/glTFLoaderInterfaces.js
var EComponentType;
(function(EComponentType2) {
  EComponentType2[EComponentType2["BYTE"] = 5120] = "BYTE";
  EComponentType2[EComponentType2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  EComponentType2[EComponentType2["SHORT"] = 5122] = "SHORT";
  EComponentType2[EComponentType2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  EComponentType2[EComponentType2["FLOAT"] = 5126] = "FLOAT";
})(EComponentType || (EComponentType = {}));
var EShaderType;
(function(EShaderType2) {
  EShaderType2[EShaderType2["FRAGMENT"] = 35632] = "FRAGMENT";
  EShaderType2[EShaderType2["VERTEX"] = 35633] = "VERTEX";
})(EShaderType || (EShaderType = {}));
var EParameterType;
(function(EParameterType2) {
  EParameterType2[EParameterType2["BYTE"] = 5120] = "BYTE";
  EParameterType2[EParameterType2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  EParameterType2[EParameterType2["SHORT"] = 5122] = "SHORT";
  EParameterType2[EParameterType2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  EParameterType2[EParameterType2["INT"] = 5124] = "INT";
  EParameterType2[EParameterType2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  EParameterType2[EParameterType2["FLOAT"] = 5126] = "FLOAT";
  EParameterType2[EParameterType2["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
  EParameterType2[EParameterType2["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
  EParameterType2[EParameterType2["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
  EParameterType2[EParameterType2["INT_VEC2"] = 35667] = "INT_VEC2";
  EParameterType2[EParameterType2["INT_VEC3"] = 35668] = "INT_VEC3";
  EParameterType2[EParameterType2["INT_VEC4"] = 35669] = "INT_VEC4";
  EParameterType2[EParameterType2["BOOL"] = 35670] = "BOOL";
  EParameterType2[EParameterType2["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
  EParameterType2[EParameterType2["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
  EParameterType2[EParameterType2["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
  EParameterType2[EParameterType2["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
  EParameterType2[EParameterType2["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
  EParameterType2[EParameterType2["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
  EParameterType2[EParameterType2["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
})(EParameterType || (EParameterType = {}));
var ETextureWrapMode;
(function(ETextureWrapMode2) {
  ETextureWrapMode2[ETextureWrapMode2["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
  ETextureWrapMode2[ETextureWrapMode2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  ETextureWrapMode2[ETextureWrapMode2["REPEAT"] = 10497] = "REPEAT";
})(ETextureWrapMode || (ETextureWrapMode = {}));
var ETextureFilterType;
(function(ETextureFilterType2) {
  ETextureFilterType2[ETextureFilterType2["NEAREST"] = 9728] = "NEAREST";
  ETextureFilterType2[ETextureFilterType2["LINEAR"] = 9728] = "LINEAR";
  ETextureFilterType2[ETextureFilterType2["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
  ETextureFilterType2[ETextureFilterType2["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
  ETextureFilterType2[ETextureFilterType2["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
  ETextureFilterType2[ETextureFilterType2["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
})(ETextureFilterType || (ETextureFilterType = {}));
var ETextureFormat;
(function(ETextureFormat2) {
  ETextureFormat2[ETextureFormat2["ALPHA"] = 6406] = "ALPHA";
  ETextureFormat2[ETextureFormat2["RGB"] = 6407] = "RGB";
  ETextureFormat2[ETextureFormat2["RGBA"] = 6408] = "RGBA";
  ETextureFormat2[ETextureFormat2["LUMINANCE"] = 6409] = "LUMINANCE";
  ETextureFormat2[ETextureFormat2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
})(ETextureFormat || (ETextureFormat = {}));
var ECullingType;
(function(ECullingType2) {
  ECullingType2[ECullingType2["FRONT"] = 1028] = "FRONT";
  ECullingType2[ECullingType2["BACK"] = 1029] = "BACK";
  ECullingType2[ECullingType2["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
})(ECullingType || (ECullingType = {}));
var EBlendingFunction;
(function(EBlendingFunction2) {
  EBlendingFunction2[EBlendingFunction2["ZERO"] = 0] = "ZERO";
  EBlendingFunction2[EBlendingFunction2["ONE"] = 1] = "ONE";
  EBlendingFunction2[EBlendingFunction2["SRC_COLOR"] = 768] = "SRC_COLOR";
  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
  EBlendingFunction2[EBlendingFunction2["DST_COLOR"] = 774] = "DST_COLOR";
  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
  EBlendingFunction2[EBlendingFunction2["SRC_ALPHA"] = 770] = "SRC_ALPHA";
  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
  EBlendingFunction2[EBlendingFunction2["DST_ALPHA"] = 772] = "DST_ALPHA";
  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
  EBlendingFunction2[EBlendingFunction2["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
  EBlendingFunction2[EBlendingFunction2["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
  EBlendingFunction2[EBlendingFunction2["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
})(EBlendingFunction || (EBlendingFunction = {}));

// node_modules/@babylonjs/loaders/glTF/1.0/glTFLoaderUtils.js
var GLTFUtils = function() {
  function GLTFUtils2() {
  }
  GLTFUtils2.SetMatrix = function(scene, source, parameter, uniformName, shaderMaterial) {
    var mat = null;
    if (parameter.semantic === "MODEL") {
      mat = source.getWorldMatrix();
    } else if (parameter.semantic === "PROJECTION") {
      mat = scene.getProjectionMatrix();
    } else if (parameter.semantic === "VIEW") {
      mat = scene.getViewMatrix();
    } else if (parameter.semantic === "MODELVIEWINVERSETRANSPOSE") {
      mat = Matrix.Transpose(source.getWorldMatrix().multiply(scene.getViewMatrix()).invert());
    } else if (parameter.semantic === "MODELVIEW") {
      mat = source.getWorldMatrix().multiply(scene.getViewMatrix());
    } else if (parameter.semantic === "MODELVIEWPROJECTION") {
      mat = source.getWorldMatrix().multiply(scene.getTransformMatrix());
    } else if (parameter.semantic === "MODELINVERSE") {
      mat = source.getWorldMatrix().invert();
    } else if (parameter.semantic === "VIEWINVERSE") {
      mat = scene.getViewMatrix().invert();
    } else if (parameter.semantic === "PROJECTIONINVERSE") {
      mat = scene.getProjectionMatrix().invert();
    } else if (parameter.semantic === "MODELVIEWINVERSE") {
      mat = source.getWorldMatrix().multiply(scene.getViewMatrix()).invert();
    } else if (parameter.semantic === "MODELVIEWPROJECTIONINVERSE") {
      mat = source.getWorldMatrix().multiply(scene.getTransformMatrix()).invert();
    } else if (parameter.semantic === "MODELINVERSETRANSPOSE") {
      mat = Matrix.Transpose(source.getWorldMatrix().invert());
    } else {
      debugger;
    }
    if (mat) {
      switch (parameter.type) {
        case EParameterType.FLOAT_MAT2:
          shaderMaterial.setMatrix2x2(uniformName, Matrix.GetAsMatrix2x2(mat));
          break;
        case EParameterType.FLOAT_MAT3:
          shaderMaterial.setMatrix3x3(uniformName, Matrix.GetAsMatrix3x3(mat));
          break;
        case EParameterType.FLOAT_MAT4:
          shaderMaterial.setMatrix(uniformName, mat);
          break;
        default:
          break;
      }
    }
  };
  GLTFUtils2.SetUniform = function(shaderMaterial, uniform, value, type) {
    switch (type) {
      case EParameterType.FLOAT:
        shaderMaterial.setFloat(uniform, value);
        return true;
      case EParameterType.FLOAT_VEC2:
        shaderMaterial.setVector2(uniform, Vector2.FromArray(value));
        return true;
      case EParameterType.FLOAT_VEC3:
        shaderMaterial.setVector3(uniform, Vector3.FromArray(value));
        return true;
      case EParameterType.FLOAT_VEC4:
        shaderMaterial.setVector4(uniform, Vector4.FromArray(value));
        return true;
      default:
        return false;
    }
  };
  GLTFUtils2.GetWrapMode = function(mode) {
    switch (mode) {
      case ETextureWrapMode.CLAMP_TO_EDGE:
        return Texture.CLAMP_ADDRESSMODE;
      case ETextureWrapMode.MIRRORED_REPEAT:
        return Texture.MIRROR_ADDRESSMODE;
      case ETextureWrapMode.REPEAT:
        return Texture.WRAP_ADDRESSMODE;
      default:
        return Texture.WRAP_ADDRESSMODE;
    }
  };
  GLTFUtils2.GetByteStrideFromType = function(accessor) {
    var type = accessor.type;
    switch (type) {
      case "VEC2":
        return 2;
      case "VEC3":
        return 3;
      case "VEC4":
        return 4;
      case "MAT2":
        return 4;
      case "MAT3":
        return 9;
      case "MAT4":
        return 16;
      default:
        return 1;
    }
  };
  GLTFUtils2.GetTextureFilterMode = function(mode) {
    switch (mode) {
      case ETextureFilterType.LINEAR:
      case ETextureFilterType.LINEAR_MIPMAP_NEAREST:
      case ETextureFilterType.LINEAR_MIPMAP_LINEAR:
        return Texture.TRILINEAR_SAMPLINGMODE;
      case ETextureFilterType.NEAREST:
      case ETextureFilterType.NEAREST_MIPMAP_NEAREST:
        return Texture.NEAREST_SAMPLINGMODE;
      default:
        return Texture.BILINEAR_SAMPLINGMODE;
    }
  };
  GLTFUtils2.GetBufferFromBufferView = function(gltfRuntime, bufferView, byteOffset, byteLength, componentType) {
    var byteOffset = bufferView.byteOffset + byteOffset;
    var loadedBufferView = gltfRuntime.loadedBufferViews[bufferView.buffer];
    if (byteOffset + byteLength > loadedBufferView.byteLength) {
      throw new Error("Buffer access is out of range");
    }
    var buffer = loadedBufferView.buffer;
    byteOffset += loadedBufferView.byteOffset;
    switch (componentType) {
      case EComponentType.BYTE:
        return new Int8Array(buffer, byteOffset, byteLength);
      case EComponentType.UNSIGNED_BYTE:
        return new Uint8Array(buffer, byteOffset, byteLength);
      case EComponentType.SHORT:
        return new Int16Array(buffer, byteOffset, byteLength);
      case EComponentType.UNSIGNED_SHORT:
        return new Uint16Array(buffer, byteOffset, byteLength);
      default:
        return new Float32Array(buffer, byteOffset, byteLength);
    }
  };
  GLTFUtils2.GetBufferFromAccessor = function(gltfRuntime, accessor) {
    var bufferView = gltfRuntime.bufferViews[accessor.bufferView];
    var byteLength = accessor.count * GLTFUtils2.GetByteStrideFromType(accessor);
    return GLTFUtils2.GetBufferFromBufferView(gltfRuntime, bufferView, accessor.byteOffset, byteLength, accessor.componentType);
  };
  GLTFUtils2.DecodeBufferToText = function(view) {
    var result = "";
    var length = view.byteLength;
    for (var i = 0; i < length; ++i) {
      result += String.fromCharCode(view[i]);
    }
    return result;
  };
  GLTFUtils2.GetDefaultMaterial = function(scene) {
    if (!GLTFUtils2._DefaultMaterial) {
      Effect.ShadersStore["GLTFDefaultMaterialVertexShader"] = [
        "precision highp float;",
        "",
        "uniform mat4 worldView;",
        "uniform mat4 projection;",
        "",
        "attribute vec3 position;",
        "",
        "void main(void)",
        "{",
        "    gl_Position = projection * worldView * vec4(position, 1.0);",
        "}"
      ].join("\n");
      Effect.ShadersStore["GLTFDefaultMaterialPixelShader"] = [
        "precision highp float;",
        "",
        "uniform vec4 u_emission;",
        "",
        "void main(void)",
        "{",
        "    gl_FragColor = u_emission;",
        "}"
      ].join("\n");
      var shaderPath = {
        vertex: "GLTFDefaultMaterial",
        fragment: "GLTFDefaultMaterial"
      };
      var options = {
        attributes: ["position"],
        uniforms: ["worldView", "projection", "u_emission"],
        samplers: new Array(),
        needAlphaBlending: false
      };
      GLTFUtils2._DefaultMaterial = new ShaderMaterial("GLTFDefaultMaterial", scene, shaderPath, options);
      GLTFUtils2._DefaultMaterial.setColor4("u_emission", new Color4(0.5, 0.5, 0.5, 1));
    }
    return GLTFUtils2._DefaultMaterial;
  };
  GLTFUtils2._DefaultMaterial = null;
  return GLTFUtils2;
}();

// node_modules/@babylonjs/loaders/glTF/1.0/glTFLoader.js
var ETokenType;
(function(ETokenType2) {
  ETokenType2[ETokenType2["IDENTIFIER"] = 1] = "IDENTIFIER";
  ETokenType2[ETokenType2["UNKNOWN"] = 2] = "UNKNOWN";
  ETokenType2[ETokenType2["END_OF_INPUT"] = 3] = "END_OF_INPUT";
})(ETokenType || (ETokenType = {}));
var Tokenizer = function() {
  function Tokenizer2(toParse) {
    this._pos = 0;
    this.currentToken = ETokenType.UNKNOWN;
    this.currentIdentifier = "";
    this.currentString = "";
    this.isLetterOrDigitPattern = /^[a-zA-Z0-9]+$/;
    this._toParse = toParse;
    this._maxPos = toParse.length;
  }
  Tokenizer2.prototype.getNextToken = function() {
    if (this.isEnd()) {
      return ETokenType.END_OF_INPUT;
    }
    this.currentString = this.read();
    this.currentToken = ETokenType.UNKNOWN;
    if (this.currentString === "_" || this.isLetterOrDigitPattern.test(this.currentString)) {
      this.currentToken = ETokenType.IDENTIFIER;
      this.currentIdentifier = this.currentString;
      while (!this.isEnd() && (this.isLetterOrDigitPattern.test(this.currentString = this.peek()) || this.currentString === "_")) {
        this.currentIdentifier += this.currentString;
        this.forward();
      }
    }
    return this.currentToken;
  };
  Tokenizer2.prototype.peek = function() {
    return this._toParse[this._pos];
  };
  Tokenizer2.prototype.read = function() {
    return this._toParse[this._pos++];
  };
  Tokenizer2.prototype.forward = function() {
    this._pos++;
  };
  Tokenizer2.prototype.isEnd = function() {
    return this._pos >= this._maxPos;
  };
  return Tokenizer2;
}();
var glTFTransforms = ["MODEL", "VIEW", "PROJECTION", "MODELVIEW", "MODELVIEWPROJECTION", "JOINTMATRIX"];
var babylonTransforms = ["world", "view", "projection", "worldView", "worldViewProjection", "mBones"];
var glTFAnimationPaths = ["translation", "rotation", "scale"];
var babylonAnimationPaths = ["position", "rotationQuaternion", "scaling"];
var parseBuffers = function(parsedBuffers, gltfRuntime) {
  for (var buf in parsedBuffers) {
    var parsedBuffer = parsedBuffers[buf];
    gltfRuntime.buffers[buf] = parsedBuffer;
    gltfRuntime.buffersCount++;
  }
};
var parseShaders = function(parsedShaders, gltfRuntime) {
  for (var sha in parsedShaders) {
    var parsedShader = parsedShaders[sha];
    gltfRuntime.shaders[sha] = parsedShader;
    gltfRuntime.shaderscount++;
  }
};
var parseObject = function(parsedObjects, runtimeProperty, gltfRuntime) {
  for (var object in parsedObjects) {
    var parsedObject = parsedObjects[object];
    gltfRuntime[runtimeProperty][object] = parsedObject;
  }
};
var normalizeUVs = function(buffer) {
  if (!buffer) {
    return;
  }
  for (var i = 0; i < buffer.length / 2; i++) {
    buffer[i * 2 + 1] = 1 - buffer[i * 2 + 1];
  }
};
var getAttribute = function(attributeParameter) {
  if (attributeParameter.semantic === "NORMAL") {
    return "normal";
  } else if (attributeParameter.semantic === "POSITION") {
    return "position";
  } else if (attributeParameter.semantic === "JOINT") {
    return "matricesIndices";
  } else if (attributeParameter.semantic === "WEIGHT") {
    return "matricesWeights";
  } else if (attributeParameter.semantic === "COLOR") {
    return "color";
  } else if (attributeParameter.semantic && attributeParameter.semantic.indexOf("TEXCOORD_") !== -1) {
    var channel = Number(attributeParameter.semantic.split("_")[1]);
    return "uv" + (channel === 0 ? "" : channel + 1);
  }
  return null;
};
var loadAnimations = function(gltfRuntime) {
  for (var anim in gltfRuntime.animations) {
    var animation = gltfRuntime.animations[anim];
    if (!animation.channels || !animation.samplers) {
      continue;
    }
    var lastAnimation = null;
    for (var i = 0; i < animation.channels.length; i++) {
      var channel = animation.channels[i];
      var sampler = animation.samplers[channel.sampler];
      if (!sampler) {
        continue;
      }
      var inputData = null;
      var outputData = null;
      if (animation.parameters) {
        inputData = animation.parameters[sampler.input];
        outputData = animation.parameters[sampler.output];
      } else {
        inputData = sampler.input;
        outputData = sampler.output;
      }
      var bufferInput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[inputData]);
      var bufferOutput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[outputData]);
      var targetID = channel.target.id;
      var targetNode = gltfRuntime.scene.getNodeByID(targetID);
      if (targetNode === null) {
        targetNode = gltfRuntime.scene.getNodeByName(targetID);
      }
      if (targetNode === null) {
        Tools.Warn("Creating animation named " + anim + ". But cannot find node named " + targetID + " to attach to");
        continue;
      }
      var isBone = targetNode instanceof Bone;
      var targetPath = channel.target.path;
      var targetPathIndex = glTFAnimationPaths.indexOf(targetPath);
      if (targetPathIndex !== -1) {
        targetPath = babylonAnimationPaths[targetPathIndex];
      }
      var animationType = Animation.ANIMATIONTYPE_MATRIX;
      if (!isBone) {
        if (targetPath === "rotationQuaternion") {
          animationType = Animation.ANIMATIONTYPE_QUATERNION;
          targetNode.rotationQuaternion = new Quaternion();
        } else {
          animationType = Animation.ANIMATIONTYPE_VECTOR3;
        }
      }
      var babylonAnimation = null;
      var keys = [];
      var arrayOffset = 0;
      var modifyKey = false;
      if (isBone && lastAnimation && lastAnimation.getKeys().length === bufferInput.length) {
        babylonAnimation = lastAnimation;
        modifyKey = true;
      }
      if (!modifyKey) {
        gltfRuntime.scene._blockEntityCollection = gltfRuntime.forAssetContainer;
        babylonAnimation = new Animation(anim, isBone ? "_matrix" : targetPath, 1, animationType, Animation.ANIMATIONLOOPMODE_CYCLE);
        gltfRuntime.scene._blockEntityCollection = false;
      }
      for (var j = 0; j < bufferInput.length; j++) {
        var value = null;
        if (targetPath === "rotationQuaternion") {
          value = Quaternion.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2], bufferOutput[arrayOffset + 3]]);
          arrayOffset += 4;
        } else {
          value = Vector3.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2]]);
          arrayOffset += 3;
        }
        if (isBone) {
          var bone = targetNode;
          var translation = Vector3.Zero();
          var rotationQuaternion = new Quaternion();
          var scaling = Vector3.Zero();
          var mat = bone.getBaseMatrix();
          if (modifyKey && lastAnimation) {
            mat = lastAnimation.getKeys()[j].value;
          }
          mat.decompose(scaling, rotationQuaternion, translation);
          if (targetPath === "position") {
            translation = value;
          } else if (targetPath === "rotationQuaternion") {
            rotationQuaternion = value;
          } else {
            scaling = value;
          }
          value = Matrix.Compose(scaling, rotationQuaternion, translation);
        }
        if (!modifyKey) {
          keys.push({
            frame: bufferInput[j],
            value
          });
        } else if (lastAnimation) {
          lastAnimation.getKeys()[j].value = value;
        }
      }
      if (!modifyKey && babylonAnimation) {
        babylonAnimation.setKeys(keys);
        targetNode.animations.push(babylonAnimation);
      }
      lastAnimation = babylonAnimation;
      gltfRuntime.scene.stopAnimation(targetNode);
      gltfRuntime.scene.beginAnimation(targetNode, 0, bufferInput[bufferInput.length - 1], true, 1);
    }
  }
};
var configureBoneTransformation = function(node) {
  var mat = null;
  if (node.translation || node.rotation || node.scale) {
    var scale = Vector3.FromArray(node.scale || [1, 1, 1]);
    var rotation = Quaternion.FromArray(node.rotation || [0, 0, 0, 1]);
    var position = Vector3.FromArray(node.translation || [0, 0, 0]);
    mat = Matrix.Compose(scale, rotation, position);
  } else {
    mat = Matrix.FromArray(node.matrix);
  }
  return mat;
};
var getParentBone = function(gltfRuntime, skins, jointName, newSkeleton) {
  for (var i = 0; i < newSkeleton.bones.length; i++) {
    if (newSkeleton.bones[i].name === jointName) {
      return newSkeleton.bones[i];
    }
  }
  var nodes = gltfRuntime.nodes;
  for (var nde in nodes) {
    var node = nodes[nde];
    if (!node.jointName) {
      continue;
    }
    var children = node.children;
    for (var i = 0; i < children.length; i++) {
      var child = gltfRuntime.nodes[children[i]];
      if (!child.jointName) {
        continue;
      }
      if (child.jointName === jointName) {
        var mat = configureBoneTransformation(node);
        var bone = new Bone(node.name || "", newSkeleton, getParentBone(gltfRuntime, skins, node.jointName, newSkeleton), mat);
        bone.id = nde;
        return bone;
      }
    }
  }
  return null;
};
var getNodeToRoot = function(nodesToRoot, id) {
  for (var i = 0; i < nodesToRoot.length; i++) {
    var nodeToRoot = nodesToRoot[i];
    for (var j = 0; j < nodeToRoot.node.children.length; j++) {
      var child = nodeToRoot.node.children[j];
      if (child === id) {
        return nodeToRoot.bone;
      }
    }
  }
  return null;
};
var getJointNode = function(gltfRuntime, jointName) {
  var nodes = gltfRuntime.nodes;
  var node = nodes[jointName];
  if (node) {
    return {
      node,
      id: jointName
    };
  }
  for (var nde in nodes) {
    node = nodes[nde];
    if (node.jointName === jointName) {
      return {
        node,
        id: nde
      };
    }
  }
  return null;
};
var nodeIsInJoints = function(skins, id) {
  for (var i = 0; i < skins.jointNames.length; i++) {
    if (skins.jointNames[i] === id) {
      return true;
    }
  }
  return false;
};
var getNodesToRoot = function(gltfRuntime, newSkeleton, skins, nodesToRoot) {
  for (var nde in gltfRuntime.nodes) {
    var node = gltfRuntime.nodes[nde];
    var id = nde;
    if (!node.jointName || nodeIsInJoints(skins, node.jointName)) {
      continue;
    }
    var mat = configureBoneTransformation(node);
    var bone = new Bone(node.name || "", newSkeleton, null, mat);
    bone.id = id;
    nodesToRoot.push({ bone, node, id });
  }
  for (var i = 0; i < nodesToRoot.length; i++) {
    var nodeToRoot = nodesToRoot[i];
    var children = nodeToRoot.node.children;
    for (var j = 0; j < children.length; j++) {
      var child = null;
      for (var k = 0; k < nodesToRoot.length; k++) {
        if (nodesToRoot[k].id === children[j]) {
          child = nodesToRoot[k];
          break;
        }
      }
      if (child) {
        child.bone._parent = nodeToRoot.bone;
        nodeToRoot.bone.children.push(child.bone);
      }
    }
  }
};
var importSkeleton = function(gltfRuntime, skins, mesh, newSkeleton, id) {
  if (!newSkeleton) {
    newSkeleton = new Skeleton(skins.name || "", "", gltfRuntime.scene);
  }
  if (!skins.babylonSkeleton) {
    return newSkeleton;
  }
  var nodesToRoot = [];
  var nodesToRootToAdd = [];
  getNodesToRoot(gltfRuntime, newSkeleton, skins, nodesToRoot);
  newSkeleton.bones = [];
  for (var i = 0; i < skins.jointNames.length; i++) {
    var jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);
    if (!jointNode) {
      continue;
    }
    var node = jointNode.node;
    if (!node) {
      Tools.Warn("Joint named " + skins.jointNames[i] + " does not exist");
      continue;
    }
    var id = jointNode.id;
    var existingBone = gltfRuntime.scene.getBoneByID(id);
    if (existingBone) {
      newSkeleton.bones.push(existingBone);
      continue;
    }
    var foundBone = false;
    var parentBone = null;
    for (var j = 0; j < i; j++) {
      var jointNode_1 = getJointNode(gltfRuntime, skins.jointNames[j]);
      if (!jointNode_1) {
        continue;
      }
      var joint = jointNode_1.node;
      if (!joint) {
        Tools.Warn("Joint named " + skins.jointNames[j] + " does not exist when looking for parent");
        continue;
      }
      var children = joint.children;
      if (!children) {
        continue;
      }
      foundBone = false;
      for (var k = 0; k < children.length; k++) {
        if (children[k] === id) {
          parentBone = getParentBone(gltfRuntime, skins, skins.jointNames[j], newSkeleton);
          foundBone = true;
          break;
        }
      }
      if (foundBone) {
        break;
      }
    }
    var mat = configureBoneTransformation(node);
    if (!parentBone && nodesToRoot.length > 0) {
      parentBone = getNodeToRoot(nodesToRoot, id);
      if (parentBone) {
        if (nodesToRootToAdd.indexOf(parentBone) === -1) {
          nodesToRootToAdd.push(parentBone);
        }
      }
    }
    var bone = new Bone(node.jointName || "", newSkeleton, parentBone, mat);
    bone.id = id;
  }
  var bones = newSkeleton.bones;
  newSkeleton.bones = [];
  for (var i = 0; i < skins.jointNames.length; i++) {
    var jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);
    if (!jointNode) {
      continue;
    }
    for (var j = 0; j < bones.length; j++) {
      if (bones[j].id === jointNode.id) {
        newSkeleton.bones.push(bones[j]);
        break;
      }
    }
  }
  newSkeleton.prepare();
  for (var i = 0; i < nodesToRootToAdd.length; i++) {
    newSkeleton.bones.push(nodesToRootToAdd[i]);
  }
  return newSkeleton;
};
var importMesh = function(gltfRuntime, node, meshes, id, newMesh) {
  if (!newMesh) {
    gltfRuntime.scene._blockEntityCollection = gltfRuntime.forAssetContainer;
    newMesh = new Mesh(node.name || "", gltfRuntime.scene);
    gltfRuntime.scene._blockEntityCollection = false;
    newMesh.id = id;
  }
  if (!node.babylonNode) {
    return newMesh;
  }
  var subMaterials = [];
  var vertexData = null;
  var verticesStarts = new Array();
  var verticesCounts = new Array();
  var indexStarts = new Array();
  var indexCounts = new Array();
  for (var meshIndex = 0; meshIndex < meshes.length; meshIndex++) {
    var meshID = meshes[meshIndex];
    var mesh = gltfRuntime.meshes[meshID];
    if (!mesh) {
      continue;
    }
    for (var i = 0; i < mesh.primitives.length; i++) {
      var tempVertexData = new VertexData();
      var primitive = mesh.primitives[i];
      if (primitive.mode !== 4) {
      }
      var attributes = primitive.attributes;
      var accessor = null;
      var buffer = null;
      for (var semantic in attributes) {
        accessor = gltfRuntime.accessors[attributes[semantic]];
        buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);
        if (semantic === "NORMAL") {
          tempVertexData.normals = new Float32Array(buffer.length);
          tempVertexData.normals.set(buffer);
        } else if (semantic === "POSITION") {
          if (GLTFFileLoader.HomogeneousCoordinates) {
            tempVertexData.positions = new Float32Array(buffer.length - buffer.length / 4);
            for (var j = 0; j < buffer.length; j += 4) {
              tempVertexData.positions[j] = buffer[j];
              tempVertexData.positions[j + 1] = buffer[j + 1];
              tempVertexData.positions[j + 2] = buffer[j + 2];
            }
          } else {
            tempVertexData.positions = new Float32Array(buffer.length);
            tempVertexData.positions.set(buffer);
          }
          verticesCounts.push(tempVertexData.positions.length);
        } else if (semantic.indexOf("TEXCOORD_") !== -1) {
          var channel = Number(semantic.split("_")[1]);
          var uvKind = VertexBuffer.UVKind + (channel === 0 ? "" : channel + 1);
          var uvs = new Float32Array(buffer.length);
          uvs.set(buffer);
          normalizeUVs(uvs);
          tempVertexData.set(uvs, uvKind);
        } else if (semantic === "JOINT") {
          tempVertexData.matricesIndices = new Float32Array(buffer.length);
          tempVertexData.matricesIndices.set(buffer);
        } else if (semantic === "WEIGHT") {
          tempVertexData.matricesWeights = new Float32Array(buffer.length);
          tempVertexData.matricesWeights.set(buffer);
        } else if (semantic === "COLOR") {
          tempVertexData.colors = new Float32Array(buffer.length);
          tempVertexData.colors.set(buffer);
        }
      }
      accessor = gltfRuntime.accessors[primitive.indices];
      if (accessor) {
        buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);
        tempVertexData.indices = new Int32Array(buffer.length);
        tempVertexData.indices.set(buffer);
        indexCounts.push(tempVertexData.indices.length);
      } else {
        var indices = [];
        for (var j = 0; j < tempVertexData.positions.length / 3; j++) {
          indices.push(j);
        }
        tempVertexData.indices = new Int32Array(indices);
        indexCounts.push(tempVertexData.indices.length);
      }
      if (!vertexData) {
        vertexData = tempVertexData;
      } else {
        vertexData.merge(tempVertexData);
      }
      var material_1 = gltfRuntime.scene.getMaterialByID(primitive.material);
      subMaterials.push(material_1 === null ? GLTFUtils.GetDefaultMaterial(gltfRuntime.scene) : material_1);
      verticesStarts.push(verticesStarts.length === 0 ? 0 : verticesStarts[verticesStarts.length - 1] + verticesCounts[verticesCounts.length - 2]);
      indexStarts.push(indexStarts.length === 0 ? 0 : indexStarts[indexStarts.length - 1] + indexCounts[indexCounts.length - 2]);
    }
  }
  var material;
  gltfRuntime.scene._blockEntityCollection = gltfRuntime.forAssetContainer;
  if (subMaterials.length > 1) {
    material = new MultiMaterial("multimat" + id, gltfRuntime.scene);
    material.subMaterials = subMaterials;
  } else {
    material = new StandardMaterial("multimat" + id, gltfRuntime.scene);
  }
  if (subMaterials.length === 1) {
    material = subMaterials[0];
  }
  if (!newMesh.material) {
    newMesh.material = material;
  }
  new Geometry(id, gltfRuntime.scene, vertexData, false, newMesh);
  newMesh.computeWorldMatrix(true);
  gltfRuntime.scene._blockEntityCollection = false;
  newMesh.subMeshes = [];
  var index = 0;
  for (var meshIndex = 0; meshIndex < meshes.length; meshIndex++) {
    var meshID = meshes[meshIndex];
    var mesh = gltfRuntime.meshes[meshID];
    if (!mesh) {
      continue;
    }
    for (var i = 0; i < mesh.primitives.length; i++) {
      if (mesh.primitives[i].mode !== 4) {
      }
      SubMesh.AddToMesh(index, verticesStarts[index], verticesCounts[index], indexStarts[index], indexCounts[index], newMesh, newMesh, true);
      index++;
    }
  }
  return newMesh;
};
var configureNode = function(newNode, position, rotation, scaling) {
  if (newNode.position) {
    newNode.position = position;
  }
  if (newNode.rotationQuaternion || newNode.rotation) {
    newNode.rotationQuaternion = rotation;
  }
  if (newNode.scaling) {
    newNode.scaling = scaling;
  }
};
var configureNodeFromMatrix = function(newNode, node, parent) {
  if (node.matrix) {
    var position = new Vector3(0, 0, 0);
    var rotation = new Quaternion();
    var scaling = new Vector3(0, 0, 0);
    var mat = Matrix.FromArray(node.matrix);
    mat.decompose(scaling, rotation, position);
    configureNode(newNode, position, rotation, scaling);
  } else if (node.translation && node.rotation && node.scale) {
    configureNode(newNode, Vector3.FromArray(node.translation), Quaternion.FromArray(node.rotation), Vector3.FromArray(node.scale));
  }
  newNode.computeWorldMatrix(true);
};
var importNode = function(gltfRuntime, node, id, parent) {
  var lastNode = null;
  if (gltfRuntime.importOnlyMeshes && (node.skin || node.meshes)) {
    if (gltfRuntime.importMeshesNames && gltfRuntime.importMeshesNames.length > 0 && gltfRuntime.importMeshesNames.indexOf(node.name || "") === -1) {
      return null;
    }
  }
  if (node.skin) {
    if (node.meshes) {
      var skin = gltfRuntime.skins[node.skin];
      var newMesh = importMesh(gltfRuntime, node, node.meshes, id, node.babylonNode);
      newMesh.skeleton = gltfRuntime.scene.getLastSkeletonByID(node.skin);
      if (newMesh.skeleton === null) {
        newMesh.skeleton = importSkeleton(gltfRuntime, skin, newMesh, skin.babylonSkeleton, node.skin);
        if (!skin.babylonSkeleton) {
          skin.babylonSkeleton = newMesh.skeleton;
        }
      }
      lastNode = newMesh;
    }
  } else if (node.meshes) {
    var newMesh = importMesh(gltfRuntime, node, node.mesh ? [node.mesh] : node.meshes, id, node.babylonNode);
    lastNode = newMesh;
  } else if (node.light && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {
    var light = gltfRuntime.lights[node.light];
    if (light) {
      if (light.type === "ambient") {
        var ambienLight = light[light.type];
        var hemiLight = new HemisphericLight(node.light, Vector3.Zero(), gltfRuntime.scene);
        hemiLight.name = node.name || "";
        if (ambienLight.color) {
          hemiLight.diffuse = Color3.FromArray(ambienLight.color);
        }
        lastNode = hemiLight;
      } else if (light.type === "directional") {
        var directionalLight = light[light.type];
        var dirLight = new DirectionalLight(node.light, Vector3.Zero(), gltfRuntime.scene);
        dirLight.name = node.name || "";
        if (directionalLight.color) {
          dirLight.diffuse = Color3.FromArray(directionalLight.color);
        }
        lastNode = dirLight;
      } else if (light.type === "point") {
        var pointLight = light[light.type];
        var ptLight = new PointLight(node.light, Vector3.Zero(), gltfRuntime.scene);
        ptLight.name = node.name || "";
        if (pointLight.color) {
          ptLight.diffuse = Color3.FromArray(pointLight.color);
        }
        lastNode = ptLight;
      } else if (light.type === "spot") {
        var spotLight = light[light.type];
        var spLight = new SpotLight(node.light, Vector3.Zero(), Vector3.Zero(), 0, 0, gltfRuntime.scene);
        spLight.name = node.name || "";
        if (spotLight.color) {
          spLight.diffuse = Color3.FromArray(spotLight.color);
        }
        if (spotLight.fallOfAngle) {
          spLight.angle = spotLight.fallOfAngle;
        }
        if (spotLight.fallOffExponent) {
          spLight.exponent = spotLight.fallOffExponent;
        }
        lastNode = spLight;
      }
    }
  } else if (node.camera && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {
    var camera = gltfRuntime.cameras[node.camera];
    if (camera) {
      gltfRuntime.scene._blockEntityCollection = gltfRuntime.forAssetContainer;
      if (camera.type === "orthographic") {
        var orthoCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);
        orthoCamera.name = node.name || "";
        orthoCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;
        orthoCamera.attachControl();
        lastNode = orthoCamera;
      } else if (camera.type === "perspective") {
        var perspectiveCamera = camera[camera.type];
        var persCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);
        persCamera.name = node.name || "";
        persCamera.attachControl();
        if (!perspectiveCamera.aspectRatio) {
          perspectiveCamera.aspectRatio = gltfRuntime.scene.getEngine().getRenderWidth() / gltfRuntime.scene.getEngine().getRenderHeight();
        }
        if (perspectiveCamera.znear && perspectiveCamera.zfar) {
          persCamera.maxZ = perspectiveCamera.zfar;
          persCamera.minZ = perspectiveCamera.znear;
        }
        lastNode = persCamera;
      }
      gltfRuntime.scene._blockEntityCollection = false;
    }
  }
  if (!node.jointName) {
    if (node.babylonNode) {
      return node.babylonNode;
    } else if (lastNode === null) {
      gltfRuntime.scene._blockEntityCollection = gltfRuntime.forAssetContainer;
      var dummy = new Mesh(node.name || "", gltfRuntime.scene);
      gltfRuntime.scene._blockEntityCollection = false;
      node.babylonNode = dummy;
      lastNode = dummy;
    }
  }
  if (lastNode !== null) {
    if (node.matrix && lastNode instanceof Mesh) {
      configureNodeFromMatrix(lastNode, node, parent);
    } else {
      var translation = node.translation || [0, 0, 0];
      var rotation = node.rotation || [0, 0, 0, 1];
      var scale = node.scale || [1, 1, 1];
      configureNode(lastNode, Vector3.FromArray(translation), Quaternion.FromArray(rotation), Vector3.FromArray(scale));
    }
    lastNode.updateCache(true);
    node.babylonNode = lastNode;
  }
  return lastNode;
};
var traverseNodes = function(gltfRuntime, id, parent, meshIncluded) {
  if (meshIncluded === void 0) {
    meshIncluded = false;
  }
  var node = gltfRuntime.nodes[id];
  var newNode = null;
  if (gltfRuntime.importOnlyMeshes && !meshIncluded && gltfRuntime.importMeshesNames) {
    if (gltfRuntime.importMeshesNames.indexOf(node.name || "") !== -1 || gltfRuntime.importMeshesNames.length === 0) {
      meshIncluded = true;
    } else {
      meshIncluded = false;
    }
  } else {
    meshIncluded = true;
  }
  if (!node.jointName && meshIncluded) {
    newNode = importNode(gltfRuntime, node, id, parent);
    if (newNode !== null) {
      newNode.id = id;
      newNode.parent = parent;
    }
  }
  if (node.children) {
    for (var i = 0; i < node.children.length; i++) {
      traverseNodes(gltfRuntime, node.children[i], newNode, meshIncluded);
    }
  }
};
var postLoad = function(gltfRuntime) {
  var currentScene = gltfRuntime.currentScene;
  if (currentScene) {
    for (var i = 0; i < currentScene.nodes.length; i++) {
      traverseNodes(gltfRuntime, currentScene.nodes[i], null);
    }
  } else {
    for (var thing in gltfRuntime.scenes) {
      currentScene = gltfRuntime.scenes[thing];
      for (var i = 0; i < currentScene.nodes.length; i++) {
        traverseNodes(gltfRuntime, currentScene.nodes[i], null);
      }
    }
  }
  loadAnimations(gltfRuntime);
  for (var i = 0; i < gltfRuntime.scene.skeletons.length; i++) {
    var skeleton = gltfRuntime.scene.skeletons[i];
    gltfRuntime.scene.beginAnimation(skeleton, 0, Number.MAX_VALUE, true, 1);
  }
};
var onBindShaderMaterial = function(mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess) {
  var materialValues = material.values || technique.parameters;
  for (var unif in unTreatedUniforms) {
    var uniform = unTreatedUniforms[unif];
    var type = uniform.type;
    if (type === EParameterType.FLOAT_MAT2 || type === EParameterType.FLOAT_MAT3 || type === EParameterType.FLOAT_MAT4) {
      if (uniform.semantic && !uniform.source && !uniform.node) {
        GLTFUtils.SetMatrix(gltfRuntime.scene, mesh, uniform, unif, shaderMaterial.getEffect());
      } else if (uniform.semantic && (uniform.source || uniform.node)) {
        var source = gltfRuntime.scene.getNodeByName(uniform.source || uniform.node || "");
        if (source === null) {
          source = gltfRuntime.scene.getNodeByID(uniform.source || uniform.node || "");
        }
        if (source === null) {
          continue;
        }
        GLTFUtils.SetMatrix(gltfRuntime.scene, source, uniform, unif, shaderMaterial.getEffect());
      }
    } else {
      var value = materialValues[technique.uniforms[unif]];
      if (!value) {
        continue;
      }
      if (type === EParameterType.SAMPLER_2D) {
        var texture = gltfRuntime.textures[material.values ? value : uniform.value].babylonTexture;
        if (texture === null || texture === void 0) {
          continue;
        }
        shaderMaterial.getEffect().setTexture(unif, texture);
      } else {
        GLTFUtils.SetUniform(shaderMaterial.getEffect(), unif, value, type);
      }
    }
  }
  onSuccess(shaderMaterial);
};
var prepareShaderMaterialUniforms = function(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms) {
  var materialValues = material.values || technique.parameters;
  var techniqueUniforms = technique.uniforms;
  for (var unif in unTreatedUniforms) {
    var uniform = unTreatedUniforms[unif];
    var type = uniform.type;
    var value = materialValues[techniqueUniforms[unif]];
    if (value === void 0) {
      value = uniform.value;
    }
    if (!value) {
      continue;
    }
    var onLoadTexture = function(uniformName) {
      return function(texture) {
        if (uniform.value && uniformName) {
          shaderMaterial.setTexture(uniformName, texture);
          delete unTreatedUniforms[uniformName];
        }
      };
    };
    if (type === EParameterType.SAMPLER_2D) {
      GLTFLoaderExtension.LoadTextureAsync(gltfRuntime, material.values ? value : uniform.value, onLoadTexture(unif), function() {
        return onLoadTexture(null);
      });
    } else {
      if (uniform.value && GLTFUtils.SetUniform(shaderMaterial, unif, material.values ? value : uniform.value, type)) {
        delete unTreatedUniforms[unif];
      }
    }
  }
};
var onShaderCompileError = function(program, shaderMaterial, onError) {
  return function(effect, error) {
    shaderMaterial.dispose(true);
    onError("Cannot compile program named " + program.name + ". Error: " + error + ". Default material will be applied");
  };
};
var onShaderCompileSuccess = function(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess) {
  return function(_) {
    prepareShaderMaterialUniforms(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms);
    shaderMaterial.onBind = function(mesh) {
      onBindShaderMaterial(mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess);
    };
  };
};
var parseShaderUniforms = function(tokenizer, technique, unTreatedUniforms) {
  for (var unif in technique.uniforms) {
    var uniform = technique.uniforms[unif];
    var uniformParameter = technique.parameters[uniform];
    if (tokenizer.currentIdentifier === unif) {
      if (uniformParameter.semantic && !uniformParameter.source && !uniformParameter.node) {
        var transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);
        if (transformIndex !== -1) {
          delete unTreatedUniforms[unif];
          return babylonTransforms[transformIndex];
        }
      }
    }
  }
  return tokenizer.currentIdentifier;
};
var importMaterials = function(gltfRuntime) {
  for (var mat in gltfRuntime.materials) {
    GLTFLoaderExtension.LoadMaterialAsync(gltfRuntime, mat, function(material) {
    }, function() {
    });
  }
};
var GLTFLoaderBase = function() {
  function GLTFLoaderBase2() {
  }
  GLTFLoaderBase2.CreateRuntime = function(parsedData, scene, rootUrl) {
    var gltfRuntime = {
      extensions: {},
      accessors: {},
      buffers: {},
      bufferViews: {},
      meshes: {},
      lights: {},
      cameras: {},
      nodes: {},
      images: {},
      textures: {},
      shaders: {},
      programs: {},
      samplers: {},
      techniques: {},
      materials: {},
      animations: {},
      skins: {},
      extensionsUsed: [],
      scenes: {},
      buffersCount: 0,
      shaderscount: 0,
      scene,
      rootUrl,
      loadedBufferCount: 0,
      loadedBufferViews: {},
      loadedShaderCount: 0,
      importOnlyMeshes: false,
      dummyNodes: [],
      forAssetContainer: false
    };
    if (parsedData.extensions) {
      parseObject(parsedData.extensions, "extensions", gltfRuntime);
    }
    if (parsedData.extensionsUsed) {
      parseObject(parsedData.extensionsUsed, "extensionsUsed", gltfRuntime);
    }
    if (parsedData.buffers) {
      parseBuffers(parsedData.buffers, gltfRuntime);
    }
    if (parsedData.bufferViews) {
      parseObject(parsedData.bufferViews, "bufferViews", gltfRuntime);
    }
    if (parsedData.accessors) {
      parseObject(parsedData.accessors, "accessors", gltfRuntime);
    }
    if (parsedData.meshes) {
      parseObject(parsedData.meshes, "meshes", gltfRuntime);
    }
    if (parsedData.lights) {
      parseObject(parsedData.lights, "lights", gltfRuntime);
    }
    if (parsedData.cameras) {
      parseObject(parsedData.cameras, "cameras", gltfRuntime);
    }
    if (parsedData.nodes) {
      parseObject(parsedData.nodes, "nodes", gltfRuntime);
    }
    if (parsedData.images) {
      parseObject(parsedData.images, "images", gltfRuntime);
    }
    if (parsedData.textures) {
      parseObject(parsedData.textures, "textures", gltfRuntime);
    }
    if (parsedData.shaders) {
      parseShaders(parsedData.shaders, gltfRuntime);
    }
    if (parsedData.programs) {
      parseObject(parsedData.programs, "programs", gltfRuntime);
    }
    if (parsedData.samplers) {
      parseObject(parsedData.samplers, "samplers", gltfRuntime);
    }
    if (parsedData.techniques) {
      parseObject(parsedData.techniques, "techniques", gltfRuntime);
    }
    if (parsedData.materials) {
      parseObject(parsedData.materials, "materials", gltfRuntime);
    }
    if (parsedData.animations) {
      parseObject(parsedData.animations, "animations", gltfRuntime);
    }
    if (parsedData.skins) {
      parseObject(parsedData.skins, "skins", gltfRuntime);
    }
    if (parsedData.scenes) {
      gltfRuntime.scenes = parsedData.scenes;
    }
    if (parsedData.scene && parsedData.scenes) {
      gltfRuntime.currentScene = parsedData.scenes[parsedData.scene];
    }
    return gltfRuntime;
  };
  GLTFLoaderBase2.LoadBufferAsync = function(gltfRuntime, id, onSuccess, onError, onProgress) {
    var buffer = gltfRuntime.buffers[id];
    if (Tools.IsBase64(buffer.uri)) {
      setTimeout(function() {
        return onSuccess(new Uint8Array(Tools.DecodeBase64(buffer.uri)));
      });
    } else {
      Tools.LoadFile(gltfRuntime.rootUrl + buffer.uri, function(data) {
        return onSuccess(new Uint8Array(data));
      }, onProgress, void 0, true, function(request) {
        if (request) {
          onError(request.status + " " + request.statusText);
        }
      });
    }
  };
  GLTFLoaderBase2.LoadTextureBufferAsync = function(gltfRuntime, id, onSuccess, onError) {
    var texture = gltfRuntime.textures[id];
    if (!texture || !texture.source) {
      onError("");
      return;
    }
    if (texture.babylonTexture) {
      onSuccess(null);
      return;
    }
    var source = gltfRuntime.images[texture.source];
    if (Tools.IsBase64(source.uri)) {
      setTimeout(function() {
        return onSuccess(new Uint8Array(Tools.DecodeBase64(source.uri)));
      });
    } else {
      Tools.LoadFile(gltfRuntime.rootUrl + source.uri, function(data) {
        return onSuccess(new Uint8Array(data));
      }, void 0, void 0, true, function(request) {
        if (request) {
          onError(request.status + " " + request.statusText);
        }
      });
    }
  };
  GLTFLoaderBase2.CreateTextureAsync = function(gltfRuntime, id, buffer, onSuccess, onError) {
    var texture = gltfRuntime.textures[id];
    if (texture.babylonTexture) {
      onSuccess(texture.babylonTexture);
      return;
    }
    var sampler = gltfRuntime.samplers[texture.sampler];
    var createMipMaps = sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_NEAREST || sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_LINEAR || sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_NEAREST || sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_LINEAR;
    var samplingMode = Texture.BILINEAR_SAMPLINGMODE;
    var blob = buffer == null ? new Blob() : new Blob([buffer]);
    var blobURL = URL.createObjectURL(blob);
    var revokeBlobURL = function() {
      return URL.revokeObjectURL(blobURL);
    };
    var newTexture = new Texture(blobURL, gltfRuntime.scene, !createMipMaps, true, samplingMode, revokeBlobURL, revokeBlobURL);
    if (sampler.wrapS !== void 0) {
      newTexture.wrapU = GLTFUtils.GetWrapMode(sampler.wrapS);
    }
    if (sampler.wrapT !== void 0) {
      newTexture.wrapV = GLTFUtils.GetWrapMode(sampler.wrapT);
    }
    newTexture.name = id;
    texture.babylonTexture = newTexture;
    onSuccess(newTexture);
  };
  GLTFLoaderBase2.LoadShaderStringAsync = function(gltfRuntime, id, onSuccess, onError) {
    var shader = gltfRuntime.shaders[id];
    if (Tools.IsBase64(shader.uri)) {
      var shaderString = atob(shader.uri.split(",")[1]);
      if (onSuccess) {
        onSuccess(shaderString);
      }
    } else {
      Tools.LoadFile(gltfRuntime.rootUrl + shader.uri, onSuccess, void 0, void 0, false, function(request) {
        if (request && onError) {
          onError(request.status + " " + request.statusText);
        }
      });
    }
  };
  GLTFLoaderBase2.LoadMaterialAsync = function(gltfRuntime, id, onSuccess, onError) {
    var material = gltfRuntime.materials[id];
    if (!material.technique) {
      if (onError) {
        onError("No technique found.");
      }
      return;
    }
    var technique = gltfRuntime.techniques[material.technique];
    if (!technique) {
      gltfRuntime.scene._blockEntityCollection = gltfRuntime.forAssetContainer;
      var defaultMaterial = new StandardMaterial(id, gltfRuntime.scene);
      gltfRuntime.scene._blockEntityCollection = false;
      defaultMaterial.diffuseColor = new Color3(0.5, 0.5, 0.5);
      defaultMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;
      onSuccess(defaultMaterial);
      return;
    }
    var program = gltfRuntime.programs[technique.program];
    var states = technique.states;
    var vertexShader = Effect.ShadersStore[program.vertexShader + "VertexShader"];
    var pixelShader = Effect.ShadersStore[program.fragmentShader + "PixelShader"];
    var newVertexShader = "";
    var newPixelShader = "";
    var vertexTokenizer = new Tokenizer(vertexShader);
    var pixelTokenizer = new Tokenizer(pixelShader);
    var unTreatedUniforms = {};
    var uniforms = [];
    var attributes = [];
    var samplers = [];
    for (var unif in technique.uniforms) {
      var uniform = technique.uniforms[unif];
      var uniformParameter = technique.parameters[uniform];
      unTreatedUniforms[unif] = uniformParameter;
      if (uniformParameter.semantic && !uniformParameter.node && !uniformParameter.source) {
        var transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);
        if (transformIndex !== -1) {
          uniforms.push(babylonTransforms[transformIndex]);
          delete unTreatedUniforms[unif];
        } else {
          uniforms.push(unif);
        }
      } else if (uniformParameter.type === EParameterType.SAMPLER_2D) {
        samplers.push(unif);
      } else {
        uniforms.push(unif);
      }
    }
    for (var attr in technique.attributes) {
      var attribute = technique.attributes[attr];
      var attributeParameter = technique.parameters[attribute];
      if (attributeParameter.semantic) {
        var name_1 = getAttribute(attributeParameter);
        if (name_1) {
          attributes.push(name_1);
        }
      }
    }
    while (!vertexTokenizer.isEnd() && vertexTokenizer.getNextToken()) {
      var tokenType = vertexTokenizer.currentToken;
      if (tokenType !== ETokenType.IDENTIFIER) {
        newVertexShader += vertexTokenizer.currentString;
        continue;
      }
      var foundAttribute = false;
      for (var attr in technique.attributes) {
        var attribute = technique.attributes[attr];
        var attributeParameter = technique.parameters[attribute];
        if (vertexTokenizer.currentIdentifier === attr && attributeParameter.semantic) {
          newVertexShader += getAttribute(attributeParameter);
          foundAttribute = true;
          break;
        }
      }
      if (foundAttribute) {
        continue;
      }
      newVertexShader += parseShaderUniforms(vertexTokenizer, technique, unTreatedUniforms);
    }
    while (!pixelTokenizer.isEnd() && pixelTokenizer.getNextToken()) {
      var tokenType = pixelTokenizer.currentToken;
      if (tokenType !== ETokenType.IDENTIFIER) {
        newPixelShader += pixelTokenizer.currentString;
        continue;
      }
      newPixelShader += parseShaderUniforms(pixelTokenizer, technique, unTreatedUniforms);
    }
    var shaderPath = {
      vertex: program.vertexShader + id,
      fragment: program.fragmentShader + id
    };
    var options = {
      attributes,
      uniforms,
      samplers,
      needAlphaBlending: states && states.enable && states.enable.indexOf(3042) !== -1
    };
    Effect.ShadersStore[program.vertexShader + id + "VertexShader"] = newVertexShader;
    Effect.ShadersStore[program.fragmentShader + id + "PixelShader"] = newPixelShader;
    var shaderMaterial = new ShaderMaterial(id, gltfRuntime.scene, shaderPath, options);
    shaderMaterial.onError = onShaderCompileError(program, shaderMaterial, onError);
    shaderMaterial.onCompiled = onShaderCompileSuccess(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess);
    shaderMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;
    if (states && states.functions) {
      var functions = states.functions;
      if (functions.cullFace && functions.cullFace[0] !== ECullingType.BACK) {
        shaderMaterial.backFaceCulling = false;
      }
      var blendFunc = functions.blendFuncSeparate;
      if (blendFunc) {
        if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_ALPHA && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {
          shaderMaterial.alphaMode = Constants.ALPHA_COMBINE;
        } else if (blendFunc[0] === EBlendingFunction.ONE && blendFunc[1] === EBlendingFunction.ONE && blendFunc[2] === EBlendingFunction.ZERO && blendFunc[3] === EBlendingFunction.ONE) {
          shaderMaterial.alphaMode = Constants.ALPHA_ONEONE;
        } else if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE && blendFunc[2] === EBlendingFunction.ZERO && blendFunc[3] === EBlendingFunction.ONE) {
          shaderMaterial.alphaMode = Constants.ALPHA_ADD;
        } else if (blendFunc[0] === EBlendingFunction.ZERO && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {
          shaderMaterial.alphaMode = Constants.ALPHA_SUBTRACT;
        } else if (blendFunc[0] === EBlendingFunction.DST_COLOR && blendFunc[1] === EBlendingFunction.ZERO && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {
          shaderMaterial.alphaMode = Constants.ALPHA_MULTIPLY;
        } else if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {
          shaderMaterial.alphaMode = Constants.ALPHA_MAXIMIZED;
        }
      }
    }
  };
  return GLTFLoaderBase2;
}();
var GLTFLoader = function() {
  function GLTFLoader3() {
    this.state = null;
  }
  GLTFLoader3.RegisterExtension = function(extension) {
    if (GLTFLoader3.Extensions[extension.name]) {
      Tools.Error('Tool with the same name "' + extension.name + '" already exists');
      return;
    }
    GLTFLoader3.Extensions[extension.name] = extension;
  };
  GLTFLoader3.prototype.dispose = function() {
  };
  GLTFLoader3.prototype._importMeshAsync = function(meshesNames, scene, data, rootUrl, forAssetContainer, onSuccess, onProgress, onError) {
    var _this = this;
    scene.useRightHandedSystem = true;
    GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, function(gltfRuntime) {
      gltfRuntime.forAssetContainer = forAssetContainer;
      gltfRuntime.importOnlyMeshes = true;
      if (meshesNames === "") {
        gltfRuntime.importMeshesNames = [];
      } else if (typeof meshesNames === "string") {
        gltfRuntime.importMeshesNames = [meshesNames];
      } else if (meshesNames && !(meshesNames instanceof Array)) {
        gltfRuntime.importMeshesNames = [meshesNames];
      } else {
        gltfRuntime.importMeshesNames = [];
        Tools.Warn("Argument meshesNames must be of type string or string[]");
      }
      _this._createNodes(gltfRuntime);
      var meshes = new Array();
      var skeletons = new Array();
      for (var nde in gltfRuntime.nodes) {
        var node = gltfRuntime.nodes[nde];
        if (node.babylonNode instanceof AbstractMesh) {
          meshes.push(node.babylonNode);
        }
      }
      for (var skl in gltfRuntime.skins) {
        var skin = gltfRuntime.skins[skl];
        if (skin.babylonSkeleton instanceof Skeleton) {
          skeletons.push(skin.babylonSkeleton);
        }
      }
      _this._loadBuffersAsync(gltfRuntime, function() {
        _this._loadShadersAsync(gltfRuntime, function() {
          importMaterials(gltfRuntime);
          postLoad(gltfRuntime);
          if (!GLTFFileLoader.IncrementalLoading && onSuccess) {
            onSuccess(meshes, skeletons);
          }
        });
      }, onProgress);
      if (GLTFFileLoader.IncrementalLoading && onSuccess) {
        onSuccess(meshes, skeletons);
      }
    }, onError);
    return true;
  };
  GLTFLoader3.prototype.importMeshAsync = function(meshesNames, scene, forAssetContainer, data, rootUrl, onProgress) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      _this._importMeshAsync(meshesNames, scene, data, rootUrl, forAssetContainer, function(meshes, skeletons) {
        resolve({
          meshes,
          particleSystems: [],
          skeletons,
          animationGroups: [],
          lights: [],
          transformNodes: [],
          geometries: []
        });
      }, onProgress, function(message) {
        reject(new Error(message));
      });
    });
  };
  GLTFLoader3.prototype._loadAsync = function(scene, data, rootUrl, forAssetContainer, onSuccess, onProgress, onError) {
    var _this = this;
    scene.useRightHandedSystem = true;
    GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, function(gltfRuntime) {
      GLTFLoaderExtension.LoadRuntimeExtensionsAsync(gltfRuntime, function() {
        _this._createNodes(gltfRuntime);
        _this._loadBuffersAsync(gltfRuntime, function() {
          _this._loadShadersAsync(gltfRuntime, function() {
            importMaterials(gltfRuntime);
            postLoad(gltfRuntime);
            if (!GLTFFileLoader.IncrementalLoading) {
              onSuccess();
            }
          });
        });
        if (GLTFFileLoader.IncrementalLoading) {
          onSuccess();
        }
      }, onError);
    }, onError);
  };
  GLTFLoader3.prototype.loadAsync = function(scene, data, rootUrl, onProgress) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      _this._loadAsync(scene, data, rootUrl, false, function() {
        resolve();
      }, onProgress, function(message) {
        reject(new Error(message));
      });
    });
  };
  GLTFLoader3.prototype._loadShadersAsync = function(gltfRuntime, onload) {
    var hasShaders = false;
    var processShader = function(sha2, shader2) {
      GLTFLoaderExtension.LoadShaderStringAsync(gltfRuntime, sha2, function(shaderString) {
        if (shaderString instanceof ArrayBuffer) {
          return;
        }
        gltfRuntime.loadedShaderCount++;
        if (shaderString) {
          Effect.ShadersStore[sha2 + (shader2.type === EShaderType.VERTEX ? "VertexShader" : "PixelShader")] = shaderString;
        }
        if (gltfRuntime.loadedShaderCount === gltfRuntime.shaderscount) {
          onload();
        }
      }, function() {
        Tools.Error("Error when loading shader program named " + sha2 + " located at " + shader2.uri);
      });
    };
    for (var sha in gltfRuntime.shaders) {
      hasShaders = true;
      var shader = gltfRuntime.shaders[sha];
      if (shader) {
        processShader.bind(this, sha, shader)();
      } else {
        Tools.Error("No shader named: " + sha);
      }
    }
    if (!hasShaders) {
      onload();
    }
  };
  GLTFLoader3.prototype._loadBuffersAsync = function(gltfRuntime, onLoad, onProgress) {
    var hasBuffers = false;
    var processBuffer = function(buf2, buffer2) {
      GLTFLoaderExtension.LoadBufferAsync(gltfRuntime, buf2, function(bufferView) {
        gltfRuntime.loadedBufferCount++;
        if (bufferView) {
          if (bufferView.byteLength != gltfRuntime.buffers[buf2].byteLength) {
            Tools.Error("Buffer named " + buf2 + " is length " + bufferView.byteLength + ". Expected: " + buffer2.byteLength);
          }
          gltfRuntime.loadedBufferViews[buf2] = bufferView;
        }
        if (gltfRuntime.loadedBufferCount === gltfRuntime.buffersCount) {
          onLoad();
        }
      }, function() {
        Tools.Error("Error when loading buffer named " + buf2 + " located at " + buffer2.uri);
      });
    };
    for (var buf in gltfRuntime.buffers) {
      hasBuffers = true;
      var buffer = gltfRuntime.buffers[buf];
      if (buffer) {
        processBuffer.bind(this, buf, buffer)();
      } else {
        Tools.Error("No buffer named: " + buf);
      }
    }
    if (!hasBuffers) {
      onLoad();
    }
  };
  GLTFLoader3.prototype._createNodes = function(gltfRuntime) {
    var currentScene = gltfRuntime.currentScene;
    if (currentScene) {
      for (var i = 0; i < currentScene.nodes.length; i++) {
        traverseNodes(gltfRuntime, currentScene.nodes[i], null);
      }
    } else {
      for (var thing in gltfRuntime.scenes) {
        currentScene = gltfRuntime.scenes[thing];
        for (var i = 0; i < currentScene.nodes.length; i++) {
          traverseNodes(gltfRuntime, currentScene.nodes[i], null);
        }
      }
    }
  };
  GLTFLoader3.Extensions = {};
  return GLTFLoader3;
}();
var GLTFLoaderExtension = function() {
  function GLTFLoaderExtension2(name) {
    this._name = name;
  }
  Object.defineProperty(GLTFLoaderExtension2.prototype, "name", {
    get: function() {
      return this._name;
    },
    enumerable: false,
    configurable: true
  });
  GLTFLoaderExtension2.prototype.loadRuntimeAsync = function(scene, data, rootUrl, onSuccess, onError) {
    return false;
  };
  GLTFLoaderExtension2.prototype.loadRuntimeExtensionsAsync = function(gltfRuntime, onSuccess, onError) {
    return false;
  };
  GLTFLoaderExtension2.prototype.loadBufferAsync = function(gltfRuntime, id, onSuccess, onError, onProgress) {
    return false;
  };
  GLTFLoaderExtension2.prototype.loadTextureBufferAsync = function(gltfRuntime, id, onSuccess, onError) {
    return false;
  };
  GLTFLoaderExtension2.prototype.createTextureAsync = function(gltfRuntime, id, buffer, onSuccess, onError) {
    return false;
  };
  GLTFLoaderExtension2.prototype.loadShaderStringAsync = function(gltfRuntime, id, onSuccess, onError) {
    return false;
  };
  GLTFLoaderExtension2.prototype.loadMaterialAsync = function(gltfRuntime, id, onSuccess, onError) {
    return false;
  };
  GLTFLoaderExtension2.LoadRuntimeAsync = function(scene, data, rootUrl, onSuccess, onError) {
    GLTFLoaderExtension2.ApplyExtensions(function(loaderExtension) {
      return loaderExtension.loadRuntimeAsync(scene, data, rootUrl, onSuccess, onError);
    }, function() {
      setTimeout(function() {
        if (!onSuccess) {
          return;
        }
        onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));
      });
    });
  };
  GLTFLoaderExtension2.LoadRuntimeExtensionsAsync = function(gltfRuntime, onSuccess, onError) {
    GLTFLoaderExtension2.ApplyExtensions(function(loaderExtension) {
      return loaderExtension.loadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError);
    }, function() {
      setTimeout(function() {
        onSuccess();
      });
    });
  };
  GLTFLoaderExtension2.LoadBufferAsync = function(gltfRuntime, id, onSuccess, onError, onProgress) {
    GLTFLoaderExtension2.ApplyExtensions(function(loaderExtension) {
      return loaderExtension.loadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);
    }, function() {
      GLTFLoaderBase.LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);
    });
  };
  GLTFLoaderExtension2.LoadTextureAsync = function(gltfRuntime, id, onSuccess, onError) {
    GLTFLoaderExtension2.LoadTextureBufferAsync(gltfRuntime, id, function(buffer) {
      if (buffer) {
        GLTFLoaderExtension2.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);
      }
    }, onError);
  };
  GLTFLoaderExtension2.LoadShaderStringAsync = function(gltfRuntime, id, onSuccess, onError) {
    GLTFLoaderExtension2.ApplyExtensions(function(loaderExtension) {
      return loaderExtension.loadShaderStringAsync(gltfRuntime, id, onSuccess, onError);
    }, function() {
      GLTFLoaderBase.LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError);
    });
  };
  GLTFLoaderExtension2.LoadMaterialAsync = function(gltfRuntime, id, onSuccess, onError) {
    GLTFLoaderExtension2.ApplyExtensions(function(loaderExtension) {
      return loaderExtension.loadMaterialAsync(gltfRuntime, id, onSuccess, onError);
    }, function() {
      GLTFLoaderBase.LoadMaterialAsync(gltfRuntime, id, onSuccess, onError);
    });
  };
  GLTFLoaderExtension2.LoadTextureBufferAsync = function(gltfRuntime, id, onSuccess, onError) {
    GLTFLoaderExtension2.ApplyExtensions(function(loaderExtension) {
      return loaderExtension.loadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);
    }, function() {
      GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);
    });
  };
  GLTFLoaderExtension2.CreateTextureAsync = function(gltfRuntime, id, buffer, onSuccess, onError) {
    GLTFLoaderExtension2.ApplyExtensions(function(loaderExtension) {
      return loaderExtension.createTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);
    }, function() {
      GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);
    });
  };
  GLTFLoaderExtension2.ApplyExtensions = function(func, defaultFunc) {
    for (var extensionName in GLTFLoader.Extensions) {
      var loaderExtension = GLTFLoader.Extensions[extensionName];
      if (func(loaderExtension)) {
        return;
      }
    }
    defaultFunc();
  };
  return GLTFLoaderExtension2;
}();
GLTFFileLoader._CreateGLTF1Loader = function() {
  return new GLTFLoader();
};

// node_modules/@babylonjs/loaders/glTF/1.0/glTFBinaryExtension.js
var BinaryExtensionBufferName = "binary_glTF";
var GLTFBinaryExtension = function(_super) {
  __extends(GLTFBinaryExtension2, _super);
  function GLTFBinaryExtension2() {
    return _super.call(this, "KHR_binary_glTF") || this;
  }
  GLTFBinaryExtension2.prototype.loadRuntimeAsync = function(scene, data, rootUrl, onSuccess, onError) {
    var extensionsUsed = data.json.extensionsUsed;
    if (!extensionsUsed || extensionsUsed.indexOf(this.name) === -1 || !data.bin) {
      return false;
    }
    this._bin = data.bin;
    onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));
    return true;
  };
  GLTFBinaryExtension2.prototype.loadBufferAsync = function(gltfRuntime, id, onSuccess, onError) {
    if (gltfRuntime.extensionsUsed.indexOf(this.name) === -1) {
      return false;
    }
    if (id !== BinaryExtensionBufferName) {
      return false;
    }
    this._bin.readAsync(0, this._bin.byteLength).then(onSuccess, function(error) {
      return onError(error.message);
    });
    return true;
  };
  GLTFBinaryExtension2.prototype.loadTextureBufferAsync = function(gltfRuntime, id, onSuccess, onError) {
    var texture = gltfRuntime.textures[id];
    var source = gltfRuntime.images[texture.source];
    if (!source.extensions || !(this.name in source.extensions)) {
      return false;
    }
    var sourceExt = source.extensions[this.name];
    var bufferView = gltfRuntime.bufferViews[sourceExt.bufferView];
    var buffer = GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, EComponentType.UNSIGNED_BYTE);
    onSuccess(buffer);
    return true;
  };
  GLTFBinaryExtension2.prototype.loadShaderStringAsync = function(gltfRuntime, id, onSuccess, onError) {
    var shader = gltfRuntime.shaders[id];
    if (!shader.extensions || !(this.name in shader.extensions)) {
      return false;
    }
    var binaryExtensionShader = shader.extensions[this.name];
    var bufferView = gltfRuntime.bufferViews[binaryExtensionShader.bufferView];
    var shaderBytes = GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, EComponentType.UNSIGNED_BYTE);
    setTimeout(function() {
      var shaderString = GLTFUtils.DecodeBufferToText(shaderBytes);
      onSuccess(shaderString);
    });
    return true;
  };
  return GLTFBinaryExtension2;
}(GLTFLoaderExtension);
GLTFLoader.RegisterExtension(new GLTFBinaryExtension());

// node_modules/@babylonjs/loaders/glTF/1.0/glTFMaterialsCommonExtension.js
var GLTFMaterialsCommonExtension = function(_super) {
  __extends(GLTFMaterialsCommonExtension2, _super);
  function GLTFMaterialsCommonExtension2() {
    return _super.call(this, "KHR_materials_common") || this;
  }
  GLTFMaterialsCommonExtension2.prototype.loadRuntimeExtensionsAsync = function(gltfRuntime, onSuccess, onError) {
    if (!gltfRuntime.extensions) {
      return false;
    }
    var extension = gltfRuntime.extensions[this.name];
    if (!extension) {
      return false;
    }
    var lights = extension.lights;
    if (lights) {
      for (var thing in lights) {
        var light = lights[thing];
        switch (light.type) {
          case "ambient":
            var ambientLight = new HemisphericLight(light.name, new Vector3(0, 1, 0), gltfRuntime.scene);
            var ambient = light.ambient;
            if (ambient) {
              ambientLight.diffuse = Color3.FromArray(ambient.color || [1, 1, 1]);
            }
            break;
          case "point":
            var pointLight = new PointLight(light.name, new Vector3(10, 10, 10), gltfRuntime.scene);
            var point = light.point;
            if (point) {
              pointLight.diffuse = Color3.FromArray(point.color || [1, 1, 1]);
            }
            break;
          case "directional":
            var dirLight = new DirectionalLight(light.name, new Vector3(0, -1, 0), gltfRuntime.scene);
            var directional = light.directional;
            if (directional) {
              dirLight.diffuse = Color3.FromArray(directional.color || [1, 1, 1]);
            }
            break;
          case "spot":
            var spot = light.spot;
            if (spot) {
              var spotLight = new SpotLight(light.name, new Vector3(0, 10, 0), new Vector3(0, -1, 0), spot.fallOffAngle || Math.PI, spot.fallOffExponent || 0, gltfRuntime.scene);
              spotLight.diffuse = Color3.FromArray(spot.color || [1, 1, 1]);
            }
            break;
          default:
            Tools.Warn('GLTF Material Common extension: light type "' + light.type + "\u201D not supported");
            break;
        }
      }
    }
    return false;
  };
  GLTFMaterialsCommonExtension2.prototype.loadMaterialAsync = function(gltfRuntime, id, onSuccess, onError) {
    var material = gltfRuntime.materials[id];
    if (!material || !material.extensions) {
      return false;
    }
    var extension = material.extensions[this.name];
    if (!extension) {
      return false;
    }
    var standardMaterial = new StandardMaterial(id, gltfRuntime.scene);
    standardMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;
    if (extension.technique === "CONSTANT") {
      standardMaterial.disableLighting = true;
    }
    standardMaterial.backFaceCulling = extension.doubleSided === void 0 ? false : !extension.doubleSided;
    standardMaterial.alpha = extension.values.transparency === void 0 ? 1 : extension.values.transparency;
    standardMaterial.specularPower = extension.values.shininess === void 0 ? 0 : extension.values.shininess;
    if (typeof extension.values.ambient === "string") {
      this._loadTexture(gltfRuntime, extension.values.ambient, standardMaterial, "ambientTexture", onError);
    } else {
      standardMaterial.ambientColor = Color3.FromArray(extension.values.ambient || [0, 0, 0]);
    }
    if (typeof extension.values.diffuse === "string") {
      this._loadTexture(gltfRuntime, extension.values.diffuse, standardMaterial, "diffuseTexture", onError);
    } else {
      standardMaterial.diffuseColor = Color3.FromArray(extension.values.diffuse || [0, 0, 0]);
    }
    if (typeof extension.values.emission === "string") {
      this._loadTexture(gltfRuntime, extension.values.emission, standardMaterial, "emissiveTexture", onError);
    } else {
      standardMaterial.emissiveColor = Color3.FromArray(extension.values.emission || [0, 0, 0]);
    }
    if (typeof extension.values.specular === "string") {
      this._loadTexture(gltfRuntime, extension.values.specular, standardMaterial, "specularTexture", onError);
    } else {
      standardMaterial.specularColor = Color3.FromArray(extension.values.specular || [0, 0, 0]);
    }
    return true;
  };
  GLTFMaterialsCommonExtension2.prototype._loadTexture = function(gltfRuntime, id, material, propertyPath, onError) {
    GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, function(buffer) {
      GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, function(texture) {
        return material[propertyPath] = texture;
      }, onError);
    }, onError);
  };
  return GLTFMaterialsCommonExtension2;
}(GLTFLoaderExtension);
GLTFLoader.RegisterExtension(new GLTFMaterialsCommonExtension());

// node_modules/@babylonjs/loaders/glTF/2.0/index.js
var __exports2 = {};
__export(__exports2, {
  ArrayItem: () => ArrayItem,
  EXT_lights_image_based: () => EXT_lights_image_based,
  EXT_mesh_gpu_instancing: () => EXT_mesh_gpu_instancing,
  EXT_texture_webp: () => EXT_texture_webp,
  ExtrasAsMetadata: () => ExtrasAsMetadata,
  GLTFLoader: () => GLTFLoader2,
  KHR_draco_mesh_compression: () => KHR_draco_mesh_compression,
  KHR_lights: () => KHR_lights,
  KHR_materials_clearcoat: () => KHR_materials_clearcoat,
  KHR_materials_ior: () => KHR_materials_ior,
  KHR_materials_pbrSpecularGlossiness: () => KHR_materials_pbrSpecularGlossiness,
  KHR_materials_sheen: () => KHR_materials_sheen,
  KHR_materials_specular: () => KHR_materials_specular,
  KHR_materials_translucency: () => KHR_materials_translucency,
  KHR_materials_transmission: () => KHR_materials_transmission,
  KHR_materials_unlit: () => KHR_materials_unlit,
  KHR_materials_variants: () => KHR_materials_variants,
  KHR_mesh_quantization: () => KHR_mesh_quantization,
  KHR_texture_basisu: () => KHR_texture_basisu,
  KHR_texture_transform: () => KHR_texture_transform,
  MSFT_audio_emitter: () => MSFT_audio_emitter,
  MSFT_lod: () => MSFT_lod,
  MSFT_minecraftMesh: () => MSFT_minecraftMesh,
  MSFT_sRGBFactors: () => MSFT_sRGBFactors
});

// node_modules/@babylonjs/loaders/glTF/2.0/glTFLoader.js
var ArrayItem = function() {
  function ArrayItem2() {
  }
  ArrayItem2.Get = function(context, array, index) {
    if (!array || index == void 0 || !array[index]) {
      throw new Error(context + ": Failed to find index (" + index + ")");
    }
    return array[index];
  };
  ArrayItem2.Assign = function(array) {
    if (array) {
      for (var index = 0; index < array.length; index++) {
        array[index].index = index;
      }
    }
  };
  return ArrayItem2;
}();
var GLTFLoader2 = function() {
  function GLTFLoader3(parent) {
    this._completePromises = new Array();
    this._forAssetContainer = false;
    this._babylonLights = [];
    this._disableInstancedMesh = 0;
    this._disposed = false;
    this._state = null;
    this._extensions = new Array();
    this._defaultBabylonMaterialData = {};
    this._parent = parent;
  }
  GLTFLoader3.RegisterExtension = function(name, factory) {
    if (GLTFLoader3.UnregisterExtension(name)) {
      Logger.Warn("Extension with the name '" + name + "' already exists");
    }
    GLTFLoader3._RegisteredExtensions[name] = {
      factory
    };
  };
  GLTFLoader3.UnregisterExtension = function(name) {
    if (!GLTFLoader3._RegisteredExtensions[name]) {
      return false;
    }
    delete GLTFLoader3._RegisteredExtensions[name];
    return true;
  };
  Object.defineProperty(GLTFLoader3.prototype, "state", {
    get: function() {
      return this._state;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GLTFLoader3.prototype, "gltf", {
    get: function() {
      return this._gltf;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GLTFLoader3.prototype, "bin", {
    get: function() {
      return this._bin;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GLTFLoader3.prototype, "parent", {
    get: function() {
      return this._parent;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GLTFLoader3.prototype, "babylonScene", {
    get: function() {
      return this._babylonScene;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GLTFLoader3.prototype, "rootBabylonMesh", {
    get: function() {
      return this._rootBabylonMesh;
    },
    enumerable: false,
    configurable: true
  });
  GLTFLoader3.prototype.dispose = function() {
    if (this._disposed) {
      return;
    }
    this._disposed = true;
    this._completePromises.length = 0;
    for (var name_1 in this._extensions) {
      var extension = this._extensions[name_1];
      extension.dispose && extension.dispose();
      delete this._extensions[name_1];
    }
    this._gltf = null;
    this._babylonScene = null;
    this._rootBabylonMesh = null;
    this._parent.dispose();
  };
  GLTFLoader3.prototype.importMeshAsync = function(meshesNames, scene, forAssetContainer, data, rootUrl, onProgress, fileName) {
    var _this = this;
    return Promise.resolve().then(function() {
      _this._babylonScene = scene;
      _this._rootUrl = rootUrl;
      _this._fileName = fileName || "scene";
      _this._forAssetContainer = forAssetContainer;
      _this._loadData(data);
      var nodes = null;
      if (meshesNames) {
        var nodeMap_1 = {};
        if (_this._gltf.nodes) {
          for (var _i = 0, _a = _this._gltf.nodes; _i < _a.length; _i++) {
            var node = _a[_i];
            if (node.name) {
              nodeMap_1[node.name] = node.index;
            }
          }
        }
        var names = meshesNames instanceof Array ? meshesNames : [meshesNames];
        nodes = names.map(function(name) {
          var node2 = nodeMap_1[name];
          if (node2 === void 0) {
            throw new Error("Failed to find node '" + name + "'");
          }
          return node2;
        });
      }
      return _this._loadAsync(nodes, function() {
        return {
          meshes: _this._getMeshes(),
          particleSystems: [],
          skeletons: _this._getSkeletons(),
          animationGroups: _this._getAnimationGroups(),
          lights: _this._babylonLights,
          transformNodes: _this._getTransformNodes(),
          geometries: _this._getGeometries()
        };
      });
    });
  };
  GLTFLoader3.prototype.loadAsync = function(scene, data, rootUrl, onProgress, fileName) {
    var _this = this;
    return Promise.resolve().then(function() {
      _this._babylonScene = scene;
      _this._rootUrl = rootUrl;
      _this._fileName = fileName || "scene";
      _this._loadData(data);
      return _this._loadAsync(null, function() {
        return void 0;
      });
    });
  };
  GLTFLoader3.prototype._loadAsync = function(nodes, resultFunc) {
    var _this = this;
    return Promise.resolve().then(function() {
      _this._uniqueRootUrl = _this._rootUrl.indexOf("file:") === -1 && _this._fileName ? _this._rootUrl : "" + _this._rootUrl + Date.now() + "/";
      _this._loadExtensions();
      _this._checkExtensions();
      var loadingToReadyCounterName = GLTFLoaderState[GLTFLoaderState.LOADING] + " => " + GLTFLoaderState[GLTFLoaderState.READY];
      var loadingToCompleteCounterName = GLTFLoaderState[GLTFLoaderState.LOADING] + " => " + GLTFLoaderState[GLTFLoaderState.COMPLETE];
      _this._parent._startPerformanceCounter(loadingToReadyCounterName);
      _this._parent._startPerformanceCounter(loadingToCompleteCounterName);
      _this._setState(GLTFLoaderState.LOADING);
      _this._extensionsOnLoading();
      var promises = new Array();
      var oldBlockMaterialDirtyMechanism = _this._babylonScene.blockMaterialDirtyMechanism;
      _this._babylonScene.blockMaterialDirtyMechanism = true;
      if (nodes) {
        promises.push(_this.loadSceneAsync("/nodes", { nodes, index: -1 }));
      } else if (_this._gltf.scene != void 0 || _this._gltf.scenes && _this._gltf.scenes[0]) {
        var scene = ArrayItem.Get("/scene", _this._gltf.scenes, _this._gltf.scene || 0);
        promises.push(_this.loadSceneAsync("/scenes/" + scene.index, scene));
      }
      if (_this.parent.loadAllMaterials && _this._gltf.materials) {
        for (var m = 0; m < _this._gltf.materials.length; ++m) {
          var material = _this._gltf.materials[m];
          var context_1 = "/materials/" + m;
          var babylonDrawMode = Material.TriangleFillMode;
          promises.push(_this._loadMaterialAsync(context_1, material, null, babylonDrawMode, function(material2) {
          }));
        }
      }
      _this._babylonScene.blockMaterialDirtyMechanism = oldBlockMaterialDirtyMechanism;
      if (_this._parent.compileMaterials) {
        promises.push(_this._compileMaterialsAsync());
      }
      if (_this._parent.compileShadowGenerators) {
        promises.push(_this._compileShadowGeneratorsAsync());
      }
      var resultPromise = Promise.all(promises).then(function() {
        if (_this._rootBabylonMesh) {
          _this._rootBabylonMesh.setEnabled(true);
        }
        _this._extensionsOnReady();
        _this._setState(GLTFLoaderState.READY);
        _this._startAnimations();
        return resultFunc();
      });
      resultPromise.then(function() {
        _this._parent._endPerformanceCounter(loadingToReadyCounterName);
        Tools.SetImmediate(function() {
          if (!_this._disposed) {
            Promise.all(_this._completePromises).then(function() {
              _this._parent._endPerformanceCounter(loadingToCompleteCounterName);
              _this._setState(GLTFLoaderState.COMPLETE);
              _this._parent.onCompleteObservable.notifyObservers(void 0);
              _this._parent.onCompleteObservable.clear();
              _this.dispose();
            }, function(error) {
              _this._parent.onErrorObservable.notifyObservers(error);
              _this._parent.onErrorObservable.clear();
              _this.dispose();
            });
          }
        });
      });
      return resultPromise;
    }).catch(function(error) {
      if (!_this._disposed) {
        _this._parent.onErrorObservable.notifyObservers(error);
        _this._parent.onErrorObservable.clear();
        _this.dispose();
      }
      throw error;
    });
  };
  GLTFLoader3.prototype._loadData = function(data) {
    this._gltf = data.json;
    this._setupData();
    if (data.bin) {
      var buffers = this._gltf.buffers;
      if (buffers && buffers[0] && !buffers[0].uri) {
        var binaryBuffer = buffers[0];
        if (binaryBuffer.byteLength < data.bin.byteLength - 3 || binaryBuffer.byteLength > data.bin.byteLength) {
          Logger.Warn("Binary buffer length (" + binaryBuffer.byteLength + ") from JSON does not match chunk length (" + data.bin.byteLength + ")");
        }
        this._bin = data.bin;
      } else {
        Logger.Warn("Unexpected BIN chunk");
      }
    }
  };
  GLTFLoader3.prototype._setupData = function() {
    ArrayItem.Assign(this._gltf.accessors);
    ArrayItem.Assign(this._gltf.animations);
    ArrayItem.Assign(this._gltf.buffers);
    ArrayItem.Assign(this._gltf.bufferViews);
    ArrayItem.Assign(this._gltf.cameras);
    ArrayItem.Assign(this._gltf.images);
    ArrayItem.Assign(this._gltf.materials);
    ArrayItem.Assign(this._gltf.meshes);
    ArrayItem.Assign(this._gltf.nodes);
    ArrayItem.Assign(this._gltf.samplers);
    ArrayItem.Assign(this._gltf.scenes);
    ArrayItem.Assign(this._gltf.skins);
    ArrayItem.Assign(this._gltf.textures);
    if (this._gltf.nodes) {
      var nodeParents = {};
      for (var _i = 0, _a = this._gltf.nodes; _i < _a.length; _i++) {
        var node = _a[_i];
        if (node.children) {
          for (var _b = 0, _c = node.children; _b < _c.length; _b++) {
            var index = _c[_b];
            nodeParents[index] = node.index;
          }
        }
      }
      var rootNode = this._createRootNode();
      for (var _d = 0, _e = this._gltf.nodes; _d < _e.length; _d++) {
        var node = _e[_d];
        var parentIndex = nodeParents[node.index];
        node.parent = parentIndex === void 0 ? rootNode : this._gltf.nodes[parentIndex];
      }
    }
  };
  GLTFLoader3.prototype._loadExtensions = function() {
    for (var name_2 in GLTFLoader3._RegisteredExtensions) {
      var extension = GLTFLoader3._RegisteredExtensions[name_2].factory(this);
      if (extension.name !== name_2) {
        Logger.Warn("The name of the glTF loader extension instance does not match the registered name: " + extension.name + " !== " + name_2);
      }
      this._extensions.push(extension);
      this._parent.onExtensionLoadedObservable.notifyObservers(extension);
    }
    this._extensions.sort(function(a, b) {
      return (a.order || Number.MAX_VALUE) - (b.order || Number.MAX_VALUE);
    });
    this._parent.onExtensionLoadedObservable.clear();
  };
  GLTFLoader3.prototype._checkExtensions = function() {
    if (this._gltf.extensionsRequired) {
      var _loop_1 = function(name_32) {
        var available = this_1._extensions.some(function(extension) {
          return extension.name === name_32 && extension.enabled;
        });
        if (!available) {
          throw new Error("Require extension " + name_32 + " is not available");
        }
      };
      var this_1 = this;
      for (var _i = 0, _a = this._gltf.extensionsRequired; _i < _a.length; _i++) {
        var name_3 = _a[_i];
        _loop_1(name_3);
      }
    }
  };
  GLTFLoader3.prototype._setState = function(state) {
    this._state = state;
    this.log(GLTFLoaderState[this._state]);
  };
  GLTFLoader3.prototype._createRootNode = function() {
    this._babylonScene._blockEntityCollection = this._forAssetContainer;
    this._rootBabylonMesh = new Mesh("__root__", this._babylonScene);
    this._babylonScene._blockEntityCollection = false;
    this._rootBabylonMesh.setEnabled(false);
    var rootNode = {
      _babylonTransformNode: this._rootBabylonMesh,
      index: -1
    };
    switch (this._parent.coordinateSystemMode) {
      case GLTFLoaderCoordinateSystemMode.AUTO: {
        if (!this._babylonScene.useRightHandedSystem) {
          rootNode.rotation = [0, 1, 0, 0];
          rootNode.scale = [1, 1, -1];
          GLTFLoader3._LoadTransform(rootNode, this._rootBabylonMesh);
        }
        break;
      }
      case GLTFLoaderCoordinateSystemMode.FORCE_RIGHT_HANDED: {
        this._babylonScene.useRightHandedSystem = true;
        break;
      }
      default: {
        throw new Error("Invalid coordinate system mode (" + this._parent.coordinateSystemMode + ")");
      }
    }
    this._parent.onMeshLoadedObservable.notifyObservers(this._rootBabylonMesh);
    return rootNode;
  };
  GLTFLoader3.prototype.loadSceneAsync = function(context, scene) {
    var _this = this;
    var extensionPromise = this._extensionsLoadSceneAsync(context, scene);
    if (extensionPromise) {
      return extensionPromise;
    }
    var promises = new Array();
    this.logOpen(context + " " + (scene.name || ""));
    if (scene.nodes) {
      for (var _i = 0, _a = scene.nodes; _i < _a.length; _i++) {
        var index = _a[_i];
        var node = ArrayItem.Get(context + "/nodes/" + index, this._gltf.nodes, index);
        promises.push(this.loadNodeAsync("/nodes/" + node.index, node, function(babylonMesh) {
          babylonMesh.parent = _this._rootBabylonMesh;
        }));
      }
    }
    if (this._gltf.nodes) {
      for (var _b = 0, _c = this._gltf.nodes; _b < _c.length; _b++) {
        var node = _c[_b];
        if (node._babylonTransformNode && node._babylonBones) {
          for (var _d = 0, _e = node._babylonBones; _d < _e.length; _d++) {
            var babylonBone = _e[_d];
            babylonBone.linkTransformNode(node._babylonTransformNode);
          }
        }
      }
    }
    promises.push(this._loadAnimationsAsync());
    this.logClose();
    return Promise.all(promises).then(function() {
    });
  };
  GLTFLoader3.prototype._forEachPrimitive = function(node, callback) {
    if (node._primitiveBabylonMeshes) {
      for (var _i = 0, _a = node._primitiveBabylonMeshes; _i < _a.length; _i++) {
        var babylonMesh = _a[_i];
        callback(babylonMesh);
      }
    }
  };
  GLTFLoader3.prototype._getGeometries = function() {
    var geometries = new Array();
    var nodes = this._gltf.nodes;
    if (nodes) {
      for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
        var node = nodes_1[_i];
        this._forEachPrimitive(node, function(babylonMesh) {
          var geometry = babylonMesh.geometry;
          if (geometry && geometries.indexOf(geometry) === -1) {
            geometries.push(geometry);
          }
        });
      }
    }
    return geometries;
  };
  GLTFLoader3.prototype._getMeshes = function() {
    var meshes = new Array();
    meshes.push(this._rootBabylonMesh);
    var nodes = this._gltf.nodes;
    if (nodes) {
      for (var _i = 0, nodes_2 = nodes; _i < nodes_2.length; _i++) {
        var node = nodes_2[_i];
        this._forEachPrimitive(node, function(babylonMesh) {
          meshes.push(babylonMesh);
        });
      }
    }
    return meshes;
  };
  GLTFLoader3.prototype._getTransformNodes = function() {
    var transformNodes = new Array();
    var nodes = this._gltf.nodes;
    if (nodes) {
      for (var _i = 0, nodes_3 = nodes; _i < nodes_3.length; _i++) {
        var node = nodes_3[_i];
        if (node._babylonTransformNode && node._babylonTransformNode.getClassName() === "TransformNode") {
          transformNodes.push(node._babylonTransformNode);
        }
      }
    }
    return transformNodes;
  };
  GLTFLoader3.prototype._getSkeletons = function() {
    var skeletons = new Array();
    var skins = this._gltf.skins;
    if (skins) {
      for (var _i = 0, skins_1 = skins; _i < skins_1.length; _i++) {
        var skin = skins_1[_i];
        if (skin._data) {
          skeletons.push(skin._data.babylonSkeleton);
        }
      }
    }
    return skeletons;
  };
  GLTFLoader3.prototype._getAnimationGroups = function() {
    var animationGroups = new Array();
    var animations = this._gltf.animations;
    if (animations) {
      for (var _i = 0, animations_1 = animations; _i < animations_1.length; _i++) {
        var animation = animations_1[_i];
        if (animation._babylonAnimationGroup) {
          animationGroups.push(animation._babylonAnimationGroup);
        }
      }
    }
    return animationGroups;
  };
  GLTFLoader3.prototype._startAnimations = function() {
    switch (this._parent.animationStartMode) {
      case GLTFLoaderAnimationStartMode.NONE: {
        break;
      }
      case GLTFLoaderAnimationStartMode.FIRST: {
        var babylonAnimationGroups = this._getAnimationGroups();
        if (babylonAnimationGroups.length !== 0) {
          babylonAnimationGroups[0].start(true);
        }
        break;
      }
      case GLTFLoaderAnimationStartMode.ALL: {
        var babylonAnimationGroups = this._getAnimationGroups();
        for (var _i = 0, babylonAnimationGroups_1 = babylonAnimationGroups; _i < babylonAnimationGroups_1.length; _i++) {
          var babylonAnimationGroup = babylonAnimationGroups_1[_i];
          babylonAnimationGroup.start(true);
        }
        break;
      }
      default: {
        Logger.Error("Invalid animation start mode (" + this._parent.animationStartMode + ")");
        return;
      }
    }
  };
  GLTFLoader3.prototype.loadNodeAsync = function(context, node, assign) {
    var _this = this;
    if (assign === void 0) {
      assign = function() {
      };
    }
    var extensionPromise = this._extensionsLoadNodeAsync(context, node, assign);
    if (extensionPromise) {
      return extensionPromise;
    }
    if (node._babylonTransformNode) {
      throw new Error(context + ": Invalid recursive node hierarchy");
    }
    var promises = new Array();
    this.logOpen(context + " " + (node.name || ""));
    var loadNode = function(babylonTransformNode) {
      GLTFLoader3.AddPointerMetadata(babylonTransformNode, context);
      GLTFLoader3._LoadTransform(node, babylonTransformNode);
      if (node.camera != void 0) {
        var camera = ArrayItem.Get(context + "/camera", _this._gltf.cameras, node.camera);
        promises.push(_this.loadCameraAsync("/cameras/" + camera.index, camera, function(babylonCamera) {
          babylonCamera.parent = babylonTransformNode;
        }));
      }
      if (node.children) {
        for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
          var index = _a[_i];
          var childNode = ArrayItem.Get(context + "/children/" + index, _this._gltf.nodes, index);
          promises.push(_this.loadNodeAsync("/nodes/" + childNode.index, childNode, function(childBabylonMesh) {
            childBabylonMesh.parent = babylonTransformNode;
          }));
        }
      }
      assign(babylonTransformNode);
    };
    if (node.mesh == void 0) {
      var nodeName = node.name || "node" + node.index;
      this._babylonScene._blockEntityCollection = this._forAssetContainer;
      node._babylonTransformNode = new TransformNode(nodeName, this._babylonScene);
      this._babylonScene._blockEntityCollection = false;
      loadNode(node._babylonTransformNode);
    } else {
      var mesh = ArrayItem.Get(context + "/mesh", this._gltf.meshes, node.mesh);
      promises.push(this._loadMeshAsync("/meshes/" + mesh.index, node, mesh, loadNode));
    }
    this.logClose();
    return Promise.all(promises).then(function() {
      _this._forEachPrimitive(node, function(babylonMesh) {
        if (babylonMesh.geometry && babylonMesh.geometry.useBoundingInfoFromGeometry) {
          babylonMesh._updateBoundingInfo();
        } else {
          babylonMesh.refreshBoundingInfo(true);
        }
      });
      return node._babylonTransformNode;
    });
  };
  GLTFLoader3.prototype._loadMeshAsync = function(context, node, mesh, assign) {
    var primitives = mesh.primitives;
    if (!primitives || !primitives.length) {
      throw new Error(context + ": Primitives are missing");
    }
    if (primitives[0].index == void 0) {
      ArrayItem.Assign(primitives);
    }
    var promises = new Array();
    this.logOpen(context + " " + (mesh.name || ""));
    var name = node.name || "node" + node.index;
    if (primitives.length === 1) {
      var primitive = mesh.primitives[0];
      promises.push(this._loadMeshPrimitiveAsync(context + "/primitives/" + primitive.index, name, node, mesh, primitive, function(babylonMesh) {
        node._babylonTransformNode = babylonMesh;
        node._primitiveBabylonMeshes = [babylonMesh];
      }));
    } else {
      this._babylonScene._blockEntityCollection = this._forAssetContainer;
      node._babylonTransformNode = new TransformNode(name, this._babylonScene);
      this._babylonScene._blockEntityCollection = false;
      node._primitiveBabylonMeshes = [];
      for (var _i = 0, primitives_1 = primitives; _i < primitives_1.length; _i++) {
        var primitive = primitives_1[_i];
        promises.push(this._loadMeshPrimitiveAsync(context + "/primitives/" + primitive.index, name + "_primitive" + primitive.index, node, mesh, primitive, function(babylonMesh) {
          babylonMesh.parent = node._babylonTransformNode;
          node._primitiveBabylonMeshes.push(babylonMesh);
        }));
      }
    }
    if (node.skin != void 0) {
      var skin = ArrayItem.Get(context + "/skin", this._gltf.skins, node.skin);
      promises.push(this._loadSkinAsync("/skins/" + skin.index, node, skin));
    }
    assign(node._babylonTransformNode);
    this.logClose();
    return Promise.all(promises).then(function() {
      return node._babylonTransformNode;
    });
  };
  GLTFLoader3.prototype._loadMeshPrimitiveAsync = function(context, name, node, mesh, primitive, assign) {
    var _this = this;
    var extensionPromise = this._extensionsLoadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign);
    if (extensionPromise) {
      return extensionPromise;
    }
    this.logOpen("" + context);
    var shouldInstance = this._disableInstancedMesh === 0 && this._parent.createInstances && (node.skin == void 0 && !mesh.primitives[0].targets);
    var babylonAbstractMesh;
    var promise;
    if (shouldInstance && primitive._instanceData) {
      babylonAbstractMesh = primitive._instanceData.babylonSourceMesh.createInstance(name);
      promise = primitive._instanceData.promise;
    } else {
      var promises = new Array();
      this._babylonScene._blockEntityCollection = this._forAssetContainer;
      var babylonMesh_1 = new Mesh(name, this._babylonScene);
      this._babylonScene._blockEntityCollection = false;
      babylonMesh_1.overrideMaterialSideOrientation = this._babylonScene.useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;
      this._createMorphTargets(context, node, mesh, primitive, babylonMesh_1);
      promises.push(this._loadVertexDataAsync(context, primitive, babylonMesh_1).then(function(babylonGeometry) {
        return _this._loadMorphTargetsAsync(context, primitive, babylonMesh_1, babylonGeometry).then(function() {
          _this._babylonScene._blockEntityCollection = _this._forAssetContainer;
          babylonGeometry.applyToMesh(babylonMesh_1);
          _this._babylonScene._blockEntityCollection = false;
        });
      }));
      var babylonDrawMode = GLTFLoader3._GetDrawMode(context, primitive.mode);
      if (primitive.material == void 0) {
        var babylonMaterial = this._defaultBabylonMaterialData[babylonDrawMode];
        if (!babylonMaterial) {
          babylonMaterial = this._createDefaultMaterial("__GLTFLoader._default", babylonDrawMode);
          this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);
          this._defaultBabylonMaterialData[babylonDrawMode] = babylonMaterial;
        }
        babylonMesh_1.material = babylonMaterial;
      } else {
        var material = ArrayItem.Get(context + "/material", this._gltf.materials, primitive.material);
        promises.push(this._loadMaterialAsync("/materials/" + material.index, material, babylonMesh_1, babylonDrawMode, function(babylonMaterial2) {
          babylonMesh_1.material = babylonMaterial2;
        }));
      }
      promise = Promise.all(promises);
      if (shouldInstance) {
        primitive._instanceData = {
          babylonSourceMesh: babylonMesh_1,
          promise
        };
      }
      babylonAbstractMesh = babylonMesh_1;
    }
    GLTFLoader3.AddPointerMetadata(babylonAbstractMesh, context);
    this._parent.onMeshLoadedObservable.notifyObservers(babylonAbstractMesh);
    assign(babylonAbstractMesh);
    this.logClose();
    return promise.then(function() {
      return babylonAbstractMesh;
    });
  };
  GLTFLoader3.prototype._loadVertexDataAsync = function(context, primitive, babylonMesh) {
    var _this = this;
    var extensionPromise = this._extensionsLoadVertexDataAsync(context, primitive, babylonMesh);
    if (extensionPromise) {
      return extensionPromise;
    }
    var attributes = primitive.attributes;
    if (!attributes) {
      throw new Error(context + ": Attributes are missing");
    }
    var promises = new Array();
    var babylonGeometry = new Geometry(babylonMesh.name, this._babylonScene);
    if (primitive.indices == void 0) {
      babylonMesh.isUnIndexed = true;
    } else {
      var accessor = ArrayItem.Get(context + "/indices", this._gltf.accessors, primitive.indices);
      promises.push(this._loadIndicesAccessorAsync("/accessors/" + accessor.index, accessor).then(function(data) {
        babylonGeometry.setIndices(data);
      }));
    }
    var loadAttribute = function(attribute, kind, callback) {
      if (attributes[attribute] == void 0) {
        return;
      }
      babylonMesh._delayInfo = babylonMesh._delayInfo || [];
      if (babylonMesh._delayInfo.indexOf(kind) === -1) {
        babylonMesh._delayInfo.push(kind);
      }
      var accessor2 = ArrayItem.Get(context + "/attributes/" + attribute, _this._gltf.accessors, attributes[attribute]);
      promises.push(_this._loadVertexAccessorAsync("/accessors/" + accessor2.index, accessor2, kind).then(function(babylonVertexBuffer) {
        if (babylonVertexBuffer.getKind() === VertexBuffer.PositionKind && !_this.parent.alwaysComputeBoundingBox && !babylonMesh.skeleton) {
          var mmin = accessor2.min, mmax = accessor2.max;
          if (mmin !== void 0 && mmax !== void 0) {
            var min = TmpVectors.Vector3[0], max = TmpVectors.Vector3[1];
            min.copyFromFloats.apply(min, mmin);
            max.copyFromFloats.apply(max, mmax);
            babylonGeometry._boundingInfo = new BoundingInfo(min, max);
            babylonGeometry.useBoundingInfoFromGeometry = true;
          }
        }
        babylonGeometry.setVerticesBuffer(babylonVertexBuffer, accessor2.count);
      }));
      if (kind == VertexBuffer.MatricesIndicesExtraKind) {
        babylonMesh.numBoneInfluencers = 8;
      }
      if (callback) {
        callback(accessor2);
      }
    };
    loadAttribute("POSITION", VertexBuffer.PositionKind);
    loadAttribute("NORMAL", VertexBuffer.NormalKind);
    loadAttribute("TANGENT", VertexBuffer.TangentKind);
    loadAttribute("TEXCOORD_0", VertexBuffer.UVKind);
    loadAttribute("TEXCOORD_1", VertexBuffer.UV2Kind);
    loadAttribute("JOINTS_0", VertexBuffer.MatricesIndicesKind);
    loadAttribute("WEIGHTS_0", VertexBuffer.MatricesWeightsKind);
    loadAttribute("JOINTS_1", VertexBuffer.MatricesIndicesExtraKind);
    loadAttribute("WEIGHTS_1", VertexBuffer.MatricesWeightsExtraKind);
    loadAttribute("COLOR_0", VertexBuffer.ColorKind, function(accessor2) {
      if (accessor2.type === "VEC4") {
        babylonMesh.hasVertexAlpha = true;
      }
    });
    return Promise.all(promises).then(function() {
      return babylonGeometry;
    });
  };
  GLTFLoader3.prototype._createMorphTargets = function(context, node, mesh, primitive, babylonMesh) {
    if (!primitive.targets) {
      return;
    }
    if (node._numMorphTargets == void 0) {
      node._numMorphTargets = primitive.targets.length;
    } else if (primitive.targets.length !== node._numMorphTargets) {
      throw new Error(context + ": Primitives do not have the same number of targets");
    }
    var targetNames = mesh.extras ? mesh.extras.targetNames : null;
    babylonMesh.morphTargetManager = new MorphTargetManager(babylonMesh.getScene());
    for (var index = 0; index < primitive.targets.length; index++) {
      var weight = node.weights ? node.weights[index] : mesh.weights ? mesh.weights[index] : 0;
      var name_4 = targetNames ? targetNames[index] : "morphTarget" + index;
      babylonMesh.morphTargetManager.addTarget(new MorphTarget(name_4, weight, babylonMesh.getScene()));
    }
  };
  GLTFLoader3.prototype._loadMorphTargetsAsync = function(context, primitive, babylonMesh, babylonGeometry) {
    if (!primitive.targets) {
      return Promise.resolve();
    }
    var promises = new Array();
    var morphTargetManager = babylonMesh.morphTargetManager;
    for (var index = 0; index < morphTargetManager.numTargets; index++) {
      var babylonMorphTarget = morphTargetManager.getTarget(index);
      promises.push(this._loadMorphTargetVertexDataAsync(context + "/targets/" + index, babylonGeometry, primitive.targets[index], babylonMorphTarget));
    }
    return Promise.all(promises).then(function() {
    });
  };
  GLTFLoader3.prototype._loadMorphTargetVertexDataAsync = function(context, babylonGeometry, attributes, babylonMorphTarget) {
    var _this = this;
    var promises = new Array();
    var loadAttribute = function(attribute, kind, setData) {
      if (attributes[attribute] == void 0) {
        return;
      }
      var babylonVertexBuffer = babylonGeometry.getVertexBuffer(kind);
      if (!babylonVertexBuffer) {
        return;
      }
      var accessor = ArrayItem.Get(context + "/" + attribute, _this._gltf.accessors, attributes[attribute]);
      promises.push(_this._loadFloatAccessorAsync("/accessors/" + accessor.index, accessor).then(function(data) {
        setData(babylonVertexBuffer, data);
      }));
    };
    loadAttribute("POSITION", VertexBuffer.PositionKind, function(babylonVertexBuffer, data) {
      var positions = new Float32Array(data.length);
      babylonVertexBuffer.forEach(data.length, function(value, index) {
        positions[index] = data[index] + value;
      });
      babylonMorphTarget.setPositions(positions);
    });
    loadAttribute("NORMAL", VertexBuffer.NormalKind, function(babylonVertexBuffer, data) {
      var normals = new Float32Array(data.length);
      babylonVertexBuffer.forEach(normals.length, function(value, index) {
        normals[index] = data[index] + value;
      });
      babylonMorphTarget.setNormals(normals);
    });
    loadAttribute("TANGENT", VertexBuffer.TangentKind, function(babylonVertexBuffer, data) {
      var tangents = new Float32Array(data.length / 3 * 4);
      var dataIndex = 0;
      babylonVertexBuffer.forEach(data.length / 3 * 4, function(value, index) {
        if ((index + 1) % 4 !== 0) {
          tangents[dataIndex] = data[dataIndex] + value;
          dataIndex++;
        }
      });
      babylonMorphTarget.setTangents(tangents);
    });
    return Promise.all(promises).then(function() {
    });
  };
  GLTFLoader3._LoadTransform = function(node, babylonNode) {
    if (node.skin != void 0) {
      return;
    }
    var position = Vector3.Zero();
    var rotation = Quaternion.Identity();
    var scaling = Vector3.One();
    if (node.matrix) {
      var matrix = Matrix.FromArray(node.matrix);
      matrix.decompose(scaling, rotation, position);
    } else {
      if (node.translation) {
        position = Vector3.FromArray(node.translation);
      }
      if (node.rotation) {
        rotation = Quaternion.FromArray(node.rotation);
      }
      if (node.scale) {
        scaling = Vector3.FromArray(node.scale);
      }
    }
    babylonNode.position = position;
    babylonNode.rotationQuaternion = rotation;
    babylonNode.scaling = scaling;
  };
  GLTFLoader3.prototype._loadSkinAsync = function(context, node, skin) {
    var _this = this;
    var extensionPromise = this._extensionsLoadSkinAsync(context, node, skin);
    if (extensionPromise) {
      return extensionPromise;
    }
    var assignSkeleton = function(skeleton) {
      _this._forEachPrimitive(node, function(babylonMesh) {
        babylonMesh.skeleton = skeleton;
      });
    };
    if (skin._data) {
      assignSkeleton(skin._data.babylonSkeleton);
      return skin._data.promise;
    }
    var skeletonId = "skeleton" + skin.index;
    this._babylonScene._blockEntityCollection = this._forAssetContainer;
    var babylonSkeleton = new Skeleton(skin.name || skeletonId, skeletonId, this._babylonScene);
    this._babylonScene._blockEntityCollection = false;
    babylonSkeleton.overrideMesh = this._rootBabylonMesh;
    this._loadBones(context, skin, babylonSkeleton);
    assignSkeleton(babylonSkeleton);
    var promise = this._loadSkinInverseBindMatricesDataAsync(context, skin).then(function(inverseBindMatricesData) {
      _this._updateBoneMatrices(babylonSkeleton, inverseBindMatricesData);
    });
    skin._data = {
      babylonSkeleton,
      promise
    };
    return promise;
  };
  GLTFLoader3.prototype._loadBones = function(context, skin, babylonSkeleton) {
    var babylonBones = {};
    for (var _i = 0, _a = skin.joints; _i < _a.length; _i++) {
      var index = _a[_i];
      var node = ArrayItem.Get(context + "/joints/" + index, this._gltf.nodes, index);
      this._loadBone(node, skin, babylonSkeleton, babylonBones);
    }
  };
  GLTFLoader3.prototype._loadBone = function(node, skin, babylonSkeleton, babylonBones) {
    var babylonBone = babylonBones[node.index];
    if (babylonBone) {
      return babylonBone;
    }
    var babylonParentBone = null;
    if (node.parent && node.parent._babylonTransformNode !== this._rootBabylonMesh) {
      babylonParentBone = this._loadBone(node.parent, skin, babylonSkeleton, babylonBones);
    }
    var boneIndex = skin.joints.indexOf(node.index);
    babylonBone = new Bone(node.name || "joint" + node.index, babylonSkeleton, babylonParentBone, this._getNodeMatrix(node), null, null, boneIndex);
    babylonBones[node.index] = babylonBone;
    node._babylonBones = node._babylonBones || [];
    node._babylonBones.push(babylonBone);
    return babylonBone;
  };
  GLTFLoader3.prototype._loadSkinInverseBindMatricesDataAsync = function(context, skin) {
    if (skin.inverseBindMatrices == void 0) {
      return Promise.resolve(null);
    }
    var accessor = ArrayItem.Get(context + "/inverseBindMatrices", this._gltf.accessors, skin.inverseBindMatrices);
    return this._loadFloatAccessorAsync("/accessors/" + accessor.index, accessor);
  };
  GLTFLoader3.prototype._updateBoneMatrices = function(babylonSkeleton, inverseBindMatricesData) {
    for (var _i = 0, _a = babylonSkeleton.bones; _i < _a.length; _i++) {
      var babylonBone = _a[_i];
      var baseMatrix = Matrix.Identity();
      var boneIndex = babylonBone._index;
      if (inverseBindMatricesData && boneIndex !== -1) {
        Matrix.FromArrayToRef(inverseBindMatricesData, boneIndex * 16, baseMatrix);
        baseMatrix.invertToRef(baseMatrix);
      }
      var babylonParentBone = babylonBone.getParent();
      if (babylonParentBone) {
        baseMatrix.multiplyToRef(babylonParentBone.getInvertedAbsoluteTransform(), baseMatrix);
      }
      babylonBone.setBindPose(baseMatrix);
      babylonBone.updateMatrix(baseMatrix, false, false);
      babylonBone._updateDifferenceMatrix(void 0, false);
    }
  };
  GLTFLoader3.prototype._getNodeMatrix = function(node) {
    return node.matrix ? Matrix.FromArray(node.matrix) : Matrix.Compose(node.scale ? Vector3.FromArray(node.scale) : Vector3.One(), node.rotation ? Quaternion.FromArray(node.rotation) : Quaternion.Identity(), node.translation ? Vector3.FromArray(node.translation) : Vector3.Zero());
  };
  GLTFLoader3.prototype.loadCameraAsync = function(context, camera, assign) {
    if (assign === void 0) {
      assign = function() {
      };
    }
    var extensionPromise = this._extensionsLoadCameraAsync(context, camera, assign);
    if (extensionPromise) {
      return extensionPromise;
    }
    var promises = new Array();
    this.logOpen(context + " " + (camera.name || ""));
    this._babylonScene._blockEntityCollection = this._forAssetContainer;
    var babylonCamera = new FreeCamera(camera.name || "camera" + camera.index, Vector3.Zero(), this._babylonScene, false);
    this._babylonScene._blockEntityCollection = false;
    babylonCamera.ignoreParentScaling = true;
    babylonCamera.rotation = new Vector3(0, Math.PI, 0);
    switch (camera.type) {
      case "perspective": {
        var perspective = camera.perspective;
        if (!perspective) {
          throw new Error(context + ": Camera perspective properties are missing");
        }
        babylonCamera.fov = perspective.yfov;
        babylonCamera.minZ = perspective.znear;
        babylonCamera.maxZ = perspective.zfar || Number.MAX_VALUE;
        break;
      }
      case "orthographic": {
        if (!camera.orthographic) {
          throw new Error(context + ": Camera orthographic properties are missing");
        }
        babylonCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;
        babylonCamera.orthoLeft = -camera.orthographic.xmag;
        babylonCamera.orthoRight = camera.orthographic.xmag;
        babylonCamera.orthoBottom = -camera.orthographic.ymag;
        babylonCamera.orthoTop = camera.orthographic.ymag;
        babylonCamera.minZ = camera.orthographic.znear;
        babylonCamera.maxZ = camera.orthographic.zfar;
        break;
      }
      default: {
        throw new Error(context + ": Invalid camera type (" + camera.type + ")");
      }
    }
    GLTFLoader3.AddPointerMetadata(babylonCamera, context);
    this._parent.onCameraLoadedObservable.notifyObservers(babylonCamera);
    assign(babylonCamera);
    this.logClose();
    return Promise.all(promises).then(function() {
      return babylonCamera;
    });
  };
  GLTFLoader3.prototype._loadAnimationsAsync = function() {
    var animations = this._gltf.animations;
    if (!animations) {
      return Promise.resolve();
    }
    var promises = new Array();
    for (var index = 0; index < animations.length; index++) {
      var animation = animations[index];
      promises.push(this.loadAnimationAsync("/animations/" + animation.index, animation));
    }
    return Promise.all(promises).then(function() {
    });
  };
  GLTFLoader3.prototype.loadAnimationAsync = function(context, animation) {
    var promise = this._extensionsLoadAnimationAsync(context, animation);
    if (promise) {
      return promise;
    }
    this._babylonScene._blockEntityCollection = this._forAssetContainer;
    var babylonAnimationGroup = new AnimationGroup(animation.name || "animation" + animation.index, this._babylonScene);
    this._babylonScene._blockEntityCollection = false;
    animation._babylonAnimationGroup = babylonAnimationGroup;
    var promises = new Array();
    ArrayItem.Assign(animation.channels);
    ArrayItem.Assign(animation.samplers);
    for (var _i = 0, _a = animation.channels; _i < _a.length; _i++) {
      var channel = _a[_i];
      promises.push(this._loadAnimationChannelAsync(context + "/channels/" + channel.index, context, animation, channel, babylonAnimationGroup));
    }
    return Promise.all(promises).then(function() {
      babylonAnimationGroup.normalize(0);
      return babylonAnimationGroup;
    });
  };
  GLTFLoader3.prototype._loadAnimationChannelAsync = function(context, animationContext, animation, channel, babylonAnimationGroup, animationTargetOverride) {
    var _this = this;
    if (animationTargetOverride === void 0) {
      animationTargetOverride = null;
    }
    if (channel.target.node == void 0) {
      return Promise.resolve();
    }
    var targetNode = ArrayItem.Get(context + "/target/node", this._gltf.nodes, channel.target.node);
    if (channel.target.path === "weights" && !targetNode._numMorphTargets || channel.target.path !== "weights" && !targetNode._babylonTransformNode) {
      return Promise.resolve();
    }
    var sampler = ArrayItem.Get(context + "/sampler", animation.samplers, channel.sampler);
    return this._loadAnimationSamplerAsync(animationContext + "/samplers/" + channel.sampler, sampler).then(function(data) {
      var targetPath;
      var animationType;
      switch (channel.target.path) {
        case "translation": {
          targetPath = "position";
          animationType = Animation.ANIMATIONTYPE_VECTOR3;
          break;
        }
        case "rotation": {
          targetPath = "rotationQuaternion";
          animationType = Animation.ANIMATIONTYPE_QUATERNION;
          break;
        }
        case "scale": {
          targetPath = "scaling";
          animationType = Animation.ANIMATIONTYPE_VECTOR3;
          break;
        }
        case "weights": {
          targetPath = "influence";
          animationType = Animation.ANIMATIONTYPE_FLOAT;
          break;
        }
        default: {
          throw new Error(context + "/target/path: Invalid value (" + channel.target.path + ")");
        }
      }
      var outputBufferOffset = 0;
      var getNextOutputValue;
      switch (targetPath) {
        case "position": {
          getNextOutputValue = function() {
            var value = Vector3.FromArray(data.output, outputBufferOffset);
            outputBufferOffset += 3;
            return value;
          };
          break;
        }
        case "rotationQuaternion": {
          getNextOutputValue = function() {
            var value = Quaternion.FromArray(data.output, outputBufferOffset);
            outputBufferOffset += 4;
            return value;
          };
          break;
        }
        case "scaling": {
          getNextOutputValue = function() {
            var value = Vector3.FromArray(data.output, outputBufferOffset);
            outputBufferOffset += 3;
            return value;
          };
          break;
        }
        case "influence": {
          getNextOutputValue = function() {
            var value = new Array(targetNode._numMorphTargets);
            for (var i = 0; i < targetNode._numMorphTargets; i++) {
              value[i] = data.output[outputBufferOffset++];
            }
            return value;
          };
          break;
        }
      }
      var getNextKey;
      switch (data.interpolation) {
        case "STEP": {
          getNextKey = function(frameIndex2) {
            return {
              frame: data.input[frameIndex2],
              value: getNextOutputValue(),
              interpolation: AnimationKeyInterpolation.STEP
            };
          };
          break;
        }
        case "LINEAR": {
          getNextKey = function(frameIndex2) {
            return {
              frame: data.input[frameIndex2],
              value: getNextOutputValue()
            };
          };
          break;
        }
        case "CUBICSPLINE": {
          getNextKey = function(frameIndex2) {
            return {
              frame: data.input[frameIndex2],
              inTangent: getNextOutputValue(),
              value: getNextOutputValue(),
              outTangent: getNextOutputValue()
            };
          };
          break;
        }
      }
      var keys = new Array(data.input.length);
      for (var frameIndex = 0; frameIndex < data.input.length; frameIndex++) {
        keys[frameIndex] = getNextKey(frameIndex);
      }
      if (targetPath === "influence") {
        var _loop_2 = function(targetIndex2) {
          var animationName2 = babylonAnimationGroup.name + "_channel" + babylonAnimationGroup.targetedAnimations.length;
          var babylonAnimation2 = new Animation(animationName2, targetPath, 1, animationType);
          babylonAnimation2.setKeys(keys.map(function(key) {
            return {
              frame: key.frame,
              inTangent: key.inTangent ? key.inTangent[targetIndex2] : void 0,
              value: key.value[targetIndex2],
              outTangent: key.outTangent ? key.outTangent[targetIndex2] : void 0
            };
          }));
          _this._forEachPrimitive(targetNode, function(babylonAbstractMesh) {
            var babylonMesh = babylonAbstractMesh;
            var morphTarget = babylonMesh.morphTargetManager.getTarget(targetIndex2);
            var babylonAnimationClone = babylonAnimation2.clone();
            morphTarget.animations.push(babylonAnimationClone);
            babylonAnimationGroup.addTargetedAnimation(babylonAnimationClone, morphTarget);
          });
        };
        for (var targetIndex = 0; targetIndex < targetNode._numMorphTargets; targetIndex++) {
          _loop_2(targetIndex);
        }
      } else {
        var animationName = babylonAnimationGroup.name + "_channel" + babylonAnimationGroup.targetedAnimations.length;
        var babylonAnimation = new Animation(animationName, targetPath, 1, animationType);
        babylonAnimation.setKeys(keys);
        if (animationTargetOverride != null && animationTargetOverride.animations != null) {
          animationTargetOverride.animations.push(babylonAnimation);
          babylonAnimationGroup.addTargetedAnimation(babylonAnimation, animationTargetOverride);
        } else {
          targetNode._babylonTransformNode.animations.push(babylonAnimation);
          babylonAnimationGroup.addTargetedAnimation(babylonAnimation, targetNode._babylonTransformNode);
        }
      }
    });
  };
  GLTFLoader3.prototype._loadAnimationSamplerAsync = function(context, sampler) {
    if (sampler._data) {
      return sampler._data;
    }
    var interpolation = sampler.interpolation || "LINEAR";
    switch (interpolation) {
      case "STEP":
      case "LINEAR":
      case "CUBICSPLINE": {
        break;
      }
      default: {
        throw new Error(context + "/interpolation: Invalid value (" + sampler.interpolation + ")");
      }
    }
    var inputAccessor = ArrayItem.Get(context + "/input", this._gltf.accessors, sampler.input);
    var outputAccessor = ArrayItem.Get(context + "/output", this._gltf.accessors, sampler.output);
    sampler._data = Promise.all([
      this._loadFloatAccessorAsync("/accessors/" + inputAccessor.index, inputAccessor),
      this._loadFloatAccessorAsync("/accessors/" + outputAccessor.index, outputAccessor)
    ]).then(function(_a) {
      var inputData = _a[0], outputData = _a[1];
      return {
        input: inputData,
        interpolation,
        output: outputData
      };
    });
    return sampler._data;
  };
  GLTFLoader3.prototype._loadBufferAsync = function(context, buffer, byteOffset, byteLength) {
    var extensionPromise = this._extensionsLoadBufferAsync(context, buffer, byteOffset, byteLength);
    if (extensionPromise) {
      return extensionPromise;
    }
    if (!buffer._data) {
      if (buffer.uri) {
        buffer._data = this.loadUriAsync(context + "/uri", buffer, buffer.uri);
      } else {
        if (!this._bin) {
          throw new Error(context + ": Uri is missing or the binary glTF is missing its binary chunk");
        }
        buffer._data = this._bin.readAsync(0, buffer.byteLength);
      }
    }
    return buffer._data.then(function(data) {
      try {
        return new Uint8Array(data.buffer, data.byteOffset + byteOffset, byteLength);
      } catch (e) {
        throw new Error(context + ": " + e.message);
      }
    });
  };
  GLTFLoader3.prototype.loadBufferViewAsync = function(context, bufferView) {
    var extensionPromise = this._extensionsLoadBufferViewAsync(context, bufferView);
    if (extensionPromise) {
      return extensionPromise;
    }
    if (bufferView._data) {
      return bufferView._data;
    }
    var buffer = ArrayItem.Get(context + "/buffer", this._gltf.buffers, bufferView.buffer);
    bufferView._data = this._loadBufferAsync("/buffers/" + buffer.index, buffer, bufferView.byteOffset || 0, bufferView.byteLength);
    return bufferView._data;
  };
  GLTFLoader3.prototype._loadAccessorAsync = function(context, accessor, constructor) {
    var _this = this;
    if (accessor._data) {
      return accessor._data;
    }
    var numComponents = GLTFLoader3._GetNumComponents(context, accessor.type);
    var byteStride = numComponents * VertexBuffer.GetTypeByteLength(accessor.componentType);
    var length = numComponents * accessor.count;
    if (accessor.bufferView == void 0) {
      accessor._data = Promise.resolve(new constructor(length));
    } else {
      var bufferView_1 = ArrayItem.Get(context + "/bufferView", this._gltf.bufferViews, accessor.bufferView);
      accessor._data = this.loadBufferViewAsync("/bufferViews/" + bufferView_1.index, bufferView_1).then(function(data) {
        if (accessor.componentType === 5126 && !accessor.normalized && (!bufferView_1.byteStride || bufferView_1.byteStride === byteStride)) {
          return GLTFLoader3._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, length);
        } else {
          var typedArray_1 = new constructor(length);
          VertexBuffer.ForEach(data, accessor.byteOffset || 0, bufferView_1.byteStride || byteStride, numComponents, accessor.componentType, typedArray_1.length, accessor.normalized || false, function(value, index) {
            typedArray_1[index] = value;
          });
          return typedArray_1;
        }
      });
    }
    if (accessor.sparse) {
      var sparse_1 = accessor.sparse;
      accessor._data = accessor._data.then(function(data) {
        var typedArray = data;
        var indicesBufferView = ArrayItem.Get(context + "/sparse/indices/bufferView", _this._gltf.bufferViews, sparse_1.indices.bufferView);
        var valuesBufferView = ArrayItem.Get(context + "/sparse/values/bufferView", _this._gltf.bufferViews, sparse_1.values.bufferView);
        return Promise.all([
          _this.loadBufferViewAsync("/bufferViews/" + indicesBufferView.index, indicesBufferView),
          _this.loadBufferViewAsync("/bufferViews/" + valuesBufferView.index, valuesBufferView)
        ]).then(function(_a) {
          var indicesData = _a[0], valuesData = _a[1];
          var indices = GLTFLoader3._GetTypedArray(context + "/sparse/indices", sparse_1.indices.componentType, indicesData, sparse_1.indices.byteOffset, sparse_1.count);
          var sparseLength = numComponents * sparse_1.count;
          var values;
          if (accessor.componentType === 5126 && !accessor.normalized) {
            values = GLTFLoader3._GetTypedArray(context + "/sparse/values", accessor.componentType, valuesData, sparse_1.values.byteOffset, sparseLength);
          } else {
            var sparseData = GLTFLoader3._GetTypedArray(context + "/sparse/values", accessor.componentType, valuesData, sparse_1.values.byteOffset, sparseLength);
            values = new constructor(sparseLength);
            VertexBuffer.ForEach(sparseData, 0, byteStride, numComponents, accessor.componentType, values.length, accessor.normalized || false, function(value, index) {
              values[index] = value;
            });
          }
          var valuesIndex = 0;
          for (var indicesIndex = 0; indicesIndex < indices.length; indicesIndex++) {
            var dataIndex = indices[indicesIndex] * numComponents;
            for (var componentIndex = 0; componentIndex < numComponents; componentIndex++) {
              typedArray[dataIndex++] = values[valuesIndex++];
            }
          }
          return typedArray;
        });
      });
    }
    return accessor._data;
  };
  GLTFLoader3.prototype._loadFloatAccessorAsync = function(context, accessor) {
    return this._loadAccessorAsync(context, accessor, Float32Array);
  };
  GLTFLoader3.prototype._loadIndicesAccessorAsync = function(context, accessor) {
    if (accessor.type !== "SCALAR") {
      throw new Error(context + "/type: Invalid value " + accessor.type);
    }
    if (accessor.componentType !== 5121 && accessor.componentType !== 5123 && accessor.componentType !== 5125) {
      throw new Error(context + "/componentType: Invalid value " + accessor.componentType);
    }
    if (accessor._data) {
      return accessor._data;
    }
    if (accessor.sparse) {
      var constructor = GLTFLoader3._GetTypedArrayConstructor(context + "/componentType", accessor.componentType);
      accessor._data = this._loadAccessorAsync(context, accessor, constructor);
    } else {
      var bufferView = ArrayItem.Get(context + "/bufferView", this._gltf.bufferViews, accessor.bufferView);
      accessor._data = this.loadBufferViewAsync("/bufferViews/" + bufferView.index, bufferView).then(function(data) {
        return GLTFLoader3._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, accessor.count);
      });
    }
    return accessor._data;
  };
  GLTFLoader3.prototype._loadVertexBufferViewAsync = function(bufferView, kind) {
    var _this = this;
    if (bufferView._babylonBuffer) {
      return bufferView._babylonBuffer;
    }
    bufferView._babylonBuffer = this.loadBufferViewAsync("/bufferViews/" + bufferView.index, bufferView).then(function(data) {
      return new Buffer(_this._babylonScene.getEngine(), data, false);
    });
    return bufferView._babylonBuffer;
  };
  GLTFLoader3.prototype._loadVertexAccessorAsync = function(context, accessor, kind) {
    var _this = this;
    if (accessor._babylonVertexBuffer) {
      return accessor._babylonVertexBuffer;
    }
    if (accessor.sparse) {
      accessor._babylonVertexBuffer = this._loadFloatAccessorAsync("/accessors/" + accessor.index, accessor).then(function(data) {
        return new VertexBuffer(_this._babylonScene.getEngine(), data, kind, false);
      });
    } else if (accessor.byteOffset && accessor.byteOffset % VertexBuffer.GetTypeByteLength(accessor.componentType) !== 0) {
      Logger.Warn("Accessor byte offset is not a multiple of component type byte length");
      accessor._babylonVertexBuffer = this._loadFloatAccessorAsync("/accessors/" + accessor.index, accessor).then(function(data) {
        return new VertexBuffer(_this._babylonScene.getEngine(), data, kind, false);
      });
    } else if (kind === VertexBuffer.MatricesIndicesKind || kind === VertexBuffer.MatricesIndicesExtraKind) {
      accessor._babylonVertexBuffer = this._loadFloatAccessorAsync("/accessors/" + accessor.index, accessor).then(function(data) {
        return new VertexBuffer(_this._babylonScene.getEngine(), data, kind, false);
      });
    } else {
      var bufferView_2 = ArrayItem.Get(context + "/bufferView", this._gltf.bufferViews, accessor.bufferView);
      accessor._babylonVertexBuffer = this._loadVertexBufferViewAsync(bufferView_2, kind).then(function(babylonBuffer) {
        var size = GLTFLoader3._GetNumComponents(context, accessor.type);
        return new VertexBuffer(_this._babylonScene.getEngine(), babylonBuffer, kind, false, false, bufferView_2.byteStride, false, accessor.byteOffset, size, accessor.componentType, accessor.normalized, true, 1, true);
      });
    }
    return accessor._babylonVertexBuffer;
  };
  GLTFLoader3.prototype._loadMaterialMetallicRoughnessPropertiesAsync = function(context, properties, babylonMaterial) {
    if (!(babylonMaterial instanceof PBRMaterial)) {
      throw new Error(context + ": Material type not supported");
    }
    var promises = new Array();
    if (properties) {
      if (properties.baseColorFactor) {
        babylonMaterial.albedoColor = Color3.FromArray(properties.baseColorFactor);
        babylonMaterial.alpha = properties.baseColorFactor[3];
      } else {
        babylonMaterial.albedoColor = Color3.White();
      }
      babylonMaterial.metallic = properties.metallicFactor == void 0 ? 1 : properties.metallicFactor;
      babylonMaterial.roughness = properties.roughnessFactor == void 0 ? 1 : properties.roughnessFactor;
      if (properties.baseColorTexture) {
        promises.push(this.loadTextureInfoAsync(context + "/baseColorTexture", properties.baseColorTexture, function(texture) {
          texture.name = babylonMaterial.name + " (Base Color)";
          babylonMaterial.albedoTexture = texture;
        }));
      }
      if (properties.metallicRoughnessTexture) {
        properties.metallicRoughnessTexture.nonColorData = true;
        promises.push(this.loadTextureInfoAsync(context + "/metallicRoughnessTexture", properties.metallicRoughnessTexture, function(texture) {
          texture.name = babylonMaterial.name + " (Metallic Roughness)";
          babylonMaterial.metallicTexture = texture;
        }));
        babylonMaterial.useMetallnessFromMetallicTextureBlue = true;
        babylonMaterial.useRoughnessFromMetallicTextureGreen = true;
        babylonMaterial.useRoughnessFromMetallicTextureAlpha = false;
      }
    }
    return Promise.all(promises).then(function() {
    });
  };
  GLTFLoader3.prototype._loadMaterialAsync = function(context, material, babylonMesh, babylonDrawMode, assign) {
    if (assign === void 0) {
      assign = function() {
      };
    }
    var extensionPromise = this._extensionsLoadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign);
    if (extensionPromise) {
      return extensionPromise;
    }
    material._data = material._data || {};
    var babylonData = material._data[babylonDrawMode];
    if (!babylonData) {
      this.logOpen(context + " " + (material.name || ""));
      var babylonMaterial = this.createMaterial(context, material, babylonDrawMode);
      babylonData = {
        babylonMaterial,
        babylonMeshes: [],
        promise: this.loadMaterialPropertiesAsync(context, material, babylonMaterial)
      };
      material._data[babylonDrawMode] = babylonData;
      GLTFLoader3.AddPointerMetadata(babylonMaterial, context);
      this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);
      this.logClose();
    }
    if (babylonMesh) {
      babylonData.babylonMeshes.push(babylonMesh);
      babylonMesh.onDisposeObservable.addOnce(function() {
        var index = babylonData.babylonMeshes.indexOf(babylonMesh);
        if (index !== -1) {
          babylonData.babylonMeshes.splice(index, 1);
        }
      });
    }
    assign(babylonData.babylonMaterial);
    return babylonData.promise.then(function() {
      return babylonData.babylonMaterial;
    });
  };
  GLTFLoader3.prototype._createDefaultMaterial = function(name, babylonDrawMode) {
    this._babylonScene._blockEntityCollection = this._forAssetContainer;
    var babylonMaterial = new PBRMaterial(name, this._babylonScene);
    this._babylonScene._blockEntityCollection = false;
    babylonMaterial.fillMode = babylonDrawMode;
    babylonMaterial.enableSpecularAntiAliasing = true;
    babylonMaterial.useRadianceOverAlpha = !this._parent.transparencyAsCoverage;
    babylonMaterial.useSpecularOverAlpha = !this._parent.transparencyAsCoverage;
    babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_OPAQUE;
    babylonMaterial.metallic = 1;
    babylonMaterial.roughness = 1;
    return babylonMaterial;
  };
  GLTFLoader3.prototype.createMaterial = function(context, material, babylonDrawMode) {
    var extensionPromise = this._extensionsCreateMaterial(context, material, babylonDrawMode);
    if (extensionPromise) {
      return extensionPromise;
    }
    var name = material.name || "material" + material.index;
    var babylonMaterial = this._createDefaultMaterial(name, babylonDrawMode);
    return babylonMaterial;
  };
  GLTFLoader3.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
    var extensionPromise = this._extensionsLoadMaterialPropertiesAsync(context, material, babylonMaterial);
    if (extensionPromise) {
      return extensionPromise;
    }
    var promises = new Array();
    promises.push(this.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));
    if (material.pbrMetallicRoughness) {
      promises.push(this._loadMaterialMetallicRoughnessPropertiesAsync(context + "/pbrMetallicRoughness", material.pbrMetallicRoughness, babylonMaterial));
    }
    this.loadMaterialAlphaProperties(context, material, babylonMaterial);
    return Promise.all(promises).then(function() {
    });
  };
  GLTFLoader3.prototype.loadMaterialBasePropertiesAsync = function(context, material, babylonMaterial) {
    if (!(babylonMaterial instanceof PBRMaterial)) {
      throw new Error(context + ": Material type not supported");
    }
    var promises = new Array();
    babylonMaterial.emissiveColor = material.emissiveFactor ? Color3.FromArray(material.emissiveFactor) : new Color3(0, 0, 0);
    if (material.doubleSided) {
      babylonMaterial.backFaceCulling = false;
      babylonMaterial.twoSidedLighting = true;
    }
    if (material.normalTexture) {
      material.normalTexture.nonColorData = true;
      promises.push(this.loadTextureInfoAsync(context + "/normalTexture", material.normalTexture, function(texture) {
        texture.name = babylonMaterial.name + " (Normal)";
        babylonMaterial.bumpTexture = texture;
      }));
      babylonMaterial.invertNormalMapX = !this._babylonScene.useRightHandedSystem;
      babylonMaterial.invertNormalMapY = this._babylonScene.useRightHandedSystem;
      if (material.normalTexture.scale != void 0) {
        babylonMaterial.bumpTexture.level = material.normalTexture.scale;
      }
      babylonMaterial.forceIrradianceInFragment = true;
    }
    if (material.occlusionTexture) {
      material.occlusionTexture.nonColorData = true;
      promises.push(this.loadTextureInfoAsync(context + "/occlusionTexture", material.occlusionTexture, function(texture) {
        texture.name = babylonMaterial.name + " (Occlusion)";
        babylonMaterial.ambientTexture = texture;
      }));
      babylonMaterial.useAmbientInGrayScale = true;
      if (material.occlusionTexture.strength != void 0) {
        babylonMaterial.ambientTextureStrength = material.occlusionTexture.strength;
      }
    }
    if (material.emissiveTexture) {
      promises.push(this.loadTextureInfoAsync(context + "/emissiveTexture", material.emissiveTexture, function(texture) {
        texture.name = babylonMaterial.name + " (Emissive)";
        babylonMaterial.emissiveTexture = texture;
      }));
    }
    return Promise.all(promises).then(function() {
    });
  };
  GLTFLoader3.prototype.loadMaterialAlphaProperties = function(context, material, babylonMaterial) {
    if (!(babylonMaterial instanceof PBRMaterial)) {
      throw new Error(context + ": Material type not supported");
    }
    var alphaMode = material.alphaMode || "OPAQUE";
    switch (alphaMode) {
      case "OPAQUE": {
        babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_OPAQUE;
        break;
      }
      case "MASK": {
        babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHATEST;
        babylonMaterial.alphaCutOff = material.alphaCutoff == void 0 ? 0.5 : material.alphaCutoff;
        if (babylonMaterial.albedoTexture) {
          babylonMaterial.albedoTexture.hasAlpha = true;
        }
        break;
      }
      case "BLEND": {
        babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHABLEND;
        if (babylonMaterial.albedoTexture) {
          babylonMaterial.albedoTexture.hasAlpha = true;
          babylonMaterial.useAlphaFromAlbedoTexture = true;
        }
        break;
      }
      default: {
        throw new Error(context + "/alphaMode: Invalid value (" + material.alphaMode + ")");
      }
    }
  };
  GLTFLoader3.prototype.loadTextureInfoAsync = function(context, textureInfo, assign) {
    var _this = this;
    if (assign === void 0) {
      assign = function() {
      };
    }
    var extensionPromise = this._extensionsLoadTextureInfoAsync(context, textureInfo, assign);
    if (extensionPromise) {
      return extensionPromise;
    }
    this.logOpen("" + context);
    if (textureInfo.texCoord >= 2) {
      throw new Error(context + "/texCoord: Invalid value (" + textureInfo.texCoord + ")");
    }
    var texture = ArrayItem.Get(context + "/index", this._gltf.textures, textureInfo.index);
    texture._textureInfo = textureInfo;
    var promise = this._loadTextureAsync("/textures/" + textureInfo.index, texture, function(babylonTexture) {
      babylonTexture.coordinatesIndex = textureInfo.texCoord || 0;
      GLTFLoader3.AddPointerMetadata(babylonTexture, context);
      _this._parent.onTextureLoadedObservable.notifyObservers(babylonTexture);
      assign(babylonTexture);
    });
    this.logClose();
    return promise;
  };
  GLTFLoader3.prototype._loadTextureAsync = function(context, texture, assign) {
    if (assign === void 0) {
      assign = function() {
      };
    }
    var extensionPromise = this._extensionsLoadTextureAsync(context, texture, assign);
    if (extensionPromise) {
      return extensionPromise;
    }
    this.logOpen(context + " " + (texture.name || ""));
    var sampler = texture.sampler == void 0 ? GLTFLoader3.DefaultSampler : ArrayItem.Get(context + "/sampler", this._gltf.samplers, texture.sampler);
    var image = ArrayItem.Get(context + "/source", this._gltf.images, texture.source);
    var promise = this._createTextureAsync(context, sampler, image, assign);
    this.logClose();
    return promise;
  };
  GLTFLoader3.prototype._createTextureAsync = function(context, sampler, image, assign, textureLoaderOptions) {
    var _this = this;
    if (assign === void 0) {
      assign = function() {
      };
    }
    var samplerData = this._loadSampler("/samplers/" + sampler.index, sampler);
    var promises = new Array();
    var deferred = new Deferred();
    this._babylonScene._blockEntityCollection = this._forAssetContainer;
    var babylonTexture = new Texture(null, this._babylonScene, samplerData.noMipMaps, false, samplerData.samplingMode, function() {
      if (!_this._disposed) {
        deferred.resolve();
      }
    }, function(message, exception) {
      if (!_this._disposed) {
        deferred.reject(new Error(context + ": " + (exception && exception.message ? exception.message : message || "Failed to load texture")));
      }
    }, void 0, void 0, void 0, image.mimeType, textureLoaderOptions);
    this._babylonScene._blockEntityCollection = false;
    promises.push(deferred.promise);
    promises.push(this.loadImageAsync("/images/" + image.index, image).then(function(data) {
      var name = image.uri || _this._fileName + "#image" + image.index;
      var dataUrl = "data:" + _this._uniqueRootUrl + name;
      babylonTexture.updateURL(dataUrl, data);
    }));
    babylonTexture.wrapU = samplerData.wrapU;
    babylonTexture.wrapV = samplerData.wrapV;
    assign(babylonTexture);
    return Promise.all(promises).then(function() {
      return babylonTexture;
    });
  };
  GLTFLoader3.prototype._loadSampler = function(context, sampler) {
    if (!sampler._data) {
      sampler._data = {
        noMipMaps: sampler.minFilter === 9728 || sampler.minFilter === 9729,
        samplingMode: GLTFLoader3._GetTextureSamplingMode(context, sampler),
        wrapU: GLTFLoader3._GetTextureWrapMode(context + "/wrapS", sampler.wrapS),
        wrapV: GLTFLoader3._GetTextureWrapMode(context + "/wrapT", sampler.wrapT)
      };
    }
    return sampler._data;
  };
  GLTFLoader3.prototype.loadImageAsync = function(context, image) {
    if (!image._data) {
      this.logOpen(context + " " + (image.name || ""));
      if (image.uri) {
        image._data = this.loadUriAsync(context + "/uri", image, image.uri);
      } else {
        var bufferView = ArrayItem.Get(context + "/bufferView", this._gltf.bufferViews, image.bufferView);
        image._data = this.loadBufferViewAsync("/bufferViews/" + bufferView.index, bufferView);
      }
      this.logClose();
    }
    return image._data;
  };
  GLTFLoader3.prototype.loadUriAsync = function(context, property, uri) {
    var _this = this;
    var extensionPromise = this._extensionsLoadUriAsync(context, property, uri);
    if (extensionPromise) {
      return extensionPromise;
    }
    if (!GLTFLoader3._ValidateUri(uri)) {
      throw new Error(context + ": '" + uri + "' is invalid");
    }
    if (Tools.IsBase64(uri)) {
      var data = new Uint8Array(Tools.DecodeBase64(uri));
      this.log("Decoded " + uri.substr(0, 64) + "... (" + data.length + " bytes)");
      return Promise.resolve(data);
    }
    this.log("Loading " + uri);
    return this._parent.preprocessUrlAsync(this._rootUrl + uri).then(function(url) {
      return new Promise(function(resolve, reject) {
        _this._parent._loadFile(url, _this._babylonScene, function(data2) {
          if (!_this._disposed) {
            _this.log("Loaded " + uri + " (" + data2.byteLength + " bytes)");
            resolve(new Uint8Array(data2));
          }
        }, true, function(request) {
          reject(new LoadFileError(context + ": Failed to load '" + uri + "'" + (request ? ": " + request.status + " " + request.statusText : ""), request));
        });
      });
    });
  };
  GLTFLoader3.AddPointerMetadata = function(babylonObject, pointer) {
    var metadata = babylonObject.metadata = babylonObject.metadata || {};
    var gltf = metadata.gltf = metadata.gltf || {};
    var pointers = gltf.pointers = gltf.pointers || [];
    pointers.push(pointer);
  };
  GLTFLoader3._GetTextureWrapMode = function(context, mode) {
    mode = mode == void 0 ? 10497 : mode;
    switch (mode) {
      case 33071:
        return Texture.CLAMP_ADDRESSMODE;
      case 33648:
        return Texture.MIRROR_ADDRESSMODE;
      case 10497:
        return Texture.WRAP_ADDRESSMODE;
      default:
        Logger.Warn(context + ": Invalid value (" + mode + ")");
        return Texture.WRAP_ADDRESSMODE;
    }
  };
  GLTFLoader3._GetTextureSamplingMode = function(context, sampler) {
    var magFilter = sampler.magFilter == void 0 ? 9729 : sampler.magFilter;
    var minFilter = sampler.minFilter == void 0 ? 9987 : sampler.minFilter;
    if (magFilter === 9729) {
      switch (minFilter) {
        case 9728:
          return Texture.LINEAR_NEAREST;
        case 9729:
          return Texture.LINEAR_LINEAR;
        case 9984:
          return Texture.LINEAR_NEAREST_MIPNEAREST;
        case 9985:
          return Texture.LINEAR_LINEAR_MIPNEAREST;
        case 9986:
          return Texture.LINEAR_NEAREST_MIPLINEAR;
        case 9987:
          return Texture.LINEAR_LINEAR_MIPLINEAR;
        default:
          Logger.Warn(context + "/minFilter: Invalid value (" + minFilter + ")");
          return Texture.LINEAR_LINEAR_MIPLINEAR;
      }
    } else {
      if (magFilter !== 9728) {
        Logger.Warn(context + "/magFilter: Invalid value (" + magFilter + ")");
      }
      switch (minFilter) {
        case 9728:
          return Texture.NEAREST_NEAREST;
        case 9729:
          return Texture.NEAREST_LINEAR;
        case 9984:
          return Texture.NEAREST_NEAREST_MIPNEAREST;
        case 9985:
          return Texture.NEAREST_LINEAR_MIPNEAREST;
        case 9986:
          return Texture.NEAREST_NEAREST_MIPLINEAR;
        case 9987:
          return Texture.NEAREST_LINEAR_MIPLINEAR;
        default:
          Logger.Warn(context + "/minFilter: Invalid value (" + minFilter + ")");
          return Texture.NEAREST_NEAREST_MIPNEAREST;
      }
    }
  };
  GLTFLoader3._GetTypedArrayConstructor = function(context, componentType) {
    switch (componentType) {
      case 5120:
        return Int8Array;
      case 5121:
        return Uint8Array;
      case 5122:
        return Int16Array;
      case 5123:
        return Uint16Array;
      case 5125:
        return Uint32Array;
      case 5126:
        return Float32Array;
      default:
        throw new Error(context + ": Invalid component type " + componentType);
    }
  };
  GLTFLoader3._GetTypedArray = function(context, componentType, bufferView, byteOffset, length) {
    var buffer = bufferView.buffer;
    byteOffset = bufferView.byteOffset + (byteOffset || 0);
    var constructor = GLTFLoader3._GetTypedArrayConstructor(context + "/componentType", componentType);
    try {
      return new constructor(buffer, byteOffset, length);
    } catch (e) {
      throw new Error(context + ": " + e);
    }
  };
  GLTFLoader3._GetNumComponents = function(context, type) {
    switch (type) {
      case "SCALAR":
        return 1;
      case "VEC2":
        return 2;
      case "VEC3":
        return 3;
      case "VEC4":
        return 4;
      case "MAT2":
        return 4;
      case "MAT3":
        return 9;
      case "MAT4":
        return 16;
    }
    throw new Error(context + ": Invalid type (" + type + ")");
  };
  GLTFLoader3._ValidateUri = function(uri) {
    return Tools.IsBase64(uri) || uri.indexOf("..") === -1;
  };
  GLTFLoader3._GetDrawMode = function(context, mode) {
    if (mode == void 0) {
      mode = 4;
    }
    switch (mode) {
      case 0:
        return Material.PointListDrawMode;
      case 1:
        return Material.LineListDrawMode;
      case 2:
        return Material.LineLoopDrawMode;
      case 3:
        return Material.LineStripDrawMode;
      case 4:
        return Material.TriangleFillMode;
      case 5:
        return Material.TriangleStripDrawMode;
      case 6:
        return Material.TriangleFanDrawMode;
    }
    throw new Error(context + ": Invalid mesh primitive mode (" + mode + ")");
  };
  GLTFLoader3.prototype._compileMaterialsAsync = function() {
    var _this = this;
    this._parent._startPerformanceCounter("Compile materials");
    var promises = new Array();
    if (this._gltf.materials) {
      for (var _i = 0, _a = this._gltf.materials; _i < _a.length; _i++) {
        var material = _a[_i];
        if (material._data) {
          for (var babylonDrawMode in material._data) {
            var babylonData = material._data[babylonDrawMode];
            for (var _b = 0, _c = babylonData.babylonMeshes; _b < _c.length; _b++) {
              var babylonMesh = _c[_b];
              babylonMesh.computeWorldMatrix(true);
              var babylonMaterial = babylonData.babylonMaterial;
              promises.push(babylonMaterial.forceCompilationAsync(babylonMesh));
              promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { useInstances: true }));
              if (this._parent.useClipPlane) {
                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true }));
                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true, useInstances: true }));
              }
            }
          }
        }
      }
    }
    return Promise.all(promises).then(function() {
      _this._parent._endPerformanceCounter("Compile materials");
    });
  };
  GLTFLoader3.prototype._compileShadowGeneratorsAsync = function() {
    var _this = this;
    this._parent._startPerformanceCounter("Compile shadow generators");
    var promises = new Array();
    var lights = this._babylonScene.lights;
    for (var _i = 0, lights_1 = lights; _i < lights_1.length; _i++) {
      var light = lights_1[_i];
      var generator = light.getShadowGenerator();
      if (generator) {
        promises.push(generator.forceCompilationAsync());
      }
    }
    return Promise.all(promises).then(function() {
      _this._parent._endPerformanceCounter("Compile shadow generators");
    });
  };
  GLTFLoader3.prototype._forEachExtensions = function(action) {
    for (var _i = 0, _a = this._extensions; _i < _a.length; _i++) {
      var extension = _a[_i];
      if (extension.enabled) {
        action(extension);
      }
    }
  };
  GLTFLoader3.prototype._applyExtensions = function(property, functionName, actionAsync) {
    for (var _i = 0, _a = this._extensions; _i < _a.length; _i++) {
      var extension = _a[_i];
      if (extension.enabled) {
        var id = extension.name + "." + functionName;
        var loaderProperty = property;
        loaderProperty._activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions || {};
        var activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions;
        if (!activeLoaderExtensionFunctions[id]) {
          activeLoaderExtensionFunctions[id] = true;
          try {
            var result = actionAsync(extension);
            if (result) {
              return result;
            }
          } finally {
            delete activeLoaderExtensionFunctions[id];
          }
        }
      }
    }
    return null;
  };
  GLTFLoader3.prototype._extensionsOnLoading = function() {
    this._forEachExtensions(function(extension) {
      return extension.onLoading && extension.onLoading();
    });
  };
  GLTFLoader3.prototype._extensionsOnReady = function() {
    this._forEachExtensions(function(extension) {
      return extension.onReady && extension.onReady();
    });
  };
  GLTFLoader3.prototype._extensionsLoadSceneAsync = function(context, scene) {
    return this._applyExtensions(scene, "loadScene", function(extension) {
      return extension.loadSceneAsync && extension.loadSceneAsync(context, scene);
    });
  };
  GLTFLoader3.prototype._extensionsLoadNodeAsync = function(context, node, assign) {
    return this._applyExtensions(node, "loadNode", function(extension) {
      return extension.loadNodeAsync && extension.loadNodeAsync(context, node, assign);
    });
  };
  GLTFLoader3.prototype._extensionsLoadCameraAsync = function(context, camera, assign) {
    return this._applyExtensions(camera, "loadCamera", function(extension) {
      return extension.loadCameraAsync && extension.loadCameraAsync(context, camera, assign);
    });
  };
  GLTFLoader3.prototype._extensionsLoadVertexDataAsync = function(context, primitive, babylonMesh) {
    return this._applyExtensions(primitive, "loadVertexData", function(extension) {
      return extension._loadVertexDataAsync && extension._loadVertexDataAsync(context, primitive, babylonMesh);
    });
  };
  GLTFLoader3.prototype._extensionsLoadMeshPrimitiveAsync = function(context, name, node, mesh, primitive, assign) {
    return this._applyExtensions(primitive, "loadMeshPrimitive", function(extension) {
      return extension._loadMeshPrimitiveAsync && extension._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign);
    });
  };
  GLTFLoader3.prototype._extensionsLoadMaterialAsync = function(context, material, babylonMesh, babylonDrawMode, assign) {
    return this._applyExtensions(material, "loadMaterial", function(extension) {
      return extension._loadMaterialAsync && extension._loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign);
    });
  };
  GLTFLoader3.prototype._extensionsCreateMaterial = function(context, material, babylonDrawMode) {
    return this._applyExtensions(material, "createMaterial", function(extension) {
      return extension.createMaterial && extension.createMaterial(context, material, babylonDrawMode);
    });
  };
  GLTFLoader3.prototype._extensionsLoadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
    return this._applyExtensions(material, "loadMaterialProperties", function(extension) {
      return extension.loadMaterialPropertiesAsync && extension.loadMaterialPropertiesAsync(context, material, babylonMaterial);
    });
  };
  GLTFLoader3.prototype._extensionsLoadTextureInfoAsync = function(context, textureInfo, assign) {
    return this._applyExtensions(textureInfo, "loadTextureInfo", function(extension) {
      return extension.loadTextureInfoAsync && extension.loadTextureInfoAsync(context, textureInfo, assign);
    });
  };
  GLTFLoader3.prototype._extensionsLoadTextureAsync = function(context, texture, assign) {
    return this._applyExtensions(texture, "loadTexture", function(extension) {
      return extension._loadTextureAsync && extension._loadTextureAsync(context, texture, assign);
    });
  };
  GLTFLoader3.prototype._extensionsLoadAnimationAsync = function(context, animation) {
    return this._applyExtensions(animation, "loadAnimation", function(extension) {
      return extension.loadAnimationAsync && extension.loadAnimationAsync(context, animation);
    });
  };
  GLTFLoader3.prototype._extensionsLoadSkinAsync = function(context, node, skin) {
    return this._applyExtensions(skin, "loadSkin", function(extension) {
      return extension._loadSkinAsync && extension._loadSkinAsync(context, node, skin);
    });
  };
  GLTFLoader3.prototype._extensionsLoadUriAsync = function(context, property, uri) {
    return this._applyExtensions(property, "loadUri", function(extension) {
      return extension._loadUriAsync && extension._loadUriAsync(context, property, uri);
    });
  };
  GLTFLoader3.prototype._extensionsLoadBufferViewAsync = function(context, bufferView) {
    return this._applyExtensions(bufferView, "loadBufferView", function(extension) {
      return extension.loadBufferViewAsync && extension.loadBufferViewAsync(context, bufferView);
    });
  };
  GLTFLoader3.prototype._extensionsLoadBufferAsync = function(context, buffer, byteOffset, byteLength) {
    return this._applyExtensions(buffer, "loadBuffer", function(extension) {
      return extension.loadBufferAsync && extension.loadBufferAsync(context, buffer, byteOffset, byteLength);
    });
  };
  GLTFLoader3.LoadExtensionAsync = function(context, property, extensionName, actionAsync) {
    if (!property.extensions) {
      return null;
    }
    var extensions = property.extensions;
    var extension = extensions[extensionName];
    if (!extension) {
      return null;
    }
    return actionAsync(context + "/extensions/" + extensionName, extension);
  };
  GLTFLoader3.LoadExtraAsync = function(context, property, extensionName, actionAsync) {
    if (!property.extras) {
      return null;
    }
    var extras = property.extras;
    var extra = extras[extensionName];
    if (!extra) {
      return null;
    }
    return actionAsync(context + "/extras/" + extensionName, extra);
  };
  GLTFLoader3.prototype.isExtensionUsed = function(name) {
    return !!this._gltf.extensionsUsed && this._gltf.extensionsUsed.indexOf(name) !== -1;
  };
  GLTFLoader3.prototype.logOpen = function(message) {
    this._parent._logOpen(message);
  };
  GLTFLoader3.prototype.logClose = function() {
    this._parent._logClose();
  };
  GLTFLoader3.prototype.log = function(message) {
    this._parent._log(message);
  };
  GLTFLoader3.prototype.startPerformanceCounter = function(counterName) {
    this._parent._startPerformanceCounter(counterName);
  };
  GLTFLoader3.prototype.endPerformanceCounter = function(counterName) {
    this._parent._endPerformanceCounter(counterName);
  };
  GLTFLoader3._RegisteredExtensions = {};
  GLTFLoader3.DefaultSampler = { index: -1 };
  return GLTFLoader3;
}();
GLTFFileLoader._CreateGLTF2Loader = function(parent) {
  return new GLTFLoader2(parent);
};

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/EXT_lights_image_based.js
var NAME = "EXT_lights_image_based";
var EXT_lights_image_based = function() {
  function EXT_lights_image_based2(loader) {
    this.name = NAME;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME);
  }
  EXT_lights_image_based2.prototype.dispose = function() {
    this._loader = null;
    delete this._lights;
  };
  EXT_lights_image_based2.prototype.onLoading = function() {
    var extensions = this._loader.gltf.extensions;
    if (extensions && extensions[this.name]) {
      var extension = extensions[this.name];
      this._lights = extension.lights;
    }
  };
  EXT_lights_image_based2.prototype.loadSceneAsync = function(context, scene) {
    var _this = this;
    return GLTFLoader2.LoadExtensionAsync(context, scene, this.name, function(extensionContext, extension) {
      var promises = new Array();
      promises.push(_this._loader.loadSceneAsync(context, scene));
      _this._loader.logOpen("" + extensionContext);
      var light = ArrayItem.Get(extensionContext + "/light", _this._lights, extension.light);
      promises.push(_this._loadLightAsync("/extensions/" + _this.name + "/lights/" + extension.light, light).then(function(texture) {
        _this._loader.babylonScene.environmentTexture = texture;
      }));
      _this._loader.logClose();
      return Promise.all(promises).then(function() {
      });
    });
  };
  EXT_lights_image_based2.prototype._loadLightAsync = function(context, light) {
    var _this = this;
    if (!light._loaded) {
      var promises = new Array();
      this._loader.logOpen("" + context);
      var imageData_1 = new Array(light.specularImages.length);
      var _loop_1 = function(mipmap2) {
        var faces = light.specularImages[mipmap2];
        imageData_1[mipmap2] = new Array(faces.length);
        var _loop_2 = function(face2) {
          var specularImageContext = context + "/specularImages/" + mipmap2 + "/" + face2;
          this_1._loader.logOpen("" + specularImageContext);
          var index = faces[face2];
          var image = ArrayItem.Get(specularImageContext, this_1._loader.gltf.images, index);
          promises.push(this_1._loader.loadImageAsync("/images/" + index, image).then(function(data) {
            imageData_1[mipmap2][face2] = data;
          }));
          this_1._loader.logClose();
        };
        for (var face = 0; face < faces.length; face++) {
          _loop_2(face);
        }
      };
      var this_1 = this;
      for (var mipmap = 0; mipmap < light.specularImages.length; mipmap++) {
        _loop_1(mipmap);
      }
      this._loader.logClose();
      light._loaded = Promise.all(promises).then(function() {
        var babylonTexture = new RawCubeTexture(_this._loader.babylonScene, null, light.specularImageSize);
        babylonTexture.name = light.name || "environment";
        light._babylonTexture = babylonTexture;
        if (light.intensity != void 0) {
          babylonTexture.level = light.intensity;
        }
        if (light.rotation) {
          var rotation = Quaternion.FromArray(light.rotation);
          if (!_this._loader.babylonScene.useRightHandedSystem) {
            rotation = Quaternion.Inverse(rotation);
          }
          Matrix.FromQuaternionToRef(rotation, babylonTexture.getReflectionTextureMatrix());
        }
        var sphericalHarmonics = SphericalHarmonics.FromArray(light.irradianceCoefficients);
        sphericalHarmonics.scaleInPlace(light.intensity);
        sphericalHarmonics.convertIrradianceToLambertianRadiance();
        var sphericalPolynomial = SphericalPolynomial.FromHarmonics(sphericalHarmonics);
        var lodGenerationScale = (imageData_1.length - 1) / Scalar.Log2(light.specularImageSize);
        return babylonTexture.updateRGBDAsync(imageData_1, sphericalPolynomial, lodGenerationScale);
      });
    }
    return light._loaded.then(function() {
      return light._babylonTexture;
    });
  };
  return EXT_lights_image_based2;
}();
GLTFLoader2.RegisterExtension(NAME, function(loader) {
  return new EXT_lights_image_based(loader);
});

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/EXT_mesh_gpu_instancing.js
var NAME2 = "EXT_mesh_gpu_instancing";
var EXT_mesh_gpu_instancing = function() {
  function EXT_mesh_gpu_instancing2(loader) {
    this.name = NAME2;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME2);
  }
  EXT_mesh_gpu_instancing2.prototype.dispose = function() {
    this._loader = null;
  };
  EXT_mesh_gpu_instancing2.prototype.loadNodeAsync = function(context, node, assign) {
    var _this = this;
    return GLTFLoader2.LoadExtensionAsync(context, node, this.name, function(extensionContext, extension) {
      _this._loader._disableInstancedMesh++;
      var promise = _this._loader.loadNodeAsync("/nodes/" + node.index, node, assign);
      _this._loader._disableInstancedMesh--;
      if (!node._primitiveBabylonMeshes) {
        return promise;
      }
      var promises = new Array();
      var instanceCount = 0;
      var loadAttribute = function(attribute) {
        if (extension.attributes[attribute] == void 0) {
          promises.push(Promise.resolve(null));
          return;
        }
        var accessor = ArrayItem.Get(extensionContext + "/attributes/" + attribute, _this._loader.gltf.accessors, extension.attributes[attribute]);
        promises.push(_this._loader._loadFloatAccessorAsync("/accessors/" + accessor.bufferView, accessor));
        if (instanceCount === 0) {
          instanceCount = accessor.count;
        } else if (instanceCount !== accessor.count) {
          throw new Error(extensionContext + "/attributes: Instance buffer accessors do not have the same count.");
        }
      };
      loadAttribute("TRANSLATION");
      loadAttribute("ROTATION");
      loadAttribute("SCALE");
      return promise.then(function(babylonTransformNode) {
        return Promise.all(promises).then(function(_a) {
          var translationBuffer = _a[0], rotationBuffer = _a[1], scaleBuffer = _a[2];
          var matrices = new Float32Array(instanceCount * 16);
          TmpVectors.Vector3[0].copyFromFloats(0, 0, 0);
          TmpVectors.Quaternion[0].copyFromFloats(0, 0, 0, 1);
          TmpVectors.Vector3[1].copyFromFloats(1, 1, 1);
          for (var i = 0; i < instanceCount; ++i) {
            translationBuffer && Vector3.FromArrayToRef(translationBuffer, i * 3, TmpVectors.Vector3[0]);
            rotationBuffer && Quaternion.FromArrayToRef(rotationBuffer, i * 4, TmpVectors.Quaternion[0]);
            scaleBuffer && Vector3.FromArrayToRef(scaleBuffer, i * 3, TmpVectors.Vector3[1]);
            Matrix.ComposeToRef(TmpVectors.Vector3[1], TmpVectors.Quaternion[0], TmpVectors.Vector3[0], TmpVectors.Matrix[0]);
            TmpVectors.Matrix[0].copyToArray(matrices, i * 16);
          }
          for (var _i = 0, _b = node._primitiveBabylonMeshes; _i < _b.length; _i++) {
            var babylonMesh = _b[_i];
            babylonMesh.thinInstanceSetBuffer("matrix", matrices, 16, true);
          }
          return babylonTransformNode;
        });
      });
    });
  };
  return EXT_mesh_gpu_instancing2;
}();
GLTFLoader2.RegisterExtension(NAME2, function(loader) {
  return new EXT_mesh_gpu_instancing(loader);
});

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/EXT_texture_webp.js
var NAME3 = "EXT_texture_webp";
var EXT_texture_webp = function() {
  function EXT_texture_webp2(loader) {
    this.name = NAME3;
    this._loader = loader;
    this.enabled = loader.isExtensionUsed(NAME3);
  }
  EXT_texture_webp2.prototype.dispose = function() {
    this._loader = null;
  };
  EXT_texture_webp2.prototype._loadTextureAsync = function(context, texture, assign) {
    var _this = this;
    return GLTFLoader2.LoadExtensionAsync(context, texture, this.name, function(extensionContext, extension) {
      var sampler = texture.sampler == void 0 ? GLTFLoader2.DefaultSampler : ArrayItem.Get(context + "/sampler", _this._loader.gltf.samplers, texture.sampler);
      var image = ArrayItem.Get(extensionContext + "/source", _this._loader.gltf.images, extension.source);
      return _this._loader._createTextureAsync(context, sampler, image, function(babylonTexture) {
        assign(babylonTexture);
      });
    });
  };
  return EXT_texture_webp2;
}();
GLTFLoader2.RegisterExtension(NAME3, function(loader) {
  return new EXT_texture_webp(loader);
});

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_draco_mesh_compression.js
var NAME4 = "KHR_draco_mesh_compression";
var KHR_draco_mesh_compression = function() {
  function KHR_draco_mesh_compression2(loader) {
    this.name = NAME4;
    this._loader = loader;
    this.enabled = DracoCompression.DecoderAvailable && this._loader.isExtensionUsed(NAME4);
  }
  KHR_draco_mesh_compression2.prototype.dispose = function() {
    delete this.dracoCompression;
    this._loader = null;
  };
  KHR_draco_mesh_compression2.prototype._loadVertexDataAsync = function(context, primitive, babylonMesh) {
    var _this = this;
    return GLTFLoader2.LoadExtensionAsync(context, primitive, this.name, function(extensionContext, extension) {
      if (primitive.mode != void 0) {
        if (primitive.mode !== 5 && primitive.mode !== 4) {
          throw new Error(context + ": Unsupported mode " + primitive.mode);
        }
        if (primitive.mode === 5) {
          throw new Error(context + ": Mode " + primitive.mode + " is not currently supported");
        }
      }
      var attributes = {};
      var loadAttribute = function(name, kind) {
        var uniqueId = extension.attributes[name];
        if (uniqueId == void 0) {
          return;
        }
        babylonMesh._delayInfo = babylonMesh._delayInfo || [];
        if (babylonMesh._delayInfo.indexOf(kind) === -1) {
          babylonMesh._delayInfo.push(kind);
        }
        attributes[kind] = uniqueId;
      };
      loadAttribute("POSITION", VertexBuffer.PositionKind);
      loadAttribute("NORMAL", VertexBuffer.NormalKind);
      loadAttribute("TANGENT", VertexBuffer.TangentKind);
      loadAttribute("TEXCOORD_0", VertexBuffer.UVKind);
      loadAttribute("TEXCOORD_1", VertexBuffer.UV2Kind);
      loadAttribute("JOINTS_0", VertexBuffer.MatricesIndicesKind);
      loadAttribute("WEIGHTS_0", VertexBuffer.MatricesWeightsKind);
      loadAttribute("COLOR_0", VertexBuffer.ColorKind);
      var bufferView = ArrayItem.Get(extensionContext, _this._loader.gltf.bufferViews, extension.bufferView);
      if (!bufferView._dracoBabylonGeometry) {
        bufferView._dracoBabylonGeometry = _this._loader.loadBufferViewAsync("/bufferViews/" + bufferView.index, bufferView).then(function(data) {
          var dracoCompression = _this.dracoCompression || DracoCompression.Default;
          return dracoCompression.decodeMeshAsync(data, attributes).then(function(babylonVertexData) {
            var babylonGeometry = new Geometry(babylonMesh.name, _this._loader.babylonScene);
            babylonVertexData.applyToGeometry(babylonGeometry);
            return babylonGeometry;
          }).catch(function(error) {
            throw new Error(context + ": " + error.message);
          });
        });
      }
      return bufferView._dracoBabylonGeometry;
    });
  };
  return KHR_draco_mesh_compression2;
}();
GLTFLoader2.RegisterExtension(NAME4, function(loader) {
  return new KHR_draco_mesh_compression(loader);
});

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_lights_punctual.js
var NAME5 = "KHR_lights_punctual";
var KHR_lights = function() {
  function KHR_lights2(loader) {
    this.name = NAME5;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME5);
  }
  KHR_lights2.prototype.dispose = function() {
    this._loader = null;
    delete this._lights;
  };
  KHR_lights2.prototype.onLoading = function() {
    var extensions = this._loader.gltf.extensions;
    if (extensions && extensions[this.name]) {
      var extension = extensions[this.name];
      this._lights = extension.lights;
    }
  };
  KHR_lights2.prototype.loadNodeAsync = function(context, node, assign) {
    var _this = this;
    return GLTFLoader2.LoadExtensionAsync(context, node, this.name, function(extensionContext, extension) {
      return _this._loader.loadNodeAsync(context, node, function(babylonMesh) {
        var babylonLight;
        var light = ArrayItem.Get(extensionContext, _this._lights, extension.light);
        var name = light.name || babylonMesh.name;
        _this._loader.babylonScene._blockEntityCollection = _this._loader._forAssetContainer;
        switch (light.type) {
          case "directional": {
            babylonLight = new DirectionalLight(name, Vector3.Backward(), _this._loader.babylonScene);
            break;
          }
          case "point": {
            babylonLight = new PointLight(name, Vector3.Zero(), _this._loader.babylonScene);
            break;
          }
          case "spot": {
            var babylonSpotLight = new SpotLight(name, Vector3.Zero(), Vector3.Backward(), 0, 1, _this._loader.babylonScene);
            babylonSpotLight.angle = (light.spot && light.spot.outerConeAngle || Math.PI / 4) * 2;
            babylonSpotLight.innerAngle = (light.spot && light.spot.innerConeAngle || 0) * 2;
            babylonLight = babylonSpotLight;
            break;
          }
          default: {
            _this._loader.babylonScene._blockEntityCollection = false;
            throw new Error(extensionContext + ": Invalid light type (" + light.type + ")");
          }
        }
        _this._loader.babylonScene._blockEntityCollection = false;
        babylonLight.falloffType = Light.FALLOFF_GLTF;
        babylonLight.diffuse = light.color ? Color3.FromArray(light.color) : Color3.White();
        babylonLight.intensity = light.intensity == void 0 ? 1 : light.intensity;
        babylonLight.range = light.range == void 0 ? Number.MAX_VALUE : light.range;
        babylonLight.parent = babylonMesh;
        _this._loader._babylonLights.push(babylonLight);
        GLTFLoader2.AddPointerMetadata(babylonLight, extensionContext);
        assign(babylonMesh);
      });
    });
  };
  return KHR_lights2;
}();
GLTFLoader2.RegisterExtension(NAME5, function(loader) {
  return new KHR_lights(loader);
});

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_pbrSpecularGlossiness.js
var NAME6 = "KHR_materials_pbrSpecularGlossiness";
var KHR_materials_pbrSpecularGlossiness = function() {
  function KHR_materials_pbrSpecularGlossiness2(loader) {
    this.name = NAME6;
    this.order = 200;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME6);
  }
  KHR_materials_pbrSpecularGlossiness2.prototype.dispose = function() {
    this._loader = null;
  };
  KHR_materials_pbrSpecularGlossiness2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
    var _this = this;
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
      var promises = new Array();
      promises.push(_this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));
      promises.push(_this._loadSpecularGlossinessPropertiesAsync(extensionContext, material, extension, babylonMaterial));
      _this._loader.loadMaterialAlphaProperties(context, material, babylonMaterial);
      return Promise.all(promises).then(function() {
      });
    });
  };
  KHR_materials_pbrSpecularGlossiness2.prototype._loadSpecularGlossinessPropertiesAsync = function(context, material, properties, babylonMaterial) {
    if (!(babylonMaterial instanceof PBRMaterial)) {
      throw new Error(context + ": Material type not supported");
    }
    var promises = new Array();
    babylonMaterial.metallic = null;
    babylonMaterial.roughness = null;
    if (properties.diffuseFactor) {
      babylonMaterial.albedoColor = Color3.FromArray(properties.diffuseFactor);
      babylonMaterial.alpha = properties.diffuseFactor[3];
    } else {
      babylonMaterial.albedoColor = Color3.White();
    }
    babylonMaterial.reflectivityColor = properties.specularFactor ? Color3.FromArray(properties.specularFactor) : Color3.White();
    babylonMaterial.microSurface = properties.glossinessFactor == void 0 ? 1 : properties.glossinessFactor;
    if (properties.diffuseTexture) {
      promises.push(this._loader.loadTextureInfoAsync(context + "/diffuseTexture", properties.diffuseTexture, function(texture) {
        texture.name = babylonMaterial.name + " (Diffuse)";
        babylonMaterial.albedoTexture = texture;
      }));
    }
    if (properties.specularGlossinessTexture) {
      properties.specularGlossinessTexture.nonColorData = true;
      promises.push(this._loader.loadTextureInfoAsync(context + "/specularGlossinessTexture", properties.specularGlossinessTexture, function(texture) {
        texture.name = babylonMaterial.name + " (Specular Glossiness)";
        babylonMaterial.reflectivityTexture = texture;
      }));
      babylonMaterial.reflectivityTexture.hasAlpha = true;
      babylonMaterial.useMicroSurfaceFromReflectivityMapAlpha = true;
    }
    return Promise.all(promises).then(function() {
    });
  };
  return KHR_materials_pbrSpecularGlossiness2;
}();
GLTFLoader2.RegisterExtension(NAME6, function(loader) {
  return new KHR_materials_pbrSpecularGlossiness(loader);
});

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_unlit.js
var NAME7 = "KHR_materials_unlit";
var KHR_materials_unlit = function() {
  function KHR_materials_unlit2(loader) {
    this.name = NAME7;
    this.order = 210;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME7);
  }
  KHR_materials_unlit2.prototype.dispose = function() {
    this._loader = null;
  };
  KHR_materials_unlit2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
    var _this = this;
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, function() {
      return _this._loadUnlitPropertiesAsync(context, material, babylonMaterial);
    });
  };
  KHR_materials_unlit2.prototype._loadUnlitPropertiesAsync = function(context, material, babylonMaterial) {
    if (!(babylonMaterial instanceof PBRMaterial)) {
      throw new Error(context + ": Material type not supported");
    }
    var promises = new Array();
    babylonMaterial.unlit = true;
    var properties = material.pbrMetallicRoughness;
    if (properties) {
      if (properties.baseColorFactor) {
        babylonMaterial.albedoColor = Color3.FromArray(properties.baseColorFactor);
        babylonMaterial.alpha = properties.baseColorFactor[3];
      } else {
        babylonMaterial.albedoColor = Color3.White();
      }
      if (properties.baseColorTexture) {
        promises.push(this._loader.loadTextureInfoAsync(context + "/baseColorTexture", properties.baseColorTexture, function(texture) {
          texture.name = babylonMaterial.name + " (Base Color)";
          babylonMaterial.albedoTexture = texture;
        }));
      }
    }
    if (material.doubleSided) {
      babylonMaterial.backFaceCulling = false;
      babylonMaterial.twoSidedLighting = true;
    }
    this._loader.loadMaterialAlphaProperties(context, material, babylonMaterial);
    return Promise.all(promises).then(function() {
    });
  };
  return KHR_materials_unlit2;
}();
GLTFLoader2.RegisterExtension(NAME7, function(loader) {
  return new KHR_materials_unlit(loader);
});

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_clearcoat.js
var NAME8 = "KHR_materials_clearcoat";
var KHR_materials_clearcoat = function() {
  function KHR_materials_clearcoat2(loader) {
    this.name = NAME8;
    this.order = 190;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME8);
  }
  KHR_materials_clearcoat2.prototype.dispose = function() {
    this._loader = null;
  };
  KHR_materials_clearcoat2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
    var _this = this;
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
      var promises = new Array();
      promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
      promises.push(_this._loadClearCoatPropertiesAsync(extensionContext, extension, babylonMaterial));
      return Promise.all(promises).then(function() {
      });
    });
  };
  KHR_materials_clearcoat2.prototype._loadClearCoatPropertiesAsync = function(context, properties, babylonMaterial) {
    if (!(babylonMaterial instanceof PBRMaterial)) {
      throw new Error(context + ": Material type not supported");
    }
    var promises = new Array();
    babylonMaterial.clearCoat.isEnabled = true;
    babylonMaterial.clearCoat.useRoughnessFromMainTexture = false;
    babylonMaterial.clearCoat.remapF0OnInterfaceChange = false;
    if (properties.clearcoatFactor != void 0) {
      babylonMaterial.clearCoat.intensity = properties.clearcoatFactor;
    } else {
      babylonMaterial.clearCoat.intensity = 0;
    }
    if (properties.clearcoatTexture) {
      promises.push(this._loader.loadTextureInfoAsync(context + "/clearcoatTexture", properties.clearcoatTexture, function(texture) {
        texture.name = babylonMaterial.name + " (ClearCoat Intensity)";
        babylonMaterial.clearCoat.texture = texture;
      }));
    }
    if (properties.clearcoatRoughnessFactor != void 0) {
      babylonMaterial.clearCoat.roughness = properties.clearcoatRoughnessFactor;
    } else {
      babylonMaterial.clearCoat.roughness = 0;
    }
    if (properties.clearcoatRoughnessTexture) {
      properties.clearcoatRoughnessTexture.nonColorData = true;
      promises.push(this._loader.loadTextureInfoAsync(context + "/clearcoatRoughnessTexture", properties.clearcoatRoughnessTexture, function(texture) {
        texture.name = babylonMaterial.name + " (ClearCoat Roughness)";
        babylonMaterial.clearCoat.textureRoughness = texture;
      }));
    }
    if (properties.clearcoatNormalTexture) {
      properties.clearcoatNormalTexture.nonColorData = true;
      promises.push(this._loader.loadTextureInfoAsync(context + "/clearcoatNormalTexture", properties.clearcoatNormalTexture, function(texture) {
        texture.name = babylonMaterial.name + " (ClearCoat Normal)";
        babylonMaterial.clearCoat.bumpTexture = texture;
      }));
      babylonMaterial.invertNormalMapX = !babylonMaterial.getScene().useRightHandedSystem;
      babylonMaterial.invertNormalMapY = babylonMaterial.getScene().useRightHandedSystem;
      if (properties.clearcoatNormalTexture.scale != void 0) {
        babylonMaterial.clearCoat.bumpTexture.level = properties.clearcoatNormalTexture.scale;
      }
    }
    return Promise.all(promises).then(function() {
    });
  };
  return KHR_materials_clearcoat2;
}();
GLTFLoader2.RegisterExtension(NAME8, function(loader) {
  return new KHR_materials_clearcoat(loader);
});

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_sheen.js
var NAME9 = "KHR_materials_sheen";
var KHR_materials_sheen = function() {
  function KHR_materials_sheen2(loader) {
    this.name = NAME9;
    this.order = 190;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME9);
  }
  KHR_materials_sheen2.prototype.dispose = function() {
    this._loader = null;
  };
  KHR_materials_sheen2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
    var _this = this;
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
      var promises = new Array();
      promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
      promises.push(_this._loadSheenPropertiesAsync(extensionContext, extension, babylonMaterial));
      return Promise.all(promises).then(function() {
      });
    });
  };
  KHR_materials_sheen2.prototype._loadSheenPropertiesAsync = function(context, properties, babylonMaterial) {
    if (!(babylonMaterial instanceof PBRMaterial)) {
      throw new Error(context + ": Material type not supported");
    }
    var promises = new Array();
    babylonMaterial.sheen.isEnabled = true;
    babylonMaterial.sheen.intensity = 1;
    if (properties.sheenColorFactor != void 0) {
      babylonMaterial.sheen.color = Color3.FromArray(properties.sheenColorFactor);
    } else {
      babylonMaterial.sheen.color = Color3.Black();
    }
    if (properties.sheenColorTexture) {
      promises.push(this._loader.loadTextureInfoAsync(context + "/sheenColorTexture", properties.sheenColorTexture, function(texture) {
        texture.name = babylonMaterial.name + " (Sheen Color)";
        babylonMaterial.sheen.texture = texture;
      }));
    }
    if (properties.sheenRoughnessFactor !== void 0) {
      babylonMaterial.sheen.roughness = properties.sheenRoughnessFactor;
    } else {
      babylonMaterial.sheen.roughness = 0;
    }
    if (properties.sheenRoughnessTexture) {
      properties.sheenRoughnessTexture.nonColorData = true;
      promises.push(this._loader.loadTextureInfoAsync(context + "/sheenRoughnessTexture", properties.sheenRoughnessTexture, function(texture) {
        texture.name = babylonMaterial.name + " (Sheen Roughness)";
        babylonMaterial.sheen.textureRoughness = texture;
      }));
    }
    babylonMaterial.sheen.albedoScaling = true;
    babylonMaterial.sheen.useRoughnessFromMainTexture = false;
    return Promise.all(promises).then(function() {
    });
  };
  return KHR_materials_sheen2;
}();
GLTFLoader2.RegisterExtension(NAME9, function(loader) {
  return new KHR_materials_sheen(loader);
});

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_specular.js
var NAME10 = "KHR_materials_specular";
var KHR_materials_specular = function() {
  function KHR_materials_specular2(loader) {
    this.name = NAME10;
    this.order = 190;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME10);
  }
  KHR_materials_specular2.prototype.dispose = function() {
    this._loader = null;
  };
  KHR_materials_specular2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
    var _this = this;
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
      var promises = new Array();
      promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
      promises.push(_this._loadSpecularPropertiesAsync(extensionContext, extension, babylonMaterial));
      return Promise.all(promises).then(function() {
      });
    });
  };
  KHR_materials_specular2.prototype._loadSpecularPropertiesAsync = function(context, properties, babylonMaterial) {
    if (!(babylonMaterial instanceof PBRMaterial)) {
      throw new Error(context + ": Material type not supported");
    }
    var promises = new Array();
    if (properties.specularFactor !== void 0) {
      babylonMaterial.metallicF0Factor = properties.specularFactor;
    }
    if (properties.specularColorFactor !== void 0) {
      babylonMaterial.metallicReflectanceColor = Color3.FromArray(properties.specularColorFactor);
    }
    if (properties.specularTexture) {
      properties.specularTexture.nonColorData = true;
      promises.push(this._loader.loadTextureInfoAsync(context + "/specularTexture", properties.specularTexture, function(texture) {
        texture.name = babylonMaterial.name + " (Specular F0 Color)";
        babylonMaterial.metallicReflectanceTexture = texture;
      }));
    }
    return Promise.all(promises).then(function() {
    });
  };
  return KHR_materials_specular2;
}();
GLTFLoader2.RegisterExtension(NAME10, function(loader) {
  return new KHR_materials_specular(loader);
});

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_ior.js
var NAME11 = "KHR_materials_ior";
var KHR_materials_ior = function() {
  function KHR_materials_ior2(loader) {
    this.name = NAME11;
    this.order = 180;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME11);
  }
  KHR_materials_ior2.prototype.dispose = function() {
    this._loader = null;
  };
  KHR_materials_ior2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
    var _this = this;
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
      var promises = new Array();
      promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
      promises.push(_this._loadIorPropertiesAsync(extensionContext, extension, babylonMaterial));
      return Promise.all(promises).then(function() {
      });
    });
  };
  KHR_materials_ior2.prototype._loadIorPropertiesAsync = function(context, properties, babylonMaterial) {
    if (!(babylonMaterial instanceof PBRMaterial)) {
      throw new Error(context + ": Material type not supported");
    }
    if (properties.ior !== void 0) {
      babylonMaterial.indexOfRefraction = properties.ior;
    } else {
      babylonMaterial.indexOfRefraction = KHR_materials_ior2._DEFAULT_IOR;
    }
    return Promise.resolve();
  };
  KHR_materials_ior2._DEFAULT_IOR = 1.5;
  return KHR_materials_ior2;
}();
GLTFLoader2.RegisterExtension(NAME11, function(loader) {
  return new KHR_materials_ior(loader);
});

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_variants.js
var NAME12 = "KHR_materials_variants";
var KHR_materials_variants = function() {
  function KHR_materials_variants2(loader) {
    this.name = NAME12;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME12);
  }
  KHR_materials_variants2.prototype.dispose = function() {
    this._loader = null;
  };
  KHR_materials_variants2.GetAvailableVariants = function(rootMesh) {
    var extensionMetadata = this._GetExtensionMetadata(rootMesh);
    if (!extensionMetadata) {
      return [];
    }
    return Object.keys(extensionMetadata.variants);
  };
  KHR_materials_variants2.prototype.getAvailableVariants = function(rootMesh) {
    return KHR_materials_variants2.GetAvailableVariants(rootMesh);
  };
  KHR_materials_variants2.SelectVariant = function(rootMesh, variantName) {
    var extensionMetadata = this._GetExtensionMetadata(rootMesh);
    if (!extensionMetadata) {
      throw new Error("Cannot select variant on a glTF mesh that does not have the " + NAME12 + " extension");
    }
    var select = function(variantName2) {
      var entries = extensionMetadata.variants[variantName2];
      if (entries) {
        for (var _i2 = 0, entries_1 = entries; _i2 < entries_1.length; _i2++) {
          var entry = entries_1[_i2];
          entry.mesh.material = entry.material;
        }
      }
    };
    if (variantName instanceof Array) {
      for (var _i = 0, variantName_1 = variantName; _i < variantName_1.length; _i++) {
        var name_1 = variantName_1[_i];
        select(name_1);
      }
    } else {
      select(variantName);
    }
    extensionMetadata.lastSelected = variantName;
  };
  KHR_materials_variants2.prototype.selectVariant = function(rootMesh, variantName) {
    return KHR_materials_variants2.SelectVariant(rootMesh, variantName);
  };
  KHR_materials_variants2.Reset = function(rootMesh) {
    var extensionMetadata = this._GetExtensionMetadata(rootMesh);
    if (!extensionMetadata) {
      throw new Error("Cannot reset on a glTF mesh that does not have the " + NAME12 + " extension");
    }
    for (var _i = 0, _a = extensionMetadata.original; _i < _a.length; _i++) {
      var entry = _a[_i];
      entry.mesh.material = entry.material;
    }
    extensionMetadata.lastSelected = null;
  };
  KHR_materials_variants2.prototype.reset = function(rootMesh) {
    return KHR_materials_variants2.Reset(rootMesh);
  };
  KHR_materials_variants2.GetLastSelectedVariant = function(rootMesh) {
    var extensionMetadata = this._GetExtensionMetadata(rootMesh);
    if (!extensionMetadata) {
      throw new Error("Cannot get the last selected variant on a glTF mesh that does not have the " + NAME12 + " extension");
    }
    return extensionMetadata.lastSelected;
  };
  KHR_materials_variants2.prototype.getLastSelectedVariant = function(rootMesh) {
    return KHR_materials_variants2.GetLastSelectedVariant(rootMesh);
  };
  KHR_materials_variants2._GetExtensionMetadata = function(rootMesh) {
    var _a, _b;
    return ((_b = (_a = rootMesh === null || rootMesh === void 0 ? void 0 : rootMesh.metadata) === null || _a === void 0 ? void 0 : _a.gltf) === null || _b === void 0 ? void 0 : _b[NAME12]) || null;
  };
  KHR_materials_variants2.prototype.onLoading = function() {
    var extensions = this._loader.gltf.extensions;
    if (extensions && extensions[this.name]) {
      var extension = extensions[this.name];
      this._variants = extension.variants;
    }
  };
  KHR_materials_variants2.prototype._loadMeshPrimitiveAsync = function(context, name, node, mesh, primitive, assign) {
    var _this = this;
    return GLTFLoader2.LoadExtensionAsync(context, primitive, this.name, function(extensionContext, extension) {
      var promises = new Array();
      promises.push(_this._loader._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, function(babylonMesh) {
        assign(babylonMesh);
        if (babylonMesh instanceof Mesh) {
          var babylonDrawMode = GLTFLoader2._GetDrawMode(context, primitive.mode);
          var root = _this._loader.rootBabylonMesh;
          var metadata = root.metadata = root.metadata || {};
          var gltf = metadata.gltf = metadata.gltf || {};
          var extensionMetadata = gltf[NAME12] = gltf[NAME12] || { lastSelected: null, original: [], variants: {} };
          extensionMetadata.original.push({ mesh: babylonMesh, material: babylonMesh.material });
          var variants_1 = extensionMetadata.variants;
          for (var _i = 0, _a = extension.mappings; _i < _a.length; _i++) {
            var mapping = _a[_i];
            var _loop_1 = function(variantIndex2) {
              var variant = ArrayItem.Get(extensionContext + "/mapping/" + variantIndex2, _this._variants, variantIndex2);
              var material = ArrayItem.Get("#/materials/", _this._loader.gltf.materials, mapping.material);
              promises.push(_this._loader._loadMaterialAsync("#/materials/" + mapping.material, material, babylonMesh, babylonDrawMode, function(babylonMaterial) {
                variants_1[variant.name] = variants_1[variant.name] || [];
                variants_1[variant.name].push({
                  mesh: babylonMesh,
                  material: babylonMaterial
                });
              }));
            };
            for (var _b = 0, _c = mapping.variants; _b < _c.length; _b++) {
              var variantIndex = _c[_b];
              _loop_1(variantIndex);
            }
          }
        }
      }));
      return Promise.all(promises).then(function(_a) {
        var babylonMesh = _a[0];
        return babylonMesh;
      });
    });
  };
  return KHR_materials_variants2;
}();
GLTFLoader2.RegisterExtension(NAME12, function(loader) {
  return new KHR_materials_variants(loader);
});

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_transmission.js
var TransmissionHelper = function() {
  function TransmissionHelper2(options, scene) {
    var _this = this;
    this._opaqueRenderTarget = null;
    this._opaqueMeshesCache = [];
    this._transparentMeshesCache = [];
    this._options = __assign(__assign({}, TransmissionHelper2._getDefaultOptions()), options);
    this._scene = scene;
    this._scene._transmissionHelper = this;
    this.onErrorObservable = new Observable();
    this._scene.onDisposeObservable.addOnce(function(scene2) {
      _this.dispose();
    });
    this._parseScene();
    this._setupRenderTargets();
  }
  TransmissionHelper2._getDefaultOptions = function() {
    return {
      renderSize: 512
    };
  };
  TransmissionHelper2.prototype.updateOptions = function(options) {
    var _this = this;
    var newValues = Object.keys(options).filter(function(key) {
      return _this._options[key] !== options[key];
    });
    if (!newValues.length) {
      return;
    }
    var newOptions = __assign(__assign({}, this._options), options);
    var oldOptions = this._options;
    this._options = newOptions;
    if (newOptions.renderSize !== oldOptions.renderSize) {
      this._setupRenderTargets();
    }
  };
  TransmissionHelper2.prototype.getOpaqueTarget = function() {
    return this._opaqueRenderTarget;
  };
  TransmissionHelper2.prototype.shouldRenderAsTransmission = function(material) {
    if (!material) {
      return false;
    }
    if (material instanceof PBRMaterial && material.subSurface.isRefractionEnabled) {
      return true;
    }
    return false;
  };
  TransmissionHelper2.prototype._addMesh = function(mesh) {
    if (mesh instanceof Mesh) {
      mesh.onMaterialChangedObservable.add(this.onMeshMaterialChanged.bind(this));
      if (this.shouldRenderAsTransmission(mesh.material)) {
        this._transparentMeshesCache.push(mesh);
      } else {
        this._opaqueMeshesCache.push(mesh);
      }
    }
  };
  TransmissionHelper2.prototype._removeMesh = function(mesh) {
    if (mesh instanceof Mesh) {
      mesh.onMaterialChangedObservable.remove(this.onMeshMaterialChanged.bind(this));
      var idx = this._transparentMeshesCache.indexOf(mesh);
      if (idx !== -1) {
        this._transparentMeshesCache.splice(idx, 1);
      }
      idx = this._opaqueMeshesCache.indexOf(mesh);
      if (idx !== -1) {
        this._opaqueMeshesCache.splice(idx, 1);
      }
    }
  };
  TransmissionHelper2.prototype._parseScene = function() {
    this._scene.meshes.forEach(this._addMesh.bind(this));
    this._scene.onNewMeshAddedObservable.add(this._addMesh.bind(this));
    this._scene.onMeshRemovedObservable.add(this._removeMesh.bind(this));
  };
  TransmissionHelper2.prototype.onMeshMaterialChanged = function(mesh) {
    if (mesh instanceof Mesh) {
      var transparentIdx = this._transparentMeshesCache.indexOf(mesh);
      var opaqueIdx = this._opaqueMeshesCache.indexOf(mesh);
      var useTransmission = this.shouldRenderAsTransmission(mesh.material);
      if (useTransmission) {
        if (mesh.material instanceof PBRMaterial) {
          mesh.material.subSurface.refractionTexture = this._opaqueRenderTarget;
        }
        if (opaqueIdx !== -1) {
          this._opaqueMeshesCache.splice(opaqueIdx, 1);
          this._transparentMeshesCache.push(mesh);
        } else if (transparentIdx === -1) {
          this._transparentMeshesCache.push(mesh);
        }
      } else {
        if (transparentIdx !== -1) {
          this._transparentMeshesCache.splice(transparentIdx, 1);
          this._opaqueMeshesCache.push(mesh);
        } else if (opaqueIdx === -1) {
          this._opaqueMeshesCache.push(mesh);
        }
      }
    }
  };
  TransmissionHelper2.prototype._setupRenderTargets = function() {
    var _this = this;
    var opaqueRTIndex = -1;
    if (this._scene.layers && this._opaqueRenderTarget) {
      for (var _i = 0, _a = this._scene.layers; _i < _a.length; _i++) {
        var layer = _a[_i];
        var idx = layer.renderTargetTextures.indexOf(this._opaqueRenderTarget);
        if (idx >= 0) {
          layer.renderTargetTextures.splice(idx, 1);
        }
      }
    }
    if (this._opaqueRenderTarget) {
      opaqueRTIndex = this._scene.customRenderTargets.indexOf(this._opaqueRenderTarget);
      this._opaqueRenderTarget.dispose();
    }
    this._opaqueRenderTarget = new RenderTargetTexture("opaqueSceneTexture", this._options.renderSize, this._scene, true);
    this._opaqueRenderTarget.renderList = this._opaqueMeshesCache;
    this._opaqueRenderTarget.gammaSpace = true;
    this._opaqueRenderTarget.lodGenerationScale = 1;
    this._opaqueRenderTarget.lodGenerationOffset = -4;
    if (opaqueRTIndex >= 0) {
      this._scene.customRenderTargets.splice(opaqueRTIndex, 0, this._opaqueRenderTarget);
    } else {
      opaqueRTIndex = this._scene.customRenderTargets.length;
      this._scene.customRenderTargets.push(this._opaqueRenderTarget);
    }
    if (this._scene.layers && this._opaqueRenderTarget) {
      for (var _b = 0, _c = this._scene.layers; _b < _c.length; _b++) {
        var layer = _c[_b];
        layer.renderTargetTextures.push(this._opaqueRenderTarget);
      }
    }
    this._transparentMeshesCache.forEach(function(mesh) {
      if (_this.shouldRenderAsTransmission(mesh.material) && mesh.material instanceof PBRMaterial) {
        mesh.material.refractionTexture = _this._opaqueRenderTarget;
      }
    });
  };
  TransmissionHelper2.prototype.dispose = function() {
    this._scene._transmissionHelper = void 0;
    if (this._opaqueRenderTarget) {
      this._opaqueRenderTarget.dispose();
      this._opaqueRenderTarget = null;
    }
    this._transparentMeshesCache = [];
    this._opaqueMeshesCache = [];
  };
  return TransmissionHelper2;
}();
var NAME13 = "KHR_materials_transmission";
var KHR_materials_transmission = function() {
  function KHR_materials_transmission2(loader) {
    this.name = NAME13;
    this.order = 175;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME13);
    if (this.enabled) {
      loader.parent.transparencyAsCoverage = true;
    }
  }
  KHR_materials_transmission2.prototype.dispose = function() {
    this._loader = null;
  };
  KHR_materials_transmission2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
    var _this = this;
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
      var promises = new Array();
      promises.push(_this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));
      promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
      promises.push(_this._loadTransparentPropertiesAsync(extensionContext, material, babylonMaterial, extension));
      return Promise.all(promises).then(function() {
      });
    });
  };
  KHR_materials_transmission2.prototype._loadTransparentPropertiesAsync = function(context, material, babylonMaterial, extension) {
    if (!(babylonMaterial instanceof PBRMaterial)) {
      throw new Error(context + ": Material type not supported");
    }
    var pbrMaterial = babylonMaterial;
    pbrMaterial.subSurface.isRefractionEnabled = true;
    pbrMaterial.subSurface.volumeIndexOfRefraction = 1;
    pbrMaterial.subSurface.useAlbedoToTintRefraction = true;
    if (extension.transmissionFactor !== void 0) {
      pbrMaterial.subSurface.refractionIntensity = extension.transmissionFactor;
      var scene = pbrMaterial.getScene();
      if (pbrMaterial.subSurface.refractionIntensity && !scene._transmissionHelper) {
        new TransmissionHelper({}, pbrMaterial.getScene());
      }
    } else {
      pbrMaterial.subSurface.refractionIntensity = 0;
      pbrMaterial.subSurface.isRefractionEnabled = false;
      return Promise.resolve();
    }
    if (extension.transmissionTexture) {
      extension.transmissionTexture.nonColorData = true;
      return this._loader.loadTextureInfoAsync(context + "/transmissionTexture", extension.transmissionTexture, void 0).then(function(texture) {
        pbrMaterial.subSurface.thicknessTexture = texture;
        pbrMaterial.subSurface.useMaskFromThicknessTextureGltf = true;
      });
    } else {
      return Promise.resolve();
    }
  };
  return KHR_materials_transmission2;
}();
GLTFLoader2.RegisterExtension(NAME13, function(loader) {
  return new KHR_materials_transmission(loader);
});

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_translucency.js
var NAME14 = "KHR_materials_translucency";
var KHR_materials_translucency = function() {
  function KHR_materials_translucency2(loader) {
    this.name = NAME14;
    this.order = 175;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME14);
    if (this.enabled) {
      loader.parent.transparencyAsCoverage = true;
    }
  }
  KHR_materials_translucency2.prototype.dispose = function() {
    this._loader = null;
  };
  KHR_materials_translucency2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
    var _this = this;
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
      var promises = new Array();
      promises.push(_this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));
      promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
      promises.push(_this._loadTranslucentPropertiesAsync(extensionContext, material, babylonMaterial, extension));
      return Promise.all(promises).then(function() {
      });
    });
  };
  KHR_materials_translucency2.prototype._loadTranslucentPropertiesAsync = function(context, material, babylonMaterial, extension) {
    if (!(babylonMaterial instanceof PBRMaterial)) {
      throw new Error(context + ": Material type not supported");
    }
    var pbrMaterial = babylonMaterial;
    pbrMaterial.subSurface.isTranslucencyEnabled = true;
    pbrMaterial.subSurface.volumeIndexOfRefraction = 1;
    pbrMaterial.subSurface.minimumThickness = 0;
    pbrMaterial.subSurface.maximumThickness = 0;
    pbrMaterial.subSurface.useAlbedoToTintRefraction = true;
    if (extension.translucencyFactor !== void 0) {
      pbrMaterial.subSurface.translucencyIntensity = extension.translucencyFactor;
    } else {
      pbrMaterial.subSurface.translucencyIntensity = 0;
      pbrMaterial.subSurface.isTranslucencyEnabled = false;
      return Promise.resolve();
    }
    if (extension.translucencyTexture) {
      return this._loader.loadTextureInfoAsync(context + "/translucencyTexture", extension.translucencyTexture).then(function(texture) {
        pbrMaterial.subSurface.thicknessTexture = texture;
        pbrMaterial.subSurface.useMaskFromThicknessTextureGltf = true;
      });
    } else {
      return Promise.resolve();
    }
  };
  return KHR_materials_translucency2;
}();
GLTFLoader2.RegisterExtension(NAME14, function(loader) {
  return new KHR_materials_translucency(loader);
});

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_mesh_quantization.js
var NAME15 = "KHR_mesh_quantization";
var KHR_mesh_quantization = function() {
  function KHR_mesh_quantization2(loader) {
    this.name = NAME15;
    this.enabled = loader.isExtensionUsed(NAME15);
  }
  KHR_mesh_quantization2.prototype.dispose = function() {
  };
  return KHR_mesh_quantization2;
}();
GLTFLoader2.RegisterExtension(NAME15, function(loader) {
  return new KHR_mesh_quantization(loader);
});

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_texture_basisu.js
var NAME16 = "KHR_texture_basisu";
var KHR_texture_basisu = function() {
  function KHR_texture_basisu2(loader) {
    this.name = NAME16;
    this._loader = loader;
    this.enabled = loader.isExtensionUsed(NAME16);
  }
  KHR_texture_basisu2.prototype.dispose = function() {
    this._loader = null;
  };
  KHR_texture_basisu2.prototype._loadTextureAsync = function(context, texture, assign) {
    var _this = this;
    return GLTFLoader2.LoadExtensionAsync(context, texture, this.name, function(extensionContext, extension) {
      var sampler = texture.sampler == void 0 ? GLTFLoader2.DefaultSampler : ArrayItem.Get(context + "/sampler", _this._loader.gltf.samplers, texture.sampler);
      var image = ArrayItem.Get(extensionContext + "/source", _this._loader.gltf.images, extension.source);
      return _this._loader._createTextureAsync(context, sampler, image, function(babylonTexture) {
        assign(babylonTexture);
      }, texture._textureInfo.nonColorData ? { useRGBAIfASTCBC7NotAvailableWhenUASTC: true } : void 0);
    });
  };
  return KHR_texture_basisu2;
}();
GLTFLoader2.RegisterExtension(NAME16, function(loader) {
  return new KHR_texture_basisu(loader);
});

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_texture_transform.js
var NAME17 = "KHR_texture_transform";
var KHR_texture_transform = function() {
  function KHR_texture_transform2(loader) {
    this.name = NAME17;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME17);
  }
  KHR_texture_transform2.prototype.dispose = function() {
    this._loader = null;
  };
  KHR_texture_transform2.prototype.loadTextureInfoAsync = function(context, textureInfo, assign) {
    var _this = this;
    return GLTFLoader2.LoadExtensionAsync(context, textureInfo, this.name, function(extensionContext, extension) {
      return _this._loader.loadTextureInfoAsync(context, textureInfo, function(babylonTexture) {
        if (!(babylonTexture instanceof Texture)) {
          throw new Error(extensionContext + ": Texture type not supported");
        }
        if (extension.offset) {
          babylonTexture.uOffset = extension.offset[0];
          babylonTexture.vOffset = extension.offset[1];
        }
        babylonTexture.uRotationCenter = 0;
        babylonTexture.vRotationCenter = 0;
        if (extension.rotation) {
          babylonTexture.wAng = -extension.rotation;
        }
        if (extension.scale) {
          babylonTexture.uScale = extension.scale[0];
          babylonTexture.vScale = extension.scale[1];
        }
        if (extension.texCoord != void 0) {
          babylonTexture.coordinatesIndex = extension.texCoord;
        }
        assign(babylonTexture);
      });
    });
  };
  return KHR_texture_transform2;
}();
GLTFLoader2.RegisterExtension(NAME17, function(loader) {
  return new KHR_texture_transform(loader);
});

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/MSFT_audio_emitter.js
var NAME18 = "MSFT_audio_emitter";
var MSFT_audio_emitter = function() {
  function MSFT_audio_emitter2(loader) {
    this.name = NAME18;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME18);
  }
  MSFT_audio_emitter2.prototype.dispose = function() {
    this._loader = null;
    this._clips = null;
    this._emitters = null;
  };
  MSFT_audio_emitter2.prototype.onLoading = function() {
    var extensions = this._loader.gltf.extensions;
    if (extensions && extensions[this.name]) {
      var extension = extensions[this.name];
      this._clips = extension.clips;
      this._emitters = extension.emitters;
      ArrayItem.Assign(this._clips);
      ArrayItem.Assign(this._emitters);
    }
  };
  MSFT_audio_emitter2.prototype.loadSceneAsync = function(context, scene) {
    var _this = this;
    return GLTFLoader2.LoadExtensionAsync(context, scene, this.name, function(extensionContext, extension) {
      var promises = new Array();
      promises.push(_this._loader.loadSceneAsync(context, scene));
      for (var _i = 0, _a = extension.emitters; _i < _a.length; _i++) {
        var emitterIndex = _a[_i];
        var emitter = ArrayItem.Get(extensionContext + "/emitters", _this._emitters, emitterIndex);
        if (emitter.refDistance != void 0 || emitter.maxDistance != void 0 || emitter.rolloffFactor != void 0 || emitter.distanceModel != void 0 || emitter.innerAngle != void 0 || emitter.outerAngle != void 0) {
          throw new Error(extensionContext + ": Direction or Distance properties are not allowed on emitters attached to a scene");
        }
        promises.push(_this._loadEmitterAsync(extensionContext + "/emitters/" + emitter.index, emitter));
      }
      return Promise.all(promises).then(function() {
      });
    });
  };
  MSFT_audio_emitter2.prototype.loadNodeAsync = function(context, node, assign) {
    var _this = this;
    return GLTFLoader2.LoadExtensionAsync(context, node, this.name, function(extensionContext, extension) {
      var promises = new Array();
      return _this._loader.loadNodeAsync(extensionContext, node, function(babylonMesh) {
        var _loop_1 = function(emitterIndex2) {
          var emitter = ArrayItem.Get(extensionContext + "/emitters", _this._emitters, emitterIndex2);
          promises.push(_this._loadEmitterAsync(extensionContext + "/emitters/" + emitter.index, emitter).then(function() {
            for (var _i2 = 0, _a2 = emitter._babylonSounds; _i2 < _a2.length; _i2++) {
              var sound = _a2[_i2];
              sound.attachToMesh(babylonMesh);
              if (emitter.innerAngle != void 0 || emitter.outerAngle != void 0) {
                sound.setLocalDirectionToMesh(Vector3.Forward());
                sound.setDirectionalCone(2 * Tools.ToDegrees(emitter.innerAngle == void 0 ? Math.PI : emitter.innerAngle), 2 * Tools.ToDegrees(emitter.outerAngle == void 0 ? Math.PI : emitter.outerAngle), 0);
              }
            }
          }));
        };
        for (var _i = 0, _a = extension.emitters; _i < _a.length; _i++) {
          var emitterIndex = _a[_i];
          _loop_1(emitterIndex);
        }
        assign(babylonMesh);
      }).then(function(babylonMesh) {
        return Promise.all(promises).then(function() {
          return babylonMesh;
        });
      });
    });
  };
  MSFT_audio_emitter2.prototype.loadAnimationAsync = function(context, animation) {
    var _this = this;
    return GLTFLoader2.LoadExtensionAsync(context, animation, this.name, function(extensionContext, extension) {
      return _this._loader.loadAnimationAsync(context, animation).then(function(babylonAnimationGroup) {
        var promises = new Array();
        ArrayItem.Assign(extension.events);
        for (var _i = 0, _a = extension.events; _i < _a.length; _i++) {
          var event_1 = _a[_i];
          promises.push(_this._loadAnimationEventAsync(extensionContext + "/events/" + event_1.index, context, animation, event_1, babylonAnimationGroup));
        }
        return Promise.all(promises).then(function() {
          return babylonAnimationGroup;
        });
      });
    });
  };
  MSFT_audio_emitter2.prototype._loadClipAsync = function(context, clip) {
    if (clip._objectURL) {
      return clip._objectURL;
    }
    var promise;
    if (clip.uri) {
      promise = this._loader.loadUriAsync(context, clip, clip.uri);
    } else {
      var bufferView = ArrayItem.Get(context + "/bufferView", this._loader.gltf.bufferViews, clip.bufferView);
      promise = this._loader.loadBufferViewAsync("/bufferViews/" + bufferView.index, bufferView);
    }
    clip._objectURL = promise.then(function(data) {
      return URL.createObjectURL(new Blob([data], { type: clip.mimeType }));
    });
    return clip._objectURL;
  };
  MSFT_audio_emitter2.prototype._loadEmitterAsync = function(context, emitter) {
    var _this = this;
    emitter._babylonSounds = emitter._babylonSounds || [];
    if (!emitter._babylonData) {
      var clipPromises = new Array();
      var name_1 = emitter.name || "emitter" + emitter.index;
      var options_1 = {
        loop: false,
        autoplay: false,
        volume: emitter.volume == void 0 ? 1 : emitter.volume
      };
      var _loop_2 = function(i2) {
        var clipContext = "/extensions/" + this_1.name + "/clips";
        var clip = ArrayItem.Get(clipContext, this_1._clips, emitter.clips[i2].clip);
        clipPromises.push(this_1._loadClipAsync(clipContext + "/" + emitter.clips[i2].clip, clip).then(function(objectURL) {
          var sound = emitter._babylonSounds[i2] = new Sound(name_1, objectURL, _this._loader.babylonScene, null, options_1);
          sound.refDistance = emitter.refDistance || 1;
          sound.maxDistance = emitter.maxDistance || 256;
          sound.rolloffFactor = emitter.rolloffFactor || 1;
          sound.distanceModel = emitter.distanceModel || "exponential";
          sound._positionInEmitterSpace = true;
        }));
      };
      var this_1 = this;
      for (var i = 0; i < emitter.clips.length; i++) {
        _loop_2(i);
      }
      var promise = Promise.all(clipPromises).then(function() {
        var weights = emitter.clips.map(function(clip) {
          return clip.weight || 1;
        });
        var weightedSound = new WeightedSound(emitter.loop || false, emitter._babylonSounds, weights);
        if (emitter.innerAngle) {
          weightedSound.directionalConeInnerAngle = 2 * Tools.ToDegrees(emitter.innerAngle);
        }
        if (emitter.outerAngle) {
          weightedSound.directionalConeOuterAngle = 2 * Tools.ToDegrees(emitter.outerAngle);
        }
        if (emitter.volume) {
          weightedSound.volume = emitter.volume;
        }
        emitter._babylonData.sound = weightedSound;
      });
      emitter._babylonData = {
        loaded: promise
      };
    }
    return emitter._babylonData.loaded;
  };
  MSFT_audio_emitter2.prototype._getEventAction = function(context, sound, action, time, startOffset) {
    switch (action) {
      case "play": {
        return function(currentFrame) {
          var frameOffset = (startOffset || 0) + (currentFrame - time);
          sound.play(frameOffset);
        };
      }
      case "stop": {
        return function(currentFrame) {
          sound.stop();
        };
      }
      case "pause": {
        return function(currentFrame) {
          sound.pause();
        };
      }
      default: {
        throw new Error(context + ": Unsupported action " + action);
      }
    }
  };
  MSFT_audio_emitter2.prototype._loadAnimationEventAsync = function(context, animationContext, animation, event, babylonAnimationGroup) {
    var _this = this;
    if (babylonAnimationGroup.targetedAnimations.length == 0) {
      return Promise.resolve();
    }
    var babylonAnimation = babylonAnimationGroup.targetedAnimations[0];
    var emitterIndex = event.emitter;
    var emitter = ArrayItem.Get("/extensions/" + this.name + "/emitters", this._emitters, emitterIndex);
    return this._loadEmitterAsync(context, emitter).then(function() {
      var sound = emitter._babylonData.sound;
      if (sound) {
        var babylonAnimationEvent = new AnimationEvent(event.time, _this._getEventAction(context, sound, event.action, event.time, event.startOffset));
        babylonAnimation.animation.addEvent(babylonAnimationEvent);
        babylonAnimationGroup.onAnimationGroupEndObservable.add(function() {
          sound.stop();
        });
        babylonAnimationGroup.onAnimationGroupPauseObservable.add(function() {
          sound.pause();
        });
      }
    });
  };
  return MSFT_audio_emitter2;
}();
GLTFLoader2.RegisterExtension(NAME18, function(loader) {
  return new MSFT_audio_emitter(loader);
});

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/MSFT_lod.js
var NAME19 = "MSFT_lod";
var MSFT_lod = function() {
  function MSFT_lod2(loader) {
    this.name = NAME19;
    this.order = 100;
    this.maxLODsToLoad = 10;
    this.onNodeLODsLoadedObservable = new Observable();
    this.onMaterialLODsLoadedObservable = new Observable();
    this._bufferLODs = new Array();
    this._nodeIndexLOD = null;
    this._nodeSignalLODs = new Array();
    this._nodePromiseLODs = new Array();
    this._nodeBufferLODs = new Array();
    this._materialIndexLOD = null;
    this._materialSignalLODs = new Array();
    this._materialPromiseLODs = new Array();
    this._materialBufferLODs = new Array();
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME19);
  }
  MSFT_lod2.prototype.dispose = function() {
    this._loader = null;
    this._nodeIndexLOD = null;
    this._nodeSignalLODs.length = 0;
    this._nodePromiseLODs.length = 0;
    this._nodeBufferLODs.length = 0;
    this._materialIndexLOD = null;
    this._materialSignalLODs.length = 0;
    this._materialPromiseLODs.length = 0;
    this._materialBufferLODs.length = 0;
    this.onMaterialLODsLoadedObservable.clear();
    this.onNodeLODsLoadedObservable.clear();
  };
  MSFT_lod2.prototype.onReady = function() {
    var _this = this;
    var _loop_1 = function(indexLOD2) {
      var promise = Promise.all(this_1._nodePromiseLODs[indexLOD2]).then(function() {
        if (indexLOD2 !== 0) {
          _this._loader.endPerformanceCounter("Node LOD " + indexLOD2);
          _this._loader.log("Loaded node LOD " + indexLOD2);
        }
        _this.onNodeLODsLoadedObservable.notifyObservers(indexLOD2);
        if (indexLOD2 !== _this._nodePromiseLODs.length - 1) {
          _this._loader.startPerformanceCounter("Node LOD " + (indexLOD2 + 1));
          _this._loadBufferLOD(_this._nodeBufferLODs, indexLOD2 + 1);
          if (_this._nodeSignalLODs[indexLOD2]) {
            _this._nodeSignalLODs[indexLOD2].resolve();
          }
        }
      });
      this_1._loader._completePromises.push(promise);
    };
    var this_1 = this;
    for (var indexLOD = 0; indexLOD < this._nodePromiseLODs.length; indexLOD++) {
      _loop_1(indexLOD);
    }
    var _loop_2 = function(indexLOD2) {
      var promise = Promise.all(this_2._materialPromiseLODs[indexLOD2]).then(function() {
        if (indexLOD2 !== 0) {
          _this._loader.endPerformanceCounter("Material LOD " + indexLOD2);
          _this._loader.log("Loaded material LOD " + indexLOD2);
        }
        _this.onMaterialLODsLoadedObservable.notifyObservers(indexLOD2);
        if (indexLOD2 !== _this._materialPromiseLODs.length - 1) {
          _this._loader.startPerformanceCounter("Material LOD " + (indexLOD2 + 1));
          _this._loadBufferLOD(_this._materialBufferLODs, indexLOD2 + 1);
          if (_this._materialSignalLODs[indexLOD2]) {
            _this._materialSignalLODs[indexLOD2].resolve();
          }
        }
      });
      this_2._loader._completePromises.push(promise);
    };
    var this_2 = this;
    for (var indexLOD = 0; indexLOD < this._materialPromiseLODs.length; indexLOD++) {
      _loop_2(indexLOD);
    }
  };
  MSFT_lod2.prototype.loadSceneAsync = function(context, scene) {
    var promise = this._loader.loadSceneAsync(context, scene);
    this._loadBufferLOD(this._bufferLODs, 0);
    return promise;
  };
  MSFT_lod2.prototype.loadNodeAsync = function(context, node, assign) {
    var _this = this;
    return GLTFLoader2.LoadExtensionAsync(context, node, this.name, function(extensionContext, extension) {
      var firstPromise;
      var nodeLODs = _this._getLODs(extensionContext, node, _this._loader.gltf.nodes, extension.ids);
      _this._loader.logOpen("" + extensionContext);
      var _loop_3 = function(indexLOD2) {
        var nodeLOD = nodeLODs[indexLOD2];
        if (indexLOD2 !== 0) {
          _this._nodeIndexLOD = indexLOD2;
          _this._nodeSignalLODs[indexLOD2] = _this._nodeSignalLODs[indexLOD2] || new Deferred();
        }
        var assign_1 = function(babylonTransformNode) {
          babylonTransformNode.setEnabled(false);
        };
        var promise = _this._loader.loadNodeAsync("/nodes/" + nodeLOD.index, nodeLOD, assign_1).then(function(babylonMesh) {
          if (indexLOD2 !== 0) {
            var previousNodeLOD = nodeLODs[indexLOD2 - 1];
            if (previousNodeLOD._babylonTransformNode) {
              _this._disposeTransformNode(previousNodeLOD._babylonTransformNode);
              delete previousNodeLOD._babylonTransformNode;
            }
          }
          babylonMesh.setEnabled(true);
          return babylonMesh;
        });
        _this._nodePromiseLODs[indexLOD2] = _this._nodePromiseLODs[indexLOD2] || [];
        if (indexLOD2 === 0) {
          firstPromise = promise;
        } else {
          _this._nodeIndexLOD = null;
          _this._nodePromiseLODs[indexLOD2].push(promise);
        }
      };
      for (var indexLOD = 0; indexLOD < nodeLODs.length; indexLOD++) {
        _loop_3(indexLOD);
      }
      _this._loader.logClose();
      return firstPromise;
    });
  };
  MSFT_lod2.prototype._loadMaterialAsync = function(context, material, babylonMesh, babylonDrawMode, assign) {
    var _this = this;
    if (this._nodeIndexLOD) {
      return null;
    }
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
      var firstPromise;
      var materialLODs = _this._getLODs(extensionContext, material, _this._loader.gltf.materials, extension.ids);
      _this._loader.logOpen("" + extensionContext);
      var _loop_4 = function(indexLOD2) {
        var materialLOD = materialLODs[indexLOD2];
        if (indexLOD2 !== 0) {
          _this._materialIndexLOD = indexLOD2;
        }
        var promise = _this._loader._loadMaterialAsync("/materials/" + materialLOD.index, materialLOD, babylonMesh, babylonDrawMode, function(babylonMaterial) {
          if (indexLOD2 === 0) {
            assign(babylonMaterial);
          }
        }).then(function(babylonMaterial) {
          if (indexLOD2 !== 0) {
            assign(babylonMaterial);
            var previousDataLOD = materialLODs[indexLOD2 - 1]._data;
            if (previousDataLOD[babylonDrawMode]) {
              _this._disposeMaterials([previousDataLOD[babylonDrawMode].babylonMaterial]);
              delete previousDataLOD[babylonDrawMode];
            }
          }
          return babylonMaterial;
        });
        _this._materialPromiseLODs[indexLOD2] = _this._materialPromiseLODs[indexLOD2] || [];
        if (indexLOD2 === 0) {
          firstPromise = promise;
        } else {
          _this._materialIndexLOD = null;
          _this._materialPromiseLODs[indexLOD2].push(promise);
        }
      };
      for (var indexLOD = 0; indexLOD < materialLODs.length; indexLOD++) {
        _loop_4(indexLOD);
      }
      _this._loader.logClose();
      return firstPromise;
    });
  };
  MSFT_lod2.prototype._loadUriAsync = function(context, property, uri) {
    var _this = this;
    if (this._nodeIndexLOD !== null) {
      this._loader.log("deferred");
      var previousIndexLOD = this._nodeIndexLOD - 1;
      this._nodeSignalLODs[previousIndexLOD] = this._nodeSignalLODs[previousIndexLOD] || new Deferred();
      return this._nodeSignalLODs[this._nodeIndexLOD - 1].promise.then(function() {
        return _this._loader.loadUriAsync(context, property, uri);
      });
    } else if (this._materialIndexLOD !== null) {
      this._loader.log("deferred");
      var previousIndexLOD = this._materialIndexLOD - 1;
      this._materialSignalLODs[previousIndexLOD] = this._materialSignalLODs[previousIndexLOD] || new Deferred();
      return this._materialSignalLODs[previousIndexLOD].promise.then(function() {
        return _this._loader.loadUriAsync(context, property, uri);
      });
    }
    return null;
  };
  MSFT_lod2.prototype.loadBufferAsync = function(context, buffer, byteOffset, byteLength) {
    if (this._loader.parent.useRangeRequests && !buffer.uri) {
      if (!this._loader.bin) {
        throw new Error(context + ": Uri is missing or the binary glTF is missing its binary chunk");
      }
      var loadAsync = function(bufferLODs, indexLOD) {
        var start = byteOffset;
        var end = start + byteLength - 1;
        var bufferLOD = bufferLODs[indexLOD];
        if (bufferLOD) {
          bufferLOD.start = Math.min(bufferLOD.start, start);
          bufferLOD.end = Math.max(bufferLOD.end, end);
        } else {
          bufferLOD = { start, end, loaded: new Deferred() };
          bufferLODs[indexLOD] = bufferLOD;
        }
        return bufferLOD.loaded.promise.then(function(data) {
          return new Uint8Array(data.buffer, data.byteOffset + byteOffset - bufferLOD.start, byteLength);
        });
      };
      this._loader.log("deferred");
      if (this._nodeIndexLOD !== null) {
        return loadAsync(this._nodeBufferLODs, this._nodeIndexLOD);
      } else if (this._materialIndexLOD !== null) {
        return loadAsync(this._materialBufferLODs, this._materialIndexLOD);
      } else {
        return loadAsync(this._bufferLODs, 0);
      }
    }
    return null;
  };
  MSFT_lod2.prototype._loadBufferLOD = function(bufferLODs, indexLOD) {
    var bufferLOD = bufferLODs[indexLOD];
    if (bufferLOD) {
      this._loader.log("Loading buffer range [" + bufferLOD.start + "-" + bufferLOD.end + "]");
      this._loader.bin.readAsync(bufferLOD.start, bufferLOD.end - bufferLOD.start + 1).then(function(data) {
        bufferLOD.loaded.resolve(data);
      }, function(error) {
        bufferLOD.loaded.reject(error);
      });
    }
  };
  MSFT_lod2.prototype._getLODs = function(context, property, array, ids) {
    if (this.maxLODsToLoad <= 0) {
      throw new Error("maxLODsToLoad must be greater than zero");
    }
    var properties = new Array();
    for (var i = ids.length - 1; i >= 0; i--) {
      properties.push(ArrayItem.Get(context + "/ids/" + ids[i], array, ids[i]));
      if (properties.length === this.maxLODsToLoad) {
        return properties;
      }
    }
    properties.push(property);
    return properties;
  };
  MSFT_lod2.prototype._disposeTransformNode = function(babylonTransformNode) {
    var _this = this;
    var babylonMaterials = new Array();
    var babylonMaterial = babylonTransformNode.material;
    if (babylonMaterial) {
      babylonMaterials.push(babylonMaterial);
    }
    for (var _i = 0, _a = babylonTransformNode.getChildMeshes(); _i < _a.length; _i++) {
      var babylonMesh = _a[_i];
      if (babylonMesh.material) {
        babylonMaterials.push(babylonMesh.material);
      }
    }
    babylonTransformNode.dispose();
    var babylonMaterialsToDispose = babylonMaterials.filter(function(babylonMaterial2) {
      return _this._loader.babylonScene.meshes.every(function(mesh) {
        return mesh.material != babylonMaterial2;
      });
    });
    this._disposeMaterials(babylonMaterialsToDispose);
  };
  MSFT_lod2.prototype._disposeMaterials = function(babylonMaterials) {
    var babylonTextures = {};
    for (var _i = 0, babylonMaterials_1 = babylonMaterials; _i < babylonMaterials_1.length; _i++) {
      var babylonMaterial = babylonMaterials_1[_i];
      for (var _a = 0, _b = babylonMaterial.getActiveTextures(); _a < _b.length; _a++) {
        var babylonTexture = _b[_a];
        babylonTextures[babylonTexture.uniqueId] = babylonTexture;
      }
      babylonMaterial.dispose();
    }
    for (var uniqueId in babylonTextures) {
      for (var _c = 0, _d = this._loader.babylonScene.materials; _c < _d.length; _c++) {
        var babylonMaterial = _d[_c];
        if (babylonMaterial.hasTexture(babylonTextures[uniqueId])) {
          delete babylonTextures[uniqueId];
        }
      }
    }
    for (var uniqueId in babylonTextures) {
      babylonTextures[uniqueId].dispose();
    }
  };
  return MSFT_lod2;
}();
GLTFLoader2.RegisterExtension(NAME19, function(loader) {
  return new MSFT_lod(loader);
});

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/MSFT_minecraftMesh.js
var NAME20 = "MSFT_minecraftMesh";
var MSFT_minecraftMesh = function() {
  function MSFT_minecraftMesh2(loader) {
    this.name = NAME20;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME20);
  }
  MSFT_minecraftMesh2.prototype.dispose = function() {
    this._loader = null;
  };
  MSFT_minecraftMesh2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
    var _this = this;
    return GLTFLoader2.LoadExtraAsync(context, material, this.name, function(extraContext, extra) {
      if (extra) {
        if (!(babylonMaterial instanceof PBRMaterial)) {
          throw new Error(extraContext + ": Material type not supported");
        }
        var promise = _this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial);
        if (babylonMaterial.needAlphaBlending()) {
          babylonMaterial.forceDepthWrite = true;
          babylonMaterial.separateCullingPass = true;
        }
        babylonMaterial.backFaceCulling = babylonMaterial.forceDepthWrite;
        babylonMaterial.twoSidedLighting = true;
        return promise;
      }
      return null;
    });
  };
  return MSFT_minecraftMesh2;
}();
GLTFLoader2.RegisterExtension(NAME20, function(loader) {
  return new MSFT_minecraftMesh(loader);
});

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/MSFT_sRGBFactors.js
var NAME21 = "MSFT_sRGBFactors";
var MSFT_sRGBFactors = function() {
  function MSFT_sRGBFactors2(loader) {
    this.name = NAME21;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME21);
  }
  MSFT_sRGBFactors2.prototype.dispose = function() {
    this._loader = null;
  };
  MSFT_sRGBFactors2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
    var _this = this;
    return GLTFLoader2.LoadExtraAsync(context, material, this.name, function(extraContext, extra) {
      if (extra) {
        if (!(babylonMaterial instanceof PBRMaterial)) {
          throw new Error(extraContext + ": Material type not supported");
        }
        var promise = _this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial);
        if (!babylonMaterial.albedoTexture) {
          babylonMaterial.albedoColor.toLinearSpaceToRef(babylonMaterial.albedoColor);
        }
        if (!babylonMaterial.reflectivityTexture) {
          babylonMaterial.reflectivityColor.toLinearSpaceToRef(babylonMaterial.reflectivityColor);
        }
        return promise;
      }
      return null;
    });
  };
  return MSFT_sRGBFactors2;
}();
GLTFLoader2.RegisterExtension(NAME21, function(loader) {
  return new MSFT_sRGBFactors(loader);
});

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/ExtrasAsMetadata.js
var NAME22 = "ExtrasAsMetadata";
var ExtrasAsMetadata = function() {
  function ExtrasAsMetadata2(loader) {
    this.name = NAME22;
    this.enabled = true;
    this._loader = loader;
  }
  ExtrasAsMetadata2.prototype._assignExtras = function(babylonObject, gltfProp) {
    if (gltfProp.extras && Object.keys(gltfProp.extras).length > 0) {
      var metadata = babylonObject.metadata = babylonObject.metadata || {};
      var gltf = metadata.gltf = metadata.gltf || {};
      gltf.extras = gltfProp.extras;
    }
  };
  ExtrasAsMetadata2.prototype.dispose = function() {
    this._loader = null;
  };
  ExtrasAsMetadata2.prototype.loadNodeAsync = function(context, node, assign) {
    var _this = this;
    return this._loader.loadNodeAsync(context, node, function(babylonTransformNode) {
      _this._assignExtras(babylonTransformNode, node);
      assign(babylonTransformNode);
    });
  };
  ExtrasAsMetadata2.prototype.loadCameraAsync = function(context, camera, assign) {
    var _this = this;
    return this._loader.loadCameraAsync(context, camera, function(babylonCamera) {
      _this._assignExtras(babylonCamera, camera);
      assign(babylonCamera);
    });
  };
  ExtrasAsMetadata2.prototype.createMaterial = function(context, material, babylonDrawMode) {
    var babylonMaterial = this._loader.createMaterial(context, material, babylonDrawMode);
    this._assignExtras(babylonMaterial, material);
    return babylonMaterial;
  };
  return ExtrasAsMetadata2;
}();
GLTFLoader2.RegisterExtension(NAME22, function(loader) {
  return new ExtrasAsMetadata(loader);
});

// node_modules/@babylonjs/loaders/OBJ/mtlFileLoader.js
var MTLFileLoader = function() {
  function MTLFileLoader2() {
    this.materials = [];
  }
  MTLFileLoader2.prototype.parseMTL = function(scene, data, rootUrl, forAssetContainer) {
    if (data instanceof ArrayBuffer) {
      return;
    }
    var lines = data.split("\n");
    var delimiter_pattern = /\s+/;
    var color;
    var material = null;
    for (var i = 0; i < lines.length; i++) {
      var line = lines[i].trim();
      if (line.length === 0 || line.charAt(0) === "#") {
        continue;
      }
      var pos = line.indexOf(" ");
      var key = pos >= 0 ? line.substring(0, pos) : line;
      key = key.toLowerCase();
      var value = pos >= 0 ? line.substring(pos + 1).trim() : "";
      if (key === "newmtl") {
        if (material) {
          this.materials.push(material);
        }
        scene._blockEntityCollection = forAssetContainer;
        material = new StandardMaterial(value, scene);
        scene._blockEntityCollection = false;
      } else if (key === "kd" && material) {
        color = value.split(delimiter_pattern, 3).map(parseFloat);
        material.diffuseColor = Color3.FromArray(color);
      } else if (key === "ka" && material) {
        color = value.split(delimiter_pattern, 3).map(parseFloat);
        material.ambientColor = Color3.FromArray(color);
      } else if (key === "ks" && material) {
        color = value.split(delimiter_pattern, 3).map(parseFloat);
        material.specularColor = Color3.FromArray(color);
      } else if (key === "ke" && material) {
        color = value.split(delimiter_pattern, 3).map(parseFloat);
        material.emissiveColor = Color3.FromArray(color);
      } else if (key === "ns" && material) {
        material.specularPower = parseFloat(value);
      } else if (key === "d" && material) {
        material.alpha = parseFloat(value);
      } else if (key === "map_ka" && material) {
        material.ambientTexture = MTLFileLoader2._getTexture(rootUrl, value, scene);
      } else if (key === "map_kd" && material) {
        material.diffuseTexture = MTLFileLoader2._getTexture(rootUrl, value, scene);
      } else if (key === "map_ks" && material) {
        material.specularTexture = MTLFileLoader2._getTexture(rootUrl, value, scene);
      } else if (key === "map_ns") {
      } else if (key === "map_bump" && material) {
        material.bumpTexture = MTLFileLoader2._getTexture(rootUrl, value, scene);
      } else if (key === "map_d" && material) {
        material.opacityTexture = MTLFileLoader2._getTexture(rootUrl, value, scene);
      } else if (key === "illum") {
        if (value === "0") {
        } else if (value === "1") {
        } else if (value === "2") {
        } else if (value === "3") {
        } else if (value === "4") {
        } else if (value === "5") {
        } else if (value === "6") {
        } else if (value === "7") {
        } else if (value === "8") {
        } else if (value === "9") {
        } else if (value === "10") {
        }
      } else {
      }
    }
    if (material) {
      this.materials.push(material);
    }
  };
  MTLFileLoader2._getTexture = function(rootUrl, value, scene) {
    if (!value) {
      return null;
    }
    var url = rootUrl;
    if (rootUrl === "file:") {
      var lastDelimiter = value.lastIndexOf("\\");
      if (lastDelimiter === -1) {
        lastDelimiter = value.lastIndexOf("/");
      }
      if (lastDelimiter > -1) {
        url += value.substr(lastDelimiter + 1);
      } else {
        url += value;
      }
    } else {
      url += value;
    }
    return new Texture(url, scene, false, MTLFileLoader2.INVERT_TEXTURE_Y);
  };
  MTLFileLoader2.INVERT_TEXTURE_Y = true;
  return MTLFileLoader2;
}();

// node_modules/@babylonjs/loaders/OBJ/objFileLoader.js
var OBJFileLoader = function() {
  function OBJFileLoader2(meshLoadOptions) {
    this.name = "obj";
    this.extensions = ".obj";
    this.obj = /^o/;
    this.group = /^g/;
    this.mtllib = /^mtllib /;
    this.usemtl = /^usemtl /;
    this.smooth = /^s /;
    this.vertexPattern = /v(\s+[\d|\.|\+|\-|e|E]+){3,7}/;
    this.normalPattern = /vn(\s+[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/;
    this.uvPattern = /vt(\s+[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/;
    this.facePattern1 = /f\s+(([\d]{1,}[\s]?){3,})+/;
    this.facePattern2 = /f\s+((([\d]{1,}\/[\d]{1,}[\s]?){3,})+)/;
    this.facePattern3 = /f\s+((([\d]{1,}\/[\d]{1,}\/[\d]{1,}[\s]?){3,})+)/;
    this.facePattern4 = /f\s+((([\d]{1,}\/\/[\d]{1,}[\s]?){3,})+)/;
    this.facePattern5 = /f\s+(((-[\d]{1,}\/-[\d]{1,}\/-[\d]{1,}[\s]?){3,})+)/;
    this._forAssetContainer = false;
    this._meshLoadOptions = meshLoadOptions || OBJFileLoader2.currentMeshLoadOptions;
  }
  Object.defineProperty(OBJFileLoader2, "INVERT_TEXTURE_Y", {
    get: function() {
      return MTLFileLoader.INVERT_TEXTURE_Y;
    },
    set: function(value) {
      MTLFileLoader.INVERT_TEXTURE_Y = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(OBJFileLoader2, "currentMeshLoadOptions", {
    get: function() {
      return {
        ComputeNormals: OBJFileLoader2.COMPUTE_NORMALS,
        ImportVertexColors: OBJFileLoader2.IMPORT_VERTEX_COLORS,
        InvertY: OBJFileLoader2.INVERT_Y,
        InvertTextureY: OBJFileLoader2.INVERT_TEXTURE_Y,
        UVScaling: OBJFileLoader2.UV_SCALING,
        MaterialLoadingFailsSilently: OBJFileLoader2.MATERIAL_LOADING_FAILS_SILENTLY,
        OptimizeWithUV: OBJFileLoader2.OPTIMIZE_WITH_UV,
        SkipMaterials: OBJFileLoader2.SKIP_MATERIALS
      };
    },
    enumerable: false,
    configurable: true
  });
  OBJFileLoader2.prototype._loadMTL = function(url, rootUrl, onSuccess, onFailure) {
    var pathOfFile = Tools.BaseUrl + rootUrl + url;
    Tools.LoadFile(pathOfFile, onSuccess, void 0, void 0, false, function(request, exception) {
      onFailure(pathOfFile, exception);
    });
  };
  OBJFileLoader2.prototype.createPlugin = function() {
    return new OBJFileLoader2(OBJFileLoader2.currentMeshLoadOptions);
  };
  OBJFileLoader2.prototype.canDirectLoad = function(data) {
    return false;
  };
  OBJFileLoader2.prototype.importMeshAsync = function(meshesNames, scene, data, rootUrl, onProgress, fileName) {
    return this._parseSolid(meshesNames, scene, data, rootUrl).then(function(meshes) {
      return {
        meshes,
        particleSystems: [],
        skeletons: [],
        animationGroups: [],
        transformNodes: [],
        geometries: [],
        lights: []
      };
    });
  };
  OBJFileLoader2.prototype.loadAsync = function(scene, data, rootUrl, onProgress, fileName) {
    return this.importMeshAsync(null, scene, data, rootUrl, onProgress).then(function() {
    });
  };
  OBJFileLoader2.prototype.loadAssetContainerAsync = function(scene, data, rootUrl, onProgress, fileName) {
    var _this = this;
    this._forAssetContainer = true;
    return this.importMeshAsync(null, scene, data, rootUrl).then(function(result) {
      var container = new AssetContainer(scene);
      result.meshes.forEach(function(mesh) {
        return container.meshes.push(mesh);
      });
      result.meshes.forEach(function(mesh) {
        var material = mesh.material;
        if (material) {
          if (container.materials.indexOf(material) == -1) {
            container.materials.push(material);
            var textures = material.getActiveTextures();
            textures.forEach(function(t) {
              if (container.textures.indexOf(t) == -1) {
                container.textures.push(t);
              }
            });
          }
        }
      });
      _this._forAssetContainer = false;
      return container;
    }).catch(function(ex) {
      _this._forAssetContainer = false;
      throw ex;
    });
  };
  OBJFileLoader2.prototype._parseSolid = function(meshesNames, scene, data, rootUrl) {
    var _this = this;
    var positions = [];
    var normals = [];
    var uvs = [];
    var colors = [];
    var meshesFromObj = [];
    var handledMesh;
    var indicesForBabylon = [];
    var wrappedPositionForBabylon = [];
    var wrappedUvsForBabylon = [];
    var wrappedColorsForBabylon = [];
    var wrappedNormalsForBabylon = [];
    var tuplePosNorm = [];
    var curPositionInIndices = 0;
    var hasMeshes = false;
    var unwrappedPositionsForBabylon = [];
    var unwrappedColorsForBabylon = [];
    var unwrappedNormalsForBabylon = [];
    var unwrappedUVForBabylon = [];
    var triangles = [];
    var materialNameFromObj = "";
    var fileToLoad = "";
    var materialsFromMTLFile = new MTLFileLoader();
    var objMeshName = "";
    var increment = 1;
    var isFirstMaterial = true;
    var grayColor = new Color4(0.5, 0.5, 0.5, 1);
    var isInArray = function(arr, obj) {
      if (!arr[obj[0]]) {
        arr[obj[0]] = { normals: [], idx: [] };
      }
      var idx = arr[obj[0]].normals.indexOf(obj[1]);
      return idx === -1 ? -1 : arr[obj[0]].idx[idx];
    };
    var isInArrayUV = function(arr, obj) {
      if (!arr[obj[0]]) {
        arr[obj[0]] = { normals: [], idx: [], uv: [] };
      }
      var idx = arr[obj[0]].normals.indexOf(obj[1]);
      if (idx != 1 && obj[2] === arr[obj[0]].uv[idx]) {
        return arr[obj[0]].idx[idx];
      }
      return -1;
    };
    var setData = function(indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj, positionVectorFromOBJ, textureVectorFromOBJ, normalsVectorFromOBJ, positionColorsFromOBJ) {
      var _index;
      if (_this._meshLoadOptions.OptimizeWithUV) {
        _index = isInArrayUV(tuplePosNorm, [
          indicePositionFromObj,
          indiceNormalFromObj,
          indiceUvsFromObj
        ]);
      } else {
        _index = isInArray(tuplePosNorm, [
          indicePositionFromObj,
          indiceNormalFromObj
        ]);
      }
      if (_index === -1) {
        indicesForBabylon.push(wrappedPositionForBabylon.length);
        wrappedPositionForBabylon.push(positionVectorFromOBJ);
        wrappedUvsForBabylon.push(textureVectorFromOBJ);
        wrappedNormalsForBabylon.push(normalsVectorFromOBJ);
        if (positionColorsFromOBJ !== void 0) {
          wrappedColorsForBabylon.push(positionColorsFromOBJ);
        }
        tuplePosNorm[indicePositionFromObj].normals.push(indiceNormalFromObj);
        tuplePosNorm[indicePositionFromObj].idx.push(curPositionInIndices++);
        if (_this._meshLoadOptions.OptimizeWithUV) {
          tuplePosNorm[indicePositionFromObj].uv.push(indiceUvsFromObj);
        }
      } else {
        indicesForBabylon.push(_index);
      }
    };
    var unwrapData = function() {
      for (var l = 0; l < wrappedPositionForBabylon.length; l++) {
        unwrappedPositionsForBabylon.push(wrappedPositionForBabylon[l].x, wrappedPositionForBabylon[l].y, wrappedPositionForBabylon[l].z);
        unwrappedNormalsForBabylon.push(wrappedNormalsForBabylon[l].x, wrappedNormalsForBabylon[l].y, wrappedNormalsForBabylon[l].z);
        unwrappedUVForBabylon.push(wrappedUvsForBabylon[l].x, wrappedUvsForBabylon[l].y);
        if (_this._meshLoadOptions.ImportVertexColors === true) {
          unwrappedColorsForBabylon.push(wrappedColorsForBabylon[l].r, wrappedColorsForBabylon[l].g, wrappedColorsForBabylon[l].b, wrappedColorsForBabylon[l].a);
        }
      }
      wrappedPositionForBabylon = [];
      wrappedNormalsForBabylon = [];
      wrappedUvsForBabylon = [];
      wrappedColorsForBabylon = [];
      tuplePosNorm = [];
      curPositionInIndices = 0;
    };
    var getTriangles = function(faces, v) {
      for (var faceIndex = v; faceIndex < faces.length - 1; faceIndex++) {
        triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]);
      }
    };
    var setDataForCurrentFaceWithPattern1 = function(face, v) {
      getTriangles(face, v);
      for (var k = 0; k < triangles.length; k++) {
        var indicePositionFromObj = parseInt(triangles[k]) - 1;
        setData(indicePositionFromObj, 0, 0, positions[indicePositionFromObj], Vector2.Zero(), Vector3.Up(), _this._meshLoadOptions.ImportVertexColors === true ? colors[indicePositionFromObj] : void 0);
      }
      triangles = [];
    };
    var setDataForCurrentFaceWithPattern2 = function(face, v) {
      getTriangles(face, v);
      for (var k = 0; k < triangles.length; k++) {
        var point = triangles[k].split("/");
        var indicePositionFromObj = parseInt(point[0]) - 1;
        var indiceUvsFromObj = parseInt(point[1]) - 1;
        setData(indicePositionFromObj, indiceUvsFromObj, 0, positions[indicePositionFromObj], uvs[indiceUvsFromObj], Vector3.Up(), _this._meshLoadOptions.ImportVertexColors === true ? colors[indicePositionFromObj] : void 0);
      }
      triangles = [];
    };
    var setDataForCurrentFaceWithPattern3 = function(face, v) {
      getTriangles(face, v);
      for (var k = 0; k < triangles.length; k++) {
        var point = triangles[k].split("/");
        var indicePositionFromObj = parseInt(point[0]) - 1;
        var indiceUvsFromObj = parseInt(point[1]) - 1;
        var indiceNormalFromObj = parseInt(point[2]) - 1;
        setData(indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj, positions[indicePositionFromObj], uvs[indiceUvsFromObj], normals[indiceNormalFromObj]);
      }
      triangles = [];
    };
    var setDataForCurrentFaceWithPattern4 = function(face, v) {
      getTriangles(face, v);
      for (var k = 0; k < triangles.length; k++) {
        var point = triangles[k].split("//");
        var indicePositionFromObj = parseInt(point[0]) - 1;
        var indiceNormalFromObj = parseInt(point[1]) - 1;
        setData(indicePositionFromObj, 1, indiceNormalFromObj, positions[indicePositionFromObj], Vector2.Zero(), normals[indiceNormalFromObj], _this._meshLoadOptions.ImportVertexColors === true ? colors[indicePositionFromObj] : void 0);
      }
      triangles = [];
    };
    var setDataForCurrentFaceWithPattern5 = function(face, v) {
      getTriangles(face, v);
      for (var k = 0; k < triangles.length; k++) {
        var point = triangles[k].split("/");
        var indicePositionFromObj = positions.length + parseInt(point[0]);
        var indiceUvsFromObj = uvs.length + parseInt(point[1]);
        var indiceNormalFromObj = normals.length + parseInt(point[2]);
        setData(indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj, positions[indicePositionFromObj], uvs[indiceUvsFromObj], normals[indiceNormalFromObj], _this._meshLoadOptions.ImportVertexColors === true ? colors[indicePositionFromObj] : void 0);
      }
      triangles = [];
    };
    var addPreviousObjMesh = function() {
      if (meshesFromObj.length > 0) {
        handledMesh = meshesFromObj[meshesFromObj.length - 1];
        unwrapData();
        indicesForBabylon.reverse();
        handledMesh.indices = indicesForBabylon.slice();
        handledMesh.positions = unwrappedPositionsForBabylon.slice();
        handledMesh.normals = unwrappedNormalsForBabylon.slice();
        handledMesh.uvs = unwrappedUVForBabylon.slice();
        if (_this._meshLoadOptions.ImportVertexColors === true) {
          handledMesh.colors = unwrappedColorsForBabylon.slice();
        }
        indicesForBabylon = [];
        unwrappedPositionsForBabylon = [];
        unwrappedColorsForBabylon = [];
        unwrappedNormalsForBabylon = [];
        unwrappedUVForBabylon = [];
      }
    };
    var lines = data.split("\n");
    for (var i = 0; i < lines.length; i++) {
      var line = lines[i].trim().replace(/\s\s/g, " ");
      var result;
      if (line.length === 0 || line.charAt(0) === "#") {
        continue;
      } else if (this.vertexPattern.test(line)) {
        result = line.match(/[^ ]+/g);
        positions.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));
        if (this._meshLoadOptions.ImportVertexColors === true) {
          if (result.length >= 7) {
            colors.push(new Color4(parseFloat(result[4]), parseFloat(result[5]), parseFloat(result[6]), result.length === 7 || result[7] === void 0 ? 1 : parseFloat(result[7])));
          } else {
            colors.push(grayColor);
          }
        }
      } else if ((result = this.normalPattern.exec(line)) !== null) {
        normals.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));
      } else if ((result = this.uvPattern.exec(line)) !== null) {
        uvs.push(new Vector2(parseFloat(result[1]) * OBJFileLoader2.UV_SCALING.x, parseFloat(result[2]) * OBJFileLoader2.UV_SCALING.y));
      } else if ((result = this.facePattern3.exec(line)) !== null) {
        setDataForCurrentFaceWithPattern3(result[1].trim().split(" "), 1);
      } else if ((result = this.facePattern4.exec(line)) !== null) {
        setDataForCurrentFaceWithPattern4(result[1].trim().split(" "), 1);
      } else if ((result = this.facePattern5.exec(line)) !== null) {
        setDataForCurrentFaceWithPattern5(result[1].trim().split(" "), 1);
      } else if ((result = this.facePattern2.exec(line)) !== null) {
        setDataForCurrentFaceWithPattern2(result[1].trim().split(" "), 1);
      } else if ((result = this.facePattern1.exec(line)) !== null) {
        setDataForCurrentFaceWithPattern1(result[1].trim().split(" "), 1);
      } else if (this.group.test(line) || this.obj.test(line)) {
        var objMesh = {
          name: line.substring(2).trim(),
          indices: void 0,
          positions: void 0,
          normals: void 0,
          uvs: void 0,
          colors: void 0,
          materialName: ""
        };
        addPreviousObjMesh();
        meshesFromObj.push(objMesh);
        hasMeshes = true;
        isFirstMaterial = true;
        increment = 1;
      } else if (this.usemtl.test(line)) {
        materialNameFromObj = line.substring(7).trim();
        if (!isFirstMaterial || !hasMeshes) {
          addPreviousObjMesh();
          var objMesh = {
            name: (objMeshName || "mesh") + "_mm" + increment.toString(),
            indices: void 0,
            positions: void 0,
            normals: void 0,
            uvs: void 0,
            colors: void 0,
            materialName: materialNameFromObj
          };
          increment++;
          meshesFromObj.push(objMesh);
          hasMeshes = true;
        }
        if (hasMeshes && isFirstMaterial) {
          meshesFromObj[meshesFromObj.length - 1].materialName = materialNameFromObj;
          isFirstMaterial = false;
        }
      } else if (this.mtllib.test(line)) {
        fileToLoad = line.substring(7).trim();
      } else if (this.smooth.test(line)) {
      } else {
        console.log("Unhandled expression at line : " + line);
      }
    }
    if (hasMeshes) {
      handledMesh = meshesFromObj[meshesFromObj.length - 1];
      indicesForBabylon.reverse();
      unwrapData();
      handledMesh.indices = indicesForBabylon;
      handledMesh.positions = unwrappedPositionsForBabylon;
      handledMesh.normals = unwrappedNormalsForBabylon;
      handledMesh.uvs = unwrappedUVForBabylon;
      if (this._meshLoadOptions.ImportVertexColors === true) {
        handledMesh.colors = unwrappedColorsForBabylon;
      }
    }
    if (!hasMeshes) {
      indicesForBabylon.reverse();
      unwrapData();
      meshesFromObj.push({
        name: Geometry.RandomId(),
        indices: indicesForBabylon,
        positions: unwrappedPositionsForBabylon,
        colors: unwrappedColorsForBabylon,
        normals: unwrappedNormalsForBabylon,
        uvs: unwrappedUVForBabylon,
        materialName: materialNameFromObj
      });
    }
    var babylonMeshesArray = [];
    var materialToUse = new Array();
    for (var j = 0; j < meshesFromObj.length; j++) {
      if (meshesNames && meshesFromObj[j].name) {
        if (meshesNames instanceof Array) {
          if (meshesNames.indexOf(meshesFromObj[j].name) === -1) {
            continue;
          }
        } else {
          if (meshesFromObj[j].name !== meshesNames) {
            continue;
          }
        }
      }
      handledMesh = meshesFromObj[j];
      scene._blockEntityCollection = this._forAssetContainer;
      var babylonMesh = new Mesh(meshesFromObj[j].name, scene);
      scene._blockEntityCollection = false;
      materialToUse.push(meshesFromObj[j].materialName);
      var vertexData = new VertexData();
      vertexData.uvs = handledMesh.uvs;
      vertexData.indices = handledMesh.indices;
      vertexData.positions = handledMesh.positions;
      if (this._meshLoadOptions.ComputeNormals === true) {
        var normals_1 = new Array();
        VertexData.ComputeNormals(handledMesh.positions, handledMesh.indices, normals_1);
        vertexData.normals = normals_1;
      } else {
        vertexData.normals = handledMesh.normals;
      }
      if (this._meshLoadOptions.ImportVertexColors === true) {
        vertexData.colors = handledMesh.colors;
      }
      vertexData.applyToMesh(babylonMesh);
      if (this._meshLoadOptions.InvertY) {
        babylonMesh.scaling.y *= -1;
      }
      babylonMeshesArray.push(babylonMesh);
    }
    var mtlPromises = [];
    if (fileToLoad !== "" && this._meshLoadOptions.SkipMaterials === false) {
      mtlPromises.push(new Promise(function(resolve, reject) {
        _this._loadMTL(fileToLoad, rootUrl, function(dataLoaded) {
          try {
            materialsFromMTLFile.parseMTL(scene, dataLoaded, rootUrl, _this._forAssetContainer);
            for (var n = 0; n < materialsFromMTLFile.materials.length; n++) {
              var startIndex = 0;
              var _indices = [];
              var _index;
              while ((_index = materialToUse.indexOf(materialsFromMTLFile.materials[n].name, startIndex)) > -1) {
                _indices.push(_index);
                startIndex = _index + 1;
              }
              if (_index === -1 && _indices.length === 0) {
                materialsFromMTLFile.materials[n].dispose();
              } else {
                for (var o = 0; o < _indices.length; o++) {
                  babylonMeshesArray[_indices[o]].material = materialsFromMTLFile.materials[n];
                }
              }
            }
            resolve();
          } catch (e) {
            Tools.Warn("Error processing MTL file: '" + fileToLoad + "'");
            if (_this._meshLoadOptions.MaterialLoadingFailsSilently) {
              resolve();
            } else {
              reject(e);
            }
          }
        }, function(pathOfFile, exception) {
          Tools.Warn("Error downloading MTL file: '" + fileToLoad + "'");
          if (_this._meshLoadOptions.MaterialLoadingFailsSilently) {
            resolve();
          } else {
            reject(exception);
          }
        });
      }));
    }
    return Promise.all(mtlPromises).then(function() {
      return babylonMeshesArray;
    });
  };
  OBJFileLoader2.OPTIMIZE_WITH_UV = true;
  OBJFileLoader2.INVERT_Y = false;
  OBJFileLoader2.IMPORT_VERTEX_COLORS = false;
  OBJFileLoader2.COMPUTE_NORMALS = false;
  OBJFileLoader2.UV_SCALING = new Vector2(1, 1);
  OBJFileLoader2.SKIP_MATERIALS = false;
  OBJFileLoader2.MATERIAL_LOADING_FAILS_SILENTLY = true;
  return OBJFileLoader2;
}();
if (SceneLoader) {
  SceneLoader.RegisterPlugin(new OBJFileLoader());
}

// node_modules/@babylonjs/loaders/STL/stlFileLoader.js
var STLFileLoader = function() {
  function STLFileLoader2() {
    this.solidPattern = /solid (\S*)([\S\s]*?)endsolid[ ]*(\S*)/g;
    this.facetsPattern = /facet([\s\S]*?)endfacet/g;
    this.normalPattern = /normal[\s]+([\-+]?[0-9]+\.?[0-9]*([eE][\-+]?[0-9]+)?)+[\s]+([\-+]?[0-9]*\.?[0-9]+([eE][\-+]?[0-9]+)?)+[\s]+([\-+]?[0-9]*\.?[0-9]+([eE][\-+]?[0-9]+)?)+/g;
    this.vertexPattern = /vertex[\s]+([\-+]?[0-9]+\.?[0-9]*([eE][\-+]?[0-9]+)?)+[\s]+([\-+]?[0-9]*\.?[0-9]+([eE][\-+]?[0-9]+)?)+[\s]+([\-+]?[0-9]*\.?[0-9]+([eE][\-+]?[0-9]+)?)+/g;
    this.name = "stl";
    this.extensions = {
      ".stl": { isBinary: true }
    };
  }
  STLFileLoader2.prototype.importMesh = function(meshesNames, scene, data, rootUrl, meshes, particleSystems, skeletons) {
    var matches;
    if (typeof data !== "string") {
      if (this._isBinary(data)) {
        var babylonMesh = new Mesh("stlmesh", scene);
        this._parseBinary(babylonMesh, data);
        if (meshes) {
          meshes.push(babylonMesh);
        }
        return true;
      }
      var array_buffer = new Uint8Array(data);
      var str = "";
      for (var i = 0; i < data.byteLength; i++) {
        str += String.fromCharCode(array_buffer[i]);
      }
      data = str;
    }
    while (matches = this.solidPattern.exec(data)) {
      var meshName = matches[1];
      var meshNameFromEnd = matches[3];
      if (meshName != meshNameFromEnd) {
        Tools.Error("Error in STL, solid name != endsolid name");
        return false;
      }
      if (meshesNames && meshName) {
        if (meshesNames instanceof Array) {
          if (!meshesNames.indexOf(meshName)) {
            continue;
          }
        } else {
          if (meshName !== meshesNames) {
            continue;
          }
        }
      }
      meshName = meshName || "stlmesh";
      var babylonMesh = new Mesh(meshName, scene);
      this._parseASCII(babylonMesh, matches[2]);
      if (meshes) {
        meshes.push(babylonMesh);
      }
    }
    return true;
  };
  STLFileLoader2.prototype.load = function(scene, data, rootUrl) {
    var result = this.importMesh(null, scene, data, rootUrl, null, null, null);
    return result;
  };
  STLFileLoader2.prototype.loadAssetContainer = function(scene, data, rootUrl, onError) {
    var container = new AssetContainer(scene);
    scene._blockEntityCollection = true;
    this.importMesh(null, scene, data, rootUrl, container.meshes, null, null);
    scene._blockEntityCollection = false;
    return container;
  };
  STLFileLoader2.prototype._isBinary = function(data) {
    var faceSize, nFaces, reader;
    reader = new DataView(data);
    faceSize = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;
    nFaces = reader.getUint32(80, true);
    if (80 + 32 / 8 + nFaces * faceSize === reader.byteLength) {
      return true;
    }
    var fileLength = reader.byteLength;
    for (var index = 0; index < fileLength; index++) {
      if (reader.getUint8(index) > 127) {
        return true;
      }
    }
    return false;
  };
  STLFileLoader2.prototype._parseBinary = function(mesh, data) {
    var reader = new DataView(data);
    var faces = reader.getUint32(80, true);
    var dataOffset = 84;
    var faceLength = 12 * 4 + 2;
    var offset = 0;
    var positions = new Float32Array(faces * 3 * 3);
    var normals = new Float32Array(faces * 3 * 3);
    var indices = new Uint32Array(faces * 3);
    var indicesCount = 0;
    for (var face = 0; face < faces; face++) {
      var start = dataOffset + face * faceLength;
      var normalX = reader.getFloat32(start, true);
      var normalY = reader.getFloat32(start + 4, true);
      var normalZ = reader.getFloat32(start + 8, true);
      for (var i = 1; i <= 3; i++) {
        var vertexstart = start + i * 12;
        positions[offset] = reader.getFloat32(vertexstart, true);
        positions[offset + 2] = reader.getFloat32(vertexstart + 4, true);
        positions[offset + 1] = reader.getFloat32(vertexstart + 8, true);
        normals[offset] = normalX;
        normals[offset + 2] = normalY;
        normals[offset + 1] = normalZ;
        offset += 3;
      }
      indices[indicesCount] = indicesCount++;
      indices[indicesCount] = indicesCount++;
      indices[indicesCount] = indicesCount++;
    }
    mesh.setVerticesData(VertexBuffer.PositionKind, positions);
    mesh.setVerticesData(VertexBuffer.NormalKind, normals);
    mesh.setIndices(indices);
    mesh.computeWorldMatrix(true);
  };
  STLFileLoader2.prototype._parseASCII = function(mesh, solidData) {
    var positions = [];
    var normals = [];
    var indices = [];
    var indicesCount = 0;
    var matches;
    while (matches = this.facetsPattern.exec(solidData)) {
      var facet = matches[1];
      var normalMatches = this.normalPattern.exec(facet);
      this.normalPattern.lastIndex = 0;
      if (!normalMatches) {
        continue;
      }
      var normal = [Number(normalMatches[1]), Number(normalMatches[5]), Number(normalMatches[3])];
      var vertexMatch;
      while (vertexMatch = this.vertexPattern.exec(facet)) {
        positions.push(Number(vertexMatch[1]), Number(vertexMatch[5]), Number(vertexMatch[3]));
        normals.push(normal[0], normal[1], normal[2]);
      }
      indices.push(indicesCount++, indicesCount++, indicesCount++);
      this.vertexPattern.lastIndex = 0;
    }
    this.facetsPattern.lastIndex = 0;
    mesh.setVerticesData(VertexBuffer.PositionKind, positions);
    mesh.setVerticesData(VertexBuffer.NormalKind, normals);
    mesh.setIndices(indices);
    mesh.computeWorldMatrix(true);
  };
  return STLFileLoader2;
}();
if (SceneLoader) {
  SceneLoader.RegisterPlugin(new STLFileLoader());
}
export {
  __exports as GLTF1,
  __exports2 as GLTF2,
  GLTFFileLoader,
  GLTFLoaderAnimationStartMode,
  GLTFLoaderCoordinateSystemMode,
  GLTFLoaderState,
  GLTFValidation,
  MTLFileLoader,
  OBJFileLoader,
  STLFileLoader
};
//# sourceMappingURL=@babylonjs_loaders.js.map
