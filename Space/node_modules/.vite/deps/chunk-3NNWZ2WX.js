import {
  CanvasGenerator,
  Color3,
  Color4,
  Effect,
  EngineStore,
  HemisphericLight,
  InternalTexture,
  InternalTextureSource,
  Logger,
  Material,
  Mesh,
  Observable,
  PointerEventTypes,
  PointerInfo,
  Scene,
  SceneComponentConstants,
  Texture,
  ThinEngine,
  Vector2,
  Vector3,
  Vector4,
  VertexBuffer,
  VertexData,
  __extends
} from "./chunk-FSGEGJV4.js";

// node_modules/@babylonjs/core/Behaviors/Meshes/fadeInOutBehavior.js
var FadeInOutBehavior = function() {
  function FadeInOutBehavior2() {
    var _this = this;
    this.delay = 0;
    this.fadeInTime = 300;
    this._millisecondsPerFrame = 1e3 / 60;
    this._hovered = false;
    this._hoverValue = 0;
    this._ownerNode = null;
    this._update = function() {
      if (_this._ownerNode) {
        _this._hoverValue += _this._hovered ? _this._millisecondsPerFrame : -_this._millisecondsPerFrame;
        _this._setAllVisibility(_this._ownerNode, (_this._hoverValue - _this.delay) / _this.fadeInTime);
        if (_this._ownerNode.visibility > 1) {
          _this._setAllVisibility(_this._ownerNode, 1);
          _this._hoverValue = _this.fadeInTime + _this.delay;
          return;
        } else if (_this._ownerNode.visibility < 0) {
          _this._setAllVisibility(_this._ownerNode, 0);
          if (_this._hoverValue < 0) {
            _this._hoverValue = 0;
            return;
          }
        }
        setTimeout(_this._update, _this._millisecondsPerFrame);
      }
    };
  }
  Object.defineProperty(FadeInOutBehavior2.prototype, "name", {
    get: function() {
      return "FadeInOut";
    },
    enumerable: false,
    configurable: true
  });
  FadeInOutBehavior2.prototype.init = function() {
  };
  FadeInOutBehavior2.prototype.attach = function(ownerNode) {
    this._ownerNode = ownerNode;
    this._setAllVisibility(this._ownerNode, 0);
  };
  FadeInOutBehavior2.prototype.detach = function() {
    this._ownerNode = null;
  };
  FadeInOutBehavior2.prototype.fadeIn = function(value) {
    this._hovered = value;
    this._update();
  };
  FadeInOutBehavior2.prototype._setAllVisibility = function(mesh, value) {
    var _this = this;
    mesh.visibility = value;
    mesh.getChildMeshes().forEach(function(c) {
      _this._setAllVisibility(c, value);
    });
  };
  return FadeInOutBehavior2;
}();

// node_modules/@babylonjs/core/Meshes/Builders/planeBuilder.js
VertexData.CreatePlane = function(options) {
  var indices = [];
  var positions = [];
  var normals = [];
  var uvs = [];
  var width = options.width || options.size || 1;
  var height = options.height || options.size || 1;
  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  var halfWidth = width / 2;
  var halfHeight = height / 2;
  positions.push(-halfWidth, -halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(0, 0);
  positions.push(halfWidth, -halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(1, 0);
  positions.push(halfWidth, halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(1, 1);
  positions.push(-halfWidth, halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(0, 1);
  indices.push(0);
  indices.push(1);
  indices.push(2);
  indices.push(0);
  indices.push(2);
  indices.push(3);
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  var vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
};
Mesh.CreatePlane = function(name3, size, scene, updatable, sideOrientation) {
  var options = {
    size,
    width: size,
    height: size,
    sideOrientation,
    updatable
  };
  return PlaneBuilder.CreatePlane(name3, options, scene);
};
var PlaneBuilder = function() {
  function PlaneBuilder2() {
  }
  PlaneBuilder2.CreatePlane = function(name3, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    var plane = new Mesh(name3, scene);
    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
    plane._originalBuilderSideOrientation = options.sideOrientation;
    var vertexData = VertexData.CreatePlane(options);
    vertexData.applyToMesh(plane, options.updatable);
    if (options.sourcePlane) {
      plane.translate(options.sourcePlane.normal, -options.sourcePlane.d);
      plane.setDirection(options.sourcePlane.normal.scale(-1));
    }
    return plane;
  };
  return PlaneBuilder2;
}();

// node_modules/@babylonjs/core/Engines/Extensions/engine.dynamicTexture.js
ThinEngine.prototype.createDynamicTexture = function(width, height, generateMipMaps, samplingMode) {
  var texture = new InternalTexture(this, InternalTextureSource.Dynamic);
  texture.baseWidth = width;
  texture.baseHeight = height;
  if (generateMipMaps) {
    width = this.needPOTTextures ? ThinEngine.GetExponentOfTwo(width, this._caps.maxTextureSize) : width;
    height = this.needPOTTextures ? ThinEngine.GetExponentOfTwo(height, this._caps.maxTextureSize) : height;
  }
  texture.width = width;
  texture.height = height;
  texture.isReady = false;
  texture.generateMipMaps = generateMipMaps;
  texture.samplingMode = samplingMode;
  this.updateTextureSamplingMode(samplingMode, texture);
  this._internalTexturesCache.push(texture);
  return texture;
};
ThinEngine.prototype.updateDynamicTexture = function(texture, source, invertY, premulAlpha, format, forceBindTexture) {
  if (premulAlpha === void 0) {
    premulAlpha = false;
  }
  if (forceBindTexture === void 0) {
    forceBindTexture = false;
  }
  if (!texture) {
    return;
  }
  var gl = this._gl;
  var target = gl.TEXTURE_2D;
  var wasPreviouslyBound = this._bindTextureDirectly(target, texture, true, forceBindTexture);
  this._unpackFlipY(invertY === void 0 ? texture.invertY : invertY);
  if (premulAlpha) {
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
  }
  var textureType = this._getWebGLTextureType(texture.type);
  var glformat = this._getInternalFormat(format ? format : texture.format);
  var internalFormat = this._getRGBABufferInternalSizedFormat(texture.type, glformat);
  gl.texImage2D(target, 0, internalFormat, glformat, textureType, source);
  if (texture.generateMipMaps) {
    gl.generateMipmap(target);
  }
  if (!wasPreviouslyBound) {
    this._bindTextureDirectly(target, null);
  }
  if (premulAlpha) {
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
  }
  texture.isReady = true;
};

// node_modules/@babylonjs/core/Materials/Textures/dynamicTexture.js
var DynamicTexture = function(_super) {
  __extends(DynamicTexture2, _super);
  function DynamicTexture2(name3, options, scene, generateMipMaps, samplingMode, format, invertY) {
    if (scene === void 0) {
      scene = null;
    }
    if (samplingMode === void 0) {
      samplingMode = 3;
    }
    if (format === void 0) {
      format = 5;
    }
    var _this = _super.call(this, null, scene, !generateMipMaps, invertY, samplingMode, void 0, void 0, void 0, void 0, format) || this;
    _this.name = name3;
    _this.wrapU = Texture.CLAMP_ADDRESSMODE;
    _this.wrapV = Texture.CLAMP_ADDRESSMODE;
    _this._generateMipMaps = generateMipMaps;
    var engine = _this._getEngine();
    if (!engine) {
      return _this;
    }
    if (options.getContext) {
      _this._canvas = options;
      _this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);
    } else {
      _this._canvas = CanvasGenerator.CreateCanvas(1, 1);
      if (options.width || options.width === 0) {
        _this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);
      } else {
        _this._texture = engine.createDynamicTexture(options, options, generateMipMaps, samplingMode);
      }
    }
    var textureSize = _this.getSize();
    _this._canvas.width = textureSize.width;
    _this._canvas.height = textureSize.height;
    _this._context = _this._canvas.getContext("2d");
    return _this;
  }
  DynamicTexture2.prototype.getClassName = function() {
    return "DynamicTexture";
  };
  Object.defineProperty(DynamicTexture2.prototype, "canRescale", {
    get: function() {
      return true;
    },
    enumerable: false,
    configurable: true
  });
  DynamicTexture2.prototype._recreate = function(textureSize) {
    this._canvas.width = textureSize.width;
    this._canvas.height = textureSize.height;
    this.releaseInternalTexture();
    this._texture = this._getEngine().createDynamicTexture(textureSize.width, textureSize.height, this._generateMipMaps, this.samplingMode);
  };
  DynamicTexture2.prototype.scale = function(ratio) {
    var textureSize = this.getSize();
    textureSize.width *= ratio;
    textureSize.height *= ratio;
    this._recreate(textureSize);
  };
  DynamicTexture2.prototype.scaleTo = function(width, height) {
    var textureSize = this.getSize();
    textureSize.width = width;
    textureSize.height = height;
    this._recreate(textureSize);
  };
  DynamicTexture2.prototype.getContext = function() {
    return this._context;
  };
  DynamicTexture2.prototype.clear = function() {
    var size = this.getSize();
    this._context.fillRect(0, 0, size.width, size.height);
  };
  DynamicTexture2.prototype.update = function(invertY, premulAlpha) {
    if (premulAlpha === void 0) {
      premulAlpha = false;
    }
    this._getEngine().updateDynamicTexture(this._texture, this._canvas, invertY === void 0 ? true : invertY, premulAlpha, this._format || void 0);
  };
  DynamicTexture2.prototype.drawText = function(text, x, y, font, color, clearColor, invertY, update) {
    if (update === void 0) {
      update = true;
    }
    var size = this.getSize();
    if (clearColor) {
      this._context.fillStyle = clearColor;
      this._context.fillRect(0, 0, size.width, size.height);
    }
    this._context.font = font;
    if (x === null || x === void 0) {
      var textSize = this._context.measureText(text);
      x = (size.width - textSize.width) / 2;
    }
    if (y === null || y === void 0) {
      var fontSize = parseInt(font.replace(/\D/g, ""));
      y = size.height / 2 + fontSize / 3.65;
    }
    this._context.fillStyle = color || "";
    this._context.fillText(text, x, y);
    if (update) {
      this.update(invertY);
    }
  };
  DynamicTexture2.prototype.clone = function() {
    var scene = this.getScene();
    if (!scene) {
      return this;
    }
    var textureSize = this.getSize();
    var newTexture = new DynamicTexture2(this.name, textureSize, scene, this._generateMipMaps);
    newTexture.hasAlpha = this.hasAlpha;
    newTexture.level = this.level;
    newTexture.wrapU = this.wrapU;
    newTexture.wrapV = this.wrapV;
    return newTexture;
  };
  DynamicTexture2.prototype.serialize = function() {
    var scene = this.getScene();
    if (scene && !scene.isReady()) {
      Logger.Warn("The scene must be ready before serializing the dynamic texture");
    }
    var serializationObject = _super.prototype.serialize.call(this);
    if (this._IsCanvasElement(this._canvas)) {
      serializationObject.base64String = this._canvas.toDataURL();
    }
    serializationObject.invertY = this._invertY;
    serializationObject.samplingMode = this.samplingMode;
    return serializationObject;
  };
  DynamicTexture2.prototype._IsCanvasElement = function(canvas) {
    return canvas.toDataURL !== void 0;
  };
  DynamicTexture2.prototype._rebuild = function() {
    this.update();
  };
  return DynamicTexture2;
}(Texture);

// node_modules/@babylonjs/core/Rendering/utilityLayerRenderer.js
var UtilityLayerRenderer = function() {
  function UtilityLayerRenderer2(originalScene, handleEvents) {
    var _this = this;
    if (handleEvents === void 0) {
      handleEvents = true;
    }
    this.originalScene = originalScene;
    this._pointerCaptures = {};
    this._lastPointerEvents = {};
    this._sharedGizmoLight = null;
    this._renderCamera = null;
    this.pickUtilitySceneFirst = true;
    this.shouldRender = true;
    this.onlyCheckPointerDownEvents = true;
    this.processAllEvents = false;
    this.onPointerOutObservable = new Observable();
    this.utilityLayerScene = new Scene(originalScene.getEngine(), { virtual: true });
    this.utilityLayerScene.useRightHandedSystem = originalScene.useRightHandedSystem;
    this.utilityLayerScene._allowPostProcessClearColor = false;
    this.utilityLayerScene.detachControl();
    if (handleEvents) {
      this._originalPointerObserver = originalScene.onPrePointerObservable.add(function(prePointerInfo, eventState) {
        if (!_this.utilityLayerScene.activeCamera) {
          return;
        }
        if (!_this.processAllEvents) {
          if (prePointerInfo.type !== PointerEventTypes.POINTERMOVE && prePointerInfo.type !== PointerEventTypes.POINTERUP && prePointerInfo.type !== PointerEventTypes.POINTERDOWN && prePointerInfo.type !== PointerEventTypes.POINTERDOUBLETAP) {
            return;
          }
        }
        _this.utilityLayerScene.pointerX = originalScene.pointerX;
        _this.utilityLayerScene.pointerY = originalScene.pointerY;
        var pointerEvent = prePointerInfo.event;
        if (originalScene.isPointerCaptured(pointerEvent.pointerId)) {
          _this._pointerCaptures[pointerEvent.pointerId] = false;
          return;
        }
        var utilityScenePick = prePointerInfo.ray ? _this.utilityLayerScene.pickWithRay(prePointerInfo.ray) : _this.utilityLayerScene.pick(originalScene.pointerX, originalScene.pointerY);
        if (!prePointerInfo.ray && utilityScenePick) {
          prePointerInfo.ray = utilityScenePick.ray;
        }
        _this.utilityLayerScene.onPrePointerObservable.notifyObservers(prePointerInfo);
        if (_this.onlyCheckPointerDownEvents && prePointerInfo.type != PointerEventTypes.POINTERDOWN) {
          if (!prePointerInfo.skipOnPointerObservable) {
            _this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);
          }
          if (prePointerInfo.type === PointerEventTypes.POINTERUP && _this._pointerCaptures[pointerEvent.pointerId]) {
            _this._pointerCaptures[pointerEvent.pointerId] = false;
          }
          return;
        }
        if (_this.utilityLayerScene.autoClearDepthAndStencil || _this.pickUtilitySceneFirst) {
          if (utilityScenePick && utilityScenePick.hit) {
            if (!prePointerInfo.skipOnPointerObservable) {
              _this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);
            }
            prePointerInfo.skipOnPointerObservable = true;
          }
        } else {
          var originalScenePick = prePointerInfo.ray ? originalScene.pickWithRay(prePointerInfo.ray) : originalScene.pick(originalScene.pointerX, originalScene.pointerY);
          var pointerEvent_1 = prePointerInfo.event;
          if (originalScenePick && utilityScenePick) {
            if (utilityScenePick.distance === 0 && originalScenePick.pickedMesh) {
              if (_this.mainSceneTrackerPredicate && _this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {
                _this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent_1);
                prePointerInfo.skipOnPointerObservable = true;
              } else if (prePointerInfo.type === PointerEventTypes.POINTERDOWN) {
                _this._pointerCaptures[pointerEvent_1.pointerId] = true;
              } else if (_this._lastPointerEvents[pointerEvent_1.pointerId]) {
                _this.onPointerOutObservable.notifyObservers(pointerEvent_1.pointerId);
                delete _this._lastPointerEvents[pointerEvent_1.pointerId];
              }
            } else if (!_this._pointerCaptures[pointerEvent_1.pointerId] && (utilityScenePick.distance < originalScenePick.distance || originalScenePick.distance === 0)) {
              _this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent_1);
              if (!prePointerInfo.skipOnPointerObservable) {
                prePointerInfo.skipOnPointerObservable = utilityScenePick.distance > 0;
              }
            } else if (!_this._pointerCaptures[pointerEvent_1.pointerId] && utilityScenePick.distance > originalScenePick.distance) {
              if (_this.mainSceneTrackerPredicate && _this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {
                _this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent_1);
                prePointerInfo.skipOnPointerObservable = true;
              } else if (_this._lastPointerEvents[pointerEvent_1.pointerId]) {
                _this.onPointerOutObservable.notifyObservers(pointerEvent_1.pointerId);
                delete _this._lastPointerEvents[pointerEvent_1.pointerId];
              }
            }
            if (prePointerInfo.type === PointerEventTypes.POINTERUP && _this._pointerCaptures[pointerEvent_1.pointerId]) {
              _this._pointerCaptures[pointerEvent_1.pointerId] = false;
            }
          }
        }
      });
      if (this._originalPointerObserver) {
        originalScene.onPrePointerObservable.makeObserverTopPriority(this._originalPointerObserver);
      }
    }
    this.utilityLayerScene.autoClear = false;
    this._afterRenderObserver = this.originalScene.onAfterCameraRenderObservable.add(function(camera) {
      if (_this.shouldRender && camera == _this.getRenderCamera()) {
        _this.render();
      }
    });
    this._sceneDisposeObserver = this.originalScene.onDisposeObservable.add(function() {
      _this.dispose();
    });
    this._updateCamera();
  }
  UtilityLayerRenderer2.prototype.getRenderCamera = function(getRigParentIfPossible) {
    if (this._renderCamera) {
      return this._renderCamera;
    } else {
      var activeCam = void 0;
      if (this.originalScene.activeCameras && this.originalScene.activeCameras.length > 1) {
        activeCam = this.originalScene.activeCameras[this.originalScene.activeCameras.length - 1];
      } else {
        activeCam = this.originalScene.activeCamera;
      }
      if (getRigParentIfPossible && activeCam && activeCam.isRigCamera) {
        return activeCam.rigParent;
      }
      return activeCam;
    }
  };
  UtilityLayerRenderer2.prototype.setRenderCamera = function(cam) {
    this._renderCamera = cam;
  };
  UtilityLayerRenderer2.prototype._getSharedGizmoLight = function() {
    if (!this._sharedGizmoLight) {
      this._sharedGizmoLight = new HemisphericLight("shared gizmo light", new Vector3(0, 1, 0), this.utilityLayerScene);
      this._sharedGizmoLight.intensity = 2;
      this._sharedGizmoLight.groundColor = Color3.Gray();
    }
    return this._sharedGizmoLight;
  };
  Object.defineProperty(UtilityLayerRenderer2, "DefaultUtilityLayer", {
    get: function() {
      if (UtilityLayerRenderer2._DefaultUtilityLayer == null) {
        UtilityLayerRenderer2._DefaultUtilityLayer = new UtilityLayerRenderer2(EngineStore.LastCreatedScene);
        UtilityLayerRenderer2._DefaultUtilityLayer.originalScene.onDisposeObservable.addOnce(function() {
          UtilityLayerRenderer2._DefaultUtilityLayer = null;
        });
      }
      return UtilityLayerRenderer2._DefaultUtilityLayer;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(UtilityLayerRenderer2, "DefaultKeepDepthUtilityLayer", {
    get: function() {
      if (UtilityLayerRenderer2._DefaultKeepDepthUtilityLayer == null) {
        UtilityLayerRenderer2._DefaultKeepDepthUtilityLayer = new UtilityLayerRenderer2(EngineStore.LastCreatedScene);
        UtilityLayerRenderer2._DefaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;
        UtilityLayerRenderer2._DefaultKeepDepthUtilityLayer.originalScene.onDisposeObservable.addOnce(function() {
          UtilityLayerRenderer2._DefaultKeepDepthUtilityLayer = null;
        });
      }
      return UtilityLayerRenderer2._DefaultKeepDepthUtilityLayer;
    },
    enumerable: false,
    configurable: true
  });
  UtilityLayerRenderer2.prototype._notifyObservers = function(prePointerInfo, pickInfo, pointerEvent) {
    if (!prePointerInfo.skipOnPointerObservable) {
      this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, pickInfo), prePointerInfo.type);
      this._lastPointerEvents[pointerEvent.pointerId] = true;
    }
  };
  UtilityLayerRenderer2.prototype.render = function() {
    this._updateCamera();
    if (this.utilityLayerScene.activeCamera) {
      var oldScene = this.utilityLayerScene.activeCamera.getScene();
      var camera = this.utilityLayerScene.activeCamera;
      camera._scene = this.utilityLayerScene;
      if (camera.leftCamera) {
        camera.leftCamera._scene = this.utilityLayerScene;
      }
      if (camera.rightCamera) {
        camera.rightCamera._scene = this.utilityLayerScene;
      }
      this.utilityLayerScene.render(false);
      camera._scene = oldScene;
      if (camera.leftCamera) {
        camera.leftCamera._scene = oldScene;
      }
      if (camera.rightCamera) {
        camera.rightCamera._scene = oldScene;
      }
    }
  };
  UtilityLayerRenderer2.prototype.dispose = function() {
    this.onPointerOutObservable.clear();
    if (this._afterRenderObserver) {
      this.originalScene.onAfterCameraRenderObservable.remove(this._afterRenderObserver);
    }
    if (this._sceneDisposeObserver) {
      this.originalScene.onDisposeObservable.remove(this._sceneDisposeObserver);
    }
    if (this._originalPointerObserver) {
      this.originalScene.onPrePointerObservable.remove(this._originalPointerObserver);
    }
    this.utilityLayerScene.dispose();
  };
  UtilityLayerRenderer2.prototype._updateCamera = function() {
    this.utilityLayerScene.cameraToUseForPointers = this.getRenderCamera();
    this.utilityLayerScene.activeCamera = this.getRenderCamera();
  };
  UtilityLayerRenderer2._DefaultUtilityLayer = null;
  UtilityLayerRenderer2._DefaultKeepDepthUtilityLayer = null;
  return UtilityLayerRenderer2;
}();

// node_modules/@babylonjs/core/Meshes/Builders/boxBuilder.js
VertexData.CreateBox = function(options) {
  var nbFaces = 6;
  var indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];
  var normals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0];
  var uvs = [];
  var positions = [];
  var width = options.width || options.size || 1;
  var height = options.height || options.size || 1;
  var depth = options.depth || options.size || 1;
  var wrap = options.wrap || false;
  var topBaseAt = options.topBaseAt === void 0 ? 1 : options.topBaseAt;
  var bottomBaseAt = options.bottomBaseAt === void 0 ? 0 : options.bottomBaseAt;
  topBaseAt = (topBaseAt + 4) % 4;
  bottomBaseAt = (bottomBaseAt + 4) % 4;
  var topOrder = [2, 0, 3, 1];
  var bottomOrder = [2, 0, 1, 3];
  var topIndex = topOrder[topBaseAt];
  var bottomIndex = bottomOrder[bottomBaseAt];
  var basePositions = [1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1];
  if (wrap) {
    indices = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14];
    basePositions = [-1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1];
    var topFaceBase = [[1, 1, 1], [-1, 1, 1], [-1, 1, -1], [1, 1, -1]];
    var bottomFaceBase = [[-1, -1, 1], [1, -1, 1], [1, -1, -1], [-1, -1, -1]];
    var topFaceOrder = [17, 18, 19, 16];
    var bottomFaceOrder = [22, 23, 20, 21];
    while (topIndex > 0) {
      topFaceBase.unshift(topFaceBase.pop());
      topFaceOrder.unshift(topFaceOrder.pop());
      topIndex--;
    }
    while (bottomIndex > 0) {
      bottomFaceBase.unshift(bottomFaceBase.pop());
      bottomFaceOrder.unshift(bottomFaceOrder.pop());
      bottomIndex--;
    }
    topFaceBase = topFaceBase.flat();
    bottomFaceBase = bottomFaceBase.flat();
    basePositions = basePositions.concat(topFaceBase).concat(bottomFaceBase);
    indices.push(topFaceOrder[0], topFaceOrder[2], topFaceOrder[3], topFaceOrder[0], topFaceOrder[1], topFaceOrder[2]);
    indices.push(bottomFaceOrder[0], bottomFaceOrder[2], bottomFaceOrder[3], bottomFaceOrder[0], bottomFaceOrder[1], bottomFaceOrder[2]);
  }
  var scaleArray = [width / 2, height / 2, depth / 2];
  positions = basePositions.reduce(function(accumulator, currentValue, currentIndex) {
    return accumulator.concat(currentValue * scaleArray[currentIndex % 3]);
  }, []);
  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  var faceUV = options.faceUV || new Array(6);
  var faceColors = options.faceColors;
  var colors = [];
  for (var f = 0; f < 6; f++) {
    if (faceUV[f] === void 0) {
      faceUV[f] = new Vector4(0, 0, 1, 1);
    }
    if (faceColors && faceColors[f] === void 0) {
      faceColors[f] = new Color4(1, 1, 1, 1);
    }
  }
  for (var index = 0; index < nbFaces; index++) {
    uvs.push(faceUV[index].z, faceUV[index].w);
    uvs.push(faceUV[index].x, faceUV[index].w);
    uvs.push(faceUV[index].x, faceUV[index].y);
    uvs.push(faceUV[index].z, faceUV[index].y);
    if (faceColors) {
      for (var c = 0; c < 4; c++) {
        colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);
      }
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  var vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  if (faceColors) {
    var totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;
    vertexData.colors = totalColors;
  }
  return vertexData;
};
Mesh.CreateBox = function(name3, size, scene, updatable, sideOrientation) {
  if (scene === void 0) {
    scene = null;
  }
  var options = {
    size,
    sideOrientation,
    updatable
  };
  return BoxBuilder.CreateBox(name3, options, scene);
};
var BoxBuilder = function() {
  function BoxBuilder2() {
  }
  BoxBuilder2.CreateBox = function(name3, options, scene) {
    if (scene === void 0) {
      scene = null;
    }
    var box = new Mesh(name3, scene);
    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
    box._originalBuilderSideOrientation = options.sideOrientation;
    var vertexData = VertexData.CreateBox(options);
    vertexData.applyToMesh(box, options.updatable);
    return box;
  };
  return BoxBuilder2;
}();

// node_modules/@babylonjs/core/Events/clipboardEvents.js
var ClipboardEventTypes = function() {
  function ClipboardEventTypes2() {
  }
  ClipboardEventTypes2.COPY = 1;
  ClipboardEventTypes2.CUT = 2;
  ClipboardEventTypes2.PASTE = 3;
  return ClipboardEventTypes2;
}();
var ClipboardInfo = function() {
  function ClipboardInfo2(type, event) {
    this.type = type;
    this.event = event;
  }
  ClipboardInfo2.GetTypeFromCharacter = function(keyCode) {
    var charCode = keyCode;
    switch (charCode) {
      case 67:
        return ClipboardEventTypes.COPY;
      case 86:
        return ClipboardEventTypes.PASTE;
      case 88:
        return ClipboardEventTypes.CUT;
      default:
        return -1;
    }
  };
  return ClipboardInfo2;
}();

// node_modules/@babylonjs/core/Layers/layerSceneComponent.js
var LayerSceneComponent = function() {
  function LayerSceneComponent2(scene) {
    this.name = SceneComponentConstants.NAME_LAYER;
    this.scene = scene;
    this._engine = scene.getEngine();
    scene.layers = new Array();
  }
  LayerSceneComponent2.prototype.register = function() {
    this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_LAYER, this, this._drawCameraBackground);
    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_LAYER, this, this._drawCameraForeground);
    this.scene._beforeRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_LAYER, this, this._drawRenderTargetBackground);
    this.scene._afterRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_LAYER, this, this._drawRenderTargetForeground);
  };
  LayerSceneComponent2.prototype.rebuild = function() {
    var layers = this.scene.layers;
    for (var _i = 0, layers_1 = layers; _i < layers_1.length; _i++) {
      var layer = layers_1[_i];
      layer._rebuild();
    }
  };
  LayerSceneComponent2.prototype.dispose = function() {
    var layers = this.scene.layers;
    while (layers.length) {
      layers[0].dispose();
    }
  };
  LayerSceneComponent2.prototype._draw = function(predicate) {
    var layers = this.scene.layers;
    if (layers.length) {
      this._engine.setDepthBuffer(false);
      for (var _i = 0, layers_2 = layers; _i < layers_2.length; _i++) {
        var layer = layers_2[_i];
        if (predicate(layer)) {
          layer.render();
        }
      }
      this._engine.setDepthBuffer(true);
    }
  };
  LayerSceneComponent2.prototype._drawCameraPredicate = function(layer, isBackground, cameraLayerMask) {
    return !layer.renderOnlyInRenderTargetTextures && layer.isBackground === isBackground && (layer.layerMask & cameraLayerMask) !== 0;
  };
  LayerSceneComponent2.prototype._drawCameraBackground = function(camera) {
    var _this = this;
    this._draw(function(layer) {
      return _this._drawCameraPredicate(layer, true, camera.layerMask);
    });
  };
  LayerSceneComponent2.prototype._drawCameraForeground = function(camera) {
    var _this = this;
    this._draw(function(layer) {
      return _this._drawCameraPredicate(layer, false, camera.layerMask);
    });
  };
  LayerSceneComponent2.prototype._drawRenderTargetPredicate = function(layer, isBackground, cameraLayerMask, renderTargetTexture) {
    return layer.renderTargetTextures.length > 0 && layer.isBackground === isBackground && layer.renderTargetTextures.indexOf(renderTargetTexture) > -1 && (layer.layerMask & cameraLayerMask) !== 0;
  };
  LayerSceneComponent2.prototype._drawRenderTargetBackground = function(renderTarget) {
    var _this = this;
    this._draw(function(layer) {
      return _this._drawRenderTargetPredicate(layer, true, _this.scene.activeCamera.layerMask, renderTarget);
    });
  };
  LayerSceneComponent2.prototype._drawRenderTargetForeground = function(renderTarget) {
    var _this = this;
    this._draw(function(layer) {
      return _this._drawRenderTargetPredicate(layer, false, _this.scene.activeCamera.layerMask, renderTarget);
    });
  };
  LayerSceneComponent2.prototype.addFromContainer = function(container) {
    var _this = this;
    if (!container.layers) {
      return;
    }
    container.layers.forEach(function(layer) {
      _this.scene.layers.push(layer);
    });
  };
  LayerSceneComponent2.prototype.removeFromContainer = function(container, dispose) {
    var _this = this;
    if (dispose === void 0) {
      dispose = false;
    }
    if (!container.layers) {
      return;
    }
    container.layers.forEach(function(layer) {
      var index = _this.scene.layers.indexOf(layer);
      if (index !== -1) {
        _this.scene.layers.splice(index, 1);
      }
      if (dispose) {
        layer.dispose();
      }
    });
  };
  return LayerSceneComponent2;
}();

// node_modules/@babylonjs/core/Shaders/layer.fragment.js
var name = "layerPixelShader";
var shader = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nuniform vec4 color;\n\n#include<helperFunctions>\nvoid main(void) {\nvec4 baseColor=texture2D(textureSampler,vUV);\n#ifdef LINEAR\nbaseColor.rgb=toGammaSpace(baseColor.rgb);\n#endif\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\ngl_FragColor=baseColor*color;\n}";
Effect.ShadersStore[name] = shader;

// node_modules/@babylonjs/core/Shaders/layer.vertex.js
var name2 = "layerVertexShader";
var shader2 = "\nattribute vec2 position;\n\nuniform vec2 scale;\nuniform vec2 offset;\nuniform mat4 textureMatrix;\n\nvarying vec2 vUV;\nconst vec2 madd=vec2(0.5,0.5);\nvoid main(void) {\nvec2 shiftedPosition=position*scale+offset;\nvUV=vec2(textureMatrix*vec4(shiftedPosition*madd+madd,1.0,0.0));\ngl_Position=vec4(shiftedPosition,0.0,1.0);\n}";
Effect.ShadersStore[name2] = shader2;

// node_modules/@babylonjs/core/Layers/layer.js
var Layer = function() {
  function Layer2(name3, imgUrl, scene, isBackground, color) {
    this.name = name3;
    this.scale = new Vector2(1, 1);
    this.offset = new Vector2(0, 0);
    this.alphaBlendingMode = 2;
    this.layerMask = 268435455;
    this.renderTargetTextures = [];
    this.renderOnlyInRenderTargetTextures = false;
    this._vertexBuffers = {};
    this.onDisposeObservable = new Observable();
    this.onBeforeRenderObservable = new Observable();
    this.onAfterRenderObservable = new Observable();
    this.texture = imgUrl ? new Texture(imgUrl, scene, true) : null;
    this.isBackground = isBackground === void 0 ? true : isBackground;
    this.color = color === void 0 ? new Color4(1, 1, 1, 1) : color;
    this._scene = scene || EngineStore.LastCreatedScene;
    var layerComponent = this._scene._getComponent(SceneComponentConstants.NAME_LAYER);
    if (!layerComponent) {
      layerComponent = new LayerSceneComponent(this._scene);
      this._scene._addComponent(layerComponent);
    }
    this._scene.layers.push(this);
    var engine = this._scene.getEngine();
    var vertices = [];
    vertices.push(1, 1);
    vertices.push(-1, 1);
    vertices.push(-1, -1);
    vertices.push(1, -1);
    var vertexBuffer = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2);
    this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;
    this._createIndexBuffer();
  }
  Object.defineProperty(Layer2.prototype, "onDispose", {
    set: function(callback) {
      if (this._onDisposeObserver) {
        this.onDisposeObservable.remove(this._onDisposeObserver);
      }
      this._onDisposeObserver = this.onDisposeObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Layer2.prototype, "onBeforeRender", {
    set: function(callback) {
      if (this._onBeforeRenderObserver) {
        this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
      }
      this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Layer2.prototype, "onAfterRender", {
    set: function(callback) {
      if (this._onAfterRenderObserver) {
        this.onAfterRenderObservable.remove(this._onAfterRenderObserver);
      }
      this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Layer2.prototype._createIndexBuffer = function() {
    var engine = this._scene.getEngine();
    var indices = [];
    indices.push(0);
    indices.push(1);
    indices.push(2);
    indices.push(0);
    indices.push(2);
    indices.push(3);
    this._indexBuffer = engine.createIndexBuffer(indices);
  };
  Layer2.prototype._rebuild = function() {
    var vb = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vb) {
      vb._rebuild();
    }
    this._createIndexBuffer();
  };
  Layer2.prototype.render = function() {
    var engine = this._scene.getEngine();
    var defines = "";
    if (this.alphaTest) {
      defines = "#define ALPHATEST";
    }
    if (this.texture && !this.texture.gammaSpace) {
      defines += "\r\n#define LINEAR";
    }
    if (this._previousDefines !== defines) {
      this._previousDefines = defines;
      this._effect = engine.createEffect("layer", [VertexBuffer.PositionKind], ["textureMatrix", "color", "scale", "offset"], ["textureSampler"], defines);
    }
    var currentEffect = this._effect;
    if (!currentEffect || !currentEffect.isReady() || !this.texture || !this.texture.isReady()) {
      return;
    }
    var engine = this._scene.getEngine();
    this.onBeforeRenderObservable.notifyObservers(this);
    engine.enableEffect(currentEffect);
    engine.setState(false);
    currentEffect.setTexture("textureSampler", this.texture);
    currentEffect.setMatrix("textureMatrix", this.texture.getTextureMatrix());
    currentEffect.setFloat4("color", this.color.r, this.color.g, this.color.b, this.color.a);
    currentEffect.setVector2("offset", this.offset);
    currentEffect.setVector2("scale", this.scale);
    engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect);
    if (!this.alphaTest) {
      engine.setAlphaMode(this.alphaBlendingMode);
      engine.drawElementsType(Material.TriangleFillMode, 0, 6);
      engine.setAlphaMode(0);
    } else {
      engine.drawElementsType(Material.TriangleFillMode, 0, 6);
    }
    this.onAfterRenderObservable.notifyObservers(this);
  };
  Layer2.prototype.dispose = function() {
    var vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vertexBuffer) {
      vertexBuffer.dispose();
      this._vertexBuffers[VertexBuffer.PositionKind] = null;
    }
    if (this._indexBuffer) {
      this._scene.getEngine()._releaseBuffer(this._indexBuffer);
      this._indexBuffer = null;
    }
    if (this.texture) {
      this.texture.dispose();
      this.texture = null;
    }
    this.renderTargetTextures = [];
    var index = this._scene.layers.indexOf(this);
    this._scene.layers.splice(index, 1);
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    this.onAfterRenderObservable.clear();
    this.onBeforeRenderObservable.clear();
  };
  return Layer2;
}();

export {
  FadeInOutBehavior,
  PlaneBuilder,
  DynamicTexture,
  UtilityLayerRenderer,
  BoxBuilder,
  ClipboardEventTypes,
  ClipboardInfo,
  LayerSceneComponent,
  Layer
};
//# sourceMappingURL=chunk-3NNWZ2WX.js.map
