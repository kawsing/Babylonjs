{
  "version": 3,
  "sources": ["../../sourceES6/core/Behaviors/Meshes/fadeInOutBehavior.ts", "../../sourceES6/core/Meshes/Builders/planeBuilder.ts", "../../sourceES6/core/Engines/Extensions/engine.dynamicTexture.ts", "../../sourceES6/core/Materials/Textures/dynamicTexture.ts", "../../sourceES6/core/Rendering/utilityLayerRenderer.ts", "../../sourceES6/core/Meshes/Builders/boxBuilder.ts", "../../sourceES6/core/Events/clipboardEvents.ts", "../../sourceES6/core/Layers/layerSceneComponent.ts", "../../sourceES6/core/Shaders/layer.fragment.ts", "../../sourceES6/core/Shaders/layer.vertex.ts", "../../sourceES6/core/Layers/layer.ts"],
  "sourcesContent": ["import { Behavior } from \"../behavior\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport { Nullable } from \"../../types\";\r\n\r\n/**\r\n * A behavior that when attached to a mesh will allow the mesh to fade in and out\r\n */\r\nexport class FadeInOutBehavior implements Behavior<Mesh> {\r\n    /**\r\n     * Time in milliseconds to delay before fading in (Default: 0)\r\n     */\r\n    public delay = 0;\r\n    /**\r\n     * Time in milliseconds for the mesh to fade in (Default: 300)\r\n     */\r\n    public fadeInTime = 300;\r\n\r\n    private _millisecondsPerFrame = 1000 / 60;\r\n    private _hovered = false;\r\n    private _hoverValue = 0;\r\n    private _ownerNode: Nullable<Mesh> = null;\r\n\r\n    /**\r\n     * Instatiates the FadeInOutBehavior\r\n     */\r\n    constructor() {\r\n    }\r\n\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"FadeInOut\";\r\n    }\r\n\r\n    /**\r\n     *  Initializes the behavior\r\n     */\r\n    public init() {\r\n    }\r\n\r\n    /**\r\n     * Attaches the fade behavior on the passed in mesh\r\n     * @param ownerNode The mesh that will be faded in/out once attached\r\n     */\r\n    public attach(ownerNode: Mesh): void {\r\n        this._ownerNode = ownerNode;\r\n        this._setAllVisibility(this._ownerNode, 0);\r\n    }\r\n    /**\r\n     *  Detaches the behavior from the mesh\r\n     */\r\n    public detach(): void {\r\n        this._ownerNode = null;\r\n    }\r\n\r\n    /**\r\n     * Triggers the mesh to begin fading in or out\r\n     * @param value if the object should fade in or out (true to fade in)\r\n     */\r\n    public fadeIn(value: boolean) {\r\n        this._hovered = value;\r\n        this._update();\r\n    }\r\n\r\n    private _update = () => {\r\n        if (this._ownerNode) {\r\n            this._hoverValue += this._hovered ? this._millisecondsPerFrame : -this._millisecondsPerFrame;\r\n\r\n            this._setAllVisibility(this._ownerNode, (this._hoverValue - this.delay) / this.fadeInTime);\r\n\r\n            if (this._ownerNode.visibility > 1) {\r\n                this._setAllVisibility(this._ownerNode, 1);\r\n                this._hoverValue = this.fadeInTime + this.delay;\r\n                return;\r\n            } else if (this._ownerNode.visibility < 0) {\r\n                this._setAllVisibility(this._ownerNode, 0);\r\n                if (this._hoverValue < 0) {\r\n                    this._hoverValue = 0;\r\n                    return;\r\n                }\r\n            }\r\n            setTimeout(this._update, this._millisecondsPerFrame);\r\n        }\r\n    }\r\n\r\n    private _setAllVisibility(mesh: AbstractMesh, value: number) {\r\n        mesh.visibility = value;\r\n        mesh.getChildMeshes().forEach((c) => {\r\n            this._setAllVisibility(c, value);\r\n        });\r\n    }\r\n\r\n}\r\n", "import { Scene } from \"../../scene\";\r\nimport { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { Nullable } from '../../types';\r\nimport { Plane } from '../../Maths/math.plane';\r\n\r\nVertexData.CreatePlane = function(options: { size?: number, width?: number, height?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n    var indices = [];\r\n    var positions = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n\r\n    var width: number = options.width || options.size || 1;\r\n    var height: number = options.height || options.size || 1;\r\n    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // Vertices\r\n    var halfWidth = width / 2.0;\r\n    var halfHeight = height / 2.0;\r\n\r\n    positions.push(-halfWidth, -halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(0.0, 0.0);\r\n\r\n    positions.push(halfWidth, -halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(1.0, 0.0);\r\n\r\n    positions.push(halfWidth, halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(1.0, 1.0);\r\n\r\n    positions.push(-halfWidth, halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(0.0, 1.0);\r\n\r\n    // Indices\r\n    indices.push(0);\r\n    indices.push(1);\r\n    indices.push(2);\r\n\r\n    indices.push(0);\r\n    indices.push(2);\r\n    indices.push(3);\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    var vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n};\r\n\r\nMesh.CreatePlane = (name: string, size: number, scene: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    var options = {\r\n        size: size,\r\n        width: size,\r\n        height: size,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable\r\n    };\r\n\r\n    return PlaneBuilder.CreatePlane(name, options, scene);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class PlaneBuilder {\r\n    /**\r\n     * Creates a plane mesh\r\n     * * The parameter `size` sets the size (float) of both sides of the plane at once (default 1)\r\n     * * You can set some different plane dimensions by using the parameters `width` and `height` (both by default have the same value of `size`)\r\n     * * The parameter `sourcePlane` is a Plane instance. It builds a mesh plane from a Math plane\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the plane mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#plane\r\n     */\r\n    public static CreatePlane(name: string, options: { size?: number, width?: number, height?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, updatable?: boolean, sourcePlane?: Plane }, scene: Nullable<Scene> = null): Mesh {\r\n        var plane = new Mesh(name, scene);\r\n\r\n        options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        plane._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n        var vertexData = VertexData.CreatePlane(options);\r\n\r\n        vertexData.applyToMesh(plane, options.updatable);\r\n\r\n        if (options.sourcePlane) {\r\n            plane.translate(options.sourcePlane.normal, -options.sourcePlane.d);\r\n            plane.setDirection(options.sourcePlane.normal.scale(-1));\r\n        }\r\n\r\n        return plane;\r\n    }\r\n}", "import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { InternalTexture, InternalTextureSource } from '../../Materials/Textures/internalTexture';\r\nimport { Nullable } from '../../types';\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Creates a dynamic texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param generateMipMaps defines if the engine should generate the mip levels\r\n         * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n         * @returns the dynamic texture inside an InternalTexture\r\n         */\r\n        createDynamicTexture(width: number, height: number, generateMipMaps: boolean, samplingMode: number): InternalTexture;\r\n\r\n        /**\r\n         * Update the content of a dynamic texture\r\n         * @param texture defines the texture to update\r\n         * @param source defines the source containing the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param premulAlpha defines if alpha is stored as premultiplied\r\n         * @param format defines the format of the data\r\n         * @param forceBindTexture if the texture should be forced to be bound eg. after a graphics context loss (Default: false)\r\n         */\r\n        updateDynamicTexture(texture: Nullable<InternalTexture>,\r\n            source: ImageBitmap | ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | OffscreenCanvas,\r\n            invertY?: boolean, premulAlpha?: boolean, format?: number, forceBindTexture?: boolean): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.createDynamicTexture = function(width: number, height: number, generateMipMaps: boolean, samplingMode: number): InternalTexture {\r\n    var texture = new InternalTexture(this, InternalTextureSource.Dynamic);\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n\r\n    if (generateMipMaps) {\r\n        width = this.needPOTTextures ? ThinEngine.GetExponentOfTwo(width, this._caps.maxTextureSize) : width;\r\n        height = this.needPOTTextures ? ThinEngine.GetExponentOfTwo(height, this._caps.maxTextureSize) : height;\r\n    }\r\n\r\n    //  this.resetTextureCache();\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.isReady = false;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n\r\n    this.updateTextureSamplingMode(samplingMode, texture);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.updateDynamicTexture = function(texture: Nullable<InternalTexture>,\r\n    source: ImageBitmap | ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | OffscreenCanvas,\r\n    invertY?: boolean,\r\n    premulAlpha: boolean = false,\r\n    format?: number,\r\n    forceBindTexture: boolean = false): void {\r\n    if (!texture) {\r\n        return;\r\n    }\r\n\r\n    const gl = this._gl;\r\n    const target = gl.TEXTURE_2D;\r\n\r\n    const wasPreviouslyBound = this._bindTextureDirectly(target, texture, true, forceBindTexture);\r\n\r\n    this._unpackFlipY(invertY === undefined ? texture.invertY : invertY);\r\n\r\n    if (premulAlpha) {\r\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);\r\n    }\r\n\r\n    const textureType = this._getWebGLTextureType(texture.type);\r\n    const glformat = this._getInternalFormat(format ? format : texture.format);\r\n    const internalFormat = this._getRGBABufferInternalSizedFormat(texture.type, glformat);\r\n\r\n    gl.texImage2D(target, 0, internalFormat, glformat, textureType, source);\r\n\r\n    if (texture.generateMipMaps) {\r\n        gl.generateMipmap(target);\r\n    }\r\n\r\n    if (!wasPreviouslyBound) {\r\n        this._bindTextureDirectly(target, null);\r\n    }\r\n\r\n    if (premulAlpha) {\r\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);\r\n    }\r\n\r\n    texture.isReady = true;\r\n};", "import { Logger } from \"../../Misc/logger\";\r\nimport { Nullable } from \"../../types\";\r\nimport { Scene } from \"../../scene\";\r\nimport { ISize } from \"../../Maths/math.size\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\n\r\nimport \"../../Engines/Extensions/engine.dynamicTexture\";\r\nimport { CanvasGenerator } from '../../Misc/canvasGenerator';\r\n\r\n/**\r\n * A class extending Texture allowing drawing on a texture\r\n * @see https://doc.babylonjs.com/how_to/dynamictexture\r\n */\r\nexport class DynamicTexture extends Texture {\r\n    private _generateMipMaps: boolean;\r\n    private _canvas: HTMLCanvasElement | OffscreenCanvas;\r\n    private _context: CanvasRenderingContext2D;\r\n\r\n    /**\r\n     * Creates a DynamicTexture\r\n     * @param name defines the name of the texture\r\n     * @param options provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height\r\n     * @param scene defines the scene where you want the texture\r\n     * @param generateMipMaps defines the use of MinMaps or not (default is false)\r\n     * @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)\r\n     * @param format defines the texture format to use (default is Engine.TEXTUREFORMAT_RGBA)\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading\r\n     */\r\n\r\n    constructor(name: string, options: any, scene: Nullable<Scene> = null, generateMipMaps: boolean, samplingMode: number = 3, format: number = 5, invertY?: boolean) {\r\n        super(null, scene, !generateMipMaps, invertY, samplingMode, undefined, undefined, undefined, undefined, format);\r\n\r\n        this.name = name;\r\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n\r\n        this._generateMipMaps = generateMipMaps;\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return;\r\n        }\r\n\r\n        if (options.getContext) {\r\n            this._canvas = options;\r\n            this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\r\n        } else {\r\n            this._canvas = CanvasGenerator.CreateCanvas(1, 1);\r\n\r\n            if (options.width || options.width === 0) {\r\n                this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\r\n            } else {\r\n                this._texture = engine.createDynamicTexture(options, options, generateMipMaps, samplingMode);\r\n            }\r\n        }\r\n\r\n        var textureSize = this.getSize();\r\n\r\n        this._canvas.width = textureSize.width;\r\n        this._canvas.height = textureSize.height;\r\n        this._context = <CanvasRenderingContext2D>this._canvas.getContext(\"2d\");\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"DynamicTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"DynamicTexture\";\r\n    }\r\n\r\n    /**\r\n     * Gets the current state of canRescale\r\n     */\r\n    public get canRescale(): boolean {\r\n        return true;\r\n    }\r\n\r\n    private _recreate(textureSize: ISize): void {\r\n        this._canvas.width = textureSize.width;\r\n        this._canvas.height = textureSize.height;\r\n\r\n        this.releaseInternalTexture();\r\n\r\n        this._texture = this._getEngine()!.createDynamicTexture(textureSize.width, textureSize.height, this._generateMipMaps, this.samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Scales the texture\r\n     * @param ratio the scale factor to apply to both width and height\r\n     */\r\n    public scale(ratio: number): void {\r\n        var textureSize = this.getSize();\r\n\r\n        textureSize.width *= ratio;\r\n        textureSize.height *= ratio;\r\n\r\n        this._recreate(textureSize);\r\n    }\r\n\r\n    /**\r\n     * Resizes the texture\r\n     * @param width the new width\r\n     * @param height the new height\r\n     */\r\n    public scaleTo(width: number, height: number): void {\r\n        var textureSize = this.getSize();\r\n\r\n        textureSize.width = width;\r\n        textureSize.height = height;\r\n\r\n        this._recreate(textureSize);\r\n    }\r\n\r\n    /**\r\n     * Gets the context of the canvas used by the texture\r\n     * @returns the canvas context of the dynamic texture\r\n     */\r\n    public getContext(): CanvasRenderingContext2D {\r\n        return this._context;\r\n    }\r\n\r\n    /**\r\n     * Clears the texture\r\n     */\r\n    public clear(): void {\r\n        var size = this.getSize();\r\n        this._context.fillRect(0, 0, size.width, size.height);\r\n    }\r\n\r\n    /**\r\n     * Updates the texture\r\n     * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n     * @param premulAlpha defines if alpha is stored as premultiplied (default is false)\r\n     */\r\n    public update(invertY?: boolean, premulAlpha = false): void {\r\n        this._getEngine()!.updateDynamicTexture(this._texture, this._canvas, invertY === undefined ? true : invertY, premulAlpha, this._format || undefined);\r\n    }\r\n\r\n    /**\r\n     * Draws text onto the texture\r\n     * @param text defines the text to be drawn\r\n     * @param x defines the placement of the text from the left\r\n     * @param y defines the placement of the text from the top when invertY is true and from the bottom when false\r\n     * @param font defines the font to be used with font-style, font-size, font-name\r\n     * @param color defines the color used for the text\r\n     * @param clearColor defines the color for the canvas, use null to not overwrite canvas\r\n     * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n     * @param update defines whether texture is immediately update (default is true)\r\n     */\r\n    public drawText(text: string, x: number | null | undefined, y: number | null | undefined, font: string, color: string | null, clearColor: string, invertY?: boolean, update = true) {\r\n        var size = this.getSize();\r\n        if (clearColor) {\r\n            this._context.fillStyle = clearColor;\r\n            this._context.fillRect(0, 0, size.width, size.height);\r\n        }\r\n\r\n        this._context.font = font;\r\n        if (x === null || x === undefined) {\r\n            var textSize = this._context.measureText(text);\r\n            x = (size.width - textSize.width) / 2;\r\n        }\r\n        if (y === null || y === undefined) {\r\n            var fontSize = parseInt((font.replace(/\\D/g, '')));\r\n            y = (size.height / 2) + (fontSize / 3.65);\r\n        }\r\n\r\n        this._context.fillStyle = color || \"\";\r\n        this._context.fillText(text, x, y);\r\n\r\n        if (update) {\r\n            this.update(invertY);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones the texture\r\n     * @returns the clone of the texture.\r\n     */\r\n    public clone(): DynamicTexture {\r\n        let scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this;\r\n        }\r\n\r\n        var textureSize = this.getSize();\r\n        var newTexture = new DynamicTexture(this.name, textureSize, scene, this._generateMipMaps);\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // Dynamic Texture\r\n        newTexture.wrapU = this.wrapU;\r\n        newTexture.wrapV = this.wrapV;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Serializes the dynamic texture.  The scene should be ready before the dynamic texture is serialized\r\n     * @returns a serialized dynamic texture object\r\n     */\r\n    public serialize(): any {\r\n        const scene = this.getScene();\r\n        if (scene && !scene.isReady()) {\r\n            Logger.Warn(\"The scene must be ready before serializing the dynamic texture\");\r\n        }\r\n\r\n        const serializationObject = super.serialize();\r\n        if (this._IsCanvasElement(this._canvas)) {\r\n            serializationObject.base64String = (this._canvas as HTMLCanvasElement).toDataURL();\r\n        }\r\n\r\n        serializationObject.invertY = this._invertY;\r\n        serializationObject.samplingMode = this.samplingMode;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private _IsCanvasElement(canvas: HTMLCanvasElement | OffscreenCanvas): canvas is HTMLCanvasElement {\r\n        return (canvas as HTMLCanvasElement).toDataURL !== undefined;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n        this.update();\r\n    }\r\n}\r\n", "import { IDisposable, Scene } from \"../scene\";\r\nimport { Nullable } from \"../types\";\r\nimport { Observable, Observer } from \"../Misc/observable\";\r\nimport { PointerInfoPre, PointerInfo, PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { HemisphericLight } from '../Lights/hemisphericLight';\r\nimport { Vector3 } from '../Maths/math.vector';\r\nimport { Camera } from '../Cameras/camera';\r\nimport { Color3 } from '../Maths/math.color';\r\n\r\n/**\r\n * Renders a layer on top of an existing scene\r\n */\r\nexport class UtilityLayerRenderer implements IDisposable {\r\n    private _pointerCaptures: { [pointerId: number]: boolean } = {};\r\n    private _lastPointerEvents: { [pointerId: number]: boolean } = {};\r\n    private static _DefaultUtilityLayer: Nullable<UtilityLayerRenderer> = null;\r\n    private static _DefaultKeepDepthUtilityLayer: Nullable<UtilityLayerRenderer> = null;\r\n    private _sharedGizmoLight: Nullable<HemisphericLight> = null;\r\n\r\n    private _renderCamera: Nullable<Camera> = null;\r\n\r\n    /**\r\n     * Gets the camera that is used to render the utility layer (when not set, this will be the last active camera)\r\n     * @param getRigParentIfPossible if the current active camera is a rig camera, should its parent camera be returned\r\n     * @returns the camera that is used when rendering the utility layer\r\n     */\r\n    public getRenderCamera(getRigParentIfPossible?: boolean) {\r\n        if (this._renderCamera) {\r\n            return this._renderCamera;\r\n        } else {\r\n            let activeCam: Camera;\r\n            if (this.originalScene.activeCameras && this.originalScene.activeCameras.length > 1) {\r\n                activeCam = this.originalScene.activeCameras[this.originalScene.activeCameras.length - 1];\r\n            } else {\r\n                activeCam = <Camera>(this.originalScene.activeCamera!);\r\n            }\r\n\r\n            if (getRigParentIfPossible && activeCam && activeCam.isRigCamera) {\r\n                return activeCam.rigParent!;\r\n            }\r\n            return activeCam;\r\n        }\r\n    }\r\n    /**\r\n     * Sets the camera that should be used when rendering the utility layer (If set to null the last active camera will be used)\r\n     * @param cam the camera that should be used when rendering the utility layer\r\n     */\r\n    public setRenderCamera(cam: Nullable<Camera>) {\r\n        this._renderCamera = cam;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Light which used by gizmos to get light shading\r\n     */\r\n    public _getSharedGizmoLight(): HemisphericLight {\r\n        if (!this._sharedGizmoLight) {\r\n            this._sharedGizmoLight = new HemisphericLight(\"shared gizmo light\", new Vector3(0, 1, 0), this.utilityLayerScene);\r\n            this._sharedGizmoLight.intensity = 2;\r\n            this._sharedGizmoLight.groundColor = Color3.Gray();\r\n        }\r\n        return this._sharedGizmoLight;\r\n    }\r\n\r\n    /**\r\n     * If the picking should be done on the utility layer prior to the actual scene (Default: true)\r\n     */\r\n    public pickUtilitySceneFirst = true;\r\n    /**\r\n     * A shared utility layer that can be used to overlay objects into a scene (Depth map of the previous scene is cleared before drawing on top of it)\r\n     */\r\n    public static get DefaultUtilityLayer(): UtilityLayerRenderer {\r\n        if (UtilityLayerRenderer._DefaultUtilityLayer == null) {\r\n            UtilityLayerRenderer._DefaultUtilityLayer = new UtilityLayerRenderer(EngineStore.LastCreatedScene!);\r\n            UtilityLayerRenderer._DefaultUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\r\n                UtilityLayerRenderer._DefaultUtilityLayer = null;\r\n            });\r\n        }\r\n        return UtilityLayerRenderer._DefaultUtilityLayer;\r\n    }\r\n    /**\r\n     * A shared utility layer that can be used to embed objects into a scene (Depth map of the previous scene is not cleared before drawing on top of it)\r\n     */\r\n    public static get DefaultKeepDepthUtilityLayer(): UtilityLayerRenderer {\r\n        if (UtilityLayerRenderer._DefaultKeepDepthUtilityLayer == null) {\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = new UtilityLayerRenderer(EngineStore.LastCreatedScene!);\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\r\n                UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;\r\n            });\r\n        }\r\n        return UtilityLayerRenderer._DefaultKeepDepthUtilityLayer;\r\n    }\r\n\r\n    /**\r\n     * The scene that is rendered on top of the original scene\r\n     */\r\n    public utilityLayerScene: Scene;\r\n\r\n    /**\r\n     *  If the utility layer should automatically be rendered on top of existing scene\r\n    */\r\n    public shouldRender: boolean = true;\r\n    /**\r\n     * If set to true, only pointer down onPointerObservable events will be blocked when picking is occluded by original scene\r\n     */\r\n    public onlyCheckPointerDownEvents = true;\r\n\r\n    /**\r\n     * If set to false, only pointerUp, pointerDown and pointerMove will be sent to the utilityLayerScene (false by default)\r\n     */\r\n    public processAllEvents = false;\r\n\r\n    /**\r\n     * Observable raised when the pointer move from the utility layer scene to the main scene\r\n     */\r\n    public onPointerOutObservable = new Observable<number>();\r\n\r\n    /** Gets or sets a predicate that will be used to indicate utility meshes present in the main scene */\r\n    public mainSceneTrackerPredicate: (mesh: Nullable<AbstractMesh>) => boolean;\r\n\r\n    private _afterRenderObserver: Nullable<Observer<Camera>>;\r\n    private _sceneDisposeObserver: Nullable<Observer<Scene>>;\r\n    private _originalPointerObserver: Nullable<Observer<PointerInfoPre>>;\r\n    /**\r\n     * Instantiates a UtilityLayerRenderer\r\n     * @param originalScene the original scene that will be rendered on top of\r\n     * @param handleEvents boolean indicating if the utility layer should handle events\r\n     */\r\n    constructor(\r\n        /** the original scene that will be rendered on top of */\r\n        public originalScene: Scene,\r\n        handleEvents: boolean = true) {\r\n        // Create scene which will be rendered in the foreground and remove it from being referenced by engine to avoid interfering with existing app\r\n        this.utilityLayerScene = new Scene(originalScene.getEngine(), { virtual: true });\r\n        this.utilityLayerScene.useRightHandedSystem = originalScene.useRightHandedSystem;\r\n        this.utilityLayerScene._allowPostProcessClearColor = false;\r\n\r\n        // Detach controls on utility scene, events will be fired by logic below to handle picking priority\r\n        this.utilityLayerScene.detachControl();\r\n\r\n        if (handleEvents) {\r\n            this._originalPointerObserver = originalScene.onPrePointerObservable.add((prePointerInfo, eventState) => {\r\n                if (!this.utilityLayerScene.activeCamera) {\r\n                    return;\r\n                }\r\n                if (!this.processAllEvents) {\r\n                    if (prePointerInfo.type !== PointerEventTypes.POINTERMOVE\r\n                        && prePointerInfo.type !== PointerEventTypes.POINTERUP\r\n                        && prePointerInfo.type !== PointerEventTypes.POINTERDOWN\r\n                        && prePointerInfo.type !== PointerEventTypes.POINTERDOUBLETAP) {\r\n                        return;\r\n                    }\r\n                }\r\n                this.utilityLayerScene.pointerX = originalScene.pointerX;\r\n                this.utilityLayerScene.pointerY = originalScene.pointerY;\r\n                let pointerEvent = <PointerEvent>(prePointerInfo.event);\r\n                if (originalScene!.isPointerCaptured(pointerEvent.pointerId)) {\r\n                    this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                    return;\r\n                }\r\n\r\n                var utilityScenePick = prePointerInfo.ray ? this.utilityLayerScene.pickWithRay(prePointerInfo.ray) : this.utilityLayerScene.pick(originalScene.pointerX, originalScene.pointerY);\r\n                if (!prePointerInfo.ray && utilityScenePick) {\r\n                    prePointerInfo.ray = utilityScenePick.ray;\r\n                }\r\n\r\n                // always fire the prepointer oversvable\r\n                this.utilityLayerScene.onPrePointerObservable.notifyObservers(prePointerInfo);\r\n\r\n                // allow every non pointer down event to flow to the utility layer\r\n                if (this.onlyCheckPointerDownEvents && prePointerInfo.type != PointerEventTypes.POINTERDOWN) {\r\n                    if (!prePointerInfo.skipOnPointerObservable) {\r\n                        this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);\r\n                    }\r\n                    if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\r\n                        this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                if (this.utilityLayerScene.autoClearDepthAndStencil || this.pickUtilitySceneFirst) {\r\n                    // If this layer is an overlay, check if this layer was hit and if so, skip pointer events for the main scene\r\n                    if (utilityScenePick && utilityScenePick.hit) {\r\n\r\n                        if (!prePointerInfo.skipOnPointerObservable) {\r\n                            this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);\r\n                        }\r\n                        prePointerInfo.skipOnPointerObservable = true;\r\n                    }\r\n                } else {\r\n                    var originalScenePick = prePointerInfo.ray ? originalScene.pickWithRay(prePointerInfo.ray) : originalScene.pick(originalScene.pointerX, originalScene.pointerY);\r\n                    let pointerEvent = <PointerEvent>(prePointerInfo.event);\r\n\r\n                    // If the layer can be occluded by the original scene, only fire pointer events to the first layer that hit they ray\r\n                    if (originalScenePick && utilityScenePick) {\r\n\r\n                        // No pick in utility scene\r\n                        if (utilityScenePick.distance === 0 && originalScenePick.pickedMesh) {\r\n                            if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\r\n                                // We touched an utility mesh present in the main scene\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                                prePointerInfo.skipOnPointerObservable = true;\r\n                            } else if (prePointerInfo.type === PointerEventTypes.POINTERDOWN) {\r\n                                this._pointerCaptures[pointerEvent.pointerId] = true;\r\n                            } else if (this._lastPointerEvents[pointerEvent.pointerId]) {\r\n                                // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\r\n                                this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\r\n                                delete this._lastPointerEvents[pointerEvent.pointerId];\r\n                            }\r\n                        } else if (!this._pointerCaptures[pointerEvent.pointerId] && (utilityScenePick.distance < originalScenePick.distance || originalScenePick.distance === 0)) {\r\n                            // We pick something in utility scene or the pick in utility is closer than the one in main scene\r\n                            this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent);\r\n                            // If a previous utility layer set this, do not unset this\r\n                            if (!prePointerInfo.skipOnPointerObservable) {\r\n                                prePointerInfo.skipOnPointerObservable = utilityScenePick.distance > 0;\r\n                            }\r\n                        } else if (!this._pointerCaptures[pointerEvent.pointerId] && (utilityScenePick.distance > originalScenePick.distance)) {\r\n                            // We have a pick in both scenes but main is closer than utility\r\n\r\n                            // We touched an utility mesh present in the main scene\r\n                            if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                                prePointerInfo.skipOnPointerObservable = true;\r\n                            } else if (this._lastPointerEvents[pointerEvent.pointerId]) {\r\n                                // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\r\n                                this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\r\n                                delete this._lastPointerEvents[pointerEvent.pointerId];\r\n                            }\r\n                        }\r\n\r\n                        if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\r\n                            this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n\r\n            // As a newly added utility layer will be rendered over the screen last, it's pointer events should be processed first\r\n            if (this._originalPointerObserver) {\r\n                originalScene.onPrePointerObservable.makeObserverTopPriority(this._originalPointerObserver);\r\n            }\r\n        }\r\n\r\n        // Render directly on top of existing scene without clearing\r\n        this.utilityLayerScene.autoClear = false;\r\n\r\n        this._afterRenderObserver = this.originalScene.onAfterCameraRenderObservable.add((camera) => {\r\n            // Only render when the render camera finishes rendering\r\n            if (this.shouldRender && camera == this.getRenderCamera()) {\r\n                this.render();\r\n            }\r\n        });\r\n\r\n        this._sceneDisposeObserver = this.originalScene.onDisposeObservable.add(() => {\r\n            this.dispose();\r\n        });\r\n\r\n        this._updateCamera();\r\n    }\r\n\r\n    private _notifyObservers(prePointerInfo: PointerInfoPre, pickInfo: PickingInfo, pointerEvent: PointerEvent) {\r\n        if (!prePointerInfo.skipOnPointerObservable) {\r\n            this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, pickInfo), prePointerInfo.type);\r\n            this._lastPointerEvents[pointerEvent.pointerId] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renders the utility layers scene on top of the original scene\r\n     */\r\n    public render() {\r\n        this._updateCamera();\r\n        if (this.utilityLayerScene.activeCamera) {\r\n            // Set the camera's scene to utility layers scene\r\n            var oldScene = this.utilityLayerScene.activeCamera.getScene();\r\n            var camera = this.utilityLayerScene.activeCamera;\r\n            camera._scene = this.utilityLayerScene;\r\n            if (camera.leftCamera) {\r\n                camera.leftCamera._scene = this.utilityLayerScene;\r\n            }\r\n            if (camera.rightCamera) {\r\n                camera.rightCamera._scene = this.utilityLayerScene;\r\n            }\r\n\r\n            this.utilityLayerScene.render(false);\r\n\r\n            // Reset camera's scene back to original\r\n            camera._scene = oldScene;\r\n            if (camera.leftCamera) {\r\n                camera.leftCamera._scene = oldScene;\r\n            }\r\n            if (camera.rightCamera) {\r\n                camera.rightCamera._scene = oldScene;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Disposes of the renderer\r\n     */\r\n    public dispose() {\r\n        this.onPointerOutObservable.clear();\r\n\r\n        if (this._afterRenderObserver) {\r\n            this.originalScene.onAfterCameraRenderObservable.remove(this._afterRenderObserver);\r\n        }\r\n        if (this._sceneDisposeObserver) {\r\n            this.originalScene.onDisposeObservable.remove(this._sceneDisposeObserver);\r\n        }\r\n        if (this._originalPointerObserver) {\r\n            this.originalScene.onPrePointerObservable.remove(this._originalPointerObserver);\r\n        }\r\n        this.utilityLayerScene.dispose();\r\n    }\r\n\r\n    private _updateCamera() {\r\n        this.utilityLayerScene.cameraToUseForPointers = this.getRenderCamera();\r\n        this.utilityLayerScene.activeCamera = this.getRenderCamera();\r\n    }\r\n}\r\n", "import { Nullable } from \"../../types\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from '../../Maths/math.color';\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\n\r\nVertexData.CreateBox = function(options: { size?: number, width?: number, height?: number, depth?: number, faceUV?: Vector4[], faceColors?: Color4[], sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, wrap?: boolean, topBaseAt?: number, bottomBaseAt?: number }): VertexData {\r\n    var nbFaces = 6;\r\n    var indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];\r\n    var normals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0];\r\n    var uvs = [];\r\n    var positions = [];\r\n    var width = options.width || options.size || 1;\r\n    var height = options.height || options.size || 1;\r\n    var depth = options.depth || options.size || 1;\r\n    var wrap = options.wrap || false;\r\n    var topBaseAt = (options.topBaseAt === void 0) ? 1 : options.topBaseAt;\r\n    var bottomBaseAt = (options.bottomBaseAt === void 0) ? 0 : options.bottomBaseAt;\r\n    topBaseAt = (topBaseAt + 4) % 4; // places values as 0 to 3\r\n    bottomBaseAt = (bottomBaseAt + 4) % 4; // places values as 0 to 3\r\n    var topOrder = [2, 0, 3, 1];\r\n    var bottomOrder = [2, 0, 1, 3];\r\n    var topIndex = topOrder[topBaseAt];\r\n    var bottomIndex = bottomOrder[bottomBaseAt];\r\n    var basePositions = [1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1];\r\n    if (wrap) {\r\n        indices = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14];\r\n        basePositions = [-1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1];\r\n        var topFaceBase: any = [[1, 1, 1], [-1, 1, 1], [-1, 1, -1], [1, 1, -1]];\r\n        var bottomFaceBase: any = [[-1, -1, 1], [1, -1, 1], [1, -1, -1], [-1, -1, -1]];\r\n        var topFaceOrder: any = [17, 18, 19, 16];\r\n        var bottomFaceOrder: any = [22, 23, 20, 21];\r\n        while (topIndex > 0) {\r\n            topFaceBase.unshift(topFaceBase.pop());\r\n            topFaceOrder.unshift(topFaceOrder.pop());\r\n            topIndex--;\r\n        }\r\n        while (bottomIndex > 0) {\r\n            bottomFaceBase.unshift(bottomFaceBase.pop());\r\n            bottomFaceOrder.unshift(bottomFaceOrder.pop());\r\n            bottomIndex--;\r\n        }\r\n        topFaceBase = topFaceBase.flat();\r\n        bottomFaceBase = bottomFaceBase.flat();\r\n        basePositions = basePositions.concat(topFaceBase).concat(bottomFaceBase);\r\n        indices.push(topFaceOrder[0], topFaceOrder[2], topFaceOrder[3], topFaceOrder[0], topFaceOrder[1], topFaceOrder[2]);\r\n        indices.push(bottomFaceOrder[0], bottomFaceOrder[2], bottomFaceOrder[3], bottomFaceOrder[0], bottomFaceOrder[1], bottomFaceOrder[2]);\r\n    }\r\n    var scaleArray = [width / 2, height / 2, depth / 2];\r\n    positions = basePositions.reduce(\r\n        (accumulator: Array<number>, currentValue, currentIndex) => accumulator.concat(currentValue * scaleArray[currentIndex % 3]),\r\n        []\r\n    );\r\n\r\n    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    var faceUV: Vector4[] = options.faceUV || new Array<Vector4>(6);\r\n    var faceColors = options.faceColors;\r\n    var colors = [];\r\n\r\n    // default face colors and UV if undefined\r\n    for (var f = 0; f < 6; f++) {\r\n        if (faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n\r\n    // Create each face in turn.\r\n    for (var index = 0; index < nbFaces; index++) {\r\n        uvs.push(faceUV[index].z, faceUV[index].w);\r\n        uvs.push(faceUV[index].x, faceUV[index].w);\r\n        uvs.push(faceUV[index].x, faceUV[index].y);\r\n        uvs.push(faceUV[index].z, faceUV[index].y);\r\n        if (faceColors) {\r\n            for (var c = 0; c < 4; c++) {\r\n                colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);\r\n            }\r\n        }\r\n    }\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    var vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    if (faceColors) {\r\n        var totalColors = (sideOrientation === VertexData.DOUBLESIDE) ? colors.concat(colors) : colors;\r\n        vertexData.colors = totalColors;\r\n    }\r\n\r\n    return vertexData;\r\n};\r\n\r\nMesh.CreateBox = (name: string, size: number, scene: Nullable<Scene> = null, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    var options = {\r\n        size: size,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable\r\n    };\r\n\r\n    return BoxBuilder.CreateBox(name, options, scene);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class BoxBuilder {\r\n    /**\r\n     * Creates a box mesh\r\n     * * The parameter `size` sets the size (float) of each box side (default 1)\r\n     * * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value of `size`)\r\n     * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)\r\n     * * Please read this tutorial : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#box\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the box mesh\r\n     */\r\n    public static CreateBox(name: string, options: { size?: number, width?: number, height?: number, depth?: number, faceUV?: Vector4[], faceColors?: Color4[], sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, wrap?: boolean, topBaseAt?: number, bottomBaseAt?: number, updatable?: boolean }, scene: Nullable<Scene> = null): Mesh {\r\n        var box = new Mesh(name, scene);\r\n\r\n        options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        box._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n        var vertexData = VertexData.CreateBox(options);\r\n\r\n        vertexData.applyToMesh(box, options.updatable);\r\n\r\n        return box;\r\n    }\r\n}", "/**\n * Gather the list of clipboard event types as constants.\n */\nexport class ClipboardEventTypes {\n    /**\n     * The clipboard event is fired when a copy command is active (pressed).\n     */\n    public static readonly COPY = 0x01; //\n    /**\n     *  The clipboard event is fired when a cut command is active (pressed).\n     */\n    public static readonly CUT = 0x02;\n\n    /**\n     * The clipboard event is fired when a paste command is active (pressed).\n     */\n    public static readonly PASTE = 0x03;\n}\n/**\n * This class is used to store clipboard related info for the onClipboardObservable event.\n */\nexport class ClipboardInfo {\n    /**\n     *Creates an instance of ClipboardInfo.\n     * @param type Defines the type of event (BABYLON.ClipboardEventTypes)\n     * @param event Defines the related dom event\n     */\n    constructor(\n        /**\n         * Defines the type of event (BABYLON.ClipboardEventTypes)\n         */\n        public type: number,\n        /**\n         * Defines the related dom event\n         */\n        public event: ClipboardEvent) {\n    }\n\n    /**\n     *  Get the clipboard event's type from the keycode.\n     * @param keyCode Defines the keyCode for the current keyboard event.\n     * @return {number}\n     */\n    public static GetTypeFromCharacter(keyCode: number): number {\n        let charCode = keyCode;\n        //TODO: add codes for extended ASCII\n        switch (charCode) {\n            case 67: return ClipboardEventTypes.COPY;\n            case 86: return ClipboardEventTypes.PASTE;\n            case 88: return ClipboardEventTypes.CUT;\n            default: return -1;\n        }\n    }\n}", "import { Camera } from \"../Cameras/camera\";\r\nimport { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { SceneComponentConstants, ISceneComponent } from \"../sceneComponent\";\r\nimport { Layer } from \"./layer\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { AbstractScene } from '../abstractScene';\r\n\r\ndeclare module \"../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /**\r\n         * The list of layers (background and foreground) of the scene\r\n         */\r\n        layers: Array<Layer>;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines the layer scene component responsible to manage any layers\r\n * in a given scene.\r\n */\r\nexport class LayerSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpfull to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_LAYER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    private _engine: Engine;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        this._engine = scene.getEngine();\r\n        scene.layers = new Array<Layer>();\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_LAYER, this, this._drawCameraBackground);\r\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_LAYER, this, this._drawCameraForeground);\r\n\r\n        this.scene._beforeRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_LAYER, this, this._drawRenderTargetBackground);\r\n        this.scene._afterRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_LAYER, this, this._drawRenderTargetForeground);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        let layers = this.scene.layers;\r\n\r\n        for (let layer of layers) {\r\n            layer._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated ressources.\r\n     */\r\n    public dispose(): void {\r\n        let layers = this.scene.layers;\r\n\r\n        while (layers.length) {\r\n            layers[0].dispose();\r\n        }\r\n    }\r\n\r\n    private _draw(predicate: (layer: Layer) => boolean): void {\r\n        let layers = this.scene.layers;\r\n\r\n        if (layers.length) {\r\n            this._engine.setDepthBuffer(false);\r\n            for (let layer of layers) {\r\n                if (predicate(layer)) {\r\n                    layer.render();\r\n                }\r\n            }\r\n            this._engine.setDepthBuffer(true);\r\n        }\r\n    }\r\n\r\n    private _drawCameraPredicate(layer: Layer, isBackground: boolean, cameraLayerMask: number): boolean {\r\n        return !layer.renderOnlyInRenderTargetTextures &&\r\n            layer.isBackground === isBackground &&\r\n            ((layer.layerMask & cameraLayerMask) !== 0);\r\n    }\r\n\r\n    private _drawCameraBackground(camera: Camera): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawCameraPredicate(layer, true, camera.layerMask);\r\n        });\r\n    }\r\n\r\n    private _drawCameraForeground(camera: Camera): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawCameraPredicate(layer, false, camera.layerMask);\r\n        });\r\n    }\r\n\r\n    private _drawRenderTargetPredicate(layer: Layer, isBackground: boolean, cameraLayerMask: number, renderTargetTexture: RenderTargetTexture): boolean {\r\n        return (layer.renderTargetTextures.length > 0) &&\r\n            layer.isBackground === isBackground &&\r\n            (layer.renderTargetTextures.indexOf(renderTargetTexture) > -1) &&\r\n            ((layer.layerMask & cameraLayerMask) !== 0);\r\n    }\r\n\r\n    private _drawRenderTargetBackground(renderTarget: RenderTargetTexture): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawRenderTargetPredicate(layer, true, this.scene.activeCamera!.layerMask, renderTarget);\r\n        });\r\n    }\r\n\r\n    private _drawRenderTargetForeground(renderTarget: RenderTargetTexture): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawRenderTargetPredicate(layer, false, this.scene.activeCamera!.layerMask, renderTarget);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    public addFromContainer(container: AbstractScene): void {\r\n        if (!container.layers) {\r\n            return;\r\n        }\r\n        container.layers.forEach((layer) => {\r\n            this.scene.layers.push(layer);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    public removeFromContainer(container: AbstractScene, dispose = false): void {\r\n        if (!container.layers) {\r\n            return;\r\n        }\r\n        container.layers.forEach((layer) => {\r\n            var index = this.scene.layers.indexOf(layer);\r\n            if (index !== -1) {\r\n                this.scene.layers.splice(index, 1);\r\n            }\r\n            if (dispose) {\r\n                layer.dispose();\r\n            }\r\n        });\r\n    }\r\n}\r\n", "import { Effect } from \"../Materials/effect\";\nimport \"./ShadersInclude/helperFunctions\";\n\nlet name = 'layerPixelShader';\nlet shader = `\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nuniform vec4 color;\n\n#include<helperFunctions>\nvoid main(void) {\nvec4 baseColor=texture2D(textureSampler,vUV);\n#ifdef LINEAR\nbaseColor.rgb=toGammaSpace(baseColor.rgb);\n#endif\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\ngl_FragColor=baseColor*color;\n}`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var layerPixelShader = { name, shader };\n", "import { Effect } from \"../Materials/effect\";\n\nlet name = 'layerVertexShader';\nlet shader = `\nattribute vec2 position;\n\nuniform vec2 scale;\nuniform vec2 offset;\nuniform mat4 textureMatrix;\n\nvarying vec2 vUV;\nconst vec2 madd=vec2(0.5,0.5);\nvoid main(void) {\nvec2 shiftedPosition=position*scale+offset;\nvUV=vec2(textureMatrix*vec4(shiftedPosition*madd+madd,1.0,0.0));\ngl_Position=vec4(shiftedPosition,0.0,1.0);\n}`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var layerVertexShader = { name, shader };\n", "import { Observer, Observable } from \"../Misc/observable\";\r\nimport { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport { Color4 } from '../Maths/math.color';\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { LayerSceneComponent } from \"./layerSceneComponent\";\r\n\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\n\r\nimport \"../Shaders/layer.fragment\";\r\nimport \"../Shaders/layer.vertex\";\r\nimport { DataBuffer } from '../Meshes/dataBuffer';\r\n\r\n/**\r\n * This represents a full screen 2d layer.\r\n * This can be useful to display a picture in the  background of your scene for instance.\r\n * @see https://www.babylonjs-playground.com/#08A2BS#1\r\n */\r\nexport class Layer {\r\n    /**\r\n     * Define the texture the layer should display.\r\n     */\r\n    public texture: Nullable<Texture>;\r\n\r\n    /**\r\n     * Is the layer in background or foreground.\r\n     */\r\n    public isBackground: boolean;\r\n\r\n    /**\r\n     * Define the color of the layer (instead of texture).\r\n     */\r\n    public color: Color4;\r\n\r\n    /**\r\n     * Define the scale of the layer in order to zoom in out of the texture.\r\n     */\r\n    public scale = new Vector2(1, 1);\r\n\r\n    /**\r\n     * Define an offset for the layer in order to shift the texture.\r\n     */\r\n    public offset = new Vector2(0, 0);\r\n\r\n    /**\r\n     * Define the alpha blending mode used in the layer in case the texture or color has an alpha.\r\n     */\r\n    public alphaBlendingMode = 2;\r\n\r\n    /**\r\n     * Define if the layer should alpha test or alpha blend with the rest of the scene.\r\n     * Alpha test will not mix with the background color in case of transparency.\r\n     * It will either use the texture color or the background depending on the alpha value of the current pixel.\r\n     */\r\n    public alphaTest: boolean;\r\n\r\n    /**\r\n     * Define a mask to restrict the layer to only some of the scene cameras.\r\n     */\r\n    public layerMask: number = 0x0FFFFFFF;\r\n\r\n    /**\r\n     * Define the list of render target the layer is visible into.\r\n     */\r\n    public renderTargetTextures: RenderTargetTexture[] = [];\r\n\r\n    /**\r\n     * Define if the layer is only used in renderTarget or if it also\r\n     * renders in the main frame buffer of the canvas.\r\n     */\r\n    public renderOnlyInRenderTargetTextures = false;\r\n\r\n    private _scene: Scene;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _effect: Effect;\r\n    private _previousDefines: string;\r\n\r\n    /**\r\n     * An event triggered when the layer is disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<Layer>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<Layer>>;\r\n    /**\r\n     * Back compatibility with callback before the onDisposeObservable existed.\r\n     * The set callback will be triggered when the layer has been disposed.\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n    * An event triggered before rendering the scene\r\n    */\r\n    public onBeforeRenderObservable = new Observable<Layer>();\r\n\r\n    private _onBeforeRenderObserver: Nullable<Observer<Layer>>;\r\n    /**\r\n     * Back compatibility with callback before the onBeforeRenderObservable existed.\r\n     * The set callback will be triggered just before rendering the layer.\r\n     */\r\n    public set onBeforeRender(callback: () => void) {\r\n        if (this._onBeforeRenderObserver) {\r\n            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\r\n        }\r\n        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n    * An event triggered after rendering the scene\r\n    */\r\n    public onAfterRenderObservable = new Observable<Layer>();\r\n\r\n    private _onAfterRenderObserver: Nullable<Observer<Layer>>;\r\n    /**\r\n     * Back compatibility with callback before the onAfterRenderObservable existed.\r\n     * The set callback will be triggered just after rendering the layer.\r\n     */\r\n    public set onAfterRender(callback: () => void) {\r\n        if (this._onAfterRenderObserver) {\r\n            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\r\n        }\r\n        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new layer.\r\n     * This represents a full screen 2d layer.\r\n     * This can be useful to display a picture in the  background of your scene for instance.\r\n     * @see https://www.babylonjs-playground.com/#08A2BS#1\r\n     * @param name Define the name of the layer in the scene\r\n     * @param imgUrl Define the url of the texture to display in the layer\r\n     * @param scene Define the scene the layer belongs to\r\n     * @param isBackground Defines whether the layer is displayed in front or behind the scene\r\n     * @param color Defines a color for the layer\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define the name of the layer.\r\n         */\r\n        public name: string,\r\n        imgUrl: Nullable<string>,\r\n        scene: Nullable<Scene>,\r\n        isBackground?: boolean, color?: Color4) {\r\n\r\n        this.texture = imgUrl ? new Texture(imgUrl, scene, true) : null;\r\n        this.isBackground = isBackground === undefined ? true : isBackground;\r\n        this.color = color === undefined ? new Color4(1, 1, 1, 1) : color;\r\n\r\n        this._scene = <Scene>(scene || EngineStore.LastCreatedScene);\r\n        let layerComponent = this._scene._getComponent(SceneComponentConstants.NAME_LAYER) as LayerSceneComponent;\r\n        if (!layerComponent) {\r\n            layerComponent = new LayerSceneComponent(this._scene);\r\n            this._scene._addComponent(layerComponent);\r\n        }\r\n        this._scene.layers.push(this);\r\n\r\n        var engine = this._scene.getEngine();\r\n\r\n        // VBO\r\n        var vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        var vertexBuffer = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;\r\n\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    private _createIndexBuffer(): void {\r\n        var engine = this._scene.getEngine();\r\n\r\n        // Indices\r\n        var indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n        let vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    /**\r\n     * Renders the layer in the scene.\r\n     */\r\n    public render(): void {\r\n\r\n        var engine = this._scene.getEngine();\r\n\r\n        var defines = \"\";\r\n\r\n        if (this.alphaTest) {\r\n            defines = \"#define ALPHATEST\";\r\n        }\r\n\r\n        if (this.texture && !this.texture.gammaSpace) {\r\n            defines += \"\\r\\n#define LINEAR\";\r\n        }\r\n\r\n        if (this._previousDefines !== defines) {\r\n            this._previousDefines = defines;\r\n            this._effect = engine.createEffect(\"layer\",\r\n                [VertexBuffer.PositionKind],\r\n                [\"textureMatrix\", \"color\", \"scale\", \"offset\"],\r\n                [\"textureSampler\"], defines);\r\n        }\r\n        var currentEffect = this._effect;\r\n\r\n        // Check\r\n        if (!currentEffect || !currentEffect.isReady() || !this.texture || !this.texture.isReady()) {\r\n            return;\r\n        }\r\n\r\n        var engine = this._scene.getEngine();\r\n\r\n        this.onBeforeRenderObservable.notifyObservers(this);\r\n\r\n        // Render\r\n        engine.enableEffect(currentEffect);\r\n        engine.setState(false);\r\n\r\n        // Texture\r\n        currentEffect.setTexture(\"textureSampler\", this.texture);\r\n        currentEffect.setMatrix(\"textureMatrix\", this.texture.getTextureMatrix());\r\n\r\n        // Color\r\n        currentEffect.setFloat4(\"color\", this.color.r, this.color.g, this.color.b, this.color.a);\r\n\r\n        // Scale / offset\r\n        currentEffect.setVector2(\"offset\", this.offset);\r\n        currentEffect.setVector2(\"scale\", this.scale);\r\n\r\n        // VBOs\r\n        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect);\r\n\r\n        // Draw order\r\n        if (!this.alphaTest) {\r\n            engine.setAlphaMode(this.alphaBlendingMode);\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n            engine.setAlphaMode(0);\r\n        }\r\n        else {\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n\r\n        this.onAfterRenderObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Disposes and releases the associated ressources.\r\n     */\r\n    public dispose(): void {\r\n        var vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        if (this.texture) {\r\n            this.texture.dispose();\r\n            this.texture = null;\r\n        }\r\n\r\n        // Clean RTT list\r\n        this.renderTargetTextures = [];\r\n\r\n        // Remove from scene\r\n        var index = this._scene.layers.indexOf(this);\r\n        this._scene.layers.splice(index, 1);\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n\r\n        this.onDisposeObservable.clear();\r\n        this.onAfterRenderObservable.clear();\r\n        this.onBeforeRenderObservable.clear();\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
