var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name45 in all)
    __defProp(target, name45, { get: all[name45], enumerable: true });
};

// node_modules/@babylonjs/core/abstractScene.js
var AbstractScene = function() {
  function AbstractScene2() {
    this.rootNodes = new Array();
    this.cameras = new Array();
    this.lights = new Array();
    this.meshes = new Array();
    this.skeletons = new Array();
    this.particleSystems = new Array();
    this.animations = [];
    this.animationGroups = new Array();
    this.multiMaterials = new Array();
    this.materials = new Array();
    this.morphTargetManagers = new Array();
    this.geometries = new Array();
    this.transformNodes = new Array();
    this.actionManagers = new Array();
    this.textures = new Array();
    this._environmentTexture = null;
    this.postProcesses = new Array();
  }
  AbstractScene2.AddParser = function(name45, parser) {
    this._BabylonFileParsers[name45] = parser;
  };
  AbstractScene2.GetParser = function(name45) {
    if (this._BabylonFileParsers[name45]) {
      return this._BabylonFileParsers[name45];
    }
    return null;
  };
  AbstractScene2.AddIndividualParser = function(name45, parser) {
    this._IndividualBabylonFileParsers[name45] = parser;
  };
  AbstractScene2.GetIndividualParser = function(name45) {
    if (this._IndividualBabylonFileParsers[name45]) {
      return this._IndividualBabylonFileParsers[name45];
    }
    return null;
  };
  AbstractScene2.Parse = function(jsonData, scene, container, rootUrl) {
    for (var parserName in this._BabylonFileParsers) {
      if (this._BabylonFileParsers.hasOwnProperty(parserName)) {
        this._BabylonFileParsers[parserName](jsonData, scene, container, rootUrl);
      }
    }
  };
  Object.defineProperty(AbstractScene2.prototype, "environmentTexture", {
    get: function() {
      return this._environmentTexture;
    },
    set: function(value) {
      this._environmentTexture = value;
    },
    enumerable: false,
    configurable: true
  });
  AbstractScene2.prototype.getNodes = function() {
    var nodes = new Array();
    nodes = nodes.concat(this.meshes);
    nodes = nodes.concat(this.lights);
    nodes = nodes.concat(this.cameras);
    nodes = nodes.concat(this.transformNodes);
    this.skeletons.forEach(function(skeleton) {
      return nodes = nodes.concat(skeleton.bones);
    });
    return nodes;
  };
  AbstractScene2._BabylonFileParsers = {};
  AbstractScene2._IndividualBabylonFileParsers = {};
  return AbstractScene2;
}();

// node_modules/@babylonjs/core/Actions/abstractActionManager.js
var AbstractActionManager = function() {
  function AbstractActionManager2() {
    this.hoverCursor = "";
    this.actions = new Array();
    this.isRecursive = false;
  }
  Object.defineProperty(AbstractActionManager2, "HasTriggers", {
    get: function() {
      for (var t in AbstractActionManager2.Triggers) {
        if (AbstractActionManager2.Triggers.hasOwnProperty(t)) {
          return true;
        }
      }
      return false;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractActionManager2, "HasPickTriggers", {
    get: function() {
      for (var t in AbstractActionManager2.Triggers) {
        if (AbstractActionManager2.Triggers.hasOwnProperty(t)) {
          var t_int = parseInt(t);
          if (t_int >= 1 && t_int <= 7) {
            return true;
          }
        }
      }
      return false;
    },
    enumerable: false,
    configurable: true
  });
  AbstractActionManager2.HasSpecificTrigger = function(trigger) {
    for (var t in AbstractActionManager2.Triggers) {
      if (AbstractActionManager2.Triggers.hasOwnProperty(t)) {
        var t_int = parseInt(t);
        if (t_int === trigger) {
          return true;
        }
      }
    }
    return false;
  };
  AbstractActionManager2.Triggers = {};
  return AbstractActionManager2;
}();

// node_modules/@babylonjs/core/Misc/observable.js
var EventState = function() {
  function EventState2(mask, skipNextObservers, target, currentTarget) {
    if (skipNextObservers === void 0) {
      skipNextObservers = false;
    }
    this.initalize(mask, skipNextObservers, target, currentTarget);
  }
  EventState2.prototype.initalize = function(mask, skipNextObservers, target, currentTarget) {
    if (skipNextObservers === void 0) {
      skipNextObservers = false;
    }
    this.mask = mask;
    this.skipNextObservers = skipNextObservers;
    this.target = target;
    this.currentTarget = currentTarget;
    return this;
  };
  return EventState2;
}();
var Observer = function() {
  function Observer2(callback, mask, scope) {
    if (scope === void 0) {
      scope = null;
    }
    this.callback = callback;
    this.mask = mask;
    this.scope = scope;
    this._willBeUnregistered = false;
    this.unregisterOnNextCall = false;
  }
  return Observer2;
}();
var MultiObserver = function() {
  function MultiObserver2() {
  }
  MultiObserver2.prototype.dispose = function() {
    if (this._observers && this._observables) {
      for (var index = 0; index < this._observers.length; index++) {
        this._observables[index].remove(this._observers[index]);
      }
    }
    this._observers = null;
    this._observables = null;
  };
  MultiObserver2.Watch = function(observables, callback, mask, scope) {
    if (mask === void 0) {
      mask = -1;
    }
    if (scope === void 0) {
      scope = null;
    }
    var result = new MultiObserver2();
    result._observers = new Array();
    result._observables = observables;
    for (var _i = 0, observables_1 = observables; _i < observables_1.length; _i++) {
      var observable = observables_1[_i];
      var observer = observable.add(callback, mask, false, scope);
      if (observer) {
        result._observers.push(observer);
      }
    }
    return result;
  };
  return MultiObserver2;
}();
var Observable = function() {
  function Observable2(onObserverAdded) {
    this._observers = new Array();
    this._eventState = new EventState(0);
    if (onObserverAdded) {
      this._onObserverAdded = onObserverAdded;
    }
  }
  Object.defineProperty(Observable2.prototype, "observers", {
    get: function() {
      return this._observers;
    },
    enumerable: false,
    configurable: true
  });
  Observable2.prototype.add = function(callback, mask, insertFirst, scope, unregisterOnFirstCall) {
    if (mask === void 0) {
      mask = -1;
    }
    if (insertFirst === void 0) {
      insertFirst = false;
    }
    if (scope === void 0) {
      scope = null;
    }
    if (unregisterOnFirstCall === void 0) {
      unregisterOnFirstCall = false;
    }
    if (!callback) {
      return null;
    }
    var observer = new Observer(callback, mask, scope);
    observer.unregisterOnNextCall = unregisterOnFirstCall;
    if (insertFirst) {
      this._observers.unshift(observer);
    } else {
      this._observers.push(observer);
    }
    if (this._onObserverAdded) {
      this._onObserverAdded(observer);
    }
    return observer;
  };
  Observable2.prototype.addOnce = function(callback) {
    return this.add(callback, void 0, void 0, void 0, true);
  };
  Observable2.prototype.remove = function(observer) {
    if (!observer) {
      return false;
    }
    var index = this._observers.indexOf(observer);
    if (index !== -1) {
      this._deferUnregister(observer);
      return true;
    }
    return false;
  };
  Observable2.prototype.removeCallback = function(callback, scope) {
    for (var index = 0; index < this._observers.length; index++) {
      var observer = this._observers[index];
      if (observer._willBeUnregistered) {
        continue;
      }
      if (observer.callback === callback && (!scope || scope === observer.scope)) {
        this._deferUnregister(observer);
        return true;
      }
    }
    return false;
  };
  Observable2.prototype._deferUnregister = function(observer) {
    var _this = this;
    observer.unregisterOnNextCall = false;
    observer._willBeUnregistered = true;
    setTimeout(function() {
      _this._remove(observer);
    }, 0);
  };
  Observable2.prototype._remove = function(observer) {
    if (!observer) {
      return false;
    }
    var index = this._observers.indexOf(observer);
    if (index !== -1) {
      this._observers.splice(index, 1);
      return true;
    }
    return false;
  };
  Observable2.prototype.makeObserverTopPriority = function(observer) {
    this._remove(observer);
    this._observers.unshift(observer);
  };
  Observable2.prototype.makeObserverBottomPriority = function(observer) {
    this._remove(observer);
    this._observers.push(observer);
  };
  Observable2.prototype.notifyObservers = function(eventData, mask, target, currentTarget, userInfo) {
    if (mask === void 0) {
      mask = -1;
    }
    if (!this._observers.length) {
      return true;
    }
    var state = this._eventState;
    state.mask = mask;
    state.target = target;
    state.currentTarget = currentTarget;
    state.skipNextObservers = false;
    state.lastReturnValue = eventData;
    state.userInfo = userInfo;
    for (var _i = 0, _a = this._observers; _i < _a.length; _i++) {
      var obs = _a[_i];
      if (obs._willBeUnregistered) {
        continue;
      }
      if (obs.mask & mask) {
        if (obs.scope) {
          state.lastReturnValue = obs.callback.apply(obs.scope, [eventData, state]);
        } else {
          state.lastReturnValue = obs.callback(eventData, state);
        }
        if (obs.unregisterOnNextCall) {
          this._deferUnregister(obs);
        }
      }
      if (state.skipNextObservers) {
        return false;
      }
    }
    return true;
  };
  Observable2.prototype.notifyObserversWithPromise = function(eventData, mask, target, currentTarget, userInfo) {
    var _this = this;
    if (mask === void 0) {
      mask = -1;
    }
    var p = Promise.resolve(eventData);
    if (!this._observers.length) {
      return p;
    }
    var state = this._eventState;
    state.mask = mask;
    state.target = target;
    state.currentTarget = currentTarget;
    state.skipNextObservers = false;
    state.userInfo = userInfo;
    this._observers.forEach(function(obs) {
      if (state.skipNextObservers) {
        return;
      }
      if (obs._willBeUnregistered) {
        return;
      }
      if (obs.mask & mask) {
        if (obs.scope) {
          p = p.then(function(lastReturnedValue) {
            state.lastReturnValue = lastReturnedValue;
            return obs.callback.apply(obs.scope, [eventData, state]);
          });
        } else {
          p = p.then(function(lastReturnedValue) {
            state.lastReturnValue = lastReturnedValue;
            return obs.callback(eventData, state);
          });
        }
        if (obs.unregisterOnNextCall) {
          _this._deferUnregister(obs);
        }
      }
    });
    return p.then(function() {
      return eventData;
    });
  };
  Observable2.prototype.notifyObserver = function(observer, eventData, mask) {
    if (mask === void 0) {
      mask = -1;
    }
    var state = this._eventState;
    state.mask = mask;
    state.skipNextObservers = false;
    observer.callback(eventData, state);
  };
  Observable2.prototype.hasObservers = function() {
    return this._observers.length > 0;
  };
  Observable2.prototype.clear = function() {
    this._observers = new Array();
    this._onObserverAdded = null;
  };
  Observable2.prototype.clone = function() {
    var result = new Observable2();
    result._observers = this._observers.slice(0);
    return result;
  };
  Observable2.prototype.hasSpecificMask = function(mask) {
    if (mask === void 0) {
      mask = -1;
    }
    for (var _i = 0, _a = this._observers; _i < _a.length; _i++) {
      var obs = _a[_i];
      if (obs.mask & mask || obs.mask === mask) {
        return true;
      }
    }
    return false;
  };
  return Observable2;
}();

// node_modules/@babylonjs/core/Maths/math.scalar.js
var Scalar = function() {
  function Scalar2() {
  }
  Scalar2.WithinEpsilon = function(a, b, epsilon) {
    if (epsilon === void 0) {
      epsilon = 1401298e-51;
    }
    var num = a - b;
    return -epsilon <= num && num <= epsilon;
  };
  Scalar2.ToHex = function(i) {
    var str = i.toString(16);
    if (i <= 15) {
      return ("0" + str).toUpperCase();
    }
    return str.toUpperCase();
  };
  Scalar2.Sign = function(value) {
    value = +value;
    if (value === 0 || isNaN(value)) {
      return value;
    }
    return value > 0 ? 1 : -1;
  };
  Scalar2.Clamp = function(value, min, max) {
    if (min === void 0) {
      min = 0;
    }
    if (max === void 0) {
      max = 1;
    }
    return Math.min(max, Math.max(min, value));
  };
  Scalar2.Log2 = function(value) {
    return Math.log(value) * Math.LOG2E;
  };
  Scalar2.Repeat = function(value, length) {
    return value - Math.floor(value / length) * length;
  };
  Scalar2.Normalize = function(value, min, max) {
    return (value - min) / (max - min);
  };
  Scalar2.Denormalize = function(normalized, min, max) {
    return normalized * (max - min) + min;
  };
  Scalar2.DeltaAngle = function(current, target) {
    var num = Scalar2.Repeat(target - current, 360);
    if (num > 180) {
      num -= 360;
    }
    return num;
  };
  Scalar2.PingPong = function(tx, length) {
    var t = Scalar2.Repeat(tx, length * 2);
    return length - Math.abs(t - length);
  };
  Scalar2.SmoothStep = function(from, to, tx) {
    var t = Scalar2.Clamp(tx);
    t = -2 * t * t * t + 3 * t * t;
    return to * t + from * (1 - t);
  };
  Scalar2.MoveTowards = function(current, target, maxDelta) {
    var result = 0;
    if (Math.abs(target - current) <= maxDelta) {
      result = target;
    } else {
      result = current + Scalar2.Sign(target - current) * maxDelta;
    }
    return result;
  };
  Scalar2.MoveTowardsAngle = function(current, target, maxDelta) {
    var num = Scalar2.DeltaAngle(current, target);
    var result = 0;
    if (-maxDelta < num && num < maxDelta) {
      result = target;
    } else {
      target = current + num;
      result = Scalar2.MoveTowards(current, target, maxDelta);
    }
    return result;
  };
  Scalar2.Lerp = function(start, end, amount) {
    return start + (end - start) * amount;
  };
  Scalar2.LerpAngle = function(start, end, amount) {
    var num = Scalar2.Repeat(end - start, 360);
    if (num > 180) {
      num -= 360;
    }
    return start + num * Scalar2.Clamp(amount);
  };
  Scalar2.InverseLerp = function(a, b, value) {
    var result = 0;
    if (a != b) {
      result = Scalar2.Clamp((value - a) / (b - a));
    } else {
      result = 0;
    }
    return result;
  };
  Scalar2.Hermite = function(value1, tangent1, value2, tangent2, amount) {
    var squared = amount * amount;
    var cubed = amount * squared;
    var part1 = 2 * cubed - 3 * squared + 1;
    var part2 = -2 * cubed + 3 * squared;
    var part3 = cubed - 2 * squared + amount;
    var part4 = cubed - squared;
    return value1 * part1 + value2 * part2 + tangent1 * part3 + tangent2 * part4;
  };
  Scalar2.RandomRange = function(min, max) {
    if (min === max) {
      return min;
    }
    return Math.random() * (max - min) + min;
  };
  Scalar2.RangeToPercent = function(number, min, max) {
    return (number - min) / (max - min);
  };
  Scalar2.PercentToRange = function(percent, min, max) {
    return (max - min) * percent + min;
  };
  Scalar2.NormalizeRadians = function(angle) {
    angle -= Scalar2.TwoPi * Math.floor((angle + Math.PI) / Scalar2.TwoPi);
    return angle;
  };
  Scalar2.TwoPi = Math.PI * 2;
  return Scalar2;
}();

// node_modules/@babylonjs/core/Maths/math.constants.js
var ToGammaSpace = 1 / 2.2;
var ToLinearSpace = 2.2;
var Epsilon = 1e-3;

// node_modules/@babylonjs/core/Misc/typeStore.js
var _TypeStore = function() {
  function _TypeStore2() {
  }
  _TypeStore2.GetClass = function(fqdn) {
    if (this.RegisteredTypes && this.RegisteredTypes[fqdn]) {
      return this.RegisteredTypes[fqdn];
    }
    return null;
  };
  _TypeStore2.RegisteredTypes = {};
  return _TypeStore2;
}();

// node_modules/@babylonjs/core/Engines/performanceConfigurator.js
var PerformanceConfigurator = function() {
  function PerformanceConfigurator2() {
  }
  PerformanceConfigurator2.SetMatrixPrecision = function(use64bits) {
    PerformanceConfigurator2.MatrixTrackPrecisionChange = false;
    if (use64bits && !PerformanceConfigurator2.MatrixUse64Bits) {
      if (PerformanceConfigurator2.MatrixTrackedMatrices) {
        for (var m = 0; m < PerformanceConfigurator2.MatrixTrackedMatrices.length; ++m) {
          var matrix = PerformanceConfigurator2.MatrixTrackedMatrices[m];
          var values = matrix._m;
          matrix._m = new Array(16);
          for (var i = 0; i < 16; ++i) {
            matrix._m[i] = values[i];
          }
        }
      }
    }
    PerformanceConfigurator2.MatrixUse64Bits = use64bits;
    PerformanceConfigurator2.MatrixCurrentType = PerformanceConfigurator2.MatrixUse64Bits ? Array : Float32Array;
    PerformanceConfigurator2.MatrixTrackedMatrices = null;
  };
  PerformanceConfigurator2.MatrixUse64Bits = false;
  PerformanceConfigurator2.MatrixTrackPrecisionChange = true;
  PerformanceConfigurator2.MatrixCurrentType = Float32Array;
  PerformanceConfigurator2.MatrixTrackedMatrices = [];
  return PerformanceConfigurator2;
}();

// node_modules/@babylonjs/core/Misc/arrayTools.js
var ArrayTools = function() {
  function ArrayTools2() {
  }
  ArrayTools2.BuildArray = function(size, itemBuilder) {
    var a = [];
    for (var i = 0; i < size; ++i) {
      a.push(itemBuilder());
    }
    return a;
  };
  return ArrayTools2;
}();

// node_modules/@babylonjs/core/Maths/math.vector.js
var Vector2 = function() {
  function Vector22(x, y) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    this.x = x;
    this.y = y;
  }
  Vector22.prototype.toString = function() {
    return "{X: " + this.x + " Y: " + this.y + "}";
  };
  Vector22.prototype.getClassName = function() {
    return "Vector2";
  };
  Vector22.prototype.getHashCode = function() {
    var hash = this.x | 0;
    hash = hash * 397 ^ (this.y | 0);
    return hash;
  };
  Vector22.prototype.toArray = function(array, index) {
    if (index === void 0) {
      index = 0;
    }
    array[index] = this.x;
    array[index + 1] = this.y;
    return this;
  };
  Vector22.prototype.fromArray = function(array, index) {
    if (index === void 0) {
      index = 0;
    }
    Vector22.FromArrayToRef(array, index, this);
    return this;
  };
  Vector22.prototype.asArray = function() {
    var result = new Array();
    this.toArray(result, 0);
    return result;
  };
  Vector22.prototype.copyFrom = function(source) {
    this.x = source.x;
    this.y = source.y;
    return this;
  };
  Vector22.prototype.copyFromFloats = function(x, y) {
    this.x = x;
    this.y = y;
    return this;
  };
  Vector22.prototype.set = function(x, y) {
    return this.copyFromFloats(x, y);
  };
  Vector22.prototype.add = function(otherVector) {
    return new Vector22(this.x + otherVector.x, this.y + otherVector.y);
  };
  Vector22.prototype.addToRef = function(otherVector, result) {
    result.x = this.x + otherVector.x;
    result.y = this.y + otherVector.y;
    return this;
  };
  Vector22.prototype.addInPlace = function(otherVector) {
    this.x += otherVector.x;
    this.y += otherVector.y;
    return this;
  };
  Vector22.prototype.addVector3 = function(otherVector) {
    return new Vector22(this.x + otherVector.x, this.y + otherVector.y);
  };
  Vector22.prototype.subtract = function(otherVector) {
    return new Vector22(this.x - otherVector.x, this.y - otherVector.y);
  };
  Vector22.prototype.subtractToRef = function(otherVector, result) {
    result.x = this.x - otherVector.x;
    result.y = this.y - otherVector.y;
    return this;
  };
  Vector22.prototype.subtractInPlace = function(otherVector) {
    this.x -= otherVector.x;
    this.y -= otherVector.y;
    return this;
  };
  Vector22.prototype.multiplyInPlace = function(otherVector) {
    this.x *= otherVector.x;
    this.y *= otherVector.y;
    return this;
  };
  Vector22.prototype.multiply = function(otherVector) {
    return new Vector22(this.x * otherVector.x, this.y * otherVector.y);
  };
  Vector22.prototype.multiplyToRef = function(otherVector, result) {
    result.x = this.x * otherVector.x;
    result.y = this.y * otherVector.y;
    return this;
  };
  Vector22.prototype.multiplyByFloats = function(x, y) {
    return new Vector22(this.x * x, this.y * y);
  };
  Vector22.prototype.divide = function(otherVector) {
    return new Vector22(this.x / otherVector.x, this.y / otherVector.y);
  };
  Vector22.prototype.divideToRef = function(otherVector, result) {
    result.x = this.x / otherVector.x;
    result.y = this.y / otherVector.y;
    return this;
  };
  Vector22.prototype.divideInPlace = function(otherVector) {
    return this.divideToRef(otherVector, this);
  };
  Vector22.prototype.negate = function() {
    return new Vector22(-this.x, -this.y);
  };
  Vector22.prototype.negateInPlace = function() {
    this.x *= -1;
    this.y *= -1;
    return this;
  };
  Vector22.prototype.negateToRef = function(result) {
    return result.copyFromFloats(this.x * -1, this.y * -1);
  };
  Vector22.prototype.scaleInPlace = function(scale) {
    this.x *= scale;
    this.y *= scale;
    return this;
  };
  Vector22.prototype.scale = function(scale) {
    var result = new Vector22(0, 0);
    this.scaleToRef(scale, result);
    return result;
  };
  Vector22.prototype.scaleToRef = function(scale, result) {
    result.x = this.x * scale;
    result.y = this.y * scale;
    return this;
  };
  Vector22.prototype.scaleAndAddToRef = function(scale, result) {
    result.x += this.x * scale;
    result.y += this.y * scale;
    return this;
  };
  Vector22.prototype.equals = function(otherVector) {
    return otherVector && this.x === otherVector.x && this.y === otherVector.y;
  };
  Vector22.prototype.equalsWithEpsilon = function(otherVector, epsilon) {
    if (epsilon === void 0) {
      epsilon = Epsilon;
    }
    return otherVector && Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) && Scalar.WithinEpsilon(this.y, otherVector.y, epsilon);
  };
  Vector22.prototype.floor = function() {
    return new Vector22(Math.floor(this.x), Math.floor(this.y));
  };
  Vector22.prototype.fract = function() {
    return new Vector22(this.x - Math.floor(this.x), this.y - Math.floor(this.y));
  };
  Vector22.prototype.length = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  };
  Vector22.prototype.lengthSquared = function() {
    return this.x * this.x + this.y * this.y;
  };
  Vector22.prototype.normalize = function() {
    var len = this.length();
    if (len === 0) {
      return this;
    }
    this.x /= len;
    this.y /= len;
    return this;
  };
  Vector22.prototype.clone = function() {
    return new Vector22(this.x, this.y);
  };
  Vector22.Zero = function() {
    return new Vector22(0, 0);
  };
  Vector22.One = function() {
    return new Vector22(1, 1);
  };
  Vector22.FromArray = function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    return new Vector22(array[offset], array[offset + 1]);
  };
  Vector22.FromArrayToRef = function(array, offset, result) {
    result.x = array[offset];
    result.y = array[offset + 1];
  };
  Vector22.CatmullRom = function(value1, value2, value3, value4, amount) {
    var squared = amount * amount;
    var cubed = amount * squared;
    var x = 0.5 * (2 * value2.x + (-value1.x + value3.x) * amount + (2 * value1.x - 5 * value2.x + 4 * value3.x - value4.x) * squared + (-value1.x + 3 * value2.x - 3 * value3.x + value4.x) * cubed);
    var y = 0.5 * (2 * value2.y + (-value1.y + value3.y) * amount + (2 * value1.y - 5 * value2.y + 4 * value3.y - value4.y) * squared + (-value1.y + 3 * value2.y - 3 * value3.y + value4.y) * cubed);
    return new Vector22(x, y);
  };
  Vector22.Clamp = function(value, min, max) {
    var x = value.x;
    x = x > max.x ? max.x : x;
    x = x < min.x ? min.x : x;
    var y = value.y;
    y = y > max.y ? max.y : y;
    y = y < min.y ? min.y : y;
    return new Vector22(x, y);
  };
  Vector22.Hermite = function(value1, tangent1, value2, tangent2, amount) {
    var squared = amount * amount;
    var cubed = amount * squared;
    var part1 = 2 * cubed - 3 * squared + 1;
    var part2 = -2 * cubed + 3 * squared;
    var part3 = cubed - 2 * squared + amount;
    var part4 = cubed - squared;
    var x = value1.x * part1 + value2.x * part2 + tangent1.x * part3 + tangent2.x * part4;
    var y = value1.y * part1 + value2.y * part2 + tangent1.y * part3 + tangent2.y * part4;
    return new Vector22(x, y);
  };
  Vector22.Lerp = function(start, end, amount) {
    var x = start.x + (end.x - start.x) * amount;
    var y = start.y + (end.y - start.y) * amount;
    return new Vector22(x, y);
  };
  Vector22.Dot = function(left, right) {
    return left.x * right.x + left.y * right.y;
  };
  Vector22.Normalize = function(vector) {
    var newVector = vector.clone();
    newVector.normalize();
    return newVector;
  };
  Vector22.Minimize = function(left, right) {
    var x = left.x < right.x ? left.x : right.x;
    var y = left.y < right.y ? left.y : right.y;
    return new Vector22(x, y);
  };
  Vector22.Maximize = function(left, right) {
    var x = left.x > right.x ? left.x : right.x;
    var y = left.y > right.y ? left.y : right.y;
    return new Vector22(x, y);
  };
  Vector22.Transform = function(vector, transformation) {
    var r = Vector22.Zero();
    Vector22.TransformToRef(vector, transformation, r);
    return r;
  };
  Vector22.TransformToRef = function(vector, transformation, result) {
    var m = transformation.m;
    var x = vector.x * m[0] + vector.y * m[4] + m[12];
    var y = vector.x * m[1] + vector.y * m[5] + m[13];
    result.x = x;
    result.y = y;
  };
  Vector22.PointInTriangle = function(p, p0, p1, p2) {
    var a = 1 / 2 * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);
    var sign = a < 0 ? -1 : 1;
    var s = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) * p.x + (p0.x - p2.x) * p.y) * sign;
    var t = (p0.x * p1.y - p0.y * p1.x + (p0.y - p1.y) * p.x + (p1.x - p0.x) * p.y) * sign;
    return s > 0 && t > 0 && s + t < 2 * a * sign;
  };
  Vector22.Distance = function(value1, value2) {
    return Math.sqrt(Vector22.DistanceSquared(value1, value2));
  };
  Vector22.DistanceSquared = function(value1, value2) {
    var x = value1.x - value2.x;
    var y = value1.y - value2.y;
    return x * x + y * y;
  };
  Vector22.Center = function(value1, value2) {
    var center = value1.add(value2);
    center.scaleInPlace(0.5);
    return center;
  };
  Vector22.DistanceOfPointFromSegment = function(p, segA, segB) {
    var l2 = Vector22.DistanceSquared(segA, segB);
    if (l2 === 0) {
      return Vector22.Distance(p, segA);
    }
    var v = segB.subtract(segA);
    var t = Math.max(0, Math.min(1, Vector22.Dot(p.subtract(segA), v) / l2));
    var proj = segA.add(v.multiplyByFloats(t, t));
    return Vector22.Distance(p, proj);
  };
  return Vector22;
}();
var Vector3 = function() {
  function Vector32(x, y, z) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    this._isDirty = true;
    this._x = x;
    this._y = y;
    this._z = z;
  }
  Object.defineProperty(Vector32.prototype, "x", {
    get: function() {
      return this._x;
    },
    set: function(value) {
      this._x = value;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Vector32.prototype, "y", {
    get: function() {
      return this._y;
    },
    set: function(value) {
      this._y = value;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Vector32.prototype, "z", {
    get: function() {
      return this._z;
    },
    set: function(value) {
      this._z = value;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Vector32.prototype.toString = function() {
    return "{X: " + this._x + " Y:" + this._y + " Z:" + this._z + "}";
  };
  Vector32.prototype.getClassName = function() {
    return "Vector3";
  };
  Vector32.prototype.getHashCode = function() {
    var hash = this._x | 0;
    hash = hash * 397 ^ (this._y | 0);
    hash = hash * 397 ^ (this._z | 0);
    return hash;
  };
  Vector32.prototype.asArray = function() {
    var result = [];
    this.toArray(result, 0);
    return result;
  };
  Vector32.prototype.toArray = function(array, index) {
    if (index === void 0) {
      index = 0;
    }
    array[index] = this._x;
    array[index + 1] = this._y;
    array[index + 2] = this._z;
    return this;
  };
  Vector32.prototype.fromArray = function(array, index) {
    if (index === void 0) {
      index = 0;
    }
    Vector32.FromArrayToRef(array, index, this);
    return this;
  };
  Vector32.prototype.toQuaternion = function() {
    return Quaternion.RotationYawPitchRoll(this._y, this._x, this._z);
  };
  Vector32.prototype.addInPlace = function(otherVector) {
    return this.addInPlaceFromFloats(otherVector._x, otherVector._y, otherVector._z);
  };
  Vector32.prototype.addInPlaceFromFloats = function(x, y, z) {
    this.x += x;
    this.y += y;
    this.z += z;
    return this;
  };
  Vector32.prototype.add = function(otherVector) {
    return new Vector32(this._x + otherVector._x, this._y + otherVector._y, this._z + otherVector._z);
  };
  Vector32.prototype.addToRef = function(otherVector, result) {
    return result.copyFromFloats(this._x + otherVector._x, this._y + otherVector._y, this._z + otherVector._z);
  };
  Vector32.prototype.subtractInPlace = function(otherVector) {
    this.x -= otherVector._x;
    this.y -= otherVector._y;
    this.z -= otherVector._z;
    return this;
  };
  Vector32.prototype.subtract = function(otherVector) {
    return new Vector32(this._x - otherVector._x, this._y - otherVector._y, this._z - otherVector._z);
  };
  Vector32.prototype.subtractToRef = function(otherVector, result) {
    return this.subtractFromFloatsToRef(otherVector._x, otherVector._y, otherVector._z, result);
  };
  Vector32.prototype.subtractFromFloats = function(x, y, z) {
    return new Vector32(this._x - x, this._y - y, this._z - z);
  };
  Vector32.prototype.subtractFromFloatsToRef = function(x, y, z, result) {
    return result.copyFromFloats(this._x - x, this._y - y, this._z - z);
  };
  Vector32.prototype.negate = function() {
    return new Vector32(-this._x, -this._y, -this._z);
  };
  Vector32.prototype.negateInPlace = function() {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;
    return this;
  };
  Vector32.prototype.negateToRef = function(result) {
    return result.copyFromFloats(this._x * -1, this._y * -1, this._z * -1);
  };
  Vector32.prototype.scaleInPlace = function(scale) {
    this.x *= scale;
    this.y *= scale;
    this.z *= scale;
    return this;
  };
  Vector32.prototype.scale = function(scale) {
    return new Vector32(this._x * scale, this._y * scale, this._z * scale);
  };
  Vector32.prototype.scaleToRef = function(scale, result) {
    return result.copyFromFloats(this._x * scale, this._y * scale, this._z * scale);
  };
  Vector32.prototype.scaleAndAddToRef = function(scale, result) {
    return result.addInPlaceFromFloats(this._x * scale, this._y * scale, this._z * scale);
  };
  Vector32.prototype.projectOnPlane = function(plane, origin) {
    var result = Vector32.Zero();
    this.projectOnPlaneToRef(plane, origin, result);
    return result;
  };
  Vector32.prototype.projectOnPlaneToRef = function(plane, origin, result) {
    var n = plane.normal;
    var d = plane.d;
    var V = MathTmp.Vector3[0];
    this.subtractToRef(origin, V);
    V.normalize();
    var denom = Vector32.Dot(V, n);
    var t = -(Vector32.Dot(origin, n) + d) / denom;
    var scaledV = V.scaleInPlace(t);
    origin.addToRef(scaledV, result);
  };
  Vector32.prototype.equals = function(otherVector) {
    return otherVector && this._x === otherVector._x && this._y === otherVector._y && this._z === otherVector._z;
  };
  Vector32.prototype.equalsWithEpsilon = function(otherVector, epsilon) {
    if (epsilon === void 0) {
      epsilon = Epsilon;
    }
    return otherVector && Scalar.WithinEpsilon(this._x, otherVector._x, epsilon) && Scalar.WithinEpsilon(this._y, otherVector._y, epsilon) && Scalar.WithinEpsilon(this._z, otherVector._z, epsilon);
  };
  Vector32.prototype.equalsToFloats = function(x, y, z) {
    return this._x === x && this._y === y && this._z === z;
  };
  Vector32.prototype.multiplyInPlace = function(otherVector) {
    this.x *= otherVector._x;
    this.y *= otherVector._y;
    this.z *= otherVector._z;
    return this;
  };
  Vector32.prototype.multiply = function(otherVector) {
    return this.multiplyByFloats(otherVector._x, otherVector._y, otherVector._z);
  };
  Vector32.prototype.multiplyToRef = function(otherVector, result) {
    return result.copyFromFloats(this._x * otherVector._x, this._y * otherVector._y, this._z * otherVector._z);
  };
  Vector32.prototype.multiplyByFloats = function(x, y, z) {
    return new Vector32(this._x * x, this._y * y, this._z * z);
  };
  Vector32.prototype.divide = function(otherVector) {
    return new Vector32(this._x / otherVector._x, this._y / otherVector._y, this._z / otherVector._z);
  };
  Vector32.prototype.divideToRef = function(otherVector, result) {
    return result.copyFromFloats(this._x / otherVector._x, this._y / otherVector._y, this._z / otherVector._z);
  };
  Vector32.prototype.divideInPlace = function(otherVector) {
    return this.divideToRef(otherVector, this);
  };
  Vector32.prototype.minimizeInPlace = function(other) {
    return this.minimizeInPlaceFromFloats(other._x, other._y, other._z);
  };
  Vector32.prototype.maximizeInPlace = function(other) {
    return this.maximizeInPlaceFromFloats(other._x, other._y, other._z);
  };
  Vector32.prototype.minimizeInPlaceFromFloats = function(x, y, z) {
    if (x < this._x) {
      this.x = x;
    }
    if (y < this._y) {
      this.y = y;
    }
    if (z < this._z) {
      this.z = z;
    }
    return this;
  };
  Vector32.prototype.maximizeInPlaceFromFloats = function(x, y, z) {
    if (x > this._x) {
      this.x = x;
    }
    if (y > this._y) {
      this.y = y;
    }
    if (z > this._z) {
      this.z = z;
    }
    return this;
  };
  Vector32.prototype.isNonUniformWithinEpsilon = function(epsilon) {
    var absX = Math.abs(this._x);
    var absY = Math.abs(this._y);
    if (!Scalar.WithinEpsilon(absX, absY, epsilon)) {
      return true;
    }
    var absZ = Math.abs(this._z);
    if (!Scalar.WithinEpsilon(absX, absZ, epsilon)) {
      return true;
    }
    if (!Scalar.WithinEpsilon(absY, absZ, epsilon)) {
      return true;
    }
    return false;
  };
  Object.defineProperty(Vector32.prototype, "isNonUniform", {
    get: function() {
      var absX = Math.abs(this._x);
      var absY = Math.abs(this._y);
      if (absX !== absY) {
        return true;
      }
      var absZ = Math.abs(this._z);
      if (absX !== absZ) {
        return true;
      }
      return false;
    },
    enumerable: false,
    configurable: true
  });
  Vector32.prototype.floor = function() {
    return new Vector32(Math.floor(this._x), Math.floor(this._y), Math.floor(this._z));
  };
  Vector32.prototype.fract = function() {
    return new Vector32(this._x - Math.floor(this._x), this._y - Math.floor(this._y), this._z - Math.floor(this._z));
  };
  Vector32.prototype.length = function() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z);
  };
  Vector32.prototype.lengthSquared = function() {
    return this._x * this._x + this._y * this._y + this._z * this._z;
  };
  Vector32.prototype.normalize = function() {
    return this.normalizeFromLength(this.length());
  };
  Vector32.prototype.reorderInPlace = function(order) {
    var _this = this;
    order = order.toLowerCase();
    if (order === "xyz") {
      return this;
    }
    MathTmp.Vector3[0].copyFrom(this);
    ["x", "y", "z"].forEach(function(val, i) {
      _this[val] = MathTmp.Vector3[0][order[i]];
    });
    return this;
  };
  Vector32.prototype.rotateByQuaternionToRef = function(quaternion, result) {
    quaternion.toRotationMatrix(MathTmp.Matrix[0]);
    Vector32.TransformCoordinatesToRef(this, MathTmp.Matrix[0], result);
    return result;
  };
  Vector32.prototype.rotateByQuaternionAroundPointToRef = function(quaternion, point, result) {
    this.subtractToRef(point, MathTmp.Vector3[0]);
    MathTmp.Vector3[0].rotateByQuaternionToRef(quaternion, MathTmp.Vector3[0]);
    point.addToRef(MathTmp.Vector3[0], result);
    return result;
  };
  Vector32.prototype.cross = function(other) {
    return Vector32.Cross(this, other);
  };
  Vector32.prototype.normalizeFromLength = function(len) {
    if (len === 0 || len === 1) {
      return this;
    }
    return this.scaleInPlace(1 / len);
  };
  Vector32.prototype.normalizeToNew = function() {
    var normalized = new Vector32(0, 0, 0);
    this.normalizeToRef(normalized);
    return normalized;
  };
  Vector32.prototype.normalizeToRef = function(reference) {
    var len = this.length();
    if (len === 0 || len === 1) {
      return reference.copyFromFloats(this._x, this._y, this._z);
    }
    return this.scaleToRef(1 / len, reference);
  };
  Vector32.prototype.clone = function() {
    return new Vector32(this._x, this._y, this._z);
  };
  Vector32.prototype.copyFrom = function(source) {
    return this.copyFromFloats(source._x, source._y, source._z);
  };
  Vector32.prototype.copyFromFloats = function(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  };
  Vector32.prototype.set = function(x, y, z) {
    return this.copyFromFloats(x, y, z);
  };
  Vector32.prototype.setAll = function(v) {
    this.x = this.y = this.z = v;
    return this;
  };
  Vector32.GetClipFactor = function(vector0, vector1, axis, size) {
    var d0 = Vector32.Dot(vector0, axis) - size;
    var d1 = Vector32.Dot(vector1, axis) - size;
    var s = d0 / (d0 - d1);
    return s;
  };
  Vector32.GetAngleBetweenVectors = function(vector0, vector1, normal) {
    var v0 = vector0.normalizeToRef(MathTmp.Vector3[1]);
    var v1 = vector1.normalizeToRef(MathTmp.Vector3[2]);
    var dot = Vector32.Dot(v0, v1);
    var n = MathTmp.Vector3[3];
    Vector32.CrossToRef(v0, v1, n);
    if (Vector32.Dot(n, normal) > 0) {
      return Math.acos(dot);
    }
    return -Math.acos(dot);
  };
  Vector32.FromArray = function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    return new Vector32(array[offset], array[offset + 1], array[offset + 2]);
  };
  Vector32.FromFloatArray = function(array, offset) {
    return Vector32.FromArray(array, offset);
  };
  Vector32.FromArrayToRef = function(array, offset, result) {
    result.x = array[offset];
    result.y = array[offset + 1];
    result.z = array[offset + 2];
  };
  Vector32.FromFloatArrayToRef = function(array, offset, result) {
    return Vector32.FromArrayToRef(array, offset, result);
  };
  Vector32.FromFloatsToRef = function(x, y, z, result) {
    result.copyFromFloats(x, y, z);
  };
  Vector32.Zero = function() {
    return new Vector32(0, 0, 0);
  };
  Vector32.One = function() {
    return new Vector32(1, 1, 1);
  };
  Vector32.Up = function() {
    return new Vector32(0, 1, 0);
  };
  Object.defineProperty(Vector32, "UpReadOnly", {
    get: function() {
      return Vector32._UpReadOnly;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Vector32, "ZeroReadOnly", {
    get: function() {
      return Vector32._ZeroReadOnly;
    },
    enumerable: false,
    configurable: true
  });
  Vector32.Down = function() {
    return new Vector32(0, -1, 0);
  };
  Vector32.Forward = function(rightHandedSystem) {
    if (rightHandedSystem === void 0) {
      rightHandedSystem = false;
    }
    return new Vector32(0, 0, rightHandedSystem ? -1 : 1);
  };
  Vector32.Backward = function(rightHandedSystem) {
    if (rightHandedSystem === void 0) {
      rightHandedSystem = false;
    }
    return new Vector32(0, 0, rightHandedSystem ? 1 : -1);
  };
  Vector32.Right = function() {
    return new Vector32(1, 0, 0);
  };
  Vector32.Left = function() {
    return new Vector32(-1, 0, 0);
  };
  Vector32.TransformCoordinates = function(vector, transformation) {
    var result = Vector32.Zero();
    Vector32.TransformCoordinatesToRef(vector, transformation, result);
    return result;
  };
  Vector32.TransformCoordinatesToRef = function(vector, transformation, result) {
    Vector32.TransformCoordinatesFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);
  };
  Vector32.TransformCoordinatesFromFloatsToRef = function(x, y, z, transformation, result) {
    var m = transformation.m;
    var rx = x * m[0] + y * m[4] + z * m[8] + m[12];
    var ry = x * m[1] + y * m[5] + z * m[9] + m[13];
    var rz = x * m[2] + y * m[6] + z * m[10] + m[14];
    var rw = 1 / (x * m[3] + y * m[7] + z * m[11] + m[15]);
    result.x = rx * rw;
    result.y = ry * rw;
    result.z = rz * rw;
  };
  Vector32.TransformNormal = function(vector, transformation) {
    var result = Vector32.Zero();
    Vector32.TransformNormalToRef(vector, transformation, result);
    return result;
  };
  Vector32.TransformNormalToRef = function(vector, transformation, result) {
    this.TransformNormalFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);
  };
  Vector32.TransformNormalFromFloatsToRef = function(x, y, z, transformation, result) {
    var m = transformation.m;
    result.x = x * m[0] + y * m[4] + z * m[8];
    result.y = x * m[1] + y * m[5] + z * m[9];
    result.z = x * m[2] + y * m[6] + z * m[10];
  };
  Vector32.CatmullRom = function(value1, value2, value3, value4, amount) {
    var squared = amount * amount;
    var cubed = amount * squared;
    var x = 0.5 * (2 * value2._x + (-value1._x + value3._x) * amount + (2 * value1._x - 5 * value2._x + 4 * value3._x - value4._x) * squared + (-value1._x + 3 * value2._x - 3 * value3._x + value4._x) * cubed);
    var y = 0.5 * (2 * value2._y + (-value1._y + value3._y) * amount + (2 * value1._y - 5 * value2._y + 4 * value3._y - value4._y) * squared + (-value1._y + 3 * value2._y - 3 * value3._y + value4._y) * cubed);
    var z = 0.5 * (2 * value2._z + (-value1._z + value3._z) * amount + (2 * value1._z - 5 * value2._z + 4 * value3._z - value4._z) * squared + (-value1._z + 3 * value2._z - 3 * value3._z + value4._z) * cubed);
    return new Vector32(x, y, z);
  };
  Vector32.Clamp = function(value, min, max) {
    var v = new Vector32();
    Vector32.ClampToRef(value, min, max, v);
    return v;
  };
  Vector32.ClampToRef = function(value, min, max, result) {
    var x = value._x;
    x = x > max._x ? max._x : x;
    x = x < min._x ? min._x : x;
    var y = value._y;
    y = y > max._y ? max._y : y;
    y = y < min._y ? min._y : y;
    var z = value._z;
    z = z > max._z ? max._z : z;
    z = z < min._z ? min._z : z;
    result.copyFromFloats(x, y, z);
  };
  Vector32.CheckExtends = function(v, min, max) {
    min.minimizeInPlace(v);
    max.maximizeInPlace(v);
  };
  Vector32.Hermite = function(value1, tangent1, value2, tangent2, amount) {
    var squared = amount * amount;
    var cubed = amount * squared;
    var part1 = 2 * cubed - 3 * squared + 1;
    var part2 = -2 * cubed + 3 * squared;
    var part3 = cubed - 2 * squared + amount;
    var part4 = cubed - squared;
    var x = value1._x * part1 + value2._x * part2 + tangent1._x * part3 + tangent2._x * part4;
    var y = value1._y * part1 + value2._y * part2 + tangent1._y * part3 + tangent2._y * part4;
    var z = value1._z * part1 + value2._z * part2 + tangent1._z * part3 + tangent2._z * part4;
    return new Vector32(x, y, z);
  };
  Vector32.Lerp = function(start, end, amount) {
    var result = new Vector32(0, 0, 0);
    Vector32.LerpToRef(start, end, amount, result);
    return result;
  };
  Vector32.LerpToRef = function(start, end, amount, result) {
    result.x = start._x + (end._x - start._x) * amount;
    result.y = start._y + (end._y - start._y) * amount;
    result.z = start._z + (end._z - start._z) * amount;
  };
  Vector32.Dot = function(left, right) {
    return left._x * right._x + left._y * right._y + left._z * right._z;
  };
  Vector32.Cross = function(left, right) {
    var result = Vector32.Zero();
    Vector32.CrossToRef(left, right, result);
    return result;
  };
  Vector32.CrossToRef = function(left, right, result) {
    var x = left._y * right._z - left._z * right._y;
    var y = left._z * right._x - left._x * right._z;
    var z = left._x * right._y - left._y * right._x;
    result.copyFromFloats(x, y, z);
  };
  Vector32.Normalize = function(vector) {
    var result = Vector32.Zero();
    Vector32.NormalizeToRef(vector, result);
    return result;
  };
  Vector32.NormalizeToRef = function(vector, result) {
    vector.normalizeToRef(result);
  };
  Vector32.Project = function(vector, world, transform, viewport) {
    var result = new Vector32();
    Vector32.ProjectToRef(vector, world, transform, viewport, result);
    return result;
  };
  Vector32.ProjectToRef = function(vector, world, transform, viewport, result) {
    var cw = viewport.width;
    var ch = viewport.height;
    var cx = viewport.x;
    var cy = viewport.y;
    var viewportMatrix = MathTmp.Matrix[1];
    Matrix.FromValuesToRef(cw / 2, 0, 0, 0, 0, -ch / 2, 0, 0, 0, 0, 0.5, 0, cx + cw / 2, ch / 2 + cy, 0.5, 1, viewportMatrix);
    var matrix = MathTmp.Matrix[0];
    world.multiplyToRef(transform, matrix);
    matrix.multiplyToRef(viewportMatrix, matrix);
    Vector32.TransformCoordinatesToRef(vector, matrix, result);
    return result;
  };
  Vector32._UnprojectFromInvertedMatrixToRef = function(source, matrix, result) {
    Vector32.TransformCoordinatesToRef(source, matrix, result);
    var m = matrix.m;
    var num = source._x * m[3] + source._y * m[7] + source._z * m[11] + m[15];
    if (Scalar.WithinEpsilon(num, 1)) {
      result.scaleInPlace(1 / num);
    }
  };
  Vector32.UnprojectFromTransform = function(source, viewportWidth, viewportHeight, world, transform) {
    var matrix = MathTmp.Matrix[0];
    world.multiplyToRef(transform, matrix);
    matrix.invert();
    source.x = source._x / viewportWidth * 2 - 1;
    source.y = -(source._y / viewportHeight * 2 - 1);
    var vector = new Vector32();
    Vector32._UnprojectFromInvertedMatrixToRef(source, matrix, vector);
    return vector;
  };
  Vector32.Unproject = function(source, viewportWidth, viewportHeight, world, view, projection) {
    var result = Vector32.Zero();
    Vector32.UnprojectToRef(source, viewportWidth, viewportHeight, world, view, projection, result);
    return result;
  };
  Vector32.UnprojectToRef = function(source, viewportWidth, viewportHeight, world, view, projection, result) {
    Vector32.UnprojectFloatsToRef(source._x, source._y, source._z, viewportWidth, viewportHeight, world, view, projection, result);
  };
  Vector32.UnprojectFloatsToRef = function(sourceX, sourceY, sourceZ, viewportWidth, viewportHeight, world, view, projection, result) {
    var matrix = MathTmp.Matrix[0];
    world.multiplyToRef(view, matrix);
    matrix.multiplyToRef(projection, matrix);
    matrix.invert();
    var screenSource = MathTmp.Vector3[0];
    screenSource.x = sourceX / viewportWidth * 2 - 1;
    screenSource.y = -(sourceY / viewportHeight * 2 - 1);
    screenSource.z = 2 * sourceZ - 1;
    Vector32._UnprojectFromInvertedMatrixToRef(screenSource, matrix, result);
  };
  Vector32.Minimize = function(left, right) {
    var min = left.clone();
    min.minimizeInPlace(right);
    return min;
  };
  Vector32.Maximize = function(left, right) {
    var max = left.clone();
    max.maximizeInPlace(right);
    return max;
  };
  Vector32.Distance = function(value1, value2) {
    return Math.sqrt(Vector32.DistanceSquared(value1, value2));
  };
  Vector32.DistanceSquared = function(value1, value2) {
    var x = value1._x - value2._x;
    var y = value1._y - value2._y;
    var z = value1._z - value2._z;
    return x * x + y * y + z * z;
  };
  Vector32.Center = function(value1, value2) {
    var center = value1.add(value2);
    center.scaleInPlace(0.5);
    return center;
  };
  Vector32.RotationFromAxis = function(axis1, axis2, axis3) {
    var rotation = Vector32.Zero();
    Vector32.RotationFromAxisToRef(axis1, axis2, axis3, rotation);
    return rotation;
  };
  Vector32.RotationFromAxisToRef = function(axis1, axis2, axis3, ref) {
    var quat = MathTmp.Quaternion[0];
    Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);
    quat.toEulerAnglesToRef(ref);
  };
  Vector32._UpReadOnly = Vector32.Up();
  Vector32._ZeroReadOnly = Vector32.Zero();
  return Vector32;
}();
var Vector4 = function() {
  function Vector42(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  Vector42.prototype.toString = function() {
    return "{X: " + this.x + " Y:" + this.y + " Z:" + this.z + " W:" + this.w + "}";
  };
  Vector42.prototype.getClassName = function() {
    return "Vector4";
  };
  Vector42.prototype.getHashCode = function() {
    var hash = this.x | 0;
    hash = hash * 397 ^ (this.y | 0);
    hash = hash * 397 ^ (this.z | 0);
    hash = hash * 397 ^ (this.w | 0);
    return hash;
  };
  Vector42.prototype.asArray = function() {
    var result = new Array();
    this.toArray(result, 0);
    return result;
  };
  Vector42.prototype.toArray = function(array, index) {
    if (index === void 0) {
      index = 0;
    }
    array[index] = this.x;
    array[index + 1] = this.y;
    array[index + 2] = this.z;
    array[index + 3] = this.w;
    return this;
  };
  Vector42.prototype.fromArray = function(array, index) {
    if (index === void 0) {
      index = 0;
    }
    Vector42.FromArrayToRef(array, index, this);
    return this;
  };
  Vector42.prototype.addInPlace = function(otherVector) {
    this.x += otherVector.x;
    this.y += otherVector.y;
    this.z += otherVector.z;
    this.w += otherVector.w;
    return this;
  };
  Vector42.prototype.add = function(otherVector) {
    return new Vector42(this.x + otherVector.x, this.y + otherVector.y, this.z + otherVector.z, this.w + otherVector.w);
  };
  Vector42.prototype.addToRef = function(otherVector, result) {
    result.x = this.x + otherVector.x;
    result.y = this.y + otherVector.y;
    result.z = this.z + otherVector.z;
    result.w = this.w + otherVector.w;
    return this;
  };
  Vector42.prototype.subtractInPlace = function(otherVector) {
    this.x -= otherVector.x;
    this.y -= otherVector.y;
    this.z -= otherVector.z;
    this.w -= otherVector.w;
    return this;
  };
  Vector42.prototype.subtract = function(otherVector) {
    return new Vector42(this.x - otherVector.x, this.y - otherVector.y, this.z - otherVector.z, this.w - otherVector.w);
  };
  Vector42.prototype.subtractToRef = function(otherVector, result) {
    result.x = this.x - otherVector.x;
    result.y = this.y - otherVector.y;
    result.z = this.z - otherVector.z;
    result.w = this.w - otherVector.w;
    return this;
  };
  Vector42.prototype.subtractFromFloats = function(x, y, z, w) {
    return new Vector42(this.x - x, this.y - y, this.z - z, this.w - w);
  };
  Vector42.prototype.subtractFromFloatsToRef = function(x, y, z, w, result) {
    result.x = this.x - x;
    result.y = this.y - y;
    result.z = this.z - z;
    result.w = this.w - w;
    return this;
  };
  Vector42.prototype.negate = function() {
    return new Vector42(-this.x, -this.y, -this.z, -this.w);
  };
  Vector42.prototype.negateInPlace = function() {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;
    this.w *= -1;
    return this;
  };
  Vector42.prototype.negateToRef = function(result) {
    return result.copyFromFloats(this.x * -1, this.y * -1, this.z * -1, this.w * -1);
  };
  Vector42.prototype.scaleInPlace = function(scale) {
    this.x *= scale;
    this.y *= scale;
    this.z *= scale;
    this.w *= scale;
    return this;
  };
  Vector42.prototype.scale = function(scale) {
    return new Vector42(this.x * scale, this.y * scale, this.z * scale, this.w * scale);
  };
  Vector42.prototype.scaleToRef = function(scale, result) {
    result.x = this.x * scale;
    result.y = this.y * scale;
    result.z = this.z * scale;
    result.w = this.w * scale;
    return this;
  };
  Vector42.prototype.scaleAndAddToRef = function(scale, result) {
    result.x += this.x * scale;
    result.y += this.y * scale;
    result.z += this.z * scale;
    result.w += this.w * scale;
    return this;
  };
  Vector42.prototype.equals = function(otherVector) {
    return otherVector && this.x === otherVector.x && this.y === otherVector.y && this.z === otherVector.z && this.w === otherVector.w;
  };
  Vector42.prototype.equalsWithEpsilon = function(otherVector, epsilon) {
    if (epsilon === void 0) {
      epsilon = Epsilon;
    }
    return otherVector && Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) && Scalar.WithinEpsilon(this.y, otherVector.y, epsilon) && Scalar.WithinEpsilon(this.z, otherVector.z, epsilon) && Scalar.WithinEpsilon(this.w, otherVector.w, epsilon);
  };
  Vector42.prototype.equalsToFloats = function(x, y, z, w) {
    return this.x === x && this.y === y && this.z === z && this.w === w;
  };
  Vector42.prototype.multiplyInPlace = function(otherVector) {
    this.x *= otherVector.x;
    this.y *= otherVector.y;
    this.z *= otherVector.z;
    this.w *= otherVector.w;
    return this;
  };
  Vector42.prototype.multiply = function(otherVector) {
    return new Vector42(this.x * otherVector.x, this.y * otherVector.y, this.z * otherVector.z, this.w * otherVector.w);
  };
  Vector42.prototype.multiplyToRef = function(otherVector, result) {
    result.x = this.x * otherVector.x;
    result.y = this.y * otherVector.y;
    result.z = this.z * otherVector.z;
    result.w = this.w * otherVector.w;
    return this;
  };
  Vector42.prototype.multiplyByFloats = function(x, y, z, w) {
    return new Vector42(this.x * x, this.y * y, this.z * z, this.w * w);
  };
  Vector42.prototype.divide = function(otherVector) {
    return new Vector42(this.x / otherVector.x, this.y / otherVector.y, this.z / otherVector.z, this.w / otherVector.w);
  };
  Vector42.prototype.divideToRef = function(otherVector, result) {
    result.x = this.x / otherVector.x;
    result.y = this.y / otherVector.y;
    result.z = this.z / otherVector.z;
    result.w = this.w / otherVector.w;
    return this;
  };
  Vector42.prototype.divideInPlace = function(otherVector) {
    return this.divideToRef(otherVector, this);
  };
  Vector42.prototype.minimizeInPlace = function(other) {
    if (other.x < this.x) {
      this.x = other.x;
    }
    if (other.y < this.y) {
      this.y = other.y;
    }
    if (other.z < this.z) {
      this.z = other.z;
    }
    if (other.w < this.w) {
      this.w = other.w;
    }
    return this;
  };
  Vector42.prototype.maximizeInPlace = function(other) {
    if (other.x > this.x) {
      this.x = other.x;
    }
    if (other.y > this.y) {
      this.y = other.y;
    }
    if (other.z > this.z) {
      this.z = other.z;
    }
    if (other.w > this.w) {
      this.w = other.w;
    }
    return this;
  };
  Vector42.prototype.floor = function() {
    return new Vector42(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z), Math.floor(this.w));
  };
  Vector42.prototype.fract = function() {
    return new Vector42(this.x - Math.floor(this.x), this.y - Math.floor(this.y), this.z - Math.floor(this.z), this.w - Math.floor(this.w));
  };
  Vector42.prototype.length = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  };
  Vector42.prototype.lengthSquared = function() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  };
  Vector42.prototype.normalize = function() {
    var len = this.length();
    if (len === 0) {
      return this;
    }
    return this.scaleInPlace(1 / len);
  };
  Vector42.prototype.toVector3 = function() {
    return new Vector3(this.x, this.y, this.z);
  };
  Vector42.prototype.clone = function() {
    return new Vector42(this.x, this.y, this.z, this.w);
  };
  Vector42.prototype.copyFrom = function(source) {
    this.x = source.x;
    this.y = source.y;
    this.z = source.z;
    this.w = source.w;
    return this;
  };
  Vector42.prototype.copyFromFloats = function(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  };
  Vector42.prototype.set = function(x, y, z, w) {
    return this.copyFromFloats(x, y, z, w);
  };
  Vector42.prototype.setAll = function(v) {
    this.x = this.y = this.z = this.w = v;
    return this;
  };
  Vector42.FromArray = function(array, offset) {
    if (!offset) {
      offset = 0;
    }
    return new Vector42(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);
  };
  Vector42.FromArrayToRef = function(array, offset, result) {
    result.x = array[offset];
    result.y = array[offset + 1];
    result.z = array[offset + 2];
    result.w = array[offset + 3];
  };
  Vector42.FromFloatArrayToRef = function(array, offset, result) {
    Vector42.FromArrayToRef(array, offset, result);
  };
  Vector42.FromFloatsToRef = function(x, y, z, w, result) {
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = w;
  };
  Vector42.Zero = function() {
    return new Vector42(0, 0, 0, 0);
  };
  Vector42.One = function() {
    return new Vector42(1, 1, 1, 1);
  };
  Vector42.Normalize = function(vector) {
    var result = Vector42.Zero();
    Vector42.NormalizeToRef(vector, result);
    return result;
  };
  Vector42.NormalizeToRef = function(vector, result) {
    result.copyFrom(vector);
    result.normalize();
  };
  Vector42.Minimize = function(left, right) {
    var min = left.clone();
    min.minimizeInPlace(right);
    return min;
  };
  Vector42.Maximize = function(left, right) {
    var max = left.clone();
    max.maximizeInPlace(right);
    return max;
  };
  Vector42.Distance = function(value1, value2) {
    return Math.sqrt(Vector42.DistanceSquared(value1, value2));
  };
  Vector42.DistanceSquared = function(value1, value2) {
    var x = value1.x - value2.x;
    var y = value1.y - value2.y;
    var z = value1.z - value2.z;
    var w = value1.w - value2.w;
    return x * x + y * y + z * z + w * w;
  };
  Vector42.Center = function(value1, value2) {
    var center = value1.add(value2);
    center.scaleInPlace(0.5);
    return center;
  };
  Vector42.TransformNormal = function(vector, transformation) {
    var result = Vector42.Zero();
    Vector42.TransformNormalToRef(vector, transformation, result);
    return result;
  };
  Vector42.TransformNormalToRef = function(vector, transformation, result) {
    var m = transformation.m;
    var x = vector.x * m[0] + vector.y * m[4] + vector.z * m[8];
    var y = vector.x * m[1] + vector.y * m[5] + vector.z * m[9];
    var z = vector.x * m[2] + vector.y * m[6] + vector.z * m[10];
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = vector.w;
  };
  Vector42.TransformNormalFromFloatsToRef = function(x, y, z, w, transformation, result) {
    var m = transformation.m;
    result.x = x * m[0] + y * m[4] + z * m[8];
    result.y = x * m[1] + y * m[5] + z * m[9];
    result.z = x * m[2] + y * m[6] + z * m[10];
    result.w = w;
  };
  Vector42.FromVector3 = function(source, w) {
    if (w === void 0) {
      w = 0;
    }
    return new Vector42(source._x, source._y, source._z, w);
  };
  return Vector42;
}();
var Quaternion = function() {
  function Quaternion2(x, y, z, w) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    if (w === void 0) {
      w = 1;
    }
    this._isDirty = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
  }
  Object.defineProperty(Quaternion2.prototype, "x", {
    get: function() {
      return this._x;
    },
    set: function(value) {
      this._x = value;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Quaternion2.prototype, "y", {
    get: function() {
      return this._y;
    },
    set: function(value) {
      this._y = value;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Quaternion2.prototype, "z", {
    get: function() {
      return this._z;
    },
    set: function(value) {
      this._z = value;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Quaternion2.prototype, "w", {
    get: function() {
      return this._w;
    },
    set: function(value) {
      this._w = value;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Quaternion2.prototype.toString = function() {
    return "{X: " + this._x + " Y:" + this._y + " Z:" + this._z + " W:" + this._w + "}";
  };
  Quaternion2.prototype.getClassName = function() {
    return "Quaternion";
  };
  Quaternion2.prototype.getHashCode = function() {
    var hash = this._x | 0;
    hash = hash * 397 ^ (this._y | 0);
    hash = hash * 397 ^ (this._z | 0);
    hash = hash * 397 ^ (this._w | 0);
    return hash;
  };
  Quaternion2.prototype.asArray = function() {
    return [this._x, this._y, this._z, this._w];
  };
  Quaternion2.prototype.equals = function(otherQuaternion) {
    return otherQuaternion && this._x === otherQuaternion._x && this._y === otherQuaternion._y && this._z === otherQuaternion._z && this._w === otherQuaternion._w;
  };
  Quaternion2.prototype.equalsWithEpsilon = function(otherQuaternion, epsilon) {
    if (epsilon === void 0) {
      epsilon = Epsilon;
    }
    return otherQuaternion && Scalar.WithinEpsilon(this._x, otherQuaternion._x, epsilon) && Scalar.WithinEpsilon(this._y, otherQuaternion._y, epsilon) && Scalar.WithinEpsilon(this._z, otherQuaternion._z, epsilon) && Scalar.WithinEpsilon(this._w, otherQuaternion._w, epsilon);
  };
  Quaternion2.prototype.clone = function() {
    return new Quaternion2(this._x, this._y, this._z, this._w);
  };
  Quaternion2.prototype.copyFrom = function(other) {
    this.x = other._x;
    this.y = other._y;
    this.z = other._z;
    this.w = other._w;
    return this;
  };
  Quaternion2.prototype.copyFromFloats = function(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  };
  Quaternion2.prototype.set = function(x, y, z, w) {
    return this.copyFromFloats(x, y, z, w);
  };
  Quaternion2.prototype.add = function(other) {
    return new Quaternion2(this._x + other._x, this._y + other._y, this._z + other._z, this._w + other._w);
  };
  Quaternion2.prototype.addInPlace = function(other) {
    this._x += other._x;
    this._y += other._y;
    this._z += other._z;
    this._w += other._w;
    return this;
  };
  Quaternion2.prototype.subtract = function(other) {
    return new Quaternion2(this._x - other._x, this._y - other._y, this._z - other._z, this._w - other._w);
  };
  Quaternion2.prototype.scale = function(value) {
    return new Quaternion2(this._x * value, this._y * value, this._z * value, this._w * value);
  };
  Quaternion2.prototype.scaleToRef = function(scale, result) {
    result.x = this._x * scale;
    result.y = this._y * scale;
    result.z = this._z * scale;
    result.w = this._w * scale;
    return this;
  };
  Quaternion2.prototype.scaleInPlace = function(value) {
    this.x *= value;
    this.y *= value;
    this.z *= value;
    this.w *= value;
    return this;
  };
  Quaternion2.prototype.scaleAndAddToRef = function(scale, result) {
    result.x += this._x * scale;
    result.y += this._y * scale;
    result.z += this._z * scale;
    result.w += this._w * scale;
    return this;
  };
  Quaternion2.prototype.multiply = function(q1) {
    var result = new Quaternion2(0, 0, 0, 1);
    this.multiplyToRef(q1, result);
    return result;
  };
  Quaternion2.prototype.multiplyToRef = function(q1, result) {
    var x = this._x * q1._w + this._y * q1._z - this._z * q1._y + this._w * q1._x;
    var y = -this._x * q1._z + this._y * q1._w + this._z * q1._x + this._w * q1._y;
    var z = this._x * q1._y - this._y * q1._x + this._z * q1._w + this._w * q1._z;
    var w = -this._x * q1._x - this._y * q1._y - this._z * q1._z + this._w * q1._w;
    result.copyFromFloats(x, y, z, w);
    return this;
  };
  Quaternion2.prototype.multiplyInPlace = function(q1) {
    this.multiplyToRef(q1, this);
    return this;
  };
  Quaternion2.prototype.conjugateToRef = function(ref) {
    ref.copyFromFloats(-this._x, -this._y, -this._z, this._w);
    return this;
  };
  Quaternion2.prototype.conjugateInPlace = function() {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;
    return this;
  };
  Quaternion2.prototype.conjugate = function() {
    var result = new Quaternion2(-this._x, -this._y, -this._z, this._w);
    return result;
  };
  Quaternion2.prototype.length = function() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  };
  Quaternion2.prototype.normalize = function() {
    var len = this.length();
    if (len === 0) {
      return this;
    }
    var inv = 1 / len;
    this.x *= inv;
    this.y *= inv;
    this.z *= inv;
    this.w *= inv;
    return this;
  };
  Quaternion2.prototype.toEulerAngles = function(order) {
    if (order === void 0) {
      order = "YZX";
    }
    var result = Vector3.Zero();
    this.toEulerAnglesToRef(result);
    return result;
  };
  Quaternion2.prototype.toEulerAnglesToRef = function(result) {
    var qz = this._z;
    var qx = this._x;
    var qy = this._y;
    var qw = this._w;
    var sqw = qw * qw;
    var sqz = qz * qz;
    var sqx = qx * qx;
    var sqy = qy * qy;
    var zAxisY = qy * qz - qx * qw;
    var limit = 0.4999999;
    if (zAxisY < -limit) {
      result.y = 2 * Math.atan2(qy, qw);
      result.x = Math.PI / 2;
      result.z = 0;
    } else if (zAxisY > limit) {
      result.y = 2 * Math.atan2(qy, qw);
      result.x = -Math.PI / 2;
      result.z = 0;
    } else {
      result.z = Math.atan2(2 * (qx * qy + qz * qw), -sqz - sqx + sqy + sqw);
      result.x = Math.asin(-2 * (qz * qy - qx * qw));
      result.y = Math.atan2(2 * (qz * qx + qy * qw), sqz - sqx - sqy + sqw);
    }
    return this;
  };
  Quaternion2.prototype.toRotationMatrix = function(result) {
    Matrix.FromQuaternionToRef(this, result);
    return this;
  };
  Quaternion2.prototype.fromRotationMatrix = function(matrix) {
    Quaternion2.FromRotationMatrixToRef(matrix, this);
    return this;
  };
  Quaternion2.FromRotationMatrix = function(matrix) {
    var result = new Quaternion2();
    Quaternion2.FromRotationMatrixToRef(matrix, result);
    return result;
  };
  Quaternion2.FromRotationMatrixToRef = function(matrix, result) {
    var data = matrix.m;
    var m11 = data[0], m12 = data[4], m13 = data[8];
    var m21 = data[1], m22 = data[5], m23 = data[9];
    var m31 = data[2], m32 = data[6], m33 = data[10];
    var trace = m11 + m22 + m33;
    var s;
    if (trace > 0) {
      s = 0.5 / Math.sqrt(trace + 1);
      result.w = 0.25 / s;
      result.x = (m32 - m23) * s;
      result.y = (m13 - m31) * s;
      result.z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      result.w = (m32 - m23) / s;
      result.x = 0.25 * s;
      result.y = (m12 + m21) / s;
      result.z = (m13 + m31) / s;
    } else if (m22 > m33) {
      s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      result.w = (m13 - m31) / s;
      result.x = (m12 + m21) / s;
      result.y = 0.25 * s;
      result.z = (m23 + m32) / s;
    } else {
      s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      result.w = (m21 - m12) / s;
      result.x = (m13 + m31) / s;
      result.y = (m23 + m32) / s;
      result.z = 0.25 * s;
    }
  };
  Quaternion2.Dot = function(left, right) {
    return left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;
  };
  Quaternion2.AreClose = function(quat0, quat1) {
    var dot = Quaternion2.Dot(quat0, quat1);
    return dot >= 0;
  };
  Quaternion2.Zero = function() {
    return new Quaternion2(0, 0, 0, 0);
  };
  Quaternion2.Inverse = function(q) {
    return new Quaternion2(-q._x, -q._y, -q._z, q._w);
  };
  Quaternion2.InverseToRef = function(q, result) {
    result.set(-q._x, -q._y, -q._z, q._w);
    return result;
  };
  Quaternion2.Identity = function() {
    return new Quaternion2(0, 0, 0, 1);
  };
  Quaternion2.IsIdentity = function(quaternion) {
    return quaternion && quaternion._x === 0 && quaternion._y === 0 && quaternion._z === 0 && quaternion._w === 1;
  };
  Quaternion2.RotationAxis = function(axis, angle) {
    return Quaternion2.RotationAxisToRef(axis, angle, new Quaternion2());
  };
  Quaternion2.RotationAxisToRef = function(axis, angle, result) {
    var sin = Math.sin(angle / 2);
    axis.normalize();
    result.w = Math.cos(angle / 2);
    result.x = axis._x * sin;
    result.y = axis._y * sin;
    result.z = axis._z * sin;
    return result;
  };
  Quaternion2.FromArray = function(array, offset) {
    if (!offset) {
      offset = 0;
    }
    return new Quaternion2(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);
  };
  Quaternion2.FromArrayToRef = function(array, offset, result) {
    result.x = array[offset];
    result.y = array[offset + 1];
    result.z = array[offset + 2];
    result.w = array[offset + 3];
  };
  Quaternion2.FromEulerAngles = function(x, y, z) {
    var q = new Quaternion2();
    Quaternion2.RotationYawPitchRollToRef(y, x, z, q);
    return q;
  };
  Quaternion2.FromEulerAnglesToRef = function(x, y, z, result) {
    Quaternion2.RotationYawPitchRollToRef(y, x, z, result);
    return result;
  };
  Quaternion2.FromEulerVector = function(vec) {
    var q = new Quaternion2();
    Quaternion2.RotationYawPitchRollToRef(vec._y, vec._x, vec._z, q);
    return q;
  };
  Quaternion2.FromEulerVectorToRef = function(vec, result) {
    Quaternion2.RotationYawPitchRollToRef(vec._y, vec._x, vec._z, result);
    return result;
  };
  Quaternion2.RotationYawPitchRoll = function(yaw, pitch, roll) {
    var q = new Quaternion2();
    Quaternion2.RotationYawPitchRollToRef(yaw, pitch, roll, q);
    return q;
  };
  Quaternion2.RotationYawPitchRollToRef = function(yaw, pitch, roll, result) {
    var halfRoll = roll * 0.5;
    var halfPitch = pitch * 0.5;
    var halfYaw = yaw * 0.5;
    var sinRoll = Math.sin(halfRoll);
    var cosRoll = Math.cos(halfRoll);
    var sinPitch = Math.sin(halfPitch);
    var cosPitch = Math.cos(halfPitch);
    var sinYaw = Math.sin(halfYaw);
    var cosYaw = Math.cos(halfYaw);
    result.x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll;
    result.y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
    result.z = cosYaw * cosPitch * sinRoll - sinYaw * sinPitch * cosRoll;
    result.w = cosYaw * cosPitch * cosRoll + sinYaw * sinPitch * sinRoll;
  };
  Quaternion2.RotationAlphaBetaGamma = function(alpha, beta, gamma) {
    var result = new Quaternion2();
    Quaternion2.RotationAlphaBetaGammaToRef(alpha, beta, gamma, result);
    return result;
  };
  Quaternion2.RotationAlphaBetaGammaToRef = function(alpha, beta, gamma, result) {
    var halfGammaPlusAlpha = (gamma + alpha) * 0.5;
    var halfGammaMinusAlpha = (gamma - alpha) * 0.5;
    var halfBeta = beta * 0.5;
    result.x = Math.cos(halfGammaMinusAlpha) * Math.sin(halfBeta);
    result.y = Math.sin(halfGammaMinusAlpha) * Math.sin(halfBeta);
    result.z = Math.sin(halfGammaPlusAlpha) * Math.cos(halfBeta);
    result.w = Math.cos(halfGammaPlusAlpha) * Math.cos(halfBeta);
  };
  Quaternion2.RotationQuaternionFromAxis = function(axis1, axis2, axis3) {
    var quat = new Quaternion2(0, 0, 0, 0);
    Quaternion2.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);
    return quat;
  };
  Quaternion2.RotationQuaternionFromAxisToRef = function(axis1, axis2, axis3, ref) {
    var rotMat = MathTmp.Matrix[0];
    Matrix.FromXYZAxesToRef(axis1.normalize(), axis2.normalize(), axis3.normalize(), rotMat);
    Quaternion2.FromRotationMatrixToRef(rotMat, ref);
  };
  Quaternion2.Slerp = function(left, right, amount) {
    var result = Quaternion2.Identity();
    Quaternion2.SlerpToRef(left, right, amount, result);
    return result;
  };
  Quaternion2.SlerpToRef = function(left, right, amount, result) {
    var num2;
    var num3;
    var num4 = left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;
    var flag = false;
    if (num4 < 0) {
      flag = true;
      num4 = -num4;
    }
    if (num4 > 0.999999) {
      num3 = 1 - amount;
      num2 = flag ? -amount : amount;
    } else {
      var num5 = Math.acos(num4);
      var num6 = 1 / Math.sin(num5);
      num3 = Math.sin((1 - amount) * num5) * num6;
      num2 = flag ? -Math.sin(amount * num5) * num6 : Math.sin(amount * num5) * num6;
    }
    result.x = num3 * left._x + num2 * right._x;
    result.y = num3 * left._y + num2 * right._y;
    result.z = num3 * left._z + num2 * right._z;
    result.w = num3 * left._w + num2 * right._w;
  };
  Quaternion2.Hermite = function(value1, tangent1, value2, tangent2, amount) {
    var squared = amount * amount;
    var cubed = amount * squared;
    var part1 = 2 * cubed - 3 * squared + 1;
    var part2 = -2 * cubed + 3 * squared;
    var part3 = cubed - 2 * squared + amount;
    var part4 = cubed - squared;
    var x = value1._x * part1 + value2._x * part2 + tangent1._x * part3 + tangent2._x * part4;
    var y = value1._y * part1 + value2._y * part2 + tangent1._y * part3 + tangent2._y * part4;
    var z = value1._z * part1 + value2._z * part2 + tangent1._z * part3 + tangent2._z * part4;
    var w = value1._w * part1 + value2._w * part2 + tangent1._w * part3 + tangent2._w * part4;
    return new Quaternion2(x, y, z, w);
  };
  return Quaternion2;
}();
var Matrix = function() {
  function Matrix2() {
    this._isIdentity = false;
    this._isIdentityDirty = true;
    this._isIdentity3x2 = true;
    this._isIdentity3x2Dirty = true;
    this.updateFlag = -1;
    if (PerformanceConfigurator.MatrixTrackPrecisionChange) {
      PerformanceConfigurator.MatrixTrackedMatrices.push(this);
    }
    this._m = new PerformanceConfigurator.MatrixCurrentType(16);
    this._updateIdentityStatus(false);
  }
  Object.defineProperty(Matrix2, "Use64Bits", {
    get: function() {
      return PerformanceConfigurator.MatrixUse64Bits;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Matrix2.prototype, "m", {
    get: function() {
      return this._m;
    },
    enumerable: false,
    configurable: true
  });
  Matrix2.prototype._markAsUpdated = function() {
    this.updateFlag = Matrix2._updateFlagSeed++;
    this._isIdentity = false;
    this._isIdentity3x2 = false;
    this._isIdentityDirty = true;
    this._isIdentity3x2Dirty = true;
  };
  Matrix2.prototype._updateIdentityStatus = function(isIdentity, isIdentityDirty, isIdentity3x2, isIdentity3x2Dirty) {
    if (isIdentityDirty === void 0) {
      isIdentityDirty = false;
    }
    if (isIdentity3x2 === void 0) {
      isIdentity3x2 = false;
    }
    if (isIdentity3x2Dirty === void 0) {
      isIdentity3x2Dirty = true;
    }
    this.updateFlag = Matrix2._updateFlagSeed++;
    this._isIdentity = isIdentity;
    this._isIdentity3x2 = isIdentity || isIdentity3x2;
    this._isIdentityDirty = this._isIdentity ? false : isIdentityDirty;
    this._isIdentity3x2Dirty = this._isIdentity3x2 ? false : isIdentity3x2Dirty;
  };
  Matrix2.prototype.isIdentity = function() {
    if (this._isIdentityDirty) {
      this._isIdentityDirty = false;
      var m = this._m;
      this._isIdentity = m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 0 && m[5] === 1 && m[6] === 0 && m[7] === 0 && m[8] === 0 && m[9] === 0 && m[10] === 1 && m[11] === 0 && m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1;
    }
    return this._isIdentity;
  };
  Matrix2.prototype.isIdentityAs3x2 = function() {
    if (this._isIdentity3x2Dirty) {
      this._isIdentity3x2Dirty = false;
      if (this._m[0] !== 1 || this._m[5] !== 1 || this._m[15] !== 1) {
        this._isIdentity3x2 = false;
      } else if (this._m[1] !== 0 || this._m[2] !== 0 || this._m[3] !== 0 || this._m[4] !== 0 || this._m[6] !== 0 || this._m[7] !== 0 || this._m[8] !== 0 || this._m[9] !== 0 || this._m[10] !== 0 || this._m[11] !== 0 || this._m[12] !== 0 || this._m[13] !== 0 || this._m[14] !== 0) {
        this._isIdentity3x2 = false;
      } else {
        this._isIdentity3x2 = true;
      }
    }
    return this._isIdentity3x2;
  };
  Matrix2.prototype.determinant = function() {
    if (this._isIdentity === true) {
      return 1;
    }
    var m = this._m;
    var m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];
    var m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];
    var m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];
    var m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];
    var det_22_33 = m22 * m33 - m32 * m23;
    var det_21_33 = m21 * m33 - m31 * m23;
    var det_21_32 = m21 * m32 - m31 * m22;
    var det_20_33 = m20 * m33 - m30 * m23;
    var det_20_32 = m20 * m32 - m22 * m30;
    var det_20_31 = m20 * m31 - m30 * m21;
    var cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);
    var cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);
    var cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);
    var cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);
    return m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;
  };
  Matrix2.prototype.toArray = function() {
    return this._m;
  };
  Matrix2.prototype.asArray = function() {
    return this._m;
  };
  Matrix2.prototype.invert = function() {
    this.invertToRef(this);
    return this;
  };
  Matrix2.prototype.reset = function() {
    Matrix2.FromValuesToRef(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, this);
    this._updateIdentityStatus(false);
    return this;
  };
  Matrix2.prototype.add = function(other) {
    var result = new Matrix2();
    this.addToRef(other, result);
    return result;
  };
  Matrix2.prototype.addToRef = function(other, result) {
    var m = this._m;
    var resultM = result._m;
    var otherM = other.m;
    for (var index = 0; index < 16; index++) {
      resultM[index] = m[index] + otherM[index];
    }
    result._markAsUpdated();
    return this;
  };
  Matrix2.prototype.addToSelf = function(other) {
    var m = this._m;
    var otherM = other.m;
    for (var index = 0; index < 16; index++) {
      m[index] += otherM[index];
    }
    this._markAsUpdated();
    return this;
  };
  Matrix2.prototype.invertToRef = function(other) {
    if (this._isIdentity === true) {
      Matrix2.IdentityToRef(other);
      return this;
    }
    var m = this._m;
    var m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];
    var m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];
    var m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];
    var m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];
    var det_22_33 = m22 * m33 - m32 * m23;
    var det_21_33 = m21 * m33 - m31 * m23;
    var det_21_32 = m21 * m32 - m31 * m22;
    var det_20_33 = m20 * m33 - m30 * m23;
    var det_20_32 = m20 * m32 - m22 * m30;
    var det_20_31 = m20 * m31 - m30 * m21;
    var cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);
    var cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);
    var cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);
    var cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);
    var det = m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;
    if (det === 0) {
      other.copyFrom(this);
      return this;
    }
    var detInv = 1 / det;
    var det_12_33 = m12 * m33 - m32 * m13;
    var det_11_33 = m11 * m33 - m31 * m13;
    var det_11_32 = m11 * m32 - m31 * m12;
    var det_10_33 = m10 * m33 - m30 * m13;
    var det_10_32 = m10 * m32 - m30 * m12;
    var det_10_31 = m10 * m31 - m30 * m11;
    var det_12_23 = m12 * m23 - m22 * m13;
    var det_11_23 = m11 * m23 - m21 * m13;
    var det_11_22 = m11 * m22 - m21 * m12;
    var det_10_23 = m10 * m23 - m20 * m13;
    var det_10_22 = m10 * m22 - m20 * m12;
    var det_10_21 = m10 * m21 - m20 * m11;
    var cofact_10 = -(m01 * det_22_33 - m02 * det_21_33 + m03 * det_21_32);
    var cofact_11 = +(m00 * det_22_33 - m02 * det_20_33 + m03 * det_20_32);
    var cofact_12 = -(m00 * det_21_33 - m01 * det_20_33 + m03 * det_20_31);
    var cofact_13 = +(m00 * det_21_32 - m01 * det_20_32 + m02 * det_20_31);
    var cofact_20 = +(m01 * det_12_33 - m02 * det_11_33 + m03 * det_11_32);
    var cofact_21 = -(m00 * det_12_33 - m02 * det_10_33 + m03 * det_10_32);
    var cofact_22 = +(m00 * det_11_33 - m01 * det_10_33 + m03 * det_10_31);
    var cofact_23 = -(m00 * det_11_32 - m01 * det_10_32 + m02 * det_10_31);
    var cofact_30 = -(m01 * det_12_23 - m02 * det_11_23 + m03 * det_11_22);
    var cofact_31 = +(m00 * det_12_23 - m02 * det_10_23 + m03 * det_10_22);
    var cofact_32 = -(m00 * det_11_23 - m01 * det_10_23 + m03 * det_10_21);
    var cofact_33 = +(m00 * det_11_22 - m01 * det_10_22 + m02 * det_10_21);
    Matrix2.FromValuesToRef(cofact_00 * detInv, cofact_10 * detInv, cofact_20 * detInv, cofact_30 * detInv, cofact_01 * detInv, cofact_11 * detInv, cofact_21 * detInv, cofact_31 * detInv, cofact_02 * detInv, cofact_12 * detInv, cofact_22 * detInv, cofact_32 * detInv, cofact_03 * detInv, cofact_13 * detInv, cofact_23 * detInv, cofact_33 * detInv, other);
    return this;
  };
  Matrix2.prototype.addAtIndex = function(index, value) {
    this._m[index] += value;
    this._markAsUpdated();
    return this;
  };
  Matrix2.prototype.multiplyAtIndex = function(index, value) {
    this._m[index] *= value;
    this._markAsUpdated();
    return this;
  };
  Matrix2.prototype.setTranslationFromFloats = function(x, y, z) {
    this._m[12] = x;
    this._m[13] = y;
    this._m[14] = z;
    this._markAsUpdated();
    return this;
  };
  Matrix2.prototype.addTranslationFromFloats = function(x, y, z) {
    this._m[12] += x;
    this._m[13] += y;
    this._m[14] += z;
    this._markAsUpdated();
    return this;
  };
  Matrix2.prototype.setTranslation = function(vector3) {
    return this.setTranslationFromFloats(vector3._x, vector3._y, vector3._z);
  };
  Matrix2.prototype.getTranslation = function() {
    return new Vector3(this._m[12], this._m[13], this._m[14]);
  };
  Matrix2.prototype.getTranslationToRef = function(result) {
    result.x = this._m[12];
    result.y = this._m[13];
    result.z = this._m[14];
    return this;
  };
  Matrix2.prototype.removeRotationAndScaling = function() {
    var m = this.m;
    Matrix2.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, m[12], m[13], m[14], m[15], this);
    this._updateIdentityStatus(m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1);
    return this;
  };
  Matrix2.prototype.multiply = function(other) {
    var result = new Matrix2();
    this.multiplyToRef(other, result);
    return result;
  };
  Matrix2.prototype.copyFrom = function(other) {
    other.copyToArray(this._m);
    var o = other;
    this._updateIdentityStatus(o._isIdentity, o._isIdentityDirty, o._isIdentity3x2, o._isIdentity3x2Dirty);
    return this;
  };
  Matrix2.prototype.copyToArray = function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    var source = this._m;
    array[offset] = source[0];
    array[offset + 1] = source[1];
    array[offset + 2] = source[2];
    array[offset + 3] = source[3];
    array[offset + 4] = source[4];
    array[offset + 5] = source[5];
    array[offset + 6] = source[6];
    array[offset + 7] = source[7];
    array[offset + 8] = source[8];
    array[offset + 9] = source[9];
    array[offset + 10] = source[10];
    array[offset + 11] = source[11];
    array[offset + 12] = source[12];
    array[offset + 13] = source[13];
    array[offset + 14] = source[14];
    array[offset + 15] = source[15];
    return this;
  };
  Matrix2.prototype.multiplyToRef = function(other, result) {
    if (this._isIdentity) {
      result.copyFrom(other);
      return this;
    }
    if (other._isIdentity) {
      result.copyFrom(this);
      return this;
    }
    this.multiplyToArray(other, result._m, 0);
    result._markAsUpdated();
    return this;
  };
  Matrix2.prototype.multiplyToArray = function(other, result, offset) {
    var m = this._m;
    var otherM = other.m;
    var tm0 = m[0], tm1 = m[1], tm2 = m[2], tm3 = m[3];
    var tm4 = m[4], tm5 = m[5], tm6 = m[6], tm7 = m[7];
    var tm8 = m[8], tm9 = m[9], tm10 = m[10], tm11 = m[11];
    var tm12 = m[12], tm13 = m[13], tm14 = m[14], tm15 = m[15];
    var om0 = otherM[0], om1 = otherM[1], om2 = otherM[2], om3 = otherM[3];
    var om4 = otherM[4], om5 = otherM[5], om6 = otherM[6], om7 = otherM[7];
    var om8 = otherM[8], om9 = otherM[9], om10 = otherM[10], om11 = otherM[11];
    var om12 = otherM[12], om13 = otherM[13], om14 = otherM[14], om15 = otherM[15];
    result[offset] = tm0 * om0 + tm1 * om4 + tm2 * om8 + tm3 * om12;
    result[offset + 1] = tm0 * om1 + tm1 * om5 + tm2 * om9 + tm3 * om13;
    result[offset + 2] = tm0 * om2 + tm1 * om6 + tm2 * om10 + tm3 * om14;
    result[offset + 3] = tm0 * om3 + tm1 * om7 + tm2 * om11 + tm3 * om15;
    result[offset + 4] = tm4 * om0 + tm5 * om4 + tm6 * om8 + tm7 * om12;
    result[offset + 5] = tm4 * om1 + tm5 * om5 + tm6 * om9 + tm7 * om13;
    result[offset + 6] = tm4 * om2 + tm5 * om6 + tm6 * om10 + tm7 * om14;
    result[offset + 7] = tm4 * om3 + tm5 * om7 + tm6 * om11 + tm7 * om15;
    result[offset + 8] = tm8 * om0 + tm9 * om4 + tm10 * om8 + tm11 * om12;
    result[offset + 9] = tm8 * om1 + tm9 * om5 + tm10 * om9 + tm11 * om13;
    result[offset + 10] = tm8 * om2 + tm9 * om6 + tm10 * om10 + tm11 * om14;
    result[offset + 11] = tm8 * om3 + tm9 * om7 + tm10 * om11 + tm11 * om15;
    result[offset + 12] = tm12 * om0 + tm13 * om4 + tm14 * om8 + tm15 * om12;
    result[offset + 13] = tm12 * om1 + tm13 * om5 + tm14 * om9 + tm15 * om13;
    result[offset + 14] = tm12 * om2 + tm13 * om6 + tm14 * om10 + tm15 * om14;
    result[offset + 15] = tm12 * om3 + tm13 * om7 + tm14 * om11 + tm15 * om15;
    return this;
  };
  Matrix2.prototype.equals = function(value) {
    var other = value;
    if (!other) {
      return false;
    }
    if (this._isIdentity || other._isIdentity) {
      if (!this._isIdentityDirty && !other._isIdentityDirty) {
        return this._isIdentity && other._isIdentity;
      }
    }
    var m = this.m;
    var om = other.m;
    return m[0] === om[0] && m[1] === om[1] && m[2] === om[2] && m[3] === om[3] && m[4] === om[4] && m[5] === om[5] && m[6] === om[6] && m[7] === om[7] && m[8] === om[8] && m[9] === om[9] && m[10] === om[10] && m[11] === om[11] && m[12] === om[12] && m[13] === om[13] && m[14] === om[14] && m[15] === om[15];
  };
  Matrix2.prototype.clone = function() {
    var matrix = new Matrix2();
    matrix.copyFrom(this);
    return matrix;
  };
  Matrix2.prototype.getClassName = function() {
    return "Matrix";
  };
  Matrix2.prototype.getHashCode = function() {
    var hash = this._m[0] | 0;
    for (var i = 1; i < 16; i++) {
      hash = hash * 397 ^ (this._m[i] | 0);
    }
    return hash;
  };
  Matrix2.prototype.decompose = function(scale, rotation, translation) {
    if (this._isIdentity) {
      if (translation) {
        translation.setAll(0);
      }
      if (scale) {
        scale.setAll(1);
      }
      if (rotation) {
        rotation.copyFromFloats(0, 0, 0, 1);
      }
      return true;
    }
    var m = this._m;
    if (translation) {
      translation.copyFromFloats(m[12], m[13], m[14]);
    }
    scale = scale || MathTmp.Vector3[0];
    scale.x = Math.sqrt(m[0] * m[0] + m[1] * m[1] + m[2] * m[2]);
    scale.y = Math.sqrt(m[4] * m[4] + m[5] * m[5] + m[6] * m[6]);
    scale.z = Math.sqrt(m[8] * m[8] + m[9] * m[9] + m[10] * m[10]);
    if (this.determinant() <= 0) {
      scale.y *= -1;
    }
    if (scale._x === 0 || scale._y === 0 || scale._z === 0) {
      if (rotation) {
        rotation.copyFromFloats(0, 0, 0, 1);
      }
      return false;
    }
    if (rotation) {
      var sx = 1 / scale._x, sy = 1 / scale._y, sz = 1 / scale._z;
      Matrix2.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0, m[4] * sy, m[5] * sy, m[6] * sy, 0, m[8] * sz, m[9] * sz, m[10] * sz, 0, 0, 0, 0, 1, MathTmp.Matrix[0]);
      Quaternion.FromRotationMatrixToRef(MathTmp.Matrix[0], rotation);
    }
    return true;
  };
  Matrix2.prototype.getRow = function(index) {
    if (index < 0 || index > 3) {
      return null;
    }
    var i = index * 4;
    return new Vector4(this._m[i + 0], this._m[i + 1], this._m[i + 2], this._m[i + 3]);
  };
  Matrix2.prototype.setRow = function(index, row) {
    return this.setRowFromFloats(index, row.x, row.y, row.z, row.w);
  };
  Matrix2.prototype.transpose = function() {
    return Matrix2.Transpose(this);
  };
  Matrix2.prototype.transposeToRef = function(result) {
    Matrix2.TransposeToRef(this, result);
    return this;
  };
  Matrix2.prototype.setRowFromFloats = function(index, x, y, z, w) {
    if (index < 0 || index > 3) {
      return this;
    }
    var i = index * 4;
    this._m[i + 0] = x;
    this._m[i + 1] = y;
    this._m[i + 2] = z;
    this._m[i + 3] = w;
    this._markAsUpdated();
    return this;
  };
  Matrix2.prototype.scale = function(scale) {
    var result = new Matrix2();
    this.scaleToRef(scale, result);
    return result;
  };
  Matrix2.prototype.scaleToRef = function(scale, result) {
    for (var index = 0; index < 16; index++) {
      result._m[index] = this._m[index] * scale;
    }
    result._markAsUpdated();
    return this;
  };
  Matrix2.prototype.scaleAndAddToRef = function(scale, result) {
    for (var index = 0; index < 16; index++) {
      result._m[index] += this._m[index] * scale;
    }
    result._markAsUpdated();
    return this;
  };
  Matrix2.prototype.toNormalMatrix = function(ref) {
    var tmp = MathTmp.Matrix[0];
    this.invertToRef(tmp);
    tmp.transposeToRef(ref);
    var m = ref._m;
    Matrix2.FromValuesToRef(m[0], m[1], m[2], 0, m[4], m[5], m[6], 0, m[8], m[9], m[10], 0, 0, 0, 0, 1, ref);
  };
  Matrix2.prototype.getRotationMatrix = function() {
    var result = new Matrix2();
    this.getRotationMatrixToRef(result);
    return result;
  };
  Matrix2.prototype.getRotationMatrixToRef = function(result) {
    var scale = MathTmp.Vector3[0];
    if (!this.decompose(scale)) {
      Matrix2.IdentityToRef(result);
      return this;
    }
    var m = this._m;
    var sx = 1 / scale._x, sy = 1 / scale._y, sz = 1 / scale._z;
    Matrix2.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0, m[4] * sy, m[5] * sy, m[6] * sy, 0, m[8] * sz, m[9] * sz, m[10] * sz, 0, 0, 0, 0, 1, result);
    return this;
  };
  Matrix2.prototype.toggleModelMatrixHandInPlace = function() {
    var m = this._m;
    m[2] *= -1;
    m[6] *= -1;
    m[8] *= -1;
    m[9] *= -1;
    m[14] *= -1;
    this._markAsUpdated();
  };
  Matrix2.prototype.toggleProjectionMatrixHandInPlace = function() {
    var m = this._m;
    m[8] *= -1;
    m[9] *= -1;
    m[10] *= -1;
    m[11] *= -1;
    this._markAsUpdated();
  };
  Matrix2.FromArray = function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    var result = new Matrix2();
    Matrix2.FromArrayToRef(array, offset, result);
    return result;
  };
  Matrix2.FromArrayToRef = function(array, offset, result) {
    for (var index = 0; index < 16; index++) {
      result._m[index] = array[index + offset];
    }
    result._markAsUpdated();
  };
  Matrix2.FromFloat32ArrayToRefScaled = function(array, offset, scale, result) {
    for (var index = 0; index < 16; index++) {
      result._m[index] = array[index + offset] * scale;
    }
    result._markAsUpdated();
  };
  Object.defineProperty(Matrix2, "IdentityReadOnly", {
    get: function() {
      return Matrix2._identityReadOnly;
    },
    enumerable: false,
    configurable: true
  });
  Matrix2.FromValuesToRef = function(initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44, result) {
    var m = result._m;
    m[0] = initialM11;
    m[1] = initialM12;
    m[2] = initialM13;
    m[3] = initialM14;
    m[4] = initialM21;
    m[5] = initialM22;
    m[6] = initialM23;
    m[7] = initialM24;
    m[8] = initialM31;
    m[9] = initialM32;
    m[10] = initialM33;
    m[11] = initialM34;
    m[12] = initialM41;
    m[13] = initialM42;
    m[14] = initialM43;
    m[15] = initialM44;
    result._markAsUpdated();
  };
  Matrix2.FromValues = function(initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44) {
    var result = new Matrix2();
    var m = result._m;
    m[0] = initialM11;
    m[1] = initialM12;
    m[2] = initialM13;
    m[3] = initialM14;
    m[4] = initialM21;
    m[5] = initialM22;
    m[6] = initialM23;
    m[7] = initialM24;
    m[8] = initialM31;
    m[9] = initialM32;
    m[10] = initialM33;
    m[11] = initialM34;
    m[12] = initialM41;
    m[13] = initialM42;
    m[14] = initialM43;
    m[15] = initialM44;
    result._markAsUpdated();
    return result;
  };
  Matrix2.Compose = function(scale, rotation, translation) {
    var result = new Matrix2();
    Matrix2.ComposeToRef(scale, rotation, translation, result);
    return result;
  };
  Matrix2.ComposeToRef = function(scale, rotation, translation, result) {
    var m = result._m;
    var x = rotation._x, y = rotation._y, z = rotation._z, w = rotation._w;
    var x2 = x + x, y2 = y + y, z2 = z + z;
    var xx = x * x2, xy = x * y2, xz = x * z2;
    var yy = y * y2, yz = y * z2, zz = z * z2;
    var wx = w * x2, wy = w * y2, wz = w * z2;
    var sx = scale._x, sy = scale._y, sz = scale._z;
    m[0] = (1 - (yy + zz)) * sx;
    m[1] = (xy + wz) * sx;
    m[2] = (xz - wy) * sx;
    m[3] = 0;
    m[4] = (xy - wz) * sy;
    m[5] = (1 - (xx + zz)) * sy;
    m[6] = (yz + wx) * sy;
    m[7] = 0;
    m[8] = (xz + wy) * sz;
    m[9] = (yz - wx) * sz;
    m[10] = (1 - (xx + yy)) * sz;
    m[11] = 0;
    m[12] = translation._x;
    m[13] = translation._y;
    m[14] = translation._z;
    m[15] = 1;
    result._markAsUpdated();
  };
  Matrix2.Identity = function() {
    var identity = Matrix2.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    identity._updateIdentityStatus(true);
    return identity;
  };
  Matrix2.IdentityToRef = function(result) {
    Matrix2.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, result);
    result._updateIdentityStatus(true);
  };
  Matrix2.Zero = function() {
    var zero = Matrix2.FromValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    zero._updateIdentityStatus(false);
    return zero;
  };
  Matrix2.RotationX = function(angle) {
    var result = new Matrix2();
    Matrix2.RotationXToRef(angle, result);
    return result;
  };
  Matrix2.Invert = function(source) {
    var result = new Matrix2();
    source.invertToRef(result);
    return result;
  };
  Matrix2.RotationXToRef = function(angle, result) {
    var s = Math.sin(angle);
    var c = Math.cos(angle);
    Matrix2.FromValuesToRef(1, 0, 0, 0, 0, c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, result);
    result._updateIdentityStatus(c === 1 && s === 0);
  };
  Matrix2.RotationY = function(angle) {
    var result = new Matrix2();
    Matrix2.RotationYToRef(angle, result);
    return result;
  };
  Matrix2.RotationYToRef = function(angle, result) {
    var s = Math.sin(angle);
    var c = Math.cos(angle);
    Matrix2.FromValuesToRef(c, 0, -s, 0, 0, 1, 0, 0, s, 0, c, 0, 0, 0, 0, 1, result);
    result._updateIdentityStatus(c === 1 && s === 0);
  };
  Matrix2.RotationZ = function(angle) {
    var result = new Matrix2();
    Matrix2.RotationZToRef(angle, result);
    return result;
  };
  Matrix2.RotationZToRef = function(angle, result) {
    var s = Math.sin(angle);
    var c = Math.cos(angle);
    Matrix2.FromValuesToRef(c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, result);
    result._updateIdentityStatus(c === 1 && s === 0);
  };
  Matrix2.RotationAxis = function(axis, angle) {
    var result = new Matrix2();
    Matrix2.RotationAxisToRef(axis, angle, result);
    return result;
  };
  Matrix2.RotationAxisToRef = function(axis, angle, result) {
    var s = Math.sin(-angle);
    var c = Math.cos(-angle);
    var c1 = 1 - c;
    axis.normalize();
    var m = result._m;
    m[0] = axis._x * axis._x * c1 + c;
    m[1] = axis._x * axis._y * c1 - axis._z * s;
    m[2] = axis._x * axis._z * c1 + axis._y * s;
    m[3] = 0;
    m[4] = axis._y * axis._x * c1 + axis._z * s;
    m[5] = axis._y * axis._y * c1 + c;
    m[6] = axis._y * axis._z * c1 - axis._x * s;
    m[7] = 0;
    m[8] = axis._z * axis._x * c1 - axis._y * s;
    m[9] = axis._z * axis._y * c1 + axis._x * s;
    m[10] = axis._z * axis._z * c1 + c;
    m[11] = 0;
    m[12] = 0;
    m[13] = 0;
    m[14] = 0;
    m[15] = 1;
    result._markAsUpdated();
  };
  Matrix2.RotationAlignToRef = function(from, to, result) {
    var v = Vector3.Cross(to, from);
    var c = Vector3.Dot(to, from);
    var k = 1 / (1 + c);
    var m = result._m;
    m[0] = v._x * v._x * k + c;
    m[1] = v._y * v._x * k - v._z;
    m[2] = v._z * v._x * k + v._y;
    m[3] = 0;
    m[4] = v._x * v._y * k + v._z;
    m[5] = v._y * v._y * k + c;
    m[6] = v._z * v._y * k - v._x;
    m[7] = 0;
    m[8] = v._x * v._z * k - v._y;
    m[9] = v._y * v._z * k + v._x;
    m[10] = v._z * v._z * k + c;
    m[11] = 0;
    m[12] = 0;
    m[13] = 0;
    m[14] = 0;
    m[15] = 1;
    result._markAsUpdated();
  };
  Matrix2.RotationYawPitchRoll = function(yaw, pitch, roll) {
    var result = new Matrix2();
    Matrix2.RotationYawPitchRollToRef(yaw, pitch, roll, result);
    return result;
  };
  Matrix2.RotationYawPitchRollToRef = function(yaw, pitch, roll, result) {
    Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, MathTmp.Quaternion[0]);
    MathTmp.Quaternion[0].toRotationMatrix(result);
  };
  Matrix2.Scaling = function(x, y, z) {
    var result = new Matrix2();
    Matrix2.ScalingToRef(x, y, z, result);
    return result;
  };
  Matrix2.ScalingToRef = function(x, y, z, result) {
    Matrix2.FromValuesToRef(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1, result);
    result._updateIdentityStatus(x === 1 && y === 1 && z === 1);
  };
  Matrix2.Translation = function(x, y, z) {
    var result = new Matrix2();
    Matrix2.TranslationToRef(x, y, z, result);
    return result;
  };
  Matrix2.TranslationToRef = function(x, y, z, result) {
    Matrix2.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, z, 1, result);
    result._updateIdentityStatus(x === 0 && y === 0 && z === 0);
  };
  Matrix2.Lerp = function(startValue, endValue, gradient) {
    var result = new Matrix2();
    Matrix2.LerpToRef(startValue, endValue, gradient, result);
    return result;
  };
  Matrix2.LerpToRef = function(startValue, endValue, gradient, result) {
    var resultM = result._m;
    var startM = startValue.m;
    var endM = endValue.m;
    for (var index = 0; index < 16; index++) {
      resultM[index] = startM[index] * (1 - gradient) + endM[index] * gradient;
    }
    result._markAsUpdated();
  };
  Matrix2.DecomposeLerp = function(startValue, endValue, gradient) {
    var result = new Matrix2();
    Matrix2.DecomposeLerpToRef(startValue, endValue, gradient, result);
    return result;
  };
  Matrix2.DecomposeLerpToRef = function(startValue, endValue, gradient, result) {
    var startScale = MathTmp.Vector3[0];
    var startRotation = MathTmp.Quaternion[0];
    var startTranslation = MathTmp.Vector3[1];
    startValue.decompose(startScale, startRotation, startTranslation);
    var endScale = MathTmp.Vector3[2];
    var endRotation = MathTmp.Quaternion[1];
    var endTranslation = MathTmp.Vector3[3];
    endValue.decompose(endScale, endRotation, endTranslation);
    var resultScale = MathTmp.Vector3[4];
    Vector3.LerpToRef(startScale, endScale, gradient, resultScale);
    var resultRotation = MathTmp.Quaternion[2];
    Quaternion.SlerpToRef(startRotation, endRotation, gradient, resultRotation);
    var resultTranslation = MathTmp.Vector3[5];
    Vector3.LerpToRef(startTranslation, endTranslation, gradient, resultTranslation);
    Matrix2.ComposeToRef(resultScale, resultRotation, resultTranslation, result);
  };
  Matrix2.LookAtLH = function(eye, target, up) {
    var result = new Matrix2();
    Matrix2.LookAtLHToRef(eye, target, up, result);
    return result;
  };
  Matrix2.LookAtLHToRef = function(eye, target, up, result) {
    var xAxis = MathTmp.Vector3[0];
    var yAxis = MathTmp.Vector3[1];
    var zAxis = MathTmp.Vector3[2];
    target.subtractToRef(eye, zAxis);
    zAxis.normalize();
    Vector3.CrossToRef(up, zAxis, xAxis);
    var xSquareLength = xAxis.lengthSquared();
    if (xSquareLength === 0) {
      xAxis.x = 1;
    } else {
      xAxis.normalizeFromLength(Math.sqrt(xSquareLength));
    }
    Vector3.CrossToRef(zAxis, xAxis, yAxis);
    yAxis.normalize();
    var ex = -Vector3.Dot(xAxis, eye);
    var ey = -Vector3.Dot(yAxis, eye);
    var ez = -Vector3.Dot(zAxis, eye);
    Matrix2.FromValuesToRef(xAxis._x, yAxis._x, zAxis._x, 0, xAxis._y, yAxis._y, zAxis._y, 0, xAxis._z, yAxis._z, zAxis._z, 0, ex, ey, ez, 1, result);
  };
  Matrix2.LookAtRH = function(eye, target, up) {
    var result = new Matrix2();
    Matrix2.LookAtRHToRef(eye, target, up, result);
    return result;
  };
  Matrix2.LookAtRHToRef = function(eye, target, up, result) {
    var xAxis = MathTmp.Vector3[0];
    var yAxis = MathTmp.Vector3[1];
    var zAxis = MathTmp.Vector3[2];
    eye.subtractToRef(target, zAxis);
    zAxis.normalize();
    Vector3.CrossToRef(up, zAxis, xAxis);
    var xSquareLength = xAxis.lengthSquared();
    if (xSquareLength === 0) {
      xAxis.x = 1;
    } else {
      xAxis.normalizeFromLength(Math.sqrt(xSquareLength));
    }
    Vector3.CrossToRef(zAxis, xAxis, yAxis);
    yAxis.normalize();
    var ex = -Vector3.Dot(xAxis, eye);
    var ey = -Vector3.Dot(yAxis, eye);
    var ez = -Vector3.Dot(zAxis, eye);
    Matrix2.FromValuesToRef(xAxis._x, yAxis._x, zAxis._x, 0, xAxis._y, yAxis._y, zAxis._y, 0, xAxis._z, yAxis._z, zAxis._z, 0, ex, ey, ez, 1, result);
  };
  Matrix2.OrthoLH = function(width, height, znear, zfar) {
    var matrix = new Matrix2();
    Matrix2.OrthoLHToRef(width, height, znear, zfar, matrix);
    return matrix;
  };
  Matrix2.OrthoLHToRef = function(width, height, znear, zfar, result) {
    var n = znear;
    var f = zfar;
    var a = 2 / width;
    var b = 2 / height;
    var c = 2 / (f - n);
    var d = -(f + n) / (f - n);
    Matrix2.FromValuesToRef(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, d, 1, result);
    result._updateIdentityStatus(a === 1 && b === 1 && c === 1 && d === 0);
  };
  Matrix2.OrthoOffCenterLH = function(left, right, bottom, top, znear, zfar) {
    var matrix = new Matrix2();
    Matrix2.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, matrix);
    return matrix;
  };
  Matrix2.OrthoOffCenterLHToRef = function(left, right, bottom, top, znear, zfar, result) {
    var n = znear;
    var f = zfar;
    var a = 2 / (right - left);
    var b = 2 / (top - bottom);
    var c = 2 / (f - n);
    var d = -(f + n) / (f - n);
    var i0 = (left + right) / (left - right);
    var i1 = (top + bottom) / (bottom - top);
    Matrix2.FromValuesToRef(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, i0, i1, d, 1, result);
    result._markAsUpdated();
  };
  Matrix2.OrthoOffCenterRH = function(left, right, bottom, top, znear, zfar) {
    var matrix = new Matrix2();
    Matrix2.OrthoOffCenterRHToRef(left, right, bottom, top, znear, zfar, matrix);
    return matrix;
  };
  Matrix2.OrthoOffCenterRHToRef = function(left, right, bottom, top, znear, zfar, result) {
    Matrix2.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, result);
    result._m[10] *= -1;
  };
  Matrix2.PerspectiveLH = function(width, height, znear, zfar) {
    var matrix = new Matrix2();
    var n = znear;
    var f = zfar;
    var a = 2 * n / width;
    var b = 2 * n / height;
    var c = (f + n) / (f - n);
    var d = -2 * f * n / (f - n);
    Matrix2.FromValuesToRef(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 1, 0, 0, d, 0, matrix);
    matrix._updateIdentityStatus(false);
    return matrix;
  };
  Matrix2.PerspectiveFovLH = function(fov, aspect, znear, zfar) {
    var matrix = new Matrix2();
    Matrix2.PerspectiveFovLHToRef(fov, aspect, znear, zfar, matrix);
    return matrix;
  };
  Matrix2.PerspectiveFovLHToRef = function(fov, aspect, znear, zfar, result, isVerticalFovFixed) {
    if (isVerticalFovFixed === void 0) {
      isVerticalFovFixed = true;
    }
    var n = znear;
    var f = zfar;
    var t = 1 / Math.tan(fov * 0.5);
    var a = isVerticalFovFixed ? t / aspect : t;
    var b = isVerticalFovFixed ? t : t * aspect;
    var c = (f + n) / (f - n);
    var d = -2 * f * n / (f - n);
    Matrix2.FromValuesToRef(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 1, 0, 0, d, 0, result);
    result._updateIdentityStatus(false);
  };
  Matrix2.PerspectiveFovReverseLHToRef = function(fov, aspect, znear, zfar, result, isVerticalFovFixed) {
    if (isVerticalFovFixed === void 0) {
      isVerticalFovFixed = true;
    }
    var t = 1 / Math.tan(fov * 0.5);
    var a = isVerticalFovFixed ? t / aspect : t;
    var b = isVerticalFovFixed ? t : t * aspect;
    Matrix2.FromValuesToRef(a, 0, 0, 0, 0, b, 0, 0, 0, 0, -znear, 1, 0, 0, 1, 0, result);
    result._updateIdentityStatus(false);
  };
  Matrix2.PerspectiveFovRH = function(fov, aspect, znear, zfar) {
    var matrix = new Matrix2();
    Matrix2.PerspectiveFovRHToRef(fov, aspect, znear, zfar, matrix);
    return matrix;
  };
  Matrix2.PerspectiveFovRHToRef = function(fov, aspect, znear, zfar, result, isVerticalFovFixed) {
    if (isVerticalFovFixed === void 0) {
      isVerticalFovFixed = true;
    }
    var n = znear;
    var f = zfar;
    var t = 1 / Math.tan(fov * 0.5);
    var a = isVerticalFovFixed ? t / aspect : t;
    var b = isVerticalFovFixed ? t : t * aspect;
    var c = -(f + n) / (f - n);
    var d = -2 * f * n / (f - n);
    Matrix2.FromValuesToRef(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, -1, 0, 0, d, 0, result);
    result._updateIdentityStatus(false);
  };
  Matrix2.PerspectiveFovReverseRHToRef = function(fov, aspect, znear, zfar, result, isVerticalFovFixed) {
    if (isVerticalFovFixed === void 0) {
      isVerticalFovFixed = true;
    }
    var t = 1 / Math.tan(fov * 0.5);
    var a = isVerticalFovFixed ? t / aspect : t;
    var b = isVerticalFovFixed ? t : t * aspect;
    Matrix2.FromValuesToRef(a, 0, 0, 0, 0, b, 0, 0, 0, 0, -znear, -1, 0, 0, -1, 0, result);
    result._updateIdentityStatus(false);
  };
  Matrix2.PerspectiveFovWebVRToRef = function(fov, znear, zfar, result, rightHanded) {
    if (rightHanded === void 0) {
      rightHanded = false;
    }
    var rightHandedFactor = rightHanded ? -1 : 1;
    var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
    var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
    var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
    var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
    var xScale = 2 / (leftTan + rightTan);
    var yScale = 2 / (upTan + downTan);
    var m = result._m;
    m[0] = xScale;
    m[1] = m[2] = m[3] = m[4] = 0;
    m[5] = yScale;
    m[6] = m[7] = 0;
    m[8] = (leftTan - rightTan) * xScale * 0.5;
    m[9] = -((upTan - downTan) * yScale * 0.5);
    m[10] = -zfar / (znear - zfar);
    m[11] = 1 * rightHandedFactor;
    m[12] = m[13] = m[15] = 0;
    m[14] = -(2 * zfar * znear) / (zfar - znear);
    result._markAsUpdated();
  };
  Matrix2.GetFinalMatrix = function(viewport, world, view, projection, zmin, zmax) {
    var cw = viewport.width;
    var ch = viewport.height;
    var cx = viewport.x;
    var cy = viewport.y;
    var viewportMatrix = Matrix2.FromValues(cw / 2, 0, 0, 0, 0, -ch / 2, 0, 0, 0, 0, zmax - zmin, 0, cx + cw / 2, ch / 2 + cy, zmin, 1);
    var matrix = MathTmp.Matrix[0];
    world.multiplyToRef(view, matrix);
    matrix.multiplyToRef(projection, matrix);
    return matrix.multiply(viewportMatrix);
  };
  Matrix2.GetAsMatrix2x2 = function(matrix) {
    var m = matrix.m;
    var arr = [m[0], m[1], m[4], m[5]];
    return PerformanceConfigurator.MatrixUse64Bits ? arr : new Float32Array(arr);
  };
  Matrix2.GetAsMatrix3x3 = function(matrix) {
    var m = matrix.m;
    var arr = [
      m[0],
      m[1],
      m[2],
      m[4],
      m[5],
      m[6],
      m[8],
      m[9],
      m[10]
    ];
    return PerformanceConfigurator.MatrixUse64Bits ? arr : new Float32Array(arr);
  };
  Matrix2.Transpose = function(matrix) {
    var result = new Matrix2();
    Matrix2.TransposeToRef(matrix, result);
    return result;
  };
  Matrix2.TransposeToRef = function(matrix, result) {
    var rm = result._m;
    var mm = matrix.m;
    rm[0] = mm[0];
    rm[1] = mm[4];
    rm[2] = mm[8];
    rm[3] = mm[12];
    rm[4] = mm[1];
    rm[5] = mm[5];
    rm[6] = mm[9];
    rm[7] = mm[13];
    rm[8] = mm[2];
    rm[9] = mm[6];
    rm[10] = mm[10];
    rm[11] = mm[14];
    rm[12] = mm[3];
    rm[13] = mm[7];
    rm[14] = mm[11];
    rm[15] = mm[15];
    result._updateIdentityStatus(matrix._isIdentity, matrix._isIdentityDirty);
  };
  Matrix2.Reflection = function(plane) {
    var matrix = new Matrix2();
    Matrix2.ReflectionToRef(plane, matrix);
    return matrix;
  };
  Matrix2.ReflectionToRef = function(plane, result) {
    plane.normalize();
    var x = plane.normal.x;
    var y = plane.normal.y;
    var z = plane.normal.z;
    var temp = -2 * x;
    var temp2 = -2 * y;
    var temp3 = -2 * z;
    Matrix2.FromValuesToRef(temp * x + 1, temp2 * x, temp3 * x, 0, temp * y, temp2 * y + 1, temp3 * y, 0, temp * z, temp2 * z, temp3 * z + 1, 0, temp * plane.d, temp2 * plane.d, temp3 * plane.d, 1, result);
  };
  Matrix2.FromXYZAxesToRef = function(xaxis, yaxis, zaxis, result) {
    Matrix2.FromValuesToRef(xaxis._x, xaxis._y, xaxis._z, 0, yaxis._x, yaxis._y, yaxis._z, 0, zaxis._x, zaxis._y, zaxis._z, 0, 0, 0, 0, 1, result);
  };
  Matrix2.FromQuaternionToRef = function(quat, result) {
    var xx = quat._x * quat._x;
    var yy = quat._y * quat._y;
    var zz = quat._z * quat._z;
    var xy = quat._x * quat._y;
    var zw = quat._z * quat._w;
    var zx = quat._z * quat._x;
    var yw = quat._y * quat._w;
    var yz = quat._y * quat._z;
    var xw = quat._x * quat._w;
    result._m[0] = 1 - 2 * (yy + zz);
    result._m[1] = 2 * (xy + zw);
    result._m[2] = 2 * (zx - yw);
    result._m[3] = 0;
    result._m[4] = 2 * (xy - zw);
    result._m[5] = 1 - 2 * (zz + xx);
    result._m[6] = 2 * (yz + xw);
    result._m[7] = 0;
    result._m[8] = 2 * (zx + yw);
    result._m[9] = 2 * (yz - xw);
    result._m[10] = 1 - 2 * (yy + xx);
    result._m[11] = 0;
    result._m[12] = 0;
    result._m[13] = 0;
    result._m[14] = 0;
    result._m[15] = 1;
    result._markAsUpdated();
  };
  Matrix2._updateFlagSeed = 0;
  Matrix2._identityReadOnly = Matrix2.Identity();
  return Matrix2;
}();
var MathTmp = function() {
  function MathTmp2() {
  }
  MathTmp2.Vector3 = ArrayTools.BuildArray(6, Vector3.Zero);
  MathTmp2.Matrix = ArrayTools.BuildArray(2, Matrix.Identity);
  MathTmp2.Quaternion = ArrayTools.BuildArray(3, Quaternion.Zero);
  return MathTmp2;
}();
var TmpVectors = function() {
  function TmpVectors2() {
  }
  TmpVectors2.Vector2 = ArrayTools.BuildArray(3, Vector2.Zero);
  TmpVectors2.Vector3 = ArrayTools.BuildArray(13, Vector3.Zero);
  TmpVectors2.Vector4 = ArrayTools.BuildArray(3, Vector4.Zero);
  TmpVectors2.Quaternion = ArrayTools.BuildArray(2, Quaternion.Zero);
  TmpVectors2.Matrix = ArrayTools.BuildArray(8, Matrix.Identity);
  return TmpVectors2;
}();
_TypeStore.RegisteredTypes["BABYLON.Vector2"] = Vector2;
_TypeStore.RegisteredTypes["BABYLON.Vector3"] = Vector3;
_TypeStore.RegisteredTypes["BABYLON.Vector4"] = Vector4;
_TypeStore.RegisteredTypes["BABYLON.Matrix"] = Matrix;

// node_modules/@babylonjs/core/Maths/math.color.js
var Color3 = function() {
  function Color32(r, g, b) {
    if (r === void 0) {
      r = 0;
    }
    if (g === void 0) {
      g = 0;
    }
    if (b === void 0) {
      b = 0;
    }
    this.r = r;
    this.g = g;
    this.b = b;
  }
  Color32.prototype.toString = function() {
    return "{R: " + this.r + " G:" + this.g + " B:" + this.b + "}";
  };
  Color32.prototype.getClassName = function() {
    return "Color3";
  };
  Color32.prototype.getHashCode = function() {
    var hash = this.r * 255 | 0;
    hash = hash * 397 ^ (this.g * 255 | 0);
    hash = hash * 397 ^ (this.b * 255 | 0);
    return hash;
  };
  Color32.prototype.toArray = function(array, index) {
    if (index === void 0) {
      index = 0;
    }
    array[index] = this.r;
    array[index + 1] = this.g;
    array[index + 2] = this.b;
    return this;
  };
  Color32.prototype.fromArray = function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    Color32.FromArrayToRef(array, offset, this);
    return this;
  };
  Color32.prototype.toColor4 = function(alpha) {
    if (alpha === void 0) {
      alpha = 1;
    }
    return new Color4(this.r, this.g, this.b, alpha);
  };
  Color32.prototype.asArray = function() {
    var result = new Array();
    this.toArray(result, 0);
    return result;
  };
  Color32.prototype.toLuminance = function() {
    return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;
  };
  Color32.prototype.multiply = function(otherColor) {
    return new Color32(this.r * otherColor.r, this.g * otherColor.g, this.b * otherColor.b);
  };
  Color32.prototype.multiplyToRef = function(otherColor, result) {
    result.r = this.r * otherColor.r;
    result.g = this.g * otherColor.g;
    result.b = this.b * otherColor.b;
    return this;
  };
  Color32.prototype.equals = function(otherColor) {
    return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b;
  };
  Color32.prototype.equalsFloats = function(r, g, b) {
    return this.r === r && this.g === g && this.b === b;
  };
  Color32.prototype.scale = function(scale) {
    return new Color32(this.r * scale, this.g * scale, this.b * scale);
  };
  Color32.prototype.scaleToRef = function(scale, result) {
    result.r = this.r * scale;
    result.g = this.g * scale;
    result.b = this.b * scale;
    return this;
  };
  Color32.prototype.scaleAndAddToRef = function(scale, result) {
    result.r += this.r * scale;
    result.g += this.g * scale;
    result.b += this.b * scale;
    return this;
  };
  Color32.prototype.clampToRef = function(min, max, result) {
    if (min === void 0) {
      min = 0;
    }
    if (max === void 0) {
      max = 1;
    }
    result.r = Scalar.Clamp(this.r, min, max);
    result.g = Scalar.Clamp(this.g, min, max);
    result.b = Scalar.Clamp(this.b, min, max);
    return this;
  };
  Color32.prototype.add = function(otherColor) {
    return new Color32(this.r + otherColor.r, this.g + otherColor.g, this.b + otherColor.b);
  };
  Color32.prototype.addToRef = function(otherColor, result) {
    result.r = this.r + otherColor.r;
    result.g = this.g + otherColor.g;
    result.b = this.b + otherColor.b;
    return this;
  };
  Color32.prototype.subtract = function(otherColor) {
    return new Color32(this.r - otherColor.r, this.g - otherColor.g, this.b - otherColor.b);
  };
  Color32.prototype.subtractToRef = function(otherColor, result) {
    result.r = this.r - otherColor.r;
    result.g = this.g - otherColor.g;
    result.b = this.b - otherColor.b;
    return this;
  };
  Color32.prototype.clone = function() {
    return new Color32(this.r, this.g, this.b);
  };
  Color32.prototype.copyFrom = function(source) {
    this.r = source.r;
    this.g = source.g;
    this.b = source.b;
    return this;
  };
  Color32.prototype.copyFromFloats = function(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
    return this;
  };
  Color32.prototype.set = function(r, g, b) {
    return this.copyFromFloats(r, g, b);
  };
  Color32.prototype.toHexString = function() {
    var intR = this.r * 255 | 0;
    var intG = this.g * 255 | 0;
    var intB = this.b * 255 | 0;
    return "#" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);
  };
  Color32.prototype.toLinearSpace = function() {
    var convertedColor = new Color32();
    this.toLinearSpaceToRef(convertedColor);
    return convertedColor;
  };
  Color32.prototype.toHSV = function() {
    var result = new Color32();
    this.toHSVToRef(result);
    return result;
  };
  Color32.prototype.toHSVToRef = function(result) {
    var r = this.r;
    var g = this.g;
    var b = this.b;
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var h = 0;
    var s = 0;
    var v = max;
    var dm = max - min;
    if (max !== 0) {
      s = dm / max;
    }
    if (max != min) {
      if (max == r) {
        h = (g - b) / dm;
        if (g < b) {
          h += 6;
        }
      } else if (max == g) {
        h = (b - r) / dm + 2;
      } else if (max == b) {
        h = (r - g) / dm + 4;
      }
      h *= 60;
    }
    result.r = h;
    result.g = s;
    result.b = v;
  };
  Color32.prototype.toLinearSpaceToRef = function(convertedColor) {
    convertedColor.r = Math.pow(this.r, ToLinearSpace);
    convertedColor.g = Math.pow(this.g, ToLinearSpace);
    convertedColor.b = Math.pow(this.b, ToLinearSpace);
    return this;
  };
  Color32.prototype.toGammaSpace = function() {
    var convertedColor = new Color32();
    this.toGammaSpaceToRef(convertedColor);
    return convertedColor;
  };
  Color32.prototype.toGammaSpaceToRef = function(convertedColor) {
    convertedColor.r = Math.pow(this.r, ToGammaSpace);
    convertedColor.g = Math.pow(this.g, ToGammaSpace);
    convertedColor.b = Math.pow(this.b, ToGammaSpace);
    return this;
  };
  Color32.HSVtoRGBToRef = function(hue, saturation, value, result) {
    var chroma = value * saturation;
    var h = hue / 60;
    var x = chroma * (1 - Math.abs(h % 2 - 1));
    var r = 0;
    var g = 0;
    var b = 0;
    if (h >= 0 && h <= 1) {
      r = chroma;
      g = x;
    } else if (h >= 1 && h <= 2) {
      r = x;
      g = chroma;
    } else if (h >= 2 && h <= 3) {
      g = chroma;
      b = x;
    } else if (h >= 3 && h <= 4) {
      g = x;
      b = chroma;
    } else if (h >= 4 && h <= 5) {
      r = x;
      b = chroma;
    } else if (h >= 5 && h <= 6) {
      r = chroma;
      b = x;
    }
    var m = value - chroma;
    result.set(r + m, g + m, b + m);
  };
  Color32.FromHexString = function(hex) {
    if (hex.substring(0, 1) !== "#" || hex.length !== 7) {
      return new Color32(0, 0, 0);
    }
    var r = parseInt(hex.substring(1, 3), 16);
    var g = parseInt(hex.substring(3, 5), 16);
    var b = parseInt(hex.substring(5, 7), 16);
    return Color32.FromInts(r, g, b);
  };
  Color32.FromArray = function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    return new Color32(array[offset], array[offset + 1], array[offset + 2]);
  };
  Color32.FromArrayToRef = function(array, offset, result) {
    if (offset === void 0) {
      offset = 0;
    }
    result.r = array[offset];
    result.g = array[offset + 1];
    result.b = array[offset + 2];
  };
  Color32.FromInts = function(r, g, b) {
    return new Color32(r / 255, g / 255, b / 255);
  };
  Color32.Lerp = function(start, end, amount) {
    var result = new Color32(0, 0, 0);
    Color32.LerpToRef(start, end, amount, result);
    return result;
  };
  Color32.LerpToRef = function(left, right, amount, result) {
    result.r = left.r + (right.r - left.r) * amount;
    result.g = left.g + (right.g - left.g) * amount;
    result.b = left.b + (right.b - left.b) * amount;
  };
  Color32.Red = function() {
    return new Color32(1, 0, 0);
  };
  Color32.Green = function() {
    return new Color32(0, 1, 0);
  };
  Color32.Blue = function() {
    return new Color32(0, 0, 1);
  };
  Color32.Black = function() {
    return new Color32(0, 0, 0);
  };
  Object.defineProperty(Color32, "BlackReadOnly", {
    get: function() {
      return Color32._BlackReadOnly;
    },
    enumerable: false,
    configurable: true
  });
  Color32.White = function() {
    return new Color32(1, 1, 1);
  };
  Color32.Purple = function() {
    return new Color32(0.5, 0, 0.5);
  };
  Color32.Magenta = function() {
    return new Color32(1, 0, 1);
  };
  Color32.Yellow = function() {
    return new Color32(1, 1, 0);
  };
  Color32.Gray = function() {
    return new Color32(0.5, 0.5, 0.5);
  };
  Color32.Teal = function() {
    return new Color32(0, 1, 1);
  };
  Color32.Random = function() {
    return new Color32(Math.random(), Math.random(), Math.random());
  };
  Color32._BlackReadOnly = Color32.Black();
  return Color32;
}();
var Color4 = function() {
  function Color42(r, g, b, a) {
    if (r === void 0) {
      r = 0;
    }
    if (g === void 0) {
      g = 0;
    }
    if (b === void 0) {
      b = 0;
    }
    if (a === void 0) {
      a = 1;
    }
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }
  Color42.prototype.addInPlace = function(right) {
    this.r += right.r;
    this.g += right.g;
    this.b += right.b;
    this.a += right.a;
    return this;
  };
  Color42.prototype.asArray = function() {
    var result = new Array();
    this.toArray(result, 0);
    return result;
  };
  Color42.prototype.toArray = function(array, index) {
    if (index === void 0) {
      index = 0;
    }
    array[index] = this.r;
    array[index + 1] = this.g;
    array[index + 2] = this.b;
    array[index + 3] = this.a;
    return this;
  };
  Color42.prototype.fromArray = function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    Color42.FromArrayToRef(array, offset, this);
    return this;
  };
  Color42.prototype.equals = function(otherColor) {
    return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b && this.a === otherColor.a;
  };
  Color42.prototype.add = function(right) {
    return new Color42(this.r + right.r, this.g + right.g, this.b + right.b, this.a + right.a);
  };
  Color42.prototype.subtract = function(right) {
    return new Color42(this.r - right.r, this.g - right.g, this.b - right.b, this.a - right.a);
  };
  Color42.prototype.subtractToRef = function(right, result) {
    result.r = this.r - right.r;
    result.g = this.g - right.g;
    result.b = this.b - right.b;
    result.a = this.a - right.a;
    return this;
  };
  Color42.prototype.scale = function(scale) {
    return new Color42(this.r * scale, this.g * scale, this.b * scale, this.a * scale);
  };
  Color42.prototype.scaleToRef = function(scale, result) {
    result.r = this.r * scale;
    result.g = this.g * scale;
    result.b = this.b * scale;
    result.a = this.a * scale;
    return this;
  };
  Color42.prototype.scaleAndAddToRef = function(scale, result) {
    result.r += this.r * scale;
    result.g += this.g * scale;
    result.b += this.b * scale;
    result.a += this.a * scale;
    return this;
  };
  Color42.prototype.clampToRef = function(min, max, result) {
    if (min === void 0) {
      min = 0;
    }
    if (max === void 0) {
      max = 1;
    }
    result.r = Scalar.Clamp(this.r, min, max);
    result.g = Scalar.Clamp(this.g, min, max);
    result.b = Scalar.Clamp(this.b, min, max);
    result.a = Scalar.Clamp(this.a, min, max);
    return this;
  };
  Color42.prototype.multiply = function(color) {
    return new Color42(this.r * color.r, this.g * color.g, this.b * color.b, this.a * color.a);
  };
  Color42.prototype.multiplyToRef = function(color, result) {
    result.r = this.r * color.r;
    result.g = this.g * color.g;
    result.b = this.b * color.b;
    result.a = this.a * color.a;
    return result;
  };
  Color42.prototype.toString = function() {
    return "{R: " + this.r + " G:" + this.g + " B:" + this.b + " A:" + this.a + "}";
  };
  Color42.prototype.getClassName = function() {
    return "Color4";
  };
  Color42.prototype.getHashCode = function() {
    var hash = this.r * 255 | 0;
    hash = hash * 397 ^ (this.g * 255 | 0);
    hash = hash * 397 ^ (this.b * 255 | 0);
    hash = hash * 397 ^ (this.a * 255 | 0);
    return hash;
  };
  Color42.prototype.clone = function() {
    return new Color42(this.r, this.g, this.b, this.a);
  };
  Color42.prototype.copyFrom = function(source) {
    this.r = source.r;
    this.g = source.g;
    this.b = source.b;
    this.a = source.a;
    return this;
  };
  Color42.prototype.copyFromFloats = function(r, g, b, a) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
    return this;
  };
  Color42.prototype.set = function(r, g, b, a) {
    return this.copyFromFloats(r, g, b, a);
  };
  Color42.prototype.toHexString = function(returnAsColor3) {
    if (returnAsColor3 === void 0) {
      returnAsColor3 = false;
    }
    var intR = this.r * 255 | 0;
    var intG = this.g * 255 | 0;
    var intB = this.b * 255 | 0;
    if (returnAsColor3) {
      return "#" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);
    }
    var intA = this.a * 255 | 0;
    return "#" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB) + Scalar.ToHex(intA);
  };
  Color42.prototype.toLinearSpace = function() {
    var convertedColor = new Color42();
    this.toLinearSpaceToRef(convertedColor);
    return convertedColor;
  };
  Color42.prototype.toLinearSpaceToRef = function(convertedColor) {
    convertedColor.r = Math.pow(this.r, ToLinearSpace);
    convertedColor.g = Math.pow(this.g, ToLinearSpace);
    convertedColor.b = Math.pow(this.b, ToLinearSpace);
    convertedColor.a = this.a;
    return this;
  };
  Color42.prototype.toGammaSpace = function() {
    var convertedColor = new Color42();
    this.toGammaSpaceToRef(convertedColor);
    return convertedColor;
  };
  Color42.prototype.toGammaSpaceToRef = function(convertedColor) {
    convertedColor.r = Math.pow(this.r, ToGammaSpace);
    convertedColor.g = Math.pow(this.g, ToGammaSpace);
    convertedColor.b = Math.pow(this.b, ToGammaSpace);
    convertedColor.a = this.a;
    return this;
  };
  Color42.FromHexString = function(hex) {
    if (hex.substring(0, 1) !== "#" || hex.length !== 9) {
      return new Color42(0, 0, 0, 0);
    }
    var r = parseInt(hex.substring(1, 3), 16);
    var g = parseInt(hex.substring(3, 5), 16);
    var b = parseInt(hex.substring(5, 7), 16);
    var a = parseInt(hex.substring(7, 9), 16);
    return Color42.FromInts(r, g, b, a);
  };
  Color42.Lerp = function(left, right, amount) {
    var result = new Color42(0, 0, 0, 0);
    Color42.LerpToRef(left, right, amount, result);
    return result;
  };
  Color42.LerpToRef = function(left, right, amount, result) {
    result.r = left.r + (right.r - left.r) * amount;
    result.g = left.g + (right.g - left.g) * amount;
    result.b = left.b + (right.b - left.b) * amount;
    result.a = left.a + (right.a - left.a) * amount;
  };
  Color42.FromColor3 = function(color3, alpha) {
    if (alpha === void 0) {
      alpha = 1;
    }
    return new Color42(color3.r, color3.g, color3.b, alpha);
  };
  Color42.FromArray = function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    return new Color42(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);
  };
  Color42.FromArrayToRef = function(array, offset, result) {
    if (offset === void 0) {
      offset = 0;
    }
    result.r = array[offset];
    result.g = array[offset + 1];
    result.b = array[offset + 2];
    result.a = array[offset + 3];
  };
  Color42.FromInts = function(r, g, b, a) {
    return new Color42(r / 255, g / 255, b / 255, a / 255);
  };
  Color42.CheckColors4 = function(colors, count) {
    if (colors.length === count * 3) {
      var colors4 = [];
      for (var index = 0; index < colors.length; index += 3) {
        var newIndex = index / 3 * 4;
        colors4[newIndex] = colors[index];
        colors4[newIndex + 1] = colors[index + 1];
        colors4[newIndex + 2] = colors[index + 2];
        colors4[newIndex + 3] = 1;
      }
      return colors4;
    }
    return colors;
  };
  return Color42;
}();
var TmpColors = function() {
  function TmpColors2() {
  }
  TmpColors2.Color3 = ArrayTools.BuildArray(3, Color3.Black);
  TmpColors2.Color4 = ArrayTools.BuildArray(3, function() {
    return new Color4(0, 0, 0, 0);
  });
  return TmpColors2;
}();
_TypeStore.RegisteredTypes["BABYLON.Color3"] = Color3;
_TypeStore.RegisteredTypes["BABYLON.Color4"] = Color4;

// node_modules/@babylonjs/core/Actions/actionEvent.js
var ActionEvent = function() {
  function ActionEvent2(source, pointerX, pointerY, meshUnderPointer, sourceEvent, additionalData) {
    this.source = source;
    this.pointerX = pointerX;
    this.pointerY = pointerY;
    this.meshUnderPointer = meshUnderPointer;
    this.sourceEvent = sourceEvent;
    this.additionalData = additionalData;
  }
  ActionEvent2.CreateNew = function(source, evt, additionalData) {
    var scene = source.getScene();
    return new ActionEvent2(source, scene.pointerX, scene.pointerY, scene.meshUnderPointer || source, evt, additionalData);
  };
  ActionEvent2.CreateNewFromSprite = function(source, scene, evt, additionalData) {
    return new ActionEvent2(source, scene.pointerX, scene.pointerY, scene.meshUnderPointer, evt, additionalData);
  };
  ActionEvent2.CreateNewFromScene = function(scene, evt) {
    return new ActionEvent2(null, scene.pointerX, scene.pointerY, scene.meshUnderPointer, evt);
  };
  ActionEvent2.CreateNewFromPrimitive = function(prim, pointerPos, evt, additionalData) {
    return new ActionEvent2(prim, pointerPos.x, pointerPos.y, null, evt, additionalData);
  };
  return ActionEvent2;
}();

// node_modules/@babylonjs/core/Misc/logger.js
var Logger = function() {
  function Logger2() {
  }
  Logger2._AddLogEntry = function(entry) {
    Logger2._LogCache = entry + Logger2._LogCache;
    if (Logger2.OnNewCacheEntry) {
      Logger2.OnNewCacheEntry(entry);
    }
  };
  Logger2._FormatMessage = function(message) {
    var padStr = function(i) {
      return i < 10 ? "0" + i : "" + i;
    };
    var date = new Date();
    return "[" + padStr(date.getHours()) + ":" + padStr(date.getMinutes()) + ":" + padStr(date.getSeconds()) + "]: " + message;
  };
  Logger2._LogDisabled = function(message) {
  };
  Logger2._LogEnabled = function(message) {
    var formattedMessage = Logger2._FormatMessage(message);
    console.log("BJS - " + formattedMessage);
    var entry = "<div style='color:white'>" + formattedMessage + "</div><br>";
    Logger2._AddLogEntry(entry);
  };
  Logger2._WarnDisabled = function(message) {
  };
  Logger2._WarnEnabled = function(message) {
    var formattedMessage = Logger2._FormatMessage(message);
    console.warn("BJS - " + formattedMessage);
    var entry = "<div style='color:orange'>" + formattedMessage + "</div><br>";
    Logger2._AddLogEntry(entry);
  };
  Logger2._ErrorDisabled = function(message) {
  };
  Logger2._ErrorEnabled = function(message) {
    Logger2.errorsCount++;
    var formattedMessage = Logger2._FormatMessage(message);
    console.error("BJS - " + formattedMessage);
    var entry = "<div style='color:red'>" + formattedMessage + "</div><br>";
    Logger2._AddLogEntry(entry);
  };
  Object.defineProperty(Logger2, "LogCache", {
    get: function() {
      return Logger2._LogCache;
    },
    enumerable: false,
    configurable: true
  });
  Logger2.ClearLogCache = function() {
    Logger2._LogCache = "";
    Logger2.errorsCount = 0;
  };
  Object.defineProperty(Logger2, "LogLevels", {
    set: function(level) {
      if ((level & Logger2.MessageLogLevel) === Logger2.MessageLogLevel) {
        Logger2.Log = Logger2._LogEnabled;
      } else {
        Logger2.Log = Logger2._LogDisabled;
      }
      if ((level & Logger2.WarningLogLevel) === Logger2.WarningLogLevel) {
        Logger2.Warn = Logger2._WarnEnabled;
      } else {
        Logger2.Warn = Logger2._WarnDisabled;
      }
      if ((level & Logger2.ErrorLogLevel) === Logger2.ErrorLogLevel) {
        Logger2.Error = Logger2._ErrorEnabled;
      } else {
        Logger2.Error = Logger2._ErrorDisabled;
      }
    },
    enumerable: false,
    configurable: true
  });
  Logger2.NoneLogLevel = 0;
  Logger2.MessageLogLevel = 1;
  Logger2.WarningLogLevel = 2;
  Logger2.ErrorLogLevel = 4;
  Logger2.AllLogLevel = 7;
  Logger2._LogCache = "";
  Logger2.errorsCount = 0;
  Logger2.Log = Logger2._LogEnabled;
  Logger2.Warn = Logger2._WarnEnabled;
  Logger2.Error = Logger2._ErrorEnabled;
  return Logger2;
}();

// node_modules/@babylonjs/core/Engines/engineStore.js
var EngineStore = function() {
  function EngineStore2() {
  }
  Object.defineProperty(EngineStore2, "LastCreatedEngine", {
    get: function() {
      if (this.Instances.length === 0) {
        return null;
      }
      return this.Instances[this.Instances.length - 1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EngineStore2, "LastCreatedScene", {
    get: function() {
      return this._LastCreatedScene;
    },
    enumerable: false,
    configurable: true
  });
  EngineStore2.Instances = new Array();
  EngineStore2._LastCreatedScene = null;
  EngineStore2.UseFallbackTexture = true;
  EngineStore2.FallbackTexture = "";
  return EngineStore2;
}();

// node_modules/@babylonjs/core/Misc/stringTools.js
var StringTools = function() {
  function StringTools2() {
  }
  StringTools2.EndsWith = function(str, suffix) {
    return str.indexOf(suffix, str.length - suffix.length) !== -1;
  };
  StringTools2.StartsWith = function(str, suffix) {
    if (!str) {
      return false;
    }
    return str.indexOf(suffix) === 0;
  };
  StringTools2.Decode = function(buffer) {
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(buffer);
    }
    var result = "";
    for (var i = 0; i < buffer.byteLength; i++) {
      result += String.fromCharCode(buffer[i]);
    }
    return result;
  };
  StringTools2.EncodeArrayBufferToBase64 = function(buffer) {
    var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var output = "";
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i = 0;
    var bytes = ArrayBuffer.isView(buffer) ? new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength) : new Uint8Array(buffer);
    while (i < bytes.length) {
      chr1 = bytes[i++];
      chr2 = i < bytes.length ? bytes[i++] : Number.NaN;
      chr3 = i < bytes.length ? bytes[i++] : Number.NaN;
      enc1 = chr1 >> 2;
      enc2 = (chr1 & 3) << 4 | chr2 >> 4;
      enc3 = (chr2 & 15) << 2 | chr3 >> 6;
      enc4 = chr3 & 63;
      if (isNaN(chr2)) {
        enc3 = enc4 = 64;
      } else if (isNaN(chr3)) {
        enc4 = 64;
      }
      output += keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);
    }
    return output;
  };
  StringTools2.PadNumber = function(num, length) {
    var str = String(num);
    while (str.length < length) {
      str = "0" + str;
    }
    return str;
  };
  return StringTools2;
}();

// node_modules/@babylonjs/core/Misc/deepCopier.js
var cloneValue = function(source, destinationObject) {
  if (!source) {
    return null;
  }
  if (source.getClassName && source.getClassName() === "Mesh") {
    return null;
  }
  if (source.getClassName && source.getClassName() === "SubMesh") {
    return source.clone(destinationObject);
  } else if (source.clone) {
    return source.clone();
  }
  return null;
};
function getAllPropertyNames(obj) {
  var props = [];
  do {
    Object.getOwnPropertyNames(obj).forEach(function(prop) {
      if (props.indexOf(prop) === -1) {
        props.push(prop);
      }
    });
  } while (obj = Object.getPrototypeOf(obj));
  return props;
}
var DeepCopier = function() {
  function DeepCopier2() {
  }
  DeepCopier2.DeepCopy = function(source, destination, doNotCopyList, mustCopyList) {
    var proerties = getAllPropertyNames(source);
    for (var _i = 0, proerties_1 = proerties; _i < proerties_1.length; _i++) {
      var prop = proerties_1[_i];
      if (prop[0] === "_" && (!mustCopyList || mustCopyList.indexOf(prop) === -1)) {
        continue;
      }
      if (StringTools.EndsWith(prop, "Observable")) {
        continue;
      }
      if (doNotCopyList && doNotCopyList.indexOf(prop) !== -1) {
        continue;
      }
      var sourceValue = source[prop];
      var typeOfSourceValue = typeof sourceValue;
      if (typeOfSourceValue === "function") {
        continue;
      }
      try {
        if (typeOfSourceValue === "object") {
          if (sourceValue instanceof Array) {
            destination[prop] = [];
            if (sourceValue.length > 0) {
              if (typeof sourceValue[0] == "object") {
                for (var index = 0; index < sourceValue.length; index++) {
                  var clonedValue = cloneValue(sourceValue[index], destination);
                  if (destination[prop].indexOf(clonedValue) === -1) {
                    destination[prop].push(clonedValue);
                  }
                }
              } else {
                destination[prop] = sourceValue.slice(0);
              }
            }
          } else {
            destination[prop] = cloneValue(sourceValue, destination);
          }
        } else {
          destination[prop] = sourceValue;
        }
      } catch (e) {
        Logger.Warn(e.message);
      }
    }
  };
  return DeepCopier2;
}();

// node_modules/@babylonjs/core/Misc/andOrNotEvaluator.js
var AndOrNotEvaluator = function() {
  function AndOrNotEvaluator2() {
  }
  AndOrNotEvaluator2.Eval = function(query, evaluateCallback) {
    if (!query.match(/\([^\(\)]*\)/g)) {
      query = AndOrNotEvaluator2._HandleParenthesisContent(query, evaluateCallback);
    } else {
      query = query.replace(/\([^\(\)]*\)/g, function(r) {
        r = r.slice(1, r.length - 1);
        return AndOrNotEvaluator2._HandleParenthesisContent(r, evaluateCallback);
      });
    }
    if (query === "true") {
      return true;
    }
    if (query === "false") {
      return false;
    }
    return AndOrNotEvaluator2.Eval(query, evaluateCallback);
  };
  AndOrNotEvaluator2._HandleParenthesisContent = function(parenthesisContent, evaluateCallback) {
    evaluateCallback = evaluateCallback || function(r) {
      return r === "true" ? true : false;
    };
    var result;
    var or = parenthesisContent.split("||");
    for (var i in or) {
      if (or.hasOwnProperty(i)) {
        var ori = AndOrNotEvaluator2._SimplifyNegation(or[i].trim());
        var and = ori.split("&&");
        if (and.length > 1) {
          for (var j = 0; j < and.length; ++j) {
            var andj = AndOrNotEvaluator2._SimplifyNegation(and[j].trim());
            if (andj !== "true" && andj !== "false") {
              if (andj[0] === "!") {
                result = !evaluateCallback(andj.substring(1));
              } else {
                result = evaluateCallback(andj);
              }
            } else {
              result = andj === "true" ? true : false;
            }
            if (!result) {
              ori = "false";
              break;
            }
          }
        }
        if (result || ori === "true") {
          result = true;
          break;
        }
        if (ori !== "true" && ori !== "false") {
          if (ori[0] === "!") {
            result = !evaluateCallback(ori.substring(1));
          } else {
            result = evaluateCallback(ori);
          }
        } else {
          result = ori === "true" ? true : false;
        }
      }
    }
    return result ? "true" : "false";
  };
  AndOrNotEvaluator2._SimplifyNegation = function(booleanString) {
    booleanString = booleanString.replace(/^[\s!]+/, function(r) {
      r = r.replace(/[\s]/g, function() {
        return "";
      });
      return r.length % 2 ? "!" : "";
    });
    booleanString = booleanString.trim();
    if (booleanString === "!true") {
      booleanString = "false";
    } else if (booleanString === "!false") {
      booleanString = "true";
    }
    return booleanString;
  };
  return AndOrNotEvaluator2;
}();

// node_modules/@babylonjs/core/Misc/tags.js
var Tags = function() {
  function Tags2() {
  }
  Tags2.EnableFor = function(obj) {
    obj._tags = obj._tags || {};
    obj.hasTags = function() {
      return Tags2.HasTags(obj);
    };
    obj.addTags = function(tagsString) {
      return Tags2.AddTagsTo(obj, tagsString);
    };
    obj.removeTags = function(tagsString) {
      return Tags2.RemoveTagsFrom(obj, tagsString);
    };
    obj.matchesTagsQuery = function(tagsQuery) {
      return Tags2.MatchesQuery(obj, tagsQuery);
    };
  };
  Tags2.DisableFor = function(obj) {
    delete obj._tags;
    delete obj.hasTags;
    delete obj.addTags;
    delete obj.removeTags;
    delete obj.matchesTagsQuery;
  };
  Tags2.HasTags = function(obj) {
    if (!obj._tags) {
      return false;
    }
    var tags = obj._tags;
    for (var i in tags) {
      if (tags.hasOwnProperty(i)) {
        return true;
      }
    }
    return false;
  };
  Tags2.GetTags = function(obj, asString) {
    if (asString === void 0) {
      asString = true;
    }
    if (!obj._tags) {
      return null;
    }
    if (asString) {
      var tagsArray = [];
      for (var tag in obj._tags) {
        if (obj._tags.hasOwnProperty(tag) && obj._tags[tag] === true) {
          tagsArray.push(tag);
        }
      }
      return tagsArray.join(" ");
    } else {
      return obj._tags;
    }
  };
  Tags2.AddTagsTo = function(obj, tagsString) {
    if (!tagsString) {
      return;
    }
    if (typeof tagsString !== "string") {
      return;
    }
    var tags = tagsString.split(" ");
    tags.forEach(function(tag, index, array) {
      Tags2._AddTagTo(obj, tag);
    });
  };
  Tags2._AddTagTo = function(obj, tag) {
    tag = tag.trim();
    if (tag === "" || tag === "true" || tag === "false") {
      return;
    }
    if (tag.match(/[\s]/) || tag.match(/^([!]|([|]|[&]){2})/)) {
      return;
    }
    Tags2.EnableFor(obj);
    obj._tags[tag] = true;
  };
  Tags2.RemoveTagsFrom = function(obj, tagsString) {
    if (!Tags2.HasTags(obj)) {
      return;
    }
    var tags = tagsString.split(" ");
    for (var t in tags) {
      Tags2._RemoveTagFrom(obj, tags[t]);
    }
  };
  Tags2._RemoveTagFrom = function(obj, tag) {
    delete obj._tags[tag];
  };
  Tags2.MatchesQuery = function(obj, tagsQuery) {
    if (tagsQuery === void 0) {
      return true;
    }
    if (tagsQuery === "") {
      return Tags2.HasTags(obj);
    }
    return AndOrNotEvaluator.Eval(tagsQuery, function(r) {
      return Tags2.HasTags(obj) && obj._tags[r];
    });
  };
  return Tags2;
}();

// node_modules/@babylonjs/core/Misc/devTools.js
var _DevTools = function() {
  function _DevTools2() {
  }
  _DevTools2.WarnImport = function(name45) {
    return name45 + " needs to be imported before as it contains a side-effect required by your code.";
  };
  return _DevTools2;
}();

// node_modules/@babylonjs/core/Misc/decorators.js
var __decoratorInitialStore = {};
var __mergedStore = {};
var _copySource = function(creationFunction, source, instanciate) {
  var destination = creationFunction();
  if (Tags) {
    Tags.AddTagsTo(destination, source.tags);
  }
  var classStore = getMergedStore(destination);
  for (var property in classStore) {
    var propertyDescriptor = classStore[property];
    var sourceProperty = source[property];
    var propertyType = propertyDescriptor.type;
    if (sourceProperty !== void 0 && sourceProperty !== null && property !== "uniqueId") {
      switch (propertyType) {
        case 0:
        case 6:
        case 11:
          destination[property] = sourceProperty;
          break;
        case 1:
          destination[property] = instanciate || sourceProperty.isRenderTarget ? sourceProperty : sourceProperty.clone();
          break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 7:
        case 10:
        case 12:
          destination[property] = instanciate ? sourceProperty : sourceProperty.clone();
          break;
      }
    }
  }
  return destination;
};
function getDirectStore(target) {
  var classKey = target.getClassName();
  if (!__decoratorInitialStore[classKey]) {
    __decoratorInitialStore[classKey] = {};
  }
  return __decoratorInitialStore[classKey];
}
function getMergedStore(target) {
  var classKey = target.getClassName();
  if (__mergedStore[classKey]) {
    return __mergedStore[classKey];
  }
  __mergedStore[classKey] = {};
  var store = __mergedStore[classKey];
  var currentTarget = target;
  var currentKey = classKey;
  while (currentKey) {
    var initialStore = __decoratorInitialStore[currentKey];
    for (var property in initialStore) {
      store[property] = initialStore[property];
    }
    var parent_1 = void 0;
    var done = false;
    do {
      parent_1 = Object.getPrototypeOf(currentTarget);
      if (!parent_1.getClassName) {
        done = true;
        break;
      }
      if (parent_1.getClassName() !== currentKey) {
        break;
      }
      currentTarget = parent_1;
    } while (parent_1);
    if (done) {
      break;
    }
    currentKey = parent_1.getClassName();
    currentTarget = parent_1;
  }
  return store;
}
function generateSerializableMember(type, sourceName) {
  return function(target, propertyKey) {
    var classStore = getDirectStore(target);
    if (!classStore[propertyKey]) {
      classStore[propertyKey] = { type, sourceName };
    }
  };
}
function generateExpandMember(setCallback, targetKey) {
  if (targetKey === void 0) {
    targetKey = null;
  }
  return function(target, propertyKey) {
    var key = targetKey || "_" + propertyKey;
    Object.defineProperty(target, propertyKey, {
      get: function() {
        return this[key];
      },
      set: function(value) {
        if (this[key] === value) {
          return;
        }
        this[key] = value;
        target[setCallback].apply(this);
      },
      enumerable: true,
      configurable: true
    });
  };
}
function expandToProperty(callback, targetKey) {
  if (targetKey === void 0) {
    targetKey = null;
  }
  return generateExpandMember(callback, targetKey);
}
function serialize(sourceName) {
  return generateSerializableMember(0, sourceName);
}
function serializeAsTexture(sourceName) {
  return generateSerializableMember(1, sourceName);
}
function serializeAsColor3(sourceName) {
  return generateSerializableMember(2, sourceName);
}
function serializeAsFresnelParameters(sourceName) {
  return generateSerializableMember(3, sourceName);
}
function serializeAsVector2(sourceName) {
  return generateSerializableMember(4, sourceName);
}
function serializeAsVector3(sourceName) {
  return generateSerializableMember(5, sourceName);
}
function serializeAsMeshReference(sourceName) {
  return generateSerializableMember(6, sourceName);
}
function serializeAsColorCurves(sourceName) {
  return generateSerializableMember(7, sourceName);
}
function serializeAsColor4(sourceName) {
  return generateSerializableMember(8, sourceName);
}
function serializeAsImageProcessingConfiguration(sourceName) {
  return generateSerializableMember(9, sourceName);
}
function serializeAsQuaternion(sourceName) {
  return generateSerializableMember(10, sourceName);
}
function serializeAsMatrix(sourceName) {
  return generateSerializableMember(12, sourceName);
}
function serializeAsCameraReference(sourceName) {
  return generateSerializableMember(11, sourceName);
}
var SerializationHelper = function() {
  function SerializationHelper2() {
  }
  SerializationHelper2.AppendSerializedAnimations = function(source, destination) {
    if (source.animations) {
      destination.animations = [];
      for (var animationIndex = 0; animationIndex < source.animations.length; animationIndex++) {
        var animation = source.animations[animationIndex];
        destination.animations.push(animation.serialize());
      }
    }
  };
  SerializationHelper2.Serialize = function(entity, serializationObject) {
    if (!serializationObject) {
      serializationObject = {};
    }
    if (Tags) {
      serializationObject.tags = Tags.GetTags(entity);
    }
    var serializedProperties = getMergedStore(entity);
    for (var property in serializedProperties) {
      var propertyDescriptor = serializedProperties[property];
      var targetPropertyName = propertyDescriptor.sourceName || property;
      var propertyType = propertyDescriptor.type;
      var sourceProperty = entity[property];
      if (sourceProperty !== void 0 && sourceProperty !== null && property !== "uniqueId") {
        switch (propertyType) {
          case 0:
            serializationObject[targetPropertyName] = sourceProperty;
            break;
          case 1:
            serializationObject[targetPropertyName] = sourceProperty.serialize();
            break;
          case 2:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
          case 3:
            serializationObject[targetPropertyName] = sourceProperty.serialize();
            break;
          case 4:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
          case 5:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
          case 6:
            serializationObject[targetPropertyName] = sourceProperty.id;
            break;
          case 7:
            serializationObject[targetPropertyName] = sourceProperty.serialize();
            break;
          case 8:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
          case 9:
            serializationObject[targetPropertyName] = sourceProperty.serialize();
            break;
          case 10:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
          case 11:
            serializationObject[targetPropertyName] = sourceProperty.id;
          case 12:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
        }
      }
    }
    return serializationObject;
  };
  SerializationHelper2.Parse = function(creationFunction, source, scene, rootUrl) {
    if (rootUrl === void 0) {
      rootUrl = null;
    }
    var destination = creationFunction();
    if (!rootUrl) {
      rootUrl = "";
    }
    if (Tags) {
      Tags.AddTagsTo(destination, source.tags);
    }
    var classStore = getMergedStore(destination);
    for (var property in classStore) {
      var propertyDescriptor = classStore[property];
      var sourceProperty = source[propertyDescriptor.sourceName || property];
      var propertyType = propertyDescriptor.type;
      if (sourceProperty !== void 0 && sourceProperty !== null && property !== "uniqueId") {
        var dest = destination;
        switch (propertyType) {
          case 0:
            dest[property] = sourceProperty;
            break;
          case 1:
            if (scene) {
              dest[property] = SerializationHelper2._TextureParser(sourceProperty, scene, rootUrl);
            }
            break;
          case 2:
            dest[property] = Color3.FromArray(sourceProperty);
            break;
          case 3:
            dest[property] = SerializationHelper2._FresnelParametersParser(sourceProperty);
            break;
          case 4:
            dest[property] = Vector2.FromArray(sourceProperty);
            break;
          case 5:
            dest[property] = Vector3.FromArray(sourceProperty);
            break;
          case 6:
            if (scene) {
              dest[property] = scene.getLastMeshByID(sourceProperty);
            }
            break;
          case 7:
            dest[property] = SerializationHelper2._ColorCurvesParser(sourceProperty);
            break;
          case 8:
            dest[property] = Color4.FromArray(sourceProperty);
            break;
          case 9:
            dest[property] = SerializationHelper2._ImageProcessingConfigurationParser(sourceProperty);
            break;
          case 10:
            dest[property] = Quaternion.FromArray(sourceProperty);
            break;
          case 11:
            if (scene) {
              dest[property] = scene.getCameraByID(sourceProperty);
            }
          case 12:
            dest[property] = Matrix.FromArray(sourceProperty);
            break;
        }
      }
    }
    return destination;
  };
  SerializationHelper2.Clone = function(creationFunction, source) {
    return _copySource(creationFunction, source, false);
  };
  SerializationHelper2.Instanciate = function(creationFunction, source) {
    return _copySource(creationFunction, source, true);
  };
  SerializationHelper2._ImageProcessingConfigurationParser = function(sourceProperty) {
    throw _DevTools.WarnImport("ImageProcessingConfiguration");
  };
  SerializationHelper2._FresnelParametersParser = function(sourceProperty) {
    throw _DevTools.WarnImport("FresnelParameters");
  };
  SerializationHelper2._ColorCurvesParser = function(sourceProperty) {
    throw _DevTools.WarnImport("ColorCurves");
  };
  SerializationHelper2._TextureParser = function(sourceProperty, scene, rootUrl) {
    throw _DevTools.WarnImport("Texture");
  };
  return SerializationHelper2;
}();

// node_modules/tslib/tslib.es6.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}

// node_modules/@babylonjs/core/node.js
var Node = function() {
  function Node2(name45, scene) {
    if (scene === void 0) {
      scene = null;
    }
    this.state = "";
    this.metadata = null;
    this.reservedDataStore = null;
    this._doNotSerialize = false;
    this._isDisposed = false;
    this.animations = new Array();
    this._ranges = {};
    this.onReady = null;
    this._isEnabled = true;
    this._isParentEnabled = true;
    this._isReady = true;
    this._currentRenderId = -1;
    this._parentUpdateId = -1;
    this._childUpdateId = -1;
    this._waitingParentId = null;
    this._cache = {};
    this._parentNode = null;
    this._children = null;
    this._worldMatrix = Matrix.Identity();
    this._worldMatrixDeterminant = 0;
    this._worldMatrixDeterminantIsDirty = true;
    this._sceneRootNodesIndex = -1;
    this._animationPropertiesOverride = null;
    this._isNode = true;
    this.onDisposeObservable = new Observable();
    this._onDisposeObserver = null;
    this._behaviors = new Array();
    this.name = name45;
    this.id = name45;
    this._scene = scene || EngineStore.LastCreatedScene;
    this.uniqueId = this._scene.getUniqueId();
    this._initCache();
  }
  Node2.AddNodeConstructor = function(type, constructorFunc) {
    this._NodeConstructors[type] = constructorFunc;
  };
  Node2.Construct = function(type, name45, scene, options) {
    var constructorFunc = this._NodeConstructors[type];
    if (!constructorFunc) {
      return null;
    }
    return constructorFunc(name45, scene, options);
  };
  Object.defineProperty(Node2.prototype, "doNotSerialize", {
    get: function() {
      if (this._doNotSerialize) {
        return true;
      }
      if (this._parentNode) {
        return this._parentNode.doNotSerialize;
      }
      return false;
    },
    set: function(value) {
      this._doNotSerialize = value;
    },
    enumerable: false,
    configurable: true
  });
  Node2.prototype.isDisposed = function() {
    return this._isDisposed;
  };
  Object.defineProperty(Node2.prototype, "parent", {
    get: function() {
      return this._parentNode;
    },
    set: function(parent) {
      if (this._parentNode === parent) {
        return;
      }
      var previousParentNode = this._parentNode;
      if (this._parentNode && this._parentNode._children !== void 0 && this._parentNode._children !== null) {
        var index = this._parentNode._children.indexOf(this);
        if (index !== -1) {
          this._parentNode._children.splice(index, 1);
        }
        if (!parent && !this._isDisposed) {
          this._addToSceneRootNodes();
        }
      }
      this._parentNode = parent;
      if (this._parentNode) {
        if (this._parentNode._children === void 0 || this._parentNode._children === null) {
          this._parentNode._children = new Array();
        }
        this._parentNode._children.push(this);
        if (!previousParentNode) {
          this._removeFromSceneRootNodes();
        }
      }
      this._syncParentEnabledState();
    },
    enumerable: false,
    configurable: true
  });
  Node2.prototype._addToSceneRootNodes = function() {
    if (this._sceneRootNodesIndex === -1) {
      this._sceneRootNodesIndex = this._scene.rootNodes.length;
      this._scene.rootNodes.push(this);
    }
  };
  Node2.prototype._removeFromSceneRootNodes = function() {
    if (this._sceneRootNodesIndex !== -1) {
      var rootNodes = this._scene.rootNodes;
      var lastIdx = rootNodes.length - 1;
      rootNodes[this._sceneRootNodesIndex] = rootNodes[lastIdx];
      rootNodes[this._sceneRootNodesIndex]._sceneRootNodesIndex = this._sceneRootNodesIndex;
      this._scene.rootNodes.pop();
      this._sceneRootNodesIndex = -1;
    }
  };
  Object.defineProperty(Node2.prototype, "animationPropertiesOverride", {
    get: function() {
      if (!this._animationPropertiesOverride) {
        return this._scene.animationPropertiesOverride;
      }
      return this._animationPropertiesOverride;
    },
    set: function(value) {
      this._animationPropertiesOverride = value;
    },
    enumerable: false,
    configurable: true
  });
  Node2.prototype.getClassName = function() {
    return "Node";
  };
  Object.defineProperty(Node2.prototype, "onDispose", {
    set: function(callback) {
      if (this._onDisposeObserver) {
        this.onDisposeObservable.remove(this._onDisposeObserver);
      }
      this._onDisposeObserver = this.onDisposeObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Node2.prototype.getScene = function() {
    return this._scene;
  };
  Node2.prototype.getEngine = function() {
    return this._scene.getEngine();
  };
  Node2.prototype.addBehavior = function(behavior, attachImmediately) {
    var _this = this;
    if (attachImmediately === void 0) {
      attachImmediately = false;
    }
    var index = this._behaviors.indexOf(behavior);
    if (index !== -1) {
      return this;
    }
    behavior.init();
    if (this._scene.isLoading && !attachImmediately) {
      this._scene.onDataLoadedObservable.addOnce(function() {
        behavior.attach(_this);
      });
    } else {
      behavior.attach(this);
    }
    this._behaviors.push(behavior);
    return this;
  };
  Node2.prototype.removeBehavior = function(behavior) {
    var index = this._behaviors.indexOf(behavior);
    if (index === -1) {
      return this;
    }
    this._behaviors[index].detach();
    this._behaviors.splice(index, 1);
    return this;
  };
  Object.defineProperty(Node2.prototype, "behaviors", {
    get: function() {
      return this._behaviors;
    },
    enumerable: false,
    configurable: true
  });
  Node2.prototype.getBehaviorByName = function(name45) {
    for (var _i = 0, _a = this._behaviors; _i < _a.length; _i++) {
      var behavior = _a[_i];
      if (behavior.name === name45) {
        return behavior;
      }
    }
    return null;
  };
  Node2.prototype.getWorldMatrix = function() {
    if (this._currentRenderId !== this._scene.getRenderId()) {
      this.computeWorldMatrix();
    }
    return this._worldMatrix;
  };
  Node2.prototype._getWorldMatrixDeterminant = function() {
    if (this._worldMatrixDeterminantIsDirty) {
      this._worldMatrixDeterminantIsDirty = false;
      this._worldMatrixDeterminant = this._worldMatrix.determinant();
    }
    return this._worldMatrixDeterminant;
  };
  Object.defineProperty(Node2.prototype, "worldMatrixFromCache", {
    get: function() {
      return this._worldMatrix;
    },
    enumerable: false,
    configurable: true
  });
  Node2.prototype._initCache = function() {
    this._cache = {};
    this._cache.parent = void 0;
  };
  Node2.prototype.updateCache = function(force) {
    if (!force && this.isSynchronized()) {
      return;
    }
    this._cache.parent = this.parent;
    this._updateCache();
  };
  Node2.prototype._getActionManagerForTrigger = function(trigger, initialCall) {
    if (initialCall === void 0) {
      initialCall = true;
    }
    if (!this.parent) {
      return null;
    }
    return this.parent._getActionManagerForTrigger(trigger, false);
  };
  Node2.prototype._updateCache = function(ignoreParentClass) {
  };
  Node2.prototype._isSynchronized = function() {
    return true;
  };
  Node2.prototype._markSyncedWithParent = function() {
    if (this._parentNode) {
      this._parentUpdateId = this._parentNode._childUpdateId;
    }
  };
  Node2.prototype.isSynchronizedWithParent = function() {
    if (!this._parentNode) {
      return true;
    }
    if (this._parentUpdateId !== this._parentNode._childUpdateId) {
      return false;
    }
    return this._parentNode.isSynchronized();
  };
  Node2.prototype.isSynchronized = function() {
    if (this._cache.parent != this._parentNode) {
      this._cache.parent = this._parentNode;
      return false;
    }
    if (this._parentNode && !this.isSynchronizedWithParent()) {
      return false;
    }
    return this._isSynchronized();
  };
  Node2.prototype.isReady = function(completeCheck) {
    if (completeCheck === void 0) {
      completeCheck = false;
    }
    return this._isReady;
  };
  Node2.prototype.isEnabled = function(checkAncestors) {
    if (checkAncestors === void 0) {
      checkAncestors = true;
    }
    if (checkAncestors === false) {
      return this._isEnabled;
    }
    if (!this._isEnabled) {
      return false;
    }
    return this._isParentEnabled;
  };
  Node2.prototype._syncParentEnabledState = function() {
    this._isParentEnabled = this._parentNode ? this._parentNode.isEnabled() : true;
    if (this._children) {
      this._children.forEach(function(c) {
        c._syncParentEnabledState();
      });
    }
  };
  Node2.prototype.setEnabled = function(value) {
    this._isEnabled = value;
    this._syncParentEnabledState();
  };
  Node2.prototype.isDescendantOf = function(ancestor) {
    if (this.parent) {
      if (this.parent === ancestor) {
        return true;
      }
      return this.parent.isDescendantOf(ancestor);
    }
    return false;
  };
  Node2.prototype._getDescendants = function(results, directDescendantsOnly, predicate) {
    if (directDescendantsOnly === void 0) {
      directDescendantsOnly = false;
    }
    if (!this._children) {
      return;
    }
    for (var index = 0; index < this._children.length; index++) {
      var item = this._children[index];
      if (!predicate || predicate(item)) {
        results.push(item);
      }
      if (!directDescendantsOnly) {
        item._getDescendants(results, false, predicate);
      }
    }
  };
  Node2.prototype.getDescendants = function(directDescendantsOnly, predicate) {
    var results = new Array();
    this._getDescendants(results, directDescendantsOnly, predicate);
    return results;
  };
  Node2.prototype.getChildMeshes = function(directDescendantsOnly, predicate) {
    var results = [];
    this._getDescendants(results, directDescendantsOnly, function(node) {
      return (!predicate || predicate(node)) && node.cullingStrategy !== void 0;
    });
    return results;
  };
  Node2.prototype.getChildren = function(predicate, directDescendantsOnly) {
    if (directDescendantsOnly === void 0) {
      directDescendantsOnly = true;
    }
    return this.getDescendants(directDescendantsOnly, predicate);
  };
  Node2.prototype._setReady = function(state) {
    if (state === this._isReady) {
      return;
    }
    if (!state) {
      this._isReady = false;
      return;
    }
    if (this.onReady) {
      this.onReady(this);
    }
    this._isReady = true;
  };
  Node2.prototype.getAnimationByName = function(name45) {
    for (var i = 0; i < this.animations.length; i++) {
      var animation = this.animations[i];
      if (animation.name === name45) {
        return animation;
      }
    }
    return null;
  };
  Node2.prototype.createAnimationRange = function(name45, from, to) {
    if (!this._ranges[name45]) {
      this._ranges[name45] = Node2._AnimationRangeFactory(name45, from, to);
      for (var i = 0, nAnimations = this.animations.length; i < nAnimations; i++) {
        if (this.animations[i]) {
          this.animations[i].createRange(name45, from, to);
        }
      }
    }
  };
  Node2.prototype.deleteAnimationRange = function(name45, deleteFrames) {
    if (deleteFrames === void 0) {
      deleteFrames = true;
    }
    for (var i = 0, nAnimations = this.animations.length; i < nAnimations; i++) {
      if (this.animations[i]) {
        this.animations[i].deleteRange(name45, deleteFrames);
      }
    }
    this._ranges[name45] = null;
  };
  Node2.prototype.getAnimationRange = function(name45) {
    return this._ranges[name45] || null;
  };
  Node2.prototype.getAnimationRanges = function() {
    var animationRanges = [];
    var name45;
    for (name45 in this._ranges) {
      animationRanges.push(this._ranges[name45]);
    }
    return animationRanges;
  };
  Node2.prototype.beginAnimation = function(name45, loop, speedRatio, onAnimationEnd) {
    var range = this.getAnimationRange(name45);
    if (!range) {
      return null;
    }
    return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);
  };
  Node2.prototype.serializeAnimationRanges = function() {
    var serializationRanges = [];
    for (var name45 in this._ranges) {
      var localRange = this._ranges[name45];
      if (!localRange) {
        continue;
      }
      var range = {};
      range.name = name45;
      range.from = localRange.from;
      range.to = localRange.to;
      serializationRanges.push(range);
    }
    return serializationRanges;
  };
  Node2.prototype.computeWorldMatrix = function(force) {
    if (!this._worldMatrix) {
      this._worldMatrix = Matrix.Identity();
    }
    return this._worldMatrix;
  };
  Node2.prototype.dispose = function(doNotRecurse, disposeMaterialAndTextures) {
    if (disposeMaterialAndTextures === void 0) {
      disposeMaterialAndTextures = false;
    }
    this._isDisposed = true;
    if (!doNotRecurse) {
      var nodes = this.getDescendants(true);
      for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
        var node = nodes_1[_i];
        node.dispose(doNotRecurse, disposeMaterialAndTextures);
      }
    }
    if (!this.parent) {
      this._removeFromSceneRootNodes();
    } else {
      this.parent = null;
    }
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    for (var _a = 0, _b = this._behaviors; _a < _b.length; _a++) {
      var behavior = _b[_a];
      behavior.detach();
    }
    this._behaviors = [];
  };
  Node2.ParseAnimationRanges = function(node, parsedNode, scene) {
    if (parsedNode.ranges) {
      for (var index = 0; index < parsedNode.ranges.length; index++) {
        var data = parsedNode.ranges[index];
        node.createAnimationRange(data.name, data.from, data.to);
      }
    }
  };
  Node2.prototype.getHierarchyBoundingVectors = function(includeDescendants, predicate) {
    if (includeDescendants === void 0) {
      includeDescendants = true;
    }
    if (predicate === void 0) {
      predicate = null;
    }
    this.getScene().incrementRenderId();
    this.computeWorldMatrix(true);
    var min;
    var max;
    var thisAbstractMesh = this;
    if (thisAbstractMesh.getBoundingInfo && thisAbstractMesh.subMeshes) {
      var boundingInfo = thisAbstractMesh.getBoundingInfo();
      min = boundingInfo.boundingBox.minimumWorld.clone();
      max = boundingInfo.boundingBox.maximumWorld.clone();
    } else {
      min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
      max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    }
    if (includeDescendants) {
      var descendants = this.getDescendants(false);
      for (var _i = 0, descendants_1 = descendants; _i < descendants_1.length; _i++) {
        var descendant = descendants_1[_i];
        var childMesh = descendant;
        childMesh.computeWorldMatrix(true);
        if (predicate && !predicate(childMesh)) {
          continue;
        }
        if (!childMesh.getBoundingInfo || childMesh.getTotalVertices() === 0) {
          continue;
        }
        var childBoundingInfo = childMesh.getBoundingInfo();
        var boundingBox = childBoundingInfo.boundingBox;
        var minBox = boundingBox.minimumWorld;
        var maxBox = boundingBox.maximumWorld;
        Vector3.CheckExtends(minBox, min, max);
        Vector3.CheckExtends(maxBox, min, max);
      }
    }
    return {
      min,
      max
    };
  };
  Node2._AnimationRangeFactory = function(name45, from, to) {
    throw _DevTools.WarnImport("AnimationRange");
  };
  Node2._NodeConstructors = {};
  __decorate([
    serialize()
  ], Node2.prototype, "name", void 0);
  __decorate([
    serialize()
  ], Node2.prototype, "id", void 0);
  __decorate([
    serialize()
  ], Node2.prototype, "uniqueId", void 0);
  __decorate([
    serialize()
  ], Node2.prototype, "state", void 0);
  __decorate([
    serialize()
  ], Node2.prototype, "metadata", void 0);
  return Node2;
}();

// node_modules/@babylonjs/core/Maths/math.size.js
var Size = function() {
  function Size2(width, height) {
    this.width = width;
    this.height = height;
  }
  Size2.prototype.toString = function() {
    return "{W: " + this.width + ", H: " + this.height + "}";
  };
  Size2.prototype.getClassName = function() {
    return "Size";
  };
  Size2.prototype.getHashCode = function() {
    var hash = this.width | 0;
    hash = hash * 397 ^ (this.height | 0);
    return hash;
  };
  Size2.prototype.copyFrom = function(src) {
    this.width = src.width;
    this.height = src.height;
  };
  Size2.prototype.copyFromFloats = function(width, height) {
    this.width = width;
    this.height = height;
    return this;
  };
  Size2.prototype.set = function(width, height) {
    return this.copyFromFloats(width, height);
  };
  Size2.prototype.multiplyByFloats = function(w, h) {
    return new Size2(this.width * w, this.height * h);
  };
  Size2.prototype.clone = function() {
    return new Size2(this.width, this.height);
  };
  Size2.prototype.equals = function(other) {
    if (!other) {
      return false;
    }
    return this.width === other.width && this.height === other.height;
  };
  Object.defineProperty(Size2.prototype, "surface", {
    get: function() {
      return this.width * this.height;
    },
    enumerable: false,
    configurable: true
  });
  Size2.Zero = function() {
    return new Size2(0, 0);
  };
  Size2.prototype.add = function(otherSize) {
    var r = new Size2(this.width + otherSize.width, this.height + otherSize.height);
    return r;
  };
  Size2.prototype.subtract = function(otherSize) {
    var r = new Size2(this.width - otherSize.width, this.height - otherSize.height);
    return r;
  };
  Size2.Lerp = function(start, end, amount) {
    var w = start.width + (end.width - start.width) * amount;
    var h = start.height + (end.height - start.height) * amount;
    return new Size2(w, h);
  };
  return Size2;
}();

// node_modules/@babylonjs/core/Misc/webRequest.js
function createXMLHttpRequest() {
  if (typeof _native !== "undefined" && _native.XMLHttpRequest) {
    return new _native.XMLHttpRequest();
  } else {
    return new XMLHttpRequest();
  }
}
var WebRequest = function() {
  function WebRequest2() {
    this._xhr = createXMLHttpRequest();
  }
  WebRequest2.prototype._injectCustomRequestHeaders = function() {
    for (var key in WebRequest2.CustomRequestHeaders) {
      var val = WebRequest2.CustomRequestHeaders[key];
      if (val) {
        this._xhr.setRequestHeader(key, val);
      }
    }
  };
  Object.defineProperty(WebRequest2.prototype, "onprogress", {
    get: function() {
      return this._xhr.onprogress;
    },
    set: function(value) {
      this._xhr.onprogress = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebRequest2.prototype, "readyState", {
    get: function() {
      return this._xhr.readyState;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebRequest2.prototype, "status", {
    get: function() {
      return this._xhr.status;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebRequest2.prototype, "statusText", {
    get: function() {
      return this._xhr.statusText;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebRequest2.prototype, "response", {
    get: function() {
      return this._xhr.response;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebRequest2.prototype, "responseURL", {
    get: function() {
      return this._xhr.responseURL;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebRequest2.prototype, "responseText", {
    get: function() {
      return this._xhr.responseText;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebRequest2.prototype, "responseType", {
    get: function() {
      return this._xhr.responseType;
    },
    set: function(value) {
      this._xhr.responseType = value;
    },
    enumerable: false,
    configurable: true
  });
  WebRequest2.prototype.addEventListener = function(type, listener, options) {
    this._xhr.addEventListener(type, listener, options);
  };
  WebRequest2.prototype.removeEventListener = function(type, listener, options) {
    this._xhr.removeEventListener(type, listener, options);
  };
  WebRequest2.prototype.abort = function() {
    this._xhr.abort();
  };
  WebRequest2.prototype.send = function(body) {
    if (WebRequest2.CustomRequestHeaders) {
      this._injectCustomRequestHeaders();
    }
    this._xhr.send(body);
  };
  WebRequest2.prototype.open = function(method, url) {
    for (var _i = 0, _a = WebRequest2.CustomRequestModifiers; _i < _a.length; _i++) {
      var update = _a[_i];
      update(this._xhr, url);
    }
    url = url.replace("file:http:", "http:");
    url = url.replace("file:https:", "https:");
    return this._xhr.open(method, url, true);
  };
  WebRequest2.prototype.setRequestHeader = function(name45, value) {
    this._xhr.setRequestHeader(name45, value);
  };
  WebRequest2.prototype.getResponseHeader = function(name45) {
    return this._xhr.getResponseHeader(name45);
  };
  WebRequest2.CustomRequestHeaders = {};
  WebRequest2.CustomRequestModifiers = new Array();
  return WebRequest2;
}();

// node_modules/@babylonjs/core/Misc/domManagement.js
var DomManagement = function() {
  function DomManagement2() {
  }
  DomManagement2.IsWindowObjectExist = function() {
    return typeof window !== "undefined";
  };
  DomManagement2.IsNavigatorAvailable = function() {
    return typeof navigator !== "undefined";
  };
  DomManagement2.IsDocumentAvailable = function() {
    return typeof document !== "undefined";
  };
  DomManagement2.GetDOMTextContent = function(element) {
    var result = "";
    var child = element.firstChild;
    while (child) {
      if (child.nodeType === 3) {
        result += child.textContent;
      }
      child = child.nextSibling;
    }
    return result;
  };
  return DomManagement2;
}();

// node_modules/@babylonjs/core/Misc/precisionDate.js
var PrecisionDate = function() {
  function PrecisionDate2() {
  }
  Object.defineProperty(PrecisionDate2, "Now", {
    get: function() {
      if (DomManagement.IsWindowObjectExist() && window.performance && window.performance.now) {
        return window.performance.now();
      }
      return Date.now();
    },
    enumerable: false,
    configurable: true
  });
  return PrecisionDate2;
}();

// node_modules/@babylonjs/core/Misc/filesInputStore.js
var FilesInputStore = function() {
  function FilesInputStore2() {
  }
  FilesInputStore2.FilesToLoad = {};
  return FilesInputStore2;
}();

// node_modules/@babylonjs/core/Misc/retryStrategy.js
var RetryStrategy = function() {
  function RetryStrategy2() {
  }
  RetryStrategy2.ExponentialBackoff = function(maxRetries, baseInterval) {
    if (maxRetries === void 0) {
      maxRetries = 3;
    }
    if (baseInterval === void 0) {
      baseInterval = 500;
    }
    return function(url, request, retryIndex) {
      if (request.status !== 0 || retryIndex >= maxRetries || url.indexOf("file:") !== -1) {
        return -1;
      }
      return Math.pow(2, retryIndex) * baseInterval;
    };
  };
  return RetryStrategy2;
}();

// node_modules/@babylonjs/core/Engines/Processors/shaderCodeNode.js
var ShaderCodeNode = function() {
  function ShaderCodeNode2() {
    this.children = [];
  }
  ShaderCodeNode2.prototype.isValid = function(preprocessors) {
    return true;
  };
  ShaderCodeNode2.prototype.process = function(preprocessors, options) {
    var result = "";
    if (this.line) {
      var value = this.line;
      var processor = options.processor;
      if (processor) {
        if (processor.lineProcessor) {
          value = processor.lineProcessor(value, options.isFragment);
        }
        if (processor.attributeProcessor && StringTools.StartsWith(this.line, "attribute")) {
          value = processor.attributeProcessor(this.line);
        } else if (processor.varyingProcessor && StringTools.StartsWith(this.line, "varying")) {
          value = processor.varyingProcessor(this.line, options.isFragment);
        } else if ((processor.uniformProcessor || processor.uniformBufferProcessor) && StringTools.StartsWith(this.line, "uniform")) {
          var regex = /uniform (.+) (.+)/;
          if (regex.test(this.line)) {
            if (processor.uniformProcessor) {
              value = processor.uniformProcessor(this.line, options.isFragment);
            }
          } else {
            if (processor.uniformBufferProcessor) {
              value = processor.uniformBufferProcessor(this.line, options.isFragment);
              options.lookForClosingBracketForUniformBuffer = true;
            }
          }
        }
        if (processor.endOfUniformBufferProcessor) {
          if (options.lookForClosingBracketForUniformBuffer && this.line.indexOf("}") !== -1) {
            options.lookForClosingBracketForUniformBuffer = false;
            value = processor.endOfUniformBufferProcessor(this.line, options.isFragment);
          }
        }
      }
      result += value + "\r\n";
    }
    this.children.forEach(function(child) {
      result += child.process(preprocessors, options);
    });
    if (this.additionalDefineKey) {
      preprocessors[this.additionalDefineKey] = this.additionalDefineValue || "true";
    }
    return result;
  };
  return ShaderCodeNode2;
}();

// node_modules/@babylonjs/core/Engines/Processors/shaderCodeCursor.js
var ShaderCodeCursor = function() {
  function ShaderCodeCursor2() {
  }
  Object.defineProperty(ShaderCodeCursor2.prototype, "currentLine", {
    get: function() {
      return this._lines[this.lineIndex];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShaderCodeCursor2.prototype, "canRead", {
    get: function() {
      return this.lineIndex < this._lines.length - 1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShaderCodeCursor2.prototype, "lines", {
    set: function(value) {
      this._lines = [];
      for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
        var line = value_1[_i];
        if (line[0] === "#") {
          this._lines.push(line);
          continue;
        }
        var split = line.split(";");
        for (var index = 0; index < split.length; index++) {
          var subLine = split[index];
          subLine = subLine.trim();
          if (!subLine) {
            continue;
          }
          this._lines.push(subLine + (index !== split.length - 1 ? ";" : ""));
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  return ShaderCodeCursor2;
}();

// node_modules/@babylonjs/core/Engines/Processors/shaderCodeConditionNode.js
var ShaderCodeConditionNode = function(_super) {
  __extends(ShaderCodeConditionNode2, _super);
  function ShaderCodeConditionNode2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ShaderCodeConditionNode2.prototype.process = function(preprocessors, options) {
    for (var index = 0; index < this.children.length; index++) {
      var node = this.children[index];
      if (node.isValid(preprocessors)) {
        return node.process(preprocessors, options);
      }
    }
    return "";
  };
  return ShaderCodeConditionNode2;
}(ShaderCodeNode);

// node_modules/@babylonjs/core/Engines/Processors/shaderCodeTestNode.js
var ShaderCodeTestNode = function(_super) {
  __extends(ShaderCodeTestNode2, _super);
  function ShaderCodeTestNode2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ShaderCodeTestNode2.prototype.isValid = function(preprocessors) {
    return this.testExpression.isTrue(preprocessors);
  };
  return ShaderCodeTestNode2;
}(ShaderCodeNode);

// node_modules/@babylonjs/core/Engines/Processors/Expressions/shaderDefineExpression.js
var ShaderDefineExpression = function() {
  function ShaderDefineExpression2() {
  }
  ShaderDefineExpression2.prototype.isTrue = function(preprocessors) {
    return true;
  };
  ShaderDefineExpression2.postfixToInfix = function(postfix) {
    var stack = [];
    for (var _i = 0, postfix_1 = postfix; _i < postfix_1.length; _i++) {
      var c = postfix_1[_i];
      if (ShaderDefineExpression2._OperatorPriority[c] === void 0) {
        stack.push(c);
      } else {
        var v1 = stack[stack.length - 1], v2 = stack[stack.length - 2];
        stack.length -= 2;
        stack.push("(" + v2 + c + v1 + ")");
      }
    }
    return stack[stack.length - 1];
  };
  ShaderDefineExpression2.infixToPostfix = function(infix) {
    var result = [];
    var stackIdx = -1;
    var pushOperand = function() {
      operand = operand.trim();
      if (operand !== "") {
        result.push(operand);
        operand = "";
      }
    };
    var push = function(s) {
      if (stackIdx < ShaderDefineExpression2._Stack.length - 1) {
        ShaderDefineExpression2._Stack[++stackIdx] = s;
      }
    };
    var peek = function() {
      return ShaderDefineExpression2._Stack[stackIdx];
    };
    var pop = function() {
      return stackIdx === -1 ? "!!INVALID EXPRESSION!!" : ShaderDefineExpression2._Stack[stackIdx--];
    };
    var idx = 0, operand = "";
    while (idx < infix.length) {
      var c = infix.charAt(idx), token = idx < infix.length - 1 ? infix.substr(idx, 2) : "";
      if (c === "(") {
        operand = "";
        push(c);
      } else if (c === ")") {
        pushOperand();
        while (stackIdx !== -1 && peek() !== "(") {
          result.push(pop());
        }
        pop();
      } else if (ShaderDefineExpression2._OperatorPriority[token] > 1) {
        pushOperand();
        while (stackIdx !== -1 && ShaderDefineExpression2._OperatorPriority[peek()] >= ShaderDefineExpression2._OperatorPriority[token]) {
          result.push(pop());
        }
        push(token);
        idx++;
      } else {
        operand += c;
      }
      idx++;
    }
    pushOperand();
    while (stackIdx !== -1) {
      if (peek() === "(") {
        pop();
      } else {
        result.push(pop());
      }
    }
    return result;
  };
  ShaderDefineExpression2._OperatorPriority = {
    ")": 0,
    "(": 1,
    "||": 2,
    "&&": 3
  };
  ShaderDefineExpression2._Stack = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
  return ShaderDefineExpression2;
}();

// node_modules/@babylonjs/core/Engines/Processors/Expressions/Operators/shaderDefineIsDefinedOperator.js
var ShaderDefineIsDefinedOperator = function(_super) {
  __extends(ShaderDefineIsDefinedOperator2, _super);
  function ShaderDefineIsDefinedOperator2(define, not) {
    if (not === void 0) {
      not = false;
    }
    var _this = _super.call(this) || this;
    _this.define = define;
    _this.not = not;
    return _this;
  }
  ShaderDefineIsDefinedOperator2.prototype.isTrue = function(preprocessors) {
    var condition = preprocessors[this.define] !== void 0;
    if (this.not) {
      condition = !condition;
    }
    return condition;
  };
  return ShaderDefineIsDefinedOperator2;
}(ShaderDefineExpression);

// node_modules/@babylonjs/core/Engines/Processors/Expressions/Operators/shaderDefineOrOperator.js
var ShaderDefineOrOperator = function(_super) {
  __extends(ShaderDefineOrOperator2, _super);
  function ShaderDefineOrOperator2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ShaderDefineOrOperator2.prototype.isTrue = function(preprocessors) {
    return this.leftOperand.isTrue(preprocessors) || this.rightOperand.isTrue(preprocessors);
  };
  return ShaderDefineOrOperator2;
}(ShaderDefineExpression);

// node_modules/@babylonjs/core/Engines/Processors/Expressions/Operators/shaderDefineAndOperator.js
var ShaderDefineAndOperator = function(_super) {
  __extends(ShaderDefineAndOperator2, _super);
  function ShaderDefineAndOperator2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ShaderDefineAndOperator2.prototype.isTrue = function(preprocessors) {
    return this.leftOperand.isTrue(preprocessors) && this.rightOperand.isTrue(preprocessors);
  };
  return ShaderDefineAndOperator2;
}(ShaderDefineExpression);

// node_modules/@babylonjs/core/Engines/Processors/Expressions/Operators/shaderDefineArithmeticOperator.js
var ShaderDefineArithmeticOperator = function(_super) {
  __extends(ShaderDefineArithmeticOperator2, _super);
  function ShaderDefineArithmeticOperator2(define, operand, testValue) {
    var _this = _super.call(this) || this;
    _this.define = define;
    _this.operand = operand;
    _this.testValue = testValue;
    return _this;
  }
  ShaderDefineArithmeticOperator2.prototype.isTrue = function(preprocessors) {
    var value = preprocessors[this.define];
    if (value === void 0) {
      value = this.define;
    }
    var condition = false;
    var left = parseInt(value);
    var right = parseInt(this.testValue);
    switch (this.operand) {
      case ">":
        condition = left > right;
        break;
      case "<":
        condition = left < right;
        break;
      case "<=":
        condition = left <= right;
        break;
      case ">=":
        condition = left >= right;
        break;
      case "==":
        condition = left === right;
        break;
    }
    return condition;
  };
  return ShaderDefineArithmeticOperator2;
}(ShaderDefineExpression);

// node_modules/@babylonjs/core/Engines/Processors/shaderProcessor.js
var regexSE = /defined\s*?\((.+?)\)/g;
var regexSERevert = /defined\s*?\[(.+?)\]/g;
var ShaderProcessor = function() {
  function ShaderProcessor2() {
  }
  ShaderProcessor2.Process = function(sourceCode, options, callback, engine) {
    var _this = this;
    this._ProcessIncludes(sourceCode, options, function(codeWithIncludes) {
      var migratedCode = _this._ProcessShaderConversion(codeWithIncludes, options, engine);
      callback(migratedCode);
    });
  };
  ShaderProcessor2._ProcessPrecision = function(source, options) {
    var shouldUseHighPrecisionShader = options.shouldUseHighPrecisionShader;
    if (source.indexOf("precision highp float") === -1) {
      if (!shouldUseHighPrecisionShader) {
        source = "precision mediump float;\n" + source;
      } else {
        source = "precision highp float;\n" + source;
      }
    } else {
      if (!shouldUseHighPrecisionShader) {
        source = source.replace("precision highp float", "precision mediump float");
      }
    }
    return source;
  };
  ShaderProcessor2._ExtractOperation = function(expression) {
    var regex = /defined\((.+)\)/;
    var match = regex.exec(expression);
    if (match && match.length) {
      return new ShaderDefineIsDefinedOperator(match[1].trim(), expression[0] === "!");
    }
    var operators = ["==", ">=", "<=", "<", ">"];
    var operator = "";
    var indexOperator = 0;
    for (var _i = 0, operators_1 = operators; _i < operators_1.length; _i++) {
      operator = operators_1[_i];
      indexOperator = expression.indexOf(operator);
      if (indexOperator > -1) {
        break;
      }
    }
    if (indexOperator === -1) {
      return new ShaderDefineIsDefinedOperator(expression);
    }
    var define = expression.substring(0, indexOperator).trim();
    var value = expression.substring(indexOperator + operator.length).trim();
    return new ShaderDefineArithmeticOperator(define, operator, value);
  };
  ShaderProcessor2._BuildSubExpression = function(expression) {
    expression = expression.replace(regexSE, "defined[$1]");
    var postfix = ShaderDefineExpression.infixToPostfix(expression);
    var stack = [];
    for (var _i = 0, postfix_1 = postfix; _i < postfix_1.length; _i++) {
      var c = postfix_1[_i];
      if (c !== "||" && c !== "&&") {
        stack.push(c);
      } else if (stack.length >= 2) {
        var v1 = stack[stack.length - 1], v2 = stack[stack.length - 2];
        stack.length -= 2;
        var operator = c == "&&" ? new ShaderDefineAndOperator() : new ShaderDefineOrOperator();
        if (typeof v1 === "string") {
          v1 = v1.replace(regexSERevert, "defined($1)");
        }
        if (typeof v2 === "string") {
          v2 = v2.replace(regexSERevert, "defined($1)");
        }
        operator.leftOperand = typeof v2 === "string" ? this._ExtractOperation(v2) : v2;
        operator.rightOperand = typeof v1 === "string" ? this._ExtractOperation(v1) : v1;
        stack.push(operator);
      }
    }
    var result = stack[stack.length - 1];
    if (typeof result === "string") {
      result = result.replace(regexSERevert, "defined($1)");
    }
    return typeof result === "string" ? this._ExtractOperation(result) : result;
  };
  ShaderProcessor2._BuildExpression = function(line, start) {
    var node = new ShaderCodeTestNode();
    var command = line.substring(0, start);
    var expression = line.substring(start);
    expression = expression.substring(0, (expression.indexOf("//") + 1 || expression.length + 1) - 1).trim();
    if (command === "#ifdef") {
      node.testExpression = new ShaderDefineIsDefinedOperator(expression);
    } else if (command === "#ifndef") {
      node.testExpression = new ShaderDefineIsDefinedOperator(expression, true);
    } else {
      node.testExpression = this._BuildSubExpression(expression);
    }
    return node;
  };
  ShaderProcessor2._MoveCursorWithinIf = function(cursor, rootNode, ifNode) {
    var line = cursor.currentLine;
    while (this._MoveCursor(cursor, ifNode)) {
      line = cursor.currentLine;
      var first5 = line.substring(0, 5).toLowerCase();
      if (first5 === "#else") {
        var elseNode = new ShaderCodeNode();
        rootNode.children.push(elseNode);
        this._MoveCursor(cursor, elseNode);
        return;
      } else if (first5 === "#elif") {
        var elifNode = this._BuildExpression(line, 5);
        rootNode.children.push(elifNode);
        ifNode = elifNode;
      }
    }
  };
  ShaderProcessor2._MoveCursor = function(cursor, rootNode) {
    while (cursor.canRead) {
      cursor.lineIndex++;
      var line = cursor.currentLine;
      var keywords = /(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;
      var matches = keywords.exec(line);
      if (matches && matches.length) {
        var keyword = matches[0];
        switch (keyword) {
          case "#ifdef": {
            var newRootNode = new ShaderCodeConditionNode();
            rootNode.children.push(newRootNode);
            var ifNode = this._BuildExpression(line, 6);
            newRootNode.children.push(ifNode);
            this._MoveCursorWithinIf(cursor, newRootNode, ifNode);
            break;
          }
          case "#else":
          case "#elif":
            return true;
          case "#endif":
            return false;
          case "#ifndef": {
            var newRootNode = new ShaderCodeConditionNode();
            rootNode.children.push(newRootNode);
            var ifNode = this._BuildExpression(line, 7);
            newRootNode.children.push(ifNode);
            this._MoveCursorWithinIf(cursor, newRootNode, ifNode);
            break;
          }
          case "#if": {
            var newRootNode = new ShaderCodeConditionNode();
            var ifNode = this._BuildExpression(line, 3);
            rootNode.children.push(newRootNode);
            newRootNode.children.push(ifNode);
            this._MoveCursorWithinIf(cursor, newRootNode, ifNode);
            break;
          }
        }
      } else {
        var newNode = new ShaderCodeNode();
        newNode.line = line;
        rootNode.children.push(newNode);
        if (line[0] === "#" && line[1] === "d") {
          var split = line.replace(";", "").split(" ");
          newNode.additionalDefineKey = split[1];
          if (split.length === 3) {
            newNode.additionalDefineValue = split[2];
          }
        }
      }
    }
    return false;
  };
  ShaderProcessor2._EvaluatePreProcessors = function(sourceCode, preprocessors, options) {
    var rootNode = new ShaderCodeNode();
    var cursor = new ShaderCodeCursor();
    cursor.lineIndex = -1;
    cursor.lines = sourceCode.split("\n");
    this._MoveCursor(cursor, rootNode);
    return rootNode.process(preprocessors, options);
  };
  ShaderProcessor2._PreparePreProcessors = function(options) {
    var defines = options.defines;
    var preprocessors = {};
    for (var _i = 0, defines_1 = defines; _i < defines_1.length; _i++) {
      var define = defines_1[_i];
      var keyValue = define.replace("#define", "").replace(";", "").trim();
      var split = keyValue.split(" ");
      preprocessors[split[0]] = split.length > 1 ? split[1] : "";
    }
    preprocessors["GL_ES"] = "true";
    preprocessors["__VERSION__"] = options.version;
    preprocessors[options.platformName] = "true";
    return preprocessors;
  };
  ShaderProcessor2._ProcessShaderConversion = function(sourceCode, options, engine) {
    var preparedSourceCode = this._ProcessPrecision(sourceCode, options);
    if (!options.processor) {
      return preparedSourceCode;
    }
    if (preparedSourceCode.indexOf("#version 3") !== -1) {
      return preparedSourceCode.replace("#version 300 es", "");
    }
    var defines = options.defines;
    var preprocessors = this._PreparePreProcessors(options);
    if (options.processor.preProcessor) {
      preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment);
    }
    preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options);
    if (options.processor.postProcessor) {
      preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, engine);
    }
    return preparedSourceCode;
  };
  ShaderProcessor2._ProcessIncludes = function(sourceCode, options, callback) {
    var _this = this;
    var regex = /#include<(.+)>(\((.*)\))*(\[(.*)\])*/g;
    var match = regex.exec(sourceCode);
    var returnValue = new String(sourceCode);
    var keepProcessing = false;
    while (match != null) {
      var includeFile = match[1];
      if (includeFile.indexOf("__decl__") !== -1) {
        includeFile = includeFile.replace(/__decl__/, "");
        if (options.supportsUniformBuffers) {
          includeFile = includeFile.replace(/Vertex/, "Ubo");
          includeFile = includeFile.replace(/Fragment/, "Ubo");
        }
        includeFile = includeFile + "Declaration";
      }
      if (options.includesShadersStore[includeFile]) {
        var includeContent = options.includesShadersStore[includeFile];
        if (match[2]) {
          var splits = match[3].split(",");
          for (var index = 0; index < splits.length; index += 2) {
            var source = new RegExp(splits[index], "g");
            var dest = splits[index + 1];
            includeContent = includeContent.replace(source, dest);
          }
        }
        if (match[4]) {
          var indexString = match[5];
          if (indexString.indexOf("..") !== -1) {
            var indexSplits = indexString.split("..");
            var minIndex = parseInt(indexSplits[0]);
            var maxIndex = parseInt(indexSplits[1]);
            var sourceIncludeContent = includeContent.slice(0);
            includeContent = "";
            if (isNaN(maxIndex)) {
              maxIndex = options.indexParameters[indexSplits[1]];
            }
            for (var i = minIndex; i < maxIndex; i++) {
              if (!options.supportsUniformBuffers) {
                sourceIncludeContent = sourceIncludeContent.replace(/light\{X\}.(\w*)/g, function(str, p1) {
                  return p1 + "{X}";
                });
              }
              includeContent += sourceIncludeContent.replace(/\{X\}/g, i.toString()) + "\n";
            }
          } else {
            if (!options.supportsUniformBuffers) {
              includeContent = includeContent.replace(/light\{X\}.(\w*)/g, function(str, p1) {
                return p1 + "{X}";
              });
            }
            includeContent = includeContent.replace(/\{X\}/g, indexString);
          }
        }
        returnValue = returnValue.replace(match[0], includeContent);
        keepProcessing = keepProcessing || includeContent.indexOf("#include<") >= 0;
      } else {
        var includeShaderUrl = options.shadersRepository + "ShadersInclude/" + includeFile + ".fx";
        ShaderProcessor2._FileToolsLoadFile(includeShaderUrl, function(fileContent) {
          options.includesShadersStore[includeFile] = fileContent;
          _this._ProcessIncludes(returnValue, options, callback);
        });
        return;
      }
      match = regex.exec(sourceCode);
    }
    if (keepProcessing) {
      this._ProcessIncludes(returnValue.toString(), options, callback);
    } else {
      callback(returnValue);
    }
  };
  ShaderProcessor2._FileToolsLoadFile = function(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
    throw _DevTools.WarnImport("FileTools");
  };
  return ShaderProcessor2;
}();

// node_modules/@babylonjs/core/Materials/effect.js
var Effect = function() {
  function Effect2(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, engine, defines, fallbacks, onCompiled, onError, indexParameters) {
    var _this = this;
    if (samplers === void 0) {
      samplers = null;
    }
    if (defines === void 0) {
      defines = null;
    }
    if (fallbacks === void 0) {
      fallbacks = null;
    }
    if (onCompiled === void 0) {
      onCompiled = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    var _a;
    this.name = null;
    this.defines = "";
    this.onCompiled = null;
    this.onError = null;
    this.onBind = null;
    this.uniqueId = 0;
    this.onCompileObservable = new Observable();
    this.onErrorObservable = new Observable();
    this._onBindObservable = null;
    this._wasPreviouslyReady = false;
    this._bonesComputationForcedToCPU = false;
    this._multiTarget = false;
    this._uniformBuffersNames = {};
    this._samplers = {};
    this._isReady = false;
    this._compilationError = "";
    this._allFallbacksProcessed = false;
    this._uniforms = {};
    this._key = "";
    this._fallbacks = null;
    this._vertexSourceCode = "";
    this._fragmentSourceCode = "";
    this._vertexSourceCodeOverride = "";
    this._fragmentSourceCodeOverride = "";
    this._transformFeedbackVaryings = null;
    this._rawVertexSourceCode = "";
    this._rawFragmentSourceCode = "";
    this._pipelineContext = null;
    this._valueCache = {};
    this.name = baseName;
    var processFinalCode = null;
    if (attributesNamesOrOptions.attributes) {
      var options = attributesNamesOrOptions;
      this._engine = uniformsNamesOrEngine;
      this._attributesNames = options.attributes;
      this._uniformsNames = options.uniformsNames.concat(options.samplers);
      this._samplerList = options.samplers.slice();
      this.defines = options.defines;
      this.onError = options.onError;
      this.onCompiled = options.onCompiled;
      this._fallbacks = options.fallbacks;
      this._indexParameters = options.indexParameters;
      this._transformFeedbackVaryings = options.transformFeedbackVaryings || null;
      this._multiTarget = !!options.multiTarget;
      if (options.uniformBuffersNames) {
        this._uniformBuffersNamesList = options.uniformBuffersNames.slice();
        for (var i = 0; i < options.uniformBuffersNames.length; i++) {
          this._uniformBuffersNames[options.uniformBuffersNames[i]] = i;
        }
      }
      processFinalCode = (_a = options.processFinalCode) !== null && _a !== void 0 ? _a : null;
    } else {
      this._engine = engine;
      this.defines = defines == null ? "" : defines;
      this._uniformsNames = uniformsNamesOrEngine.concat(samplers);
      this._samplerList = samplers ? samplers.slice() : [];
      this._attributesNames = attributesNamesOrOptions;
      this._uniformBuffersNamesList = [];
      this.onError = onError;
      this.onCompiled = onCompiled;
      this._indexParameters = indexParameters;
      this._fallbacks = fallbacks;
    }
    this._attributeLocationByName = {};
    this.uniqueId = Effect2._uniqueIdSeed++;
    var vertexSource;
    var fragmentSource;
    var hostDocument = DomManagement.IsWindowObjectExist() ? this._engine.getHostDocument() : null;
    if (baseName.vertexSource) {
      vertexSource = "source:" + baseName.vertexSource;
    } else if (baseName.vertexElement) {
      vertexSource = hostDocument ? hostDocument.getElementById(baseName.vertexElement) : null;
      if (!vertexSource) {
        vertexSource = baseName.vertexElement;
      }
    } else {
      vertexSource = baseName.vertex || baseName;
    }
    if (baseName.fragmentSource) {
      fragmentSource = "source:" + baseName.fragmentSource;
    } else if (baseName.fragmentElement) {
      fragmentSource = hostDocument ? hostDocument.getElementById(baseName.fragmentElement) : null;
      if (!fragmentSource) {
        fragmentSource = baseName.fragmentElement;
      }
    } else {
      fragmentSource = baseName.fragment || baseName;
    }
    var processorOptions = {
      defines: this.defines.split("\n"),
      indexParameters: this._indexParameters,
      isFragment: false,
      shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,
      processor: this._engine._shaderProcessor,
      supportsUniformBuffers: this._engine.supportsUniformBuffers,
      shadersRepository: Effect2.ShadersRepository,
      includesShadersStore: Effect2.IncludesShadersStore,
      version: (this._engine.webGLVersion * 100).toString(),
      platformName: this._engine.webGLVersion >= 2 ? "WEBGL2" : "WEBGL1"
    };
    this._loadShader(vertexSource, "Vertex", "", function(vertexCode) {
      _this._rawVertexSourceCode = vertexCode;
      _this._loadShader(fragmentSource, "Fragment", "Pixel", function(fragmentCode) {
        _this._rawFragmentSourceCode = fragmentCode;
        ShaderProcessor.Process(vertexCode, processorOptions, function(migratedVertexCode) {
          if (processFinalCode) {
            migratedVertexCode = processFinalCode("vertex", migratedVertexCode);
          }
          processorOptions.isFragment = true;
          ShaderProcessor.Process(fragmentCode, processorOptions, function(migratedFragmentCode) {
            if (processFinalCode) {
              migratedFragmentCode = processFinalCode("fragment", migratedFragmentCode);
            }
            _this._useFinalCode(migratedVertexCode, migratedFragmentCode, baseName);
          }, _this._engine);
        }, _this._engine);
      });
    });
  }
  Object.defineProperty(Effect2.prototype, "onBindObservable", {
    get: function() {
      if (!this._onBindObservable) {
        this._onBindObservable = new Observable();
      }
      return this._onBindObservable;
    },
    enumerable: false,
    configurable: true
  });
  Effect2.prototype._useFinalCode = function(migratedVertexCode, migratedFragmentCode, baseName) {
    if (baseName) {
      var vertex = baseName.vertexElement || baseName.vertex || baseName.spectorName || baseName;
      var fragment = baseName.fragmentElement || baseName.fragment || baseName.spectorName || baseName;
      this._vertexSourceCode = "#define SHADER_NAME vertex:" + vertex + "\n" + migratedVertexCode;
      this._fragmentSourceCode = "#define SHADER_NAME fragment:" + fragment + "\n" + migratedFragmentCode;
    } else {
      this._vertexSourceCode = migratedVertexCode;
      this._fragmentSourceCode = migratedFragmentCode;
    }
    this._prepareEffect();
  };
  Object.defineProperty(Effect2.prototype, "key", {
    get: function() {
      return this._key;
    },
    enumerable: false,
    configurable: true
  });
  Effect2.prototype.isReady = function() {
    try {
      return this._isReadyInternal();
    } catch (_a) {
      return false;
    }
  };
  Effect2.prototype._isReadyInternal = function() {
    if (this._isReady) {
      return true;
    }
    if (this._pipelineContext) {
      return this._pipelineContext.isReady;
    }
    return false;
  };
  Effect2.prototype.getEngine = function() {
    return this._engine;
  };
  Effect2.prototype.getPipelineContext = function() {
    return this._pipelineContext;
  };
  Effect2.prototype.getAttributesNames = function() {
    return this._attributesNames;
  };
  Effect2.prototype.getAttributeLocation = function(index) {
    return this._attributes[index];
  };
  Effect2.prototype.getAttributeLocationByName = function(name45) {
    return this._attributeLocationByName[name45];
  };
  Effect2.prototype.getAttributesCount = function() {
    return this._attributes.length;
  };
  Effect2.prototype.getUniformIndex = function(uniformName) {
    return this._uniformsNames.indexOf(uniformName);
  };
  Effect2.prototype.getUniform = function(uniformName) {
    return this._uniforms[uniformName];
  };
  Effect2.prototype.getSamplers = function() {
    return this._samplerList;
  };
  Effect2.prototype.getUniformNames = function() {
    return this._uniformsNames;
  };
  Effect2.prototype.getUniformBuffersNames = function() {
    return this._uniformBuffersNamesList;
  };
  Effect2.prototype.getIndexParameters = function() {
    return this._indexParameters;
  };
  Effect2.prototype.getCompilationError = function() {
    return this._compilationError;
  };
  Effect2.prototype.allFallbacksProcessed = function() {
    return this._allFallbacksProcessed;
  };
  Effect2.prototype.executeWhenCompiled = function(func) {
    var _this = this;
    if (this.isReady()) {
      func(this);
      return;
    }
    this.onCompileObservable.add(function(effect) {
      func(effect);
    });
    if (!this._pipelineContext || this._pipelineContext.isAsync) {
      setTimeout(function() {
        _this._checkIsReady(null);
      }, 16);
    }
  };
  Effect2.prototype._checkIsReady = function(previousPipelineContext) {
    var _this = this;
    try {
      if (this._isReadyInternal()) {
        return;
      }
    } catch (e) {
      this._processCompilationErrors(e, previousPipelineContext);
      return;
    }
    setTimeout(function() {
      _this._checkIsReady(previousPipelineContext);
    }, 16);
  };
  Effect2.prototype._loadShader = function(shader45, key, optionalKey, callback) {
    if (typeof HTMLElement !== "undefined") {
      if (shader45 instanceof HTMLElement) {
        var shaderCode = DomManagement.GetDOMTextContent(shader45);
        callback(shaderCode);
        return;
      }
    }
    if (shader45.substr(0, 7) === "source:") {
      callback(shader45.substr(7));
      return;
    }
    if (shader45.substr(0, 7) === "base64:") {
      var shaderBinary = window.atob(shader45.substr(7));
      callback(shaderBinary);
      return;
    }
    if (Effect2.ShadersStore[shader45 + key + "Shader"]) {
      callback(Effect2.ShadersStore[shader45 + key + "Shader"]);
      return;
    }
    if (optionalKey && Effect2.ShadersStore[shader45 + optionalKey + "Shader"]) {
      callback(Effect2.ShadersStore[shader45 + optionalKey + "Shader"]);
      return;
    }
    var shaderUrl;
    if (shader45[0] === "." || shader45[0] === "/" || shader45.indexOf("http") > -1) {
      shaderUrl = shader45;
    } else {
      shaderUrl = Effect2.ShadersRepository + shader45;
    }
    this._engine._loadFile(shaderUrl + "." + key.toLowerCase() + ".fx", callback);
  };
  Object.defineProperty(Effect2.prototype, "vertexSourceCode", {
    get: function() {
      return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._vertexSourceCodeOverride : this._vertexSourceCode;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Effect2.prototype, "fragmentSourceCode", {
    get: function() {
      return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._fragmentSourceCodeOverride : this._fragmentSourceCode;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Effect2.prototype, "rawVertexSourceCode", {
    get: function() {
      return this._rawVertexSourceCode;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Effect2.prototype, "rawFragmentSourceCode", {
    get: function() {
      return this._rawFragmentSourceCode;
    },
    enumerable: false,
    configurable: true
  });
  Effect2.prototype._rebuildProgram = function(vertexSourceCode, fragmentSourceCode, onCompiled, onError) {
    var _this = this;
    this._isReady = false;
    this._vertexSourceCodeOverride = vertexSourceCode;
    this._fragmentSourceCodeOverride = fragmentSourceCode;
    this.onError = function(effect, error) {
      if (onError) {
        onError(error);
      }
    };
    this.onCompiled = function() {
      var scenes = _this.getEngine().scenes;
      if (scenes) {
        for (var i = 0; i < scenes.length; i++) {
          scenes[i].markAllMaterialsAsDirty(63);
        }
      }
      _this._pipelineContext._handlesSpectorRebuildCallback(onCompiled);
    };
    this._fallbacks = null;
    this._prepareEffect();
  };
  Effect2.prototype._prepareEffect = function() {
    var _this = this;
    var attributesNames = this._attributesNames;
    var defines = this.defines;
    this._valueCache = {};
    var previousPipelineContext = this._pipelineContext;
    try {
      var engine_1 = this._engine;
      this._pipelineContext = engine_1.createPipelineContext();
      var rebuildRebind = this._rebuildProgram.bind(this);
      if (this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride) {
        engine_1._preparePipelineContext(this._pipelineContext, this._vertexSourceCodeOverride, this._fragmentSourceCodeOverride, true, rebuildRebind, null, this._transformFeedbackVaryings);
      } else {
        engine_1._preparePipelineContext(this._pipelineContext, this._vertexSourceCode, this._fragmentSourceCode, false, rebuildRebind, defines, this._transformFeedbackVaryings);
      }
      engine_1._executeWhenRenderingStateIsCompiled(this._pipelineContext, function() {
        if (engine_1.supportsUniformBuffers) {
          for (var name45 in _this._uniformBuffersNames) {
            _this.bindUniformBlock(name45, _this._uniformBuffersNames[name45]);
          }
        }
        var uniforms = engine_1.getUniforms(_this._pipelineContext, _this._uniformsNames);
        uniforms.forEach(function(uniform, index2) {
          _this._uniforms[_this._uniformsNames[index2]] = uniform;
        });
        _this._attributes = engine_1.getAttributes(_this._pipelineContext, attributesNames);
        if (attributesNames) {
          for (var i = 0; i < attributesNames.length; i++) {
            var name_1 = attributesNames[i];
            _this._attributeLocationByName[name_1] = _this._attributes[i];
          }
        }
        var index;
        for (index = 0; index < _this._samplerList.length; index++) {
          var sampler = _this.getUniform(_this._samplerList[index]);
          if (sampler == null) {
            _this._samplerList.splice(index, 1);
            index--;
          }
        }
        _this._samplerList.forEach(function(name46, index2) {
          _this._samplers[name46] = index2;
        });
        engine_1.bindSamplers(_this);
        _this._compilationError = "";
        _this._isReady = true;
        if (_this.onCompiled) {
          _this.onCompiled(_this);
        }
        _this.onCompileObservable.notifyObservers(_this);
        _this.onCompileObservable.clear();
        if (_this._fallbacks) {
          _this._fallbacks.unBindMesh();
        }
        if (previousPipelineContext) {
          _this.getEngine()._deletePipelineContext(previousPipelineContext);
        }
      });
      if (this._pipelineContext.isAsync) {
        this._checkIsReady(previousPipelineContext);
      }
    } catch (e) {
      this._processCompilationErrors(e, previousPipelineContext);
    }
  };
  Effect2.prototype._getShaderCodeAndErrorLine = function(code, error, isFragment) {
    var regexp = isFragment ? /FRAGMENT SHADER ERROR: 0:(\d+?):/ : /VERTEX SHADER ERROR: 0:(\d+?):/;
    var errorLine = null;
    if (error && code) {
      var res = error.match(regexp);
      if (res && res.length === 2) {
        var lineNumber = parseInt(res[1]);
        var lines = code.split("\n", -1);
        if (lines.length >= lineNumber) {
          errorLine = "Offending line [" + lineNumber + "] in " + (isFragment ? "fragment" : "vertex") + " code: " + lines[lineNumber - 1];
        }
      }
    }
    return [code, errorLine];
  };
  Effect2.prototype._processCompilationErrors = function(e, previousPipelineContext) {
    var _a, _b;
    var _c, _d, _e;
    if (previousPipelineContext === void 0) {
      previousPipelineContext = null;
    }
    this._compilationError = e.message;
    var attributesNames = this._attributesNames;
    var fallbacks = this._fallbacks;
    Logger.Error("Unable to compile effect:");
    Logger.Error("Uniforms: " + this._uniformsNames.map(function(uniform) {
      return " " + uniform;
    }));
    Logger.Error("Attributes: " + attributesNames.map(function(attribute) {
      return " " + attribute;
    }));
    Logger.Error("Defines:\r\n" + this.defines);
    if (Effect2.LogShaderCodeOnCompilationError) {
      var lineErrorVertex = null, lineErrorFragment = null, code = null;
      if ((_c = this._pipelineContext) === null || _c === void 0 ? void 0 : _c._getVertexShaderCode()) {
        _a = this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(), this._compilationError, false), code = _a[0], lineErrorVertex = _a[1];
        if (code) {
          Logger.Error("Vertex code:");
          Logger.Error(code);
        }
      }
      if ((_d = this._pipelineContext) === null || _d === void 0 ? void 0 : _d._getFragmentShaderCode()) {
        _b = this._getShaderCodeAndErrorLine((_e = this._pipelineContext) === null || _e === void 0 ? void 0 : _e._getFragmentShaderCode(), this._compilationError, true), code = _b[0], lineErrorFragment = _b[1];
        if (code) {
          Logger.Error("Fragment code:");
          Logger.Error(code);
        }
      }
      if (lineErrorVertex) {
        Logger.Error(lineErrorVertex);
      }
      if (lineErrorFragment) {
        Logger.Error(lineErrorFragment);
      }
    }
    Logger.Error("Error: " + this._compilationError);
    if (previousPipelineContext) {
      this._pipelineContext = previousPipelineContext;
      this._isReady = true;
      if (this.onError) {
        this.onError(this, this._compilationError);
      }
      this.onErrorObservable.notifyObservers(this);
    }
    if (fallbacks) {
      this._pipelineContext = null;
      if (fallbacks.hasMoreFallbacks) {
        this._allFallbacksProcessed = false;
        Logger.Error("Trying next fallback.");
        this.defines = fallbacks.reduce(this.defines, this);
        this._prepareEffect();
      } else {
        this._allFallbacksProcessed = true;
        if (this.onError) {
          this.onError(this, this._compilationError);
        }
        this.onErrorObservable.notifyObservers(this);
        this.onErrorObservable.clear();
        if (this._fallbacks) {
          this._fallbacks.unBindMesh();
        }
      }
    } else {
      this._allFallbacksProcessed = true;
    }
  };
  Object.defineProperty(Effect2.prototype, "isSupported", {
    get: function() {
      return this._compilationError === "";
    },
    enumerable: false,
    configurable: true
  });
  Effect2.prototype._bindTexture = function(channel, texture) {
    this._engine._bindTexture(this._samplers[channel], texture);
  };
  Effect2.prototype.setTexture = function(channel, texture) {
    this._engine.setTexture(this._samplers[channel], this._uniforms[channel], texture);
  };
  Effect2.prototype.setDepthStencilTexture = function(channel, texture) {
    this._engine.setDepthStencilTexture(this._samplers[channel], this._uniforms[channel], texture);
  };
  Effect2.prototype.setTextureArray = function(channel, textures) {
    var exName = channel + "Ex";
    if (this._samplerList.indexOf(exName + "0") === -1) {
      var initialPos = this._samplerList.indexOf(channel);
      for (var index = 1; index < textures.length; index++) {
        var currentExName = exName + (index - 1).toString();
        this._samplerList.splice(initialPos + index, 0, currentExName);
      }
      var channelIndex = 0;
      for (var _i = 0, _a = this._samplerList; _i < _a.length; _i++) {
        var key = _a[_i];
        this._samplers[key] = channelIndex;
        channelIndex += 1;
      }
    }
    this._engine.setTextureArray(this._samplers[channel], this._uniforms[channel], textures);
  };
  Effect2.prototype.setTextureFromPostProcess = function(channel, postProcess) {
    this._engine.setTextureFromPostProcess(this._samplers[channel], postProcess);
  };
  Effect2.prototype.setTextureFromPostProcessOutput = function(channel, postProcess) {
    this._engine.setTextureFromPostProcessOutput(this._samplers[channel], postProcess);
  };
  Effect2.prototype._cacheMatrix = function(uniformName, matrix) {
    var cache = this._valueCache[uniformName];
    var flag = matrix.updateFlag;
    if (cache !== void 0 && cache === flag) {
      return false;
    }
    this._valueCache[uniformName] = flag;
    return true;
  };
  Effect2.prototype._cacheFloat2 = function(uniformName, x, y) {
    var cache = this._valueCache[uniformName];
    if (!cache || cache.length !== 2) {
      cache = [x, y];
      this._valueCache[uniformName] = cache;
      return true;
    }
    var changed = false;
    if (cache[0] !== x) {
      cache[0] = x;
      changed = true;
    }
    if (cache[1] !== y) {
      cache[1] = y;
      changed = true;
    }
    return changed;
  };
  Effect2.prototype._cacheFloat3 = function(uniformName, x, y, z) {
    var cache = this._valueCache[uniformName];
    if (!cache || cache.length !== 3) {
      cache = [x, y, z];
      this._valueCache[uniformName] = cache;
      return true;
    }
    var changed = false;
    if (cache[0] !== x) {
      cache[0] = x;
      changed = true;
    }
    if (cache[1] !== y) {
      cache[1] = y;
      changed = true;
    }
    if (cache[2] !== z) {
      cache[2] = z;
      changed = true;
    }
    return changed;
  };
  Effect2.prototype._cacheFloat4 = function(uniformName, x, y, z, w) {
    var cache = this._valueCache[uniformName];
    if (!cache || cache.length !== 4) {
      cache = [x, y, z, w];
      this._valueCache[uniformName] = cache;
      return true;
    }
    var changed = false;
    if (cache[0] !== x) {
      cache[0] = x;
      changed = true;
    }
    if (cache[1] !== y) {
      cache[1] = y;
      changed = true;
    }
    if (cache[2] !== z) {
      cache[2] = z;
      changed = true;
    }
    if (cache[3] !== w) {
      cache[3] = w;
      changed = true;
    }
    return changed;
  };
  Effect2.prototype.bindUniformBuffer = function(buffer, name45) {
    var bufferName = this._uniformBuffersNames[name45];
    if (bufferName === void 0 || Effect2._baseCache[bufferName] === buffer) {
      return;
    }
    Effect2._baseCache[bufferName] = buffer;
    this._engine.bindUniformBufferBase(buffer, bufferName);
  };
  Effect2.prototype.bindUniformBlock = function(blockName, index) {
    this._engine.bindUniformBlock(this._pipelineContext, blockName, index);
  };
  Effect2.prototype.setInt = function(uniformName, value) {
    var cache = this._valueCache[uniformName];
    if (cache !== void 0 && cache === value) {
      return this;
    }
    if (this._engine.setInt(this._uniforms[uniformName], value)) {
      this._valueCache[uniformName] = value;
    }
    return this;
  };
  Effect2.prototype.setIntArray = function(uniformName, array) {
    this._valueCache[uniformName] = null;
    this._engine.setIntArray(this._uniforms[uniformName], array);
    return this;
  };
  Effect2.prototype.setIntArray2 = function(uniformName, array) {
    this._valueCache[uniformName] = null;
    this._engine.setIntArray2(this._uniforms[uniformName], array);
    return this;
  };
  Effect2.prototype.setIntArray3 = function(uniformName, array) {
    this._valueCache[uniformName] = null;
    this._engine.setIntArray3(this._uniforms[uniformName], array);
    return this;
  };
  Effect2.prototype.setIntArray4 = function(uniformName, array) {
    this._valueCache[uniformName] = null;
    this._engine.setIntArray4(this._uniforms[uniformName], array);
    return this;
  };
  Effect2.prototype.setFloatArray = function(uniformName, array) {
    this._valueCache[uniformName] = null;
    this._engine.setArray(this._uniforms[uniformName], array);
    return this;
  };
  Effect2.prototype.setFloatArray2 = function(uniformName, array) {
    this._valueCache[uniformName] = null;
    this._engine.setArray2(this._uniforms[uniformName], array);
    return this;
  };
  Effect2.prototype.setFloatArray3 = function(uniformName, array) {
    this._valueCache[uniformName] = null;
    this._engine.setArray3(this._uniforms[uniformName], array);
    return this;
  };
  Effect2.prototype.setFloatArray4 = function(uniformName, array) {
    this._valueCache[uniformName] = null;
    this._engine.setArray4(this._uniforms[uniformName], array);
    return this;
  };
  Effect2.prototype.setArray = function(uniformName, array) {
    this._valueCache[uniformName] = null;
    this._engine.setArray(this._uniforms[uniformName], array);
    return this;
  };
  Effect2.prototype.setArray2 = function(uniformName, array) {
    this._valueCache[uniformName] = null;
    this._engine.setArray2(this._uniforms[uniformName], array);
    return this;
  };
  Effect2.prototype.setArray3 = function(uniformName, array) {
    this._valueCache[uniformName] = null;
    this._engine.setArray3(this._uniforms[uniformName], array);
    return this;
  };
  Effect2.prototype.setArray4 = function(uniformName, array) {
    this._valueCache[uniformName] = null;
    this._engine.setArray4(this._uniforms[uniformName], array);
    return this;
  };
  Effect2.prototype.setMatrices = function(uniformName, matrices) {
    if (!matrices) {
      return this;
    }
    this._valueCache[uniformName] = null;
    this._engine.setMatrices(this._uniforms[uniformName], matrices);
    return this;
  };
  Effect2.prototype.setMatrix = function(uniformName, matrix) {
    if (this._cacheMatrix(uniformName, matrix)) {
      if (!this._engine.setMatrices(this._uniforms[uniformName], matrix.toArray())) {
        this._valueCache[uniformName] = null;
      }
    }
    return this;
  };
  Effect2.prototype.setMatrix3x3 = function(uniformName, matrix) {
    this._valueCache[uniformName] = null;
    this._engine.setMatrix3x3(this._uniforms[uniformName], matrix);
    return this;
  };
  Effect2.prototype.setMatrix2x2 = function(uniformName, matrix) {
    this._valueCache[uniformName] = null;
    this._engine.setMatrix2x2(this._uniforms[uniformName], matrix);
    return this;
  };
  Effect2.prototype.setFloat = function(uniformName, value) {
    var cache = this._valueCache[uniformName];
    if (cache !== void 0 && cache === value) {
      return this;
    }
    if (this._engine.setFloat(this._uniforms[uniformName], value)) {
      this._valueCache[uniformName] = value;
    }
    return this;
  };
  Effect2.prototype.setBool = function(uniformName, bool) {
    var cache = this._valueCache[uniformName];
    if (cache !== void 0 && cache === bool) {
      return this;
    }
    if (this._engine.setInt(this._uniforms[uniformName], bool ? 1 : 0)) {
      this._valueCache[uniformName] = bool;
    }
    return this;
  };
  Effect2.prototype.setVector2 = function(uniformName, vector2) {
    if (this._cacheFloat2(uniformName, vector2.x, vector2.y)) {
      if (!this._engine.setFloat2(this._uniforms[uniformName], vector2.x, vector2.y)) {
        this._valueCache[uniformName] = null;
      }
    }
    return this;
  };
  Effect2.prototype.setFloat2 = function(uniformName, x, y) {
    if (this._cacheFloat2(uniformName, x, y)) {
      if (!this._engine.setFloat2(this._uniforms[uniformName], x, y)) {
        this._valueCache[uniformName] = null;
      }
    }
    return this;
  };
  Effect2.prototype.setVector3 = function(uniformName, vector3) {
    if (this._cacheFloat3(uniformName, vector3.x, vector3.y, vector3.z)) {
      if (!this._engine.setFloat3(this._uniforms[uniformName], vector3.x, vector3.y, vector3.z)) {
        this._valueCache[uniformName] = null;
      }
    }
    return this;
  };
  Effect2.prototype.setFloat3 = function(uniformName, x, y, z) {
    if (this._cacheFloat3(uniformName, x, y, z)) {
      if (!this._engine.setFloat3(this._uniforms[uniformName], x, y, z)) {
        this._valueCache[uniformName] = null;
      }
    }
    return this;
  };
  Effect2.prototype.setVector4 = function(uniformName, vector4) {
    if (this._cacheFloat4(uniformName, vector4.x, vector4.y, vector4.z, vector4.w)) {
      if (!this._engine.setFloat4(this._uniforms[uniformName], vector4.x, vector4.y, vector4.z, vector4.w)) {
        this._valueCache[uniformName] = null;
      }
    }
    return this;
  };
  Effect2.prototype.setFloat4 = function(uniformName, x, y, z, w) {
    if (this._cacheFloat4(uniformName, x, y, z, w)) {
      if (!this._engine.setFloat4(this._uniforms[uniformName], x, y, z, w)) {
        this._valueCache[uniformName] = null;
      }
    }
    return this;
  };
  Effect2.prototype.setColor3 = function(uniformName, color3) {
    if (this._cacheFloat3(uniformName, color3.r, color3.g, color3.b)) {
      if (!this._engine.setFloat3(this._uniforms[uniformName], color3.r, color3.g, color3.b)) {
        this._valueCache[uniformName] = null;
      }
    }
    return this;
  };
  Effect2.prototype.setColor4 = function(uniformName, color3, alpha) {
    if (this._cacheFloat4(uniformName, color3.r, color3.g, color3.b, alpha)) {
      if (!this._engine.setFloat4(this._uniforms[uniformName], color3.r, color3.g, color3.b, alpha)) {
        this._valueCache[uniformName] = null;
      }
    }
    return this;
  };
  Effect2.prototype.setDirectColor4 = function(uniformName, color4) {
    if (this._cacheFloat4(uniformName, color4.r, color4.g, color4.b, color4.a)) {
      if (!this._engine.setFloat4(this._uniforms[uniformName], color4.r, color4.g, color4.b, color4.a)) {
        this._valueCache[uniformName] = null;
      }
    }
    return this;
  };
  Effect2.prototype.dispose = function() {
    this._engine._releaseEffect(this);
  };
  Effect2.RegisterShader = function(name45, pixelShader, vertexShader) {
    if (pixelShader) {
      Effect2.ShadersStore[name45 + "PixelShader"] = pixelShader;
    }
    if (vertexShader) {
      Effect2.ShadersStore[name45 + "VertexShader"] = vertexShader;
    }
  };
  Effect2.ResetCache = function() {
    Effect2._baseCache = {};
  };
  Effect2.ShadersRepository = "src/Shaders/";
  Effect2.LogShaderCodeOnCompilationError = true;
  Effect2._uniqueIdSeed = 0;
  Effect2._baseCache = {};
  Effect2.ShadersStore = {};
  Effect2.IncludesShadersStore = {};
  return Effect2;
}();

// node_modules/@babylonjs/core/States/depthCullingState.js
var DepthCullingState = function() {
  function DepthCullingState2() {
    this._isDepthTestDirty = false;
    this._isDepthMaskDirty = false;
    this._isDepthFuncDirty = false;
    this._isCullFaceDirty = false;
    this._isCullDirty = false;
    this._isZOffsetDirty = false;
    this._isFrontFaceDirty = false;
    this.reset();
  }
  Object.defineProperty(DepthCullingState2.prototype, "isDirty", {
    get: function() {
      return this._isDepthFuncDirty || this._isDepthTestDirty || this._isDepthMaskDirty || this._isCullFaceDirty || this._isCullDirty || this._isZOffsetDirty || this._isFrontFaceDirty;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DepthCullingState2.prototype, "zOffset", {
    get: function() {
      return this._zOffset;
    },
    set: function(value) {
      if (this._zOffset === value) {
        return;
      }
      this._zOffset = value;
      this._isZOffsetDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DepthCullingState2.prototype, "cullFace", {
    get: function() {
      return this._cullFace;
    },
    set: function(value) {
      if (this._cullFace === value) {
        return;
      }
      this._cullFace = value;
      this._isCullFaceDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DepthCullingState2.prototype, "cull", {
    get: function() {
      return this._cull;
    },
    set: function(value) {
      if (this._cull === value) {
        return;
      }
      this._cull = value;
      this._isCullDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DepthCullingState2.prototype, "depthFunc", {
    get: function() {
      return this._depthFunc;
    },
    set: function(value) {
      if (this._depthFunc === value) {
        return;
      }
      this._depthFunc = value;
      this._isDepthFuncDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DepthCullingState2.prototype, "depthMask", {
    get: function() {
      return this._depthMask;
    },
    set: function(value) {
      if (this._depthMask === value) {
        return;
      }
      this._depthMask = value;
      this._isDepthMaskDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DepthCullingState2.prototype, "depthTest", {
    get: function() {
      return this._depthTest;
    },
    set: function(value) {
      if (this._depthTest === value) {
        return;
      }
      this._depthTest = value;
      this._isDepthTestDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DepthCullingState2.prototype, "frontFace", {
    get: function() {
      return this._frontFace;
    },
    set: function(value) {
      if (this._frontFace === value) {
        return;
      }
      this._frontFace = value;
      this._isFrontFaceDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  DepthCullingState2.prototype.reset = function() {
    this._depthMask = true;
    this._depthTest = true;
    this._depthFunc = null;
    this._cullFace = null;
    this._cull = null;
    this._zOffset = 0;
    this._frontFace = null;
    this._isDepthTestDirty = true;
    this._isDepthMaskDirty = true;
    this._isDepthFuncDirty = false;
    this._isCullFaceDirty = false;
    this._isCullDirty = false;
    this._isZOffsetDirty = false;
    this._isFrontFaceDirty = false;
  };
  DepthCullingState2.prototype.apply = function(gl) {
    if (!this.isDirty) {
      return;
    }
    if (this._isCullDirty) {
      if (this.cull) {
        gl.enable(gl.CULL_FACE);
      } else {
        gl.disable(gl.CULL_FACE);
      }
      this._isCullDirty = false;
    }
    if (this._isCullFaceDirty) {
      gl.cullFace(this.cullFace);
      this._isCullFaceDirty = false;
    }
    if (this._isDepthMaskDirty) {
      gl.depthMask(this.depthMask);
      this._isDepthMaskDirty = false;
    }
    if (this._isDepthTestDirty) {
      if (this.depthTest) {
        gl.enable(gl.DEPTH_TEST);
      } else {
        gl.disable(gl.DEPTH_TEST);
      }
      this._isDepthTestDirty = false;
    }
    if (this._isDepthFuncDirty) {
      gl.depthFunc(this.depthFunc);
      this._isDepthFuncDirty = false;
    }
    if (this._isZOffsetDirty) {
      if (this.zOffset) {
        gl.enable(gl.POLYGON_OFFSET_FILL);
        gl.polygonOffset(this.zOffset, 0);
      } else {
        gl.disable(gl.POLYGON_OFFSET_FILL);
      }
      this._isZOffsetDirty = false;
    }
    if (this._isFrontFaceDirty) {
      gl.frontFace(this.frontFace);
      this._isFrontFaceDirty = false;
    }
  };
  return DepthCullingState2;
}();

// node_modules/@babylonjs/core/States/stencilState.js
var StencilState = function() {
  function StencilState2() {
    this._isStencilTestDirty = false;
    this._isStencilMaskDirty = false;
    this._isStencilFuncDirty = false;
    this._isStencilOpDirty = false;
    this.reset();
  }
  Object.defineProperty(StencilState2.prototype, "isDirty", {
    get: function() {
      return this._isStencilTestDirty || this._isStencilMaskDirty || this._isStencilFuncDirty || this._isStencilOpDirty;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilState2.prototype, "stencilFunc", {
    get: function() {
      return this._stencilFunc;
    },
    set: function(value) {
      if (this._stencilFunc === value) {
        return;
      }
      this._stencilFunc = value;
      this._isStencilFuncDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilState2.prototype, "stencilFuncRef", {
    get: function() {
      return this._stencilFuncRef;
    },
    set: function(value) {
      if (this._stencilFuncRef === value) {
        return;
      }
      this._stencilFuncRef = value;
      this._isStencilFuncDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilState2.prototype, "stencilFuncMask", {
    get: function() {
      return this._stencilFuncMask;
    },
    set: function(value) {
      if (this._stencilFuncMask === value) {
        return;
      }
      this._stencilFuncMask = value;
      this._isStencilFuncDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilState2.prototype, "stencilOpStencilFail", {
    get: function() {
      return this._stencilOpStencilFail;
    },
    set: function(value) {
      if (this._stencilOpStencilFail === value) {
        return;
      }
      this._stencilOpStencilFail = value;
      this._isStencilOpDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilState2.prototype, "stencilOpDepthFail", {
    get: function() {
      return this._stencilOpDepthFail;
    },
    set: function(value) {
      if (this._stencilOpDepthFail === value) {
        return;
      }
      this._stencilOpDepthFail = value;
      this._isStencilOpDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilState2.prototype, "stencilOpStencilDepthPass", {
    get: function() {
      return this._stencilOpStencilDepthPass;
    },
    set: function(value) {
      if (this._stencilOpStencilDepthPass === value) {
        return;
      }
      this._stencilOpStencilDepthPass = value;
      this._isStencilOpDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilState2.prototype, "stencilMask", {
    get: function() {
      return this._stencilMask;
    },
    set: function(value) {
      if (this._stencilMask === value) {
        return;
      }
      this._stencilMask = value;
      this._isStencilMaskDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilState2.prototype, "stencilTest", {
    get: function() {
      return this._stencilTest;
    },
    set: function(value) {
      if (this._stencilTest === value) {
        return;
      }
      this._stencilTest = value;
      this._isStencilTestDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  StencilState2.prototype.reset = function() {
    this._stencilTest = false;
    this._stencilMask = 255;
    this._stencilFunc = StencilState2.ALWAYS;
    this._stencilFuncRef = 1;
    this._stencilFuncMask = 255;
    this._stencilOpStencilFail = StencilState2.KEEP;
    this._stencilOpDepthFail = StencilState2.KEEP;
    this._stencilOpStencilDepthPass = StencilState2.REPLACE;
    this._isStencilTestDirty = true;
    this._isStencilMaskDirty = true;
    this._isStencilFuncDirty = true;
    this._isStencilOpDirty = true;
  };
  StencilState2.prototype.apply = function(gl) {
    if (!this.isDirty) {
      return;
    }
    if (this._isStencilTestDirty) {
      if (this.stencilTest) {
        gl.enable(gl.STENCIL_TEST);
      } else {
        gl.disable(gl.STENCIL_TEST);
      }
      this._isStencilTestDirty = false;
    }
    if (this._isStencilMaskDirty) {
      gl.stencilMask(this.stencilMask);
      this._isStencilMaskDirty = false;
    }
    if (this._isStencilFuncDirty) {
      gl.stencilFunc(this.stencilFunc, this.stencilFuncRef, this.stencilFuncMask);
      this._isStencilFuncDirty = false;
    }
    if (this._isStencilOpDirty) {
      gl.stencilOp(this.stencilOpStencilFail, this.stencilOpDepthFail, this.stencilOpStencilDepthPass);
      this._isStencilOpDirty = false;
    }
  };
  StencilState2.ALWAYS = 519;
  StencilState2.KEEP = 7680;
  StencilState2.REPLACE = 7681;
  return StencilState2;
}();

// node_modules/@babylonjs/core/States/alphaCullingState.js
var AlphaState = function() {
  function AlphaState2() {
    this._isAlphaBlendDirty = false;
    this._isBlendFunctionParametersDirty = false;
    this._isBlendEquationParametersDirty = false;
    this._isBlendConstantsDirty = false;
    this._alphaBlend = false;
    this._blendFunctionParameters = new Array(4);
    this._blendEquationParameters = new Array(2);
    this._blendConstants = new Array(4);
    this.reset();
  }
  Object.defineProperty(AlphaState2.prototype, "isDirty", {
    get: function() {
      return this._isAlphaBlendDirty || this._isBlendFunctionParametersDirty;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AlphaState2.prototype, "alphaBlend", {
    get: function() {
      return this._alphaBlend;
    },
    set: function(value) {
      if (this._alphaBlend === value) {
        return;
      }
      this._alphaBlend = value;
      this._isAlphaBlendDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  AlphaState2.prototype.setAlphaBlendConstants = function(r, g, b, a) {
    if (this._blendConstants[0] === r && this._blendConstants[1] === g && this._blendConstants[2] === b && this._blendConstants[3] === a) {
      return;
    }
    this._blendConstants[0] = r;
    this._blendConstants[1] = g;
    this._blendConstants[2] = b;
    this._blendConstants[3] = a;
    this._isBlendConstantsDirty = true;
  };
  AlphaState2.prototype.setAlphaBlendFunctionParameters = function(value0, value1, value2, value3) {
    if (this._blendFunctionParameters[0] === value0 && this._blendFunctionParameters[1] === value1 && this._blendFunctionParameters[2] === value2 && this._blendFunctionParameters[3] === value3) {
      return;
    }
    this._blendFunctionParameters[0] = value0;
    this._blendFunctionParameters[1] = value1;
    this._blendFunctionParameters[2] = value2;
    this._blendFunctionParameters[3] = value3;
    this._isBlendFunctionParametersDirty = true;
  };
  AlphaState2.prototype.setAlphaEquationParameters = function(rgb, alpha) {
    if (this._blendEquationParameters[0] === rgb && this._blendEquationParameters[1] === alpha) {
      return;
    }
    this._blendEquationParameters[0] = rgb;
    this._blendEquationParameters[1] = alpha;
    this._isBlendEquationParametersDirty = true;
  };
  AlphaState2.prototype.reset = function() {
    this._alphaBlend = false;
    this._blendFunctionParameters[0] = null;
    this._blendFunctionParameters[1] = null;
    this._blendFunctionParameters[2] = null;
    this._blendFunctionParameters[3] = null;
    this._blendEquationParameters[0] = null;
    this._blendEquationParameters[1] = null;
    this._blendConstants[0] = null;
    this._blendConstants[1] = null;
    this._blendConstants[2] = null;
    this._blendConstants[3] = null;
    this._isAlphaBlendDirty = true;
    this._isBlendFunctionParametersDirty = false;
    this._isBlendEquationParametersDirty = false;
    this._isBlendConstantsDirty = false;
  };
  AlphaState2.prototype.apply = function(gl) {
    if (!this.isDirty) {
      return;
    }
    if (this._isAlphaBlendDirty) {
      if (this._alphaBlend) {
        gl.enable(gl.BLEND);
      } else {
        gl.disable(gl.BLEND);
      }
      this._isAlphaBlendDirty = false;
    }
    if (this._isBlendFunctionParametersDirty) {
      gl.blendFuncSeparate(this._blendFunctionParameters[0], this._blendFunctionParameters[1], this._blendFunctionParameters[2], this._blendFunctionParameters[3]);
      this._isBlendFunctionParametersDirty = false;
    }
    if (this._isBlendEquationParametersDirty) {
      gl.blendEquationSeparate(this._blendEquationParameters[0], this._blendEquationParameters[1]);
      this._isBlendEquationParametersDirty = false;
    }
    if (this._isBlendConstantsDirty) {
      gl.blendColor(this._blendConstants[0], this._blendConstants[1], this._blendConstants[2], this._blendConstants[3]);
      this._isBlendConstantsDirty = false;
    }
  };
  return AlphaState2;
}();

// node_modules/@babylonjs/core/Materials/Textures/renderTargetCreationOptions.js
var RenderTargetCreationOptions = function() {
  function RenderTargetCreationOptions2() {
  }
  return RenderTargetCreationOptions2;
}();

// node_modules/@babylonjs/core/Materials/Textures/internalTexture.js
var InternalTextureSource;
(function(InternalTextureSource2) {
  InternalTextureSource2[InternalTextureSource2["Unknown"] = 0] = "Unknown";
  InternalTextureSource2[InternalTextureSource2["Url"] = 1] = "Url";
  InternalTextureSource2[InternalTextureSource2["Temp"] = 2] = "Temp";
  InternalTextureSource2[InternalTextureSource2["Raw"] = 3] = "Raw";
  InternalTextureSource2[InternalTextureSource2["Dynamic"] = 4] = "Dynamic";
  InternalTextureSource2[InternalTextureSource2["RenderTarget"] = 5] = "RenderTarget";
  InternalTextureSource2[InternalTextureSource2["MultiRenderTarget"] = 6] = "MultiRenderTarget";
  InternalTextureSource2[InternalTextureSource2["Cube"] = 7] = "Cube";
  InternalTextureSource2[InternalTextureSource2["CubeRaw"] = 8] = "CubeRaw";
  InternalTextureSource2[InternalTextureSource2["CubePrefiltered"] = 9] = "CubePrefiltered";
  InternalTextureSource2[InternalTextureSource2["Raw3D"] = 10] = "Raw3D";
  InternalTextureSource2[InternalTextureSource2["Raw2DArray"] = 11] = "Raw2DArray";
  InternalTextureSource2[InternalTextureSource2["Depth"] = 12] = "Depth";
  InternalTextureSource2[InternalTextureSource2["CubeRawRGBD"] = 13] = "CubeRawRGBD";
})(InternalTextureSource || (InternalTextureSource = {}));
var InternalTexture = function() {
  function InternalTexture2(engine, source, delayAllocation) {
    if (delayAllocation === void 0) {
      delayAllocation = false;
    }
    this.isReady = false;
    this.isCube = false;
    this.is3D = false;
    this.is2DArray = false;
    this.isMultiview = false;
    this.url = "";
    this.samplingMode = -1;
    this.generateMipMaps = false;
    this.samples = 0;
    this.type = -1;
    this.format = -1;
    this.onLoadedObservable = new Observable();
    this.width = 0;
    this.height = 0;
    this.depth = 0;
    this.baseWidth = 0;
    this.baseHeight = 0;
    this.baseDepth = 0;
    this.invertY = false;
    this._invertVScale = false;
    this._associatedChannel = -1;
    this._source = InternalTextureSource.Unknown;
    this._buffer = null;
    this._bufferView = null;
    this._bufferViewArray = null;
    this._bufferViewArrayArray = null;
    this._size = 0;
    this._extension = "";
    this._files = null;
    this._workingCanvas = null;
    this._workingContext = null;
    this._framebuffer = null;
    this._depthStencilBuffer = null;
    this._MSAAFramebuffer = null;
    this._MSAARenderBuffer = null;
    this._attachments = null;
    this._textureArray = null;
    this._cachedCoordinatesMode = null;
    this._cachedWrapU = null;
    this._cachedWrapV = null;
    this._cachedWrapR = null;
    this._cachedAnisotropicFilteringLevel = null;
    this._isDisabled = false;
    this._compression = null;
    this._generateStencilBuffer = false;
    this._generateDepthBuffer = false;
    this._comparisonFunction = 0;
    this._sphericalPolynomial = null;
    this._lodGenerationScale = 0;
    this._lodGenerationOffset = 0;
    this._colorTextureArray = null;
    this._depthStencilTextureArray = null;
    this._lodTextureHigh = null;
    this._lodTextureMid = null;
    this._lodTextureLow = null;
    this._isRGBD = false;
    this._linearSpecularLOD = false;
    this._irradianceTexture = null;
    this._webGLTexture = null;
    this._references = 1;
    this._gammaSpace = null;
    this._engine = engine;
    this._source = source;
    if (!delayAllocation) {
      this._webGLTexture = engine._createTexture();
    }
  }
  InternalTexture2.prototype.getEngine = function() {
    return this._engine;
  };
  Object.defineProperty(InternalTexture2.prototype, "source", {
    get: function() {
      return this._source;
    },
    enumerable: false,
    configurable: true
  });
  InternalTexture2.prototype.incrementReferences = function() {
    this._references++;
  };
  InternalTexture2.prototype.updateSize = function(width, height, depth) {
    if (depth === void 0) {
      depth = 1;
    }
    this.width = width;
    this.height = height;
    this.depth = depth;
    this.baseWidth = width;
    this.baseHeight = height;
    this.baseDepth = depth;
    this._size = width * height * depth;
  };
  InternalTexture2.prototype._rebuild = function() {
    var _this = this;
    var _a;
    var proxy;
    this.isReady = false;
    this._cachedCoordinatesMode = null;
    this._cachedWrapU = null;
    this._cachedWrapV = null;
    this._cachedAnisotropicFilteringLevel = null;
    switch (this.source) {
      case InternalTextureSource.Temp:
        return;
      case InternalTextureSource.Url:
        proxy = this._engine.createTexture((_a = this._originalUrl) !== null && _a !== void 0 ? _a : this.url, !this.generateMipMaps, this.invertY, null, this.samplingMode, function() {
          proxy._swapAndDie(_this);
          _this.isReady = true;
        }, null, this._buffer, void 0, this.format);
        return;
      case InternalTextureSource.Raw:
        proxy = this._engine.createRawTexture(this._bufferView, this.baseWidth, this.baseHeight, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression);
        proxy._swapAndDie(this);
        this.isReady = true;
        return;
      case InternalTextureSource.Raw3D:
        proxy = this._engine.createRawTexture3D(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression);
        proxy._swapAndDie(this);
        this.isReady = true;
        return;
      case InternalTextureSource.Raw2DArray:
        proxy = this._engine.createRawTexture2DArray(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression);
        proxy._swapAndDie(this);
        this.isReady = true;
        return;
      case InternalTextureSource.Dynamic:
        proxy = this._engine.createDynamicTexture(this.baseWidth, this.baseHeight, this.generateMipMaps, this.samplingMode);
        proxy._swapAndDie(this);
        this._engine.updateDynamicTexture(this, this._engine.getRenderingCanvas(), this.invertY, void 0, void 0, true);
        return;
      case InternalTextureSource.RenderTarget:
        var options = new RenderTargetCreationOptions();
        options.generateDepthBuffer = this._generateDepthBuffer;
        options.generateMipMaps = this.generateMipMaps;
        options.generateStencilBuffer = this._generateStencilBuffer;
        options.samplingMode = this.samplingMode;
        options.type = this.type;
        if (this.isCube) {
          proxy = this._engine.createRenderTargetCubeTexture(this.width, options);
        } else {
          var size_1 = {
            width: this.width,
            height: this.height,
            layers: this.is2DArray ? this.depth : void 0
          };
          proxy = this._engine.createRenderTargetTexture(size_1, options);
        }
        proxy._swapAndDie(this);
        this.isReady = true;
        return;
      case InternalTextureSource.Depth:
        var depthTextureOptions = {
          bilinearFiltering: this.samplingMode !== 2,
          comparisonFunction: this._comparisonFunction,
          generateStencil: this._generateStencilBuffer,
          isCube: this.isCube
        };
        var size = {
          width: this.width,
          height: this.height,
          layers: this.is2DArray ? this.depth : void 0
        };
        proxy = this._engine.createDepthStencilTexture(size, depthTextureOptions);
        proxy._swapAndDie(this);
        this.isReady = true;
        return;
      case InternalTextureSource.Cube:
        proxy = this._engine.createCubeTexture(this.url, null, this._files, !this.generateMipMaps, function() {
          proxy._swapAndDie(_this);
          _this.isReady = true;
        }, null, this.format, this._extension);
        return;
      case InternalTextureSource.CubeRaw:
        proxy = this._engine.createRawCubeTexture(this._bufferViewArray, this.width, this.format, this.type, this.generateMipMaps, this.invertY, this.samplingMode, this._compression);
        proxy._swapAndDie(this);
        this.isReady = true;
        return;
      case InternalTextureSource.CubeRawRGBD:
        proxy = this._engine.createRawCubeTexture(null, this.width, this.format, this.type, this.generateMipMaps, this.invertY, this.samplingMode, this._compression);
        InternalTexture2._UpdateRGBDAsync(proxy, this._bufferViewArrayArray, this._sphericalPolynomial, this._lodGenerationScale, this._lodGenerationOffset).then(function() {
          proxy._swapAndDie(_this);
          _this.isReady = true;
        });
        return;
      case InternalTextureSource.CubePrefiltered:
        proxy = this._engine.createPrefilteredCubeTexture(this.url, null, this._lodGenerationScale, this._lodGenerationOffset, function(proxy2) {
          if (proxy2) {
            proxy2._swapAndDie(_this);
          }
          _this.isReady = true;
        }, null, this.format, this._extension);
        proxy._sphericalPolynomial = this._sphericalPolynomial;
        return;
    }
  };
  InternalTexture2.prototype._swapAndDie = function(target) {
    target._webGLTexture = this._webGLTexture;
    target._isRGBD = this._isRGBD;
    if (this._framebuffer) {
      target._framebuffer = this._framebuffer;
    }
    if (this._depthStencilBuffer) {
      target._depthStencilBuffer = this._depthStencilBuffer;
    }
    target._depthStencilTexture = this._depthStencilTexture;
    if (this._lodTextureHigh) {
      if (target._lodTextureHigh) {
        target._lodTextureHigh.dispose();
      }
      target._lodTextureHigh = this._lodTextureHigh;
    }
    if (this._lodTextureMid) {
      if (target._lodTextureMid) {
        target._lodTextureMid.dispose();
      }
      target._lodTextureMid = this._lodTextureMid;
    }
    if (this._lodTextureLow) {
      if (target._lodTextureLow) {
        target._lodTextureLow.dispose();
      }
      target._lodTextureLow = this._lodTextureLow;
    }
    if (this._irradianceTexture) {
      if (target._irradianceTexture) {
        target._irradianceTexture.dispose();
      }
      target._irradianceTexture = this._irradianceTexture;
    }
    var cache = this._engine.getLoadedTexturesCache();
    var index = cache.indexOf(this);
    if (index !== -1) {
      cache.splice(index, 1);
    }
    var index = cache.indexOf(target);
    if (index === -1) {
      cache.push(target);
    }
  };
  InternalTexture2.prototype.dispose = function() {
    if (!this._webGLTexture) {
      return;
    }
    this._references--;
    if (this._references === 0) {
      this._engine._releaseTexture(this);
      this._webGLTexture = null;
    }
  };
  InternalTexture2._UpdateRGBDAsync = function(internalTexture, data, sphericalPolynomial, lodScale, lodOffset) {
    throw _DevTools.WarnImport("environmentTextureTools");
  };
  return InternalTexture2;
}();

// node_modules/@babylonjs/core/Engines/WebGL/webGL2ShaderProcessors.js
var WebGL2ShaderProcessor = function() {
  function WebGL2ShaderProcessor2() {
  }
  WebGL2ShaderProcessor2.prototype.attributeProcessor = function(attribute) {
    return attribute.replace("attribute", "in");
  };
  WebGL2ShaderProcessor2.prototype.varyingProcessor = function(varying, isFragment) {
    return varying.replace("varying", isFragment ? "in" : "out");
  };
  WebGL2ShaderProcessor2.prototype.postProcessor = function(code, defines, isFragment) {
    var hasDrawBuffersExtension = code.search(/#extension.+GL_EXT_draw_buffers.+require/) !== -1;
    var regex = /#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;
    code = code.replace(regex, "");
    code = code.replace(/texture2D\s*\(/g, "texture(");
    if (isFragment) {
      code = code.replace(/texture2DLodEXT\s*\(/g, "textureLod(");
      code = code.replace(/textureCubeLodEXT\s*\(/g, "textureLod(");
      code = code.replace(/textureCube\s*\(/g, "texture(");
      code = code.replace(/gl_FragDepthEXT/g, "gl_FragDepth");
      code = code.replace(/gl_FragColor/g, "glFragColor");
      code = code.replace(/gl_FragData/g, "glFragData");
      code = code.replace(/void\s+?main\s*\(/g, (hasDrawBuffersExtension ? "" : "out vec4 glFragColor;\n") + "void main(");
    } else {
      var hasMultiviewExtension = defines.indexOf("#define MULTIVIEW") !== -1;
      if (hasMultiviewExtension) {
        return "#extension GL_OVR_multiview2 : require\nlayout (num_views = 2) in;\n" + code;
      }
    }
    return code;
  };
  return WebGL2ShaderProcessor2;
}();

// node_modules/@babylonjs/core/Meshes/dataBuffer.js
var DataBuffer = function() {
  function DataBuffer2() {
    this.references = 0;
    this.capacity = 0;
    this.is32Bits = false;
  }
  Object.defineProperty(DataBuffer2.prototype, "underlyingResource", {
    get: function() {
      return null;
    },
    enumerable: false,
    configurable: true
  });
  return DataBuffer2;
}();

// node_modules/@babylonjs/core/Meshes/WebGL/webGLDataBuffer.js
var WebGLDataBuffer = function(_super) {
  __extends(WebGLDataBuffer2, _super);
  function WebGLDataBuffer2(resource) {
    var _this = _super.call(this) || this;
    _this._buffer = resource;
    return _this;
  }
  Object.defineProperty(WebGLDataBuffer2.prototype, "underlyingResource", {
    get: function() {
      return this._buffer;
    },
    enumerable: false,
    configurable: true
  });
  return WebGLDataBuffer2;
}(DataBuffer);

// node_modules/@babylonjs/core/Engines/WebGL/webGLPipelineContext.js
var WebGLPipelineContext = function() {
  function WebGLPipelineContext2() {
    this.vertexCompilationError = null;
    this.fragmentCompilationError = null;
    this.programLinkError = null;
    this.programValidationError = null;
  }
  Object.defineProperty(WebGLPipelineContext2.prototype, "isAsync", {
    get: function() {
      return this.isParallelCompiled;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebGLPipelineContext2.prototype, "isReady", {
    get: function() {
      if (this.program) {
        if (this.isParallelCompiled) {
          return this.engine._isRenderingStateCompiled(this);
        }
        return true;
      }
      return false;
    },
    enumerable: false,
    configurable: true
  });
  WebGLPipelineContext2.prototype._handlesSpectorRebuildCallback = function(onCompiled) {
    if (onCompiled && this.program) {
      onCompiled(this.program);
    }
  };
  WebGLPipelineContext2.prototype._getVertexShaderCode = function() {
    return this.vertexShader ? this.engine._getShaderSource(this.vertexShader) : null;
  };
  WebGLPipelineContext2.prototype._getFragmentShaderCode = function() {
    return this.fragmentShader ? this.engine._getShaderSource(this.fragmentShader) : null;
  };
  return WebGLPipelineContext2;
}();

// node_modules/@babylonjs/core/Misc/canvasGenerator.js
var CanvasGenerator = function() {
  function CanvasGenerator2() {
  }
  CanvasGenerator2.CreateCanvas = function(width, height) {
    if (typeof document === "undefined") {
      return new OffscreenCanvas(width, height);
    }
    var canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
  };
  return CanvasGenerator2;
}();

// node_modules/@babylonjs/core/Engines/WebGL/webGLShaderProcessors.js
var WebGLShaderProcessor = function() {
  function WebGLShaderProcessor2() {
  }
  WebGLShaderProcessor2.prototype.postProcessor = function(code, defines, isFragment, engine) {
    if (!engine.getCaps().drawBuffersExtension) {
      var regex = /#extension.+GL_EXT_draw_buffers.+(enable|require)/g;
      code = code.replace(regex, "");
    }
    return code;
  };
  return WebGLShaderProcessor2;
}();

// node_modules/@babylonjs/core/Engines/thinEngine.js
var BufferPointer = function() {
  function BufferPointer2() {
  }
  return BufferPointer2;
}();
var ThinEngine = function() {
  function ThinEngine2(canvasOrContext, antialias, options, adaptToDeviceRatio) {
    var _this = this;
    if (adaptToDeviceRatio === void 0) {
      adaptToDeviceRatio = false;
    }
    this.forcePOTTextures = false;
    this.isFullscreen = false;
    this.cullBackFaces = true;
    this.renderEvenInBackground = true;
    this.preventCacheWipeBetweenFrames = false;
    this.validateShaderPrograms = false;
    this.useReverseDepthBuffer = false;
    this.disableUniformBuffers = false;
    this._uniformBuffers = new Array();
    this._webGLVersion = 1;
    this._windowIsBackground = false;
    this._highPrecisionShadersAllowed = true;
    this._badOS = false;
    this._badDesktopOS = false;
    this._renderingQueueLaunched = false;
    this._activeRenderLoops = new Array();
    this.onContextLostObservable = new Observable();
    this.onContextRestoredObservable = new Observable();
    this._contextWasLost = false;
    this._doNotHandleContextLost = false;
    this.disableVertexArrayObjects = false;
    this._colorWrite = true;
    this._colorWriteChanged = true;
    this._depthCullingState = new DepthCullingState();
    this._stencilState = new StencilState();
    this._alphaState = new AlphaState();
    this._alphaMode = 1;
    this._alphaEquation = 0;
    this._internalTexturesCache = new Array();
    this._activeChannel = 0;
    this._currentTextureChannel = -1;
    this._boundTexturesCache = {};
    this._compiledEffects = {};
    this._vertexAttribArraysEnabled = [];
    this._uintIndicesCurrentlySet = false;
    this._currentBoundBuffer = new Array();
    this._currentFramebuffer = null;
    this._dummyFramebuffer = null;
    this._currentBufferPointers = new Array();
    this._currentInstanceLocations = new Array();
    this._currentInstanceBuffers = new Array();
    this._vaoRecordInProgress = false;
    this._mustWipeVertexAttributes = false;
    this._nextFreeTextureSlots = new Array();
    this._maxSimultaneousTextures = 0;
    this._activeRequests = new Array();
    this._transformTextureUrl = null;
    this.hostInformation = {
      isMobile: false
    };
    this.premultipliedAlpha = true;
    this.onBeforeTextureInitObservable = new Observable();
    this._viewportCached = { x: 0, y: 0, z: 0, w: 0 };
    this._unpackFlipYCached = null;
    this.enableUnpackFlipYCached = true;
    this._getDepthStencilBuffer = function(width, height, samples, internalFormat, msInternalFormat, attachment) {
      var gl = _this._gl;
      var depthStencilBuffer = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, depthStencilBuffer);
      if (samples > 1 && gl.renderbufferStorageMultisample) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, msInternalFormat, width, height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, width, height);
      }
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, depthStencilBuffer);
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      return depthStencilBuffer;
    };
    this._boundUniforms = {};
    var canvas = null;
    if (!canvasOrContext) {
      return;
    }
    options = options || {};
    PerformanceConfigurator.SetMatrixPrecision(!!options.useHighPrecisionMatrix);
    if (canvasOrContext.getContext) {
      canvas = canvasOrContext;
      this._renderingCanvas = canvas;
      if (antialias != null) {
        options.antialias = antialias;
      }
      if (options.deterministicLockstep === void 0) {
        options.deterministicLockstep = false;
      }
      if (options.lockstepMaxSteps === void 0) {
        options.lockstepMaxSteps = 4;
      }
      if (options.timeStep === void 0) {
        options.timeStep = 1 / 60;
      }
      if (options.preserveDrawingBuffer === void 0) {
        options.preserveDrawingBuffer = false;
      }
      if (options.audioEngine === void 0) {
        options.audioEngine = true;
      }
      if (options.stencil === void 0) {
        options.stencil = true;
      }
      if (options.premultipliedAlpha === false) {
        this.premultipliedAlpha = false;
      }
      if (options.xrCompatible === void 0) {
        options.xrCompatible = true;
      }
      this._doNotHandleContextLost = options.doNotHandleContextLost ? true : false;
      if (navigator && navigator.userAgent) {
        var ua = navigator.userAgent;
        this.hostInformation.isMobile = ua.indexOf("Mobile") !== -1;
        for (var _i = 0, _a = ThinEngine2.ExceptionList; _i < _a.length; _i++) {
          var exception = _a[_i];
          var key = exception.key;
          var targets = exception.targets;
          var check = new RegExp(key);
          if (check.test(ua)) {
            if (exception.capture && exception.captureConstraint) {
              var capture = exception.capture;
              var constraint = exception.captureConstraint;
              var regex = new RegExp(capture);
              var matches = regex.exec(ua);
              if (matches && matches.length > 0) {
                var capturedValue = parseInt(matches[matches.length - 1]);
                if (capturedValue >= constraint) {
                  continue;
                }
              }
            }
            for (var _b = 0, targets_1 = targets; _b < targets_1.length; _b++) {
              var target = targets_1[_b];
              switch (target) {
                case "uniformBuffer":
                  this.disableUniformBuffers = true;
                  break;
                case "vao":
                  this.disableVertexArrayObjects = true;
                  break;
              }
            }
          }
        }
      }
      if (!this._doNotHandleContextLost) {
        this._onContextLost = function(evt) {
          evt.preventDefault();
          _this._contextWasLost = true;
          Logger.Warn("WebGL context lost.");
          _this.onContextLostObservable.notifyObservers(_this);
        };
        this._onContextRestored = function() {
          setTimeout(function() {
            _this._initGLContext();
            _this._rebuildEffects();
            _this._rebuildInternalTextures();
            _this._rebuildBuffers();
            _this.wipeCaches(true);
            Logger.Warn("WebGL context successfully restored.");
            _this.onContextRestoredObservable.notifyObservers(_this);
            _this._contextWasLost = false;
          }, 0);
        };
        canvas.addEventListener("webglcontextlost", this._onContextLost, false);
        canvas.addEventListener("webglcontextrestored", this._onContextRestored, false);
        options.powerPreference = "high-performance";
      }
      if (!options.disableWebGL2Support) {
        try {
          this._gl = canvas.getContext("webgl2", options) || canvas.getContext("experimental-webgl2", options);
          if (this._gl) {
            this._webGLVersion = 2;
            if (!this._gl.deleteQuery) {
              this._webGLVersion = 1;
            }
          }
        } catch (e) {
        }
      }
      if (!this._gl) {
        if (!canvas) {
          throw new Error("The provided canvas is null or undefined.");
        }
        try {
          this._gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
        } catch (e) {
          throw new Error("WebGL not supported");
        }
      }
      if (!this._gl) {
        throw new Error("WebGL not supported");
      }
    } else {
      this._gl = canvasOrContext;
      this._renderingCanvas = this._gl.canvas;
      if (this._gl.renderbufferStorageMultisample) {
        this._webGLVersion = 2;
      }
      var attributes = this._gl.getContextAttributes();
      if (attributes) {
        options.stencil = attributes.stencil;
      }
    }
    this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE);
    if (options.useHighPrecisionFloats !== void 0) {
      this._highPrecisionShadersAllowed = options.useHighPrecisionFloats;
    }
    var devicePixelRatio = DomManagement.IsWindowObjectExist() ? window.devicePixelRatio || 1 : 1;
    var limitDeviceRatio = options.limitDeviceRatio || devicePixelRatio;
    this._hardwareScalingLevel = adaptToDeviceRatio ? 1 / Math.min(limitDeviceRatio, devicePixelRatio) : 1;
    this.resize();
    this._isStencilEnable = options.stencil ? true : false;
    this._initGLContext();
    for (var i = 0; i < this._caps.maxVertexAttribs; i++) {
      this._currentBufferPointers[i] = new BufferPointer();
    }
    if (this.webGLVersion > 1) {
      this._shaderProcessor = new WebGL2ShaderProcessor();
    } else {
      this._shaderProcessor = new WebGLShaderProcessor();
    }
    this._badOS = /iPad/i.test(navigator.userAgent) || /iPhone/i.test(navigator.userAgent);
    this._badDesktopOS = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    this._creationOptions = options;
    console.log("Babylon.js v" + ThinEngine2.Version + " - " + this.description);
  }
  Object.defineProperty(ThinEngine2, "NpmPackage", {
    get: function() {
      return "babylonjs@4.2.2";
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2, "Version", {
    get: function() {
      return "4.2.2";
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "description", {
    get: function() {
      var description = "WebGL" + this.webGLVersion;
      if (this._caps.parallelShaderCompile) {
        description += " - Parallel shader compilation";
      }
      return description;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2, "ShadersRepository", {
    get: function() {
      return Effect.ShadersRepository;
    },
    set: function(value) {
      Effect.ShadersRepository = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "supportsUniformBuffers", {
    get: function() {
      return this.webGLVersion > 1 && !this.disableUniformBuffers;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "_shouldUseHighPrecisionShader", {
    get: function() {
      return !!(this._caps.highPrecisionShaderSupported && this._highPrecisionShadersAllowed);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "needPOTTextures", {
    get: function() {
      return this._webGLVersion < 2 || this.forcePOTTextures;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "doNotHandleContextLost", {
    get: function() {
      return this._doNotHandleContextLost;
    },
    set: function(value) {
      this._doNotHandleContextLost = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "_supportsHardwareTextureRescaling", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "framebufferDimensionsObject", {
    set: function(dimensions) {
      this._framebufferDimensionsObject = dimensions;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "currentViewport", {
    get: function() {
      return this._cachedViewport;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "emptyTexture", {
    get: function() {
      if (!this._emptyTexture) {
        this._emptyTexture = this.createRawTexture(new Uint8Array(4), 1, 1, 5, false, false, 1);
      }
      return this._emptyTexture;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "emptyTexture3D", {
    get: function() {
      if (!this._emptyTexture3D) {
        this._emptyTexture3D = this.createRawTexture3D(new Uint8Array(4), 1, 1, 1, 5, false, false, 1);
      }
      return this._emptyTexture3D;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "emptyTexture2DArray", {
    get: function() {
      if (!this._emptyTexture2DArray) {
        this._emptyTexture2DArray = this.createRawTexture2DArray(new Uint8Array(4), 1, 1, 1, 5, false, false, 1);
      }
      return this._emptyTexture2DArray;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "emptyCubeTexture", {
    get: function() {
      if (!this._emptyCubeTexture) {
        var faceData = new Uint8Array(4);
        var cubeData = [faceData, faceData, faceData, faceData, faceData, faceData];
        this._emptyCubeTexture = this.createRawCubeTexture(cubeData, 1, 5, 0, false, false, 1);
      }
      return this._emptyCubeTexture;
    },
    enumerable: false,
    configurable: true
  });
  ThinEngine2.prototype._rebuildInternalTextures = function() {
    var currentState = this._internalTexturesCache.slice();
    for (var _i = 0, currentState_1 = currentState; _i < currentState_1.length; _i++) {
      var internalTexture = currentState_1[_i];
      internalTexture._rebuild();
    }
  };
  ThinEngine2.prototype._rebuildEffects = function() {
    for (var key in this._compiledEffects) {
      var effect = this._compiledEffects[key];
      effect._prepareEffect();
    }
    Effect.ResetCache();
  };
  ThinEngine2.prototype.areAllEffectsReady = function() {
    for (var key in this._compiledEffects) {
      var effect = this._compiledEffects[key];
      if (!effect.isReady()) {
        return false;
      }
    }
    return true;
  };
  ThinEngine2.prototype._rebuildBuffers = function() {
    for (var _i = 0, _a = this._uniformBuffers; _i < _a.length; _i++) {
      var uniformBuffer = _a[_i];
      uniformBuffer._rebuild();
    }
  };
  ThinEngine2.prototype._initGLContext = function() {
    this._caps = {
      maxTexturesImageUnits: this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS),
      maxCombinedTexturesImageUnits: this._gl.getParameter(this._gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
      maxVertexTextureImageUnits: this._gl.getParameter(this._gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
      maxTextureSize: this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE),
      maxSamples: this._webGLVersion > 1 ? this._gl.getParameter(this._gl.MAX_SAMPLES) : 1,
      maxCubemapTextureSize: this._gl.getParameter(this._gl.MAX_CUBE_MAP_TEXTURE_SIZE),
      maxRenderTextureSize: this._gl.getParameter(this._gl.MAX_RENDERBUFFER_SIZE),
      maxVertexAttribs: this._gl.getParameter(this._gl.MAX_VERTEX_ATTRIBS),
      maxVaryingVectors: this._gl.getParameter(this._gl.MAX_VARYING_VECTORS),
      maxFragmentUniformVectors: this._gl.getParameter(this._gl.MAX_FRAGMENT_UNIFORM_VECTORS),
      maxVertexUniformVectors: this._gl.getParameter(this._gl.MAX_VERTEX_UNIFORM_VECTORS),
      parallelShaderCompile: this._gl.getExtension("KHR_parallel_shader_compile"),
      standardDerivatives: this._webGLVersion > 1 || this._gl.getExtension("OES_standard_derivatives") !== null,
      maxAnisotropy: 1,
      astc: this._gl.getExtension("WEBGL_compressed_texture_astc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_astc"),
      bptc: this._gl.getExtension("EXT_texture_compression_bptc") || this._gl.getExtension("WEBKIT_EXT_texture_compression_bptc"),
      s3tc: this._gl.getExtension("WEBGL_compressed_texture_s3tc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"),
      pvrtc: this._gl.getExtension("WEBGL_compressed_texture_pvrtc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      etc1: this._gl.getExtension("WEBGL_compressed_texture_etc1") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc1"),
      etc2: this._gl.getExtension("WEBGL_compressed_texture_etc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc") || this._gl.getExtension("WEBGL_compressed_texture_es3_0"),
      textureAnisotropicFilterExtension: this._gl.getExtension("EXT_texture_filter_anisotropic") || this._gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic") || this._gl.getExtension("MOZ_EXT_texture_filter_anisotropic"),
      uintIndices: this._webGLVersion > 1 || this._gl.getExtension("OES_element_index_uint") !== null,
      fragmentDepthSupported: this._webGLVersion > 1 || this._gl.getExtension("EXT_frag_depth") !== null,
      highPrecisionShaderSupported: false,
      timerQuery: this._gl.getExtension("EXT_disjoint_timer_query_webgl2") || this._gl.getExtension("EXT_disjoint_timer_query"),
      canUseTimestampForTimerQuery: false,
      drawBuffersExtension: false,
      maxMSAASamples: 1,
      colorBufferFloat: this._webGLVersion > 1 && this._gl.getExtension("EXT_color_buffer_float"),
      textureFloat: this._webGLVersion > 1 || this._gl.getExtension("OES_texture_float") ? true : false,
      textureHalfFloat: this._webGLVersion > 1 || this._gl.getExtension("OES_texture_half_float") ? true : false,
      textureHalfFloatRender: false,
      textureFloatLinearFiltering: false,
      textureFloatRender: false,
      textureHalfFloatLinearFiltering: false,
      vertexArrayObject: false,
      instancedArrays: false,
      textureLOD: this._webGLVersion > 1 || this._gl.getExtension("EXT_shader_texture_lod") ? true : false,
      blendMinMax: false,
      multiview: this._gl.getExtension("OVR_multiview2"),
      oculusMultiview: this._gl.getExtension("OCULUS_multiview"),
      depthTextureExtension: false
    };
    this._glVersion = this._gl.getParameter(this._gl.VERSION);
    var rendererInfo = this._gl.getExtension("WEBGL_debug_renderer_info");
    if (rendererInfo != null) {
      this._glRenderer = this._gl.getParameter(rendererInfo.UNMASKED_RENDERER_WEBGL);
      this._glVendor = this._gl.getParameter(rendererInfo.UNMASKED_VENDOR_WEBGL);
    }
    if (!this._glVendor) {
      this._glVendor = "Unknown vendor";
    }
    if (!this._glRenderer) {
      this._glRenderer = "Unknown renderer";
    }
    if (this._gl.HALF_FLOAT_OES !== 36193) {
      this._gl.HALF_FLOAT_OES = 36193;
    }
    if (this._gl.RGBA16F !== 34842) {
      this._gl.RGBA16F = 34842;
    }
    if (this._gl.RGBA32F !== 34836) {
      this._gl.RGBA32F = 34836;
    }
    if (this._gl.DEPTH24_STENCIL8 !== 35056) {
      this._gl.DEPTH24_STENCIL8 = 35056;
    }
    if (this._caps.timerQuery) {
      if (this._webGLVersion === 1) {
        this._gl.getQuery = this._caps.timerQuery.getQueryEXT.bind(this._caps.timerQuery);
      }
      this._caps.canUseTimestampForTimerQuery = this._gl.getQuery(this._caps.timerQuery.TIMESTAMP_EXT, this._caps.timerQuery.QUERY_COUNTER_BITS_EXT) > 0;
    }
    this._caps.maxAnisotropy = this._caps.textureAnisotropicFilterExtension ? this._gl.getParameter(this._caps.textureAnisotropicFilterExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
    this._caps.textureFloatLinearFiltering = this._caps.textureFloat && this._gl.getExtension("OES_texture_float_linear") ? true : false;
    this._caps.textureFloatRender = this._caps.textureFloat && this._canRenderToFloatFramebuffer() ? true : false;
    this._caps.textureHalfFloatLinearFiltering = this._webGLVersion > 1 || this._caps.textureHalfFloat && this._gl.getExtension("OES_texture_half_float_linear") ? true : false;
    if (this._webGLVersion > 1) {
      if (this._gl.HALF_FLOAT_OES !== 5131) {
        this._gl.HALF_FLOAT_OES = 5131;
      }
    }
    this._caps.textureHalfFloatRender = this._caps.textureHalfFloat && this._canRenderToHalfFloatFramebuffer();
    if (this._webGLVersion > 1) {
      this._caps.drawBuffersExtension = true;
      this._caps.maxMSAASamples = this._gl.getParameter(this._gl.MAX_SAMPLES);
    } else {
      var drawBuffersExtension = this._gl.getExtension("WEBGL_draw_buffers");
      if (drawBuffersExtension !== null) {
        this._caps.drawBuffersExtension = true;
        this._gl.drawBuffers = drawBuffersExtension.drawBuffersWEBGL.bind(drawBuffersExtension);
        this._gl.DRAW_FRAMEBUFFER = this._gl.FRAMEBUFFER;
        for (var i = 0; i < 16; i++) {
          this._gl["COLOR_ATTACHMENT" + i + "_WEBGL"] = drawBuffersExtension["COLOR_ATTACHMENT" + i + "_WEBGL"];
        }
      }
    }
    if (this._webGLVersion > 1) {
      this._caps.depthTextureExtension = true;
    } else {
      var depthTextureExtension = this._gl.getExtension("WEBGL_depth_texture");
      if (depthTextureExtension != null) {
        this._caps.depthTextureExtension = true;
        this._gl.UNSIGNED_INT_24_8 = depthTextureExtension.UNSIGNED_INT_24_8_WEBGL;
      }
    }
    if (this.disableVertexArrayObjects) {
      this._caps.vertexArrayObject = false;
    } else if (this._webGLVersion > 1) {
      this._caps.vertexArrayObject = true;
    } else {
      var vertexArrayObjectExtension = this._gl.getExtension("OES_vertex_array_object");
      if (vertexArrayObjectExtension != null) {
        this._caps.vertexArrayObject = true;
        this._gl.createVertexArray = vertexArrayObjectExtension.createVertexArrayOES.bind(vertexArrayObjectExtension);
        this._gl.bindVertexArray = vertexArrayObjectExtension.bindVertexArrayOES.bind(vertexArrayObjectExtension);
        this._gl.deleteVertexArray = vertexArrayObjectExtension.deleteVertexArrayOES.bind(vertexArrayObjectExtension);
      }
    }
    if (this._webGLVersion > 1) {
      this._caps.instancedArrays = true;
    } else {
      var instanceExtension = this._gl.getExtension("ANGLE_instanced_arrays");
      if (instanceExtension != null) {
        this._caps.instancedArrays = true;
        this._gl.drawArraysInstanced = instanceExtension.drawArraysInstancedANGLE.bind(instanceExtension);
        this._gl.drawElementsInstanced = instanceExtension.drawElementsInstancedANGLE.bind(instanceExtension);
        this._gl.vertexAttribDivisor = instanceExtension.vertexAttribDivisorANGLE.bind(instanceExtension);
      } else {
        this._caps.instancedArrays = false;
      }
    }
    if (this._gl.getShaderPrecisionFormat) {
      var vertex_highp = this._gl.getShaderPrecisionFormat(this._gl.VERTEX_SHADER, this._gl.HIGH_FLOAT);
      var fragment_highp = this._gl.getShaderPrecisionFormat(this._gl.FRAGMENT_SHADER, this._gl.HIGH_FLOAT);
      if (vertex_highp && fragment_highp) {
        this._caps.highPrecisionShaderSupported = vertex_highp.precision !== 0 && fragment_highp.precision !== 0;
      }
    }
    if (this._webGLVersion > 1) {
      this._caps.blendMinMax = true;
    } else {
      var blendMinMaxExtension = this._gl.getExtension("EXT_blend_minmax");
      if (blendMinMaxExtension != null) {
        this._caps.blendMinMax = true;
        this._gl.MAX = blendMinMaxExtension.MAX_EXT;
        this._gl.MIN = blendMinMaxExtension.MIN_EXT;
      }
    }
    this._depthCullingState.depthTest = true;
    this._depthCullingState.depthFunc = this._gl.LEQUAL;
    this._depthCullingState.depthMask = true;
    this._maxSimultaneousTextures = this._caps.maxCombinedTexturesImageUnits;
    for (var slot = 0; slot < this._maxSimultaneousTextures; slot++) {
      this._nextFreeTextureSlots.push(slot);
    }
  };
  Object.defineProperty(ThinEngine2.prototype, "webGLVersion", {
    get: function() {
      return this._webGLVersion;
    },
    enumerable: false,
    configurable: true
  });
  ThinEngine2.prototype.getClassName = function() {
    return "ThinEngine";
  };
  Object.defineProperty(ThinEngine2.prototype, "isStencilEnable", {
    get: function() {
      return this._isStencilEnable;
    },
    enumerable: false,
    configurable: true
  });
  ThinEngine2.prototype._prepareWorkingCanvas = function() {
    if (this._workingCanvas) {
      return;
    }
    this._workingCanvas = CanvasGenerator.CreateCanvas(1, 1);
    var context = this._workingCanvas.getContext("2d");
    if (context) {
      this._workingContext = context;
    }
  };
  ThinEngine2.prototype.resetTextureCache = function() {
    for (var key in this._boundTexturesCache) {
      if (!this._boundTexturesCache.hasOwnProperty(key)) {
        continue;
      }
      this._boundTexturesCache[key] = null;
    }
    this._currentTextureChannel = -1;
  };
  ThinEngine2.prototype.getGlInfo = function() {
    return {
      vendor: this._glVendor,
      renderer: this._glRenderer,
      version: this._glVersion
    };
  };
  ThinEngine2.prototype.setHardwareScalingLevel = function(level) {
    this._hardwareScalingLevel = level;
    this.resize();
  };
  ThinEngine2.prototype.getHardwareScalingLevel = function() {
    return this._hardwareScalingLevel;
  };
  ThinEngine2.prototype.getLoadedTexturesCache = function() {
    return this._internalTexturesCache;
  };
  ThinEngine2.prototype.getCaps = function() {
    return this._caps;
  };
  ThinEngine2.prototype.stopRenderLoop = function(renderFunction) {
    if (!renderFunction) {
      this._activeRenderLoops = [];
      return;
    }
    var index = this._activeRenderLoops.indexOf(renderFunction);
    if (index >= 0) {
      this._activeRenderLoops.splice(index, 1);
    }
  };
  ThinEngine2.prototype._renderLoop = function() {
    if (!this._contextWasLost) {
      var shouldRender = true;
      if (!this.renderEvenInBackground && this._windowIsBackground) {
        shouldRender = false;
      }
      if (shouldRender) {
        this.beginFrame();
        for (var index = 0; index < this._activeRenderLoops.length; index++) {
          var renderFunction = this._activeRenderLoops[index];
          renderFunction();
        }
        this.endFrame();
      }
    }
    if (this._activeRenderLoops.length > 0) {
      this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());
    } else {
      this._renderingQueueLaunched = false;
    }
  };
  ThinEngine2.prototype.getRenderingCanvas = function() {
    return this._renderingCanvas;
  };
  ThinEngine2.prototype.getHostWindow = function() {
    if (!DomManagement.IsWindowObjectExist()) {
      return null;
    }
    if (this._renderingCanvas && this._renderingCanvas.ownerDocument && this._renderingCanvas.ownerDocument.defaultView) {
      return this._renderingCanvas.ownerDocument.defaultView;
    }
    return window;
  };
  ThinEngine2.prototype.getRenderWidth = function(useScreen) {
    if (useScreen === void 0) {
      useScreen = false;
    }
    if (!useScreen && this._currentRenderTarget) {
      return this._currentRenderTarget.width;
    }
    return this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferWidth : this._gl.drawingBufferWidth;
  };
  ThinEngine2.prototype.getRenderHeight = function(useScreen) {
    if (useScreen === void 0) {
      useScreen = false;
    }
    if (!useScreen && this._currentRenderTarget) {
      return this._currentRenderTarget.height;
    }
    return this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferHeight : this._gl.drawingBufferHeight;
  };
  ThinEngine2.prototype._queueNewFrame = function(bindedRenderFunction, requester) {
    return ThinEngine2.QueueNewFrame(bindedRenderFunction, requester);
  };
  ThinEngine2.prototype.runRenderLoop = function(renderFunction) {
    if (this._activeRenderLoops.indexOf(renderFunction) !== -1) {
      return;
    }
    this._activeRenderLoops.push(renderFunction);
    if (!this._renderingQueueLaunched) {
      this._renderingQueueLaunched = true;
      this._boundRenderFunction = this._renderLoop.bind(this);
      this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());
    }
  };
  ThinEngine2.prototype.clear = function(color, backBuffer, depth, stencil) {
    if (stencil === void 0) {
      stencil = false;
    }
    this.applyStates();
    var mode = 0;
    if (backBuffer && color) {
      this._gl.clearColor(color.r, color.g, color.b, color.a !== void 0 ? color.a : 1);
      mode |= this._gl.COLOR_BUFFER_BIT;
    }
    if (depth) {
      if (this.useReverseDepthBuffer) {
        this._depthCullingState.depthFunc = this._gl.GREATER;
        this._gl.clearDepth(0);
      } else {
        this._gl.clearDepth(1);
      }
      mode |= this._gl.DEPTH_BUFFER_BIT;
    }
    if (stencil) {
      this._gl.clearStencil(0);
      mode |= this._gl.STENCIL_BUFFER_BIT;
    }
    this._gl.clear(mode);
  };
  ThinEngine2.prototype._viewport = function(x, y, width, height) {
    if (x !== this._viewportCached.x || y !== this._viewportCached.y || width !== this._viewportCached.z || height !== this._viewportCached.w) {
      this._viewportCached.x = x;
      this._viewportCached.y = y;
      this._viewportCached.z = width;
      this._viewportCached.w = height;
      this._gl.viewport(x, y, width, height);
    }
  };
  ThinEngine2.prototype.setViewport = function(viewport, requiredWidth, requiredHeight) {
    var width = requiredWidth || this.getRenderWidth();
    var height = requiredHeight || this.getRenderHeight();
    var x = viewport.x || 0;
    var y = viewport.y || 0;
    this._cachedViewport = viewport;
    this._viewport(x * width, y * height, width * viewport.width, height * viewport.height);
  };
  ThinEngine2.prototype.beginFrame = function() {
  };
  ThinEngine2.prototype.endFrame = function() {
    if (this._badOS) {
      this.flushFramebuffer();
    }
  };
  ThinEngine2.prototype.resize = function() {
    var width;
    var height;
    if (DomManagement.IsWindowObjectExist()) {
      width = this._renderingCanvas ? this._renderingCanvas.clientWidth || this._renderingCanvas.width : window.innerWidth;
      height = this._renderingCanvas ? this._renderingCanvas.clientHeight || this._renderingCanvas.height : window.innerHeight;
    } else {
      width = this._renderingCanvas ? this._renderingCanvas.width : 100;
      height = this._renderingCanvas ? this._renderingCanvas.height : 100;
    }
    this.setSize(width / this._hardwareScalingLevel, height / this._hardwareScalingLevel);
  };
  ThinEngine2.prototype.setSize = function(width, height) {
    if (!this._renderingCanvas) {
      return false;
    }
    width = width | 0;
    height = height | 0;
    if (this._renderingCanvas.width === width && this._renderingCanvas.height === height) {
      return false;
    }
    this._renderingCanvas.width = width;
    this._renderingCanvas.height = height;
    return true;
  };
  ThinEngine2.prototype.bindFramebuffer = function(texture, faceIndex, requiredWidth, requiredHeight, forceFullscreenViewport, lodLevel, layer) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lodLevel === void 0) {
      lodLevel = 0;
    }
    if (layer === void 0) {
      layer = 0;
    }
    if (this._currentRenderTarget) {
      this.unBindFramebuffer(this._currentRenderTarget);
    }
    this._currentRenderTarget = texture;
    this._bindUnboundFramebuffer(texture._MSAAFramebuffer ? texture._MSAAFramebuffer : texture._framebuffer);
    var gl = this._gl;
    if (texture.is2DArray) {
      gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, texture._webGLTexture, lodLevel, layer);
    } else if (texture.isCube) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, texture._webGLTexture, lodLevel);
    }
    var depthStencilTexture = texture._depthStencilTexture;
    if (depthStencilTexture) {
      var attachment = depthStencilTexture._generateStencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
      if (texture.is2DArray) {
        gl.framebufferTextureLayer(gl.FRAMEBUFFER, attachment, depthStencilTexture._webGLTexture, lodLevel, layer);
      } else if (texture.isCube) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, depthStencilTexture._webGLTexture, lodLevel);
      } else {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, depthStencilTexture._webGLTexture, lodLevel);
      }
    }
    if (this._cachedViewport && !forceFullscreenViewport) {
      this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);
    } else {
      if (!requiredWidth) {
        requiredWidth = texture.width;
        if (lodLevel) {
          requiredWidth = requiredWidth / Math.pow(2, lodLevel);
        }
      }
      if (!requiredHeight) {
        requiredHeight = texture.height;
        if (lodLevel) {
          requiredHeight = requiredHeight / Math.pow(2, lodLevel);
        }
      }
      this._viewport(0, 0, requiredWidth, requiredHeight);
    }
    this.wipeCaches();
  };
  ThinEngine2.prototype._bindUnboundFramebuffer = function(framebuffer) {
    if (this._currentFramebuffer !== framebuffer) {
      this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, framebuffer);
      this._currentFramebuffer = framebuffer;
    }
  };
  ThinEngine2.prototype.unBindFramebuffer = function(texture, disableGenerateMipMaps, onBeforeUnbind) {
    if (disableGenerateMipMaps === void 0) {
      disableGenerateMipMaps = false;
    }
    this._currentRenderTarget = null;
    var gl = this._gl;
    if (texture._MSAAFramebuffer) {
      if (texture._textureArray) {
        this.unBindMultiColorAttachmentFramebuffer(texture._textureArray, disableGenerateMipMaps, onBeforeUnbind);
        return;
      }
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, texture._MSAAFramebuffer);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, texture._framebuffer);
      gl.blitFramebuffer(0, 0, texture.width, texture.height, 0, 0, texture.width, texture.height, gl.COLOR_BUFFER_BIT, gl.NEAREST);
    }
    if (texture.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {
      this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);
      gl.generateMipmap(gl.TEXTURE_2D);
      this._bindTextureDirectly(gl.TEXTURE_2D, null);
    }
    if (onBeforeUnbind) {
      if (texture._MSAAFramebuffer) {
        this._bindUnboundFramebuffer(texture._framebuffer);
      }
      onBeforeUnbind();
    }
    this._bindUnboundFramebuffer(null);
  };
  ThinEngine2.prototype.flushFramebuffer = function() {
    this._gl.flush();
  };
  ThinEngine2.prototype.restoreDefaultFramebuffer = function() {
    if (this._currentRenderTarget) {
      this.unBindFramebuffer(this._currentRenderTarget);
    } else {
      this._bindUnboundFramebuffer(null);
    }
    if (this._cachedViewport) {
      this.setViewport(this._cachedViewport);
    }
    this.wipeCaches();
  };
  ThinEngine2.prototype._resetVertexBufferBinding = function() {
    this.bindArrayBuffer(null);
    this._cachedVertexBuffers = null;
  };
  ThinEngine2.prototype.createVertexBuffer = function(data) {
    return this._createVertexBuffer(data, this._gl.STATIC_DRAW);
  };
  ThinEngine2.prototype._createVertexBuffer = function(data, usage) {
    var vbo = this._gl.createBuffer();
    if (!vbo) {
      throw new Error("Unable to create vertex buffer");
    }
    var dataBuffer = new WebGLDataBuffer(vbo);
    this.bindArrayBuffer(dataBuffer);
    if (data instanceof Array) {
      this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(data), this._gl.STATIC_DRAW);
    } else {
      this._gl.bufferData(this._gl.ARRAY_BUFFER, data, this._gl.STATIC_DRAW);
    }
    this._resetVertexBufferBinding();
    dataBuffer.references = 1;
    return dataBuffer;
  };
  ThinEngine2.prototype.createDynamicVertexBuffer = function(data) {
    return this._createVertexBuffer(data, this._gl.DYNAMIC_DRAW);
  };
  ThinEngine2.prototype._resetIndexBufferBinding = function() {
    this.bindIndexBuffer(null);
    this._cachedIndexBuffer = null;
  };
  ThinEngine2.prototype.createIndexBuffer = function(indices, updatable) {
    var vbo = this._gl.createBuffer();
    var dataBuffer = new WebGLDataBuffer(vbo);
    if (!vbo) {
      throw new Error("Unable to create index buffer");
    }
    this.bindIndexBuffer(dataBuffer);
    var data = this._normalizeIndexData(indices);
    this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, data, updatable ? this._gl.DYNAMIC_DRAW : this._gl.STATIC_DRAW);
    this._resetIndexBufferBinding();
    dataBuffer.references = 1;
    dataBuffer.is32Bits = data.BYTES_PER_ELEMENT === 4;
    return dataBuffer;
  };
  ThinEngine2.prototype._normalizeIndexData = function(indices) {
    if (indices instanceof Uint16Array) {
      return indices;
    }
    if (this._caps.uintIndices) {
      if (indices instanceof Uint32Array) {
        return indices;
      } else {
        for (var index = 0; index < indices.length; index++) {
          if (indices[index] >= 65535) {
            return new Uint32Array(indices);
          }
        }
        return new Uint16Array(indices);
      }
    }
    return new Uint16Array(indices);
  };
  ThinEngine2.prototype.bindArrayBuffer = function(buffer) {
    if (!this._vaoRecordInProgress) {
      this._unbindVertexArrayObject();
    }
    this.bindBuffer(buffer, this._gl.ARRAY_BUFFER);
  };
  ThinEngine2.prototype.bindUniformBlock = function(pipelineContext, blockName, index) {
    var program = pipelineContext.program;
    var uniformLocation = this._gl.getUniformBlockIndex(program, blockName);
    this._gl.uniformBlockBinding(program, uniformLocation, index);
  };
  ThinEngine2.prototype.bindIndexBuffer = function(buffer) {
    if (!this._vaoRecordInProgress) {
      this._unbindVertexArrayObject();
    }
    this.bindBuffer(buffer, this._gl.ELEMENT_ARRAY_BUFFER);
  };
  ThinEngine2.prototype.bindBuffer = function(buffer, target) {
    if (this._vaoRecordInProgress || this._currentBoundBuffer[target] !== buffer) {
      this._gl.bindBuffer(target, buffer ? buffer.underlyingResource : null);
      this._currentBoundBuffer[target] = buffer;
    }
  };
  ThinEngine2.prototype.updateArrayBuffer = function(data) {
    this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);
  };
  ThinEngine2.prototype._vertexAttribPointer = function(buffer, indx, size, type, normalized, stride, offset) {
    var pointer = this._currentBufferPointers[indx];
    if (!pointer) {
      return;
    }
    var changed = false;
    if (!pointer.active) {
      changed = true;
      pointer.active = true;
      pointer.index = indx;
      pointer.size = size;
      pointer.type = type;
      pointer.normalized = normalized;
      pointer.stride = stride;
      pointer.offset = offset;
      pointer.buffer = buffer;
    } else {
      if (pointer.buffer !== buffer) {
        pointer.buffer = buffer;
        changed = true;
      }
      if (pointer.size !== size) {
        pointer.size = size;
        changed = true;
      }
      if (pointer.type !== type) {
        pointer.type = type;
        changed = true;
      }
      if (pointer.normalized !== normalized) {
        pointer.normalized = normalized;
        changed = true;
      }
      if (pointer.stride !== stride) {
        pointer.stride = stride;
        changed = true;
      }
      if (pointer.offset !== offset) {
        pointer.offset = offset;
        changed = true;
      }
    }
    if (changed || this._vaoRecordInProgress) {
      this.bindArrayBuffer(buffer);
      this._gl.vertexAttribPointer(indx, size, type, normalized, stride, offset);
    }
  };
  ThinEngine2.prototype._bindIndexBufferWithCache = function(indexBuffer) {
    if (indexBuffer == null) {
      return;
    }
    if (this._cachedIndexBuffer !== indexBuffer) {
      this._cachedIndexBuffer = indexBuffer;
      this.bindIndexBuffer(indexBuffer);
      this._uintIndicesCurrentlySet = indexBuffer.is32Bits;
    }
  };
  ThinEngine2.prototype._bindVertexBuffersAttributes = function(vertexBuffers, effect) {
    var attributes = effect.getAttributesNames();
    if (!this._vaoRecordInProgress) {
      this._unbindVertexArrayObject();
    }
    this.unbindAllAttributes();
    for (var index = 0; index < attributes.length; index++) {
      var order = effect.getAttributeLocation(index);
      if (order >= 0) {
        var vertexBuffer = vertexBuffers[attributes[index]];
        if (!vertexBuffer) {
          continue;
        }
        this._gl.enableVertexAttribArray(order);
        if (!this._vaoRecordInProgress) {
          this._vertexAttribArraysEnabled[order] = true;
        }
        var buffer = vertexBuffer.getBuffer();
        if (buffer) {
          this._vertexAttribPointer(buffer, order, vertexBuffer.getSize(), vertexBuffer.type, vertexBuffer.normalized, vertexBuffer.byteStride, vertexBuffer.byteOffset);
          if (vertexBuffer.getIsInstanced()) {
            this._gl.vertexAttribDivisor(order, vertexBuffer.getInstanceDivisor());
            if (!this._vaoRecordInProgress) {
              this._currentInstanceLocations.push(order);
              this._currentInstanceBuffers.push(buffer);
            }
          }
        }
      }
    }
  };
  ThinEngine2.prototype.recordVertexArrayObject = function(vertexBuffers, indexBuffer, effect) {
    var vao = this._gl.createVertexArray();
    this._vaoRecordInProgress = true;
    this._gl.bindVertexArray(vao);
    this._mustWipeVertexAttributes = true;
    this._bindVertexBuffersAttributes(vertexBuffers, effect);
    this.bindIndexBuffer(indexBuffer);
    this._vaoRecordInProgress = false;
    this._gl.bindVertexArray(null);
    return vao;
  };
  ThinEngine2.prototype.bindVertexArrayObject = function(vertexArrayObject, indexBuffer) {
    if (this._cachedVertexArrayObject !== vertexArrayObject) {
      this._cachedVertexArrayObject = vertexArrayObject;
      this._gl.bindVertexArray(vertexArrayObject);
      this._cachedVertexBuffers = null;
      this._cachedIndexBuffer = null;
      this._uintIndicesCurrentlySet = indexBuffer != null && indexBuffer.is32Bits;
      this._mustWipeVertexAttributes = true;
    }
  };
  ThinEngine2.prototype.bindBuffersDirectly = function(vertexBuffer, indexBuffer, vertexDeclaration, vertexStrideSize, effect) {
    if (this._cachedVertexBuffers !== vertexBuffer || this._cachedEffectForVertexBuffers !== effect) {
      this._cachedVertexBuffers = vertexBuffer;
      this._cachedEffectForVertexBuffers = effect;
      var attributesCount = effect.getAttributesCount();
      this._unbindVertexArrayObject();
      this.unbindAllAttributes();
      var offset = 0;
      for (var index = 0; index < attributesCount; index++) {
        if (index < vertexDeclaration.length) {
          var order = effect.getAttributeLocation(index);
          if (order >= 0) {
            this._gl.enableVertexAttribArray(order);
            this._vertexAttribArraysEnabled[order] = true;
            this._vertexAttribPointer(vertexBuffer, order, vertexDeclaration[index], this._gl.FLOAT, false, vertexStrideSize, offset);
          }
          offset += vertexDeclaration[index] * 4;
        }
      }
    }
    this._bindIndexBufferWithCache(indexBuffer);
  };
  ThinEngine2.prototype._unbindVertexArrayObject = function() {
    if (!this._cachedVertexArrayObject) {
      return;
    }
    this._cachedVertexArrayObject = null;
    this._gl.bindVertexArray(null);
  };
  ThinEngine2.prototype.bindBuffers = function(vertexBuffers, indexBuffer, effect) {
    if (this._cachedVertexBuffers !== vertexBuffers || this._cachedEffectForVertexBuffers !== effect) {
      this._cachedVertexBuffers = vertexBuffers;
      this._cachedEffectForVertexBuffers = effect;
      this._bindVertexBuffersAttributes(vertexBuffers, effect);
    }
    this._bindIndexBufferWithCache(indexBuffer);
  };
  ThinEngine2.prototype.unbindInstanceAttributes = function() {
    var boundBuffer;
    for (var i = 0, ul = this._currentInstanceLocations.length; i < ul; i++) {
      var instancesBuffer = this._currentInstanceBuffers[i];
      if (boundBuffer != instancesBuffer && instancesBuffer.references) {
        boundBuffer = instancesBuffer;
        this.bindArrayBuffer(instancesBuffer);
      }
      var offsetLocation = this._currentInstanceLocations[i];
      this._gl.vertexAttribDivisor(offsetLocation, 0);
    }
    this._currentInstanceBuffers.length = 0;
    this._currentInstanceLocations.length = 0;
  };
  ThinEngine2.prototype.releaseVertexArrayObject = function(vao) {
    this._gl.deleteVertexArray(vao);
  };
  ThinEngine2.prototype._releaseBuffer = function(buffer) {
    buffer.references--;
    if (buffer.references === 0) {
      this._deleteBuffer(buffer);
      return true;
    }
    return false;
  };
  ThinEngine2.prototype._deleteBuffer = function(buffer) {
    this._gl.deleteBuffer(buffer.underlyingResource);
  };
  ThinEngine2.prototype.updateAndBindInstancesBuffer = function(instancesBuffer, data, offsetLocations) {
    this.bindArrayBuffer(instancesBuffer);
    if (data) {
      this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);
    }
    if (offsetLocations[0].index !== void 0) {
      this.bindInstancesBuffer(instancesBuffer, offsetLocations, true);
    } else {
      for (var index = 0; index < 4; index++) {
        var offsetLocation = offsetLocations[index];
        if (!this._vertexAttribArraysEnabled[offsetLocation]) {
          this._gl.enableVertexAttribArray(offsetLocation);
          this._vertexAttribArraysEnabled[offsetLocation] = true;
        }
        this._vertexAttribPointer(instancesBuffer, offsetLocation, 4, this._gl.FLOAT, false, 64, index * 16);
        this._gl.vertexAttribDivisor(offsetLocation, 1);
        this._currentInstanceLocations.push(offsetLocation);
        this._currentInstanceBuffers.push(instancesBuffer);
      }
    }
  };
  ThinEngine2.prototype.bindInstancesBuffer = function(instancesBuffer, attributesInfo, computeStride) {
    if (computeStride === void 0) {
      computeStride = true;
    }
    this.bindArrayBuffer(instancesBuffer);
    var stride = 0;
    if (computeStride) {
      for (var i = 0; i < attributesInfo.length; i++) {
        var ai = attributesInfo[i];
        stride += ai.attributeSize * 4;
      }
    }
    for (var i = 0; i < attributesInfo.length; i++) {
      var ai = attributesInfo[i];
      if (ai.index === void 0) {
        ai.index = this._currentEffect.getAttributeLocationByName(ai.attributeName);
      }
      if (ai.index < 0) {
        continue;
      }
      if (!this._vertexAttribArraysEnabled[ai.index]) {
        this._gl.enableVertexAttribArray(ai.index);
        this._vertexAttribArraysEnabled[ai.index] = true;
      }
      this._vertexAttribPointer(instancesBuffer, ai.index, ai.attributeSize, ai.attributeType || this._gl.FLOAT, ai.normalized || false, stride, ai.offset);
      this._gl.vertexAttribDivisor(ai.index, ai.divisor === void 0 ? 1 : ai.divisor);
      this._currentInstanceLocations.push(ai.index);
      this._currentInstanceBuffers.push(instancesBuffer);
    }
  };
  ThinEngine2.prototype.disableInstanceAttributeByName = function(name45) {
    if (!this._currentEffect) {
      return;
    }
    var attributeLocation = this._currentEffect.getAttributeLocationByName(name45);
    this.disableInstanceAttribute(attributeLocation);
  };
  ThinEngine2.prototype.disableInstanceAttribute = function(attributeLocation) {
    var shouldClean = false;
    var index;
    while ((index = this._currentInstanceLocations.indexOf(attributeLocation)) !== -1) {
      this._currentInstanceLocations.splice(index, 1);
      this._currentInstanceBuffers.splice(index, 1);
      shouldClean = true;
      index = this._currentInstanceLocations.indexOf(attributeLocation);
    }
    if (shouldClean) {
      this._gl.vertexAttribDivisor(attributeLocation, 0);
      this.disableAttributeByIndex(attributeLocation);
    }
  };
  ThinEngine2.prototype.disableAttributeByIndex = function(attributeLocation) {
    this._gl.disableVertexAttribArray(attributeLocation);
    this._vertexAttribArraysEnabled[attributeLocation] = false;
    this._currentBufferPointers[attributeLocation].active = false;
  };
  ThinEngine2.prototype.draw = function(useTriangles, indexStart, indexCount, instancesCount) {
    this.drawElementsType(useTriangles ? 0 : 1, indexStart, indexCount, instancesCount);
  };
  ThinEngine2.prototype.drawPointClouds = function(verticesStart, verticesCount, instancesCount) {
    this.drawArraysType(2, verticesStart, verticesCount, instancesCount);
  };
  ThinEngine2.prototype.drawUnIndexed = function(useTriangles, verticesStart, verticesCount, instancesCount) {
    this.drawArraysType(useTriangles ? 0 : 1, verticesStart, verticesCount, instancesCount);
  };
  ThinEngine2.prototype.drawElementsType = function(fillMode, indexStart, indexCount, instancesCount) {
    this.applyStates();
    this._reportDrawCall();
    var drawMode = this._drawMode(fillMode);
    var indexFormat = this._uintIndicesCurrentlySet ? this._gl.UNSIGNED_INT : this._gl.UNSIGNED_SHORT;
    var mult = this._uintIndicesCurrentlySet ? 4 : 2;
    if (instancesCount) {
      this._gl.drawElementsInstanced(drawMode, indexCount, indexFormat, indexStart * mult, instancesCount);
    } else {
      this._gl.drawElements(drawMode, indexCount, indexFormat, indexStart * mult);
    }
  };
  ThinEngine2.prototype.drawArraysType = function(fillMode, verticesStart, verticesCount, instancesCount) {
    this.applyStates();
    this._reportDrawCall();
    var drawMode = this._drawMode(fillMode);
    if (instancesCount) {
      this._gl.drawArraysInstanced(drawMode, verticesStart, verticesCount, instancesCount);
    } else {
      this._gl.drawArrays(drawMode, verticesStart, verticesCount);
    }
  };
  ThinEngine2.prototype._drawMode = function(fillMode) {
    switch (fillMode) {
      case 0:
        return this._gl.TRIANGLES;
      case 2:
        return this._gl.POINTS;
      case 1:
        return this._gl.LINES;
      case 3:
        return this._gl.POINTS;
      case 4:
        return this._gl.LINES;
      case 5:
        return this._gl.LINE_LOOP;
      case 6:
        return this._gl.LINE_STRIP;
      case 7:
        return this._gl.TRIANGLE_STRIP;
      case 8:
        return this._gl.TRIANGLE_FAN;
      default:
        return this._gl.TRIANGLES;
    }
  };
  ThinEngine2.prototype._reportDrawCall = function() {
  };
  ThinEngine2.prototype._releaseEffect = function(effect) {
    if (this._compiledEffects[effect._key]) {
      delete this._compiledEffects[effect._key];
      this._deletePipelineContext(effect.getPipelineContext());
    }
  };
  ThinEngine2.prototype._deletePipelineContext = function(pipelineContext) {
    var webGLPipelineContext = pipelineContext;
    if (webGLPipelineContext && webGLPipelineContext.program) {
      webGLPipelineContext.program.__SPECTOR_rebuildProgram = null;
      this._gl.deleteProgram(webGLPipelineContext.program);
    }
  };
  ThinEngine2.prototype.createEffect = function(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, defines, fallbacks, onCompiled, onError, indexParameters) {
    var vertex = baseName.vertexElement || baseName.vertex || baseName.vertexToken || baseName.vertexSource || baseName;
    var fragment = baseName.fragmentElement || baseName.fragment || baseName.fragmentToken || baseName.fragmentSource || baseName;
    var name45 = vertex + "+" + fragment + "@" + (defines ? defines : attributesNamesOrOptions.defines);
    if (this._compiledEffects[name45]) {
      var compiledEffect = this._compiledEffects[name45];
      if (onCompiled && compiledEffect.isReady()) {
        onCompiled(compiledEffect);
      }
      return compiledEffect;
    }
    var effect = new Effect(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, this, defines, fallbacks, onCompiled, onError, indexParameters);
    effect._key = name45;
    this._compiledEffects[name45] = effect;
    return effect;
  };
  ThinEngine2._ConcatenateShader = function(source, defines, shaderVersion) {
    if (shaderVersion === void 0) {
      shaderVersion = "";
    }
    return shaderVersion + (defines ? defines + "\n" : "") + source;
  };
  ThinEngine2.prototype._compileShader = function(source, type, defines, shaderVersion) {
    return this._compileRawShader(ThinEngine2._ConcatenateShader(source, defines, shaderVersion), type);
  };
  ThinEngine2.prototype._compileRawShader = function(source, type) {
    var gl = this._gl;
    var shader45 = gl.createShader(type === "vertex" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
    if (!shader45) {
      throw new Error("Something went wrong while compile the shader.");
    }
    gl.shaderSource(shader45, source);
    gl.compileShader(shader45);
    return shader45;
  };
  ThinEngine2.prototype._getShaderSource = function(shader45) {
    return this._gl.getShaderSource(shader45);
  };
  ThinEngine2.prototype.createRawShaderProgram = function(pipelineContext, vertexCode, fragmentCode, context, transformFeedbackVaryings) {
    if (transformFeedbackVaryings === void 0) {
      transformFeedbackVaryings = null;
    }
    context = context || this._gl;
    var vertexShader = this._compileRawShader(vertexCode, "vertex");
    var fragmentShader = this._compileRawShader(fragmentCode, "fragment");
    return this._createShaderProgram(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings);
  };
  ThinEngine2.prototype.createShaderProgram = function(pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings) {
    if (transformFeedbackVaryings === void 0) {
      transformFeedbackVaryings = null;
    }
    context = context || this._gl;
    var shaderVersion = this._webGLVersion > 1 ? "#version 300 es\n#define WEBGL2 \n" : "";
    var vertexShader = this._compileShader(vertexCode, "vertex", defines, shaderVersion);
    var fragmentShader = this._compileShader(fragmentCode, "fragment", defines, shaderVersion);
    return this._createShaderProgram(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings);
  };
  ThinEngine2.prototype.createPipelineContext = function() {
    var pipelineContext = new WebGLPipelineContext();
    pipelineContext.engine = this;
    if (this._caps.parallelShaderCompile) {
      pipelineContext.isParallelCompiled = true;
    }
    return pipelineContext;
  };
  ThinEngine2.prototype._createShaderProgram = function(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings) {
    if (transformFeedbackVaryings === void 0) {
      transformFeedbackVaryings = null;
    }
    var shaderProgram = context.createProgram();
    pipelineContext.program = shaderProgram;
    if (!shaderProgram) {
      throw new Error("Unable to create program");
    }
    context.attachShader(shaderProgram, vertexShader);
    context.attachShader(shaderProgram, fragmentShader);
    context.linkProgram(shaderProgram);
    pipelineContext.context = context;
    pipelineContext.vertexShader = vertexShader;
    pipelineContext.fragmentShader = fragmentShader;
    if (!pipelineContext.isParallelCompiled) {
      this._finalizePipelineContext(pipelineContext);
    }
    return shaderProgram;
  };
  ThinEngine2.prototype._finalizePipelineContext = function(pipelineContext) {
    var context = pipelineContext.context;
    var vertexShader = pipelineContext.vertexShader;
    var fragmentShader = pipelineContext.fragmentShader;
    var program = pipelineContext.program;
    var linked = context.getProgramParameter(program, context.LINK_STATUS);
    if (!linked) {
      if (!this._gl.getShaderParameter(vertexShader, this._gl.COMPILE_STATUS)) {
        var log = this._gl.getShaderInfoLog(vertexShader);
        if (log) {
          pipelineContext.vertexCompilationError = log;
          throw new Error("VERTEX SHADER " + log);
        }
      }
      if (!this._gl.getShaderParameter(fragmentShader, this._gl.COMPILE_STATUS)) {
        var log = this._gl.getShaderInfoLog(fragmentShader);
        if (log) {
          pipelineContext.fragmentCompilationError = log;
          throw new Error("FRAGMENT SHADER " + log);
        }
      }
      var error = context.getProgramInfoLog(program);
      if (error) {
        pipelineContext.programLinkError = error;
        throw new Error(error);
      }
    }
    if (this.validateShaderPrograms) {
      context.validateProgram(program);
      var validated = context.getProgramParameter(program, context.VALIDATE_STATUS);
      if (!validated) {
        var error = context.getProgramInfoLog(program);
        if (error) {
          pipelineContext.programValidationError = error;
          throw new Error(error);
        }
      }
    }
    context.deleteShader(vertexShader);
    context.deleteShader(fragmentShader);
    pipelineContext.vertexShader = void 0;
    pipelineContext.fragmentShader = void 0;
    if (pipelineContext.onCompiled) {
      pipelineContext.onCompiled();
      pipelineContext.onCompiled = void 0;
    }
  };
  ThinEngine2.prototype._preparePipelineContext = function(pipelineContext, vertexSourceCode, fragmentSourceCode, createAsRaw, rebuildRebind, defines, transformFeedbackVaryings) {
    var webGLRenderingState = pipelineContext;
    if (createAsRaw) {
      webGLRenderingState.program = this.createRawShaderProgram(webGLRenderingState, vertexSourceCode, fragmentSourceCode, void 0, transformFeedbackVaryings);
    } else {
      webGLRenderingState.program = this.createShaderProgram(webGLRenderingState, vertexSourceCode, fragmentSourceCode, defines, void 0, transformFeedbackVaryings);
    }
    webGLRenderingState.program.__SPECTOR_rebuildProgram = rebuildRebind;
  };
  ThinEngine2.prototype._isRenderingStateCompiled = function(pipelineContext) {
    var webGLPipelineContext = pipelineContext;
    if (this._gl.getProgramParameter(webGLPipelineContext.program, this._caps.parallelShaderCompile.COMPLETION_STATUS_KHR)) {
      this._finalizePipelineContext(webGLPipelineContext);
      return true;
    }
    return false;
  };
  ThinEngine2.prototype._executeWhenRenderingStateIsCompiled = function(pipelineContext, action) {
    var webGLPipelineContext = pipelineContext;
    if (!webGLPipelineContext.isParallelCompiled) {
      action();
      return;
    }
    var oldHandler = webGLPipelineContext.onCompiled;
    if (oldHandler) {
      webGLPipelineContext.onCompiled = function() {
        oldHandler();
        action();
      };
    } else {
      webGLPipelineContext.onCompiled = action;
    }
  };
  ThinEngine2.prototype.getUniforms = function(pipelineContext, uniformsNames) {
    var results = new Array();
    var webGLPipelineContext = pipelineContext;
    for (var index = 0; index < uniformsNames.length; index++) {
      results.push(this._gl.getUniformLocation(webGLPipelineContext.program, uniformsNames[index]));
    }
    return results;
  };
  ThinEngine2.prototype.getAttributes = function(pipelineContext, attributesNames) {
    var results = [];
    var webGLPipelineContext = pipelineContext;
    for (var index = 0; index < attributesNames.length; index++) {
      try {
        results.push(this._gl.getAttribLocation(webGLPipelineContext.program, attributesNames[index]));
      } catch (e) {
        results.push(-1);
      }
    }
    return results;
  };
  ThinEngine2.prototype.enableEffect = function(effect) {
    if (!effect || effect === this._currentEffect) {
      return;
    }
    this.bindSamplers(effect);
    this._currentEffect = effect;
    if (effect.onBind) {
      effect.onBind(effect);
    }
    if (effect._onBindObservable) {
      effect._onBindObservable.notifyObservers(effect);
    }
  };
  ThinEngine2.prototype.setInt = function(uniform, value) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform1i(uniform, value);
    return true;
  };
  ThinEngine2.prototype.setIntArray = function(uniform, array) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform1iv(uniform, array);
    return true;
  };
  ThinEngine2.prototype.setIntArray2 = function(uniform, array) {
    if (!uniform || array.length % 2 !== 0) {
      return false;
    }
    this._gl.uniform2iv(uniform, array);
    return true;
  };
  ThinEngine2.prototype.setIntArray3 = function(uniform, array) {
    if (!uniform || array.length % 3 !== 0) {
      return false;
    }
    this._gl.uniform3iv(uniform, array);
    return true;
  };
  ThinEngine2.prototype.setIntArray4 = function(uniform, array) {
    if (!uniform || array.length % 4 !== 0) {
      return false;
    }
    this._gl.uniform4iv(uniform, array);
    return true;
  };
  ThinEngine2.prototype.setArray = function(uniform, array) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform1fv(uniform, array);
    return true;
  };
  ThinEngine2.prototype.setArray2 = function(uniform, array) {
    if (!uniform || array.length % 2 !== 0) {
      return false;
    }
    this._gl.uniform2fv(uniform, array);
    return true;
  };
  ThinEngine2.prototype.setArray3 = function(uniform, array) {
    if (!uniform || array.length % 3 !== 0) {
      return false;
    }
    this._gl.uniform3fv(uniform, array);
    return true;
  };
  ThinEngine2.prototype.setArray4 = function(uniform, array) {
    if (!uniform || array.length % 4 !== 0) {
      return false;
    }
    this._gl.uniform4fv(uniform, array);
    return true;
  };
  ThinEngine2.prototype.setMatrices = function(uniform, matrices) {
    if (!uniform) {
      return false;
    }
    this._gl.uniformMatrix4fv(uniform, false, matrices);
    return true;
  };
  ThinEngine2.prototype.setMatrix3x3 = function(uniform, matrix) {
    if (!uniform) {
      return false;
    }
    this._gl.uniformMatrix3fv(uniform, false, matrix);
    return true;
  };
  ThinEngine2.prototype.setMatrix2x2 = function(uniform, matrix) {
    if (!uniform) {
      return false;
    }
    this._gl.uniformMatrix2fv(uniform, false, matrix);
    return true;
  };
  ThinEngine2.prototype.setFloat = function(uniform, value) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform1f(uniform, value);
    return true;
  };
  ThinEngine2.prototype.setFloat2 = function(uniform, x, y) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform2f(uniform, x, y);
    return true;
  };
  ThinEngine2.prototype.setFloat3 = function(uniform, x, y, z) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform3f(uniform, x, y, z);
    return true;
  };
  ThinEngine2.prototype.setFloat4 = function(uniform, x, y, z, w) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform4f(uniform, x, y, z, w);
    return true;
  };
  ThinEngine2.prototype.applyStates = function() {
    this._depthCullingState.apply(this._gl);
    this._stencilState.apply(this._gl);
    this._alphaState.apply(this._gl);
    if (this._colorWriteChanged) {
      this._colorWriteChanged = false;
      var enable = this._colorWrite;
      this._gl.colorMask(enable, enable, enable, enable);
    }
  };
  ThinEngine2.prototype.setColorWrite = function(enable) {
    if (enable !== this._colorWrite) {
      this._colorWriteChanged = true;
      this._colorWrite = enable;
    }
  };
  ThinEngine2.prototype.getColorWrite = function() {
    return this._colorWrite;
  };
  Object.defineProperty(ThinEngine2.prototype, "depthCullingState", {
    get: function() {
      return this._depthCullingState;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "alphaState", {
    get: function() {
      return this._alphaState;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "stencilState", {
    get: function() {
      return this._stencilState;
    },
    enumerable: false,
    configurable: true
  });
  ThinEngine2.prototype.clearInternalTexturesCache = function() {
    this._internalTexturesCache = [];
  };
  ThinEngine2.prototype.wipeCaches = function(bruteForce) {
    if (this.preventCacheWipeBetweenFrames && !bruteForce) {
      return;
    }
    this._currentEffect = null;
    this._viewportCached.x = 0;
    this._viewportCached.y = 0;
    this._viewportCached.z = 0;
    this._viewportCached.w = 0;
    this._unbindVertexArrayObject();
    if (bruteForce) {
      this._currentProgram = null;
      this.resetTextureCache();
      this._stencilState.reset();
      this._depthCullingState.reset();
      this._depthCullingState.depthFunc = this._gl.LEQUAL;
      this._alphaState.reset();
      this._alphaMode = 1;
      this._alphaEquation = 0;
      this._colorWrite = true;
      this._colorWriteChanged = true;
      this._unpackFlipYCached = null;
      this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE);
      this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
      this._mustWipeVertexAttributes = true;
      this.unbindAllAttributes();
    }
    this._resetVertexBufferBinding();
    this._cachedIndexBuffer = null;
    this._cachedEffectForVertexBuffers = null;
    this.bindIndexBuffer(null);
  };
  ThinEngine2.prototype._getSamplingParameters = function(samplingMode, generateMipMaps) {
    var gl = this._gl;
    var magFilter = gl.NEAREST;
    var minFilter = gl.NEAREST;
    switch (samplingMode) {
      case 11:
        magFilter = gl.LINEAR;
        if (generateMipMaps) {
          minFilter = gl.LINEAR_MIPMAP_NEAREST;
        } else {
          minFilter = gl.LINEAR;
        }
        break;
      case 3:
        magFilter = gl.LINEAR;
        if (generateMipMaps) {
          minFilter = gl.LINEAR_MIPMAP_LINEAR;
        } else {
          minFilter = gl.LINEAR;
        }
        break;
      case 8:
        magFilter = gl.NEAREST;
        if (generateMipMaps) {
          minFilter = gl.NEAREST_MIPMAP_LINEAR;
        } else {
          minFilter = gl.NEAREST;
        }
        break;
      case 4:
        magFilter = gl.NEAREST;
        if (generateMipMaps) {
          minFilter = gl.NEAREST_MIPMAP_NEAREST;
        } else {
          minFilter = gl.NEAREST;
        }
        break;
      case 5:
        magFilter = gl.NEAREST;
        if (generateMipMaps) {
          minFilter = gl.LINEAR_MIPMAP_NEAREST;
        } else {
          minFilter = gl.LINEAR;
        }
        break;
      case 6:
        magFilter = gl.NEAREST;
        if (generateMipMaps) {
          minFilter = gl.LINEAR_MIPMAP_LINEAR;
        } else {
          minFilter = gl.LINEAR;
        }
        break;
      case 7:
        magFilter = gl.NEAREST;
        minFilter = gl.LINEAR;
        break;
      case 1:
        magFilter = gl.NEAREST;
        minFilter = gl.NEAREST;
        break;
      case 9:
        magFilter = gl.LINEAR;
        if (generateMipMaps) {
          minFilter = gl.NEAREST_MIPMAP_NEAREST;
        } else {
          minFilter = gl.NEAREST;
        }
        break;
      case 10:
        magFilter = gl.LINEAR;
        if (generateMipMaps) {
          minFilter = gl.NEAREST_MIPMAP_LINEAR;
        } else {
          minFilter = gl.NEAREST;
        }
        break;
      case 2:
        magFilter = gl.LINEAR;
        minFilter = gl.LINEAR;
        break;
      case 12:
        magFilter = gl.LINEAR;
        minFilter = gl.NEAREST;
        break;
    }
    return {
      min: minFilter,
      mag: magFilter
    };
  };
  ThinEngine2.prototype._createTexture = function() {
    var texture = this._gl.createTexture();
    if (!texture) {
      throw new Error("Unable to create texture");
    }
    return texture;
  };
  ThinEngine2.prototype.createTexture = function(url, noMipmap, invertY, scene, samplingMode, onLoad, onError, buffer, fallback, format, forcedExtension, mimeType, loaderOptions) {
    var _this = this;
    if (samplingMode === void 0) {
      samplingMode = 3;
    }
    if (onLoad === void 0) {
      onLoad = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (buffer === void 0) {
      buffer = null;
    }
    if (fallback === void 0) {
      fallback = null;
    }
    if (format === void 0) {
      format = null;
    }
    if (forcedExtension === void 0) {
      forcedExtension = null;
    }
    url = url || "";
    var fromData = url.substr(0, 5) === "data:";
    var fromBlob = url.substr(0, 5) === "blob:";
    var isBase64 = fromData && url.indexOf(";base64,") !== -1;
    var texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Url);
    var originalUrl = url;
    if (this._transformTextureUrl && !isBase64 && !fallback && !buffer) {
      url = this._transformTextureUrl(url);
    }
    if (originalUrl !== url) {
      texture._originalUrl = originalUrl;
    }
    var lastDot = url.lastIndexOf(".");
    var extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : "";
    var loader = null;
    var queryStringIndex = extension.indexOf("?");
    if (queryStringIndex > -1) {
      extension = extension.split("?")[0];
    }
    for (var _i = 0, _a = ThinEngine2._TextureLoaders; _i < _a.length; _i++) {
      var availableLoader = _a[_i];
      if (availableLoader.canLoad(extension, mimeType)) {
        loader = availableLoader;
        break;
      }
    }
    if (scene) {
      scene._addPendingData(texture);
    }
    texture.url = url;
    texture.generateMipMaps = !noMipmap;
    texture.samplingMode = samplingMode;
    texture.invertY = invertY;
    if (!this._doNotHandleContextLost) {
      texture._buffer = buffer;
    }
    var onLoadObserver = null;
    if (onLoad && !fallback) {
      onLoadObserver = texture.onLoadedObservable.add(onLoad);
    }
    if (!fallback) {
      this._internalTexturesCache.push(texture);
    }
    var onInternalError = function(message, exception) {
      if (scene) {
        scene._removePendingData(texture);
      }
      if (url === originalUrl) {
        if (onLoadObserver) {
          texture.onLoadedObservable.remove(onLoadObserver);
        }
        if (EngineStore.UseFallbackTexture) {
          _this.createTexture(EngineStore.FallbackTexture, noMipmap, texture.invertY, scene, samplingMode, null, onError, buffer, texture);
        }
        if (onError) {
          onError((message || "Unknown error") + (EngineStore.UseFallbackTexture ? " - Fallback texture was used" : ""), exception);
        }
      } else {
        Logger.Warn("Failed to load " + url + ", falling back to " + originalUrl);
        _this.createTexture(originalUrl, noMipmap, texture.invertY, scene, samplingMode, onLoad, onError, buffer, texture, format, forcedExtension, mimeType, loaderOptions);
      }
    };
    if (loader) {
      var callback_1 = function(data) {
        loader.loadData(data, texture, function(width, height, loadMipmap, isCompressed, done, loadFailed) {
          if (loadFailed) {
            onInternalError("TextureLoader failed to load data");
          } else {
            _this._prepareWebGLTexture(texture, scene, width, height, texture.invertY, !loadMipmap, isCompressed, function() {
              done();
              return false;
            }, samplingMode);
          }
        }, loaderOptions);
      };
      if (!buffer) {
        this._loadFile(url, function(data) {
          return callback_1(new Uint8Array(data));
        }, void 0, scene ? scene.offlineProvider : void 0, true, function(request, exception) {
          onInternalError("Unable to load " + (request ? request.responseURL : url, exception));
        });
      } else {
        if (buffer instanceof ArrayBuffer) {
          callback_1(new Uint8Array(buffer));
        } else if (ArrayBuffer.isView(buffer)) {
          callback_1(buffer);
        } else {
          if (onError) {
            onError("Unable to load: only ArrayBuffer or ArrayBufferView is supported", null);
          }
        }
      }
    } else {
      var onload_1 = function(img) {
        if (fromBlob && !_this._doNotHandleContextLost) {
          texture._buffer = img;
        }
        _this._prepareWebGLTexture(texture, scene, img.width, img.height, texture.invertY, noMipmap, false, function(potWidth, potHeight, continuationCallback) {
          var gl = _this._gl;
          var isPot = img.width === potWidth && img.height === potHeight;
          var internalFormat = format ? _this._getInternalFormat(format) : extension === ".jpg" ? gl.RGB : gl.RGBA;
          if (isPot) {
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, internalFormat, gl.UNSIGNED_BYTE, img);
            return false;
          }
          var maxTextureSize = _this._caps.maxTextureSize;
          if (img.width > maxTextureSize || img.height > maxTextureSize || !_this._supportsHardwareTextureRescaling) {
            _this._prepareWorkingCanvas();
            if (!_this._workingCanvas || !_this._workingContext) {
              return false;
            }
            _this._workingCanvas.width = potWidth;
            _this._workingCanvas.height = potHeight;
            _this._workingContext.drawImage(img, 0, 0, img.width, img.height, 0, 0, potWidth, potHeight);
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, internalFormat, gl.UNSIGNED_BYTE, _this._workingCanvas);
            texture.width = potWidth;
            texture.height = potHeight;
            return false;
          } else {
            var source_1 = new InternalTexture(_this, InternalTextureSource.Temp);
            _this._bindTextureDirectly(gl.TEXTURE_2D, source_1, true);
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, internalFormat, gl.UNSIGNED_BYTE, img);
            _this._rescaleTexture(source_1, texture, scene, internalFormat, function() {
              _this._releaseTexture(source_1);
              _this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);
              continuationCallback();
            });
          }
          return true;
        }, samplingMode);
      };
      if (!fromData || isBase64) {
        if (buffer && (buffer.decoding || buffer.close)) {
          onload_1(buffer);
        } else {
          ThinEngine2._FileToolsLoadImage(url, onload_1, onInternalError, scene ? scene.offlineProvider : null, mimeType);
        }
      } else if (typeof buffer === "string" || buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer) || buffer instanceof Blob) {
        ThinEngine2._FileToolsLoadImage(buffer, onload_1, onInternalError, scene ? scene.offlineProvider : null, mimeType);
      } else if (buffer) {
        onload_1(buffer);
      }
    }
    return texture;
  };
  ThinEngine2._FileToolsLoadImage = function(input, onLoad, onError, offlineProvider, mimeType) {
    throw _DevTools.WarnImport("FileTools");
  };
  ThinEngine2.prototype._rescaleTexture = function(source, destination, scene, internalFormat, onComplete) {
  };
  ThinEngine2.prototype.createRawTexture = function(data, width, height, format, generateMipMaps, invertY, samplingMode, compression, type) {
    if (compression === void 0) {
      compression = null;
    }
    if (type === void 0) {
      type = 0;
    }
    throw _DevTools.WarnImport("Engine.RawTexture");
  };
  ThinEngine2.prototype.createRawCubeTexture = function(data, size, format, type, generateMipMaps, invertY, samplingMode, compression) {
    if (compression === void 0) {
      compression = null;
    }
    throw _DevTools.WarnImport("Engine.RawTexture");
  };
  ThinEngine2.prototype.createRawTexture3D = function(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression, textureType) {
    if (compression === void 0) {
      compression = null;
    }
    if (textureType === void 0) {
      textureType = 0;
    }
    throw _DevTools.WarnImport("Engine.RawTexture");
  };
  ThinEngine2.prototype.createRawTexture2DArray = function(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression, textureType) {
    if (compression === void 0) {
      compression = null;
    }
    if (textureType === void 0) {
      textureType = 0;
    }
    throw _DevTools.WarnImport("Engine.RawTexture");
  };
  ThinEngine2.prototype._unpackFlipY = function(value) {
    if (this._unpackFlipYCached !== value) {
      this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, value ? 1 : 0);
      if (this.enableUnpackFlipYCached) {
        this._unpackFlipYCached = value;
      }
    }
  };
  ThinEngine2.prototype._getUnpackAlignement = function() {
    return this._gl.getParameter(this._gl.UNPACK_ALIGNMENT);
  };
  ThinEngine2.prototype._getTextureTarget = function(texture) {
    if (texture.isCube) {
      return this._gl.TEXTURE_CUBE_MAP;
    } else if (texture.is3D) {
      return this._gl.TEXTURE_3D;
    } else if (texture.is2DArray || texture.isMultiview) {
      return this._gl.TEXTURE_2D_ARRAY;
    }
    return this._gl.TEXTURE_2D;
  };
  ThinEngine2.prototype.updateTextureSamplingMode = function(samplingMode, texture, generateMipMaps) {
    if (generateMipMaps === void 0) {
      generateMipMaps = false;
    }
    var target = this._getTextureTarget(texture);
    var filters = this._getSamplingParameters(samplingMode, texture.generateMipMaps || generateMipMaps);
    this._setTextureParameterInteger(target, this._gl.TEXTURE_MAG_FILTER, filters.mag, texture);
    this._setTextureParameterInteger(target, this._gl.TEXTURE_MIN_FILTER, filters.min);
    if (generateMipMaps) {
      texture.generateMipMaps = true;
      this._gl.generateMipmap(target);
    }
    this._bindTextureDirectly(target, null);
    texture.samplingMode = samplingMode;
  };
  ThinEngine2.prototype.updateTextureWrappingMode = function(texture, wrapU, wrapV, wrapR) {
    if (wrapV === void 0) {
      wrapV = null;
    }
    if (wrapR === void 0) {
      wrapR = null;
    }
    var target = this._getTextureTarget(texture);
    if (wrapU !== null) {
      this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(wrapU), texture);
      texture._cachedWrapU = wrapU;
    }
    if (wrapV !== null) {
      this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(wrapV), texture);
      texture._cachedWrapV = wrapV;
    }
    if ((texture.is2DArray || texture.is3D) && wrapR !== null) {
      this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(wrapR), texture);
      texture._cachedWrapR = wrapR;
    }
    this._bindTextureDirectly(target, null);
  };
  ThinEngine2.prototype._setupDepthStencilTexture = function(internalTexture, size, generateStencil, bilinearFiltering, comparisonFunction) {
    var width = size.width || size;
    var height = size.height || size;
    var layers = size.layers || 0;
    internalTexture.baseWidth = width;
    internalTexture.baseHeight = height;
    internalTexture.width = width;
    internalTexture.height = height;
    internalTexture.is2DArray = layers > 0;
    internalTexture.depth = layers;
    internalTexture.isReady = true;
    internalTexture.samples = 1;
    internalTexture.generateMipMaps = false;
    internalTexture._generateDepthBuffer = true;
    internalTexture._generateStencilBuffer = generateStencil;
    internalTexture.samplingMode = bilinearFiltering ? 2 : 1;
    internalTexture.type = 0;
    internalTexture._comparisonFunction = comparisonFunction;
    var gl = this._gl;
    var target = this._getTextureTarget(internalTexture);
    var samplingParameters = this._getSamplingParameters(internalTexture.samplingMode, false);
    gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, samplingParameters.mag);
    gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, samplingParameters.min);
    gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    if (comparisonFunction === 0) {
      gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, 515);
      gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, gl.NONE);
    } else {
      gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);
      gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
    }
  };
  ThinEngine2.prototype._uploadCompressedDataToTextureDirectly = function(texture, internalFormat, width, height, data, faceIndex, lod) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lod === void 0) {
      lod = 0;
    }
    var gl = this._gl;
    var target = gl.TEXTURE_2D;
    if (texture.isCube) {
      target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
    }
    this._gl.compressedTexImage2D(target, lod, internalFormat, width, height, 0, data);
  };
  ThinEngine2.prototype._uploadDataToTextureDirectly = function(texture, imageData, faceIndex, lod, babylonInternalFormat, useTextureWidthAndHeight) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lod === void 0) {
      lod = 0;
    }
    if (useTextureWidthAndHeight === void 0) {
      useTextureWidthAndHeight = false;
    }
    var gl = this._gl;
    var textureType = this._getWebGLTextureType(texture.type);
    var format = this._getInternalFormat(texture.format);
    var internalFormat = babylonInternalFormat === void 0 ? this._getRGBABufferInternalSizedFormat(texture.type, texture.format) : this._getInternalFormat(babylonInternalFormat);
    this._unpackFlipY(texture.invertY);
    var target = gl.TEXTURE_2D;
    if (texture.isCube) {
      target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
    }
    var lodMaxWidth = Math.round(Math.log(texture.width) * Math.LOG2E);
    var lodMaxHeight = Math.round(Math.log(texture.height) * Math.LOG2E);
    var width = useTextureWidthAndHeight ? texture.width : Math.pow(2, Math.max(lodMaxWidth - lod, 0));
    var height = useTextureWidthAndHeight ? texture.height : Math.pow(2, Math.max(lodMaxHeight - lod, 0));
    gl.texImage2D(target, lod, internalFormat, width, height, 0, format, textureType, imageData);
  };
  ThinEngine2.prototype.updateTextureData = function(texture, imageData, xOffset, yOffset, width, height, faceIndex, lod) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lod === void 0) {
      lod = 0;
    }
    var gl = this._gl;
    var textureType = this._getWebGLTextureType(texture.type);
    var format = this._getInternalFormat(texture.format);
    this._unpackFlipY(texture.invertY);
    var target = gl.TEXTURE_2D;
    if (texture.isCube) {
      target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
    }
    gl.texSubImage2D(target, lod, xOffset, yOffset, width, height, format, textureType, imageData);
  };
  ThinEngine2.prototype._uploadArrayBufferViewToTexture = function(texture, imageData, faceIndex, lod) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lod === void 0) {
      lod = 0;
    }
    var gl = this._gl;
    var bindTarget = texture.isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;
    this._bindTextureDirectly(bindTarget, texture, true);
    this._uploadDataToTextureDirectly(texture, imageData, faceIndex, lod);
    this._bindTextureDirectly(bindTarget, null, true);
  };
  ThinEngine2.prototype._prepareWebGLTextureContinuation = function(texture, scene, noMipmap, isCompressed, samplingMode) {
    var gl = this._gl;
    if (!gl) {
      return;
    }
    var filters = this._getSamplingParameters(samplingMode, !noMipmap);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filters.mag);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filters.min);
    if (!noMipmap && !isCompressed) {
      gl.generateMipmap(gl.TEXTURE_2D);
    }
    this._bindTextureDirectly(gl.TEXTURE_2D, null);
    if (scene) {
      scene._removePendingData(texture);
    }
    texture.onLoadedObservable.notifyObservers(texture);
    texture.onLoadedObservable.clear();
  };
  ThinEngine2.prototype._prepareWebGLTexture = function(texture, scene, width, height, invertY, noMipmap, isCompressed, processFunction, samplingMode) {
    var _this = this;
    if (samplingMode === void 0) {
      samplingMode = 3;
    }
    var maxTextureSize = this.getCaps().maxTextureSize;
    var potWidth = Math.min(maxTextureSize, this.needPOTTextures ? ThinEngine2.GetExponentOfTwo(width, maxTextureSize) : width);
    var potHeight = Math.min(maxTextureSize, this.needPOTTextures ? ThinEngine2.GetExponentOfTwo(height, maxTextureSize) : height);
    var gl = this._gl;
    if (!gl) {
      return;
    }
    if (!texture._webGLTexture) {
      if (scene) {
        scene._removePendingData(texture);
      }
      return;
    }
    this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);
    this._unpackFlipY(invertY === void 0 ? true : invertY ? true : false);
    texture.baseWidth = width;
    texture.baseHeight = height;
    texture.width = potWidth;
    texture.height = potHeight;
    texture.isReady = true;
    if (processFunction(potWidth, potHeight, function() {
      _this._prepareWebGLTextureContinuation(texture, scene, noMipmap, isCompressed, samplingMode);
    })) {
      return;
    }
    this._prepareWebGLTextureContinuation(texture, scene, noMipmap, isCompressed, samplingMode);
  };
  ThinEngine2.prototype._setupFramebufferDepthAttachments = function(generateStencilBuffer, generateDepthBuffer, width, height, samples) {
    if (samples === void 0) {
      samples = 1;
    }
    var gl = this._gl;
    if (generateStencilBuffer && generateDepthBuffer) {
      return this._getDepthStencilBuffer(width, height, samples, gl.DEPTH_STENCIL, gl.DEPTH24_STENCIL8, gl.DEPTH_STENCIL_ATTACHMENT);
    }
    if (generateDepthBuffer) {
      var depthFormat = gl.DEPTH_COMPONENT16;
      if (this._webGLVersion > 1) {
        depthFormat = gl.DEPTH_COMPONENT32F;
      }
      return this._getDepthStencilBuffer(width, height, samples, depthFormat, depthFormat, gl.DEPTH_ATTACHMENT);
    }
    if (generateStencilBuffer) {
      return this._getDepthStencilBuffer(width, height, samples, gl.STENCIL_INDEX8, gl.STENCIL_INDEX8, gl.STENCIL_ATTACHMENT);
    }
    return null;
  };
  ThinEngine2.prototype._releaseFramebufferObjects = function(texture) {
    var gl = this._gl;
    if (texture._framebuffer) {
      gl.deleteFramebuffer(texture._framebuffer);
      texture._framebuffer = null;
    }
    if (texture._depthStencilBuffer) {
      gl.deleteRenderbuffer(texture._depthStencilBuffer);
      texture._depthStencilBuffer = null;
    }
    if (texture._MSAAFramebuffer) {
      gl.deleteFramebuffer(texture._MSAAFramebuffer);
      texture._MSAAFramebuffer = null;
    }
    if (texture._MSAARenderBuffer) {
      gl.deleteRenderbuffer(texture._MSAARenderBuffer);
      texture._MSAARenderBuffer = null;
    }
  };
  ThinEngine2.prototype._releaseTexture = function(texture) {
    this._releaseFramebufferObjects(texture);
    this._deleteTexture(texture._webGLTexture);
    this.unbindAllTextures();
    var index = this._internalTexturesCache.indexOf(texture);
    if (index !== -1) {
      this._internalTexturesCache.splice(index, 1);
    }
    if (texture._lodTextureHigh) {
      texture._lodTextureHigh.dispose();
    }
    if (texture._lodTextureMid) {
      texture._lodTextureMid.dispose();
    }
    if (texture._lodTextureLow) {
      texture._lodTextureLow.dispose();
    }
    if (texture._irradianceTexture) {
      texture._irradianceTexture.dispose();
    }
  };
  ThinEngine2.prototype._deleteTexture = function(texture) {
    this._gl.deleteTexture(texture);
  };
  ThinEngine2.prototype._setProgram = function(program) {
    if (this._currentProgram !== program) {
      this._gl.useProgram(program);
      this._currentProgram = program;
    }
  };
  ThinEngine2.prototype.bindSamplers = function(effect) {
    var webGLPipelineContext = effect.getPipelineContext();
    this._setProgram(webGLPipelineContext.program);
    var samplers = effect.getSamplers();
    for (var index = 0; index < samplers.length; index++) {
      var uniform = effect.getUniform(samplers[index]);
      if (uniform) {
        this._boundUniforms[index] = uniform;
      }
    }
    this._currentEffect = null;
  };
  ThinEngine2.prototype._activateCurrentTexture = function() {
    if (this._currentTextureChannel !== this._activeChannel) {
      this._gl.activeTexture(this._gl.TEXTURE0 + this._activeChannel);
      this._currentTextureChannel = this._activeChannel;
    }
  };
  ThinEngine2.prototype._bindTextureDirectly = function(target, texture, forTextureDataUpdate, force) {
    if (forTextureDataUpdate === void 0) {
      forTextureDataUpdate = false;
    }
    if (force === void 0) {
      force = false;
    }
    var wasPreviouslyBound = false;
    var isTextureForRendering = texture && texture._associatedChannel > -1;
    if (forTextureDataUpdate && isTextureForRendering) {
      this._activeChannel = texture._associatedChannel;
    }
    var currentTextureBound = this._boundTexturesCache[this._activeChannel];
    if (currentTextureBound !== texture || force) {
      this._activateCurrentTexture();
      if (texture && texture.isMultiview) {
        this._gl.bindTexture(target, texture ? texture._colorTextureArray : null);
      } else {
        this._gl.bindTexture(target, texture ? texture._webGLTexture : null);
      }
      this._boundTexturesCache[this._activeChannel] = texture;
      if (texture) {
        texture._associatedChannel = this._activeChannel;
      }
    } else if (forTextureDataUpdate) {
      wasPreviouslyBound = true;
      this._activateCurrentTexture();
    }
    if (isTextureForRendering && !forTextureDataUpdate) {
      this._bindSamplerUniformToChannel(texture._associatedChannel, this._activeChannel);
    }
    return wasPreviouslyBound;
  };
  ThinEngine2.prototype._bindTexture = function(channel, texture) {
    if (channel === void 0) {
      return;
    }
    if (texture) {
      texture._associatedChannel = channel;
    }
    this._activeChannel = channel;
    var target = texture ? this._getTextureTarget(texture) : this._gl.TEXTURE_2D;
    this._bindTextureDirectly(target, texture);
  };
  ThinEngine2.prototype.unbindAllTextures = function() {
    for (var channel = 0; channel < this._maxSimultaneousTextures; channel++) {
      this._activeChannel = channel;
      this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
      this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
      if (this.webGLVersion > 1) {
        this._bindTextureDirectly(this._gl.TEXTURE_3D, null);
        this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null);
      }
    }
  };
  ThinEngine2.prototype.setTexture = function(channel, uniform, texture) {
    if (channel === void 0) {
      return;
    }
    if (uniform) {
      this._boundUniforms[channel] = uniform;
    }
    this._setTexture(channel, texture);
  };
  ThinEngine2.prototype._bindSamplerUniformToChannel = function(sourceSlot, destination) {
    var uniform = this._boundUniforms[sourceSlot];
    if (!uniform || uniform._currentState === destination) {
      return;
    }
    this._gl.uniform1i(uniform, destination);
    uniform._currentState = destination;
  };
  ThinEngine2.prototype._getTextureWrapMode = function(mode) {
    switch (mode) {
      case 1:
        return this._gl.REPEAT;
      case 0:
        return this._gl.CLAMP_TO_EDGE;
      case 2:
        return this._gl.MIRRORED_REPEAT;
    }
    return this._gl.REPEAT;
  };
  ThinEngine2.prototype._setTexture = function(channel, texture, isPartOfTextureArray, depthStencilTexture) {
    if (isPartOfTextureArray === void 0) {
      isPartOfTextureArray = false;
    }
    if (depthStencilTexture === void 0) {
      depthStencilTexture = false;
    }
    if (!texture) {
      if (this._boundTexturesCache[channel] != null) {
        this._activeChannel = channel;
        this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
        this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
        if (this.webGLVersion > 1) {
          this._bindTextureDirectly(this._gl.TEXTURE_3D, null);
          this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null);
        }
      }
      return false;
    }
    if (texture.video) {
      this._activeChannel = channel;
      texture.update();
    } else if (texture.delayLoadState === 4) {
      texture.delayLoad();
      return false;
    }
    var internalTexture;
    if (depthStencilTexture) {
      internalTexture = texture.depthStencilTexture;
    } else if (texture.isReady()) {
      internalTexture = texture.getInternalTexture();
    } else if (texture.isCube) {
      internalTexture = this.emptyCubeTexture;
    } else if (texture.is3D) {
      internalTexture = this.emptyTexture3D;
    } else if (texture.is2DArray) {
      internalTexture = this.emptyTexture2DArray;
    } else {
      internalTexture = this.emptyTexture;
    }
    if (!isPartOfTextureArray && internalTexture) {
      internalTexture._associatedChannel = channel;
    }
    var needToBind = true;
    if (this._boundTexturesCache[channel] === internalTexture) {
      if (!isPartOfTextureArray) {
        this._bindSamplerUniformToChannel(internalTexture._associatedChannel, channel);
      }
      needToBind = false;
    }
    this._activeChannel = channel;
    var target = this._getTextureTarget(internalTexture);
    if (needToBind) {
      this._bindTextureDirectly(target, internalTexture, isPartOfTextureArray);
    }
    if (internalTexture && !internalTexture.isMultiview) {
      if (internalTexture.isCube && internalTexture._cachedCoordinatesMode !== texture.coordinatesMode) {
        internalTexture._cachedCoordinatesMode = texture.coordinatesMode;
        var textureWrapMode = texture.coordinatesMode !== 3 && texture.coordinatesMode !== 5 ? 1 : 0;
        texture.wrapU = textureWrapMode;
        texture.wrapV = textureWrapMode;
      }
      if (internalTexture._cachedWrapU !== texture.wrapU) {
        internalTexture._cachedWrapU = texture.wrapU;
        this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(texture.wrapU), internalTexture);
      }
      if (internalTexture._cachedWrapV !== texture.wrapV) {
        internalTexture._cachedWrapV = texture.wrapV;
        this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(texture.wrapV), internalTexture);
      }
      if (internalTexture.is3D && internalTexture._cachedWrapR !== texture.wrapR) {
        internalTexture._cachedWrapR = texture.wrapR;
        this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(texture.wrapR), internalTexture);
      }
      this._setAnisotropicLevel(target, internalTexture, texture.anisotropicFilteringLevel);
    }
    return true;
  };
  ThinEngine2.prototype.setTextureArray = function(channel, uniform, textures) {
    if (channel === void 0 || !uniform) {
      return;
    }
    if (!this._textureUnits || this._textureUnits.length !== textures.length) {
      this._textureUnits = new Int32Array(textures.length);
    }
    for (var i = 0; i < textures.length; i++) {
      var texture = textures[i].getInternalTexture();
      if (texture) {
        this._textureUnits[i] = channel + i;
        texture._associatedChannel = channel + i;
      } else {
        this._textureUnits[i] = -1;
      }
    }
    this._gl.uniform1iv(uniform, this._textureUnits);
    for (var index = 0; index < textures.length; index++) {
      this._setTexture(this._textureUnits[index], textures[index], true);
    }
  };
  ThinEngine2.prototype._setAnisotropicLevel = function(target, internalTexture, anisotropicFilteringLevel) {
    var anisotropicFilterExtension = this._caps.textureAnisotropicFilterExtension;
    if (internalTexture.samplingMode !== 11 && internalTexture.samplingMode !== 3 && internalTexture.samplingMode !== 2) {
      anisotropicFilteringLevel = 1;
    }
    if (anisotropicFilterExtension && internalTexture._cachedAnisotropicFilteringLevel !== anisotropicFilteringLevel) {
      this._setTextureParameterFloat(target, anisotropicFilterExtension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(anisotropicFilteringLevel, this._caps.maxAnisotropy), internalTexture);
      internalTexture._cachedAnisotropicFilteringLevel = anisotropicFilteringLevel;
    }
  };
  ThinEngine2.prototype._setTextureParameterFloat = function(target, parameter, value, texture) {
    this._bindTextureDirectly(target, texture, true, true);
    this._gl.texParameterf(target, parameter, value);
  };
  ThinEngine2.prototype._setTextureParameterInteger = function(target, parameter, value, texture) {
    if (texture) {
      this._bindTextureDirectly(target, texture, true, true);
    }
    this._gl.texParameteri(target, parameter, value);
  };
  ThinEngine2.prototype.unbindAllAttributes = function() {
    if (this._mustWipeVertexAttributes) {
      this._mustWipeVertexAttributes = false;
      for (var i = 0; i < this._caps.maxVertexAttribs; i++) {
        this.disableAttributeByIndex(i);
      }
      return;
    }
    for (var i = 0, ul = this._vertexAttribArraysEnabled.length; i < ul; i++) {
      if (i >= this._caps.maxVertexAttribs || !this._vertexAttribArraysEnabled[i]) {
        continue;
      }
      this.disableAttributeByIndex(i);
    }
  };
  ThinEngine2.prototype.releaseEffects = function() {
    for (var name45 in this._compiledEffects) {
      var webGLPipelineContext = this._compiledEffects[name45].getPipelineContext();
      this._deletePipelineContext(webGLPipelineContext);
    }
    this._compiledEffects = {};
  };
  ThinEngine2.prototype.dispose = function() {
    this.stopRenderLoop();
    if (this.onBeforeTextureInitObservable) {
      this.onBeforeTextureInitObservable.clear();
    }
    if (this._emptyTexture) {
      this._releaseTexture(this._emptyTexture);
      this._emptyTexture = null;
    }
    if (this._emptyCubeTexture) {
      this._releaseTexture(this._emptyCubeTexture);
      this._emptyCubeTexture = null;
    }
    if (this._dummyFramebuffer) {
      this._gl.deleteFramebuffer(this._dummyFramebuffer);
    }
    this.releaseEffects();
    this.unbindAllAttributes();
    this._boundUniforms = [];
    if (DomManagement.IsWindowObjectExist()) {
      if (this._renderingCanvas) {
        if (!this._doNotHandleContextLost) {
          this._renderingCanvas.removeEventListener("webglcontextlost", this._onContextLost);
          this._renderingCanvas.removeEventListener("webglcontextrestored", this._onContextRestored);
        }
      }
    }
    this._workingCanvas = null;
    this._workingContext = null;
    this._currentBufferPointers = [];
    this._renderingCanvas = null;
    this._currentProgram = null;
    this._boundRenderFunction = null;
    Effect.ResetCache();
    for (var _i = 0, _a = this._activeRequests; _i < _a.length; _i++) {
      var request = _a[_i];
      request.abort();
    }
  };
  ThinEngine2.prototype.attachContextLostEvent = function(callback) {
    if (this._renderingCanvas) {
      this._renderingCanvas.addEventListener("webglcontextlost", callback, false);
    }
  };
  ThinEngine2.prototype.attachContextRestoredEvent = function(callback) {
    if (this._renderingCanvas) {
      this._renderingCanvas.addEventListener("webglcontextrestored", callback, false);
    }
  };
  ThinEngine2.prototype.getError = function() {
    return this._gl.getError();
  };
  ThinEngine2.prototype._canRenderToFloatFramebuffer = function() {
    if (this._webGLVersion > 1) {
      return this._caps.colorBufferFloat;
    }
    return this._canRenderToFramebuffer(1);
  };
  ThinEngine2.prototype._canRenderToHalfFloatFramebuffer = function() {
    if (this._webGLVersion > 1) {
      return this._caps.colorBufferFloat;
    }
    return this._canRenderToFramebuffer(2);
  };
  ThinEngine2.prototype._canRenderToFramebuffer = function(type) {
    var gl = this._gl;
    while (gl.getError() !== gl.NO_ERROR) {
    }
    var successful = true;
    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, this._getRGBABufferInternalSizedFormat(type), 1, 1, 0, gl.RGBA, this._getWebGLTextureType(type), null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    var fb = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    successful = successful && status === gl.FRAMEBUFFER_COMPLETE;
    successful = successful && gl.getError() === gl.NO_ERROR;
    if (successful) {
      gl.clear(gl.COLOR_BUFFER_BIT);
      successful = successful && gl.getError() === gl.NO_ERROR;
    }
    if (successful) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      var readFormat = gl.RGBA;
      var readType = gl.UNSIGNED_BYTE;
      var buffer = new Uint8Array(4);
      gl.readPixels(0, 0, 1, 1, readFormat, readType, buffer);
      successful = successful && gl.getError() === gl.NO_ERROR;
    }
    gl.deleteTexture(texture);
    gl.deleteFramebuffer(fb);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    while (!successful && gl.getError() !== gl.NO_ERROR) {
    }
    return successful;
  };
  ThinEngine2.prototype._getWebGLTextureType = function(type) {
    if (this._webGLVersion === 1) {
      switch (type) {
        case 1:
          return this._gl.FLOAT;
        case 2:
          return this._gl.HALF_FLOAT_OES;
        case 0:
          return this._gl.UNSIGNED_BYTE;
        case 8:
          return this._gl.UNSIGNED_SHORT_4_4_4_4;
        case 9:
          return this._gl.UNSIGNED_SHORT_5_5_5_1;
        case 10:
          return this._gl.UNSIGNED_SHORT_5_6_5;
      }
      return this._gl.UNSIGNED_BYTE;
    }
    switch (type) {
      case 3:
        return this._gl.BYTE;
      case 0:
        return this._gl.UNSIGNED_BYTE;
      case 4:
        return this._gl.SHORT;
      case 5:
        return this._gl.UNSIGNED_SHORT;
      case 6:
        return this._gl.INT;
      case 7:
        return this._gl.UNSIGNED_INT;
      case 1:
        return this._gl.FLOAT;
      case 2:
        return this._gl.HALF_FLOAT;
      case 8:
        return this._gl.UNSIGNED_SHORT_4_4_4_4;
      case 9:
        return this._gl.UNSIGNED_SHORT_5_5_5_1;
      case 10:
        return this._gl.UNSIGNED_SHORT_5_6_5;
      case 11:
        return this._gl.UNSIGNED_INT_2_10_10_10_REV;
      case 12:
        return this._gl.UNSIGNED_INT_24_8;
      case 13:
        return this._gl.UNSIGNED_INT_10F_11F_11F_REV;
      case 14:
        return this._gl.UNSIGNED_INT_5_9_9_9_REV;
      case 15:
        return this._gl.FLOAT_32_UNSIGNED_INT_24_8_REV;
    }
    return this._gl.UNSIGNED_BYTE;
  };
  ThinEngine2.prototype._getInternalFormat = function(format) {
    var internalFormat = this._gl.RGBA;
    switch (format) {
      case 0:
        internalFormat = this._gl.ALPHA;
        break;
      case 1:
        internalFormat = this._gl.LUMINANCE;
        break;
      case 2:
        internalFormat = this._gl.LUMINANCE_ALPHA;
        break;
      case 6:
        internalFormat = this._gl.RED;
        break;
      case 7:
        internalFormat = this._gl.RG;
        break;
      case 4:
        internalFormat = this._gl.RGB;
        break;
      case 5:
        internalFormat = this._gl.RGBA;
        break;
    }
    if (this._webGLVersion > 1) {
      switch (format) {
        case 8:
          internalFormat = this._gl.RED_INTEGER;
          break;
        case 9:
          internalFormat = this._gl.RG_INTEGER;
          break;
        case 10:
          internalFormat = this._gl.RGB_INTEGER;
          break;
        case 11:
          internalFormat = this._gl.RGBA_INTEGER;
          break;
      }
    }
    return internalFormat;
  };
  ThinEngine2.prototype._getRGBABufferInternalSizedFormat = function(type, format) {
    if (this._webGLVersion === 1) {
      if (format !== void 0) {
        switch (format) {
          case 0:
            return this._gl.ALPHA;
          case 1:
            return this._gl.LUMINANCE;
          case 2:
            return this._gl.LUMINANCE_ALPHA;
          case 4:
            return this._gl.RGB;
        }
      }
      return this._gl.RGBA;
    }
    switch (type) {
      case 3:
        switch (format) {
          case 6:
            return this._gl.R8_SNORM;
          case 7:
            return this._gl.RG8_SNORM;
          case 4:
            return this._gl.RGB8_SNORM;
          case 8:
            return this._gl.R8I;
          case 9:
            return this._gl.RG8I;
          case 10:
            return this._gl.RGB8I;
          case 11:
            return this._gl.RGBA8I;
          default:
            return this._gl.RGBA8_SNORM;
        }
      case 0:
        switch (format) {
          case 6:
            return this._gl.R8;
          case 7:
            return this._gl.RG8;
          case 4:
            return this._gl.RGB8;
          case 5:
            return this._gl.RGBA8;
          case 8:
            return this._gl.R8UI;
          case 9:
            return this._gl.RG8UI;
          case 10:
            return this._gl.RGB8UI;
          case 11:
            return this._gl.RGBA8UI;
          case 0:
            return this._gl.ALPHA;
          case 1:
            return this._gl.LUMINANCE;
          case 2:
            return this._gl.LUMINANCE_ALPHA;
          default:
            return this._gl.RGBA8;
        }
      case 4:
        switch (format) {
          case 8:
            return this._gl.R16I;
          case 9:
            return this._gl.RG16I;
          case 10:
            return this._gl.RGB16I;
          case 11:
            return this._gl.RGBA16I;
          default:
            return this._gl.RGBA16I;
        }
      case 5:
        switch (format) {
          case 8:
            return this._gl.R16UI;
          case 9:
            return this._gl.RG16UI;
          case 10:
            return this._gl.RGB16UI;
          case 11:
            return this._gl.RGBA16UI;
          default:
            return this._gl.RGBA16UI;
        }
      case 6:
        switch (format) {
          case 8:
            return this._gl.R32I;
          case 9:
            return this._gl.RG32I;
          case 10:
            return this._gl.RGB32I;
          case 11:
            return this._gl.RGBA32I;
          default:
            return this._gl.RGBA32I;
        }
      case 7:
        switch (format) {
          case 8:
            return this._gl.R32UI;
          case 9:
            return this._gl.RG32UI;
          case 10:
            return this._gl.RGB32UI;
          case 11:
            return this._gl.RGBA32UI;
          default:
            return this._gl.RGBA32UI;
        }
      case 1:
        switch (format) {
          case 6:
            return this._gl.R32F;
          case 7:
            return this._gl.RG32F;
          case 4:
            return this._gl.RGB32F;
          case 5:
            return this._gl.RGBA32F;
          default:
            return this._gl.RGBA32F;
        }
      case 2:
        switch (format) {
          case 6:
            return this._gl.R16F;
          case 7:
            return this._gl.RG16F;
          case 4:
            return this._gl.RGB16F;
          case 5:
            return this._gl.RGBA16F;
          default:
            return this._gl.RGBA16F;
        }
      case 10:
        return this._gl.RGB565;
      case 13:
        return this._gl.R11F_G11F_B10F;
      case 14:
        return this._gl.RGB9_E5;
      case 8:
        return this._gl.RGBA4;
      case 9:
        return this._gl.RGB5_A1;
      case 11:
        switch (format) {
          case 5:
            return this._gl.RGB10_A2;
          case 11:
            return this._gl.RGB10_A2UI;
          default:
            return this._gl.RGB10_A2;
        }
    }
    return this._gl.RGBA8;
  };
  ThinEngine2.prototype._getRGBAMultiSampleBufferFormat = function(type) {
    if (type === 1) {
      return this._gl.RGBA32F;
    } else if (type === 2) {
      return this._gl.RGBA16F;
    }
    return this._gl.RGBA8;
  };
  ThinEngine2.prototype._loadFile = function(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
    var _this = this;
    var request = ThinEngine2._FileToolsLoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);
    this._activeRequests.push(request);
    request.onCompleteObservable.add(function(request2) {
      _this._activeRequests.splice(_this._activeRequests.indexOf(request2), 1);
    });
    return request;
  };
  ThinEngine2._FileToolsLoadFile = function(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
    throw _DevTools.WarnImport("FileTools");
  };
  ThinEngine2.prototype.readPixels = function(x, y, width, height, hasAlpha) {
    if (hasAlpha === void 0) {
      hasAlpha = true;
    }
    var numChannels = hasAlpha ? 4 : 3;
    var format = hasAlpha ? this._gl.RGBA : this._gl.RGB;
    var data = new Uint8Array(height * width * numChannels);
    this._gl.readPixels(x, y, width, height, format, this._gl.UNSIGNED_BYTE, data);
    return data;
  };
  Object.defineProperty(ThinEngine2, "IsSupported", {
    get: function() {
      return this.isSupported();
    },
    enumerable: false,
    configurable: true
  });
  ThinEngine2.isSupported = function() {
    if (this._HasMajorPerformanceCaveat !== null) {
      return !this._HasMajorPerformanceCaveat;
    }
    if (this._IsSupported === null) {
      try {
        var tempcanvas = CanvasGenerator.CreateCanvas(1, 1);
        var gl = tempcanvas.getContext("webgl") || tempcanvas.getContext("experimental-webgl");
        this._IsSupported = gl != null && !!window.WebGLRenderingContext;
      } catch (e) {
        this._IsSupported = false;
      }
    }
    return this._IsSupported;
  };
  Object.defineProperty(ThinEngine2, "HasMajorPerformanceCaveat", {
    get: function() {
      if (this._HasMajorPerformanceCaveat === null) {
        try {
          var tempcanvas = CanvasGenerator.CreateCanvas(1, 1);
          var gl = tempcanvas.getContext("webgl", { failIfMajorPerformanceCaveat: true }) || tempcanvas.getContext("experimental-webgl", { failIfMajorPerformanceCaveat: true });
          this._HasMajorPerformanceCaveat = !gl;
        } catch (e) {
          this._HasMajorPerformanceCaveat = false;
        }
      }
      return this._HasMajorPerformanceCaveat;
    },
    enumerable: false,
    configurable: true
  });
  ThinEngine2.CeilingPOT = function(x) {
    x--;
    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    x++;
    return x;
  };
  ThinEngine2.FloorPOT = function(x) {
    x = x | x >> 1;
    x = x | x >> 2;
    x = x | x >> 4;
    x = x | x >> 8;
    x = x | x >> 16;
    return x - (x >> 1);
  };
  ThinEngine2.NearestPOT = function(x) {
    var c = ThinEngine2.CeilingPOT(x);
    var f = ThinEngine2.FloorPOT(x);
    return c - x > x - f ? f : c;
  };
  ThinEngine2.GetExponentOfTwo = function(value, max, mode) {
    if (mode === void 0) {
      mode = 2;
    }
    var pot;
    switch (mode) {
      case 1:
        pot = ThinEngine2.FloorPOT(value);
        break;
      case 2:
        pot = ThinEngine2.NearestPOT(value);
        break;
      case 3:
      default:
        pot = ThinEngine2.CeilingPOT(value);
        break;
    }
    return Math.min(pot, max);
  };
  ThinEngine2.QueueNewFrame = function(func, requester) {
    if (!DomManagement.IsWindowObjectExist()) {
      if (typeof requestAnimationFrame !== "undefined") {
        return requestAnimationFrame(func);
      }
      return setTimeout(func, 16);
    }
    if (!requester) {
      requester = window;
    }
    if (requester.requestPostAnimationFrame) {
      return requester.requestPostAnimationFrame(func);
    } else if (requester.requestAnimationFrame) {
      return requester.requestAnimationFrame(func);
    } else if (requester.msRequestAnimationFrame) {
      return requester.msRequestAnimationFrame(func);
    } else if (requester.webkitRequestAnimationFrame) {
      return requester.webkitRequestAnimationFrame(func);
    } else if (requester.mozRequestAnimationFrame) {
      return requester.mozRequestAnimationFrame(func);
    } else if (requester.oRequestAnimationFrame) {
      return requester.oRequestAnimationFrame(func);
    } else {
      return window.setTimeout(func, 16);
    }
  };
  ThinEngine2.prototype.getHostDocument = function() {
    if (this._renderingCanvas && this._renderingCanvas.ownerDocument) {
      return this._renderingCanvas.ownerDocument;
    }
    return document;
  };
  ThinEngine2.ExceptionList = [
    { key: "Chrome/63.0", capture: "63\\.0\\.3239\\.(\\d+)", captureConstraint: 108, targets: ["uniformBuffer"] },
    { key: "Firefox/58", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
    { key: "Firefox/59", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
    { key: "Chrome/72.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
    { key: "Chrome/73.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
    { key: "Chrome/74.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
    { key: "Mac OS.+Chrome/71", capture: null, captureConstraint: null, targets: ["vao"] },
    { key: "Mac OS.+Chrome/72", capture: null, captureConstraint: null, targets: ["vao"] }
  ];
  ThinEngine2._TextureLoaders = [];
  ThinEngine2.CollisionsEpsilon = 1e-3;
  ThinEngine2._IsSupported = null;
  ThinEngine2._HasMajorPerformanceCaveat = null;
  return ThinEngine2;
}();

// node_modules/@babylonjs/core/Misc/baseError.js
var BaseError = function(_super) {
  __extends(BaseError2, _super);
  function BaseError2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  BaseError2._setPrototypeOf = Object.setPrototypeOf || function(o, proto) {
    o.__proto__ = proto;
    return o;
  };
  return BaseError2;
}(Error);

// node_modules/@babylonjs/core/Misc/fileTools.js
var LoadFileError = function(_super) {
  __extends(LoadFileError2, _super);
  function LoadFileError2(message, object) {
    var _this = _super.call(this, message) || this;
    _this.name = "LoadFileError";
    BaseError._setPrototypeOf(_this, LoadFileError2.prototype);
    if (object instanceof WebRequest) {
      _this.request = object;
    } else {
      _this.file = object;
    }
    return _this;
  }
  return LoadFileError2;
}(BaseError);
var RequestFileError = function(_super) {
  __extends(RequestFileError2, _super);
  function RequestFileError2(message, request) {
    var _this = _super.call(this, message) || this;
    _this.request = request;
    _this.name = "RequestFileError";
    BaseError._setPrototypeOf(_this, RequestFileError2.prototype);
    return _this;
  }
  return RequestFileError2;
}(BaseError);
var ReadFileError = function(_super) {
  __extends(ReadFileError2, _super);
  function ReadFileError2(message, file) {
    var _this = _super.call(this, message) || this;
    _this.file = file;
    _this.name = "ReadFileError";
    BaseError._setPrototypeOf(_this, ReadFileError2.prototype);
    return _this;
  }
  return ReadFileError2;
}(BaseError);
var FileTools = function() {
  function FileTools2() {
  }
  FileTools2._CleanUrl = function(url) {
    url = url.replace(/#/mg, "%23");
    return url;
  };
  FileTools2.SetCorsBehavior = function(url, element) {
    if (url && url.indexOf("data:") === 0) {
      return;
    }
    if (FileTools2.CorsBehavior) {
      if (typeof FileTools2.CorsBehavior === "string" || this.CorsBehavior instanceof String) {
        element.crossOrigin = FileTools2.CorsBehavior;
      } else {
        var result = FileTools2.CorsBehavior(url);
        if (result) {
          element.crossOrigin = result;
        }
      }
    }
  };
  FileTools2.LoadImage = function(input, onLoad, onError, offlineProvider, mimeType) {
    if (mimeType === void 0) {
      mimeType = "";
    }
    var url;
    var usingObjectURL = false;
    if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {
      if (typeof Blob !== "undefined") {
        url = URL.createObjectURL(new Blob([input], { type: mimeType }));
        usingObjectURL = true;
      } else {
        url = "data:" + mimeType + ";base64," + StringTools.EncodeArrayBufferToBase64(input);
      }
    } else if (input instanceof Blob) {
      url = URL.createObjectURL(input);
      usingObjectURL = true;
    } else {
      url = FileTools2._CleanUrl(input);
      url = FileTools2.PreprocessUrl(input);
    }
    if (typeof Image === "undefined") {
      FileTools2.LoadFile(url, function(data) {
        createImageBitmap(new Blob([data], { type: mimeType })).then(function(imgBmp) {
          onLoad(imgBmp);
          if (usingObjectURL) {
            URL.revokeObjectURL(url);
          }
        }).catch(function(reason) {
          if (onError) {
            onError("Error while trying to load image: " + input, reason);
          }
        });
      }, void 0, offlineProvider || void 0, true, function(request, exception) {
        if (onError) {
          onError("Error while trying to load image: " + input, exception);
        }
      });
      return null;
    }
    var img = new Image();
    FileTools2.SetCorsBehavior(url, img);
    var loadHandler = function() {
      img.removeEventListener("load", loadHandler);
      img.removeEventListener("error", errorHandler);
      onLoad(img);
      if (usingObjectURL && img.src) {
        URL.revokeObjectURL(img.src);
      }
    };
    var errorHandler = function(err) {
      img.removeEventListener("load", loadHandler);
      img.removeEventListener("error", errorHandler);
      if (onError) {
        var inputText = input.toString();
        onError("Error while trying to load image: " + (inputText.length < 32 ? inputText : inputText.slice(0, 32) + "..."), err);
      }
      if (usingObjectURL && img.src) {
        URL.revokeObjectURL(img.src);
      }
    };
    img.addEventListener("load", loadHandler);
    img.addEventListener("error", errorHandler);
    var noOfflineSupport = function() {
      img.src = url;
    };
    var loadFromOfflineSupport = function() {
      if (offlineProvider) {
        offlineProvider.loadImage(url, img);
      }
    };
    if (url.substr(0, 5) !== "data:" && offlineProvider && offlineProvider.enableTexturesOffline) {
      offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);
    } else {
      if (url.indexOf("file:") !== -1) {
        var textureName = decodeURIComponent(url.substring(5).toLowerCase());
        if (FilesInputStore.FilesToLoad[textureName]) {
          try {
            var blobURL;
            try {
              blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);
            } catch (ex) {
              blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);
            }
            img.src = blobURL;
            usingObjectURL = true;
          } catch (e) {
            img.src = "";
          }
          return img;
        }
      }
      noOfflineSupport();
    }
    return img;
  };
  FileTools2.ReadFile = function(file, onSuccess, onProgress, useArrayBuffer, onError) {
    var reader = new FileReader();
    var request = {
      onCompleteObservable: new Observable(),
      abort: function() {
        return reader.abort();
      }
    };
    reader.onloadend = function(e) {
      return request.onCompleteObservable.notifyObservers(request);
    };
    if (onError) {
      reader.onerror = function(e) {
        onError(new ReadFileError("Unable to read " + file.name, file));
      };
    }
    reader.onload = function(e) {
      onSuccess(e.target["result"]);
    };
    if (onProgress) {
      reader.onprogress = onProgress;
    }
    if (!useArrayBuffer) {
      reader.readAsText(file);
    } else {
      reader.readAsArrayBuffer(file);
    }
    return request;
  };
  FileTools2.LoadFile = function(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
    if (url.indexOf("file:") !== -1) {
      var fileName = decodeURIComponent(url.substring(5).toLowerCase());
      if (fileName.indexOf("./") === 0) {
        fileName = fileName.substring(2);
      }
      var file = FilesInputStore.FilesToLoad[fileName];
      if (file) {
        return FileTools2.ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError ? function(error) {
          return onError(void 0, new LoadFileError(error.message, error.file));
        } : void 0);
      }
    }
    return FileTools2.RequestFile(url, function(data, request) {
      onSuccess(data, request ? request.responseURL : void 0);
    }, onProgress, offlineProvider, useArrayBuffer, onError ? function(error) {
      onError(error.request, new LoadFileError(error.message, error.request));
    } : void 0);
  };
  FileTools2.RequestFile = function(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened) {
    url = FileTools2._CleanUrl(url);
    url = FileTools2.PreprocessUrl(url);
    var loadUrl = FileTools2.BaseUrl + url;
    var aborted = false;
    var fileRequest = {
      onCompleteObservable: new Observable(),
      abort: function() {
        return aborted = true;
      }
    };
    var requestFile = function() {
      var request = new WebRequest();
      var retryHandle = null;
      fileRequest.abort = function() {
        aborted = true;
        if (request.readyState !== (XMLHttpRequest.DONE || 4)) {
          request.abort();
        }
        if (retryHandle !== null) {
          clearTimeout(retryHandle);
          retryHandle = null;
        }
      };
      var retryLoop = function(retryIndex) {
        request.open("GET", loadUrl);
        if (onOpened) {
          onOpened(request);
        }
        if (useArrayBuffer) {
          request.responseType = "arraybuffer";
        }
        if (onProgress) {
          request.addEventListener("progress", onProgress);
        }
        var onLoadEnd = function() {
          request.removeEventListener("loadend", onLoadEnd);
          fileRequest.onCompleteObservable.notifyObservers(fileRequest);
          fileRequest.onCompleteObservable.clear();
        };
        request.addEventListener("loadend", onLoadEnd);
        var onReadyStateChange = function() {
          if (aborted) {
            return;
          }
          if (request.readyState === (XMLHttpRequest.DONE || 4)) {
            request.removeEventListener("readystatechange", onReadyStateChange);
            if (request.status >= 200 && request.status < 300 || request.status === 0 && (!DomManagement.IsWindowObjectExist() || FileTools2.IsFileURL())) {
              onSuccess(useArrayBuffer ? request.response : request.responseText, request);
              return;
            }
            var retryStrategy = FileTools2.DefaultRetryStrategy;
            if (retryStrategy) {
              var waitTime = retryStrategy(loadUrl, request, retryIndex);
              if (waitTime !== -1) {
                request.removeEventListener("loadend", onLoadEnd);
                request = new WebRequest();
                retryHandle = setTimeout(function() {
                  return retryLoop(retryIndex + 1);
                }, waitTime);
                return;
              }
            }
            var error = new RequestFileError("Error status: " + request.status + " " + request.statusText + " - Unable to load " + loadUrl, request);
            if (onError) {
              onError(error);
            }
          }
        };
        request.addEventListener("readystatechange", onReadyStateChange);
        request.send();
      };
      retryLoop(0);
    };
    if (offlineProvider && offlineProvider.enableSceneOffline) {
      var noOfflineSupport_1 = function(request) {
        if (request && request.status > 400) {
          if (onError) {
            onError(request);
          }
        } else {
          requestFile();
        }
      };
      var loadFromOfflineSupport = function() {
        if (offlineProvider) {
          offlineProvider.loadFile(FileTools2.BaseUrl + url, function(data) {
            if (!aborted) {
              onSuccess(data);
            }
            fileRequest.onCompleteObservable.notifyObservers(fileRequest);
          }, onProgress ? function(event) {
            if (!aborted) {
              onProgress(event);
            }
          } : void 0, noOfflineSupport_1, useArrayBuffer);
        }
      };
      offlineProvider.open(loadFromOfflineSupport, noOfflineSupport_1);
    } else {
      requestFile();
    }
    return fileRequest;
  };
  FileTools2.IsFileURL = function() {
    return typeof location !== "undefined" && location.protocol === "file:";
  };
  FileTools2.DefaultRetryStrategy = RetryStrategy.ExponentialBackoff();
  FileTools2.BaseUrl = "";
  FileTools2.CorsBehavior = "anonymous";
  FileTools2.PreprocessUrl = function(url) {
    return url;
  };
  return FileTools2;
}();
ThinEngine._FileToolsLoadImage = FileTools.LoadImage.bind(FileTools);
ThinEngine._FileToolsLoadFile = FileTools.LoadFile.bind(FileTools);
ShaderProcessor._FileToolsLoadFile = FileTools.LoadFile.bind(FileTools);

// node_modules/@babylonjs/core/Misc/promise.js
var PromiseStates;
(function(PromiseStates2) {
  PromiseStates2[PromiseStates2["Pending"] = 0] = "Pending";
  PromiseStates2[PromiseStates2["Fulfilled"] = 1] = "Fulfilled";
  PromiseStates2[PromiseStates2["Rejected"] = 2] = "Rejected";
})(PromiseStates || (PromiseStates = {}));
var FulFillmentAgregator = function() {
  function FulFillmentAgregator2() {
    this.count = 0;
    this.target = 0;
    this.results = [];
  }
  return FulFillmentAgregator2;
}();
var InternalPromise = function() {
  function InternalPromise2(resolver) {
    var _this = this;
    this._state = PromiseStates.Pending;
    this._children = new Array();
    this._rejectWasConsumed = false;
    if (!resolver) {
      return;
    }
    try {
      resolver(function(value) {
        _this._resolve(value);
      }, function(reason) {
        _this._reject(reason);
      });
    } catch (e) {
      this._reject(e);
    }
  }
  Object.defineProperty(InternalPromise2.prototype, "_result", {
    get: function() {
      return this._resultValue;
    },
    set: function(value) {
      this._resultValue = value;
      if (this._parent && this._parent._result === void 0) {
        this._parent._result = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  InternalPromise2.prototype.catch = function(onRejected) {
    return this.then(void 0, onRejected);
  };
  InternalPromise2.prototype.then = function(onFulfilled, onRejected) {
    var _this = this;
    var newPromise = new InternalPromise2();
    newPromise._onFulfilled = onFulfilled;
    newPromise._onRejected = onRejected;
    this._children.push(newPromise);
    newPromise._parent = this;
    if (this._state !== PromiseStates.Pending) {
      setTimeout(function() {
        if (_this._state === PromiseStates.Fulfilled || _this._rejectWasConsumed) {
          var returnedValue = newPromise._resolve(_this._result);
          if (returnedValue !== void 0 && returnedValue !== null) {
            if (returnedValue._state !== void 0) {
              var returnedPromise = returnedValue;
              newPromise._children.push(returnedPromise);
              returnedPromise._parent = newPromise;
              newPromise = returnedPromise;
            } else {
              newPromise._result = returnedValue;
            }
          }
        } else {
          newPromise._reject(_this._reason);
        }
      });
    }
    return newPromise;
  };
  InternalPromise2.prototype._moveChildren = function(children) {
    var _a;
    var _this = this;
    (_a = this._children).push.apply(_a, children.splice(0, children.length));
    this._children.forEach(function(child2) {
      child2._parent = _this;
    });
    if (this._state === PromiseStates.Fulfilled) {
      for (var _i = 0, _b = this._children; _i < _b.length; _i++) {
        var child = _b[_i];
        child._resolve(this._result);
      }
    } else if (this._state === PromiseStates.Rejected) {
      for (var _c = 0, _d = this._children; _c < _d.length; _c++) {
        var child = _d[_c];
        child._reject(this._reason);
      }
    }
  };
  InternalPromise2.prototype._resolve = function(value) {
    try {
      this._state = PromiseStates.Fulfilled;
      var returnedValue = null;
      if (this._onFulfilled) {
        returnedValue = this._onFulfilled(value);
      }
      if (returnedValue !== void 0 && returnedValue !== null) {
        if (returnedValue._state !== void 0) {
          var returnedPromise = returnedValue;
          returnedPromise._parent = this;
          returnedPromise._moveChildren(this._children);
          value = returnedPromise._result;
        } else {
          value = returnedValue;
        }
      }
      this._result = value;
      for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
        var child = _a[_i];
        child._resolve(value);
      }
      this._children.length = 0;
      delete this._onFulfilled;
      delete this._onRejected;
    } catch (e) {
      this._reject(e, true);
    }
  };
  InternalPromise2.prototype._reject = function(reason, onLocalThrow) {
    if (onLocalThrow === void 0) {
      onLocalThrow = false;
    }
    this._state = PromiseStates.Rejected;
    this._reason = reason;
    if (this._onRejected && !onLocalThrow) {
      try {
        this._onRejected(reason);
        this._rejectWasConsumed = true;
      } catch (e) {
        reason = e;
      }
    }
    for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
      var child = _a[_i];
      if (this._rejectWasConsumed) {
        child._resolve(null);
      } else {
        child._reject(reason);
      }
    }
    this._children.length = 0;
    delete this._onFulfilled;
    delete this._onRejected;
  };
  InternalPromise2.resolve = function(value) {
    var newPromise = new InternalPromise2();
    newPromise._resolve(value);
    return newPromise;
  };
  InternalPromise2._RegisterForFulfillment = function(promise, agregator, index) {
    promise.then(function(value) {
      agregator.results[index] = value;
      agregator.count++;
      if (agregator.count === agregator.target) {
        agregator.rootPromise._resolve(agregator.results);
      }
      return null;
    }, function(reason) {
      if (agregator.rootPromise._state !== PromiseStates.Rejected) {
        agregator.rootPromise._reject(reason);
      }
    });
  };
  InternalPromise2.all = function(promises) {
    var newPromise = new InternalPromise2();
    var agregator = new FulFillmentAgregator();
    agregator.target = promises.length;
    agregator.rootPromise = newPromise;
    if (promises.length) {
      for (var index = 0; index < promises.length; index++) {
        InternalPromise2._RegisterForFulfillment(promises[index], agregator, index);
      }
    } else {
      newPromise._resolve([]);
    }
    return newPromise;
  };
  InternalPromise2.race = function(promises) {
    var newPromise = new InternalPromise2();
    if (promises.length) {
      for (var _i = 0, promises_1 = promises; _i < promises_1.length; _i++) {
        var promise = promises_1[_i];
        promise.then(function(value) {
          if (newPromise) {
            newPromise._resolve(value);
            newPromise = null;
          }
          return null;
        }, function(reason) {
          if (newPromise) {
            newPromise._reject(reason);
            newPromise = null;
          }
        });
      }
    }
    return newPromise;
  };
  return InternalPromise2;
}();
var PromisePolyfill = function() {
  function PromisePolyfill2() {
  }
  PromisePolyfill2.Apply = function(force) {
    if (force === void 0) {
      force = false;
    }
    if (force || typeof Promise === "undefined") {
      var root = window;
      root.Promise = InternalPromise;
    }
  };
  return PromisePolyfill2;
}();

// node_modules/@babylonjs/core/Misc/timingTools.js
var TimingTools = function() {
  function TimingTools2() {
  }
  TimingTools2.SetImmediate = function(action) {
    if (DomManagement.IsWindowObjectExist() && window.setImmediate) {
      window.setImmediate(action);
    } else {
      setTimeout(action, 1);
    }
  };
  return TimingTools2;
}();

// node_modules/@babylonjs/core/Misc/instantiationTools.js
var InstantiationTools = function() {
  function InstantiationTools2() {
  }
  InstantiationTools2.Instantiate = function(className2) {
    if (this.RegisteredExternalClasses && this.RegisteredExternalClasses[className2]) {
      return this.RegisteredExternalClasses[className2];
    }
    var internalClass = _TypeStore.GetClass(className2);
    if (internalClass) {
      return internalClass;
    }
    Logger.Warn(className2 + " not found, you may have missed an import.");
    var arr = className2.split(".");
    var fn = window || this;
    for (var i = 0, len = arr.length; i < len; i++) {
      fn = fn[arr[i]];
    }
    if (typeof fn !== "function") {
      return null;
    }
    return fn;
  };
  InstantiationTools2.RegisteredExternalClasses = {};
  return InstantiationTools2;
}();

// node_modules/@babylonjs/core/Misc/guid.js
var GUID = function() {
  function GUID2() {
  }
  GUID2.RandomId = function() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      var r = Math.random() * 16 | 0, v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  };
  return GUID2;
}();

// node_modules/@babylonjs/core/Misc/tools.js
var Tools = function() {
  function Tools2() {
  }
  Object.defineProperty(Tools2, "BaseUrl", {
    get: function() {
      return FileTools.BaseUrl;
    },
    set: function(value) {
      FileTools.BaseUrl = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Tools2, "DefaultRetryStrategy", {
    get: function() {
      return FileTools.DefaultRetryStrategy;
    },
    set: function(strategy) {
      FileTools.DefaultRetryStrategy = strategy;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Tools2, "CorsBehavior", {
    get: function() {
      return FileTools.CorsBehavior;
    },
    set: function(value) {
      FileTools.CorsBehavior = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Tools2, "UseFallbackTexture", {
    get: function() {
      return EngineStore.UseFallbackTexture;
    },
    set: function(value) {
      EngineStore.UseFallbackTexture = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Tools2, "RegisteredExternalClasses", {
    get: function() {
      return InstantiationTools.RegisteredExternalClasses;
    },
    set: function(classes) {
      InstantiationTools.RegisteredExternalClasses = classes;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Tools2, "fallbackTexture", {
    get: function() {
      return EngineStore.FallbackTexture;
    },
    set: function(value) {
      EngineStore.FallbackTexture = value;
    },
    enumerable: false,
    configurable: true
  });
  Tools2.FetchToRef = function(u, v, width, height, pixels, color) {
    var wrappedU = Math.abs(u) * width % width | 0;
    var wrappedV = Math.abs(v) * height % height | 0;
    var position = (wrappedU + wrappedV * width) * 4;
    color.r = pixels[position] / 255;
    color.g = pixels[position + 1] / 255;
    color.b = pixels[position + 2] / 255;
    color.a = pixels[position + 3] / 255;
  };
  Tools2.Mix = function(a, b, alpha) {
    return a * (1 - alpha) + b * alpha;
  };
  Tools2.Instantiate = function(className2) {
    return InstantiationTools.Instantiate(className2);
  };
  Tools2.Slice = function(data, start, end) {
    if (data.slice) {
      return data.slice(start, end);
    }
    return Array.prototype.slice.call(data, start, end);
  };
  Tools2.SliceToArray = function(data, start, end) {
    if (Array.isArray(data)) {
      return data.slice(start, end);
    }
    return Array.prototype.slice.call(data, start, end);
  };
  Tools2.SetImmediate = function(action) {
    TimingTools.SetImmediate(action);
  };
  Tools2.IsExponentOfTwo = function(value) {
    var count = 1;
    do {
      count *= 2;
    } while (count < value);
    return count === value;
  };
  Tools2.FloatRound = function(value) {
    if (Math.fround) {
      return Math.fround(value);
    }
    return Tools2._tmpFloatArray[0] = value;
  };
  Tools2.GetFilename = function(path) {
    var index = path.lastIndexOf("/");
    if (index < 0) {
      return path;
    }
    return path.substring(index + 1);
  };
  Tools2.GetFolderPath = function(uri, returnUnchangedIfNoSlash) {
    if (returnUnchangedIfNoSlash === void 0) {
      returnUnchangedIfNoSlash = false;
    }
    var index = uri.lastIndexOf("/");
    if (index < 0) {
      if (returnUnchangedIfNoSlash) {
        return uri;
      }
      return "";
    }
    return uri.substring(0, index + 1);
  };
  Tools2.ToDegrees = function(angle) {
    return angle * 180 / Math.PI;
  };
  Tools2.ToRadians = function(angle) {
    return angle * Math.PI / 180;
  };
  Tools2.MakeArray = function(obj, allowsNullUndefined) {
    if (allowsNullUndefined !== true && (obj === void 0 || obj == null)) {
      return null;
    }
    return Array.isArray(obj) ? obj : [obj];
  };
  Tools2.GetPointerPrefix = function(engine) {
    var eventPrefix = "pointer";
    if (DomManagement.IsWindowObjectExist() && !window.PointerEvent && DomManagement.IsNavigatorAvailable() && !navigator.pointerEnabled) {
      eventPrefix = "mouse";
    }
    if (engine._badDesktopOS && !engine._badOS && !(document && "ontouchend" in document)) {
      eventPrefix = "mouse";
    }
    return eventPrefix;
  };
  Tools2.SetCorsBehavior = function(url, element) {
    FileTools.SetCorsBehavior(url, element);
  };
  Tools2.CleanUrl = function(url) {
    url = url.replace(/#/gm, "%23");
    return url;
  };
  Object.defineProperty(Tools2, "PreprocessUrl", {
    get: function() {
      return FileTools.PreprocessUrl;
    },
    set: function(processor) {
      FileTools.PreprocessUrl = processor;
    },
    enumerable: false,
    configurable: true
  });
  Tools2.LoadImage = function(input, onLoad, onError, offlineProvider, mimeType) {
    return FileTools.LoadImage(input, onLoad, onError, offlineProvider, mimeType);
  };
  Tools2.LoadFile = function(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
    return FileTools.LoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);
  };
  Tools2.LoadFileAsync = function(url, useArrayBuffer) {
    if (useArrayBuffer === void 0) {
      useArrayBuffer = true;
    }
    return new Promise(function(resolve, reject) {
      FileTools.LoadFile(url, function(data) {
        resolve(data);
      }, void 0, void 0, useArrayBuffer, function(request, exception) {
        reject(exception);
      });
    });
  };
  Tools2.LoadScript = function(scriptUrl, onSuccess, onError, scriptId) {
    if (!DomManagement.IsWindowObjectExist()) {
      return;
    }
    var head = document.getElementsByTagName("head")[0];
    var script = document.createElement("script");
    script.setAttribute("type", "text/javascript");
    script.setAttribute("src", scriptUrl);
    if (scriptId) {
      script.id = scriptId;
    }
    script.onload = function() {
      if (onSuccess) {
        onSuccess();
      }
    };
    script.onerror = function(e) {
      if (onError) {
        onError("Unable to load script '" + scriptUrl + "'", e);
      }
    };
    head.appendChild(script);
  };
  Tools2.LoadScriptAsync = function(scriptUrl, scriptId) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      _this.LoadScript(scriptUrl, function() {
        resolve();
      }, function(message, exception) {
        reject(exception);
      });
    });
  };
  Tools2.ReadFileAsDataURL = function(fileToLoad, callback, progressCallback) {
    var reader = new FileReader();
    var request = {
      onCompleteObservable: new Observable(),
      abort: function() {
        return reader.abort();
      }
    };
    reader.onloadend = function(e) {
      request.onCompleteObservable.notifyObservers(request);
    };
    reader.onload = function(e) {
      callback(e.target["result"]);
    };
    reader.onprogress = progressCallback;
    reader.readAsDataURL(fileToLoad);
    return request;
  };
  Tools2.ReadFile = function(file, onSuccess, onProgress, useArrayBuffer, onError) {
    return FileTools.ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);
  };
  Tools2.FileAsURL = function(content) {
    var fileBlob = new Blob([content]);
    var url = window.URL || window.webkitURL;
    var link = url.createObjectURL(fileBlob);
    return link;
  };
  Tools2.Format = function(value, decimals) {
    if (decimals === void 0) {
      decimals = 2;
    }
    return value.toFixed(decimals);
  };
  Tools2.DeepCopy = function(source, destination, doNotCopyList, mustCopyList) {
    DeepCopier.DeepCopy(source, destination, doNotCopyList, mustCopyList);
  };
  Tools2.IsEmpty = function(obj) {
    for (var i in obj) {
      if (obj.hasOwnProperty(i)) {
        return false;
      }
    }
    return true;
  };
  Tools2.RegisterTopRootEvents = function(windowElement, events) {
    for (var index = 0; index < events.length; index++) {
      var event = events[index];
      windowElement.addEventListener(event.name, event.handler, false);
      try {
        if (window.parent) {
          window.parent.addEventListener(event.name, event.handler, false);
        }
      } catch (e) {
      }
    }
  };
  Tools2.UnregisterTopRootEvents = function(windowElement, events) {
    for (var index = 0; index < events.length; index++) {
      var event = events[index];
      windowElement.removeEventListener(event.name, event.handler);
      try {
        if (windowElement.parent) {
          windowElement.parent.removeEventListener(event.name, event.handler);
        }
      } catch (e) {
      }
    }
  };
  Tools2.DumpFramebuffer = function(width, height, engine, successCallback, mimeType, fileName) {
    if (mimeType === void 0) {
      mimeType = "image/png";
    }
    var numberOfChannelsByLine = width * 4;
    var halfHeight = height / 2;
    var data = engine.readPixels(0, 0, width, height);
    for (var i = 0; i < halfHeight; i++) {
      for (var j = 0; j < numberOfChannelsByLine; j++) {
        var currentCell = j + i * numberOfChannelsByLine;
        var targetLine = height - i - 1;
        var targetCell = j + targetLine * numberOfChannelsByLine;
        var temp = data[currentCell];
        data[currentCell] = data[targetCell];
        data[targetCell] = temp;
      }
    }
    if (!Tools2._ScreenshotCanvas) {
      Tools2._ScreenshotCanvas = document.createElement("canvas");
    }
    Tools2._ScreenshotCanvas.width = width;
    Tools2._ScreenshotCanvas.height = height;
    var context = Tools2._ScreenshotCanvas.getContext("2d");
    if (context) {
      var imageData = context.createImageData(width, height);
      var castData = imageData.data;
      castData.set(data);
      context.putImageData(imageData, 0, 0);
      Tools2.EncodeScreenshotCanvasData(successCallback, mimeType, fileName);
    }
  };
  Tools2.ToBlob = function(canvas, successCallback, mimeType) {
    if (mimeType === void 0) {
      mimeType = "image/png";
    }
    if (!canvas.toBlob) {
      canvas.toBlob = function(callback, type, quality) {
        var _this = this;
        setTimeout(function() {
          var binStr = atob(_this.toDataURL(type, quality).split(",")[1]), len = binStr.length, arr = new Uint8Array(len);
          for (var i = 0; i < len; i++) {
            arr[i] = binStr.charCodeAt(i);
          }
          callback(new Blob([arr]));
        });
      };
    }
    canvas.toBlob(function(blob) {
      successCallback(blob);
    }, mimeType);
  };
  Tools2.EncodeScreenshotCanvasData = function(successCallback, mimeType, fileName) {
    if (mimeType === void 0) {
      mimeType = "image/png";
    }
    if (successCallback) {
      var base64Image = Tools2._ScreenshotCanvas.toDataURL(mimeType);
      successCallback(base64Image);
    } else {
      this.ToBlob(Tools2._ScreenshotCanvas, function(blob) {
        if ("download" in document.createElement("a")) {
          if (!fileName) {
            var date = new Date();
            var stringDate = (date.getFullYear() + "-" + (date.getMonth() + 1)).slice(2) + "-" + date.getDate() + "_" + date.getHours() + "-" + ("0" + date.getMinutes()).slice(-2);
            fileName = "screenshot_" + stringDate + ".png";
          }
          Tools2.Download(blob, fileName);
        } else {
          var url = URL.createObjectURL(blob);
          var newWindow = window.open("");
          if (!newWindow) {
            return;
          }
          var img = newWindow.document.createElement("img");
          img.onload = function() {
            URL.revokeObjectURL(url);
          };
          img.src = url;
          newWindow.document.body.appendChild(img);
        }
      }, mimeType);
    }
  };
  Tools2.Download = function(blob, fileName) {
    if (navigator && navigator.msSaveBlob) {
      navigator.msSaveBlob(blob, fileName);
      return;
    }
    var url = window.URL.createObjectURL(blob);
    var a = document.createElement("a");
    document.body.appendChild(a);
    a.style.display = "none";
    a.href = url;
    a.download = fileName;
    a.addEventListener("click", function() {
      if (a.parentElement) {
        a.parentElement.removeChild(a);
      }
    });
    a.click();
    window.URL.revokeObjectURL(url);
  };
  Tools2.BackCompatCameraNoPreventDefault = function(args) {
    if (typeof args[0] === "boolean") {
      return args[0];
    } else if (typeof args[1] === "boolean") {
      return args[1];
    }
    return false;
  };
  Tools2.CreateScreenshot = function(engine, camera, size, successCallback, mimeType) {
    if (mimeType === void 0) {
      mimeType = "image/png";
    }
    throw _DevTools.WarnImport("ScreenshotTools");
  };
  Tools2.CreateScreenshotAsync = function(engine, camera, size, mimeType) {
    if (mimeType === void 0) {
      mimeType = "image/png";
    }
    throw _DevTools.WarnImport("ScreenshotTools");
  };
  Tools2.CreateScreenshotUsingRenderTarget = function(engine, camera, size, successCallback, mimeType, samples, antialiasing, fileName) {
    if (mimeType === void 0) {
      mimeType = "image/png";
    }
    if (samples === void 0) {
      samples = 1;
    }
    if (antialiasing === void 0) {
      antialiasing = false;
    }
    throw _DevTools.WarnImport("ScreenshotTools");
  };
  Tools2.CreateScreenshotUsingRenderTargetAsync = function(engine, camera, size, mimeType, samples, antialiasing, fileName) {
    if (mimeType === void 0) {
      mimeType = "image/png";
    }
    if (samples === void 0) {
      samples = 1;
    }
    if (antialiasing === void 0) {
      antialiasing = false;
    }
    throw _DevTools.WarnImport("ScreenshotTools");
  };
  Tools2.RandomId = function() {
    return GUID.RandomId();
  };
  Tools2.IsBase64 = function(uri) {
    return uri.length < 5 ? false : uri.substr(0, 5) === "data:";
  };
  Tools2.DecodeBase64 = function(uri) {
    var decodedString = atob(uri.split(",")[1]);
    var bufferLength = decodedString.length;
    var bufferView = new Uint8Array(new ArrayBuffer(bufferLength));
    for (var i = 0; i < bufferLength; i++) {
      bufferView[i] = decodedString.charCodeAt(i);
    }
    return bufferView.buffer;
  };
  Tools2.GetAbsoluteUrl = function(url) {
    var a = document.createElement("a");
    a.href = url;
    return a.href;
  };
  Object.defineProperty(Tools2, "errorsCount", {
    get: function() {
      return Logger.errorsCount;
    },
    enumerable: false,
    configurable: true
  });
  Tools2.Log = function(message) {
    Logger.Log(message);
  };
  Tools2.Warn = function(message) {
    Logger.Warn(message);
  };
  Tools2.Error = function(message) {
    Logger.Error(message);
  };
  Object.defineProperty(Tools2, "LogCache", {
    get: function() {
      return Logger.LogCache;
    },
    enumerable: false,
    configurable: true
  });
  Tools2.ClearLogCache = function() {
    Logger.ClearLogCache();
  };
  Object.defineProperty(Tools2, "LogLevels", {
    set: function(level) {
      Logger.LogLevels = level;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Tools2, "PerformanceLogLevel", {
    set: function(level) {
      if ((level & Tools2.PerformanceUserMarkLogLevel) === Tools2.PerformanceUserMarkLogLevel) {
        Tools2.StartPerformanceCounter = Tools2._StartUserMark;
        Tools2.EndPerformanceCounter = Tools2._EndUserMark;
        return;
      }
      if ((level & Tools2.PerformanceConsoleLogLevel) === Tools2.PerformanceConsoleLogLevel) {
        Tools2.StartPerformanceCounter = Tools2._StartPerformanceConsole;
        Tools2.EndPerformanceCounter = Tools2._EndPerformanceConsole;
        return;
      }
      Tools2.StartPerformanceCounter = Tools2._StartPerformanceCounterDisabled;
      Tools2.EndPerformanceCounter = Tools2._EndPerformanceCounterDisabled;
    },
    enumerable: false,
    configurable: true
  });
  Tools2._StartPerformanceCounterDisabled = function(counterName, condition) {
  };
  Tools2._EndPerformanceCounterDisabled = function(counterName, condition) {
  };
  Tools2._StartUserMark = function(counterName, condition) {
    if (condition === void 0) {
      condition = true;
    }
    if (!Tools2._performance) {
      if (!DomManagement.IsWindowObjectExist()) {
        return;
      }
      Tools2._performance = window.performance;
    }
    if (!condition || !Tools2._performance.mark) {
      return;
    }
    Tools2._performance.mark(counterName + "-Begin");
  };
  Tools2._EndUserMark = function(counterName, condition) {
    if (condition === void 0) {
      condition = true;
    }
    if (!condition || !Tools2._performance.mark) {
      return;
    }
    Tools2._performance.mark(counterName + "-End");
    Tools2._performance.measure(counterName, counterName + "-Begin", counterName + "-End");
  };
  Tools2._StartPerformanceConsole = function(counterName, condition) {
    if (condition === void 0) {
      condition = true;
    }
    if (!condition) {
      return;
    }
    Tools2._StartUserMark(counterName, condition);
    if (console.time) {
      console.time(counterName);
    }
  };
  Tools2._EndPerformanceConsole = function(counterName, condition) {
    if (condition === void 0) {
      condition = true;
    }
    if (!condition) {
      return;
    }
    Tools2._EndUserMark(counterName, condition);
    console.timeEnd(counterName);
  };
  Object.defineProperty(Tools2, "Now", {
    get: function() {
      return PrecisionDate.Now;
    },
    enumerable: false,
    configurable: true
  });
  Tools2.GetClassName = function(object, isType) {
    if (isType === void 0) {
      isType = false;
    }
    var name45 = null;
    if (!isType && object.getClassName) {
      name45 = object.getClassName();
    } else {
      if (object instanceof Object) {
        var classObj = isType ? object : Object.getPrototypeOf(object);
        name45 = classObj.constructor["__bjsclassName__"];
      }
      if (!name45) {
        name45 = typeof object;
      }
    }
    return name45;
  };
  Tools2.First = function(array, predicate) {
    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
      var el = array_1[_i];
      if (predicate(el)) {
        return el;
      }
    }
    return null;
  };
  Tools2.getFullClassName = function(object, isType) {
    if (isType === void 0) {
      isType = false;
    }
    var className2 = null;
    var moduleName = null;
    if (!isType && object.getClassName) {
      className2 = object.getClassName();
    } else {
      if (object instanceof Object) {
        var classObj = isType ? object : Object.getPrototypeOf(object);
        className2 = classObj.constructor["__bjsclassName__"];
        moduleName = classObj.constructor["__bjsmoduleName__"];
      }
      if (!className2) {
        className2 = typeof object;
      }
    }
    if (!className2) {
      return null;
    }
    return (moduleName != null ? moduleName + "." : "") + className2;
  };
  Tools2.DelayAsync = function(delay) {
    return new Promise(function(resolve) {
      setTimeout(function() {
        resolve();
      }, delay);
    });
  };
  Tools2.IsSafari = function() {
    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  };
  Tools2.UseCustomRequestHeaders = false;
  Tools2.CustomRequestHeaders = WebRequest.CustomRequestHeaders;
  Tools2._tmpFloatArray = new Float32Array(1);
  Tools2.GetDOMTextContent = DomManagement.GetDOMTextContent;
  Tools2.NoneLogLevel = Logger.NoneLogLevel;
  Tools2.MessageLogLevel = Logger.MessageLogLevel;
  Tools2.WarningLogLevel = Logger.WarningLogLevel;
  Tools2.ErrorLogLevel = Logger.ErrorLogLevel;
  Tools2.AllLogLevel = Logger.AllLogLevel;
  Tools2.IsWindowObjectExist = DomManagement.IsWindowObjectExist;
  Tools2.PerformanceNoneLogLevel = 0;
  Tools2.PerformanceUserMarkLogLevel = 1;
  Tools2.PerformanceConsoleLogLevel = 2;
  Tools2.StartPerformanceCounter = Tools2._StartPerformanceCounterDisabled;
  Tools2.EndPerformanceCounter = Tools2._EndPerformanceCounterDisabled;
  return Tools2;
}();
function className(name45, module) {
  return function(target) {
    target["__bjsclassName__"] = name45;
    target["__bjsmoduleName__"] = module != null ? module : null;
  };
}
var AsyncLoop = function() {
  function AsyncLoop2(iterations, func, successCallback, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    this.iterations = iterations;
    this.index = offset - 1;
    this._done = false;
    this._fn = func;
    this._successCallback = successCallback;
  }
  AsyncLoop2.prototype.executeNext = function() {
    if (!this._done) {
      if (this.index + 1 < this.iterations) {
        ++this.index;
        this._fn(this);
      } else {
        this.breakLoop();
      }
    }
  };
  AsyncLoop2.prototype.breakLoop = function() {
    this._done = true;
    this._successCallback();
  };
  AsyncLoop2.Run = function(iterations, fn, successCallback, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    var loop = new AsyncLoop2(iterations, fn, successCallback, offset);
    loop.executeNext();
    return loop;
  };
  AsyncLoop2.SyncAsyncForLoop = function(iterations, syncedIterations, fn, callback, breakFunction, timeout) {
    if (timeout === void 0) {
      timeout = 0;
    }
    return AsyncLoop2.Run(Math.ceil(iterations / syncedIterations), function(loop) {
      if (breakFunction && breakFunction()) {
        loop.breakLoop();
      } else {
        setTimeout(function() {
          for (var i = 0; i < syncedIterations; ++i) {
            var iteration = loop.index * syncedIterations + i;
            if (iteration >= iterations) {
              break;
            }
            fn(iteration);
            if (breakFunction && breakFunction()) {
              loop.breakLoop();
              break;
            }
          }
          loop.executeNext();
        }, timeout);
      }
    }, callback);
  };
  return AsyncLoop2;
}();
EngineStore.FallbackTexture = "data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAAQAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDQuMC41AP/bAEMABAIDAwMCBAMDAwQEBAQFCQYFBQUFCwgIBgkNCw0NDQsMDA4QFBEODxMPDAwSGBITFRYXFxcOERkbGRYaFBYXFv/bAEMBBAQEBQUFCgYGChYPDA8WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFv/AABEIAQABAAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APH6KKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76P//Z";
PromisePolyfill.Apply();

// node_modules/@babylonjs/core/Misc/smartArray.js
var SmartArray = function() {
  function SmartArray2(capacity) {
    this.length = 0;
    this.data = new Array(capacity);
    this._id = SmartArray2._GlobalId++;
  }
  SmartArray2.prototype.push = function(value) {
    this.data[this.length++] = value;
    if (this.length > this.data.length) {
      this.data.length *= 2;
    }
  };
  SmartArray2.prototype.forEach = function(func) {
    for (var index = 0; index < this.length; index++) {
      func(this.data[index]);
    }
  };
  SmartArray2.prototype.sort = function(compareFn) {
    this.data.sort(compareFn);
  };
  SmartArray2.prototype.reset = function() {
    this.length = 0;
  };
  SmartArray2.prototype.dispose = function() {
    this.reset();
    if (this.data) {
      this.data.length = 0;
      this.data = [];
    }
  };
  SmartArray2.prototype.concat = function(array) {
    if (array.length === 0) {
      return;
    }
    if (this.length + array.length > this.data.length) {
      this.data.length = (this.length + array.length) * 2;
    }
    for (var index = 0; index < array.length; index++) {
      this.data[this.length++] = (array.data || array)[index];
    }
  };
  SmartArray2.prototype.indexOf = function(value) {
    var position = this.data.indexOf(value);
    if (position >= this.length) {
      return -1;
    }
    return position;
  };
  SmartArray2.prototype.contains = function(value) {
    return this.indexOf(value) !== -1;
  };
  SmartArray2._GlobalId = 0;
  return SmartArray2;
}();
var SmartArrayNoDuplicate = function(_super) {
  __extends(SmartArrayNoDuplicate2, _super);
  function SmartArrayNoDuplicate2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._duplicateId = 0;
    return _this;
  }
  SmartArrayNoDuplicate2.prototype.push = function(value) {
    _super.prototype.push.call(this, value);
    if (!value.__smartArrayFlags) {
      value.__smartArrayFlags = {};
    }
    value.__smartArrayFlags[this._id] = this._duplicateId;
  };
  SmartArrayNoDuplicate2.prototype.pushNoDuplicate = function(value) {
    if (value.__smartArrayFlags && value.__smartArrayFlags[this._id] === this._duplicateId) {
      return false;
    }
    this.push(value);
    return true;
  };
  SmartArrayNoDuplicate2.prototype.reset = function() {
    _super.prototype.reset.call(this);
    this._duplicateId++;
  };
  SmartArrayNoDuplicate2.prototype.concatWithNoDuplicate = function(array) {
    if (array.length === 0) {
      return;
    }
    if (this.length + array.length > this.data.length) {
      this.data.length = (this.length + array.length) * 2;
    }
    for (var index = 0; index < array.length; index++) {
      var item = (array.data || array)[index];
      this.pushNoDuplicate(item);
    }
  };
  return SmartArrayNoDuplicate2;
}(SmartArray);

// node_modules/@babylonjs/core/Misc/stringDictionary.js
var StringDictionary = function() {
  function StringDictionary2() {
    this._count = 0;
    this._data = {};
  }
  StringDictionary2.prototype.copyFrom = function(source) {
    var _this = this;
    this.clear();
    source.forEach(function(t, v) {
      return _this.add(t, v);
    });
  };
  StringDictionary2.prototype.get = function(key) {
    var val = this._data[key];
    if (val !== void 0) {
      return val;
    }
    return void 0;
  };
  StringDictionary2.prototype.getOrAddWithFactory = function(key, factory) {
    var val = this.get(key);
    if (val !== void 0) {
      return val;
    }
    val = factory(key);
    if (val) {
      this.add(key, val);
    }
    return val;
  };
  StringDictionary2.prototype.getOrAdd = function(key, val) {
    var curVal = this.get(key);
    if (curVal !== void 0) {
      return curVal;
    }
    this.add(key, val);
    return val;
  };
  StringDictionary2.prototype.contains = function(key) {
    return this._data[key] !== void 0;
  };
  StringDictionary2.prototype.add = function(key, value) {
    if (this._data[key] !== void 0) {
      return false;
    }
    this._data[key] = value;
    ++this._count;
    return true;
  };
  StringDictionary2.prototype.set = function(key, value) {
    if (this._data[key] === void 0) {
      return false;
    }
    this._data[key] = value;
    return true;
  };
  StringDictionary2.prototype.getAndRemove = function(key) {
    var val = this.get(key);
    if (val !== void 0) {
      delete this._data[key];
      --this._count;
      return val;
    }
    return null;
  };
  StringDictionary2.prototype.remove = function(key) {
    if (this.contains(key)) {
      delete this._data[key];
      --this._count;
      return true;
    }
    return false;
  };
  StringDictionary2.prototype.clear = function() {
    this._data = {};
    this._count = 0;
  };
  Object.defineProperty(StringDictionary2.prototype, "count", {
    get: function() {
      return this._count;
    },
    enumerable: false,
    configurable: true
  });
  StringDictionary2.prototype.forEach = function(callback) {
    for (var cur in this._data) {
      var val = this._data[cur];
      callback(cur, val);
    }
  };
  StringDictionary2.prototype.first = function(callback) {
    for (var cur in this._data) {
      var val = this._data[cur];
      var res = callback(cur, val);
      if (res) {
        return res;
      }
    }
    return null;
  };
  return StringDictionary2;
}();

// node_modules/@babylonjs/core/Maths/math.axis.js
var Space;
(function(Space2) {
  Space2[Space2["LOCAL"] = 0] = "LOCAL";
  Space2[Space2["WORLD"] = 1] = "WORLD";
  Space2[Space2["BONE"] = 2] = "BONE";
})(Space || (Space = {}));
var Axis = function() {
  function Axis2() {
  }
  Axis2.X = new Vector3(1, 0, 0);
  Axis2.Y = new Vector3(0, 1, 0);
  Axis2.Z = new Vector3(0, 0, 1);
  return Axis2;
}();
var Coordinate;
(function(Coordinate2) {
  Coordinate2[Coordinate2["X"] = 0] = "X";
  Coordinate2[Coordinate2["Y"] = 1] = "Y";
  Coordinate2[Coordinate2["Z"] = 2] = "Z";
})(Coordinate || (Coordinate = {}));

// node_modules/@babylonjs/core/Meshes/transformNode.js
var TransformNode = function(_super) {
  __extends(TransformNode2, _super);
  function TransformNode2(name45, scene, isPure) {
    if (scene === void 0) {
      scene = null;
    }
    if (isPure === void 0) {
      isPure = true;
    }
    var _this = _super.call(this, name45, scene) || this;
    _this._forward = new Vector3(0, 0, 1);
    _this._forwardInverted = new Vector3(0, 0, -1);
    _this._up = new Vector3(0, 1, 0);
    _this._right = new Vector3(1, 0, 0);
    _this._rightInverted = new Vector3(-1, 0, 0);
    _this._position = Vector3.Zero();
    _this._rotation = Vector3.Zero();
    _this._rotationQuaternion = null;
    _this._scaling = Vector3.One();
    _this._isDirty = false;
    _this._transformToBoneReferal = null;
    _this._isAbsoluteSynced = false;
    _this._billboardMode = TransformNode2.BILLBOARDMODE_NONE;
    _this._preserveParentRotationForBillboard = false;
    _this.scalingDeterminant = 1;
    _this._infiniteDistance = false;
    _this.ignoreNonUniformScaling = false;
    _this.reIntegrateRotationIntoRotationQuaternion = false;
    _this._poseMatrix = null;
    _this._localMatrix = Matrix.Zero();
    _this._usePivotMatrix = false;
    _this._absolutePosition = Vector3.Zero();
    _this._absoluteScaling = Vector3.Zero();
    _this._absoluteRotationQuaternion = Quaternion.Identity();
    _this._pivotMatrix = Matrix.Identity();
    _this._postMultiplyPivotMatrix = false;
    _this._isWorldMatrixFrozen = false;
    _this._indexInSceneTransformNodesArray = -1;
    _this.onAfterWorldMatrixUpdateObservable = new Observable();
    _this._nonUniformScaling = false;
    if (isPure) {
      _this.getScene().addTransformNode(_this);
    }
    return _this;
  }
  Object.defineProperty(TransformNode2.prototype, "billboardMode", {
    get: function() {
      return this._billboardMode;
    },
    set: function(value) {
      if (this._billboardMode === value) {
        return;
      }
      this._billboardMode = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformNode2.prototype, "preserveParentRotationForBillboard", {
    get: function() {
      return this._preserveParentRotationForBillboard;
    },
    set: function(value) {
      if (value === this._preserveParentRotationForBillboard) {
        return;
      }
      this._preserveParentRotationForBillboard = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformNode2.prototype, "infiniteDistance", {
    get: function() {
      return this._infiniteDistance;
    },
    set: function(value) {
      if (this._infiniteDistance === value) {
        return;
      }
      this._infiniteDistance = value;
    },
    enumerable: false,
    configurable: true
  });
  TransformNode2.prototype.getClassName = function() {
    return "TransformNode";
  };
  Object.defineProperty(TransformNode2.prototype, "position", {
    get: function() {
      return this._position;
    },
    set: function(newPosition) {
      this._position = newPosition;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformNode2.prototype, "rotation", {
    get: function() {
      return this._rotation;
    },
    set: function(newRotation) {
      this._rotation = newRotation;
      this._rotationQuaternion = null;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformNode2.prototype, "scaling", {
    get: function() {
      return this._scaling;
    },
    set: function(newScaling) {
      this._scaling = newScaling;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformNode2.prototype, "rotationQuaternion", {
    get: function() {
      return this._rotationQuaternion;
    },
    set: function(quaternion) {
      this._rotationQuaternion = quaternion;
      if (quaternion) {
        this._rotation.setAll(0);
      }
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformNode2.prototype, "forward", {
    get: function() {
      return Vector3.Normalize(Vector3.TransformNormal(this.getScene().useRightHandedSystem ? this._forwardInverted : this._forward, this.getWorldMatrix()));
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformNode2.prototype, "up", {
    get: function() {
      return Vector3.Normalize(Vector3.TransformNormal(this._up, this.getWorldMatrix()));
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformNode2.prototype, "right", {
    get: function() {
      return Vector3.Normalize(Vector3.TransformNormal(this.getScene().useRightHandedSystem ? this._rightInverted : this._right, this.getWorldMatrix()));
    },
    enumerable: false,
    configurable: true
  });
  TransformNode2.prototype.updatePoseMatrix = function(matrix) {
    if (!this._poseMatrix) {
      this._poseMatrix = matrix.clone();
      return this;
    }
    this._poseMatrix.copyFrom(matrix);
    return this;
  };
  TransformNode2.prototype.getPoseMatrix = function() {
    if (!this._poseMatrix) {
      this._poseMatrix = Matrix.Identity();
    }
    return this._poseMatrix;
  };
  TransformNode2.prototype._isSynchronized = function() {
    var cache = this._cache;
    if (this.billboardMode !== cache.billboardMode || this.billboardMode !== TransformNode2.BILLBOARDMODE_NONE) {
      return false;
    }
    if (cache.pivotMatrixUpdated) {
      return false;
    }
    if (this.infiniteDistance) {
      return false;
    }
    if (this.position._isDirty) {
      return false;
    }
    if (this.scaling._isDirty) {
      return false;
    }
    if (this._rotationQuaternion && this._rotationQuaternion._isDirty || this.rotation._isDirty) {
      return false;
    }
    return true;
  };
  TransformNode2.prototype._initCache = function() {
    _super.prototype._initCache.call(this);
    var cache = this._cache;
    cache.localMatrixUpdated = false;
    cache.billboardMode = -1;
    cache.infiniteDistance = false;
  };
  TransformNode2.prototype.markAsDirty = function(property) {
    this._currentRenderId = Number.MAX_VALUE;
    this._isDirty = true;
    return this;
  };
  Object.defineProperty(TransformNode2.prototype, "absolutePosition", {
    get: function() {
      return this._absolutePosition;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformNode2.prototype, "absoluteScaling", {
    get: function() {
      this._syncAbsoluteScalingAndRotation();
      return this._absoluteScaling;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformNode2.prototype, "absoluteRotationQuaternion", {
    get: function() {
      this._syncAbsoluteScalingAndRotation();
      return this._absoluteRotationQuaternion;
    },
    enumerable: false,
    configurable: true
  });
  TransformNode2.prototype.setPreTransformMatrix = function(matrix) {
    return this.setPivotMatrix(matrix, false);
  };
  TransformNode2.prototype.setPivotMatrix = function(matrix, postMultiplyPivotMatrix) {
    if (postMultiplyPivotMatrix === void 0) {
      postMultiplyPivotMatrix = true;
    }
    this._pivotMatrix.copyFrom(matrix);
    this._usePivotMatrix = !this._pivotMatrix.isIdentity();
    this._cache.pivotMatrixUpdated = true;
    this._postMultiplyPivotMatrix = postMultiplyPivotMatrix;
    if (this._postMultiplyPivotMatrix) {
      if (!this._pivotMatrixInverse) {
        this._pivotMatrixInverse = Matrix.Invert(this._pivotMatrix);
      } else {
        this._pivotMatrix.invertToRef(this._pivotMatrixInverse);
      }
    }
    return this;
  };
  TransformNode2.prototype.getPivotMatrix = function() {
    return this._pivotMatrix;
  };
  TransformNode2.prototype.instantiateHierarchy = function(newParent, options, onNewNodeCreated) {
    if (newParent === void 0) {
      newParent = null;
    }
    var clone = this.clone("Clone of " + (this.name || this.id), newParent || this.parent, true);
    if (clone) {
      if (onNewNodeCreated) {
        onNewNodeCreated(this, clone);
      }
    }
    for (var _i = 0, _a = this.getChildTransformNodes(true); _i < _a.length; _i++) {
      var child = _a[_i];
      child.instantiateHierarchy(clone, options, onNewNodeCreated);
    }
    return clone;
  };
  TransformNode2.prototype.freezeWorldMatrix = function(newWorldMatrix) {
    if (newWorldMatrix === void 0) {
      newWorldMatrix = null;
    }
    if (newWorldMatrix) {
      this._worldMatrix = newWorldMatrix;
    } else {
      this._isWorldMatrixFrozen = false;
      this.computeWorldMatrix(true);
    }
    this._isDirty = false;
    this._isWorldMatrixFrozen = true;
    return this;
  };
  TransformNode2.prototype.unfreezeWorldMatrix = function() {
    this._isWorldMatrixFrozen = false;
    this.computeWorldMatrix(true);
    return this;
  };
  Object.defineProperty(TransformNode2.prototype, "isWorldMatrixFrozen", {
    get: function() {
      return this._isWorldMatrixFrozen;
    },
    enumerable: false,
    configurable: true
  });
  TransformNode2.prototype.getAbsolutePosition = function() {
    this.computeWorldMatrix();
    return this._absolutePosition;
  };
  TransformNode2.prototype.setAbsolutePosition = function(absolutePosition) {
    if (!absolutePosition) {
      return this;
    }
    var absolutePositionX;
    var absolutePositionY;
    var absolutePositionZ;
    if (absolutePosition.x === void 0) {
      if (arguments.length < 3) {
        return this;
      }
      absolutePositionX = arguments[0];
      absolutePositionY = arguments[1];
      absolutePositionZ = arguments[2];
    } else {
      absolutePositionX = absolutePosition.x;
      absolutePositionY = absolutePosition.y;
      absolutePositionZ = absolutePosition.z;
    }
    if (this.parent) {
      var invertParentWorldMatrix = TmpVectors.Matrix[0];
      this.parent.getWorldMatrix().invertToRef(invertParentWorldMatrix);
      Vector3.TransformCoordinatesFromFloatsToRef(absolutePositionX, absolutePositionY, absolutePositionZ, invertParentWorldMatrix, this.position);
    } else {
      this.position.x = absolutePositionX;
      this.position.y = absolutePositionY;
      this.position.z = absolutePositionZ;
    }
    this._absolutePosition.copyFrom(absolutePosition);
    return this;
  };
  TransformNode2.prototype.setPositionWithLocalVector = function(vector3) {
    this.computeWorldMatrix();
    this.position = Vector3.TransformNormal(vector3, this._localMatrix);
    return this;
  };
  TransformNode2.prototype.getPositionExpressedInLocalSpace = function() {
    this.computeWorldMatrix();
    var invLocalWorldMatrix = TmpVectors.Matrix[0];
    this._localMatrix.invertToRef(invLocalWorldMatrix);
    return Vector3.TransformNormal(this.position, invLocalWorldMatrix);
  };
  TransformNode2.prototype.locallyTranslate = function(vector3) {
    this.computeWorldMatrix(true);
    this.position = Vector3.TransformCoordinates(vector3, this._localMatrix);
    return this;
  };
  TransformNode2.prototype.lookAt = function(targetPoint, yawCor, pitchCor, rollCor, space) {
    if (yawCor === void 0) {
      yawCor = 0;
    }
    if (pitchCor === void 0) {
      pitchCor = 0;
    }
    if (rollCor === void 0) {
      rollCor = 0;
    }
    if (space === void 0) {
      space = Space.LOCAL;
    }
    var dv = TransformNode2._lookAtVectorCache;
    var pos = space === Space.LOCAL ? this.position : this.getAbsolutePosition();
    targetPoint.subtractToRef(pos, dv);
    this.setDirection(dv, yawCor, pitchCor, rollCor);
    if (space === Space.WORLD && this.parent) {
      if (this.rotationQuaternion) {
        var rotationMatrix = TmpVectors.Matrix[0];
        this.rotationQuaternion.toRotationMatrix(rotationMatrix);
        var parentRotationMatrix = TmpVectors.Matrix[1];
        this.parent.getWorldMatrix().getRotationMatrixToRef(parentRotationMatrix);
        parentRotationMatrix.invert();
        rotationMatrix.multiplyToRef(parentRotationMatrix, rotationMatrix);
        this.rotationQuaternion.fromRotationMatrix(rotationMatrix);
      } else {
        var quaternionRotation = TmpVectors.Quaternion[0];
        Quaternion.FromEulerVectorToRef(this.rotation, quaternionRotation);
        var rotationMatrix = TmpVectors.Matrix[0];
        quaternionRotation.toRotationMatrix(rotationMatrix);
        var parentRotationMatrix = TmpVectors.Matrix[1];
        this.parent.getWorldMatrix().getRotationMatrixToRef(parentRotationMatrix);
        parentRotationMatrix.invert();
        rotationMatrix.multiplyToRef(parentRotationMatrix, rotationMatrix);
        quaternionRotation.fromRotationMatrix(rotationMatrix);
        quaternionRotation.toEulerAnglesToRef(this.rotation);
      }
    }
    return this;
  };
  TransformNode2.prototype.getDirection = function(localAxis) {
    var result = Vector3.Zero();
    this.getDirectionToRef(localAxis, result);
    return result;
  };
  TransformNode2.prototype.getDirectionToRef = function(localAxis, result) {
    Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);
    return this;
  };
  TransformNode2.prototype.setDirection = function(localAxis, yawCor, pitchCor, rollCor) {
    if (yawCor === void 0) {
      yawCor = 0;
    }
    if (pitchCor === void 0) {
      pitchCor = 0;
    }
    if (rollCor === void 0) {
      rollCor = 0;
    }
    var yaw = -Math.atan2(localAxis.z, localAxis.x) + Math.PI / 2;
    var len = Math.sqrt(localAxis.x * localAxis.x + localAxis.z * localAxis.z);
    var pitch = -Math.atan2(localAxis.y, len);
    if (this.rotationQuaternion) {
      Quaternion.RotationYawPitchRollToRef(yaw + yawCor, pitch + pitchCor, rollCor, this.rotationQuaternion);
    } else {
      this.rotation.x = pitch + pitchCor;
      this.rotation.y = yaw + yawCor;
      this.rotation.z = rollCor;
    }
    return this;
  };
  TransformNode2.prototype.setPivotPoint = function(point, space) {
    if (space === void 0) {
      space = Space.LOCAL;
    }
    if (this.getScene().getRenderId() == 0) {
      this.computeWorldMatrix(true);
    }
    var wm = this.getWorldMatrix();
    if (space == Space.WORLD) {
      var tmat = TmpVectors.Matrix[0];
      wm.invertToRef(tmat);
      point = Vector3.TransformCoordinates(point, tmat);
    }
    return this.setPivotMatrix(Matrix.Translation(-point.x, -point.y, -point.z), true);
  };
  TransformNode2.prototype.getPivotPoint = function() {
    var point = Vector3.Zero();
    this.getPivotPointToRef(point);
    return point;
  };
  TransformNode2.prototype.getPivotPointToRef = function(result) {
    result.x = -this._pivotMatrix.m[12];
    result.y = -this._pivotMatrix.m[13];
    result.z = -this._pivotMatrix.m[14];
    return this;
  };
  TransformNode2.prototype.getAbsolutePivotPoint = function() {
    var point = Vector3.Zero();
    this.getAbsolutePivotPointToRef(point);
    return point;
  };
  TransformNode2.prototype.getAbsolutePivotPointToRef = function(result) {
    this.getPivotPointToRef(result);
    Vector3.TransformCoordinatesToRef(result, this.getWorldMatrix(), result);
    return this;
  };
  TransformNode2.prototype.setParent = function(node) {
    if (!node && !this.parent) {
      return this;
    }
    var quatRotation = TmpVectors.Quaternion[0];
    var position = TmpVectors.Vector3[0];
    var scale = TmpVectors.Vector3[1];
    if (!node) {
      this.computeWorldMatrix(true);
      this.getWorldMatrix().decompose(scale, quatRotation, position);
    } else {
      var diffMatrix = TmpVectors.Matrix[0];
      var invParentMatrix = TmpVectors.Matrix[1];
      this.computeWorldMatrix(true);
      node.computeWorldMatrix(true);
      node.getWorldMatrix().invertToRef(invParentMatrix);
      this.getWorldMatrix().multiplyToRef(invParentMatrix, diffMatrix);
      diffMatrix.decompose(scale, quatRotation, position);
    }
    if (this.rotationQuaternion) {
      this.rotationQuaternion.copyFrom(quatRotation);
    } else {
      quatRotation.toEulerAnglesToRef(this.rotation);
    }
    this.scaling.copyFrom(scale);
    this.position.copyFrom(position);
    this.parent = node;
    return this;
  };
  Object.defineProperty(TransformNode2.prototype, "nonUniformScaling", {
    get: function() {
      return this._nonUniformScaling;
    },
    enumerable: false,
    configurable: true
  });
  TransformNode2.prototype._updateNonUniformScalingState = function(value) {
    if (this._nonUniformScaling === value) {
      return false;
    }
    this._nonUniformScaling = value;
    return true;
  };
  TransformNode2.prototype.attachToBone = function(bone, affectedTransformNode) {
    this._transformToBoneReferal = affectedTransformNode;
    this.parent = bone;
    bone.getSkeleton().prepare();
    if (bone.getWorldMatrix().determinant() < 0) {
      this.scalingDeterminant *= -1;
    }
    return this;
  };
  TransformNode2.prototype.detachFromBone = function() {
    if (!this.parent) {
      return this;
    }
    if (this.parent.getWorldMatrix().determinant() < 0) {
      this.scalingDeterminant *= -1;
    }
    this._transformToBoneReferal = null;
    this.parent = null;
    return this;
  };
  TransformNode2.prototype.rotate = function(axis, amount, space) {
    axis.normalize();
    if (!this.rotationQuaternion) {
      this.rotationQuaternion = this.rotation.toQuaternion();
      this.rotation.setAll(0);
    }
    var rotationQuaternion;
    if (!space || space === Space.LOCAL) {
      rotationQuaternion = Quaternion.RotationAxisToRef(axis, amount, TransformNode2._rotationAxisCache);
      this.rotationQuaternion.multiplyToRef(rotationQuaternion, this.rotationQuaternion);
    } else {
      if (this.parent) {
        var invertParentWorldMatrix = TmpVectors.Matrix[0];
        this.parent.getWorldMatrix().invertToRef(invertParentWorldMatrix);
        axis = Vector3.TransformNormal(axis, invertParentWorldMatrix);
      }
      rotationQuaternion = Quaternion.RotationAxisToRef(axis, amount, TransformNode2._rotationAxisCache);
      rotationQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);
    }
    return this;
  };
  TransformNode2.prototype.rotateAround = function(point, axis, amount) {
    axis.normalize();
    if (!this.rotationQuaternion) {
      this.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);
      this.rotation.setAll(0);
    }
    var tmpVector = TmpVectors.Vector3[0];
    var finalScale = TmpVectors.Vector3[1];
    var finalTranslation = TmpVectors.Vector3[2];
    var finalRotation = TmpVectors.Quaternion[0];
    var translationMatrix = TmpVectors.Matrix[0];
    var translationMatrixInv = TmpVectors.Matrix[1];
    var rotationMatrix = TmpVectors.Matrix[2];
    var finalMatrix = TmpVectors.Matrix[3];
    point.subtractToRef(this.position, tmpVector);
    Matrix.TranslationToRef(tmpVector.x, tmpVector.y, tmpVector.z, translationMatrix);
    Matrix.TranslationToRef(-tmpVector.x, -tmpVector.y, -tmpVector.z, translationMatrixInv);
    Matrix.RotationAxisToRef(axis, amount, rotationMatrix);
    translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix);
    finalMatrix.multiplyToRef(translationMatrix, finalMatrix);
    finalMatrix.decompose(finalScale, finalRotation, finalTranslation);
    this.position.addInPlace(finalTranslation);
    finalRotation.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);
    return this;
  };
  TransformNode2.prototype.translate = function(axis, distance, space) {
    var displacementVector = axis.scale(distance);
    if (!space || space === Space.LOCAL) {
      var tempV3 = this.getPositionExpressedInLocalSpace().add(displacementVector);
      this.setPositionWithLocalVector(tempV3);
    } else {
      this.setAbsolutePosition(this.getAbsolutePosition().add(displacementVector));
    }
    return this;
  };
  TransformNode2.prototype.addRotation = function(x, y, z) {
    var rotationQuaternion;
    if (this.rotationQuaternion) {
      rotationQuaternion = this.rotationQuaternion;
    } else {
      rotationQuaternion = TmpVectors.Quaternion[1];
      Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, rotationQuaternion);
    }
    var accumulation = TmpVectors.Quaternion[0];
    Quaternion.RotationYawPitchRollToRef(y, x, z, accumulation);
    rotationQuaternion.multiplyInPlace(accumulation);
    if (!this.rotationQuaternion) {
      rotationQuaternion.toEulerAnglesToRef(this.rotation);
    }
    return this;
  };
  TransformNode2.prototype._getEffectiveParent = function() {
    return this.parent;
  };
  TransformNode2.prototype.computeWorldMatrix = function(force) {
    if (this._isWorldMatrixFrozen && !this._isDirty) {
      return this._worldMatrix;
    }
    var currentRenderId = this.getScene().getRenderId();
    if (!this._isDirty && !force && this.isSynchronized()) {
      this._currentRenderId = currentRenderId;
      return this._worldMatrix;
    }
    var camera = this.getScene().activeCamera;
    var useBillboardPosition = (this._billboardMode & TransformNode2.BILLBOARDMODE_USE_POSITION) !== 0;
    var useBillboardPath = this._billboardMode !== TransformNode2.BILLBOARDMODE_NONE && !this.preserveParentRotationForBillboard;
    if (useBillboardPath && camera && useBillboardPosition) {
      this.lookAt(camera.position);
      if ((this.billboardMode & TransformNode2.BILLBOARDMODE_X) !== TransformNode2.BILLBOARDMODE_X) {
        this.rotation.x = 0;
      }
      if ((this.billboardMode & TransformNode2.BILLBOARDMODE_Y) !== TransformNode2.BILLBOARDMODE_Y) {
        this.rotation.y = 0;
      }
      if ((this.billboardMode & TransformNode2.BILLBOARDMODE_Z) !== TransformNode2.BILLBOARDMODE_Z) {
        this.rotation.z = 0;
      }
    }
    this._updateCache();
    var cache = this._cache;
    cache.pivotMatrixUpdated = false;
    cache.billboardMode = this.billboardMode;
    cache.infiniteDistance = this.infiniteDistance;
    this._currentRenderId = currentRenderId;
    this._childUpdateId++;
    this._isDirty = false;
    this._position._isDirty = false;
    this._rotation._isDirty = false;
    this._scaling._isDirty = false;
    var parent = this._getEffectiveParent();
    var scaling = TransformNode2._TmpScaling;
    var translation = this._position;
    if (this._infiniteDistance) {
      if (!this.parent && camera) {
        var cameraWorldMatrix = camera.getWorldMatrix();
        var cameraGlobalPosition = new Vector3(cameraWorldMatrix.m[12], cameraWorldMatrix.m[13], cameraWorldMatrix.m[14]);
        translation = TransformNode2._TmpTranslation;
        translation.copyFromFloats(this._position.x + cameraGlobalPosition.x, this._position.y + cameraGlobalPosition.y, this._position.z + cameraGlobalPosition.z);
      }
    }
    scaling.copyFromFloats(this._scaling.x * this.scalingDeterminant, this._scaling.y * this.scalingDeterminant, this._scaling.z * this.scalingDeterminant);
    var rotation;
    if (this._rotationQuaternion) {
      this._rotationQuaternion._isDirty = false;
      rotation = this._rotationQuaternion;
      if (this.reIntegrateRotationIntoRotationQuaternion) {
        var len = this.rotation.lengthSquared();
        if (len) {
          this._rotationQuaternion.multiplyInPlace(Quaternion.RotationYawPitchRoll(this._rotation.y, this._rotation.x, this._rotation.z));
          this._rotation.copyFromFloats(0, 0, 0);
        }
      }
    } else {
      rotation = TransformNode2._TmpRotation;
      Quaternion.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, rotation);
    }
    if (this._usePivotMatrix) {
      var scaleMatrix = TmpVectors.Matrix[1];
      Matrix.ScalingToRef(scaling.x, scaling.y, scaling.z, scaleMatrix);
      var rotationMatrix = TmpVectors.Matrix[0];
      rotation.toRotationMatrix(rotationMatrix);
      this._pivotMatrix.multiplyToRef(scaleMatrix, TmpVectors.Matrix[4]);
      TmpVectors.Matrix[4].multiplyToRef(rotationMatrix, this._localMatrix);
      if (this._postMultiplyPivotMatrix) {
        this._localMatrix.multiplyToRef(this._pivotMatrixInverse, this._localMatrix);
      }
      this._localMatrix.addTranslationFromFloats(translation.x, translation.y, translation.z);
    } else {
      Matrix.ComposeToRef(scaling, rotation, translation, this._localMatrix);
    }
    if (parent && parent.getWorldMatrix) {
      if (force) {
        parent.computeWorldMatrix();
      }
      if (useBillboardPath) {
        if (this._transformToBoneReferal) {
          parent.getWorldMatrix().multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), TmpVectors.Matrix[7]);
        } else {
          TmpVectors.Matrix[7].copyFrom(parent.getWorldMatrix());
        }
        var translation_1 = TmpVectors.Vector3[5];
        var scale = TmpVectors.Vector3[6];
        TmpVectors.Matrix[7].decompose(scale, void 0, translation_1);
        Matrix.ScalingToRef(scale.x, scale.y, scale.z, TmpVectors.Matrix[7]);
        TmpVectors.Matrix[7].setTranslation(translation_1);
        this._localMatrix.multiplyToRef(TmpVectors.Matrix[7], this._worldMatrix);
      } else {
        if (this._transformToBoneReferal) {
          this._localMatrix.multiplyToRef(parent.getWorldMatrix(), TmpVectors.Matrix[6]);
          TmpVectors.Matrix[6].multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), this._worldMatrix);
        } else {
          this._localMatrix.multiplyToRef(parent.getWorldMatrix(), this._worldMatrix);
        }
      }
      this._markSyncedWithParent();
    } else {
      this._worldMatrix.copyFrom(this._localMatrix);
    }
    if (useBillboardPath && camera && this.billboardMode && !useBillboardPosition) {
      var storedTranslation = TmpVectors.Vector3[0];
      this._worldMatrix.getTranslationToRef(storedTranslation);
      TmpVectors.Matrix[1].copyFrom(camera.getViewMatrix());
      TmpVectors.Matrix[1].setTranslationFromFloats(0, 0, 0);
      TmpVectors.Matrix[1].invertToRef(TmpVectors.Matrix[0]);
      if ((this.billboardMode & TransformNode2.BILLBOARDMODE_ALL) !== TransformNode2.BILLBOARDMODE_ALL) {
        TmpVectors.Matrix[0].decompose(void 0, TmpVectors.Quaternion[0], void 0);
        var eulerAngles = TmpVectors.Vector3[1];
        TmpVectors.Quaternion[0].toEulerAnglesToRef(eulerAngles);
        if ((this.billboardMode & TransformNode2.BILLBOARDMODE_X) !== TransformNode2.BILLBOARDMODE_X) {
          eulerAngles.x = 0;
        }
        if ((this.billboardMode & TransformNode2.BILLBOARDMODE_Y) !== TransformNode2.BILLBOARDMODE_Y) {
          eulerAngles.y = 0;
        }
        if ((this.billboardMode & TransformNode2.BILLBOARDMODE_Z) !== TransformNode2.BILLBOARDMODE_Z) {
          eulerAngles.z = 0;
        }
        Matrix.RotationYawPitchRollToRef(eulerAngles.y, eulerAngles.x, eulerAngles.z, TmpVectors.Matrix[0]);
      }
      this._worldMatrix.setTranslationFromFloats(0, 0, 0);
      this._worldMatrix.multiplyToRef(TmpVectors.Matrix[0], this._worldMatrix);
      this._worldMatrix.setTranslation(TmpVectors.Vector3[0]);
    }
    if (!this.ignoreNonUniformScaling) {
      if (this._scaling.isNonUniformWithinEpsilon(1e-6)) {
        this._updateNonUniformScalingState(true);
      } else if (parent && parent._nonUniformScaling) {
        this._updateNonUniformScalingState(parent._nonUniformScaling);
      } else {
        this._updateNonUniformScalingState(false);
      }
    } else {
      this._updateNonUniformScalingState(false);
    }
    this._afterComputeWorldMatrix();
    this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]);
    this._isAbsoluteSynced = false;
    this.onAfterWorldMatrixUpdateObservable.notifyObservers(this);
    if (!this._poseMatrix) {
      this._poseMatrix = Matrix.Invert(this._worldMatrix);
    }
    this._worldMatrixDeterminantIsDirty = true;
    return this._worldMatrix;
  };
  TransformNode2.prototype.resetLocalMatrix = function(independentOfChildren) {
    if (independentOfChildren === void 0) {
      independentOfChildren = true;
    }
    this.computeWorldMatrix();
    if (independentOfChildren) {
      var children = this.getChildren();
      for (var i = 0; i < children.length; ++i) {
        var child = children[i];
        if (child) {
          child.computeWorldMatrix();
          var bakedMatrix = TmpVectors.Matrix[0];
          child._localMatrix.multiplyToRef(this._localMatrix, bakedMatrix);
          var tmpRotationQuaternion = TmpVectors.Quaternion[0];
          bakedMatrix.decompose(child.scaling, tmpRotationQuaternion, child.position);
          if (child.rotationQuaternion) {
            child.rotationQuaternion = tmpRotationQuaternion;
          } else {
            tmpRotationQuaternion.toEulerAnglesToRef(child.rotation);
          }
        }
      }
    }
    this.scaling.copyFromFloats(1, 1, 1);
    this.position.copyFromFloats(0, 0, 0);
    this.rotation.copyFromFloats(0, 0, 0);
    if (this.rotationQuaternion) {
      this.rotationQuaternion = Quaternion.Identity();
    }
    this._worldMatrix = Matrix.Identity();
  };
  TransformNode2.prototype._afterComputeWorldMatrix = function() {
  };
  TransformNode2.prototype.registerAfterWorldMatrixUpdate = function(func) {
    this.onAfterWorldMatrixUpdateObservable.add(func);
    return this;
  };
  TransformNode2.prototype.unregisterAfterWorldMatrixUpdate = function(func) {
    this.onAfterWorldMatrixUpdateObservable.removeCallback(func);
    return this;
  };
  TransformNode2.prototype.getPositionInCameraSpace = function(camera) {
    if (camera === void 0) {
      camera = null;
    }
    if (!camera) {
      camera = this.getScene().activeCamera;
    }
    return Vector3.TransformCoordinates(this.getAbsolutePosition(), camera.getViewMatrix());
  };
  TransformNode2.prototype.getDistanceToCamera = function(camera) {
    if (camera === void 0) {
      camera = null;
    }
    if (!camera) {
      camera = this.getScene().activeCamera;
    }
    return this.getAbsolutePosition().subtract(camera.globalPosition).length();
  };
  TransformNode2.prototype.clone = function(name45, newParent, doNotCloneChildren) {
    var _this = this;
    var result = SerializationHelper.Clone(function() {
      return new TransformNode2(name45, _this.getScene());
    }, this);
    result.name = name45;
    result.id = name45;
    if (newParent) {
      result.parent = newParent;
    }
    if (!doNotCloneChildren) {
      var directDescendants = this.getDescendants(true);
      for (var index = 0; index < directDescendants.length; index++) {
        var child = directDescendants[index];
        if (child.clone) {
          child.clone(name45 + "." + child.name, result);
        }
      }
    }
    return result;
  };
  TransformNode2.prototype.serialize = function(currentSerializationObject) {
    var serializationObject = SerializationHelper.Serialize(this, currentSerializationObject);
    serializationObject.type = this.getClassName();
    if (this.parent) {
      serializationObject.parentId = this.parent.id;
    }
    serializationObject.localMatrix = this.getPivotMatrix().asArray();
    serializationObject.isEnabled = this.isEnabled();
    if (this.parent) {
      serializationObject.parentId = this.parent.id;
    }
    return serializationObject;
  };
  TransformNode2.Parse = function(parsedTransformNode, scene, rootUrl) {
    var transformNode = SerializationHelper.Parse(function() {
      return new TransformNode2(parsedTransformNode.name, scene);
    }, parsedTransformNode, scene, rootUrl);
    if (parsedTransformNode.localMatrix) {
      transformNode.setPreTransformMatrix(Matrix.FromArray(parsedTransformNode.localMatrix));
    } else if (parsedTransformNode.pivotMatrix) {
      transformNode.setPivotMatrix(Matrix.FromArray(parsedTransformNode.pivotMatrix));
    }
    transformNode.setEnabled(parsedTransformNode.isEnabled);
    if (parsedTransformNode.parentId) {
      transformNode._waitingParentId = parsedTransformNode.parentId;
    }
    return transformNode;
  };
  TransformNode2.prototype.getChildTransformNodes = function(directDescendantsOnly, predicate) {
    var results = [];
    this._getDescendants(results, directDescendantsOnly, function(node) {
      return (!predicate || predicate(node)) && node instanceof TransformNode2;
    });
    return results;
  };
  TransformNode2.prototype.dispose = function(doNotRecurse, disposeMaterialAndTextures) {
    if (disposeMaterialAndTextures === void 0) {
      disposeMaterialAndTextures = false;
    }
    this.getScene().stopAnimation(this);
    this.getScene().removeTransformNode(this);
    this.onAfterWorldMatrixUpdateObservable.clear();
    if (doNotRecurse) {
      var transformNodes = this.getChildTransformNodes(true);
      for (var _i = 0, transformNodes_1 = transformNodes; _i < transformNodes_1.length; _i++) {
        var transformNode = transformNodes_1[_i];
        transformNode.parent = null;
        transformNode.computeWorldMatrix(true);
      }
    }
    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);
  };
  TransformNode2.prototype.normalizeToUnitCube = function(includeDescendants, ignoreRotation, predicate) {
    if (includeDescendants === void 0) {
      includeDescendants = true;
    }
    if (ignoreRotation === void 0) {
      ignoreRotation = false;
    }
    var storedRotation = null;
    var storedRotationQuaternion = null;
    if (ignoreRotation) {
      if (this.rotationQuaternion) {
        storedRotationQuaternion = this.rotationQuaternion.clone();
        this.rotationQuaternion.copyFromFloats(0, 0, 0, 1);
      } else if (this.rotation) {
        storedRotation = this.rotation.clone();
        this.rotation.copyFromFloats(0, 0, 0);
      }
    }
    var boundingVectors = this.getHierarchyBoundingVectors(includeDescendants, predicate);
    var sizeVec = boundingVectors.max.subtract(boundingVectors.min);
    var maxDimension = Math.max(sizeVec.x, sizeVec.y, sizeVec.z);
    if (maxDimension === 0) {
      return this;
    }
    var scale = 1 / maxDimension;
    this.scaling.scaleInPlace(scale);
    if (ignoreRotation) {
      if (this.rotationQuaternion && storedRotationQuaternion) {
        this.rotationQuaternion.copyFrom(storedRotationQuaternion);
      } else if (this.rotation && storedRotation) {
        this.rotation.copyFrom(storedRotation);
      }
    }
    return this;
  };
  TransformNode2.prototype._syncAbsoluteScalingAndRotation = function() {
    if (!this._isAbsoluteSynced) {
      this._worldMatrix.decompose(this._absoluteScaling, this._absoluteRotationQuaternion);
      this._isAbsoluteSynced = true;
    }
  };
  TransformNode2.BILLBOARDMODE_NONE = 0;
  TransformNode2.BILLBOARDMODE_X = 1;
  TransformNode2.BILLBOARDMODE_Y = 2;
  TransformNode2.BILLBOARDMODE_Z = 4;
  TransformNode2.BILLBOARDMODE_ALL = 7;
  TransformNode2.BILLBOARDMODE_USE_POSITION = 128;
  TransformNode2._TmpRotation = Quaternion.Zero();
  TransformNode2._TmpScaling = Vector3.Zero();
  TransformNode2._TmpTranslation = Vector3.Zero();
  TransformNode2._lookAtVectorCache = new Vector3(0, 0, 0);
  TransformNode2._rotationAxisCache = new Quaternion();
  __decorate([
    serializeAsVector3("position")
  ], TransformNode2.prototype, "_position", void 0);
  __decorate([
    serializeAsVector3("rotation")
  ], TransformNode2.prototype, "_rotation", void 0);
  __decorate([
    serializeAsQuaternion("rotationQuaternion")
  ], TransformNode2.prototype, "_rotationQuaternion", void 0);
  __decorate([
    serializeAsVector3("scaling")
  ], TransformNode2.prototype, "_scaling", void 0);
  __decorate([
    serialize("billboardMode")
  ], TransformNode2.prototype, "_billboardMode", void 0);
  __decorate([
    serialize()
  ], TransformNode2.prototype, "scalingDeterminant", void 0);
  __decorate([
    serialize("infiniteDistance")
  ], TransformNode2.prototype, "_infiniteDistance", void 0);
  __decorate([
    serialize()
  ], TransformNode2.prototype, "ignoreNonUniformScaling", void 0);
  __decorate([
    serialize()
  ], TransformNode2.prototype, "reIntegrateRotationIntoRotationQuaternion", void 0);
  return TransformNode2;
}(Node);

// node_modules/@babylonjs/core/Misc/performanceMonitor.js
var PerformanceMonitor = function() {
  function PerformanceMonitor2(frameSampleSize) {
    if (frameSampleSize === void 0) {
      frameSampleSize = 30;
    }
    this._enabled = true;
    this._rollingFrameTime = new RollingAverage(frameSampleSize);
  }
  PerformanceMonitor2.prototype.sampleFrame = function(timeMs) {
    if (timeMs === void 0) {
      timeMs = PrecisionDate.Now;
    }
    if (!this._enabled) {
      return;
    }
    if (this._lastFrameTimeMs != null) {
      var dt = timeMs - this._lastFrameTimeMs;
      this._rollingFrameTime.add(dt);
    }
    this._lastFrameTimeMs = timeMs;
  };
  Object.defineProperty(PerformanceMonitor2.prototype, "averageFrameTime", {
    get: function() {
      return this._rollingFrameTime.average;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerformanceMonitor2.prototype, "averageFrameTimeVariance", {
    get: function() {
      return this._rollingFrameTime.variance;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerformanceMonitor2.prototype, "instantaneousFrameTime", {
    get: function() {
      return this._rollingFrameTime.history(0);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerformanceMonitor2.prototype, "averageFPS", {
    get: function() {
      return 1e3 / this._rollingFrameTime.average;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerformanceMonitor2.prototype, "instantaneousFPS", {
    get: function() {
      var history = this._rollingFrameTime.history(0);
      if (history === 0) {
        return 0;
      }
      return 1e3 / history;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerformanceMonitor2.prototype, "isSaturated", {
    get: function() {
      return this._rollingFrameTime.isSaturated();
    },
    enumerable: false,
    configurable: true
  });
  PerformanceMonitor2.prototype.enable = function() {
    this._enabled = true;
  };
  PerformanceMonitor2.prototype.disable = function() {
    this._enabled = false;
    this._lastFrameTimeMs = null;
  };
  Object.defineProperty(PerformanceMonitor2.prototype, "isEnabled", {
    get: function() {
      return this._enabled;
    },
    enumerable: false,
    configurable: true
  });
  PerformanceMonitor2.prototype.reset = function() {
    this._lastFrameTimeMs = null;
    this._rollingFrameTime.reset();
  };
  return PerformanceMonitor2;
}();
var RollingAverage = function() {
  function RollingAverage2(length) {
    this._samples = new Array(length);
    this.reset();
  }
  RollingAverage2.prototype.add = function(v) {
    var delta;
    if (this.isSaturated()) {
      var bottomValue = this._samples[this._pos];
      delta = bottomValue - this.average;
      this.average -= delta / (this._sampleCount - 1);
      this._m2 -= delta * (bottomValue - this.average);
    } else {
      this._sampleCount++;
    }
    delta = v - this.average;
    this.average += delta / this._sampleCount;
    this._m2 += delta * (v - this.average);
    this.variance = this._m2 / (this._sampleCount - 1);
    this._samples[this._pos] = v;
    this._pos++;
    this._pos %= this._samples.length;
  };
  RollingAverage2.prototype.history = function(i) {
    if (i >= this._sampleCount || i >= this._samples.length) {
      return 0;
    }
    var i0 = this._wrapPosition(this._pos - 1);
    return this._samples[this._wrapPosition(i0 - i)];
  };
  RollingAverage2.prototype.isSaturated = function() {
    return this._sampleCount >= this._samples.length;
  };
  RollingAverage2.prototype.reset = function() {
    this.average = 0;
    this.variance = 0;
    this._sampleCount = 0;
    this._pos = 0;
    this._m2 = 0;
  };
  RollingAverage2.prototype._wrapPosition = function(i) {
    var max = this._samples.length;
    return (i % max + max) % max;
  };
  return RollingAverage2;
}();

// node_modules/@babylonjs/core/Misc/perfCounter.js
var PerfCounter = function() {
  function PerfCounter2() {
    this._startMonitoringTime = 0;
    this._min = 0;
    this._max = 0;
    this._average = 0;
    this._lastSecAverage = 0;
    this._current = 0;
    this._totalValueCount = 0;
    this._totalAccumulated = 0;
    this._lastSecAccumulated = 0;
    this._lastSecTime = 0;
    this._lastSecValueCount = 0;
  }
  Object.defineProperty(PerfCounter2.prototype, "min", {
    get: function() {
      return this._min;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerfCounter2.prototype, "max", {
    get: function() {
      return this._max;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerfCounter2.prototype, "average", {
    get: function() {
      return this._average;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerfCounter2.prototype, "lastSecAverage", {
    get: function() {
      return this._lastSecAverage;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerfCounter2.prototype, "current", {
    get: function() {
      return this._current;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerfCounter2.prototype, "total", {
    get: function() {
      return this._totalAccumulated;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerfCounter2.prototype, "count", {
    get: function() {
      return this._totalValueCount;
    },
    enumerable: false,
    configurable: true
  });
  PerfCounter2.prototype.fetchNewFrame = function() {
    this._totalValueCount++;
    this._current = 0;
    this._lastSecValueCount++;
  };
  PerfCounter2.prototype.addCount = function(newCount, fetchResult) {
    if (!PerfCounter2.Enabled) {
      return;
    }
    this._current += newCount;
    if (fetchResult) {
      this._fetchResult();
    }
  };
  PerfCounter2.prototype.beginMonitoring = function() {
    if (!PerfCounter2.Enabled) {
      return;
    }
    this._startMonitoringTime = PrecisionDate.Now;
  };
  PerfCounter2.prototype.endMonitoring = function(newFrame) {
    if (newFrame === void 0) {
      newFrame = true;
    }
    if (!PerfCounter2.Enabled) {
      return;
    }
    if (newFrame) {
      this.fetchNewFrame();
    }
    var currentTime = PrecisionDate.Now;
    this._current = currentTime - this._startMonitoringTime;
    if (newFrame) {
      this._fetchResult();
    }
  };
  PerfCounter2.prototype._fetchResult = function() {
    this._totalAccumulated += this._current;
    this._lastSecAccumulated += this._current;
    this._min = Math.min(this._min, this._current);
    this._max = Math.max(this._max, this._current);
    this._average = this._totalAccumulated / this._totalValueCount;
    var now = PrecisionDate.Now;
    if (now - this._lastSecTime > 1e3) {
      this._lastSecAverage = this._lastSecAccumulated / this._lastSecValueCount;
      this._lastSecTime = now;
      this._lastSecAccumulated = 0;
      this._lastSecValueCount = 0;
    }
  };
  PerfCounter2.Enabled = true;
  return PerfCounter2;
}();

// node_modules/@babylonjs/core/Engines/Extensions/engine.alpha.js
ThinEngine.prototype.setAlphaConstants = function(r, g, b, a) {
  this._alphaState.setAlphaBlendConstants(r, g, b, a);
};
ThinEngine.prototype.setAlphaMode = function(mode, noDepthWriteChange) {
  if (noDepthWriteChange === void 0) {
    noDepthWriteChange = false;
  }
  if (this._alphaMode === mode) {
    return;
  }
  switch (mode) {
    case 0:
      this._alphaState.alphaBlend = false;
      break;
    case 7:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 8:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
      this._alphaState.alphaBlend = true;
      break;
    case 2:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 6:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ZERO, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 1:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 3:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ZERO, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 4:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_COLOR, this._gl.ZERO, this._gl.ONE, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 5:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 9:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.CONSTANT_COLOR, this._gl.ONE_MINUS_CONSTANT_COLOR, this._gl.CONSTANT_ALPHA, this._gl.ONE_MINUS_CONSTANT_ALPHA);
      this._alphaState.alphaBlend = true;
      break;
    case 10:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
      this._alphaState.alphaBlend = true;
      break;
    case 11:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 12:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ZERO);
      this._alphaState.alphaBlend = true;
      break;
    case 13:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE_MINUS_DST_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);
      this._alphaState.alphaBlend = true;
      break;
    case 14:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
      this._alphaState.alphaBlend = true;
      break;
    case 15:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ZERO);
      this._alphaState.alphaBlend = true;
      break;
    case 16:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ZERO, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
  }
  if (!noDepthWriteChange) {
    this.depthCullingState.depthMask = mode === 0;
  }
  this._alphaMode = mode;
};
ThinEngine.prototype.getAlphaMode = function() {
  return this._alphaMode;
};
ThinEngine.prototype.setAlphaEquation = function(equation) {
  if (this._alphaEquation === equation) {
    return;
  }
  switch (equation) {
    case 0:
      this._alphaState.setAlphaEquationParameters(this._gl.FUNC_ADD, this._gl.FUNC_ADD);
      break;
    case 1:
      this._alphaState.setAlphaEquationParameters(this._gl.FUNC_SUBTRACT, this._gl.FUNC_SUBTRACT);
      break;
    case 2:
      this._alphaState.setAlphaEquationParameters(this._gl.FUNC_REVERSE_SUBTRACT, this._gl.FUNC_REVERSE_SUBTRACT);
      break;
    case 3:
      this._alphaState.setAlphaEquationParameters(this._gl.MAX, this._gl.MAX);
      break;
    case 4:
      this._alphaState.setAlphaEquationParameters(this._gl.MIN, this._gl.MIN);
      break;
    case 5:
      this._alphaState.setAlphaEquationParameters(this._gl.MIN, this._gl.FUNC_ADD);
      break;
  }
  this._alphaEquation = equation;
};
ThinEngine.prototype.getAlphaEquation = function() {
  return this._alphaEquation;
};

// node_modules/@babylonjs/core/Engines/Extensions/engine.readTexture.js
ThinEngine.prototype._readTexturePixels = function(texture, width, height, faceIndex, level, buffer) {
  if (faceIndex === void 0) {
    faceIndex = -1;
  }
  if (level === void 0) {
    level = 0;
  }
  if (buffer === void 0) {
    buffer = null;
  }
  var gl = this._gl;
  if (!gl) {
    throw new Error("Engine does not have gl rendering context.");
  }
  if (!this._dummyFramebuffer) {
    var dummy = gl.createFramebuffer();
    if (!dummy) {
      throw new Error("Unable to create dummy framebuffer");
    }
    this._dummyFramebuffer = dummy;
  }
  gl.bindFramebuffer(gl.FRAMEBUFFER, this._dummyFramebuffer);
  if (faceIndex > -1) {
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, texture._webGLTexture, level);
  } else {
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture._webGLTexture, level);
  }
  var readType = texture.type !== void 0 ? this._getWebGLTextureType(texture.type) : gl.UNSIGNED_BYTE;
  switch (readType) {
    case gl.UNSIGNED_BYTE:
      if (!buffer) {
        buffer = new Uint8Array(4 * width * height);
      }
      readType = gl.UNSIGNED_BYTE;
      break;
    default:
      if (!buffer) {
        buffer = new Float32Array(4 * width * height);
      }
      readType = gl.FLOAT;
      break;
  }
  gl.readPixels(0, 0, width, height, gl.RGBA, readType, buffer);
  gl.bindFramebuffer(gl.FRAMEBUFFER, this._currentFramebuffer);
  return buffer;
};

// node_modules/@babylonjs/core/Engines/Extensions/engine.dynamicBuffer.js
ThinEngine.prototype.updateDynamicIndexBuffer = function(indexBuffer, indices, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  this._currentBoundBuffer[this._gl.ELEMENT_ARRAY_BUFFER] = null;
  this.bindIndexBuffer(indexBuffer);
  var arrayBuffer;
  if (indices instanceof Uint16Array || indices instanceof Uint32Array) {
    arrayBuffer = indices;
  } else {
    arrayBuffer = indexBuffer.is32Bits ? new Uint32Array(indices) : new Uint16Array(indices);
  }
  this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, arrayBuffer, this._gl.DYNAMIC_DRAW);
  this._resetIndexBufferBinding();
};
ThinEngine.prototype.updateDynamicVertexBuffer = function(vertexBuffer, data, byteOffset, byteLength) {
  this.bindArrayBuffer(vertexBuffer);
  if (byteOffset === void 0) {
    byteOffset = 0;
  }
  var dataLength = data.length || data.byteLength;
  if (byteLength === void 0 || byteLength >= dataLength && byteOffset === 0) {
    if (data instanceof Array) {
      this._gl.bufferSubData(this._gl.ARRAY_BUFFER, byteOffset, new Float32Array(data));
    } else {
      this._gl.bufferSubData(this._gl.ARRAY_BUFFER, byteOffset, data);
    }
  } else {
    if (data instanceof Array) {
      this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, new Float32Array(data).subarray(byteOffset, byteOffset + byteLength));
    } else {
      if (data instanceof ArrayBuffer) {
        data = new Uint8Array(data, byteOffset, byteLength);
      } else {
        data = new Uint8Array(data.buffer, data.byteOffset + byteOffset, byteLength);
      }
      this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);
    }
  }
  this._resetVertexBufferBinding();
};

// node_modules/@babylonjs/core/Engines/engine.js
var Engine = function(_super) {
  __extends(Engine2, _super);
  function Engine2(canvasOrContext, antialias, options, adaptToDeviceRatio) {
    if (adaptToDeviceRatio === void 0) {
      adaptToDeviceRatio = false;
    }
    var _this = _super.call(this, canvasOrContext, antialias, options, adaptToDeviceRatio) || this;
    _this.enableOfflineSupport = false;
    _this.disableManifestCheck = false;
    _this.scenes = new Array();
    _this.onNewSceneAddedObservable = new Observable();
    _this.postProcesses = new Array();
    _this.isPointerLock = false;
    _this.onResizeObservable = new Observable();
    _this.onCanvasBlurObservable = new Observable();
    _this.onCanvasFocusObservable = new Observable();
    _this.onCanvasPointerOutObservable = new Observable();
    _this.onBeginFrameObservable = new Observable();
    _this.customAnimationFrameRequester = null;
    _this.onEndFrameObservable = new Observable();
    _this.onBeforeShaderCompilationObservable = new Observable();
    _this.onAfterShaderCompilationObservable = new Observable();
    _this._deterministicLockstep = false;
    _this._lockstepMaxSteps = 4;
    _this._timeStep = 1 / 60;
    _this._fps = 60;
    _this._deltaTime = 0;
    _this._drawCalls = new PerfCounter();
    _this.canvasTabIndex = 1;
    _this.disablePerformanceMonitorInBackground = false;
    _this._performanceMonitor = new PerformanceMonitor();
    Engine2.Instances.push(_this);
    if (!canvasOrContext) {
      return _this;
    }
    options = _this._creationOptions;
    if (canvasOrContext.getContext) {
      var canvas_1 = canvasOrContext;
      _this._onCanvasFocus = function() {
        _this.onCanvasFocusObservable.notifyObservers(_this);
      };
      _this._onCanvasBlur = function() {
        _this.onCanvasBlurObservable.notifyObservers(_this);
      };
      canvas_1.addEventListener("focus", _this._onCanvasFocus);
      canvas_1.addEventListener("blur", _this._onCanvasBlur);
      _this._onBlur = function() {
        if (_this.disablePerformanceMonitorInBackground) {
          _this._performanceMonitor.disable();
        }
        _this._windowIsBackground = true;
      };
      _this._onFocus = function() {
        if (_this.disablePerformanceMonitorInBackground) {
          _this._performanceMonitor.enable();
        }
        _this._windowIsBackground = false;
      };
      _this._onCanvasPointerOut = function(ev) {
        _this.onCanvasPointerOutObservable.notifyObservers(ev);
      };
      canvas_1.addEventListener("pointerout", _this._onCanvasPointerOut);
      if (DomManagement.IsWindowObjectExist()) {
        var hostWindow = _this.getHostWindow();
        hostWindow.addEventListener("blur", _this._onBlur);
        hostWindow.addEventListener("focus", _this._onFocus);
        var anyDoc_1 = document;
        _this._onFullscreenChange = function() {
          if (anyDoc_1.fullscreen !== void 0) {
            _this.isFullscreen = anyDoc_1.fullscreen;
          } else if (anyDoc_1.mozFullScreen !== void 0) {
            _this.isFullscreen = anyDoc_1.mozFullScreen;
          } else if (anyDoc_1.webkitIsFullScreen !== void 0) {
            _this.isFullscreen = anyDoc_1.webkitIsFullScreen;
          } else if (anyDoc_1.msIsFullScreen !== void 0) {
            _this.isFullscreen = anyDoc_1.msIsFullScreen;
          }
          if (_this.isFullscreen && _this._pointerLockRequested && canvas_1) {
            Engine2._RequestPointerlock(canvas_1);
          }
        };
        document.addEventListener("fullscreenchange", _this._onFullscreenChange, false);
        document.addEventListener("mozfullscreenchange", _this._onFullscreenChange, false);
        document.addEventListener("webkitfullscreenchange", _this._onFullscreenChange, false);
        document.addEventListener("msfullscreenchange", _this._onFullscreenChange, false);
        _this._onPointerLockChange = function() {
          _this.isPointerLock = anyDoc_1.mozPointerLockElement === canvas_1 || anyDoc_1.webkitPointerLockElement === canvas_1 || anyDoc_1.msPointerLockElement === canvas_1 || anyDoc_1.pointerLockElement === canvas_1;
        };
        document.addEventListener("pointerlockchange", _this._onPointerLockChange, false);
        document.addEventListener("mspointerlockchange", _this._onPointerLockChange, false);
        document.addEventListener("mozpointerlockchange", _this._onPointerLockChange, false);
        document.addEventListener("webkitpointerlockchange", _this._onPointerLockChange, false);
        if (!Engine2.audioEngine && options.audioEngine && Engine2.AudioEngineFactory) {
          Engine2.audioEngine = Engine2.AudioEngineFactory(_this.getRenderingCanvas());
        }
      }
      _this._connectVREvents();
      _this.enableOfflineSupport = Engine2.OfflineProviderFactory !== void 0;
      if (!options.doNotHandleTouchAction) {
        _this._disableTouchAction();
      }
      _this._deterministicLockstep = !!options.deterministicLockstep;
      _this._lockstepMaxSteps = options.lockstepMaxSteps || 0;
      _this._timeStep = options.timeStep || 1 / 60;
    }
    _this._prepareVRComponent();
    if (options.autoEnableWebVR) {
      _this.initWebVR();
    }
    return _this;
  }
  Object.defineProperty(Engine2, "NpmPackage", {
    get: function() {
      return ThinEngine.NpmPackage;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Engine2, "Version", {
    get: function() {
      return ThinEngine.Version;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Engine2, "Instances", {
    get: function() {
      return EngineStore.Instances;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Engine2, "LastCreatedEngine", {
    get: function() {
      return EngineStore.LastCreatedEngine;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Engine2, "LastCreatedScene", {
    get: function() {
      return EngineStore.LastCreatedScene;
    },
    enumerable: false,
    configurable: true
  });
  Engine2.MarkAllMaterialsAsDirty = function(flag, predicate) {
    for (var engineIndex = 0; engineIndex < Engine2.Instances.length; engineIndex++) {
      var engine = Engine2.Instances[engineIndex];
      for (var sceneIndex = 0; sceneIndex < engine.scenes.length; sceneIndex++) {
        engine.scenes[sceneIndex].markAllMaterialsAsDirty(flag, predicate);
      }
    }
  };
  Engine2.DefaultLoadingScreenFactory = function(canvas) {
    throw _DevTools.WarnImport("LoadingScreen");
  };
  Object.defineProperty(Engine2.prototype, "_supportsHardwareTextureRescaling", {
    get: function() {
      return !!Engine2._RescalePostProcessFactory;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Engine2.prototype, "performanceMonitor", {
    get: function() {
      return this._performanceMonitor;
    },
    enumerable: false,
    configurable: true
  });
  Engine2.prototype.getInputElement = function() {
    return this._renderingCanvas;
  };
  Engine2.prototype.getAspectRatio = function(viewportOwner, useScreen) {
    if (useScreen === void 0) {
      useScreen = false;
    }
    var viewport = viewportOwner.viewport;
    return this.getRenderWidth(useScreen) * viewport.width / (this.getRenderHeight(useScreen) * viewport.height);
  };
  Engine2.prototype.getScreenAspectRatio = function() {
    return this.getRenderWidth(true) / this.getRenderHeight(true);
  };
  Engine2.prototype.getRenderingCanvasClientRect = function() {
    if (!this._renderingCanvas) {
      return null;
    }
    return this._renderingCanvas.getBoundingClientRect();
  };
  Engine2.prototype.getInputElementClientRect = function() {
    if (!this._renderingCanvas) {
      return null;
    }
    return this.getInputElement().getBoundingClientRect();
  };
  Engine2.prototype.isDeterministicLockStep = function() {
    return this._deterministicLockstep;
  };
  Engine2.prototype.getLockstepMaxSteps = function() {
    return this._lockstepMaxSteps;
  };
  Engine2.prototype.getTimeStep = function() {
    return this._timeStep * 1e3;
  };
  Engine2.prototype.generateMipMapsForCubemap = function(texture, unbind) {
    if (unbind === void 0) {
      unbind = true;
    }
    if (texture.generateMipMaps) {
      var gl = this._gl;
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
      gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
      if (unbind) {
        this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
      }
    }
  };
  Engine2.prototype.setState = function(culling, zOffset, force, reverseSide) {
    if (zOffset === void 0) {
      zOffset = 0;
    }
    if (reverseSide === void 0) {
      reverseSide = false;
    }
    if (this._depthCullingState.cull !== culling || force) {
      this._depthCullingState.cull = culling;
    }
    var cullFace = this.cullBackFaces ? this._gl.BACK : this._gl.FRONT;
    if (this._depthCullingState.cullFace !== cullFace || force) {
      this._depthCullingState.cullFace = cullFace;
    }
    this.setZOffset(zOffset);
    var frontFace = reverseSide ? this._gl.CW : this._gl.CCW;
    if (this._depthCullingState.frontFace !== frontFace || force) {
      this._depthCullingState.frontFace = frontFace;
    }
  };
  Engine2.prototype.setZOffset = function(value) {
    this._depthCullingState.zOffset = value;
  };
  Engine2.prototype.getZOffset = function() {
    return this._depthCullingState.zOffset;
  };
  Engine2.prototype.setDepthBuffer = function(enable) {
    this._depthCullingState.depthTest = enable;
  };
  Engine2.prototype.getDepthWrite = function() {
    return this._depthCullingState.depthMask;
  };
  Engine2.prototype.setDepthWrite = function(enable) {
    this._depthCullingState.depthMask = enable;
  };
  Engine2.prototype.getStencilBuffer = function() {
    return this._stencilState.stencilTest;
  };
  Engine2.prototype.setStencilBuffer = function(enable) {
    this._stencilState.stencilTest = enable;
  };
  Engine2.prototype.getStencilMask = function() {
    return this._stencilState.stencilMask;
  };
  Engine2.prototype.setStencilMask = function(mask) {
    this._stencilState.stencilMask = mask;
  };
  Engine2.prototype.getStencilFunction = function() {
    return this._stencilState.stencilFunc;
  };
  Engine2.prototype.getStencilFunctionReference = function() {
    return this._stencilState.stencilFuncRef;
  };
  Engine2.prototype.getStencilFunctionMask = function() {
    return this._stencilState.stencilFuncMask;
  };
  Engine2.prototype.setStencilFunction = function(stencilFunc) {
    this._stencilState.stencilFunc = stencilFunc;
  };
  Engine2.prototype.setStencilFunctionReference = function(reference) {
    this._stencilState.stencilFuncRef = reference;
  };
  Engine2.prototype.setStencilFunctionMask = function(mask) {
    this._stencilState.stencilFuncMask = mask;
  };
  Engine2.prototype.getStencilOperationFail = function() {
    return this._stencilState.stencilOpStencilFail;
  };
  Engine2.prototype.getStencilOperationDepthFail = function() {
    return this._stencilState.stencilOpDepthFail;
  };
  Engine2.prototype.getStencilOperationPass = function() {
    return this._stencilState.stencilOpStencilDepthPass;
  };
  Engine2.prototype.setStencilOperationFail = function(operation) {
    this._stencilState.stencilOpStencilFail = operation;
  };
  Engine2.prototype.setStencilOperationDepthFail = function(operation) {
    this._stencilState.stencilOpDepthFail = operation;
  };
  Engine2.prototype.setStencilOperationPass = function(operation) {
    this._stencilState.stencilOpStencilDepthPass = operation;
  };
  Engine2.prototype.setDitheringState = function(value) {
    if (value) {
      this._gl.enable(this._gl.DITHER);
    } else {
      this._gl.disable(this._gl.DITHER);
    }
  };
  Engine2.prototype.setRasterizerState = function(value) {
    if (value) {
      this._gl.disable(this._gl.RASTERIZER_DISCARD);
    } else {
      this._gl.enable(this._gl.RASTERIZER_DISCARD);
    }
  };
  Engine2.prototype.getDepthFunction = function() {
    return this._depthCullingState.depthFunc;
  };
  Engine2.prototype.setDepthFunction = function(depthFunc) {
    this._depthCullingState.depthFunc = depthFunc;
  };
  Engine2.prototype.setDepthFunctionToGreater = function() {
    this._depthCullingState.depthFunc = this._gl.GREATER;
  };
  Engine2.prototype.setDepthFunctionToGreaterOrEqual = function() {
    this._depthCullingState.depthFunc = this._gl.GEQUAL;
  };
  Engine2.prototype.setDepthFunctionToLess = function() {
    this._depthCullingState.depthFunc = this._gl.LESS;
  };
  Engine2.prototype.setDepthFunctionToLessOrEqual = function() {
    this._depthCullingState.depthFunc = this._gl.LEQUAL;
  };
  Engine2.prototype.cacheStencilState = function() {
    this._cachedStencilBuffer = this.getStencilBuffer();
    this._cachedStencilFunction = this.getStencilFunction();
    this._cachedStencilMask = this.getStencilMask();
    this._cachedStencilOperationPass = this.getStencilOperationPass();
    this._cachedStencilOperationFail = this.getStencilOperationFail();
    this._cachedStencilOperationDepthFail = this.getStencilOperationDepthFail();
    this._cachedStencilReference = this.getStencilFunctionReference();
  };
  Engine2.prototype.restoreStencilState = function() {
    this.setStencilFunction(this._cachedStencilFunction);
    this.setStencilMask(this._cachedStencilMask);
    this.setStencilBuffer(this._cachedStencilBuffer);
    this.setStencilOperationPass(this._cachedStencilOperationPass);
    this.setStencilOperationFail(this._cachedStencilOperationFail);
    this.setStencilOperationDepthFail(this._cachedStencilOperationDepthFail);
    this.setStencilFunctionReference(this._cachedStencilReference);
  };
  Engine2.prototype.setDirectViewport = function(x, y, width, height) {
    var currentViewport = this._cachedViewport;
    this._cachedViewport = null;
    this._viewport(x, y, width, height);
    return currentViewport;
  };
  Engine2.prototype.scissorClear = function(x, y, width, height, clearColor) {
    this.enableScissor(x, y, width, height);
    this.clear(clearColor, true, true, true);
    this.disableScissor();
  };
  Engine2.prototype.enableScissor = function(x, y, width, height) {
    var gl = this._gl;
    gl.enable(gl.SCISSOR_TEST);
    gl.scissor(x, y, width, height);
  };
  Engine2.prototype.disableScissor = function() {
    var gl = this._gl;
    gl.disable(gl.SCISSOR_TEST);
  };
  Engine2.prototype._reportDrawCall = function() {
    this._drawCalls.addCount(1, false);
  };
  Engine2.prototype.initWebVR = function() {
    throw _DevTools.WarnImport("WebVRCamera");
  };
  Engine2.prototype._prepareVRComponent = function() {
  };
  Engine2.prototype._connectVREvents = function(canvas, document2) {
  };
  Engine2.prototype._submitVRFrame = function() {
  };
  Engine2.prototype.disableVR = function() {
  };
  Engine2.prototype.isVRPresenting = function() {
    return false;
  };
  Engine2.prototype._requestVRFrame = function() {
  };
  Engine2.prototype._loadFileAsync = function(url, offlineProvider, useArrayBuffer) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      _this._loadFile(url, function(data) {
        resolve(data);
      }, void 0, offlineProvider, useArrayBuffer, function(request, exception) {
        reject(exception);
      });
    });
  };
  Engine2.prototype.getVertexShaderSource = function(program) {
    var shaders = this._gl.getAttachedShaders(program);
    if (!shaders) {
      return null;
    }
    return this._gl.getShaderSource(shaders[0]);
  };
  Engine2.prototype.getFragmentShaderSource = function(program) {
    var shaders = this._gl.getAttachedShaders(program);
    if (!shaders) {
      return null;
    }
    return this._gl.getShaderSource(shaders[1]);
  };
  Engine2.prototype.setDepthStencilTexture = function(channel, uniform, texture) {
    if (channel === void 0) {
      return;
    }
    if (uniform) {
      this._boundUniforms[channel] = uniform;
    }
    if (!texture || !texture.depthStencilTexture) {
      this._setTexture(channel, null);
    } else {
      this._setTexture(channel, texture, false, true);
    }
  };
  Engine2.prototype.setTextureFromPostProcess = function(channel, postProcess) {
    this._bindTexture(channel, postProcess ? postProcess._textures.data[postProcess._currentRenderTextureInd] : null);
  };
  Engine2.prototype.setTextureFromPostProcessOutput = function(channel, postProcess) {
    this._bindTexture(channel, postProcess ? postProcess._outputTexture : null);
  };
  Engine2.prototype._rebuildBuffers = function() {
    for (var _i = 0, _a = this.scenes; _i < _a.length; _i++) {
      var scene = _a[_i];
      scene.resetCachedMaterial();
      scene._rebuildGeometries();
      scene._rebuildTextures();
    }
    _super.prototype._rebuildBuffers.call(this);
  };
  Engine2.prototype._renderFrame = function() {
    for (var index = 0; index < this._activeRenderLoops.length; index++) {
      var renderFunction = this._activeRenderLoops[index];
      renderFunction();
    }
  };
  Engine2.prototype._renderLoop = function() {
    if (!this._contextWasLost) {
      var shouldRender = true;
      if (!this.renderEvenInBackground && this._windowIsBackground) {
        shouldRender = false;
      }
      if (shouldRender) {
        this.beginFrame();
        if (!this._renderViews()) {
          this._renderFrame();
        }
        this.endFrame();
      }
    }
    if (this._activeRenderLoops.length > 0) {
      if (this.customAnimationFrameRequester) {
        this.customAnimationFrameRequester.requestID = this._queueNewFrame(this.customAnimationFrameRequester.renderFunction || this._boundRenderFunction, this.customAnimationFrameRequester);
        this._frameHandler = this.customAnimationFrameRequester.requestID;
      } else if (this.isVRPresenting()) {
        this._requestVRFrame();
      } else {
        this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());
      }
    } else {
      this._renderingQueueLaunched = false;
    }
  };
  Engine2.prototype._renderViews = function() {
    return false;
  };
  Engine2.prototype.switchFullscreen = function(requestPointerLock) {
    if (this.isFullscreen) {
      this.exitFullscreen();
    } else {
      this.enterFullscreen(requestPointerLock);
    }
  };
  Engine2.prototype.enterFullscreen = function(requestPointerLock) {
    if (!this.isFullscreen) {
      this._pointerLockRequested = requestPointerLock;
      if (this._renderingCanvas) {
        Engine2._RequestFullscreen(this._renderingCanvas);
      }
    }
  };
  Engine2.prototype.exitFullscreen = function() {
    if (this.isFullscreen) {
      Engine2._ExitFullscreen();
    }
  };
  Engine2.prototype.enterPointerlock = function() {
    if (this._renderingCanvas) {
      Engine2._RequestPointerlock(this._renderingCanvas);
    }
  };
  Engine2.prototype.exitPointerlock = function() {
    Engine2._ExitPointerlock();
  };
  Engine2.prototype.beginFrame = function() {
    this._measureFps();
    this.onBeginFrameObservable.notifyObservers(this);
    _super.prototype.beginFrame.call(this);
  };
  Engine2.prototype.endFrame = function() {
    _super.prototype.endFrame.call(this);
    this._submitVRFrame();
    this.onEndFrameObservable.notifyObservers(this);
  };
  Engine2.prototype.resize = function() {
    if (this.isVRPresenting()) {
      return;
    }
    _super.prototype.resize.call(this);
  };
  Engine2.prototype.setSize = function(width, height) {
    if (!this._renderingCanvas) {
      return false;
    }
    if (!_super.prototype.setSize.call(this, width, height)) {
      return false;
    }
    if (this.scenes) {
      for (var index = 0; index < this.scenes.length; index++) {
        var scene = this.scenes[index];
        for (var camIndex = 0; camIndex < scene.cameras.length; camIndex++) {
          var cam = scene.cameras[camIndex];
          cam._currentRenderId = 0;
        }
      }
      if (this.onResizeObservable.hasObservers()) {
        this.onResizeObservable.notifyObservers(this);
      }
    }
    return true;
  };
  Engine2.prototype._deletePipelineContext = function(pipelineContext) {
    var webGLPipelineContext = pipelineContext;
    if (webGLPipelineContext && webGLPipelineContext.program) {
      if (webGLPipelineContext.transformFeedback) {
        this.deleteTransformFeedback(webGLPipelineContext.transformFeedback);
        webGLPipelineContext.transformFeedback = null;
      }
    }
    _super.prototype._deletePipelineContext.call(this, pipelineContext);
  };
  Engine2.prototype.createShaderProgram = function(pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings) {
    if (transformFeedbackVaryings === void 0) {
      transformFeedbackVaryings = null;
    }
    context = context || this._gl;
    this.onBeforeShaderCompilationObservable.notifyObservers(this);
    var program = _super.prototype.createShaderProgram.call(this, pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings);
    this.onAfterShaderCompilationObservable.notifyObservers(this);
    return program;
  };
  Engine2.prototype._createShaderProgram = function(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings) {
    if (transformFeedbackVaryings === void 0) {
      transformFeedbackVaryings = null;
    }
    var shaderProgram = context.createProgram();
    pipelineContext.program = shaderProgram;
    if (!shaderProgram) {
      throw new Error("Unable to create program");
    }
    context.attachShader(shaderProgram, vertexShader);
    context.attachShader(shaderProgram, fragmentShader);
    if (this.webGLVersion > 1 && transformFeedbackVaryings) {
      var transformFeedback = this.createTransformFeedback();
      this.bindTransformFeedback(transformFeedback);
      this.setTranformFeedbackVaryings(shaderProgram, transformFeedbackVaryings);
      pipelineContext.transformFeedback = transformFeedback;
    }
    context.linkProgram(shaderProgram);
    if (this.webGLVersion > 1 && transformFeedbackVaryings) {
      this.bindTransformFeedback(null);
    }
    pipelineContext.context = context;
    pipelineContext.vertexShader = vertexShader;
    pipelineContext.fragmentShader = fragmentShader;
    if (!pipelineContext.isParallelCompiled) {
      this._finalizePipelineContext(pipelineContext);
    }
    return shaderProgram;
  };
  Engine2.prototype._releaseTexture = function(texture) {
    _super.prototype._releaseTexture.call(this, texture);
    this.scenes.forEach(function(scene) {
      scene.postProcesses.forEach(function(postProcess) {
        if (postProcess._outputTexture == texture) {
          postProcess._outputTexture = null;
        }
      });
      scene.cameras.forEach(function(camera) {
        camera._postProcesses.forEach(function(postProcess) {
          if (postProcess) {
            if (postProcess._outputTexture == texture) {
              postProcess._outputTexture = null;
            }
          }
        });
      });
    });
  };
  Engine2.prototype._rescaleTexture = function(source, destination, scene, internalFormat, onComplete) {
    var _this = this;
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR);
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR);
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
    var rtt = this.createRenderTargetTexture({
      width: destination.width,
      height: destination.height
    }, {
      generateMipMaps: false,
      type: 0,
      samplingMode: 2,
      generateDepthBuffer: false,
      generateStencilBuffer: false
    });
    if (!this._rescalePostProcess && Engine2._RescalePostProcessFactory) {
      this._rescalePostProcess = Engine2._RescalePostProcessFactory(this);
    }
    this._rescalePostProcess.getEffect().executeWhenCompiled(function() {
      _this._rescalePostProcess.onApply = function(effect) {
        effect._bindTexture("textureSampler", source);
      };
      var hostingScene = scene;
      if (!hostingScene) {
        hostingScene = _this.scenes[_this.scenes.length - 1];
      }
      hostingScene.postProcessManager.directRender([_this._rescalePostProcess], rtt, true);
      _this._bindTextureDirectly(_this._gl.TEXTURE_2D, destination, true);
      _this._gl.copyTexImage2D(_this._gl.TEXTURE_2D, 0, internalFormat, 0, 0, destination.width, destination.height, 0);
      _this.unBindFramebuffer(rtt);
      _this._releaseTexture(rtt);
      if (onComplete) {
        onComplete();
      }
    });
  };
  Engine2.prototype.getFps = function() {
    return this._fps;
  };
  Engine2.prototype.getDeltaTime = function() {
    return this._deltaTime;
  };
  Engine2.prototype._measureFps = function() {
    this._performanceMonitor.sampleFrame();
    this._fps = this._performanceMonitor.averageFPS;
    this._deltaTime = this._performanceMonitor.instantaneousFrameTime || 0;
  };
  Engine2.prototype._uploadImageToTexture = function(texture, image, faceIndex, lod) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lod === void 0) {
      lod = 0;
    }
    var gl = this._gl;
    var textureType = this._getWebGLTextureType(texture.type);
    var format = this._getInternalFormat(texture.format);
    var internalFormat = this._getRGBABufferInternalSizedFormat(texture.type, format);
    var bindTarget = texture.isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;
    this._bindTextureDirectly(bindTarget, texture, true);
    this._unpackFlipY(texture.invertY);
    var target = gl.TEXTURE_2D;
    if (texture.isCube) {
      target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
    }
    gl.texImage2D(target, lod, internalFormat, format, textureType, image);
    this._bindTextureDirectly(bindTarget, null, true);
  };
  Engine2.prototype.updateRenderTargetTextureSampleCount = function(texture, samples) {
    if (this.webGLVersion < 2 || !texture) {
      return 1;
    }
    if (texture.samples === samples) {
      return samples;
    }
    var gl = this._gl;
    samples = Math.min(samples, this.getCaps().maxMSAASamples);
    if (texture._depthStencilBuffer) {
      gl.deleteRenderbuffer(texture._depthStencilBuffer);
      texture._depthStencilBuffer = null;
    }
    if (texture._MSAAFramebuffer) {
      gl.deleteFramebuffer(texture._MSAAFramebuffer);
      texture._MSAAFramebuffer = null;
    }
    if (texture._MSAARenderBuffer) {
      gl.deleteRenderbuffer(texture._MSAARenderBuffer);
      texture._MSAARenderBuffer = null;
    }
    if (samples > 1 && gl.renderbufferStorageMultisample) {
      var framebuffer = gl.createFramebuffer();
      if (!framebuffer) {
        throw new Error("Unable to create multi sampled framebuffer");
      }
      texture._MSAAFramebuffer = framebuffer;
      this._bindUnboundFramebuffer(texture._MSAAFramebuffer);
      var colorRenderbuffer = gl.createRenderbuffer();
      if (!colorRenderbuffer) {
        throw new Error("Unable to create multi sampled framebuffer");
      }
      gl.bindRenderbuffer(gl.RENDERBUFFER, colorRenderbuffer);
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, this._getRGBAMultiSampleBufferFormat(texture.type), texture.width, texture.height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, colorRenderbuffer);
      texture._MSAARenderBuffer = colorRenderbuffer;
    } else {
      this._bindUnboundFramebuffer(texture._framebuffer);
    }
    texture.samples = samples;
    texture._depthStencilBuffer = this._setupFramebufferDepthAttachments(texture._generateStencilBuffer, texture._generateDepthBuffer, texture.width, texture.height, samples);
    this._bindUnboundFramebuffer(null);
    return samples;
  };
  Engine2.prototype.updateTextureComparisonFunction = function(texture, comparisonFunction) {
    if (this.webGLVersion === 1) {
      Logger.Error("WebGL 1 does not support texture comparison.");
      return;
    }
    var gl = this._gl;
    if (texture.isCube) {
      this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);
      if (comparisonFunction === 0) {
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_FUNC, 515);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_MODE, gl.NONE);
      } else {
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
      }
      this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
    } else {
      this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
      if (comparisonFunction === 0) {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_FUNC, 515);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_MODE, gl.NONE);
      } else {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
      }
      this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
    }
    texture._comparisonFunction = comparisonFunction;
  };
  Engine2.prototype.createInstancesBuffer = function(capacity) {
    var buffer = this._gl.createBuffer();
    if (!buffer) {
      throw new Error("Unable to create instance buffer");
    }
    var result = new WebGLDataBuffer(buffer);
    result.capacity = capacity;
    this.bindArrayBuffer(result);
    this._gl.bufferData(this._gl.ARRAY_BUFFER, capacity, this._gl.DYNAMIC_DRAW);
    return result;
  };
  Engine2.prototype.deleteInstancesBuffer = function(buffer) {
    this._gl.deleteBuffer(buffer);
  };
  Engine2.prototype._clientWaitAsync = function(sync, flags, interval_ms) {
    if (flags === void 0) {
      flags = 0;
    }
    if (interval_ms === void 0) {
      interval_ms = 10;
    }
    var gl = this._gl;
    return new Promise(function(resolve, reject) {
      var check = function() {
        var res = gl.clientWaitSync(sync, flags, 0);
        if (res == gl.WAIT_FAILED) {
          reject();
          return;
        }
        if (res == gl.TIMEOUT_EXPIRED) {
          setTimeout(check, interval_ms);
          return;
        }
        resolve();
      };
      check();
    });
  };
  Engine2.prototype._readPixelsAsync = function(x, y, w, h, format, type, outputBuffer) {
    if (this._webGLVersion < 2) {
      throw new Error("_readPixelsAsync only work on WebGL2+");
    }
    var gl = this._gl;
    var buf = gl.createBuffer();
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
    gl.bufferData(gl.PIXEL_PACK_BUFFER, outputBuffer.byteLength, gl.STREAM_READ);
    gl.readPixels(x, y, w, h, format, type, 0);
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
    var sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
    if (!sync) {
      return null;
    }
    gl.flush();
    return this._clientWaitAsync(sync, 0, 10).then(function() {
      gl.deleteSync(sync);
      gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
      gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, outputBuffer);
      gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
      gl.deleteBuffer(buf);
      return outputBuffer;
    });
  };
  Engine2.prototype.dispose = function() {
    this.hideLoadingUI();
    this.onNewSceneAddedObservable.clear();
    while (this.postProcesses.length) {
      this.postProcesses[0].dispose();
    }
    if (this._rescalePostProcess) {
      this._rescalePostProcess.dispose();
    }
    while (this.scenes.length) {
      this.scenes[0].dispose();
    }
    if (Engine2.Instances.length === 1 && Engine2.audioEngine) {
      Engine2.audioEngine.dispose();
    }
    this.disableVR();
    if (DomManagement.IsWindowObjectExist()) {
      window.removeEventListener("blur", this._onBlur);
      window.removeEventListener("focus", this._onFocus);
      if (this._renderingCanvas) {
        this._renderingCanvas.removeEventListener("focus", this._onCanvasFocus);
        this._renderingCanvas.removeEventListener("blur", this._onCanvasBlur);
        this._renderingCanvas.removeEventListener("pointerout", this._onCanvasPointerOut);
      }
      if (DomManagement.IsDocumentAvailable()) {
        document.removeEventListener("fullscreenchange", this._onFullscreenChange);
        document.removeEventListener("mozfullscreenchange", this._onFullscreenChange);
        document.removeEventListener("webkitfullscreenchange", this._onFullscreenChange);
        document.removeEventListener("msfullscreenchange", this._onFullscreenChange);
        document.removeEventListener("pointerlockchange", this._onPointerLockChange);
        document.removeEventListener("mspointerlockchange", this._onPointerLockChange);
        document.removeEventListener("mozpointerlockchange", this._onPointerLockChange);
        document.removeEventListener("webkitpointerlockchange", this._onPointerLockChange);
      }
    }
    _super.prototype.dispose.call(this);
    var index = Engine2.Instances.indexOf(this);
    if (index >= 0) {
      Engine2.Instances.splice(index, 1);
    }
    this.onResizeObservable.clear();
    this.onCanvasBlurObservable.clear();
    this.onCanvasFocusObservable.clear();
    this.onCanvasPointerOutObservable.clear();
    this.onBeginFrameObservable.clear();
    this.onEndFrameObservable.clear();
  };
  Engine2.prototype._disableTouchAction = function() {
    if (!this._renderingCanvas || !this._renderingCanvas.setAttribute) {
      return;
    }
    this._renderingCanvas.setAttribute("touch-action", "none");
    this._renderingCanvas.style.touchAction = "none";
    this._renderingCanvas.style.msTouchAction = "none";
  };
  Engine2.prototype.displayLoadingUI = function() {
    if (!DomManagement.IsWindowObjectExist()) {
      return;
    }
    var loadingScreen = this.loadingScreen;
    if (loadingScreen) {
      loadingScreen.displayLoadingUI();
    }
  };
  Engine2.prototype.hideLoadingUI = function() {
    if (!DomManagement.IsWindowObjectExist()) {
      return;
    }
    var loadingScreen = this._loadingScreen;
    if (loadingScreen) {
      loadingScreen.hideLoadingUI();
    }
  };
  Object.defineProperty(Engine2.prototype, "loadingScreen", {
    get: function() {
      if (!this._loadingScreen && this._renderingCanvas) {
        this._loadingScreen = Engine2.DefaultLoadingScreenFactory(this._renderingCanvas);
      }
      return this._loadingScreen;
    },
    set: function(loadingScreen) {
      this._loadingScreen = loadingScreen;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Engine2.prototype, "loadingUIText", {
    set: function(text) {
      this.loadingScreen.loadingUIText = text;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Engine2.prototype, "loadingUIBackgroundColor", {
    set: function(color) {
      this.loadingScreen.loadingUIBackgroundColor = color;
    },
    enumerable: false,
    configurable: true
  });
  Engine2._RequestPointerlock = function(element) {
    element.requestPointerLock = element.requestPointerLock || element.msRequestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
    if (element.requestPointerLock) {
      element.requestPointerLock();
    }
  };
  Engine2._ExitPointerlock = function() {
    var anyDoc = document;
    document.exitPointerLock = document.exitPointerLock || anyDoc.msExitPointerLock || anyDoc.mozExitPointerLock || anyDoc.webkitExitPointerLock;
    if (document.exitPointerLock) {
      document.exitPointerLock();
    }
  };
  Engine2._RequestFullscreen = function(element) {
    var requestFunction = element.requestFullscreen || element.msRequestFullscreen || element.webkitRequestFullscreen || element.mozRequestFullScreen;
    if (!requestFunction) {
      return;
    }
    requestFunction.call(element);
  };
  Engine2._ExitFullscreen = function() {
    var anyDoc = document;
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (anyDoc.mozCancelFullScreen) {
      anyDoc.mozCancelFullScreen();
    } else if (anyDoc.webkitCancelFullScreen) {
      anyDoc.webkitCancelFullScreen();
    } else if (anyDoc.msCancelFullScreen) {
      anyDoc.msCancelFullScreen();
    }
  };
  Engine2.ALPHA_DISABLE = 0;
  Engine2.ALPHA_ADD = 1;
  Engine2.ALPHA_COMBINE = 2;
  Engine2.ALPHA_SUBTRACT = 3;
  Engine2.ALPHA_MULTIPLY = 4;
  Engine2.ALPHA_MAXIMIZED = 5;
  Engine2.ALPHA_ONEONE = 6;
  Engine2.ALPHA_PREMULTIPLIED = 7;
  Engine2.ALPHA_PREMULTIPLIED_PORTERDUFF = 8;
  Engine2.ALPHA_INTERPOLATE = 9;
  Engine2.ALPHA_SCREENMODE = 10;
  Engine2.DELAYLOADSTATE_NONE = 0;
  Engine2.DELAYLOADSTATE_LOADED = 1;
  Engine2.DELAYLOADSTATE_LOADING = 2;
  Engine2.DELAYLOADSTATE_NOTLOADED = 4;
  Engine2.NEVER = 512;
  Engine2.ALWAYS = 519;
  Engine2.LESS = 513;
  Engine2.EQUAL = 514;
  Engine2.LEQUAL = 515;
  Engine2.GREATER = 516;
  Engine2.GEQUAL = 518;
  Engine2.NOTEQUAL = 517;
  Engine2.KEEP = 7680;
  Engine2.REPLACE = 7681;
  Engine2.INCR = 7682;
  Engine2.DECR = 7683;
  Engine2.INVERT = 5386;
  Engine2.INCR_WRAP = 34055;
  Engine2.DECR_WRAP = 34056;
  Engine2.TEXTURE_CLAMP_ADDRESSMODE = 0;
  Engine2.TEXTURE_WRAP_ADDRESSMODE = 1;
  Engine2.TEXTURE_MIRROR_ADDRESSMODE = 2;
  Engine2.TEXTUREFORMAT_ALPHA = 0;
  Engine2.TEXTUREFORMAT_LUMINANCE = 1;
  Engine2.TEXTUREFORMAT_LUMINANCE_ALPHA = 2;
  Engine2.TEXTUREFORMAT_RGB = 4;
  Engine2.TEXTUREFORMAT_RGBA = 5;
  Engine2.TEXTUREFORMAT_RED = 6;
  Engine2.TEXTUREFORMAT_R = 6;
  Engine2.TEXTUREFORMAT_RG = 7;
  Engine2.TEXTUREFORMAT_RED_INTEGER = 8;
  Engine2.TEXTUREFORMAT_R_INTEGER = 8;
  Engine2.TEXTUREFORMAT_RG_INTEGER = 9;
  Engine2.TEXTUREFORMAT_RGB_INTEGER = 10;
  Engine2.TEXTUREFORMAT_RGBA_INTEGER = 11;
  Engine2.TEXTURETYPE_UNSIGNED_BYTE = 0;
  Engine2.TEXTURETYPE_UNSIGNED_INT = 0;
  Engine2.TEXTURETYPE_FLOAT = 1;
  Engine2.TEXTURETYPE_HALF_FLOAT = 2;
  Engine2.TEXTURETYPE_BYTE = 3;
  Engine2.TEXTURETYPE_SHORT = 4;
  Engine2.TEXTURETYPE_UNSIGNED_SHORT = 5;
  Engine2.TEXTURETYPE_INT = 6;
  Engine2.TEXTURETYPE_UNSIGNED_INTEGER = 7;
  Engine2.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 = 8;
  Engine2.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 = 9;
  Engine2.TEXTURETYPE_UNSIGNED_SHORT_5_6_5 = 10;
  Engine2.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV = 11;
  Engine2.TEXTURETYPE_UNSIGNED_INT_24_8 = 12;
  Engine2.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV = 13;
  Engine2.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV = 14;
  Engine2.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV = 15;
  Engine2.TEXTURE_NEAREST_SAMPLINGMODE = 1;
  Engine2.TEXTURE_BILINEAR_SAMPLINGMODE = 2;
  Engine2.TEXTURE_TRILINEAR_SAMPLINGMODE = 3;
  Engine2.TEXTURE_NEAREST_NEAREST_MIPLINEAR = 8;
  Engine2.TEXTURE_LINEAR_LINEAR_MIPNEAREST = 11;
  Engine2.TEXTURE_LINEAR_LINEAR_MIPLINEAR = 3;
  Engine2.TEXTURE_NEAREST_NEAREST_MIPNEAREST = 4;
  Engine2.TEXTURE_NEAREST_LINEAR_MIPNEAREST = 5;
  Engine2.TEXTURE_NEAREST_LINEAR_MIPLINEAR = 6;
  Engine2.TEXTURE_NEAREST_LINEAR = 7;
  Engine2.TEXTURE_NEAREST_NEAREST = 1;
  Engine2.TEXTURE_LINEAR_NEAREST_MIPNEAREST = 9;
  Engine2.TEXTURE_LINEAR_NEAREST_MIPLINEAR = 10;
  Engine2.TEXTURE_LINEAR_LINEAR = 2;
  Engine2.TEXTURE_LINEAR_NEAREST = 12;
  Engine2.TEXTURE_EXPLICIT_MODE = 0;
  Engine2.TEXTURE_SPHERICAL_MODE = 1;
  Engine2.TEXTURE_PLANAR_MODE = 2;
  Engine2.TEXTURE_CUBIC_MODE = 3;
  Engine2.TEXTURE_PROJECTION_MODE = 4;
  Engine2.TEXTURE_SKYBOX_MODE = 5;
  Engine2.TEXTURE_INVCUBIC_MODE = 6;
  Engine2.TEXTURE_EQUIRECTANGULAR_MODE = 7;
  Engine2.TEXTURE_FIXED_EQUIRECTANGULAR_MODE = 8;
  Engine2.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;
  Engine2.SCALEMODE_FLOOR = 1;
  Engine2.SCALEMODE_NEAREST = 2;
  Engine2.SCALEMODE_CEILING = 3;
  Engine2._RescalePostProcessFactory = null;
  return Engine2;
}(ThinEngine);

// node_modules/@babylonjs/core/Meshes/buffer.js
var Buffer2 = function() {
  function Buffer3(engine, data, updatable, stride, postponeInternalCreation, instanced, useBytes, divisor) {
    if (stride === void 0) {
      stride = 0;
    }
    if (postponeInternalCreation === void 0) {
      postponeInternalCreation = false;
    }
    if (instanced === void 0) {
      instanced = false;
    }
    if (useBytes === void 0) {
      useBytes = false;
    }
    this._isAlreadyOwned = false;
    if (engine.getScene) {
      this._engine = engine.getScene().getEngine();
    } else {
      this._engine = engine;
    }
    this._updatable = updatable;
    this._instanced = instanced;
    this._divisor = divisor || 1;
    this._data = data;
    this.byteStride = useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT;
    if (!postponeInternalCreation) {
      this.create();
    }
  }
  Buffer3.prototype.createVertexBuffer = function(kind, offset, size, stride, instanced, useBytes, divisor) {
    if (useBytes === void 0) {
      useBytes = false;
    }
    var byteOffset = useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT;
    var byteStride = stride ? useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT : this.byteStride;
    return new VertexBuffer(this._engine, this, kind, this._updatable, true, byteStride, instanced === void 0 ? this._instanced : instanced, byteOffset, size, void 0, void 0, true, this._divisor || divisor);
  };
  Buffer3.prototype.isUpdatable = function() {
    return this._updatable;
  };
  Buffer3.prototype.getData = function() {
    return this._data;
  };
  Buffer3.prototype.getBuffer = function() {
    return this._buffer;
  };
  Buffer3.prototype.getStrideSize = function() {
    return this.byteStride / Float32Array.BYTES_PER_ELEMENT;
  };
  Buffer3.prototype.create = function(data) {
    if (data === void 0) {
      data = null;
    }
    if (!data && this._buffer) {
      return;
    }
    data = data || this._data;
    if (!data) {
      return;
    }
    if (!this._buffer) {
      if (this._updatable) {
        this._buffer = this._engine.createDynamicVertexBuffer(data);
        this._data = data;
      } else {
        this._buffer = this._engine.createVertexBuffer(data);
      }
    } else if (this._updatable) {
      this._engine.updateDynamicVertexBuffer(this._buffer, data);
      this._data = data;
    }
  };
  Buffer3.prototype._rebuild = function() {
    this._buffer = null;
    this.create(this._data);
  };
  Buffer3.prototype.update = function(data) {
    this.create(data);
  };
  Buffer3.prototype.updateDirectly = function(data, offset, vertexCount, useBytes) {
    if (useBytes === void 0) {
      useBytes = false;
    }
    if (!this._buffer) {
      return;
    }
    if (this._updatable) {
      this._engine.updateDynamicVertexBuffer(this._buffer, data, useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT, vertexCount ? vertexCount * this.byteStride : void 0);
      this._data = null;
    }
  };
  Buffer3.prototype._increaseReferences = function() {
    if (!this._buffer) {
      return;
    }
    if (!this._isAlreadyOwned) {
      this._isAlreadyOwned = true;
      return;
    }
    this._buffer.references++;
  };
  Buffer3.prototype.dispose = function() {
    if (!this._buffer) {
      return;
    }
    if (this._engine._releaseBuffer(this._buffer)) {
      this._buffer = null;
    }
  };
  return Buffer3;
}();
var VertexBuffer = function() {
  function VertexBuffer2(engine, data, kind, updatable, postponeInternalCreation, stride, instanced, offset, size, type, normalized, useBytes, divisor, takeBufferOwnership) {
    if (normalized === void 0) {
      normalized = false;
    }
    if (useBytes === void 0) {
      useBytes = false;
    }
    if (divisor === void 0) {
      divisor = 1;
    }
    if (takeBufferOwnership === void 0) {
      takeBufferOwnership = false;
    }
    if (data instanceof Buffer2) {
      this._buffer = data;
      this._ownsBuffer = takeBufferOwnership;
      if (takeBufferOwnership) {
        this._buffer._increaseReferences();
      }
    } else {
      this._buffer = new Buffer2(engine, data, updatable, stride, postponeInternalCreation, instanced, useBytes);
      this._ownsBuffer = true;
    }
    this._kind = kind;
    if (type == void 0) {
      var data_1 = this.getData();
      this.type = VertexBuffer2.FLOAT;
      if (data_1 instanceof Int8Array) {
        this.type = VertexBuffer2.BYTE;
      } else if (data_1 instanceof Uint8Array) {
        this.type = VertexBuffer2.UNSIGNED_BYTE;
      } else if (data_1 instanceof Int16Array) {
        this.type = VertexBuffer2.SHORT;
      } else if (data_1 instanceof Uint16Array) {
        this.type = VertexBuffer2.UNSIGNED_SHORT;
      } else if (data_1 instanceof Int32Array) {
        this.type = VertexBuffer2.INT;
      } else if (data_1 instanceof Uint32Array) {
        this.type = VertexBuffer2.UNSIGNED_INT;
      }
    } else {
      this.type = type;
    }
    var typeByteLength = VertexBuffer2.GetTypeByteLength(this.type);
    if (useBytes) {
      this._size = size || (stride ? stride / typeByteLength : VertexBuffer2.DeduceStride(kind));
      this.byteStride = stride || this._buffer.byteStride || this._size * typeByteLength;
      this.byteOffset = offset || 0;
    } else {
      this._size = size || stride || VertexBuffer2.DeduceStride(kind);
      this.byteStride = stride ? stride * typeByteLength : this._buffer.byteStride || this._size * typeByteLength;
      this.byteOffset = (offset || 0) * typeByteLength;
    }
    this.normalized = normalized;
    this._instanced = instanced !== void 0 ? instanced : false;
    this._instanceDivisor = instanced ? divisor : 0;
  }
  Object.defineProperty(VertexBuffer2.prototype, "instanceDivisor", {
    get: function() {
      return this._instanceDivisor;
    },
    set: function(value) {
      this._instanceDivisor = value;
      if (value == 0) {
        this._instanced = false;
      } else {
        this._instanced = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  VertexBuffer2.prototype._rebuild = function() {
    if (!this._buffer) {
      return;
    }
    this._buffer._rebuild();
  };
  VertexBuffer2.prototype.getKind = function() {
    return this._kind;
  };
  VertexBuffer2.prototype.isUpdatable = function() {
    return this._buffer.isUpdatable();
  };
  VertexBuffer2.prototype.getData = function() {
    return this._buffer.getData();
  };
  VertexBuffer2.prototype.getBuffer = function() {
    return this._buffer.getBuffer();
  };
  VertexBuffer2.prototype.getStrideSize = function() {
    return this.byteStride / VertexBuffer2.GetTypeByteLength(this.type);
  };
  VertexBuffer2.prototype.getOffset = function() {
    return this.byteOffset / VertexBuffer2.GetTypeByteLength(this.type);
  };
  VertexBuffer2.prototype.getSize = function() {
    return this._size;
  };
  VertexBuffer2.prototype.getIsInstanced = function() {
    return this._instanced;
  };
  VertexBuffer2.prototype.getInstanceDivisor = function() {
    return this._instanceDivisor;
  };
  VertexBuffer2.prototype.create = function(data) {
    this._buffer.create(data);
  };
  VertexBuffer2.prototype.update = function(data) {
    this._buffer.update(data);
  };
  VertexBuffer2.prototype.updateDirectly = function(data, offset, useBytes) {
    if (useBytes === void 0) {
      useBytes = false;
    }
    this._buffer.updateDirectly(data, offset, void 0, useBytes);
  };
  VertexBuffer2.prototype.dispose = function() {
    if (this._ownsBuffer) {
      this._buffer.dispose();
    }
  };
  VertexBuffer2.prototype.forEach = function(count, callback) {
    VertexBuffer2.ForEach(this._buffer.getData(), this.byteOffset, this.byteStride, this._size, this.type, count, this.normalized, callback);
  };
  VertexBuffer2.DeduceStride = function(kind) {
    switch (kind) {
      case VertexBuffer2.UVKind:
      case VertexBuffer2.UV2Kind:
      case VertexBuffer2.UV3Kind:
      case VertexBuffer2.UV4Kind:
      case VertexBuffer2.UV5Kind:
      case VertexBuffer2.UV6Kind:
        return 2;
      case VertexBuffer2.NormalKind:
      case VertexBuffer2.PositionKind:
        return 3;
      case VertexBuffer2.ColorKind:
      case VertexBuffer2.MatricesIndicesKind:
      case VertexBuffer2.MatricesIndicesExtraKind:
      case VertexBuffer2.MatricesWeightsKind:
      case VertexBuffer2.MatricesWeightsExtraKind:
      case VertexBuffer2.TangentKind:
        return 4;
      default:
        throw new Error("Invalid kind '" + kind + "'");
    }
  };
  VertexBuffer2.GetTypeByteLength = function(type) {
    switch (type) {
      case VertexBuffer2.BYTE:
      case VertexBuffer2.UNSIGNED_BYTE:
        return 1;
      case VertexBuffer2.SHORT:
      case VertexBuffer2.UNSIGNED_SHORT:
        return 2;
      case VertexBuffer2.INT:
      case VertexBuffer2.UNSIGNED_INT:
      case VertexBuffer2.FLOAT:
        return 4;
      default:
        throw new Error("Invalid type '" + type + "'");
    }
  };
  VertexBuffer2.ForEach = function(data, byteOffset, byteStride, componentCount, componentType, count, normalized, callback) {
    if (data instanceof Array) {
      var offset = byteOffset / 4;
      var stride = byteStride / 4;
      for (var index = 0; index < count; index += componentCount) {
        for (var componentIndex = 0; componentIndex < componentCount; componentIndex++) {
          callback(data[offset + componentIndex], index + componentIndex);
        }
        offset += stride;
      }
    } else {
      var dataView = data instanceof ArrayBuffer ? new DataView(data) : new DataView(data.buffer, data.byteOffset, data.byteLength);
      var componentByteLength = VertexBuffer2.GetTypeByteLength(componentType);
      for (var index = 0; index < count; index += componentCount) {
        var componentByteOffset = byteOffset;
        for (var componentIndex = 0; componentIndex < componentCount; componentIndex++) {
          var value = VertexBuffer2._GetFloatValue(dataView, componentType, componentByteOffset, normalized);
          callback(value, index + componentIndex);
          componentByteOffset += componentByteLength;
        }
        byteOffset += byteStride;
      }
    }
  };
  VertexBuffer2._GetFloatValue = function(dataView, type, byteOffset, normalized) {
    switch (type) {
      case VertexBuffer2.BYTE: {
        var value = dataView.getInt8(byteOffset);
        if (normalized) {
          value = Math.max(value / 127, -1);
        }
        return value;
      }
      case VertexBuffer2.UNSIGNED_BYTE: {
        var value = dataView.getUint8(byteOffset);
        if (normalized) {
          value = value / 255;
        }
        return value;
      }
      case VertexBuffer2.SHORT: {
        var value = dataView.getInt16(byteOffset, true);
        if (normalized) {
          value = Math.max(value / 32767, -1);
        }
        return value;
      }
      case VertexBuffer2.UNSIGNED_SHORT: {
        var value = dataView.getUint16(byteOffset, true);
        if (normalized) {
          value = value / 65535;
        }
        return value;
      }
      case VertexBuffer2.INT: {
        return dataView.getInt32(byteOffset, true);
      }
      case VertexBuffer2.UNSIGNED_INT: {
        return dataView.getUint32(byteOffset, true);
      }
      case VertexBuffer2.FLOAT: {
        return dataView.getFloat32(byteOffset, true);
      }
      default: {
        throw new Error("Invalid component type " + type);
      }
    }
  };
  VertexBuffer2.BYTE = 5120;
  VertexBuffer2.UNSIGNED_BYTE = 5121;
  VertexBuffer2.SHORT = 5122;
  VertexBuffer2.UNSIGNED_SHORT = 5123;
  VertexBuffer2.INT = 5124;
  VertexBuffer2.UNSIGNED_INT = 5125;
  VertexBuffer2.FLOAT = 5126;
  VertexBuffer2.PositionKind = "position";
  VertexBuffer2.NormalKind = "normal";
  VertexBuffer2.TangentKind = "tangent";
  VertexBuffer2.UVKind = "uv";
  VertexBuffer2.UV2Kind = "uv2";
  VertexBuffer2.UV3Kind = "uv3";
  VertexBuffer2.UV4Kind = "uv4";
  VertexBuffer2.UV5Kind = "uv5";
  VertexBuffer2.UV6Kind = "uv6";
  VertexBuffer2.ColorKind = "color";
  VertexBuffer2.MatricesIndicesKind = "matricesIndices";
  VertexBuffer2.MatricesWeightsKind = "matricesWeights";
  VertexBuffer2.MatricesIndicesExtraKind = "matricesIndicesExtra";
  VertexBuffer2.MatricesWeightsExtraKind = "matricesWeightsExtra";
  return VertexBuffer2;
}();

// node_modules/@babylonjs/core/Meshes/mesh.vertexData.js
var VertexData = function() {
  function VertexData2() {
  }
  VertexData2.prototype.set = function(data, kind) {
    if (!data.length) {
      Logger.Warn("Setting vertex data kind '" + kind + "' with an empty array");
    }
    switch (kind) {
      case VertexBuffer.PositionKind:
        this.positions = data;
        break;
      case VertexBuffer.NormalKind:
        this.normals = data;
        break;
      case VertexBuffer.TangentKind:
        this.tangents = data;
        break;
      case VertexBuffer.UVKind:
        this.uvs = data;
        break;
      case VertexBuffer.UV2Kind:
        this.uvs2 = data;
        break;
      case VertexBuffer.UV3Kind:
        this.uvs3 = data;
        break;
      case VertexBuffer.UV4Kind:
        this.uvs4 = data;
        break;
      case VertexBuffer.UV5Kind:
        this.uvs5 = data;
        break;
      case VertexBuffer.UV6Kind:
        this.uvs6 = data;
        break;
      case VertexBuffer.ColorKind:
        this.colors = data;
        break;
      case VertexBuffer.MatricesIndicesKind:
        this.matricesIndices = data;
        break;
      case VertexBuffer.MatricesWeightsKind:
        this.matricesWeights = data;
        break;
      case VertexBuffer.MatricesIndicesExtraKind:
        this.matricesIndicesExtra = data;
        break;
      case VertexBuffer.MatricesWeightsExtraKind:
        this.matricesWeightsExtra = data;
        break;
    }
  };
  VertexData2.prototype.applyToMesh = function(mesh, updatable) {
    this._applyTo(mesh, updatable);
    return this;
  };
  VertexData2.prototype.applyToGeometry = function(geometry, updatable) {
    this._applyTo(geometry, updatable);
    return this;
  };
  VertexData2.prototype.updateMesh = function(mesh) {
    this._update(mesh);
    return this;
  };
  VertexData2.prototype.updateGeometry = function(geometry) {
    this._update(geometry);
    return this;
  };
  VertexData2.prototype._applyTo = function(meshOrGeometry, updatable) {
    if (updatable === void 0) {
      updatable = false;
    }
    if (this.positions) {
      meshOrGeometry.setVerticesData(VertexBuffer.PositionKind, this.positions, updatable);
    }
    if (this.normals) {
      meshOrGeometry.setVerticesData(VertexBuffer.NormalKind, this.normals, updatable);
    }
    if (this.tangents) {
      meshOrGeometry.setVerticesData(VertexBuffer.TangentKind, this.tangents, updatable);
    }
    if (this.uvs) {
      meshOrGeometry.setVerticesData(VertexBuffer.UVKind, this.uvs, updatable);
    }
    if (this.uvs2) {
      meshOrGeometry.setVerticesData(VertexBuffer.UV2Kind, this.uvs2, updatable);
    }
    if (this.uvs3) {
      meshOrGeometry.setVerticesData(VertexBuffer.UV3Kind, this.uvs3, updatable);
    }
    if (this.uvs4) {
      meshOrGeometry.setVerticesData(VertexBuffer.UV4Kind, this.uvs4, updatable);
    }
    if (this.uvs5) {
      meshOrGeometry.setVerticesData(VertexBuffer.UV5Kind, this.uvs5, updatable);
    }
    if (this.uvs6) {
      meshOrGeometry.setVerticesData(VertexBuffer.UV6Kind, this.uvs6, updatable);
    }
    if (this.colors) {
      meshOrGeometry.setVerticesData(VertexBuffer.ColorKind, this.colors, updatable);
    }
    if (this.matricesIndices) {
      meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updatable);
    }
    if (this.matricesWeights) {
      meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updatable);
    }
    if (this.matricesIndicesExtra) {
      meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updatable);
    }
    if (this.matricesWeightsExtra) {
      meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updatable);
    }
    if (this.indices) {
      meshOrGeometry.setIndices(this.indices, null, updatable);
    } else {
      meshOrGeometry.setIndices([], null);
    }
    return this;
  };
  VertexData2.prototype._update = function(meshOrGeometry, updateExtends, makeItUnique) {
    if (this.positions) {
      meshOrGeometry.updateVerticesData(VertexBuffer.PositionKind, this.positions, updateExtends, makeItUnique);
    }
    if (this.normals) {
      meshOrGeometry.updateVerticesData(VertexBuffer.NormalKind, this.normals, updateExtends, makeItUnique);
    }
    if (this.tangents) {
      meshOrGeometry.updateVerticesData(VertexBuffer.TangentKind, this.tangents, updateExtends, makeItUnique);
    }
    if (this.uvs) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UVKind, this.uvs, updateExtends, makeItUnique);
    }
    if (this.uvs2) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV2Kind, this.uvs2, updateExtends, makeItUnique);
    }
    if (this.uvs3) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV3Kind, this.uvs3, updateExtends, makeItUnique);
    }
    if (this.uvs4) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV4Kind, this.uvs4, updateExtends, makeItUnique);
    }
    if (this.uvs5) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV5Kind, this.uvs5, updateExtends, makeItUnique);
    }
    if (this.uvs6) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV6Kind, this.uvs6, updateExtends, makeItUnique);
    }
    if (this.colors) {
      meshOrGeometry.updateVerticesData(VertexBuffer.ColorKind, this.colors, updateExtends, makeItUnique);
    }
    if (this.matricesIndices) {
      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updateExtends, makeItUnique);
    }
    if (this.matricesWeights) {
      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updateExtends, makeItUnique);
    }
    if (this.matricesIndicesExtra) {
      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updateExtends, makeItUnique);
    }
    if (this.matricesWeightsExtra) {
      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updateExtends, makeItUnique);
    }
    if (this.indices) {
      meshOrGeometry.setIndices(this.indices, null);
    }
    return this;
  };
  VertexData2.prototype.transform = function(matrix) {
    var flip = matrix.determinant() < 0;
    var transformed = Vector3.Zero();
    var index;
    if (this.positions) {
      var position = Vector3.Zero();
      for (index = 0; index < this.positions.length; index += 3) {
        Vector3.FromArrayToRef(this.positions, index, position);
        Vector3.TransformCoordinatesToRef(position, matrix, transformed);
        this.positions[index] = transformed.x;
        this.positions[index + 1] = transformed.y;
        this.positions[index + 2] = transformed.z;
      }
    }
    if (this.normals) {
      var normal = Vector3.Zero();
      for (index = 0; index < this.normals.length; index += 3) {
        Vector3.FromArrayToRef(this.normals, index, normal);
        Vector3.TransformNormalToRef(normal, matrix, transformed);
        this.normals[index] = transformed.x;
        this.normals[index + 1] = transformed.y;
        this.normals[index + 2] = transformed.z;
      }
    }
    if (this.tangents) {
      var tangent = Vector4.Zero();
      var tangentTransformed = Vector4.Zero();
      for (index = 0; index < this.tangents.length; index += 4) {
        Vector4.FromArrayToRef(this.tangents, index, tangent);
        Vector4.TransformNormalToRef(tangent, matrix, tangentTransformed);
        this.tangents[index] = tangentTransformed.x;
        this.tangents[index + 1] = tangentTransformed.y;
        this.tangents[index + 2] = tangentTransformed.z;
        this.tangents[index + 3] = tangentTransformed.w;
      }
    }
    if (flip && this.indices) {
      for (index = 0; index < this.indices.length; index += 3) {
        var tmp = this.indices[index + 1];
        this.indices[index + 1] = this.indices[index + 2];
        this.indices[index + 2] = tmp;
      }
    }
    return this;
  };
  VertexData2.prototype.merge = function(other, use32BitsIndices) {
    if (use32BitsIndices === void 0) {
      use32BitsIndices = false;
    }
    this._validate();
    other._validate();
    if (!this.normals !== !other.normals || !this.tangents !== !other.tangents || !this.uvs !== !other.uvs || !this.uvs2 !== !other.uvs2 || !this.uvs3 !== !other.uvs3 || !this.uvs4 !== !other.uvs4 || !this.uvs5 !== !other.uvs5 || !this.uvs6 !== !other.uvs6 || !this.colors !== !other.colors || !this.matricesIndices !== !other.matricesIndices || !this.matricesWeights !== !other.matricesWeights || !this.matricesIndicesExtra !== !other.matricesIndicesExtra || !this.matricesWeightsExtra !== !other.matricesWeightsExtra) {
      throw new Error("Cannot merge vertex data that do not have the same set of attributes");
    }
    if (other.indices) {
      if (!this.indices) {
        this.indices = [];
      }
      var offset = this.positions ? this.positions.length / 3 : 0;
      var isSrcTypedArray = this.indices.BYTES_PER_ELEMENT !== void 0;
      if (isSrcTypedArray) {
        var len = this.indices.length + other.indices.length;
        var temp = use32BitsIndices || this.indices instanceof Uint32Array ? new Uint32Array(len) : new Uint16Array(len);
        temp.set(this.indices);
        var decal = this.indices.length;
        for (var index = 0; index < other.indices.length; index++) {
          temp[decal + index] = other.indices[index] + offset;
        }
        this.indices = temp;
      } else {
        for (var index = 0; index < other.indices.length; index++) {
          this.indices.push(other.indices[index] + offset);
        }
      }
    }
    this.positions = this._mergeElement(this.positions, other.positions);
    this.normals = this._mergeElement(this.normals, other.normals);
    this.tangents = this._mergeElement(this.tangents, other.tangents);
    this.uvs = this._mergeElement(this.uvs, other.uvs);
    this.uvs2 = this._mergeElement(this.uvs2, other.uvs2);
    this.uvs3 = this._mergeElement(this.uvs3, other.uvs3);
    this.uvs4 = this._mergeElement(this.uvs4, other.uvs4);
    this.uvs5 = this._mergeElement(this.uvs5, other.uvs5);
    this.uvs6 = this._mergeElement(this.uvs6, other.uvs6);
    this.colors = this._mergeElement(this.colors, other.colors);
    this.matricesIndices = this._mergeElement(this.matricesIndices, other.matricesIndices);
    this.matricesWeights = this._mergeElement(this.matricesWeights, other.matricesWeights);
    this.matricesIndicesExtra = this._mergeElement(this.matricesIndicesExtra, other.matricesIndicesExtra);
    this.matricesWeightsExtra = this._mergeElement(this.matricesWeightsExtra, other.matricesWeightsExtra);
    return this;
  };
  VertexData2.prototype._mergeElement = function(source, other) {
    if (!source) {
      return other;
    }
    if (!other) {
      return source;
    }
    var len = other.length + source.length;
    var isSrcTypedArray = source instanceof Float32Array;
    var isOthTypedArray = other instanceof Float32Array;
    if (isSrcTypedArray) {
      var ret32 = new Float32Array(len);
      ret32.set(source);
      ret32.set(other, source.length);
      return ret32;
    } else if (!isOthTypedArray) {
      return source.concat(other);
    } else {
      var ret = source.slice(0);
      for (var i = 0, len = other.length; i < len; i++) {
        ret.push(other[i]);
      }
      return ret;
    }
  };
  VertexData2.prototype._validate = function() {
    if (!this.positions) {
      throw new Error("Positions are required");
    }
    var getElementCount = function(kind, values) {
      var stride = VertexBuffer.DeduceStride(kind);
      if (values.length % stride !== 0) {
        throw new Error("The " + kind + "s array count must be a multiple of " + stride);
      }
      return values.length / stride;
    };
    var positionsElementCount = getElementCount(VertexBuffer.PositionKind, this.positions);
    var validateElementCount = function(kind, values) {
      var elementCount = getElementCount(kind, values);
      if (elementCount !== positionsElementCount) {
        throw new Error("The " + kind + "s element count (" + elementCount + ") does not match the positions count (" + positionsElementCount + ")");
      }
    };
    if (this.normals) {
      validateElementCount(VertexBuffer.NormalKind, this.normals);
    }
    if (this.tangents) {
      validateElementCount(VertexBuffer.TangentKind, this.tangents);
    }
    if (this.uvs) {
      validateElementCount(VertexBuffer.UVKind, this.uvs);
    }
    if (this.uvs2) {
      validateElementCount(VertexBuffer.UV2Kind, this.uvs2);
    }
    if (this.uvs3) {
      validateElementCount(VertexBuffer.UV3Kind, this.uvs3);
    }
    if (this.uvs4) {
      validateElementCount(VertexBuffer.UV4Kind, this.uvs4);
    }
    if (this.uvs5) {
      validateElementCount(VertexBuffer.UV5Kind, this.uvs5);
    }
    if (this.uvs6) {
      validateElementCount(VertexBuffer.UV6Kind, this.uvs6);
    }
    if (this.colors) {
      validateElementCount(VertexBuffer.ColorKind, this.colors);
    }
    if (this.matricesIndices) {
      validateElementCount(VertexBuffer.MatricesIndicesKind, this.matricesIndices);
    }
    if (this.matricesWeights) {
      validateElementCount(VertexBuffer.MatricesWeightsKind, this.matricesWeights);
    }
    if (this.matricesIndicesExtra) {
      validateElementCount(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra);
    }
    if (this.matricesWeightsExtra) {
      validateElementCount(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra);
    }
  };
  VertexData2.prototype.serialize = function() {
    var serializationObject = this.serialize();
    if (this.positions) {
      serializationObject.positions = this.positions;
    }
    if (this.normals) {
      serializationObject.normals = this.normals;
    }
    if (this.tangents) {
      serializationObject.tangents = this.tangents;
    }
    if (this.uvs) {
      serializationObject.uvs = this.uvs;
    }
    if (this.uvs2) {
      serializationObject.uvs2 = this.uvs2;
    }
    if (this.uvs3) {
      serializationObject.uvs3 = this.uvs3;
    }
    if (this.uvs4) {
      serializationObject.uvs4 = this.uvs4;
    }
    if (this.uvs5) {
      serializationObject.uvs5 = this.uvs5;
    }
    if (this.uvs6) {
      serializationObject.uvs6 = this.uvs6;
    }
    if (this.colors) {
      serializationObject.colors = this.colors;
    }
    if (this.matricesIndices) {
      serializationObject.matricesIndices = this.matricesIndices;
      serializationObject.matricesIndices._isExpanded = true;
    }
    if (this.matricesWeights) {
      serializationObject.matricesWeights = this.matricesWeights;
    }
    if (this.matricesIndicesExtra) {
      serializationObject.matricesIndicesExtra = this.matricesIndicesExtra;
      serializationObject.matricesIndicesExtra._isExpanded = true;
    }
    if (this.matricesWeightsExtra) {
      serializationObject.matricesWeightsExtra = this.matricesWeightsExtra;
    }
    serializationObject.indices = this.indices;
    return serializationObject;
  };
  VertexData2.ExtractFromMesh = function(mesh, copyWhenShared, forceCopy) {
    return VertexData2._ExtractFrom(mesh, copyWhenShared, forceCopy);
  };
  VertexData2.ExtractFromGeometry = function(geometry, copyWhenShared, forceCopy) {
    return VertexData2._ExtractFrom(geometry, copyWhenShared, forceCopy);
  };
  VertexData2._ExtractFrom = function(meshOrGeometry, copyWhenShared, forceCopy) {
    var result = new VertexData2();
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.PositionKind)) {
      result.positions = meshOrGeometry.getVerticesData(VertexBuffer.PositionKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      result.normals = meshOrGeometry.getVerticesData(VertexBuffer.NormalKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.TangentKind)) {
      result.tangents = meshOrGeometry.getVerticesData(VertexBuffer.TangentKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UVKind)) {
      result.uvs = meshOrGeometry.getVerticesData(VertexBuffer.UVKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
      result.uvs2 = meshOrGeometry.getVerticesData(VertexBuffer.UV2Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV3Kind)) {
      result.uvs3 = meshOrGeometry.getVerticesData(VertexBuffer.UV3Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV4Kind)) {
      result.uvs4 = meshOrGeometry.getVerticesData(VertexBuffer.UV4Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV5Kind)) {
      result.uvs5 = meshOrGeometry.getVerticesData(VertexBuffer.UV5Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV6Kind)) {
      result.uvs6 = meshOrGeometry.getVerticesData(VertexBuffer.UV6Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.ColorKind)) {
      result.colors = meshOrGeometry.getVerticesData(VertexBuffer.ColorKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {
      result.matricesIndices = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
      result.matricesWeights = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesExtraKind)) {
      result.matricesIndicesExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesExtraKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {
      result.matricesWeightsExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsExtraKind, copyWhenShared, forceCopy);
    }
    result.indices = meshOrGeometry.getIndices(copyWhenShared, forceCopy);
    return result;
  };
  VertexData2.CreateRibbon = function(options) {
    throw _DevTools.WarnImport("ribbonBuilder");
  };
  VertexData2.CreateBox = function(options) {
    throw _DevTools.WarnImport("boxBuilder");
  };
  VertexData2.CreateTiledBox = function(options) {
    throw _DevTools.WarnImport("tiledBoxBuilder");
  };
  VertexData2.CreateTiledPlane = function(options) {
    throw _DevTools.WarnImport("tiledPlaneBuilder");
  };
  VertexData2.CreateSphere = function(options) {
    throw _DevTools.WarnImport("sphereBuilder");
  };
  VertexData2.CreateCylinder = function(options) {
    throw _DevTools.WarnImport("cylinderBuilder");
  };
  VertexData2.CreateTorus = function(options) {
    throw _DevTools.WarnImport("torusBuilder");
  };
  VertexData2.CreateLineSystem = function(options) {
    throw _DevTools.WarnImport("linesBuilder");
  };
  VertexData2.CreateDashedLines = function(options) {
    throw _DevTools.WarnImport("linesBuilder");
  };
  VertexData2.CreateGround = function(options) {
    throw _DevTools.WarnImport("groundBuilder");
  };
  VertexData2.CreateTiledGround = function(options) {
    throw _DevTools.WarnImport("groundBuilder");
  };
  VertexData2.CreateGroundFromHeightMap = function(options) {
    throw _DevTools.WarnImport("groundBuilder");
  };
  VertexData2.CreatePlane = function(options) {
    throw _DevTools.WarnImport("planeBuilder");
  };
  VertexData2.CreateDisc = function(options) {
    throw _DevTools.WarnImport("discBuilder");
  };
  VertexData2.CreatePolygon = function(polygon, sideOrientation, fUV, fColors, frontUVs, backUVs, wrap) {
    throw _DevTools.WarnImport("polygonBuilder");
  };
  VertexData2.CreateIcoSphere = function(options) {
    throw _DevTools.WarnImport("icoSphereBuilder");
  };
  VertexData2.CreatePolyhedron = function(options) {
    throw _DevTools.WarnImport("polyhedronBuilder");
  };
  VertexData2.CreateCapsule = function(options) {
    if (options === void 0) {
      options = {
        orientation: Vector3.Up(),
        subdivisions: 2,
        tessellation: 16,
        height: 1,
        radius: 0.25,
        capSubdivisions: 6
      };
    }
    throw _DevTools.WarnImport("capsuleBuilder");
  };
  VertexData2.CreateTorusKnot = function(options) {
    throw _DevTools.WarnImport("torusKnotBuilder");
  };
  VertexData2.ComputeNormals = function(positions, indices, normals, options) {
    var index = 0;
    var p1p2x = 0;
    var p1p2y = 0;
    var p1p2z = 0;
    var p3p2x = 0;
    var p3p2y = 0;
    var p3p2z = 0;
    var faceNormalx = 0;
    var faceNormaly = 0;
    var faceNormalz = 0;
    var length = 0;
    var v1x = 0;
    var v1y = 0;
    var v1z = 0;
    var v2x = 0;
    var v2y = 0;
    var v2z = 0;
    var v3x = 0;
    var v3y = 0;
    var v3z = 0;
    var computeFacetNormals = false;
    var computeFacetPositions = false;
    var computeFacetPartitioning = false;
    var computeDepthSort = false;
    var faceNormalSign = 1;
    var ratio = 0;
    var distanceTo = null;
    if (options) {
      computeFacetNormals = options.facetNormals ? true : false;
      computeFacetPositions = options.facetPositions ? true : false;
      computeFacetPartitioning = options.facetPartitioning ? true : false;
      faceNormalSign = options.useRightHandedSystem === true ? -1 : 1;
      ratio = options.ratio || 0;
      computeDepthSort = options.depthSort ? true : false;
      distanceTo = options.distanceTo;
      if (computeDepthSort) {
        if (distanceTo === void 0) {
          distanceTo = Vector3.Zero();
        }
        var depthSortedFacets = options.depthSortedFacets;
      }
    }
    var xSubRatio = 0;
    var ySubRatio = 0;
    var zSubRatio = 0;
    var subSq = 0;
    if (computeFacetPartitioning && options && options.bbSize) {
      var ox = 0;
      var oy = 0;
      var oz = 0;
      var b1x = 0;
      var b1y = 0;
      var b1z = 0;
      var b2x = 0;
      var b2y = 0;
      var b2z = 0;
      var b3x = 0;
      var b3y = 0;
      var b3z = 0;
      var block_idx_o = 0;
      var block_idx_v1 = 0;
      var block_idx_v2 = 0;
      var block_idx_v3 = 0;
      var bbSizeMax = options.bbSize.x > options.bbSize.y ? options.bbSize.x : options.bbSize.y;
      bbSizeMax = bbSizeMax > options.bbSize.z ? bbSizeMax : options.bbSize.z;
      xSubRatio = options.subDiv.X * ratio / options.bbSize.x;
      ySubRatio = options.subDiv.Y * ratio / options.bbSize.y;
      zSubRatio = options.subDiv.Z * ratio / options.bbSize.z;
      subSq = options.subDiv.max * options.subDiv.max;
      options.facetPartitioning.length = 0;
    }
    for (index = 0; index < positions.length; index++) {
      normals[index] = 0;
    }
    var nbFaces = indices.length / 3 | 0;
    for (index = 0; index < nbFaces; index++) {
      v1x = indices[index * 3] * 3;
      v1y = v1x + 1;
      v1z = v1x + 2;
      v2x = indices[index * 3 + 1] * 3;
      v2y = v2x + 1;
      v2z = v2x + 2;
      v3x = indices[index * 3 + 2] * 3;
      v3y = v3x + 1;
      v3z = v3x + 2;
      p1p2x = positions[v1x] - positions[v2x];
      p1p2y = positions[v1y] - positions[v2y];
      p1p2z = positions[v1z] - positions[v2z];
      p3p2x = positions[v3x] - positions[v2x];
      p3p2y = positions[v3y] - positions[v2y];
      p3p2z = positions[v3z] - positions[v2z];
      faceNormalx = faceNormalSign * (p1p2y * p3p2z - p1p2z * p3p2y);
      faceNormaly = faceNormalSign * (p1p2z * p3p2x - p1p2x * p3p2z);
      faceNormalz = faceNormalSign * (p1p2x * p3p2y - p1p2y * p3p2x);
      length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);
      length = length === 0 ? 1 : length;
      faceNormalx /= length;
      faceNormaly /= length;
      faceNormalz /= length;
      if (computeFacetNormals && options) {
        options.facetNormals[index].x = faceNormalx;
        options.facetNormals[index].y = faceNormaly;
        options.facetNormals[index].z = faceNormalz;
      }
      if (computeFacetPositions && options) {
        options.facetPositions[index].x = (positions[v1x] + positions[v2x] + positions[v3x]) / 3;
        options.facetPositions[index].y = (positions[v1y] + positions[v2y] + positions[v3y]) / 3;
        options.facetPositions[index].z = (positions[v1z] + positions[v2z] + positions[v3z]) / 3;
      }
      if (computeFacetPartitioning && options) {
        ox = Math.floor((options.facetPositions[index].x - options.bInfo.minimum.x * ratio) * xSubRatio);
        oy = Math.floor((options.facetPositions[index].y - options.bInfo.minimum.y * ratio) * ySubRatio);
        oz = Math.floor((options.facetPositions[index].z - options.bInfo.minimum.z * ratio) * zSubRatio);
        b1x = Math.floor((positions[v1x] - options.bInfo.minimum.x * ratio) * xSubRatio);
        b1y = Math.floor((positions[v1y] - options.bInfo.minimum.y * ratio) * ySubRatio);
        b1z = Math.floor((positions[v1z] - options.bInfo.minimum.z * ratio) * zSubRatio);
        b2x = Math.floor((positions[v2x] - options.bInfo.minimum.x * ratio) * xSubRatio);
        b2y = Math.floor((positions[v2y] - options.bInfo.minimum.y * ratio) * ySubRatio);
        b2z = Math.floor((positions[v2z] - options.bInfo.minimum.z * ratio) * zSubRatio);
        b3x = Math.floor((positions[v3x] - options.bInfo.minimum.x * ratio) * xSubRatio);
        b3y = Math.floor((positions[v3y] - options.bInfo.minimum.y * ratio) * ySubRatio);
        b3z = Math.floor((positions[v3z] - options.bInfo.minimum.z * ratio) * zSubRatio);
        block_idx_v1 = b1x + options.subDiv.max * b1y + subSq * b1z;
        block_idx_v2 = b2x + options.subDiv.max * b2y + subSq * b2z;
        block_idx_v3 = b3x + options.subDiv.max * b3y + subSq * b3z;
        block_idx_o = ox + options.subDiv.max * oy + subSq * oz;
        options.facetPartitioning[block_idx_o] = options.facetPartitioning[block_idx_o] ? options.facetPartitioning[block_idx_o] : new Array();
        options.facetPartitioning[block_idx_v1] = options.facetPartitioning[block_idx_v1] ? options.facetPartitioning[block_idx_v1] : new Array();
        options.facetPartitioning[block_idx_v2] = options.facetPartitioning[block_idx_v2] ? options.facetPartitioning[block_idx_v2] : new Array();
        options.facetPartitioning[block_idx_v3] = options.facetPartitioning[block_idx_v3] ? options.facetPartitioning[block_idx_v3] : new Array();
        options.facetPartitioning[block_idx_v1].push(index);
        if (block_idx_v2 != block_idx_v1) {
          options.facetPartitioning[block_idx_v2].push(index);
        }
        if (!(block_idx_v3 == block_idx_v2 || block_idx_v3 == block_idx_v1)) {
          options.facetPartitioning[block_idx_v3].push(index);
        }
        if (!(block_idx_o == block_idx_v1 || block_idx_o == block_idx_v2 || block_idx_o == block_idx_v3)) {
          options.facetPartitioning[block_idx_o].push(index);
        }
      }
      if (computeDepthSort && options && options.facetPositions) {
        var dsf = depthSortedFacets[index];
        dsf.ind = index * 3;
        dsf.sqDistance = Vector3.DistanceSquared(options.facetPositions[index], distanceTo);
      }
      normals[v1x] += faceNormalx;
      normals[v1y] += faceNormaly;
      normals[v1z] += faceNormalz;
      normals[v2x] += faceNormalx;
      normals[v2y] += faceNormaly;
      normals[v2z] += faceNormalz;
      normals[v3x] += faceNormalx;
      normals[v3y] += faceNormaly;
      normals[v3z] += faceNormalz;
    }
    for (index = 0; index < normals.length / 3; index++) {
      faceNormalx = normals[index * 3];
      faceNormaly = normals[index * 3 + 1];
      faceNormalz = normals[index * 3 + 2];
      length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);
      length = length === 0 ? 1 : length;
      faceNormalx /= length;
      faceNormaly /= length;
      faceNormalz /= length;
      normals[index * 3] = faceNormalx;
      normals[index * 3 + 1] = faceNormaly;
      normals[index * 3 + 2] = faceNormalz;
    }
  };
  VertexData2._ComputeSides = function(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs) {
    var li = indices.length;
    var ln = normals.length;
    var i;
    var n;
    sideOrientation = sideOrientation || VertexData2.DEFAULTSIDE;
    switch (sideOrientation) {
      case VertexData2.FRONTSIDE:
        break;
      case VertexData2.BACKSIDE:
        var tmp;
        for (i = 0; i < li; i += 3) {
          tmp = indices[i];
          indices[i] = indices[i + 2];
          indices[i + 2] = tmp;
        }
        for (n = 0; n < ln; n++) {
          normals[n] = -normals[n];
        }
        break;
      case VertexData2.DOUBLESIDE:
        var lp = positions.length;
        var l = lp / 3;
        for (var p = 0; p < lp; p++) {
          positions[lp + p] = positions[p];
        }
        for (i = 0; i < li; i += 3) {
          indices[i + li] = indices[i + 2] + l;
          indices[i + 1 + li] = indices[i + 1] + l;
          indices[i + 2 + li] = indices[i] + l;
        }
        for (n = 0; n < ln; n++) {
          normals[ln + n] = -normals[n];
        }
        var lu = uvs.length;
        var u = 0;
        for (u = 0; u < lu; u++) {
          uvs[u + lu] = uvs[u];
        }
        frontUVs = frontUVs ? frontUVs : new Vector4(0, 0, 1, 1);
        backUVs = backUVs ? backUVs : new Vector4(0, 0, 1, 1);
        u = 0;
        for (i = 0; i < lu / 2; i++) {
          uvs[u] = frontUVs.x + (frontUVs.z - frontUVs.x) * uvs[u];
          uvs[u + 1] = frontUVs.y + (frontUVs.w - frontUVs.y) * uvs[u + 1];
          uvs[u + lu] = backUVs.x + (backUVs.z - backUVs.x) * uvs[u + lu];
          uvs[u + lu + 1] = backUVs.y + (backUVs.w - backUVs.y) * uvs[u + lu + 1];
          u += 2;
        }
        break;
    }
  };
  VertexData2.ImportVertexData = function(parsedVertexData, geometry) {
    var vertexData = new VertexData2();
    var positions = parsedVertexData.positions;
    if (positions) {
      vertexData.set(positions, VertexBuffer.PositionKind);
    }
    var normals = parsedVertexData.normals;
    if (normals) {
      vertexData.set(normals, VertexBuffer.NormalKind);
    }
    var tangents = parsedVertexData.tangents;
    if (tangents) {
      vertexData.set(tangents, VertexBuffer.TangentKind);
    }
    var uvs = parsedVertexData.uvs;
    if (uvs) {
      vertexData.set(uvs, VertexBuffer.UVKind);
    }
    var uv2s = parsedVertexData.uv2s;
    if (uv2s) {
      vertexData.set(uv2s, VertexBuffer.UV2Kind);
    }
    var uv3s = parsedVertexData.uv3s;
    if (uv3s) {
      vertexData.set(uv3s, VertexBuffer.UV3Kind);
    }
    var uv4s = parsedVertexData.uv4s;
    if (uv4s) {
      vertexData.set(uv4s, VertexBuffer.UV4Kind);
    }
    var uv5s = parsedVertexData.uv5s;
    if (uv5s) {
      vertexData.set(uv5s, VertexBuffer.UV5Kind);
    }
    var uv6s = parsedVertexData.uv6s;
    if (uv6s) {
      vertexData.set(uv6s, VertexBuffer.UV6Kind);
    }
    var colors = parsedVertexData.colors;
    if (colors) {
      vertexData.set(Color4.CheckColors4(colors, positions.length / 3), VertexBuffer.ColorKind);
    }
    var matricesIndices = parsedVertexData.matricesIndices;
    if (matricesIndices) {
      vertexData.set(matricesIndices, VertexBuffer.MatricesIndicesKind);
    }
    var matricesWeights = parsedVertexData.matricesWeights;
    if (matricesWeights) {
      vertexData.set(matricesWeights, VertexBuffer.MatricesWeightsKind);
    }
    var indices = parsedVertexData.indices;
    if (indices) {
      vertexData.indices = indices;
    }
    geometry.setAllVerticesData(vertexData, parsedVertexData.updatable);
  };
  VertexData2.FRONTSIDE = 0;
  VertexData2.BACKSIDE = 1;
  VertexData2.DOUBLESIDE = 2;
  VertexData2.DEFAULTSIDE = 0;
  return VertexData2;
}();

// node_modules/@babylonjs/core/Collisions/pickingInfo.js
var PickingInfo = function() {
  function PickingInfo2() {
    this._pickingUnavailable = false;
    this.hit = false;
    this.distance = 0;
    this.pickedPoint = null;
    this.pickedMesh = null;
    this.bu = 0;
    this.bv = 0;
    this.faceId = -1;
    this.subMeshFaceId = -1;
    this.subMeshId = 0;
    this.pickedSprite = null;
    this.thinInstanceIndex = -1;
    this.originMesh = null;
    this.ray = null;
  }
  PickingInfo2.prototype.getNormal = function(useWorldCoordinates, useVerticesNormals) {
    if (useWorldCoordinates === void 0) {
      useWorldCoordinates = false;
    }
    if (useVerticesNormals === void 0) {
      useVerticesNormals = true;
    }
    if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      return null;
    }
    var indices = this.pickedMesh.getIndices();
    if (!indices) {
      return null;
    }
    var result;
    if (useVerticesNormals) {
      var normals = this.pickedMesh.getVerticesData(VertexBuffer.NormalKind);
      var normal0 = Vector3.FromArray(normals, indices[this.faceId * 3] * 3);
      var normal1 = Vector3.FromArray(normals, indices[this.faceId * 3 + 1] * 3);
      var normal2 = Vector3.FromArray(normals, indices[this.faceId * 3 + 2] * 3);
      normal0 = normal0.scale(this.bu);
      normal1 = normal1.scale(this.bv);
      normal2 = normal2.scale(1 - this.bu - this.bv);
      result = new Vector3(normal0.x + normal1.x + normal2.x, normal0.y + normal1.y + normal2.y, normal0.z + normal1.z + normal2.z);
    } else {
      var positions = this.pickedMesh.getVerticesData(VertexBuffer.PositionKind);
      var vertex1 = Vector3.FromArray(positions, indices[this.faceId * 3] * 3);
      var vertex2 = Vector3.FromArray(positions, indices[this.faceId * 3 + 1] * 3);
      var vertex3 = Vector3.FromArray(positions, indices[this.faceId * 3 + 2] * 3);
      var p1p2 = vertex1.subtract(vertex2);
      var p3p2 = vertex3.subtract(vertex2);
      result = Vector3.Cross(p1p2, p3p2);
    }
    if (useWorldCoordinates) {
      var wm = this.pickedMesh.getWorldMatrix();
      if (this.pickedMesh.nonUniformScaling) {
        TmpVectors.Matrix[0].copyFrom(wm);
        wm = TmpVectors.Matrix[0];
        wm.setTranslationFromFloats(0, 0, 0);
        wm.invert();
        wm.transposeToRef(TmpVectors.Matrix[1]);
        wm = TmpVectors.Matrix[1];
      }
      result = Vector3.TransformNormal(result, wm);
    }
    result.normalize();
    return result;
  };
  PickingInfo2.prototype.getTextureCoordinates = function() {
    if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
      return null;
    }
    var indices = this.pickedMesh.getIndices();
    if (!indices) {
      return null;
    }
    var uvs = this.pickedMesh.getVerticesData(VertexBuffer.UVKind);
    if (!uvs) {
      return null;
    }
    var uv0 = Vector2.FromArray(uvs, indices[this.faceId * 3] * 2);
    var uv1 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 1] * 2);
    var uv2 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 2] * 2);
    uv0 = uv0.scale(this.bu);
    uv1 = uv1.scale(this.bv);
    uv2 = uv2.scale(1 - this.bu - this.bv);
    return new Vector2(uv0.x + uv1.x + uv2.x, uv0.y + uv1.y + uv2.y);
  };
  return PickingInfo2;
}();

// node_modules/@babylonjs/core/Culling/boundingBox.js
var BoundingBox = function() {
  function BoundingBox2(min, max, worldMatrix) {
    this.vectors = ArrayTools.BuildArray(8, Vector3.Zero);
    this.center = Vector3.Zero();
    this.centerWorld = Vector3.Zero();
    this.extendSize = Vector3.Zero();
    this.extendSizeWorld = Vector3.Zero();
    this.directions = ArrayTools.BuildArray(3, Vector3.Zero);
    this.vectorsWorld = ArrayTools.BuildArray(8, Vector3.Zero);
    this.minimumWorld = Vector3.Zero();
    this.maximumWorld = Vector3.Zero();
    this.minimum = Vector3.Zero();
    this.maximum = Vector3.Zero();
    this.reConstruct(min, max, worldMatrix);
  }
  BoundingBox2.prototype.reConstruct = function(min, max, worldMatrix) {
    var minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;
    var vectors = this.vectors;
    this.minimum.copyFromFloats(minX, minY, minZ);
    this.maximum.copyFromFloats(maxX, maxY, maxZ);
    vectors[0].copyFromFloats(minX, minY, minZ);
    vectors[1].copyFromFloats(maxX, maxY, maxZ);
    vectors[2].copyFromFloats(maxX, minY, minZ);
    vectors[3].copyFromFloats(minX, maxY, minZ);
    vectors[4].copyFromFloats(minX, minY, maxZ);
    vectors[5].copyFromFloats(maxX, maxY, minZ);
    vectors[6].copyFromFloats(minX, maxY, maxZ);
    vectors[7].copyFromFloats(maxX, minY, maxZ);
    max.addToRef(min, this.center).scaleInPlace(0.5);
    max.subtractToRef(min, this.extendSize).scaleInPlace(0.5);
    this._worldMatrix = worldMatrix || Matrix.IdentityReadOnly;
    this._update(this._worldMatrix);
  };
  BoundingBox2.prototype.scale = function(factor) {
    var tmpVectors = BoundingBox2.TmpVector3;
    var diff = this.maximum.subtractToRef(this.minimum, tmpVectors[0]);
    var len = diff.length();
    diff.normalizeFromLength(len);
    var distance = len * factor;
    var newRadius = diff.scaleInPlace(distance * 0.5);
    var min = this.center.subtractToRef(newRadius, tmpVectors[1]);
    var max = this.center.addToRef(newRadius, tmpVectors[2]);
    this.reConstruct(min, max, this._worldMatrix);
    return this;
  };
  BoundingBox2.prototype.getWorldMatrix = function() {
    return this._worldMatrix;
  };
  BoundingBox2.prototype._update = function(world) {
    var minWorld = this.minimumWorld;
    var maxWorld = this.maximumWorld;
    var directions = this.directions;
    var vectorsWorld = this.vectorsWorld;
    var vectors = this.vectors;
    if (!world.isIdentity()) {
      minWorld.setAll(Number.MAX_VALUE);
      maxWorld.setAll(-Number.MAX_VALUE);
      for (var index = 0; index < 8; ++index) {
        var v = vectorsWorld[index];
        Vector3.TransformCoordinatesToRef(vectors[index], world, v);
        minWorld.minimizeInPlace(v);
        maxWorld.maximizeInPlace(v);
      }
      maxWorld.subtractToRef(minWorld, this.extendSizeWorld).scaleInPlace(0.5);
      maxWorld.addToRef(minWorld, this.centerWorld).scaleInPlace(0.5);
    } else {
      minWorld.copyFrom(this.minimum);
      maxWorld.copyFrom(this.maximum);
      for (var index = 0; index < 8; ++index) {
        vectorsWorld[index].copyFrom(vectors[index]);
      }
      this.extendSizeWorld.copyFrom(this.extendSize);
      this.centerWorld.copyFrom(this.center);
    }
    Vector3.FromArrayToRef(world.m, 0, directions[0]);
    Vector3.FromArrayToRef(world.m, 4, directions[1]);
    Vector3.FromArrayToRef(world.m, 8, directions[2]);
    this._worldMatrix = world;
  };
  BoundingBox2.prototype.isInFrustum = function(frustumPlanes) {
    return BoundingBox2.IsInFrustum(this.vectorsWorld, frustumPlanes);
  };
  BoundingBox2.prototype.isCompletelyInFrustum = function(frustumPlanes) {
    return BoundingBox2.IsCompletelyInFrustum(this.vectorsWorld, frustumPlanes);
  };
  BoundingBox2.prototype.intersectsPoint = function(point) {
    var min = this.minimumWorld;
    var max = this.maximumWorld;
    var minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;
    var pointX = point.x, pointY = point.y, pointZ = point.z;
    var delta = -Epsilon;
    if (maxX - pointX < delta || delta > pointX - minX) {
      return false;
    }
    if (maxY - pointY < delta || delta > pointY - minY) {
      return false;
    }
    if (maxZ - pointZ < delta || delta > pointZ - minZ) {
      return false;
    }
    return true;
  };
  BoundingBox2.prototype.intersectsSphere = function(sphere) {
    return BoundingBox2.IntersectsSphere(this.minimumWorld, this.maximumWorld, sphere.centerWorld, sphere.radiusWorld);
  };
  BoundingBox2.prototype.intersectsMinMax = function(min, max) {
    var myMin = this.minimumWorld;
    var myMax = this.maximumWorld;
    var myMinX = myMin.x, myMinY = myMin.y, myMinZ = myMin.z, myMaxX = myMax.x, myMaxY = myMax.y, myMaxZ = myMax.z;
    var minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;
    if (myMaxX < minX || myMinX > maxX) {
      return false;
    }
    if (myMaxY < minY || myMinY > maxY) {
      return false;
    }
    if (myMaxZ < minZ || myMinZ > maxZ) {
      return false;
    }
    return true;
  };
  BoundingBox2.Intersects = function(box0, box1) {
    return box0.intersectsMinMax(box1.minimumWorld, box1.maximumWorld);
  };
  BoundingBox2.IntersectsSphere = function(minPoint, maxPoint, sphereCenter, sphereRadius) {
    var vector = BoundingBox2.TmpVector3[0];
    Vector3.ClampToRef(sphereCenter, minPoint, maxPoint, vector);
    var num = Vector3.DistanceSquared(sphereCenter, vector);
    return num <= sphereRadius * sphereRadius;
  };
  BoundingBox2.IsCompletelyInFrustum = function(boundingVectors, frustumPlanes) {
    for (var p = 0; p < 6; ++p) {
      var frustumPlane = frustumPlanes[p];
      for (var i = 0; i < 8; ++i) {
        if (frustumPlane.dotCoordinate(boundingVectors[i]) < 0) {
          return false;
        }
      }
    }
    return true;
  };
  BoundingBox2.IsInFrustum = function(boundingVectors, frustumPlanes) {
    for (var p = 0; p < 6; ++p) {
      var canReturnFalse = true;
      var frustumPlane = frustumPlanes[p];
      for (var i = 0; i < 8; ++i) {
        if (frustumPlane.dotCoordinate(boundingVectors[i]) >= 0) {
          canReturnFalse = false;
          break;
        }
      }
      if (canReturnFalse) {
        return false;
      }
    }
    return true;
  };
  BoundingBox2.TmpVector3 = ArrayTools.BuildArray(3, Vector3.Zero);
  return BoundingBox2;
}();

// node_modules/@babylonjs/core/Culling/boundingSphere.js
var BoundingSphere = function() {
  function BoundingSphere2(min, max, worldMatrix) {
    this.center = Vector3.Zero();
    this.centerWorld = Vector3.Zero();
    this.minimum = Vector3.Zero();
    this.maximum = Vector3.Zero();
    this.reConstruct(min, max, worldMatrix);
  }
  BoundingSphere2.prototype.reConstruct = function(min, max, worldMatrix) {
    this.minimum.copyFrom(min);
    this.maximum.copyFrom(max);
    var distance = Vector3.Distance(min, max);
    max.addToRef(min, this.center).scaleInPlace(0.5);
    this.radius = distance * 0.5;
    this._update(worldMatrix || Matrix.IdentityReadOnly);
  };
  BoundingSphere2.prototype.scale = function(factor) {
    var newRadius = this.radius * factor;
    var tmpVectors = BoundingSphere2.TmpVector3;
    var tempRadiusVector = tmpVectors[0].setAll(newRadius);
    var min = this.center.subtractToRef(tempRadiusVector, tmpVectors[1]);
    var max = this.center.addToRef(tempRadiusVector, tmpVectors[2]);
    this.reConstruct(min, max, this._worldMatrix);
    return this;
  };
  BoundingSphere2.prototype.getWorldMatrix = function() {
    return this._worldMatrix;
  };
  BoundingSphere2.prototype._update = function(worldMatrix) {
    if (!worldMatrix.isIdentity()) {
      Vector3.TransformCoordinatesToRef(this.center, worldMatrix, this.centerWorld);
      var tempVector = BoundingSphere2.TmpVector3[0];
      Vector3.TransformNormalFromFloatsToRef(1, 1, 1, worldMatrix, tempVector);
      this.radiusWorld = Math.max(Math.abs(tempVector.x), Math.abs(tempVector.y), Math.abs(tempVector.z)) * this.radius;
    } else {
      this.centerWorld.copyFrom(this.center);
      this.radiusWorld = this.radius;
    }
  };
  BoundingSphere2.prototype.isInFrustum = function(frustumPlanes) {
    var center = this.centerWorld;
    var radius = this.radiusWorld;
    for (var i = 0; i < 6; i++) {
      if (frustumPlanes[i].dotCoordinate(center) <= -radius) {
        return false;
      }
    }
    return true;
  };
  BoundingSphere2.prototype.isCenterInFrustum = function(frustumPlanes) {
    var center = this.centerWorld;
    for (var i = 0; i < 6; i++) {
      if (frustumPlanes[i].dotCoordinate(center) < 0) {
        return false;
      }
    }
    return true;
  };
  BoundingSphere2.prototype.intersectsPoint = function(point) {
    var squareDistance = Vector3.DistanceSquared(this.centerWorld, point);
    if (this.radiusWorld * this.radiusWorld < squareDistance) {
      return false;
    }
    return true;
  };
  BoundingSphere2.Intersects = function(sphere0, sphere1) {
    var squareDistance = Vector3.DistanceSquared(sphere0.centerWorld, sphere1.centerWorld);
    var radiusSum = sphere0.radiusWorld + sphere1.radiusWorld;
    if (radiusSum * radiusSum < squareDistance) {
      return false;
    }
    return true;
  };
  BoundingSphere2.TmpVector3 = ArrayTools.BuildArray(3, Vector3.Zero);
  return BoundingSphere2;
}();

// node_modules/@babylonjs/core/Culling/boundingInfo.js
var _result0 = { min: 0, max: 0 };
var _result1 = { min: 0, max: 0 };
var computeBoxExtents = function(axis, box, result) {
  var p = Vector3.Dot(box.centerWorld, axis);
  var r0 = Math.abs(Vector3.Dot(box.directions[0], axis)) * box.extendSize.x;
  var r1 = Math.abs(Vector3.Dot(box.directions[1], axis)) * box.extendSize.y;
  var r2 = Math.abs(Vector3.Dot(box.directions[2], axis)) * box.extendSize.z;
  var r = r0 + r1 + r2;
  result.min = p - r;
  result.max = p + r;
};
var axisOverlap = function(axis, box0, box1) {
  computeBoxExtents(axis, box0, _result0);
  computeBoxExtents(axis, box1, _result1);
  return !(_result0.min > _result1.max || _result1.min > _result0.max);
};
var BoundingInfo = function() {
  function BoundingInfo2(minimum, maximum, worldMatrix) {
    this._isLocked = false;
    this.boundingBox = new BoundingBox(minimum, maximum, worldMatrix);
    this.boundingSphere = new BoundingSphere(minimum, maximum, worldMatrix);
  }
  BoundingInfo2.prototype.reConstruct = function(min, max, worldMatrix) {
    this.boundingBox.reConstruct(min, max, worldMatrix);
    this.boundingSphere.reConstruct(min, max, worldMatrix);
  };
  Object.defineProperty(BoundingInfo2.prototype, "minimum", {
    get: function() {
      return this.boundingBox.minimum;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BoundingInfo2.prototype, "maximum", {
    get: function() {
      return this.boundingBox.maximum;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BoundingInfo2.prototype, "isLocked", {
    get: function() {
      return this._isLocked;
    },
    set: function(value) {
      this._isLocked = value;
    },
    enumerable: false,
    configurable: true
  });
  BoundingInfo2.prototype.update = function(world) {
    if (this._isLocked) {
      return;
    }
    this.boundingBox._update(world);
    this.boundingSphere._update(world);
  };
  BoundingInfo2.prototype.centerOn = function(center, extend) {
    var minimum = BoundingInfo2.TmpVector3[0].copyFrom(center).subtractInPlace(extend);
    var maximum = BoundingInfo2.TmpVector3[1].copyFrom(center).addInPlace(extend);
    this.boundingBox.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());
    this.boundingSphere.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());
    return this;
  };
  BoundingInfo2.prototype.scale = function(factor) {
    this.boundingBox.scale(factor);
    this.boundingSphere.scale(factor);
    return this;
  };
  BoundingInfo2.prototype.isInFrustum = function(frustumPlanes, strategy) {
    if (strategy === void 0) {
      strategy = 0;
    }
    var inclusionTest = strategy === 2 || strategy === 3;
    if (inclusionTest) {
      if (this.boundingSphere.isCenterInFrustum(frustumPlanes)) {
        return true;
      }
    }
    if (!this.boundingSphere.isInFrustum(frustumPlanes)) {
      return false;
    }
    var bSphereOnlyTest = strategy === 1 || strategy === 3;
    if (bSphereOnlyTest) {
      return true;
    }
    return this.boundingBox.isInFrustum(frustumPlanes);
  };
  Object.defineProperty(BoundingInfo2.prototype, "diagonalLength", {
    get: function() {
      var boundingBox = this.boundingBox;
      var diag = boundingBox.maximumWorld.subtractToRef(boundingBox.minimumWorld, BoundingInfo2.TmpVector3[0]);
      return diag.length();
    },
    enumerable: false,
    configurable: true
  });
  BoundingInfo2.prototype.isCompletelyInFrustum = function(frustumPlanes) {
    return this.boundingBox.isCompletelyInFrustum(frustumPlanes);
  };
  BoundingInfo2.prototype._checkCollision = function(collider) {
    return collider._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);
  };
  BoundingInfo2.prototype.intersectsPoint = function(point) {
    if (!this.boundingSphere.centerWorld) {
      return false;
    }
    if (!this.boundingSphere.intersectsPoint(point)) {
      return false;
    }
    if (!this.boundingBox.intersectsPoint(point)) {
      return false;
    }
    return true;
  };
  BoundingInfo2.prototype.intersects = function(boundingInfo, precise) {
    if (!BoundingSphere.Intersects(this.boundingSphere, boundingInfo.boundingSphere)) {
      return false;
    }
    if (!BoundingBox.Intersects(this.boundingBox, boundingInfo.boundingBox)) {
      return false;
    }
    if (!precise) {
      return true;
    }
    var box0 = this.boundingBox;
    var box1 = boundingInfo.boundingBox;
    if (!axisOverlap(box0.directions[0], box0, box1)) {
      return false;
    }
    if (!axisOverlap(box0.directions[1], box0, box1)) {
      return false;
    }
    if (!axisOverlap(box0.directions[2], box0, box1)) {
      return false;
    }
    if (!axisOverlap(box1.directions[0], box0, box1)) {
      return false;
    }
    if (!axisOverlap(box1.directions[1], box0, box1)) {
      return false;
    }
    if (!axisOverlap(box1.directions[2], box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[0]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[1]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[2]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[0]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[1]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[2]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[0]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[1]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[2]), box0, box1)) {
      return false;
    }
    return true;
  };
  BoundingInfo2.TmpVector3 = ArrayTools.BuildArray(2, Vector3.Zero);
  return BoundingInfo2;
}();

// node_modules/@babylonjs/core/Collisions/meshCollisionData.js
var _MeshCollisionData = function() {
  function _MeshCollisionData2() {
    this._checkCollisions = false;
    this._collisionMask = -1;
    this._collisionGroup = -1;
    this._surroundingMeshes = null;
    this._collider = null;
    this._oldPositionForCollisions = new Vector3(0, 0, 0);
    this._diffPositionForCollisions = new Vector3(0, 0, 0);
    this._collisionResponse = true;
  }
  return _MeshCollisionData2;
}();

// node_modules/@babylonjs/core/Maths/math.functions.js
function extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, bias) {
  if (bias === void 0) {
    bias = null;
  }
  var minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
  var maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
  for (var index = indexStart; index < indexStart + indexCount; index++) {
    var offset = indices[index] * 3;
    var x = positions[offset];
    var y = positions[offset + 1];
    var z = positions[offset + 2];
    minimum.minimizeInPlaceFromFloats(x, y, z);
    maximum.maximizeInPlaceFromFloats(x, y, z);
  }
  if (bias) {
    minimum.x -= minimum.x * bias.x + bias.y;
    minimum.y -= minimum.y * bias.x + bias.y;
    minimum.z -= minimum.z * bias.x + bias.y;
    maximum.x += maximum.x * bias.x + bias.y;
    maximum.y += maximum.y * bias.x + bias.y;
    maximum.z += maximum.z * bias.x + bias.y;
  }
  return {
    minimum,
    maximum
  };
}
function extractMinAndMax(positions, start, count, bias, stride) {
  if (bias === void 0) {
    bias = null;
  }
  var minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
  var maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
  if (!stride) {
    stride = 3;
  }
  for (var index = start, offset = start * stride; index < start + count; index++, offset += stride) {
    var x = positions[offset];
    var y = positions[offset + 1];
    var z = positions[offset + 2];
    minimum.minimizeInPlaceFromFloats(x, y, z);
    maximum.maximizeInPlaceFromFloats(x, y, z);
  }
  if (bias) {
    minimum.x -= minimum.x * bias.x + bias.y;
    minimum.y -= minimum.y * bias.x + bias.y;
    minimum.z -= minimum.z * bias.x + bias.y;
    maximum.x += maximum.x * bias.x + bias.y;
    maximum.y += maximum.y * bias.x + bias.y;
    maximum.z += maximum.z * bias.x + bias.y;
  }
  return {
    minimum,
    maximum
  };
}

// node_modules/@babylonjs/core/Meshes/abstractMesh.js
var _FacetDataStorage = function() {
  function _FacetDataStorage2() {
    this.facetNb = 0;
    this.partitioningSubdivisions = 10;
    this.partitioningBBoxRatio = 1.01;
    this.facetDataEnabled = false;
    this.facetParameters = {};
    this.bbSize = Vector3.Zero();
    this.subDiv = {
      max: 1,
      X: 1,
      Y: 1,
      Z: 1
    };
    this.facetDepthSort = false;
    this.facetDepthSortEnabled = false;
  }
  return _FacetDataStorage2;
}();
var _InternalAbstractMeshDataInfo = function() {
  function _InternalAbstractMeshDataInfo2() {
    this._hasVertexAlpha = false;
    this._useVertexColors = true;
    this._numBoneInfluencers = 4;
    this._applyFog = true;
    this._receiveShadows = false;
    this._facetData = new _FacetDataStorage();
    this._visibility = 1;
    this._skeleton = null;
    this._layerMask = 268435455;
    this._computeBonesUsingShaders = true;
    this._isActive = false;
    this._onlyForInstances = false;
    this._isActiveIntermediate = false;
    this._onlyForInstancesIntermediate = false;
    this._actAsRegularMesh = false;
    this._currentLOD = null;
    this._currentLODIsUpToDate = false;
  }
  return _InternalAbstractMeshDataInfo2;
}();
var AbstractMesh = function(_super) {
  __extends(AbstractMesh2, _super);
  function AbstractMesh2(name45, scene) {
    if (scene === void 0) {
      scene = null;
    }
    var _this = _super.call(this, name45, scene, false) || this;
    _this._internalAbstractMeshDataInfo = new _InternalAbstractMeshDataInfo();
    _this.cullingStrategy = AbstractMesh2.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;
    _this.onCollideObservable = new Observable();
    _this.onCollisionPositionChangeObservable = new Observable();
    _this.onMaterialChangedObservable = new Observable();
    _this.definedFacingForward = true;
    _this._occlusionQuery = null;
    _this._renderingGroup = null;
    _this.alphaIndex = Number.MAX_VALUE;
    _this.isVisible = true;
    _this.isPickable = true;
    _this.showSubMeshesBoundingBox = false;
    _this.isBlocker = false;
    _this.enablePointerMoveEvents = false;
    _this._renderingGroupId = 0;
    _this._material = null;
    _this.outlineColor = Color3.Red();
    _this.outlineWidth = 0.02;
    _this.overlayColor = Color3.Red();
    _this.overlayAlpha = 0.5;
    _this.useOctreeForRenderingSelection = true;
    _this.useOctreeForPicking = true;
    _this.useOctreeForCollisions = true;
    _this.alwaysSelectAsActiveMesh = false;
    _this.doNotSyncBoundingInfo = false;
    _this.actionManager = null;
    _this._meshCollisionData = new _MeshCollisionData();
    _this.ellipsoid = new Vector3(0.5, 1, 0.5);
    _this.ellipsoidOffset = new Vector3(0, 0, 0);
    _this.edgesWidth = 1;
    _this.edgesColor = new Color4(1, 0, 0, 1);
    _this._edgesRenderer = null;
    _this._masterMesh = null;
    _this._boundingInfo = null;
    _this._renderId = 0;
    _this._intersectionsInProgress = new Array();
    _this._unIndexed = false;
    _this._lightSources = new Array();
    _this._waitingData = {
      lods: null,
      actions: null,
      freezeWorldMatrix: null
    };
    _this._bonesTransformMatrices = null;
    _this._transformMatrixTexture = null;
    _this.onRebuildObservable = new Observable();
    _this._onCollisionPositionChange = function(collisionId, newPosition, collidedMesh) {
      if (collidedMesh === void 0) {
        collidedMesh = null;
      }
      newPosition.subtractToRef(_this._meshCollisionData._oldPositionForCollisions, _this._meshCollisionData._diffPositionForCollisions);
      if (_this._meshCollisionData._diffPositionForCollisions.length() > Engine.CollisionsEpsilon) {
        _this.position.addInPlace(_this._meshCollisionData._diffPositionForCollisions);
      }
      if (collidedMesh) {
        _this.onCollideObservable.notifyObservers(collidedMesh);
      }
      _this.onCollisionPositionChangeObservable.notifyObservers(_this.position);
    };
    _this.getScene().addMesh(_this);
    _this._resyncLightSources();
    return _this;
  }
  Object.defineProperty(AbstractMesh2, "BILLBOARDMODE_NONE", {
    get: function() {
      return TransformNode.BILLBOARDMODE_NONE;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2, "BILLBOARDMODE_X", {
    get: function() {
      return TransformNode.BILLBOARDMODE_X;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2, "BILLBOARDMODE_Y", {
    get: function() {
      return TransformNode.BILLBOARDMODE_Y;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2, "BILLBOARDMODE_Z", {
    get: function() {
      return TransformNode.BILLBOARDMODE_Z;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2, "BILLBOARDMODE_ALL", {
    get: function() {
      return TransformNode.BILLBOARDMODE_ALL;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2, "BILLBOARDMODE_USE_POSITION", {
    get: function() {
      return TransformNode.BILLBOARDMODE_USE_POSITION;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "facetNb", {
    get: function() {
      return this._internalAbstractMeshDataInfo._facetData.facetNb;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "partitioningSubdivisions", {
    get: function() {
      return this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions;
    },
    set: function(nb) {
      this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions = nb;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "partitioningBBoxRatio", {
    get: function() {
      return this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio;
    },
    set: function(ratio) {
      this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio = ratio;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "mustDepthSortFacets", {
    get: function() {
      return this._internalAbstractMeshDataInfo._facetData.facetDepthSort;
    },
    set: function(sort) {
      this._internalAbstractMeshDataInfo._facetData.facetDepthSort = sort;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "facetDepthSortFrom", {
    get: function() {
      return this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom;
    },
    set: function(location2) {
      this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom = location2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "isFacetDataEnabled", {
    get: function() {
      return this._internalAbstractMeshDataInfo._facetData.facetDataEnabled;
    },
    enumerable: false,
    configurable: true
  });
  AbstractMesh2.prototype._updateNonUniformScalingState = function(value) {
    if (!_super.prototype._updateNonUniformScalingState.call(this, value)) {
      return false;
    }
    this._markSubMeshesAsMiscDirty();
    return true;
  };
  Object.defineProperty(AbstractMesh2.prototype, "onCollide", {
    set: function(callback) {
      if (this._meshCollisionData._onCollideObserver) {
        this.onCollideObservable.remove(this._meshCollisionData._onCollideObserver);
      }
      this._meshCollisionData._onCollideObserver = this.onCollideObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "onCollisionPositionChange", {
    set: function(callback) {
      if (this._meshCollisionData._onCollisionPositionChangeObserver) {
        this.onCollisionPositionChangeObservable.remove(this._meshCollisionData._onCollisionPositionChangeObserver);
      }
      this._meshCollisionData._onCollisionPositionChangeObserver = this.onCollisionPositionChangeObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "visibility", {
    get: function() {
      return this._internalAbstractMeshDataInfo._visibility;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._visibility === value) {
        return;
      }
      this._internalAbstractMeshDataInfo._visibility = value;
      this._markSubMeshesAsMiscDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "renderingGroupId", {
    get: function() {
      return this._renderingGroupId;
    },
    set: function(value) {
      this._renderingGroupId = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "material", {
    get: function() {
      return this._material;
    },
    set: function(value) {
      if (this._material === value) {
        return;
      }
      if (this._material && this._material.meshMap) {
        this._material.meshMap[this.uniqueId] = void 0;
      }
      this._material = value;
      if (value && value.meshMap) {
        value.meshMap[this.uniqueId] = this;
      }
      if (this.onMaterialChangedObservable.hasObservers()) {
        this.onMaterialChangedObservable.notifyObservers(this);
      }
      if (!this.subMeshes) {
        return;
      }
      this._unBindEffect();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "receiveShadows", {
    get: function() {
      return this._internalAbstractMeshDataInfo._receiveShadows;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._receiveShadows === value) {
        return;
      }
      this._internalAbstractMeshDataInfo._receiveShadows = value;
      this._markSubMeshesAsLightDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "hasVertexAlpha", {
    get: function() {
      return this._internalAbstractMeshDataInfo._hasVertexAlpha;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._hasVertexAlpha === value) {
        return;
      }
      this._internalAbstractMeshDataInfo._hasVertexAlpha = value;
      this._markSubMeshesAsAttributesDirty();
      this._markSubMeshesAsMiscDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "useVertexColors", {
    get: function() {
      return this._internalAbstractMeshDataInfo._useVertexColors;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._useVertexColors === value) {
        return;
      }
      this._internalAbstractMeshDataInfo._useVertexColors = value;
      this._markSubMeshesAsAttributesDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "computeBonesUsingShaders", {
    get: function() {
      return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {
        return;
      }
      this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;
      this._markSubMeshesAsAttributesDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "numBoneInfluencers", {
    get: function() {
      return this._internalAbstractMeshDataInfo._numBoneInfluencers;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._numBoneInfluencers === value) {
        return;
      }
      this._internalAbstractMeshDataInfo._numBoneInfluencers = value;
      this._markSubMeshesAsAttributesDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "applyFog", {
    get: function() {
      return this._internalAbstractMeshDataInfo._applyFog;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._applyFog === value) {
        return;
      }
      this._internalAbstractMeshDataInfo._applyFog = value;
      this._markSubMeshesAsMiscDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "layerMask", {
    get: function() {
      return this._internalAbstractMeshDataInfo._layerMask;
    },
    set: function(value) {
      if (value === this._internalAbstractMeshDataInfo._layerMask) {
        return;
      }
      this._internalAbstractMeshDataInfo._layerMask = value;
      this._resyncLightSources();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "collisionMask", {
    get: function() {
      return this._meshCollisionData._collisionMask;
    },
    set: function(mask) {
      this._meshCollisionData._collisionMask = !isNaN(mask) ? mask : -1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "collisionResponse", {
    get: function() {
      return this._meshCollisionData._collisionResponse;
    },
    set: function(response) {
      this._meshCollisionData._collisionResponse = response;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "collisionGroup", {
    get: function() {
      return this._meshCollisionData._collisionGroup;
    },
    set: function(mask) {
      this._meshCollisionData._collisionGroup = !isNaN(mask) ? mask : -1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "surroundingMeshes", {
    get: function() {
      return this._meshCollisionData._surroundingMeshes;
    },
    set: function(meshes) {
      this._meshCollisionData._surroundingMeshes = meshes;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "lightSources", {
    get: function() {
      return this._lightSources;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "_positions", {
    get: function() {
      return null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "skeleton", {
    get: function() {
      return this._internalAbstractMeshDataInfo._skeleton;
    },
    set: function(value) {
      var skeleton = this._internalAbstractMeshDataInfo._skeleton;
      if (skeleton && skeleton.needInitialSkinMatrix) {
        skeleton._unregisterMeshWithPoseMatrix(this);
      }
      if (value && value.needInitialSkinMatrix) {
        value._registerMeshWithPoseMatrix(this);
      }
      this._internalAbstractMeshDataInfo._skeleton = value;
      if (!this._internalAbstractMeshDataInfo._skeleton) {
        this._bonesTransformMatrices = null;
      }
      this._markSubMeshesAsAttributesDirty();
    },
    enumerable: false,
    configurable: true
  });
  AbstractMesh2.prototype.getClassName = function() {
    return "AbstractMesh";
  };
  AbstractMesh2.prototype.toString = function(fullDetails) {
    var ret = "Name: " + this.name + ", isInstance: " + (this.getClassName() !== "InstancedMesh" ? "YES" : "NO");
    ret += ", # of submeshes: " + (this.subMeshes ? this.subMeshes.length : 0);
    var skeleton = this._internalAbstractMeshDataInfo._skeleton;
    if (skeleton) {
      ret += ", skeleton: " + skeleton.name;
    }
    if (fullDetails) {
      ret += ", billboard mode: " + ["NONE", "X", "Y", null, "Z", null, null, "ALL"][this.billboardMode];
      ret += ", freeze wrld mat: " + (this._isWorldMatrixFrozen || this._waitingData.freezeWorldMatrix ? "YES" : "NO");
    }
    return ret;
  };
  AbstractMesh2.prototype._getEffectiveParent = function() {
    if (this._masterMesh && this.billboardMode !== TransformNode.BILLBOARDMODE_NONE) {
      return this._masterMesh;
    }
    return _super.prototype._getEffectiveParent.call(this);
  };
  AbstractMesh2.prototype._getActionManagerForTrigger = function(trigger, initialCall) {
    if (initialCall === void 0) {
      initialCall = true;
    }
    if (this.actionManager && (initialCall || this.actionManager.isRecursive)) {
      if (trigger) {
        if (this.actionManager.hasSpecificTrigger(trigger)) {
          return this.actionManager;
        }
      } else {
        return this.actionManager;
      }
    }
    if (!this.parent) {
      return null;
    }
    return this.parent._getActionManagerForTrigger(trigger, false);
  };
  AbstractMesh2.prototype._rebuild = function() {
    this.onRebuildObservable.notifyObservers(this);
    if (this._occlusionQuery) {
      this._occlusionQuery = null;
    }
    if (!this.subMeshes) {
      return;
    }
    for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {
      var subMesh = _a[_i];
      subMesh._rebuild();
    }
  };
  AbstractMesh2.prototype._resyncLightSources = function() {
    this._lightSources.length = 0;
    for (var _i = 0, _a = this.getScene().lights; _i < _a.length; _i++) {
      var light = _a[_i];
      if (!light.isEnabled()) {
        continue;
      }
      if (light.canAffectMesh(this)) {
        this._lightSources.push(light);
      }
    }
    this._markSubMeshesAsLightDirty();
  };
  AbstractMesh2.prototype._resyncLightSource = function(light) {
    var isIn = light.isEnabled() && light.canAffectMesh(this);
    var index = this._lightSources.indexOf(light);
    var removed = false;
    if (index === -1) {
      if (!isIn) {
        return;
      }
      this._lightSources.push(light);
    } else {
      if (isIn) {
        return;
      }
      removed = true;
      this._lightSources.splice(index, 1);
    }
    this._markSubMeshesAsLightDirty(removed);
  };
  AbstractMesh2.prototype._unBindEffect = function() {
    for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {
      var subMesh = _a[_i];
      subMesh.setEffect(null);
    }
  };
  AbstractMesh2.prototype._removeLightSource = function(light, dispose) {
    var index = this._lightSources.indexOf(light);
    if (index === -1) {
      return;
    }
    this._lightSources.splice(index, 1);
    this._markSubMeshesAsLightDirty(dispose);
  };
  AbstractMesh2.prototype._markSubMeshesAsDirty = function(func) {
    if (!this.subMeshes) {
      return;
    }
    for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {
      var subMesh = _a[_i];
      if (subMesh._materialDefines) {
        func(subMesh._materialDefines);
      }
    }
  };
  AbstractMesh2.prototype._markSubMeshesAsLightDirty = function(dispose) {
    if (dispose === void 0) {
      dispose = false;
    }
    this._markSubMeshesAsDirty(function(defines) {
      return defines.markAsLightDirty(dispose);
    });
  };
  AbstractMesh2.prototype._markSubMeshesAsAttributesDirty = function() {
    this._markSubMeshesAsDirty(function(defines) {
      return defines.markAsAttributesDirty();
    });
  };
  AbstractMesh2.prototype._markSubMeshesAsMiscDirty = function() {
    this._markSubMeshesAsDirty(function(defines) {
      return defines.markAsMiscDirty();
    });
  };
  Object.defineProperty(AbstractMesh2.prototype, "scaling", {
    get: function() {
      return this._scaling;
    },
    set: function(newScaling) {
      this._scaling = newScaling;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "isBlocked", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  AbstractMesh2.prototype.getLOD = function(camera) {
    return this;
  };
  AbstractMesh2.prototype.getTotalVertices = function() {
    return 0;
  };
  AbstractMesh2.prototype.getTotalIndices = function() {
    return 0;
  };
  AbstractMesh2.prototype.getIndices = function() {
    return null;
  };
  AbstractMesh2.prototype.getVerticesData = function(kind) {
    return null;
  };
  AbstractMesh2.prototype.setVerticesData = function(kind, data, updatable, stride) {
    return this;
  };
  AbstractMesh2.prototype.updateVerticesData = function(kind, data, updateExtends, makeItUnique) {
    return this;
  };
  AbstractMesh2.prototype.setIndices = function(indices, totalVertices) {
    return this;
  };
  AbstractMesh2.prototype.isVerticesDataPresent = function(kind) {
    return false;
  };
  AbstractMesh2.prototype.getBoundingInfo = function() {
    if (this._masterMesh) {
      return this._masterMesh.getBoundingInfo();
    }
    if (!this._boundingInfo) {
      this._updateBoundingInfo();
    }
    return this._boundingInfo;
  };
  AbstractMesh2.prototype.normalizeToUnitCube = function(includeDescendants, ignoreRotation, predicate) {
    if (includeDescendants === void 0) {
      includeDescendants = true;
    }
    if (ignoreRotation === void 0) {
      ignoreRotation = false;
    }
    return _super.prototype.normalizeToUnitCube.call(this, includeDescendants, ignoreRotation, predicate);
  };
  AbstractMesh2.prototype.setBoundingInfo = function(boundingInfo) {
    this._boundingInfo = boundingInfo;
    return this;
  };
  Object.defineProperty(AbstractMesh2.prototype, "useBones", {
    get: function() {
      return this.skeleton && this.getScene().skeletonsEnabled && this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind) && this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind);
    },
    enumerable: false,
    configurable: true
  });
  AbstractMesh2.prototype._preActivate = function() {
  };
  AbstractMesh2.prototype._preActivateForIntermediateRendering = function(renderId) {
  };
  AbstractMesh2.prototype._activate = function(renderId, intermediateRendering) {
    this._renderId = renderId;
    return true;
  };
  AbstractMesh2.prototype._postActivate = function() {
  };
  AbstractMesh2.prototype._freeze = function() {
  };
  AbstractMesh2.prototype._unFreeze = function() {
  };
  AbstractMesh2.prototype.getWorldMatrix = function() {
    if (this._masterMesh && this.billboardMode === TransformNode.BILLBOARDMODE_NONE) {
      return this._masterMesh.getWorldMatrix();
    }
    return _super.prototype.getWorldMatrix.call(this);
  };
  AbstractMesh2.prototype._getWorldMatrixDeterminant = function() {
    if (this._masterMesh) {
      return this._masterMesh._getWorldMatrixDeterminant();
    }
    return _super.prototype._getWorldMatrixDeterminant.call(this);
  };
  Object.defineProperty(AbstractMesh2.prototype, "isAnInstance", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "hasInstances", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "hasThinInstances", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  AbstractMesh2.prototype.movePOV = function(amountRight, amountUp, amountForward) {
    this.position.addInPlace(this.calcMovePOV(amountRight, amountUp, amountForward));
    return this;
  };
  AbstractMesh2.prototype.calcMovePOV = function(amountRight, amountUp, amountForward) {
    var rotMatrix = new Matrix();
    var rotQuaternion = this.rotationQuaternion ? this.rotationQuaternion : Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);
    rotQuaternion.toRotationMatrix(rotMatrix);
    var translationDelta = Vector3.Zero();
    var defForwardMult = this.definedFacingForward ? -1 : 1;
    Vector3.TransformCoordinatesFromFloatsToRef(amountRight * defForwardMult, amountUp, amountForward * defForwardMult, rotMatrix, translationDelta);
    return translationDelta;
  };
  AbstractMesh2.prototype.rotatePOV = function(flipBack, twirlClockwise, tiltRight) {
    this.rotation.addInPlace(this.calcRotatePOV(flipBack, twirlClockwise, tiltRight));
    return this;
  };
  AbstractMesh2.prototype.calcRotatePOV = function(flipBack, twirlClockwise, tiltRight) {
    var defForwardMult = this.definedFacingForward ? 1 : -1;
    return new Vector3(flipBack * defForwardMult, twirlClockwise, tiltRight * defForwardMult);
  };
  AbstractMesh2.prototype.refreshBoundingInfo = function(applySkeleton) {
    if (applySkeleton === void 0) {
      applySkeleton = false;
    }
    if (this._boundingInfo && this._boundingInfo.isLocked) {
      return this;
    }
    this._refreshBoundingInfo(this._getPositionData(applySkeleton), null);
    return this;
  };
  AbstractMesh2.prototype._refreshBoundingInfo = function(data, bias) {
    if (data) {
      var extend = extractMinAndMax(data, 0, this.getTotalVertices(), bias);
      if (this._boundingInfo) {
        this._boundingInfo.reConstruct(extend.minimum, extend.maximum);
      } else {
        this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);
      }
    }
    if (this.subMeshes) {
      for (var index = 0; index < this.subMeshes.length; index++) {
        this.subMeshes[index].refreshBoundingInfo(data);
      }
    }
    this._updateBoundingInfo();
  };
  AbstractMesh2.prototype._getPositionData = function(applySkeleton) {
    var data = this.getVerticesData(VertexBuffer.PositionKind);
    if (data && applySkeleton && this.skeleton) {
      data = Tools.Slice(data);
      this._generatePointsArray();
      var matricesIndicesData = this.getVerticesData(VertexBuffer.MatricesIndicesKind);
      var matricesWeightsData = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
      if (matricesWeightsData && matricesIndicesData) {
        var needExtras = this.numBoneInfluencers > 4;
        var matricesIndicesExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;
        var matricesWeightsExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;
        this.skeleton.prepare();
        var skeletonMatrices = this.skeleton.getTransformMatrices(this);
        var tempVector = TmpVectors.Vector3[0];
        var finalMatrix = TmpVectors.Matrix[0];
        var tempMatrix = TmpVectors.Matrix[1];
        var matWeightIdx = 0;
        for (var index = 0; index < data.length; index += 3, matWeightIdx += 4) {
          finalMatrix.reset();
          var inf;
          var weight;
          for (inf = 0; inf < 4; inf++) {
            weight = matricesWeightsData[matWeightIdx + inf];
            if (weight > 0) {
              Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);
              finalMatrix.addToSelf(tempMatrix);
            }
          }
          if (needExtras) {
            for (inf = 0; inf < 4; inf++) {
              weight = matricesWeightsExtraData[matWeightIdx + inf];
              if (weight > 0) {
                Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);
                finalMatrix.addToSelf(tempMatrix);
              }
            }
          }
          Vector3.TransformCoordinatesFromFloatsToRef(data[index], data[index + 1], data[index + 2], finalMatrix, tempVector);
          tempVector.toArray(data, index);
          if (this._positions) {
            this._positions[index / 3].copyFrom(tempVector);
          }
        }
      }
    }
    return data;
  };
  AbstractMesh2.prototype._updateBoundingInfo = function() {
    var effectiveMesh = this._effectiveMesh;
    if (this._boundingInfo) {
      this._boundingInfo.update(effectiveMesh.worldMatrixFromCache);
    } else {
      this._boundingInfo = new BoundingInfo(this.absolutePosition, this.absolutePosition, effectiveMesh.worldMatrixFromCache);
    }
    this._updateSubMeshesBoundingInfo(effectiveMesh.worldMatrixFromCache);
    return this;
  };
  AbstractMesh2.prototype._updateSubMeshesBoundingInfo = function(matrix) {
    if (!this.subMeshes) {
      return this;
    }
    var count = this.subMeshes.length;
    for (var subIndex = 0; subIndex < count; subIndex++) {
      var subMesh = this.subMeshes[subIndex];
      if (count > 1 || !subMesh.IsGlobal) {
        subMesh.updateBoundingInfo(matrix);
      }
    }
    return this;
  };
  AbstractMesh2.prototype._afterComputeWorldMatrix = function() {
    if (this.doNotSyncBoundingInfo) {
      return;
    }
    this._updateBoundingInfo();
  };
  Object.defineProperty(AbstractMesh2.prototype, "_effectiveMesh", {
    get: function() {
      return this.skeleton && this.skeleton.overrideMesh || this;
    },
    enumerable: false,
    configurable: true
  });
  AbstractMesh2.prototype.isInFrustum = function(frustumPlanes) {
    return this._boundingInfo !== null && this._boundingInfo.isInFrustum(frustumPlanes, this.cullingStrategy);
  };
  AbstractMesh2.prototype.isCompletelyInFrustum = function(frustumPlanes) {
    return this._boundingInfo !== null && this._boundingInfo.isCompletelyInFrustum(frustumPlanes);
  };
  AbstractMesh2.prototype.intersectsMesh = function(mesh, precise, includeDescendants) {
    if (precise === void 0) {
      precise = false;
    }
    if (!this._boundingInfo || !mesh._boundingInfo) {
      return false;
    }
    if (this._boundingInfo.intersects(mesh._boundingInfo, precise)) {
      return true;
    }
    if (includeDescendants) {
      for (var _i = 0, _a = this.getChildMeshes(); _i < _a.length; _i++) {
        var child = _a[_i];
        if (child.intersectsMesh(mesh, precise, true)) {
          return true;
        }
      }
    }
    return false;
  };
  AbstractMesh2.prototype.intersectsPoint = function(point) {
    if (!this._boundingInfo) {
      return false;
    }
    return this._boundingInfo.intersectsPoint(point);
  };
  Object.defineProperty(AbstractMesh2.prototype, "checkCollisions", {
    get: function() {
      return this._meshCollisionData._checkCollisions;
    },
    set: function(collisionEnabled) {
      this._meshCollisionData._checkCollisions = collisionEnabled;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "collider", {
    get: function() {
      return this._meshCollisionData._collider;
    },
    enumerable: false,
    configurable: true
  });
  AbstractMesh2.prototype.moveWithCollisions = function(displacement) {
    var globalPosition = this.getAbsolutePosition();
    globalPosition.addToRef(this.ellipsoidOffset, this._meshCollisionData._oldPositionForCollisions);
    var coordinator = this.getScene().collisionCoordinator;
    if (!this._meshCollisionData._collider) {
      this._meshCollisionData._collider = coordinator.createCollider();
    }
    this._meshCollisionData._collider._radius = this.ellipsoid;
    coordinator.getNewPosition(this._meshCollisionData._oldPositionForCollisions, displacement, this._meshCollisionData._collider, 3, this, this._onCollisionPositionChange, this.uniqueId);
    return this;
  };
  AbstractMesh2.prototype._collideForSubMesh = function(subMesh, transformMatrix, collider) {
    this._generatePointsArray();
    if (!this._positions) {
      return this;
    }
    if (!subMesh._lastColliderWorldVertices || !subMesh._lastColliderTransformMatrix.equals(transformMatrix)) {
      subMesh._lastColliderTransformMatrix = transformMatrix.clone();
      subMesh._lastColliderWorldVertices = [];
      subMesh._trianglePlanes = [];
      var start = subMesh.verticesStart;
      var end = subMesh.verticesStart + subMesh.verticesCount;
      for (var i = start; i < end; i++) {
        subMesh._lastColliderWorldVertices.push(Vector3.TransformCoordinates(this._positions[i], transformMatrix));
      }
    }
    collider._collide(subMesh._trianglePlanes, subMesh._lastColliderWorldVertices, this.getIndices(), subMesh.indexStart, subMesh.indexStart + subMesh.indexCount, subMesh.verticesStart, !!subMesh.getMaterial(), this);
    return this;
  };
  AbstractMesh2.prototype._processCollisionsForSubMeshes = function(collider, transformMatrix) {
    var subMeshes = this._scene.getCollidingSubMeshCandidates(this, collider);
    var len = subMeshes.length;
    for (var index = 0; index < len; index++) {
      var subMesh = subMeshes.data[index];
      if (len > 1 && !subMesh._checkCollision(collider)) {
        continue;
      }
      this._collideForSubMesh(subMesh, transformMatrix, collider);
    }
    return this;
  };
  AbstractMesh2.prototype._checkCollision = function(collider) {
    if (!this._boundingInfo || !this._boundingInfo._checkCollision(collider)) {
      return this;
    }
    var collisionsScalingMatrix = TmpVectors.Matrix[0];
    var collisionsTransformMatrix = TmpVectors.Matrix[1];
    Matrix.ScalingToRef(1 / collider._radius.x, 1 / collider._radius.y, 1 / collider._radius.z, collisionsScalingMatrix);
    this.worldMatrixFromCache.multiplyToRef(collisionsScalingMatrix, collisionsTransformMatrix);
    this._processCollisionsForSubMeshes(collider, collisionsTransformMatrix);
    return this;
  };
  AbstractMesh2.prototype._generatePointsArray = function() {
    return false;
  };
  AbstractMesh2.prototype.intersects = function(ray, fastCheck, trianglePredicate, onlyBoundingInfo, worldToUse, skipBoundingInfo) {
    var _a;
    if (onlyBoundingInfo === void 0) {
      onlyBoundingInfo = false;
    }
    if (skipBoundingInfo === void 0) {
      skipBoundingInfo = false;
    }
    var pickingInfo = new PickingInfo();
    var intersectionThreshold = this.getClassName() === "InstancedLinesMesh" || this.getClassName() === "LinesMesh" ? this.intersectionThreshold : 0;
    var boundingInfo = this._boundingInfo;
    if (!this.subMeshes || !boundingInfo) {
      return pickingInfo;
    }
    if (!skipBoundingInfo && (!ray.intersectsSphere(boundingInfo.boundingSphere, intersectionThreshold) || !ray.intersectsBox(boundingInfo.boundingBox, intersectionThreshold))) {
      return pickingInfo;
    }
    if (onlyBoundingInfo) {
      pickingInfo.hit = skipBoundingInfo ? false : true;
      pickingInfo.pickedMesh = skipBoundingInfo ? null : this;
      pickingInfo.distance = skipBoundingInfo ? 0 : Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);
      pickingInfo.subMeshId = 0;
      return pickingInfo;
    }
    if (!this._generatePointsArray()) {
      return pickingInfo;
    }
    var intersectInfo = null;
    var subMeshes = this._scene.getIntersectingSubMeshCandidates(this, ray);
    var len = subMeshes.length;
    var anySubmeshSupportIntersect = false;
    for (var index = 0; index < len; index++) {
      var subMesh = subMeshes.data[index];
      var material = subMesh.getMaterial();
      if (!material) {
        continue;
      }
      if (((_a = this.getIndices()) === null || _a === void 0 ? void 0 : _a.length) && (material.fillMode == 7 || material.fillMode == 0 || material.fillMode == 1 || material.fillMode == 2)) {
        anySubmeshSupportIntersect = true;
        break;
      }
    }
    if (!anySubmeshSupportIntersect) {
      pickingInfo.hit = true;
      pickingInfo.pickedMesh = this;
      pickingInfo.distance = Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);
      pickingInfo.subMeshId = -1;
      return pickingInfo;
    }
    for (var index = 0; index < len; index++) {
      var subMesh = subMeshes.data[index];
      if (len > 1 && !subMesh.canIntersects(ray)) {
        continue;
      }
      var currentIntersectInfo = subMesh.intersects(ray, this._positions, this.getIndices(), fastCheck, trianglePredicate);
      if (currentIntersectInfo) {
        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {
          intersectInfo = currentIntersectInfo;
          intersectInfo.subMeshId = index;
          if (fastCheck) {
            break;
          }
        }
      }
    }
    if (intersectInfo) {
      var world = worldToUse !== null && worldToUse !== void 0 ? worldToUse : this.skeleton && this.skeleton.overrideMesh ? this.skeleton.overrideMesh.getWorldMatrix() : this.getWorldMatrix();
      var worldOrigin = TmpVectors.Vector3[0];
      var direction = TmpVectors.Vector3[1];
      Vector3.TransformCoordinatesToRef(ray.origin, world, worldOrigin);
      ray.direction.scaleToRef(intersectInfo.distance, direction);
      var worldDirection = Vector3.TransformNormal(direction, world);
      var pickedPoint = worldDirection.addInPlace(worldOrigin);
      pickingInfo.hit = true;
      pickingInfo.distance = Vector3.Distance(worldOrigin, pickedPoint);
      pickingInfo.pickedPoint = pickedPoint;
      pickingInfo.pickedMesh = this;
      pickingInfo.bu = intersectInfo.bu || 0;
      pickingInfo.bv = intersectInfo.bv || 0;
      pickingInfo.subMeshFaceId = intersectInfo.faceId;
      pickingInfo.faceId = intersectInfo.faceId + subMeshes.data[intersectInfo.subMeshId].indexStart / (this.getClassName().indexOf("LinesMesh") !== -1 ? 2 : 3);
      pickingInfo.subMeshId = intersectInfo.subMeshId;
      return pickingInfo;
    }
    return pickingInfo;
  };
  AbstractMesh2.prototype.clone = function(name45, newParent, doNotCloneChildren) {
    return null;
  };
  AbstractMesh2.prototype.releaseSubMeshes = function() {
    if (this.subMeshes) {
      while (this.subMeshes.length) {
        this.subMeshes[0].dispose();
      }
    } else {
      this.subMeshes = new Array();
    }
    return this;
  };
  AbstractMesh2.prototype.dispose = function(doNotRecurse, disposeMaterialAndTextures) {
    var _this = this;
    if (disposeMaterialAndTextures === void 0) {
      disposeMaterialAndTextures = false;
    }
    var index;
    if (this._scene.useMaterialMeshMap) {
      if (this._material && this._material.meshMap) {
        this._material.meshMap[this.uniqueId] = void 0;
      }
    }
    this.getScene().freeActiveMeshes();
    this.getScene().freeRenderingGroups();
    if (this.actionManager !== void 0 && this.actionManager !== null) {
      this.actionManager.dispose();
      this.actionManager = null;
    }
    this._internalAbstractMeshDataInfo._skeleton = null;
    if (this._transformMatrixTexture) {
      this._transformMatrixTexture.dispose();
      this._transformMatrixTexture = null;
    }
    for (index = 0; index < this._intersectionsInProgress.length; index++) {
      var other = this._intersectionsInProgress[index];
      var pos = other._intersectionsInProgress.indexOf(this);
      other._intersectionsInProgress.splice(pos, 1);
    }
    this._intersectionsInProgress = [];
    var lights = this.getScene().lights;
    lights.forEach(function(light) {
      var meshIndex = light.includedOnlyMeshes.indexOf(_this);
      if (meshIndex !== -1) {
        light.includedOnlyMeshes.splice(meshIndex, 1);
      }
      meshIndex = light.excludedMeshes.indexOf(_this);
      if (meshIndex !== -1) {
        light.excludedMeshes.splice(meshIndex, 1);
      }
      var generator = light.getShadowGenerator();
      if (generator) {
        var shadowMap = generator.getShadowMap();
        if (shadowMap && shadowMap.renderList) {
          meshIndex = shadowMap.renderList.indexOf(_this);
          if (meshIndex !== -1) {
            shadowMap.renderList.splice(meshIndex, 1);
          }
        }
      }
    });
    if (this.getClassName() !== "InstancedMesh" || this.getClassName() !== "InstancedLinesMesh") {
      this.releaseSubMeshes();
    }
    var engine = this.getScene().getEngine();
    if (this._occlusionQuery) {
      this.isOcclusionQueryInProgress = false;
      engine.deleteQuery(this._occlusionQuery);
      this._occlusionQuery = null;
    }
    engine.wipeCaches();
    this.getScene().removeMesh(this);
    if (disposeMaterialAndTextures) {
      if (this.material) {
        if (this.material.getClassName() === "MultiMaterial") {
          this.material.dispose(false, true, true);
        } else {
          this.material.dispose(false, true);
        }
      }
    }
    if (!doNotRecurse) {
      for (index = 0; index < this.getScene().particleSystems.length; index++) {
        if (this.getScene().particleSystems[index].emitter === this) {
          this.getScene().particleSystems[index].dispose();
          index--;
        }
      }
    }
    if (this._internalAbstractMeshDataInfo._facetData.facetDataEnabled) {
      this.disableFacetData();
    }
    this.onAfterWorldMatrixUpdateObservable.clear();
    this.onCollideObservable.clear();
    this.onCollisionPositionChangeObservable.clear();
    this.onRebuildObservable.clear();
    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);
  };
  AbstractMesh2.prototype.addChild = function(mesh) {
    mesh.setParent(this);
    return this;
  };
  AbstractMesh2.prototype.removeChild = function(mesh) {
    mesh.setParent(null);
    return this;
  };
  AbstractMesh2.prototype._initFacetData = function() {
    var data = this._internalAbstractMeshDataInfo._facetData;
    if (!data.facetNormals) {
      data.facetNormals = new Array();
    }
    if (!data.facetPositions) {
      data.facetPositions = new Array();
    }
    if (!data.facetPartitioning) {
      data.facetPartitioning = new Array();
    }
    data.facetNb = this.getIndices().length / 3 | 0;
    data.partitioningSubdivisions = data.partitioningSubdivisions ? data.partitioningSubdivisions : 10;
    data.partitioningBBoxRatio = data.partitioningBBoxRatio ? data.partitioningBBoxRatio : 1.01;
    for (var f = 0; f < data.facetNb; f++) {
      data.facetNormals[f] = Vector3.Zero();
      data.facetPositions[f] = Vector3.Zero();
    }
    data.facetDataEnabled = true;
    return this;
  };
  AbstractMesh2.prototype.updateFacetData = function() {
    var data = this._internalAbstractMeshDataInfo._facetData;
    if (!data.facetDataEnabled) {
      this._initFacetData();
    }
    var positions = this.getVerticesData(VertexBuffer.PositionKind);
    var indices = this.getIndices();
    var normals = this.getVerticesData(VertexBuffer.NormalKind);
    var bInfo = this.getBoundingInfo();
    if (data.facetDepthSort && !data.facetDepthSortEnabled) {
      data.facetDepthSortEnabled = true;
      if (indices instanceof Uint16Array) {
        data.depthSortedIndices = new Uint16Array(indices);
      } else if (indices instanceof Uint32Array) {
        data.depthSortedIndices = new Uint32Array(indices);
      } else {
        var needs32bits = false;
        for (var i = 0; i < indices.length; i++) {
          if (indices[i] > 65535) {
            needs32bits = true;
            break;
          }
        }
        if (needs32bits) {
          data.depthSortedIndices = new Uint32Array(indices);
        } else {
          data.depthSortedIndices = new Uint16Array(indices);
        }
      }
      data.facetDepthSortFunction = function(f1, f2) {
        return f2.sqDistance - f1.sqDistance;
      };
      if (!data.facetDepthSortFrom) {
        var camera = this.getScene().activeCamera;
        data.facetDepthSortFrom = camera ? camera.position : Vector3.Zero();
      }
      data.depthSortedFacets = [];
      for (var f = 0; f < data.facetNb; f++) {
        var depthSortedFacet = { ind: f * 3, sqDistance: 0 };
        data.depthSortedFacets.push(depthSortedFacet);
      }
      data.invertedMatrix = Matrix.Identity();
      data.facetDepthSortOrigin = Vector3.Zero();
    }
    data.bbSize.x = bInfo.maximum.x - bInfo.minimum.x > Epsilon ? bInfo.maximum.x - bInfo.minimum.x : Epsilon;
    data.bbSize.y = bInfo.maximum.y - bInfo.minimum.y > Epsilon ? bInfo.maximum.y - bInfo.minimum.y : Epsilon;
    data.bbSize.z = bInfo.maximum.z - bInfo.minimum.z > Epsilon ? bInfo.maximum.z - bInfo.minimum.z : Epsilon;
    var bbSizeMax = data.bbSize.x > data.bbSize.y ? data.bbSize.x : data.bbSize.y;
    bbSizeMax = bbSizeMax > data.bbSize.z ? bbSizeMax : data.bbSize.z;
    data.subDiv.max = data.partitioningSubdivisions;
    data.subDiv.X = Math.floor(data.subDiv.max * data.bbSize.x / bbSizeMax);
    data.subDiv.Y = Math.floor(data.subDiv.max * data.bbSize.y / bbSizeMax);
    data.subDiv.Z = Math.floor(data.subDiv.max * data.bbSize.z / bbSizeMax);
    data.subDiv.X = data.subDiv.X < 1 ? 1 : data.subDiv.X;
    data.subDiv.Y = data.subDiv.Y < 1 ? 1 : data.subDiv.Y;
    data.subDiv.Z = data.subDiv.Z < 1 ? 1 : data.subDiv.Z;
    data.facetParameters.facetNormals = this.getFacetLocalNormals();
    data.facetParameters.facetPositions = this.getFacetLocalPositions();
    data.facetParameters.facetPartitioning = this.getFacetLocalPartitioning();
    data.facetParameters.bInfo = bInfo;
    data.facetParameters.bbSize = data.bbSize;
    data.facetParameters.subDiv = data.subDiv;
    data.facetParameters.ratio = this.partitioningBBoxRatio;
    data.facetParameters.depthSort = data.facetDepthSort;
    if (data.facetDepthSort && data.facetDepthSortEnabled) {
      this.computeWorldMatrix(true);
      this._worldMatrix.invertToRef(data.invertedMatrix);
      Vector3.TransformCoordinatesToRef(data.facetDepthSortFrom, data.invertedMatrix, data.facetDepthSortOrigin);
      data.facetParameters.distanceTo = data.facetDepthSortOrigin;
    }
    data.facetParameters.depthSortedFacets = data.depthSortedFacets;
    VertexData.ComputeNormals(positions, indices, normals, data.facetParameters);
    if (data.facetDepthSort && data.facetDepthSortEnabled) {
      data.depthSortedFacets.sort(data.facetDepthSortFunction);
      var l = data.depthSortedIndices.length / 3 | 0;
      for (var f = 0; f < l; f++) {
        var sind = data.depthSortedFacets[f].ind;
        data.depthSortedIndices[f * 3] = indices[sind];
        data.depthSortedIndices[f * 3 + 1] = indices[sind + 1];
        data.depthSortedIndices[f * 3 + 2] = indices[sind + 2];
      }
      this.updateIndices(data.depthSortedIndices, void 0, true);
    }
    return this;
  };
  AbstractMesh2.prototype.getFacetLocalNormals = function() {
    var facetData = this._internalAbstractMeshDataInfo._facetData;
    if (!facetData.facetNormals) {
      this.updateFacetData();
    }
    return facetData.facetNormals;
  };
  AbstractMesh2.prototype.getFacetLocalPositions = function() {
    var facetData = this._internalAbstractMeshDataInfo._facetData;
    if (!facetData.facetPositions) {
      this.updateFacetData();
    }
    return facetData.facetPositions;
  };
  AbstractMesh2.prototype.getFacetLocalPartitioning = function() {
    var facetData = this._internalAbstractMeshDataInfo._facetData;
    if (!facetData.facetPartitioning) {
      this.updateFacetData();
    }
    return facetData.facetPartitioning;
  };
  AbstractMesh2.prototype.getFacetPosition = function(i) {
    var pos = Vector3.Zero();
    this.getFacetPositionToRef(i, pos);
    return pos;
  };
  AbstractMesh2.prototype.getFacetPositionToRef = function(i, ref) {
    var localPos = this.getFacetLocalPositions()[i];
    var world = this.getWorldMatrix();
    Vector3.TransformCoordinatesToRef(localPos, world, ref);
    return this;
  };
  AbstractMesh2.prototype.getFacetNormal = function(i) {
    var norm = Vector3.Zero();
    this.getFacetNormalToRef(i, norm);
    return norm;
  };
  AbstractMesh2.prototype.getFacetNormalToRef = function(i, ref) {
    var localNorm = this.getFacetLocalNormals()[i];
    Vector3.TransformNormalToRef(localNorm, this.getWorldMatrix(), ref);
    return this;
  };
  AbstractMesh2.prototype.getFacetsAtLocalCoordinates = function(x, y, z) {
    var bInfo = this.getBoundingInfo();
    var data = this._internalAbstractMeshDataInfo._facetData;
    var ox = Math.floor((x - bInfo.minimum.x * data.partitioningBBoxRatio) * data.subDiv.X * data.partitioningBBoxRatio / data.bbSize.x);
    var oy = Math.floor((y - bInfo.minimum.y * data.partitioningBBoxRatio) * data.subDiv.Y * data.partitioningBBoxRatio / data.bbSize.y);
    var oz = Math.floor((z - bInfo.minimum.z * data.partitioningBBoxRatio) * data.subDiv.Z * data.partitioningBBoxRatio / data.bbSize.z);
    if (ox < 0 || ox > data.subDiv.max || oy < 0 || oy > data.subDiv.max || oz < 0 || oz > data.subDiv.max) {
      return null;
    }
    return data.facetPartitioning[ox + data.subDiv.max * oy + data.subDiv.max * data.subDiv.max * oz];
  };
  AbstractMesh2.prototype.getClosestFacetAtCoordinates = function(x, y, z, projected, checkFace, facing) {
    if (checkFace === void 0) {
      checkFace = false;
    }
    if (facing === void 0) {
      facing = true;
    }
    var world = this.getWorldMatrix();
    var invMat = TmpVectors.Matrix[5];
    world.invertToRef(invMat);
    var invVect = TmpVectors.Vector3[8];
    Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, invMat, invVect);
    var closest = this.getClosestFacetAtLocalCoordinates(invVect.x, invVect.y, invVect.z, projected, checkFace, facing);
    if (projected) {
      Vector3.TransformCoordinatesFromFloatsToRef(projected.x, projected.y, projected.z, world, projected);
    }
    return closest;
  };
  AbstractMesh2.prototype.getClosestFacetAtLocalCoordinates = function(x, y, z, projected, checkFace, facing) {
    if (checkFace === void 0) {
      checkFace = false;
    }
    if (facing === void 0) {
      facing = true;
    }
    var closest = null;
    var tmpx = 0;
    var tmpy = 0;
    var tmpz = 0;
    var d = 0;
    var t0 = 0;
    var projx = 0;
    var projy = 0;
    var projz = 0;
    var facetPositions = this.getFacetLocalPositions();
    var facetNormals = this.getFacetLocalNormals();
    var facetsInBlock = this.getFacetsAtLocalCoordinates(x, y, z);
    if (!facetsInBlock) {
      return null;
    }
    var shortest = Number.MAX_VALUE;
    var tmpDistance = shortest;
    var fib;
    var norm;
    var p0;
    for (var idx = 0; idx < facetsInBlock.length; idx++) {
      fib = facetsInBlock[idx];
      norm = facetNormals[fib];
      p0 = facetPositions[fib];
      d = (x - p0.x) * norm.x + (y - p0.y) * norm.y + (z - p0.z) * norm.z;
      if (!checkFace || checkFace && facing && d >= 0 || checkFace && !facing && d <= 0) {
        d = norm.x * p0.x + norm.y * p0.y + norm.z * p0.z;
        t0 = -(norm.x * x + norm.y * y + norm.z * z - d) / (norm.x * norm.x + norm.y * norm.y + norm.z * norm.z);
        projx = x + norm.x * t0;
        projy = y + norm.y * t0;
        projz = z + norm.z * t0;
        tmpx = projx - x;
        tmpy = projy - y;
        tmpz = projz - z;
        tmpDistance = tmpx * tmpx + tmpy * tmpy + tmpz * tmpz;
        if (tmpDistance < shortest) {
          shortest = tmpDistance;
          closest = fib;
          if (projected) {
            projected.x = projx;
            projected.y = projy;
            projected.z = projz;
          }
        }
      }
    }
    return closest;
  };
  AbstractMesh2.prototype.getFacetDataParameters = function() {
    return this._internalAbstractMeshDataInfo._facetData.facetParameters;
  };
  AbstractMesh2.prototype.disableFacetData = function() {
    var facetData = this._internalAbstractMeshDataInfo._facetData;
    if (facetData.facetDataEnabled) {
      facetData.facetDataEnabled = false;
      facetData.facetPositions = new Array();
      facetData.facetNormals = new Array();
      facetData.facetPartitioning = new Array();
      facetData.facetParameters = null;
      facetData.depthSortedIndices = new Uint32Array(0);
    }
    return this;
  };
  AbstractMesh2.prototype.updateIndices = function(indices, offset, gpuMemoryOnly) {
    if (gpuMemoryOnly === void 0) {
      gpuMemoryOnly = false;
    }
    return this;
  };
  AbstractMesh2.prototype.createNormals = function(updatable) {
    var positions = this.getVerticesData(VertexBuffer.PositionKind);
    var indices = this.getIndices();
    var normals;
    if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      normals = this.getVerticesData(VertexBuffer.NormalKind);
    } else {
      normals = [];
    }
    VertexData.ComputeNormals(positions, indices, normals, { useRightHandedSystem: this.getScene().useRightHandedSystem });
    this.setVerticesData(VertexBuffer.NormalKind, normals, updatable);
    return this;
  };
  AbstractMesh2.prototype.alignWithNormal = function(normal, upDirection) {
    if (!upDirection) {
      upDirection = Axis.Y;
    }
    var axisX = TmpVectors.Vector3[0];
    var axisZ = TmpVectors.Vector3[1];
    Vector3.CrossToRef(upDirection, normal, axisZ);
    Vector3.CrossToRef(normal, axisZ, axisX);
    if (this.rotationQuaternion) {
      Quaternion.RotationQuaternionFromAxisToRef(axisX, normal, axisZ, this.rotationQuaternion);
    } else {
      Vector3.RotationFromAxisToRef(axisX, normal, axisZ, this.rotation);
    }
    return this;
  };
  AbstractMesh2.prototype._checkOcclusionQuery = function() {
    return false;
  };
  AbstractMesh2.prototype.disableEdgesRendering = function() {
    throw _DevTools.WarnImport("EdgesRenderer");
  };
  AbstractMesh2.prototype.enableEdgesRendering = function(epsilon, checkVerticesInsteadOfIndices, options) {
    throw _DevTools.WarnImport("EdgesRenderer");
  };
  AbstractMesh2.prototype.getConnectedParticleSystems = function() {
    var _this = this;
    return this._scene.particleSystems.filter(function(particleSystem) {
      return particleSystem.emitter === _this;
    });
  };
  AbstractMesh2.OCCLUSION_TYPE_NONE = 0;
  AbstractMesh2.OCCLUSION_TYPE_OPTIMISTIC = 1;
  AbstractMesh2.OCCLUSION_TYPE_STRICT = 2;
  AbstractMesh2.OCCLUSION_ALGORITHM_TYPE_ACCURATE = 0;
  AbstractMesh2.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE = 1;
  AbstractMesh2.CULLINGSTRATEGY_STANDARD = 0;
  AbstractMesh2.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1;
  AbstractMesh2.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = 2;
  AbstractMesh2.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = 3;
  return AbstractMesh2;
}(TransformNode);
_TypeStore.RegisteredTypes["BABYLON.AbstractMesh"] = AbstractMesh;

// node_modules/@babylonjs/core/Maths/math.viewport.js
var Viewport = function() {
  function Viewport2(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }
  Viewport2.prototype.toGlobal = function(renderWidth, renderHeight) {
    return new Viewport2(this.x * renderWidth, this.y * renderHeight, this.width * renderWidth, this.height * renderHeight);
  };
  Viewport2.prototype.toGlobalToRef = function(renderWidth, renderHeight, ref) {
    ref.x = this.x * renderWidth;
    ref.y = this.y * renderHeight;
    ref.width = this.width * renderWidth;
    ref.height = this.height * renderHeight;
    return this;
  };
  Viewport2.prototype.clone = function() {
    return new Viewport2(this.x, this.y, this.width, this.height);
  };
  return Viewport2;
}();

// node_modules/@babylonjs/core/Maths/math.plane.js
var Plane = function() {
  function Plane2(a, b, c, d) {
    this.normal = new Vector3(a, b, c);
    this.d = d;
  }
  Plane2.prototype.asArray = function() {
    return [this.normal.x, this.normal.y, this.normal.z, this.d];
  };
  Plane2.prototype.clone = function() {
    return new Plane2(this.normal.x, this.normal.y, this.normal.z, this.d);
  };
  Plane2.prototype.getClassName = function() {
    return "Plane";
  };
  Plane2.prototype.getHashCode = function() {
    var hash = this.normal.getHashCode();
    hash = hash * 397 ^ (this.d | 0);
    return hash;
  };
  Plane2.prototype.normalize = function() {
    var norm = Math.sqrt(this.normal.x * this.normal.x + this.normal.y * this.normal.y + this.normal.z * this.normal.z);
    var magnitude = 0;
    if (norm !== 0) {
      magnitude = 1 / norm;
    }
    this.normal.x *= magnitude;
    this.normal.y *= magnitude;
    this.normal.z *= magnitude;
    this.d *= magnitude;
    return this;
  };
  Plane2.prototype.transform = function(transformation) {
    var invertedMatrix = Plane2._TmpMatrix;
    transformation.invertToRef(invertedMatrix);
    var m = invertedMatrix.m;
    var x = this.normal.x;
    var y = this.normal.y;
    var z = this.normal.z;
    var d = this.d;
    var normalX = x * m[0] + y * m[1] + z * m[2] + d * m[3];
    var normalY = x * m[4] + y * m[5] + z * m[6] + d * m[7];
    var normalZ = x * m[8] + y * m[9] + z * m[10] + d * m[11];
    var finalD = x * m[12] + y * m[13] + z * m[14] + d * m[15];
    return new Plane2(normalX, normalY, normalZ, finalD);
  };
  Plane2.prototype.dotCoordinate = function(point) {
    return this.normal.x * point.x + this.normal.y * point.y + this.normal.z * point.z + this.d;
  };
  Plane2.prototype.copyFromPoints = function(point1, point2, point3) {
    var x1 = point2.x - point1.x;
    var y1 = point2.y - point1.y;
    var z1 = point2.z - point1.z;
    var x2 = point3.x - point1.x;
    var y2 = point3.y - point1.y;
    var z2 = point3.z - point1.z;
    var yz = y1 * z2 - z1 * y2;
    var xz = z1 * x2 - x1 * z2;
    var xy = x1 * y2 - y1 * x2;
    var pyth = Math.sqrt(yz * yz + xz * xz + xy * xy);
    var invPyth;
    if (pyth !== 0) {
      invPyth = 1 / pyth;
    } else {
      invPyth = 0;
    }
    this.normal.x = yz * invPyth;
    this.normal.y = xz * invPyth;
    this.normal.z = xy * invPyth;
    this.d = -(this.normal.x * point1.x + this.normal.y * point1.y + this.normal.z * point1.z);
    return this;
  };
  Plane2.prototype.isFrontFacingTo = function(direction, epsilon) {
    var dot = Vector3.Dot(this.normal, direction);
    return dot <= epsilon;
  };
  Plane2.prototype.signedDistanceTo = function(point) {
    return Vector3.Dot(point, this.normal) + this.d;
  };
  Plane2.FromArray = function(array) {
    return new Plane2(array[0], array[1], array[2], array[3]);
  };
  Plane2.FromPoints = function(point1, point2, point3) {
    var result = new Plane2(0, 0, 0, 0);
    result.copyFromPoints(point1, point2, point3);
    return result;
  };
  Plane2.FromPositionAndNormal = function(origin, normal) {
    var result = new Plane2(0, 0, 0, 0);
    normal.normalize();
    result.normal = normal;
    result.d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);
    return result;
  };
  Plane2.SignedDistanceToPlaneFromPositionAndNormal = function(origin, normal, point) {
    var d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);
    return Vector3.Dot(point, normal) + d;
  };
  Plane2._TmpMatrix = Matrix.Identity();
  return Plane2;
}();

// node_modules/@babylonjs/core/Maths/math.frustum.js
var Frustum = function() {
  function Frustum2() {
  }
  Frustum2.GetPlanes = function(transform) {
    var frustumPlanes = [];
    for (var index = 0; index < 6; index++) {
      frustumPlanes.push(new Plane(0, 0, 0, 0));
    }
    Frustum2.GetPlanesToRef(transform, frustumPlanes);
    return frustumPlanes;
  };
  Frustum2.GetNearPlaneToRef = function(transform, frustumPlane) {
    var m = transform.m;
    frustumPlane.normal.x = m[3] + m[2];
    frustumPlane.normal.y = m[7] + m[6];
    frustumPlane.normal.z = m[11] + m[10];
    frustumPlane.d = m[15] + m[14];
    frustumPlane.normalize();
  };
  Frustum2.GetFarPlaneToRef = function(transform, frustumPlane) {
    var m = transform.m;
    frustumPlane.normal.x = m[3] - m[2];
    frustumPlane.normal.y = m[7] - m[6];
    frustumPlane.normal.z = m[11] - m[10];
    frustumPlane.d = m[15] - m[14];
    frustumPlane.normalize();
  };
  Frustum2.GetLeftPlaneToRef = function(transform, frustumPlane) {
    var m = transform.m;
    frustumPlane.normal.x = m[3] + m[0];
    frustumPlane.normal.y = m[7] + m[4];
    frustumPlane.normal.z = m[11] + m[8];
    frustumPlane.d = m[15] + m[12];
    frustumPlane.normalize();
  };
  Frustum2.GetRightPlaneToRef = function(transform, frustumPlane) {
    var m = transform.m;
    frustumPlane.normal.x = m[3] - m[0];
    frustumPlane.normal.y = m[7] - m[4];
    frustumPlane.normal.z = m[11] - m[8];
    frustumPlane.d = m[15] - m[12];
    frustumPlane.normalize();
  };
  Frustum2.GetTopPlaneToRef = function(transform, frustumPlane) {
    var m = transform.m;
    frustumPlane.normal.x = m[3] - m[1];
    frustumPlane.normal.y = m[7] - m[5];
    frustumPlane.normal.z = m[11] - m[9];
    frustumPlane.d = m[15] - m[13];
    frustumPlane.normalize();
  };
  Frustum2.GetBottomPlaneToRef = function(transform, frustumPlane) {
    var m = transform.m;
    frustumPlane.normal.x = m[3] + m[1];
    frustumPlane.normal.y = m[7] + m[5];
    frustumPlane.normal.z = m[11] + m[9];
    frustumPlane.d = m[15] + m[13];
    frustumPlane.normalize();
  };
  Frustum2.GetPlanesToRef = function(transform, frustumPlanes) {
    Frustum2.GetNearPlaneToRef(transform, frustumPlanes[0]);
    Frustum2.GetFarPlaneToRef(transform, frustumPlanes[1]);
    Frustum2.GetLeftPlaneToRef(transform, frustumPlanes[2]);
    Frustum2.GetRightPlaneToRef(transform, frustumPlanes[3]);
    Frustum2.GetTopPlaneToRef(transform, frustumPlanes[4]);
    Frustum2.GetBottomPlaneToRef(transform, frustumPlanes[5]);
  };
  return Frustum2;
}();

// node_modules/@babylonjs/core/Cameras/camera.js
var Camera = function(_super) {
  __extends(Camera2, _super);
  function Camera2(name45, position, scene, setActiveOnSceneIfNoneActive) {
    if (setActiveOnSceneIfNoneActive === void 0) {
      setActiveOnSceneIfNoneActive = true;
    }
    var _this = _super.call(this, name45, scene) || this;
    _this._position = Vector3.Zero();
    _this._upVector = Vector3.Up();
    _this.orthoLeft = null;
    _this.orthoRight = null;
    _this.orthoBottom = null;
    _this.orthoTop = null;
    _this.fov = 0.8;
    _this.minZ = 1;
    _this.maxZ = 1e4;
    _this.inertia = 0.9;
    _this.mode = Camera2.PERSPECTIVE_CAMERA;
    _this.isIntermediate = false;
    _this.viewport = new Viewport(0, 0, 1, 1);
    _this.layerMask = 268435455;
    _this.fovMode = Camera2.FOVMODE_VERTICAL_FIXED;
    _this.cameraRigMode = Camera2.RIG_MODE_NONE;
    _this.customRenderTargets = new Array();
    _this.outputRenderTarget = null;
    _this.onViewMatrixChangedObservable = new Observable();
    _this.onProjectionMatrixChangedObservable = new Observable();
    _this.onAfterCheckInputsObservable = new Observable();
    _this.onRestoreStateObservable = new Observable();
    _this.isRigCamera = false;
    _this._rigCameras = new Array();
    _this._webvrViewMatrix = Matrix.Identity();
    _this._skipRendering = false;
    _this._projectionMatrix = new Matrix();
    _this._postProcesses = new Array();
    _this._activeMeshes = new SmartArray(256);
    _this._globalPosition = Vector3.Zero();
    _this._computedViewMatrix = Matrix.Identity();
    _this._doNotComputeProjectionMatrix = false;
    _this._transformMatrix = Matrix.Zero();
    _this._refreshFrustumPlanes = true;
    _this._isCamera = true;
    _this._isLeftCamera = false;
    _this._isRightCamera = false;
    _this.getScene().addCamera(_this);
    if (setActiveOnSceneIfNoneActive && !_this.getScene().activeCamera) {
      _this.getScene().activeCamera = _this;
    }
    _this.position = position;
    return _this;
  }
  Object.defineProperty(Camera2.prototype, "position", {
    get: function() {
      return this._position;
    },
    set: function(newPosition) {
      this._position = newPosition;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Camera2.prototype, "upVector", {
    get: function() {
      return this._upVector;
    },
    set: function(vec) {
      this._upVector = vec;
    },
    enumerable: false,
    configurable: true
  });
  Camera2.prototype.storeState = function() {
    this._stateStored = true;
    this._storedFov = this.fov;
    return this;
  };
  Camera2.prototype._restoreStateValues = function() {
    if (!this._stateStored) {
      return false;
    }
    this.fov = this._storedFov;
    return true;
  };
  Camera2.prototype.restoreState = function() {
    if (this._restoreStateValues()) {
      this.onRestoreStateObservable.notifyObservers(this);
      return true;
    }
    return false;
  };
  Camera2.prototype.getClassName = function() {
    return "Camera";
  };
  Camera2.prototype.toString = function(fullDetails) {
    var ret = "Name: " + this.name;
    ret += ", type: " + this.getClassName();
    if (this.animations) {
      for (var i = 0; i < this.animations.length; i++) {
        ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
      }
    }
    if (fullDetails) {
    }
    return ret;
  };
  Object.defineProperty(Camera2.prototype, "globalPosition", {
    get: function() {
      return this._globalPosition;
    },
    enumerable: false,
    configurable: true
  });
  Camera2.prototype.getActiveMeshes = function() {
    return this._activeMeshes;
  };
  Camera2.prototype.isActiveMesh = function(mesh) {
    return this._activeMeshes.indexOf(mesh) !== -1;
  };
  Camera2.prototype.isReady = function(completeCheck) {
    if (completeCheck === void 0) {
      completeCheck = false;
    }
    if (completeCheck) {
      for (var _i = 0, _a = this._postProcesses; _i < _a.length; _i++) {
        var pp = _a[_i];
        if (pp && !pp.isReady()) {
          return false;
        }
      }
    }
    return _super.prototype.isReady.call(this, completeCheck);
  };
  Camera2.prototype._initCache = function() {
    _super.prototype._initCache.call(this);
    this._cache.position = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.upVector = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.mode = void 0;
    this._cache.minZ = void 0;
    this._cache.maxZ = void 0;
    this._cache.fov = void 0;
    this._cache.fovMode = void 0;
    this._cache.aspectRatio = void 0;
    this._cache.orthoLeft = void 0;
    this._cache.orthoRight = void 0;
    this._cache.orthoBottom = void 0;
    this._cache.orthoTop = void 0;
    this._cache.renderWidth = void 0;
    this._cache.renderHeight = void 0;
  };
  Camera2.prototype._updateCache = function(ignoreParentClass) {
    if (!ignoreParentClass) {
      _super.prototype._updateCache.call(this);
    }
    this._cache.position.copyFrom(this.position);
    this._cache.upVector.copyFrom(this.upVector);
  };
  Camera2.prototype._isSynchronized = function() {
    return this._isSynchronizedViewMatrix() && this._isSynchronizedProjectionMatrix();
  };
  Camera2.prototype._isSynchronizedViewMatrix = function() {
    if (!_super.prototype._isSynchronized.call(this)) {
      return false;
    }
    return this._cache.position.equals(this.position) && this._cache.upVector.equals(this.upVector) && this.isSynchronizedWithParent();
  };
  Camera2.prototype._isSynchronizedProjectionMatrix = function() {
    var check = this._cache.mode === this.mode && this._cache.minZ === this.minZ && this._cache.maxZ === this.maxZ;
    if (!check) {
      return false;
    }
    var engine = this.getEngine();
    if (this.mode === Camera2.PERSPECTIVE_CAMERA) {
      check = this._cache.fov === this.fov && this._cache.fovMode === this.fovMode && this._cache.aspectRatio === engine.getAspectRatio(this);
    } else {
      check = this._cache.orthoLeft === this.orthoLeft && this._cache.orthoRight === this.orthoRight && this._cache.orthoBottom === this.orthoBottom && this._cache.orthoTop === this.orthoTop && this._cache.renderWidth === engine.getRenderWidth() && this._cache.renderHeight === engine.getRenderHeight();
    }
    return check;
  };
  Camera2.prototype.attachControl = function(ignored, noPreventDefault) {
  };
  Camera2.prototype.detachControl = function(ignored) {
  };
  Camera2.prototype.update = function() {
    this._checkInputs();
    if (this.cameraRigMode !== Camera2.RIG_MODE_NONE) {
      this._updateRigCameras();
    }
  };
  Camera2.prototype._checkInputs = function() {
    this.onAfterCheckInputsObservable.notifyObservers(this);
  };
  Object.defineProperty(Camera2.prototype, "rigCameras", {
    get: function() {
      return this._rigCameras;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Camera2.prototype, "rigPostProcess", {
    get: function() {
      return this._rigPostProcess;
    },
    enumerable: false,
    configurable: true
  });
  Camera2.prototype._getFirstPostProcess = function() {
    for (var ppIndex = 0; ppIndex < this._postProcesses.length; ppIndex++) {
      if (this._postProcesses[ppIndex] !== null) {
        return this._postProcesses[ppIndex];
      }
    }
    return null;
  };
  Camera2.prototype._cascadePostProcessesToRigCams = function() {
    var firstPostProcess = this._getFirstPostProcess();
    if (firstPostProcess) {
      firstPostProcess.markTextureDirty();
    }
    for (var i = 0, len = this._rigCameras.length; i < len; i++) {
      var cam = this._rigCameras[i];
      var rigPostProcess = cam._rigPostProcess;
      if (rigPostProcess) {
        var isPass = rigPostProcess.getEffectName() === "pass";
        if (isPass) {
          cam.isIntermediate = this._postProcesses.length === 0;
        }
        cam._postProcesses = this._postProcesses.slice(0).concat(rigPostProcess);
        rigPostProcess.markTextureDirty();
      } else {
        cam._postProcesses = this._postProcesses.slice(0);
      }
    }
  };
  Camera2.prototype.attachPostProcess = function(postProcess, insertAt) {
    if (insertAt === void 0) {
      insertAt = null;
    }
    if (!postProcess.isReusable() && this._postProcesses.indexOf(postProcess) > -1) {
      Logger.Error("You're trying to reuse a post process not defined as reusable.");
      return 0;
    }
    if (insertAt == null || insertAt < 0) {
      this._postProcesses.push(postProcess);
    } else if (this._postProcesses[insertAt] === null) {
      this._postProcesses[insertAt] = postProcess;
    } else {
      this._postProcesses.splice(insertAt, 0, postProcess);
    }
    this._cascadePostProcessesToRigCams();
    if (this._scene.prePassRenderer) {
      this._scene.prePassRenderer.markAsDirty();
    }
    return this._postProcesses.indexOf(postProcess);
  };
  Camera2.prototype.detachPostProcess = function(postProcess) {
    var idx = this._postProcesses.indexOf(postProcess);
    if (idx !== -1) {
      this._postProcesses[idx] = null;
    }
    if (this._scene.prePassRenderer) {
      this._scene.prePassRenderer.markAsDirty();
    }
    this._cascadePostProcessesToRigCams();
  };
  Camera2.prototype.getWorldMatrix = function() {
    if (this._isSynchronizedViewMatrix()) {
      return this._worldMatrix;
    }
    this.getViewMatrix();
    return this._worldMatrix;
  };
  Camera2.prototype._getViewMatrix = function() {
    return Matrix.Identity();
  };
  Camera2.prototype.getViewMatrix = function(force) {
    if (!force && this._isSynchronizedViewMatrix()) {
      return this._computedViewMatrix;
    }
    this.updateCache();
    this._computedViewMatrix = this._getViewMatrix();
    this._currentRenderId = this.getScene().getRenderId();
    this._childUpdateId++;
    this._refreshFrustumPlanes = true;
    if (this._cameraRigParams && this._cameraRigParams.vrPreViewMatrix) {
      this._computedViewMatrix.multiplyToRef(this._cameraRigParams.vrPreViewMatrix, this._computedViewMatrix);
    }
    if (this.parent && this.parent.onViewMatrixChangedObservable) {
      this.parent.onViewMatrixChangedObservable.notifyObservers(this.parent);
    }
    this.onViewMatrixChangedObservable.notifyObservers(this);
    this._computedViewMatrix.invertToRef(this._worldMatrix);
    return this._computedViewMatrix;
  };
  Camera2.prototype.freezeProjectionMatrix = function(projection) {
    this._doNotComputeProjectionMatrix = true;
    if (projection !== void 0) {
      this._projectionMatrix = projection;
    }
  };
  Camera2.prototype.unfreezeProjectionMatrix = function() {
    this._doNotComputeProjectionMatrix = false;
  };
  Camera2.prototype.getProjectionMatrix = function(force) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (this._doNotComputeProjectionMatrix || !force && this._isSynchronizedProjectionMatrix()) {
      return this._projectionMatrix;
    }
    this._cache.mode = this.mode;
    this._cache.minZ = this.minZ;
    this._cache.maxZ = this.maxZ;
    this._refreshFrustumPlanes = true;
    var engine = this.getEngine();
    var scene = this.getScene();
    if (this.mode === Camera2.PERSPECTIVE_CAMERA) {
      this._cache.fov = this.fov;
      this._cache.fovMode = this.fovMode;
      this._cache.aspectRatio = engine.getAspectRatio(this);
      if (this.minZ <= 0) {
        this.minZ = 0.1;
      }
      var reverseDepth = engine.useReverseDepthBuffer;
      var getProjectionMatrix = void 0;
      if (scene.useRightHandedSystem) {
        getProjectionMatrix = reverseDepth ? Matrix.PerspectiveFovReverseRHToRef : Matrix.PerspectiveFovRHToRef;
      } else {
        getProjectionMatrix = reverseDepth ? Matrix.PerspectiveFovReverseLHToRef : Matrix.PerspectiveFovLHToRef;
      }
      getProjectionMatrix(this.fov, engine.getAspectRatio(this), this.minZ, this.maxZ, this._projectionMatrix, this.fovMode === Camera2.FOVMODE_VERTICAL_FIXED);
    } else {
      var halfWidth = engine.getRenderWidth() / 2;
      var halfHeight = engine.getRenderHeight() / 2;
      if (scene.useRightHandedSystem) {
        Matrix.OrthoOffCenterRHToRef((_a = this.orthoLeft) !== null && _a !== void 0 ? _a : -halfWidth, (_b = this.orthoRight) !== null && _b !== void 0 ? _b : halfWidth, (_c = this.orthoBottom) !== null && _c !== void 0 ? _c : -halfHeight, (_d = this.orthoTop) !== null && _d !== void 0 ? _d : halfHeight, this.minZ, this.maxZ, this._projectionMatrix);
      } else {
        Matrix.OrthoOffCenterLHToRef((_e = this.orthoLeft) !== null && _e !== void 0 ? _e : -halfWidth, (_f = this.orthoRight) !== null && _f !== void 0 ? _f : halfWidth, (_g = this.orthoBottom) !== null && _g !== void 0 ? _g : -halfHeight, (_h = this.orthoTop) !== null && _h !== void 0 ? _h : halfHeight, this.minZ, this.maxZ, this._projectionMatrix);
      }
      this._cache.orthoLeft = this.orthoLeft;
      this._cache.orthoRight = this.orthoRight;
      this._cache.orthoBottom = this.orthoBottom;
      this._cache.orthoTop = this.orthoTop;
      this._cache.renderWidth = engine.getRenderWidth();
      this._cache.renderHeight = engine.getRenderHeight();
    }
    this.onProjectionMatrixChangedObservable.notifyObservers(this);
    return this._projectionMatrix;
  };
  Camera2.prototype.getTransformationMatrix = function() {
    this._computedViewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
    return this._transformMatrix;
  };
  Camera2.prototype._updateFrustumPlanes = function() {
    if (!this._refreshFrustumPlanes) {
      return;
    }
    this.getTransformationMatrix();
    if (!this._frustumPlanes) {
      this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);
    } else {
      Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);
    }
    this._refreshFrustumPlanes = false;
  };
  Camera2.prototype.isInFrustum = function(target, checkRigCameras) {
    if (checkRigCameras === void 0) {
      checkRigCameras = false;
    }
    this._updateFrustumPlanes();
    if (checkRigCameras && this.rigCameras.length > 0) {
      var result = false;
      this.rigCameras.forEach(function(cam) {
        cam._updateFrustumPlanes();
        result = result || target.isInFrustum(cam._frustumPlanes);
      });
      return result;
    } else {
      return target.isInFrustum(this._frustumPlanes);
    }
  };
  Camera2.prototype.isCompletelyInFrustum = function(target) {
    this._updateFrustumPlanes();
    return target.isCompletelyInFrustum(this._frustumPlanes);
  };
  Camera2.prototype.getForwardRay = function(length, transform, origin) {
    if (length === void 0) {
      length = 100;
    }
    throw _DevTools.WarnImport("Ray");
  };
  Camera2.prototype.getForwardRayToRef = function(refRay, length, transform, origin) {
    if (length === void 0) {
      length = 100;
    }
    throw _DevTools.WarnImport("Ray");
  };
  Camera2.prototype.dispose = function(doNotRecurse, disposeMaterialAndTextures) {
    if (disposeMaterialAndTextures === void 0) {
      disposeMaterialAndTextures = false;
    }
    this.onViewMatrixChangedObservable.clear();
    this.onProjectionMatrixChangedObservable.clear();
    this.onAfterCheckInputsObservable.clear();
    this.onRestoreStateObservable.clear();
    if (this.inputs) {
      this.inputs.clear();
    }
    this.getScene().stopAnimation(this);
    this.getScene().removeCamera(this);
    while (this._rigCameras.length > 0) {
      var camera = this._rigCameras.pop();
      if (camera) {
        camera.dispose();
      }
    }
    if (this._rigPostProcess) {
      this._rigPostProcess.dispose(this);
      this._rigPostProcess = null;
      this._postProcesses = [];
    } else if (this.cameraRigMode !== Camera2.RIG_MODE_NONE) {
      this._rigPostProcess = null;
      this._postProcesses = [];
    } else {
      var i = this._postProcesses.length;
      while (--i >= 0) {
        var postProcess = this._postProcesses[i];
        if (postProcess) {
          postProcess.dispose(this);
        }
      }
    }
    var i = this.customRenderTargets.length;
    while (--i >= 0) {
      this.customRenderTargets[i].dispose();
    }
    this.customRenderTargets = [];
    this._activeMeshes.dispose();
    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);
  };
  Object.defineProperty(Camera2.prototype, "isLeftCamera", {
    get: function() {
      return this._isLeftCamera;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Camera2.prototype, "isRightCamera", {
    get: function() {
      return this._isRightCamera;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Camera2.prototype, "leftCamera", {
    get: function() {
      if (this._rigCameras.length < 1) {
        return null;
      }
      return this._rigCameras[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Camera2.prototype, "rightCamera", {
    get: function() {
      if (this._rigCameras.length < 2) {
        return null;
      }
      return this._rigCameras[1];
    },
    enumerable: false,
    configurable: true
  });
  Camera2.prototype.getLeftTarget = function() {
    if (this._rigCameras.length < 1) {
      return null;
    }
    return this._rigCameras[0].getTarget();
  };
  Camera2.prototype.getRightTarget = function() {
    if (this._rigCameras.length < 2) {
      return null;
    }
    return this._rigCameras[1].getTarget();
  };
  Camera2.prototype.setCameraRigMode = function(mode, rigParams) {
    if (this.cameraRigMode === mode) {
      return;
    }
    while (this._rigCameras.length > 0) {
      var camera = this._rigCameras.pop();
      if (camera) {
        camera.dispose();
      }
    }
    this.cameraRigMode = mode;
    this._cameraRigParams = {};
    this._cameraRigParams.interaxialDistance = rigParams.interaxialDistance || 0.0637;
    this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(this._cameraRigParams.interaxialDistance / 0.0637);
    if (this.cameraRigMode !== Camera2.RIG_MODE_NONE) {
      var leftCamera = this.createRigCamera(this.name + "_L", 0);
      if (leftCamera) {
        leftCamera._isLeftCamera = true;
      }
      var rightCamera = this.createRigCamera(this.name + "_R", 1);
      if (rightCamera) {
        rightCamera._isRightCamera = true;
      }
      if (leftCamera && rightCamera) {
        this._rigCameras.push(leftCamera);
        this._rigCameras.push(rightCamera);
      }
    }
    switch (this.cameraRigMode) {
      case Camera2.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
        Camera2._setStereoscopicAnaglyphRigMode(this);
        break;
      case Camera2.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
      case Camera2.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
      case Camera2.RIG_MODE_STEREOSCOPIC_OVERUNDER:
      case Camera2.RIG_MODE_STEREOSCOPIC_INTERLACED:
        Camera2._setStereoscopicRigMode(this);
        break;
      case Camera2.RIG_MODE_VR:
        Camera2._setVRRigMode(this, rigParams);
        break;
      case Camera2.RIG_MODE_WEBVR:
        Camera2._setWebVRRigMode(this, rigParams);
        break;
    }
    this._cascadePostProcessesToRigCams();
    this.update();
  };
  Camera2._setStereoscopicRigMode = function(camera) {
    throw "Import Cameras/RigModes/stereoscopicRigMode before using stereoscopic rig mode";
  };
  Camera2._setStereoscopicAnaglyphRigMode = function(camera) {
    throw "Import Cameras/RigModes/stereoscopicAnaglyphRigMode before using stereoscopic anaglyph rig mode";
  };
  Camera2._setVRRigMode = function(camera, rigParams) {
    throw "Import Cameras/RigModes/vrRigMode before using VR rig mode";
  };
  Camera2._setWebVRRigMode = function(camera, rigParams) {
    throw "Import Cameras/RigModes/WebVRRigMode before using Web VR rig mode";
  };
  Camera2.prototype._getVRProjectionMatrix = function() {
    Matrix.PerspectiveFovLHToRef(this._cameraRigParams.vrMetrics.aspectRatioFov, this._cameraRigParams.vrMetrics.aspectRatio, this.minZ, this.maxZ, this._cameraRigParams.vrWorkMatrix);
    this._cameraRigParams.vrWorkMatrix.multiplyToRef(this._cameraRigParams.vrHMatrix, this._projectionMatrix);
    return this._projectionMatrix;
  };
  Camera2.prototype._updateCameraRotationMatrix = function() {
  };
  Camera2.prototype._updateWebVRCameraRotationMatrix = function() {
  };
  Camera2.prototype._getWebVRProjectionMatrix = function() {
    return Matrix.Identity();
  };
  Camera2.prototype._getWebVRViewMatrix = function() {
    return Matrix.Identity();
  };
  Camera2.prototype.setCameraRigParameter = function(name45, value) {
    if (!this._cameraRigParams) {
      this._cameraRigParams = {};
    }
    this._cameraRigParams[name45] = value;
    if (name45 === "interaxialDistance") {
      this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(value / 0.0637);
    }
  };
  Camera2.prototype.createRigCamera = function(name45, cameraIndex) {
    return null;
  };
  Camera2.prototype._updateRigCameras = function() {
    for (var i = 0; i < this._rigCameras.length; i++) {
      this._rigCameras[i].minZ = this.minZ;
      this._rigCameras[i].maxZ = this.maxZ;
      this._rigCameras[i].fov = this.fov;
      this._rigCameras[i].upVector.copyFrom(this.upVector);
    }
    if (this.cameraRigMode === Camera2.RIG_MODE_STEREOSCOPIC_ANAGLYPH) {
      this._rigCameras[0].viewport = this._rigCameras[1].viewport = this.viewport;
    }
  };
  Camera2.prototype._setupInputs = function() {
  };
  Camera2.prototype.serialize = function() {
    var serializationObject = SerializationHelper.Serialize(this);
    serializationObject.type = this.getClassName();
    if (this.parent) {
      serializationObject.parentId = this.parent.id;
    }
    if (this.inputs) {
      this.inputs.serialize(serializationObject);
    }
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    serializationObject.ranges = this.serializeAnimationRanges();
    return serializationObject;
  };
  Camera2.prototype.clone = function(name45) {
    return SerializationHelper.Clone(Camera2.GetConstructorFromName(this.getClassName(), name45, this.getScene(), this.interaxialDistance, this.isStereoscopicSideBySide), this);
  };
  Camera2.prototype.getDirection = function(localAxis) {
    var result = Vector3.Zero();
    this.getDirectionToRef(localAxis, result);
    return result;
  };
  Object.defineProperty(Camera2.prototype, "absoluteRotation", {
    get: function() {
      var result = Quaternion.Zero();
      this.getWorldMatrix().decompose(void 0, result);
      return result;
    },
    enumerable: false,
    configurable: true
  });
  Camera2.prototype.getDirectionToRef = function(localAxis, result) {
    Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);
  };
  Camera2.GetConstructorFromName = function(type, name45, scene, interaxial_distance, isStereoscopicSideBySide) {
    if (interaxial_distance === void 0) {
      interaxial_distance = 0;
    }
    if (isStereoscopicSideBySide === void 0) {
      isStereoscopicSideBySide = true;
    }
    var constructorFunc = Node.Construct(type, name45, scene, {
      interaxial_distance,
      isStereoscopicSideBySide
    });
    if (constructorFunc) {
      return constructorFunc;
    }
    return function() {
      return Camera2._createDefaultParsedCamera(name45, scene);
    };
  };
  Camera2.prototype.computeWorldMatrix = function() {
    return this.getWorldMatrix();
  };
  Camera2.Parse = function(parsedCamera, scene) {
    var type = parsedCamera.type;
    var construct = Camera2.GetConstructorFromName(type, parsedCamera.name, scene, parsedCamera.interaxial_distance, parsedCamera.isStereoscopicSideBySide);
    var camera = SerializationHelper.Parse(construct, parsedCamera, scene);
    if (parsedCamera.parentId) {
      camera._waitingParentId = parsedCamera.parentId;
    }
    if (camera.inputs) {
      camera.inputs.parse(parsedCamera);
      camera._setupInputs();
    }
    if (parsedCamera.upVector) {
      camera.upVector = Vector3.FromArray(parsedCamera.upVector);
    }
    if (camera.setPosition) {
      camera.position.copyFromFloats(0, 0, 0);
      camera.setPosition(Vector3.FromArray(parsedCamera.position));
    }
    if (parsedCamera.target) {
      if (camera.setTarget) {
        camera.setTarget(Vector3.FromArray(parsedCamera.target));
      }
    }
    if (parsedCamera.cameraRigMode) {
      var rigParams = parsedCamera.interaxial_distance ? { interaxialDistance: parsedCamera.interaxial_distance } : {};
      camera.setCameraRigMode(parsedCamera.cameraRigMode, rigParams);
    }
    if (parsedCamera.animations) {
      for (var animationIndex = 0; animationIndex < parsedCamera.animations.length; animationIndex++) {
        var parsedAnimation = parsedCamera.animations[animationIndex];
        var internalClass = _TypeStore.GetClass("BABYLON.Animation");
        if (internalClass) {
          camera.animations.push(internalClass.Parse(parsedAnimation));
        }
      }
      Node.ParseAnimationRanges(camera, parsedCamera, scene);
    }
    if (parsedCamera.autoAnimate) {
      scene.beginAnimation(camera, parsedCamera.autoAnimateFrom, parsedCamera.autoAnimateTo, parsedCamera.autoAnimateLoop, parsedCamera.autoAnimateSpeed || 1);
    }
    return camera;
  };
  Camera2._createDefaultParsedCamera = function(name45, scene) {
    throw _DevTools.WarnImport("UniversalCamera");
  };
  Camera2.PERSPECTIVE_CAMERA = 0;
  Camera2.ORTHOGRAPHIC_CAMERA = 1;
  Camera2.FOVMODE_VERTICAL_FIXED = 0;
  Camera2.FOVMODE_HORIZONTAL_FIXED = 1;
  Camera2.RIG_MODE_NONE = 0;
  Camera2.RIG_MODE_STEREOSCOPIC_ANAGLYPH = 10;
  Camera2.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = 11;
  Camera2.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = 12;
  Camera2.RIG_MODE_STEREOSCOPIC_OVERUNDER = 13;
  Camera2.RIG_MODE_STEREOSCOPIC_INTERLACED = 14;
  Camera2.RIG_MODE_VR = 20;
  Camera2.RIG_MODE_WEBVR = 21;
  Camera2.RIG_MODE_CUSTOM = 22;
  Camera2.ForceAttachControlToAlwaysPreventDefault = false;
  __decorate([
    serializeAsVector3("position")
  ], Camera2.prototype, "_position", void 0);
  __decorate([
    serializeAsVector3("upVector")
  ], Camera2.prototype, "_upVector", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "orthoLeft", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "orthoRight", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "orthoBottom", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "orthoTop", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "fov", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "minZ", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "maxZ", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "inertia", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "mode", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "layerMask", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "fovMode", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "cameraRigMode", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "interaxialDistance", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "isStereoscopicSideBySide", void 0);
  return Camera2;
}(Node);

// node_modules/@babylonjs/core/Materials/materialDefines.js
var MaterialDefines = function() {
  function MaterialDefines2() {
    this._isDirty = true;
    this._areLightsDirty = true;
    this._areLightsDisposed = false;
    this._areAttributesDirty = true;
    this._areTexturesDirty = true;
    this._areFresnelDirty = true;
    this._areMiscDirty = true;
    this._arePrePassDirty = true;
    this._areImageProcessingDirty = true;
    this._normals = false;
    this._uvs = false;
    this._needNormals = false;
    this._needUVs = false;
  }
  Object.defineProperty(MaterialDefines2.prototype, "isDirty", {
    get: function() {
      return this._isDirty;
    },
    enumerable: false,
    configurable: true
  });
  MaterialDefines2.prototype.markAsProcessed = function() {
    this._isDirty = false;
    this._areAttributesDirty = false;
    this._areTexturesDirty = false;
    this._areFresnelDirty = false;
    this._areLightsDirty = false;
    this._areLightsDisposed = false;
    this._areMiscDirty = false;
    this._arePrePassDirty = false;
    this._areImageProcessingDirty = false;
  };
  MaterialDefines2.prototype.markAsUnprocessed = function() {
    this._isDirty = true;
  };
  MaterialDefines2.prototype.markAllAsDirty = function() {
    this._areTexturesDirty = true;
    this._areAttributesDirty = true;
    this._areLightsDirty = true;
    this._areFresnelDirty = true;
    this._areMiscDirty = true;
    this._areImageProcessingDirty = true;
    this._isDirty = true;
  };
  MaterialDefines2.prototype.markAsImageProcessingDirty = function() {
    this._areImageProcessingDirty = true;
    this._isDirty = true;
  };
  MaterialDefines2.prototype.markAsLightDirty = function(disposed) {
    if (disposed === void 0) {
      disposed = false;
    }
    this._areLightsDirty = true;
    this._areLightsDisposed = this._areLightsDisposed || disposed;
    this._isDirty = true;
  };
  MaterialDefines2.prototype.markAsAttributesDirty = function() {
    this._areAttributesDirty = true;
    this._isDirty = true;
  };
  MaterialDefines2.prototype.markAsTexturesDirty = function() {
    this._areTexturesDirty = true;
    this._isDirty = true;
  };
  MaterialDefines2.prototype.markAsFresnelDirty = function() {
    this._areFresnelDirty = true;
    this._isDirty = true;
  };
  MaterialDefines2.prototype.markAsMiscDirty = function() {
    this._areMiscDirty = true;
    this._isDirty = true;
  };
  MaterialDefines2.prototype.markAsPrePassDirty = function() {
    this._arePrePassDirty = true;
    this._isDirty = true;
  };
  MaterialDefines2.prototype.rebuild = function() {
    this._keys = [];
    for (var _i = 0, _a = Object.keys(this); _i < _a.length; _i++) {
      var key = _a[_i];
      if (key[0] === "_") {
        continue;
      }
      this._keys.push(key);
    }
  };
  MaterialDefines2.prototype.isEqual = function(other) {
    if (this._keys.length !== other._keys.length) {
      return false;
    }
    for (var index = 0; index < this._keys.length; index++) {
      var prop = this._keys[index];
      if (this[prop] !== other[prop]) {
        return false;
      }
    }
    return true;
  };
  MaterialDefines2.prototype.cloneTo = function(other) {
    if (this._keys.length !== other._keys.length) {
      other._keys = this._keys.slice(0);
    }
    for (var index = 0; index < this._keys.length; index++) {
      var prop = this._keys[index];
      other[prop] = this[prop];
    }
  };
  MaterialDefines2.prototype.reset = function() {
    for (var index = 0; index < this._keys.length; index++) {
      var prop = this._keys[index];
      var type = typeof this[prop];
      switch (type) {
        case "number":
          this[prop] = 0;
          break;
        case "string":
          this[prop] = "";
          break;
        default:
          this[prop] = false;
          break;
      }
    }
  };
  MaterialDefines2.prototype.toString = function() {
    var result = "";
    for (var index = 0; index < this._keys.length; index++) {
      var prop = this._keys[index];
      var value = this[prop];
      var type = typeof value;
      switch (type) {
        case "number":
        case "string":
          result += "#define " + prop + " " + value + "\n";
          break;
        default:
          if (value) {
            result += "#define " + prop + "\n";
          }
          break;
      }
    }
    return result;
  };
  return MaterialDefines2;
}();

// node_modules/@babylonjs/core/Materials/colorCurves.js
var ColorCurves = function() {
  function ColorCurves2() {
    this._dirty = true;
    this._tempColor = new Color4(0, 0, 0, 0);
    this._globalCurve = new Color4(0, 0, 0, 0);
    this._highlightsCurve = new Color4(0, 0, 0, 0);
    this._midtonesCurve = new Color4(0, 0, 0, 0);
    this._shadowsCurve = new Color4(0, 0, 0, 0);
    this._positiveCurve = new Color4(0, 0, 0, 0);
    this._negativeCurve = new Color4(0, 0, 0, 0);
    this._globalHue = 30;
    this._globalDensity = 0;
    this._globalSaturation = 0;
    this._globalExposure = 0;
    this._highlightsHue = 30;
    this._highlightsDensity = 0;
    this._highlightsSaturation = 0;
    this._highlightsExposure = 0;
    this._midtonesHue = 30;
    this._midtonesDensity = 0;
    this._midtonesSaturation = 0;
    this._midtonesExposure = 0;
    this._shadowsHue = 30;
    this._shadowsDensity = 0;
    this._shadowsSaturation = 0;
    this._shadowsExposure = 0;
  }
  Object.defineProperty(ColorCurves2.prototype, "globalHue", {
    get: function() {
      return this._globalHue;
    },
    set: function(value) {
      this._globalHue = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "globalDensity", {
    get: function() {
      return this._globalDensity;
    },
    set: function(value) {
      this._globalDensity = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "globalSaturation", {
    get: function() {
      return this._globalSaturation;
    },
    set: function(value) {
      this._globalSaturation = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "globalExposure", {
    get: function() {
      return this._globalExposure;
    },
    set: function(value) {
      this._globalExposure = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "highlightsHue", {
    get: function() {
      return this._highlightsHue;
    },
    set: function(value) {
      this._highlightsHue = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "highlightsDensity", {
    get: function() {
      return this._highlightsDensity;
    },
    set: function(value) {
      this._highlightsDensity = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "highlightsSaturation", {
    get: function() {
      return this._highlightsSaturation;
    },
    set: function(value) {
      this._highlightsSaturation = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "highlightsExposure", {
    get: function() {
      return this._highlightsExposure;
    },
    set: function(value) {
      this._highlightsExposure = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "midtonesHue", {
    get: function() {
      return this._midtonesHue;
    },
    set: function(value) {
      this._midtonesHue = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "midtonesDensity", {
    get: function() {
      return this._midtonesDensity;
    },
    set: function(value) {
      this._midtonesDensity = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "midtonesSaturation", {
    get: function() {
      return this._midtonesSaturation;
    },
    set: function(value) {
      this._midtonesSaturation = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "midtonesExposure", {
    get: function() {
      return this._midtonesExposure;
    },
    set: function(value) {
      this._midtonesExposure = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "shadowsHue", {
    get: function() {
      return this._shadowsHue;
    },
    set: function(value) {
      this._shadowsHue = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "shadowsDensity", {
    get: function() {
      return this._shadowsDensity;
    },
    set: function(value) {
      this._shadowsDensity = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "shadowsSaturation", {
    get: function() {
      return this._shadowsSaturation;
    },
    set: function(value) {
      this._shadowsSaturation = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "shadowsExposure", {
    get: function() {
      return this._shadowsExposure;
    },
    set: function(value) {
      this._shadowsExposure = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  ColorCurves2.prototype.getClassName = function() {
    return "ColorCurves";
  };
  ColorCurves2.Bind = function(colorCurves, effect, positiveUniform, neutralUniform, negativeUniform) {
    if (positiveUniform === void 0) {
      positiveUniform = "vCameraColorCurvePositive";
    }
    if (neutralUniform === void 0) {
      neutralUniform = "vCameraColorCurveNeutral";
    }
    if (negativeUniform === void 0) {
      negativeUniform = "vCameraColorCurveNegative";
    }
    if (colorCurves._dirty) {
      colorCurves._dirty = false;
      colorCurves.getColorGradingDataToRef(colorCurves._globalHue, colorCurves._globalDensity, colorCurves._globalSaturation, colorCurves._globalExposure, colorCurves._globalCurve);
      colorCurves.getColorGradingDataToRef(colorCurves._highlightsHue, colorCurves._highlightsDensity, colorCurves._highlightsSaturation, colorCurves._highlightsExposure, colorCurves._tempColor);
      colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._highlightsCurve);
      colorCurves.getColorGradingDataToRef(colorCurves._midtonesHue, colorCurves._midtonesDensity, colorCurves._midtonesSaturation, colorCurves._midtonesExposure, colorCurves._tempColor);
      colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._midtonesCurve);
      colorCurves.getColorGradingDataToRef(colorCurves._shadowsHue, colorCurves._shadowsDensity, colorCurves._shadowsSaturation, colorCurves._shadowsExposure, colorCurves._tempColor);
      colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._shadowsCurve);
      colorCurves._highlightsCurve.subtractToRef(colorCurves._midtonesCurve, colorCurves._positiveCurve);
      colorCurves._midtonesCurve.subtractToRef(colorCurves._shadowsCurve, colorCurves._negativeCurve);
    }
    if (effect) {
      effect.setFloat4(positiveUniform, colorCurves._positiveCurve.r, colorCurves._positiveCurve.g, colorCurves._positiveCurve.b, colorCurves._positiveCurve.a);
      effect.setFloat4(neutralUniform, colorCurves._midtonesCurve.r, colorCurves._midtonesCurve.g, colorCurves._midtonesCurve.b, colorCurves._midtonesCurve.a);
      effect.setFloat4(negativeUniform, colorCurves._negativeCurve.r, colorCurves._negativeCurve.g, colorCurves._negativeCurve.b, colorCurves._negativeCurve.a);
    }
  };
  ColorCurves2.PrepareUniforms = function(uniformsList) {
    uniformsList.push("vCameraColorCurveNeutral", "vCameraColorCurvePositive", "vCameraColorCurveNegative");
  };
  ColorCurves2.prototype.getColorGradingDataToRef = function(hue, density, saturation, exposure, result) {
    if (hue == null) {
      return;
    }
    hue = ColorCurves2.clamp(hue, 0, 360);
    density = ColorCurves2.clamp(density, -100, 100);
    saturation = ColorCurves2.clamp(saturation, -100, 100);
    exposure = ColorCurves2.clamp(exposure, -100, 100);
    density = ColorCurves2.applyColorGradingSliderNonlinear(density);
    density *= 0.5;
    exposure = ColorCurves2.applyColorGradingSliderNonlinear(exposure);
    if (density < 0) {
      density *= -1;
      hue = (hue + 180) % 360;
    }
    ColorCurves2.fromHSBToRef(hue, density, 50 + 0.25 * exposure, result);
    result.scaleToRef(2, result);
    result.a = 1 + 0.01 * saturation;
  };
  ColorCurves2.applyColorGradingSliderNonlinear = function(value) {
    value /= 100;
    var x = Math.abs(value);
    x = Math.pow(x, 2);
    if (value < 0) {
      x *= -1;
    }
    x *= 100;
    return x;
  };
  ColorCurves2.fromHSBToRef = function(hue, saturation, brightness, result) {
    var h = ColorCurves2.clamp(hue, 0, 360);
    var s = ColorCurves2.clamp(saturation / 100, 0, 1);
    var v = ColorCurves2.clamp(brightness / 100, 0, 1);
    if (s === 0) {
      result.r = v;
      result.g = v;
      result.b = v;
    } else {
      h /= 60;
      var i = Math.floor(h);
      var f = h - i;
      var p = v * (1 - s);
      var q = v * (1 - s * f);
      var t = v * (1 - s * (1 - f));
      switch (i) {
        case 0:
          result.r = v;
          result.g = t;
          result.b = p;
          break;
        case 1:
          result.r = q;
          result.g = v;
          result.b = p;
          break;
        case 2:
          result.r = p;
          result.g = v;
          result.b = t;
          break;
        case 3:
          result.r = p;
          result.g = q;
          result.b = v;
          break;
        case 4:
          result.r = t;
          result.g = p;
          result.b = v;
          break;
        default:
          result.r = v;
          result.g = p;
          result.b = q;
          break;
      }
    }
    result.a = 1;
  };
  ColorCurves2.clamp = function(value, min, max) {
    return Math.min(Math.max(value, min), max);
  };
  ColorCurves2.prototype.clone = function() {
    return SerializationHelper.Clone(function() {
      return new ColorCurves2();
    }, this);
  };
  ColorCurves2.prototype.serialize = function() {
    return SerializationHelper.Serialize(this);
  };
  ColorCurves2.Parse = function(source) {
    return SerializationHelper.Parse(function() {
      return new ColorCurves2();
    }, source, null, null);
  };
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_globalHue", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_globalDensity", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_globalSaturation", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_globalExposure", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_highlightsHue", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_highlightsDensity", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_highlightsSaturation", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_highlightsExposure", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_midtonesHue", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_midtonesDensity", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_midtonesSaturation", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_midtonesExposure", void 0);
  return ColorCurves2;
}();
SerializationHelper._ColorCurvesParser = ColorCurves.Parse;

// node_modules/@babylonjs/core/Materials/imageProcessingConfiguration.js
var ImageProcessingConfigurationDefines = function(_super) {
  __extends(ImageProcessingConfigurationDefines2, _super);
  function ImageProcessingConfigurationDefines2() {
    var _this = _super.call(this) || this;
    _this.IMAGEPROCESSING = false;
    _this.VIGNETTE = false;
    _this.VIGNETTEBLENDMODEMULTIPLY = false;
    _this.VIGNETTEBLENDMODEOPAQUE = false;
    _this.TONEMAPPING = false;
    _this.TONEMAPPING_ACES = false;
    _this.CONTRAST = false;
    _this.COLORCURVES = false;
    _this.COLORGRADING = false;
    _this.COLORGRADING3D = false;
    _this.SAMPLER3DGREENDEPTH = false;
    _this.SAMPLER3DBGRMAP = false;
    _this.IMAGEPROCESSINGPOSTPROCESS = false;
    _this.EXPOSURE = false;
    _this.rebuild();
    return _this;
  }
  return ImageProcessingConfigurationDefines2;
}(MaterialDefines);
var ImageProcessingConfiguration = function() {
  function ImageProcessingConfiguration2() {
    this.colorCurves = new ColorCurves();
    this._colorCurvesEnabled = false;
    this._colorGradingEnabled = false;
    this._colorGradingWithGreenDepth = true;
    this._colorGradingBGR = true;
    this._exposure = 1;
    this._toneMappingEnabled = false;
    this._toneMappingType = ImageProcessingConfiguration2.TONEMAPPING_STANDARD;
    this._contrast = 1;
    this.vignetteStretch = 0;
    this.vignetteCentreX = 0;
    this.vignetteCentreY = 0;
    this.vignetteWeight = 1.5;
    this.vignetteColor = new Color4(0, 0, 0, 0);
    this.vignetteCameraFov = 0.5;
    this._vignetteBlendMode = ImageProcessingConfiguration2.VIGNETTEMODE_MULTIPLY;
    this._vignetteEnabled = false;
    this._applyByPostProcess = false;
    this._isEnabled = true;
    this.onUpdateParameters = new Observable();
  }
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "colorCurvesEnabled", {
    get: function() {
      return this._colorCurvesEnabled;
    },
    set: function(value) {
      if (this._colorCurvesEnabled === value) {
        return;
      }
      this._colorCurvesEnabled = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "colorGradingTexture", {
    get: function() {
      return this._colorGradingTexture;
    },
    set: function(value) {
      if (this._colorGradingTexture === value) {
        return;
      }
      this._colorGradingTexture = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "colorGradingEnabled", {
    get: function() {
      return this._colorGradingEnabled;
    },
    set: function(value) {
      if (this._colorGradingEnabled === value) {
        return;
      }
      this._colorGradingEnabled = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "colorGradingWithGreenDepth", {
    get: function() {
      return this._colorGradingWithGreenDepth;
    },
    set: function(value) {
      if (this._colorGradingWithGreenDepth === value) {
        return;
      }
      this._colorGradingWithGreenDepth = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "colorGradingBGR", {
    get: function() {
      return this._colorGradingBGR;
    },
    set: function(value) {
      if (this._colorGradingBGR === value) {
        return;
      }
      this._colorGradingBGR = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "exposure", {
    get: function() {
      return this._exposure;
    },
    set: function(value) {
      if (this._exposure === value) {
        return;
      }
      this._exposure = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "toneMappingEnabled", {
    get: function() {
      return this._toneMappingEnabled;
    },
    set: function(value) {
      if (this._toneMappingEnabled === value) {
        return;
      }
      this._toneMappingEnabled = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "toneMappingType", {
    get: function() {
      return this._toneMappingType;
    },
    set: function(value) {
      if (this._toneMappingType === value) {
        return;
      }
      this._toneMappingType = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "contrast", {
    get: function() {
      return this._contrast;
    },
    set: function(value) {
      if (this._contrast === value) {
        return;
      }
      this._contrast = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "vignetteBlendMode", {
    get: function() {
      return this._vignetteBlendMode;
    },
    set: function(value) {
      if (this._vignetteBlendMode === value) {
        return;
      }
      this._vignetteBlendMode = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "vignetteEnabled", {
    get: function() {
      return this._vignetteEnabled;
    },
    set: function(value) {
      if (this._vignetteEnabled === value) {
        return;
      }
      this._vignetteEnabled = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "applyByPostProcess", {
    get: function() {
      return this._applyByPostProcess;
    },
    set: function(value) {
      if (this._applyByPostProcess === value) {
        return;
      }
      this._applyByPostProcess = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "isEnabled", {
    get: function() {
      return this._isEnabled;
    },
    set: function(value) {
      if (this._isEnabled === value) {
        return;
      }
      this._isEnabled = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  ImageProcessingConfiguration2.prototype._updateParameters = function() {
    this.onUpdateParameters.notifyObservers(this);
  };
  ImageProcessingConfiguration2.prototype.getClassName = function() {
    return "ImageProcessingConfiguration";
  };
  ImageProcessingConfiguration2.PrepareUniforms = function(uniforms, defines) {
    if (defines.EXPOSURE) {
      uniforms.push("exposureLinear");
    }
    if (defines.CONTRAST) {
      uniforms.push("contrast");
    }
    if (defines.COLORGRADING) {
      uniforms.push("colorTransformSettings");
    }
    if (defines.VIGNETTE) {
      uniforms.push("vInverseScreenSize");
      uniforms.push("vignetteSettings1");
      uniforms.push("vignetteSettings2");
    }
    if (defines.COLORCURVES) {
      ColorCurves.PrepareUniforms(uniforms);
    }
  };
  ImageProcessingConfiguration2.PrepareSamplers = function(samplersList, defines) {
    if (defines.COLORGRADING) {
      samplersList.push("txColorTransform");
    }
  };
  ImageProcessingConfiguration2.prototype.prepareDefines = function(defines, forPostProcess) {
    if (forPostProcess === void 0) {
      forPostProcess = false;
    }
    if (forPostProcess !== this.applyByPostProcess || !this._isEnabled) {
      defines.VIGNETTE = false;
      defines.TONEMAPPING = false;
      defines.TONEMAPPING_ACES = false;
      defines.CONTRAST = false;
      defines.EXPOSURE = false;
      defines.COLORCURVES = false;
      defines.COLORGRADING = false;
      defines.COLORGRADING3D = false;
      defines.IMAGEPROCESSING = false;
      defines.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess && this._isEnabled;
      return;
    }
    defines.VIGNETTE = this.vignetteEnabled;
    defines.VIGNETTEBLENDMODEMULTIPLY = this.vignetteBlendMode === ImageProcessingConfiguration2._VIGNETTEMODE_MULTIPLY;
    defines.VIGNETTEBLENDMODEOPAQUE = !defines.VIGNETTEBLENDMODEMULTIPLY;
    defines.TONEMAPPING = this.toneMappingEnabled;
    switch (this._toneMappingType) {
      case ImageProcessingConfiguration2.TONEMAPPING_ACES:
        defines.TONEMAPPING_ACES = true;
        break;
      default:
        defines.TONEMAPPING_ACES = false;
        break;
    }
    defines.CONTRAST = this.contrast !== 1;
    defines.EXPOSURE = this.exposure !== 1;
    defines.COLORCURVES = this.colorCurvesEnabled && !!this.colorCurves;
    defines.COLORGRADING = this.colorGradingEnabled && !!this.colorGradingTexture;
    if (defines.COLORGRADING) {
      defines.COLORGRADING3D = this.colorGradingTexture.is3D;
    } else {
      defines.COLORGRADING3D = false;
    }
    defines.SAMPLER3DGREENDEPTH = this.colorGradingWithGreenDepth;
    defines.SAMPLER3DBGRMAP = this.colorGradingBGR;
    defines.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess;
    defines.IMAGEPROCESSING = defines.VIGNETTE || defines.TONEMAPPING || defines.CONTRAST || defines.EXPOSURE || defines.COLORCURVES || defines.COLORGRADING;
  };
  ImageProcessingConfiguration2.prototype.isReady = function() {
    return !this.colorGradingEnabled || !this.colorGradingTexture || this.colorGradingTexture.isReady();
  };
  ImageProcessingConfiguration2.prototype.bind = function(effect, overrideAspectRatio) {
    if (this._colorCurvesEnabled && this.colorCurves) {
      ColorCurves.Bind(this.colorCurves, effect);
    }
    if (this._vignetteEnabled) {
      var inverseWidth = 1 / effect.getEngine().getRenderWidth();
      var inverseHeight = 1 / effect.getEngine().getRenderHeight();
      effect.setFloat2("vInverseScreenSize", inverseWidth, inverseHeight);
      var aspectRatio = overrideAspectRatio != null ? overrideAspectRatio : inverseHeight / inverseWidth;
      var vignetteScaleY = Math.tan(this.vignetteCameraFov * 0.5);
      var vignetteScaleX = vignetteScaleY * aspectRatio;
      var vignetteScaleGeometricMean = Math.sqrt(vignetteScaleX * vignetteScaleY);
      vignetteScaleX = Tools.Mix(vignetteScaleX, vignetteScaleGeometricMean, this.vignetteStretch);
      vignetteScaleY = Tools.Mix(vignetteScaleY, vignetteScaleGeometricMean, this.vignetteStretch);
      effect.setFloat4("vignetteSettings1", vignetteScaleX, vignetteScaleY, -vignetteScaleX * this.vignetteCentreX, -vignetteScaleY * this.vignetteCentreY);
      var vignettePower = -2 * this.vignetteWeight;
      effect.setFloat4("vignetteSettings2", this.vignetteColor.r, this.vignetteColor.g, this.vignetteColor.b, vignettePower);
    }
    effect.setFloat("exposureLinear", this.exposure);
    effect.setFloat("contrast", this.contrast);
    if (this.colorGradingTexture) {
      effect.setTexture("txColorTransform", this.colorGradingTexture);
      var textureSize = this.colorGradingTexture.getSize().height;
      effect.setFloat4("colorTransformSettings", (textureSize - 1) / textureSize, 0.5 / textureSize, textureSize, this.colorGradingTexture.level);
    }
  };
  ImageProcessingConfiguration2.prototype.clone = function() {
    return SerializationHelper.Clone(function() {
      return new ImageProcessingConfiguration2();
    }, this);
  };
  ImageProcessingConfiguration2.prototype.serialize = function() {
    return SerializationHelper.Serialize(this);
  };
  ImageProcessingConfiguration2.Parse = function(source) {
    return SerializationHelper.Parse(function() {
      return new ImageProcessingConfiguration2();
    }, source, null, null);
  };
  Object.defineProperty(ImageProcessingConfiguration2, "VIGNETTEMODE_MULTIPLY", {
    get: function() {
      return this._VIGNETTEMODE_MULTIPLY;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2, "VIGNETTEMODE_OPAQUE", {
    get: function() {
      return this._VIGNETTEMODE_OPAQUE;
    },
    enumerable: false,
    configurable: true
  });
  ImageProcessingConfiguration2.TONEMAPPING_STANDARD = 0;
  ImageProcessingConfiguration2.TONEMAPPING_ACES = 1;
  ImageProcessingConfiguration2._VIGNETTEMODE_MULTIPLY = 0;
  ImageProcessingConfiguration2._VIGNETTEMODE_OPAQUE = 1;
  __decorate([
    serializeAsColorCurves()
  ], ImageProcessingConfiguration2.prototype, "colorCurves", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_colorCurvesEnabled", void 0);
  __decorate([
    serializeAsTexture("colorGradingTexture")
  ], ImageProcessingConfiguration2.prototype, "_colorGradingTexture", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_colorGradingEnabled", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_colorGradingWithGreenDepth", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_colorGradingBGR", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_exposure", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_toneMappingEnabled", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_toneMappingType", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_contrast", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "vignetteStretch", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "vignetteCentreX", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "vignetteCentreY", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "vignetteWeight", void 0);
  __decorate([
    serializeAsColor4()
  ], ImageProcessingConfiguration2.prototype, "vignetteColor", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "vignetteCameraFov", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_vignetteBlendMode", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_vignetteEnabled", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_applyByPostProcess", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_isEnabled", void 0);
  return ImageProcessingConfiguration2;
}();
SerializationHelper._ImageProcessingConfigurationParser = ImageProcessingConfiguration.Parse;

// node_modules/@babylonjs/core/Engines/Extensions/engine.uniformBuffer.js
ThinEngine.prototype.createUniformBuffer = function(elements) {
  var ubo = this._gl.createBuffer();
  if (!ubo) {
    throw new Error("Unable to create uniform buffer");
  }
  var result = new WebGLDataBuffer(ubo);
  this.bindUniformBuffer(result);
  if (elements instanceof Float32Array) {
    this._gl.bufferData(this._gl.UNIFORM_BUFFER, elements, this._gl.STATIC_DRAW);
  } else {
    this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(elements), this._gl.STATIC_DRAW);
  }
  this.bindUniformBuffer(null);
  result.references = 1;
  return result;
};
ThinEngine.prototype.createDynamicUniformBuffer = function(elements) {
  var ubo = this._gl.createBuffer();
  if (!ubo) {
    throw new Error("Unable to create dynamic uniform buffer");
  }
  var result = new WebGLDataBuffer(ubo);
  this.bindUniformBuffer(result);
  if (elements instanceof Float32Array) {
    this._gl.bufferData(this._gl.UNIFORM_BUFFER, elements, this._gl.DYNAMIC_DRAW);
  } else {
    this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(elements), this._gl.DYNAMIC_DRAW);
  }
  this.bindUniformBuffer(null);
  result.references = 1;
  return result;
};
ThinEngine.prototype.updateUniformBuffer = function(uniformBuffer, elements, offset, count) {
  this.bindUniformBuffer(uniformBuffer);
  if (offset === void 0) {
    offset = 0;
  }
  if (count === void 0) {
    if (elements instanceof Float32Array) {
      this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, offset, elements);
    } else {
      this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, offset, new Float32Array(elements));
    }
  } else {
    if (elements instanceof Float32Array) {
      this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, elements.subarray(offset, offset + count));
    } else {
      this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, new Float32Array(elements).subarray(offset, offset + count));
    }
  }
  this.bindUniformBuffer(null);
};
ThinEngine.prototype.bindUniformBuffer = function(buffer) {
  this._gl.bindBuffer(this._gl.UNIFORM_BUFFER, buffer ? buffer.underlyingResource : null);
};
ThinEngine.prototype.bindUniformBufferBase = function(buffer, location2) {
  this._gl.bindBufferBase(this._gl.UNIFORM_BUFFER, location2, buffer ? buffer.underlyingResource : null);
};
ThinEngine.prototype.bindUniformBlock = function(pipelineContext, blockName, index) {
  var program = pipelineContext.program;
  var uniformLocation = this._gl.getUniformBlockIndex(program, blockName);
  this._gl.uniformBlockBinding(program, uniformLocation, index);
};

// node_modules/@babylonjs/core/Materials/uniformBuffer.js
var UniformBuffer = function() {
  function UniformBuffer2(engine, data, dynamic) {
    this._alreadyBound = false;
    this._valueCache = {};
    this._engine = engine;
    this._noUBO = !engine.supportsUniformBuffers;
    this._dynamic = dynamic;
    this._data = data || [];
    this._uniformLocations = {};
    this._uniformSizes = {};
    this._uniformLocationPointer = 0;
    this._needSync = false;
    if (this._noUBO) {
      this.updateMatrix3x3 = this._updateMatrix3x3ForEffect;
      this.updateMatrix2x2 = this._updateMatrix2x2ForEffect;
      this.updateFloat = this._updateFloatForEffect;
      this.updateFloat2 = this._updateFloat2ForEffect;
      this.updateFloat3 = this._updateFloat3ForEffect;
      this.updateFloat4 = this._updateFloat4ForEffect;
      this.updateMatrix = this._updateMatrixForEffect;
      this.updateVector3 = this._updateVector3ForEffect;
      this.updateVector4 = this._updateVector4ForEffect;
      this.updateColor3 = this._updateColor3ForEffect;
      this.updateColor4 = this._updateColor4ForEffect;
    } else {
      this._engine._uniformBuffers.push(this);
      this.updateMatrix3x3 = this._updateMatrix3x3ForUniform;
      this.updateMatrix2x2 = this._updateMatrix2x2ForUniform;
      this.updateFloat = this._updateFloatForUniform;
      this.updateFloat2 = this._updateFloat2ForUniform;
      this.updateFloat3 = this._updateFloat3ForUniform;
      this.updateFloat4 = this._updateFloat4ForUniform;
      this.updateMatrix = this._updateMatrixForUniform;
      this.updateVector3 = this._updateVector3ForUniform;
      this.updateVector4 = this._updateVector4ForUniform;
      this.updateColor3 = this._updateColor3ForUniform;
      this.updateColor4 = this._updateColor4ForUniform;
    }
  }
  Object.defineProperty(UniformBuffer2.prototype, "useUbo", {
    get: function() {
      return !this._noUBO;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(UniformBuffer2.prototype, "isSync", {
    get: function() {
      return !this._needSync;
    },
    enumerable: false,
    configurable: true
  });
  UniformBuffer2.prototype.isDynamic = function() {
    return this._dynamic !== void 0;
  };
  UniformBuffer2.prototype.getData = function() {
    return this._bufferData;
  };
  UniformBuffer2.prototype.getBuffer = function() {
    return this._buffer;
  };
  UniformBuffer2.prototype._fillAlignment = function(size) {
    var alignment;
    if (size <= 2) {
      alignment = size;
    } else {
      alignment = 4;
    }
    if (this._uniformLocationPointer % alignment !== 0) {
      var oldPointer = this._uniformLocationPointer;
      this._uniformLocationPointer += alignment - this._uniformLocationPointer % alignment;
      var diff = this._uniformLocationPointer - oldPointer;
      for (var i = 0; i < diff; i++) {
        this._data.push(0);
      }
    }
  };
  UniformBuffer2.prototype.addUniform = function(name45, size) {
    if (this._noUBO) {
      return;
    }
    if (this._uniformLocations[name45] !== void 0) {
      return;
    }
    var data;
    if (size instanceof Array) {
      data = size;
      size = data.length;
    } else {
      size = size;
      data = [];
      for (var i = 0; i < size; i++) {
        data.push(0);
      }
    }
    this._fillAlignment(size);
    this._uniformSizes[name45] = size;
    this._uniformLocations[name45] = this._uniformLocationPointer;
    this._uniformLocationPointer += size;
    for (var i = 0; i < size; i++) {
      this._data.push(data[i]);
    }
    this._needSync = true;
  };
  UniformBuffer2.prototype.addMatrix = function(name45, mat) {
    this.addUniform(name45, Array.prototype.slice.call(mat.toArray()));
  };
  UniformBuffer2.prototype.addFloat2 = function(name45, x, y) {
    var temp = [x, y];
    this.addUniform(name45, temp);
  };
  UniformBuffer2.prototype.addFloat3 = function(name45, x, y, z) {
    var temp = [x, y, z];
    this.addUniform(name45, temp);
  };
  UniformBuffer2.prototype.addColor3 = function(name45, color) {
    var temp = new Array();
    color.toArray(temp);
    this.addUniform(name45, temp);
  };
  UniformBuffer2.prototype.addColor4 = function(name45, color, alpha) {
    var temp = new Array();
    color.toArray(temp);
    temp.push(alpha);
    this.addUniform(name45, temp);
  };
  UniformBuffer2.prototype.addVector3 = function(name45, vector) {
    var temp = new Array();
    vector.toArray(temp);
    this.addUniform(name45, temp);
  };
  UniformBuffer2.prototype.addMatrix3x3 = function(name45) {
    this.addUniform(name45, 12);
  };
  UniformBuffer2.prototype.addMatrix2x2 = function(name45) {
    this.addUniform(name45, 8);
  };
  UniformBuffer2.prototype.create = function() {
    if (this._noUBO) {
      return;
    }
    if (this._buffer) {
      return;
    }
    this._fillAlignment(4);
    this._bufferData = new Float32Array(this._data);
    this._rebuild();
    this._needSync = true;
  };
  UniformBuffer2.prototype._rebuild = function() {
    if (this._noUBO || !this._bufferData) {
      return;
    }
    if (this._dynamic) {
      this._buffer = this._engine.createDynamicUniformBuffer(this._bufferData);
    } else {
      this._buffer = this._engine.createUniformBuffer(this._bufferData);
    }
  };
  UniformBuffer2.prototype.update = function() {
    if (!this._buffer) {
      this.create();
      return;
    }
    if (!this._dynamic && !this._needSync) {
      return;
    }
    this._engine.updateUniformBuffer(this._buffer, this._bufferData);
    this._needSync = false;
  };
  UniformBuffer2.prototype.updateUniform = function(uniformName, data, size) {
    var location2 = this._uniformLocations[uniformName];
    if (location2 === void 0) {
      if (this._buffer) {
        Logger.Error("Cannot add an uniform after UBO has been created.");
        return;
      }
      this.addUniform(uniformName, size);
      location2 = this._uniformLocations[uniformName];
    }
    if (!this._buffer) {
      this.create();
    }
    if (!this._dynamic) {
      var changed = false;
      for (var i = 0; i < size; i++) {
        if (size === 16 || this._bufferData[location2 + i] !== data[i]) {
          changed = true;
          this._bufferData[location2 + i] = data[i];
        }
      }
      this._needSync = this._needSync || changed;
    } else {
      for (var i = 0; i < size; i++) {
        this._bufferData[location2 + i] = data[i];
      }
    }
  };
  UniformBuffer2.prototype._cacheMatrix = function(name45, matrix) {
    var cache = this._valueCache[name45];
    var flag = matrix.updateFlag;
    if (cache !== void 0 && cache === flag) {
      return false;
    }
    this._valueCache[name45] = flag;
    return true;
  };
  UniformBuffer2.prototype._updateMatrix3x3ForUniform = function(name45, matrix) {
    for (var i = 0; i < 3; i++) {
      UniformBuffer2._tempBuffer[i * 4] = matrix[i * 3];
      UniformBuffer2._tempBuffer[i * 4 + 1] = matrix[i * 3 + 1];
      UniformBuffer2._tempBuffer[i * 4 + 2] = matrix[i * 3 + 2];
      UniformBuffer2._tempBuffer[i * 4 + 3] = 0;
    }
    this.updateUniform(name45, UniformBuffer2._tempBuffer, 12);
  };
  UniformBuffer2.prototype._updateMatrix3x3ForEffect = function(name45, matrix) {
    this._currentEffect.setMatrix3x3(name45, matrix);
  };
  UniformBuffer2.prototype._updateMatrix2x2ForEffect = function(name45, matrix) {
    this._currentEffect.setMatrix2x2(name45, matrix);
  };
  UniformBuffer2.prototype._updateMatrix2x2ForUniform = function(name45, matrix) {
    for (var i = 0; i < 2; i++) {
      UniformBuffer2._tempBuffer[i * 4] = matrix[i * 2];
      UniformBuffer2._tempBuffer[i * 4 + 1] = matrix[i * 2 + 1];
      UniformBuffer2._tempBuffer[i * 4 + 2] = 0;
      UniformBuffer2._tempBuffer[i * 4 + 3] = 0;
    }
    this.updateUniform(name45, UniformBuffer2._tempBuffer, 8);
  };
  UniformBuffer2.prototype._updateFloatForEffect = function(name45, x) {
    this._currentEffect.setFloat(name45, x);
  };
  UniformBuffer2.prototype._updateFloatForUniform = function(name45, x) {
    UniformBuffer2._tempBuffer[0] = x;
    this.updateUniform(name45, UniformBuffer2._tempBuffer, 1);
  };
  UniformBuffer2.prototype._updateFloat2ForEffect = function(name45, x, y, suffix) {
    if (suffix === void 0) {
      suffix = "";
    }
    this._currentEffect.setFloat2(name45 + suffix, x, y);
  };
  UniformBuffer2.prototype._updateFloat2ForUniform = function(name45, x, y) {
    UniformBuffer2._tempBuffer[0] = x;
    UniformBuffer2._tempBuffer[1] = y;
    this.updateUniform(name45, UniformBuffer2._tempBuffer, 2);
  };
  UniformBuffer2.prototype._updateFloat3ForEffect = function(name45, x, y, z, suffix) {
    if (suffix === void 0) {
      suffix = "";
    }
    this._currentEffect.setFloat3(name45 + suffix, x, y, z);
  };
  UniformBuffer2.prototype._updateFloat3ForUniform = function(name45, x, y, z) {
    UniformBuffer2._tempBuffer[0] = x;
    UniformBuffer2._tempBuffer[1] = y;
    UniformBuffer2._tempBuffer[2] = z;
    this.updateUniform(name45, UniformBuffer2._tempBuffer, 3);
  };
  UniformBuffer2.prototype._updateFloat4ForEffect = function(name45, x, y, z, w, suffix) {
    if (suffix === void 0) {
      suffix = "";
    }
    this._currentEffect.setFloat4(name45 + suffix, x, y, z, w);
  };
  UniformBuffer2.prototype._updateFloat4ForUniform = function(name45, x, y, z, w) {
    UniformBuffer2._tempBuffer[0] = x;
    UniformBuffer2._tempBuffer[1] = y;
    UniformBuffer2._tempBuffer[2] = z;
    UniformBuffer2._tempBuffer[3] = w;
    this.updateUniform(name45, UniformBuffer2._tempBuffer, 4);
  };
  UniformBuffer2.prototype._updateMatrixForEffect = function(name45, mat) {
    this._currentEffect.setMatrix(name45, mat);
  };
  UniformBuffer2.prototype._updateMatrixForUniform = function(name45, mat) {
    if (this._cacheMatrix(name45, mat)) {
      this.updateUniform(name45, mat.toArray(), 16);
    }
  };
  UniformBuffer2.prototype._updateVector3ForEffect = function(name45, vector) {
    this._currentEffect.setVector3(name45, vector);
  };
  UniformBuffer2.prototype._updateVector3ForUniform = function(name45, vector) {
    vector.toArray(UniformBuffer2._tempBuffer);
    this.updateUniform(name45, UniformBuffer2._tempBuffer, 3);
  };
  UniformBuffer2.prototype._updateVector4ForEffect = function(name45, vector) {
    this._currentEffect.setVector4(name45, vector);
  };
  UniformBuffer2.prototype._updateVector4ForUniform = function(name45, vector) {
    vector.toArray(UniformBuffer2._tempBuffer);
    this.updateUniform(name45, UniformBuffer2._tempBuffer, 4);
  };
  UniformBuffer2.prototype._updateColor3ForEffect = function(name45, color, suffix) {
    if (suffix === void 0) {
      suffix = "";
    }
    this._currentEffect.setColor3(name45 + suffix, color);
  };
  UniformBuffer2.prototype._updateColor3ForUniform = function(name45, color) {
    color.toArray(UniformBuffer2._tempBuffer);
    this.updateUniform(name45, UniformBuffer2._tempBuffer, 3);
  };
  UniformBuffer2.prototype._updateColor4ForEffect = function(name45, color, alpha, suffix) {
    if (suffix === void 0) {
      suffix = "";
    }
    this._currentEffect.setColor4(name45 + suffix, color, alpha);
  };
  UniformBuffer2.prototype._updateColor4ForUniform = function(name45, color, alpha) {
    color.toArray(UniformBuffer2._tempBuffer);
    UniformBuffer2._tempBuffer[3] = alpha;
    this.updateUniform(name45, UniformBuffer2._tempBuffer, 4);
  };
  UniformBuffer2.prototype.setTexture = function(name45, texture) {
    this._currentEffect.setTexture(name45, texture);
  };
  UniformBuffer2.prototype.updateUniformDirectly = function(uniformName, data) {
    this.updateUniform(uniformName, data, data.length);
    this.update();
  };
  UniformBuffer2.prototype.bindToEffect = function(effect, name45) {
    this._currentEffect = effect;
    if (this._noUBO || !this._buffer) {
      return;
    }
    this._alreadyBound = true;
    effect.bindUniformBuffer(this._buffer, name45);
  };
  UniformBuffer2.prototype.dispose = function() {
    if (this._noUBO) {
      return;
    }
    var uniformBuffers = this._engine._uniformBuffers;
    var index = uniformBuffers.indexOf(this);
    if (index !== -1) {
      uniformBuffers[index] = uniformBuffers[uniformBuffers.length - 1];
      uniformBuffers.pop();
    }
    if (!this._buffer) {
      return;
    }
    if (this._engine._releaseBuffer(this._buffer)) {
      this._buffer = null;
    }
  };
  UniformBuffer2._MAX_UNIFORM_SIZE = 256;
  UniformBuffer2._tempBuffer = new Float32Array(UniformBuffer2._MAX_UNIFORM_SIZE);
  return UniformBuffer2;
}();

// node_modules/@babylonjs/core/Lights/light.js
var Light = function(_super) {
  __extends(Light2, _super);
  function Light2(name45, scene) {
    var _this = _super.call(this, name45, scene) || this;
    _this.diffuse = new Color3(1, 1, 1);
    _this.specular = new Color3(1, 1, 1);
    _this.falloffType = Light2.FALLOFF_DEFAULT;
    _this.intensity = 1;
    _this._range = Number.MAX_VALUE;
    _this._inverseSquaredRange = 0;
    _this._photometricScale = 1;
    _this._intensityMode = Light2.INTENSITYMODE_AUTOMATIC;
    _this._radius = 1e-5;
    _this.renderPriority = 0;
    _this._shadowEnabled = true;
    _this._excludeWithLayerMask = 0;
    _this._includeOnlyWithLayerMask = 0;
    _this._lightmapMode = 0;
    _this._excludedMeshesIds = new Array();
    _this._includedOnlyMeshesIds = new Array();
    _this._isLight = true;
    _this.getScene().addLight(_this);
    _this._uniformBuffer = new UniformBuffer(_this.getScene().getEngine());
    _this._buildUniformLayout();
    _this.includedOnlyMeshes = new Array();
    _this.excludedMeshes = new Array();
    _this._resyncMeshes();
    return _this;
  }
  Object.defineProperty(Light2.prototype, "range", {
    get: function() {
      return this._range;
    },
    set: function(value) {
      this._range = value;
      this._inverseSquaredRange = 1 / (this.range * this.range);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Light2.prototype, "intensityMode", {
    get: function() {
      return this._intensityMode;
    },
    set: function(value) {
      this._intensityMode = value;
      this._computePhotometricScale();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Light2.prototype, "radius", {
    get: function() {
      return this._radius;
    },
    set: function(value) {
      this._radius = value;
      this._computePhotometricScale();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Light2.prototype, "shadowEnabled", {
    get: function() {
      return this._shadowEnabled;
    },
    set: function(value) {
      if (this._shadowEnabled === value) {
        return;
      }
      this._shadowEnabled = value;
      this._markMeshesAsLightDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Light2.prototype, "includedOnlyMeshes", {
    get: function() {
      return this._includedOnlyMeshes;
    },
    set: function(value) {
      this._includedOnlyMeshes = value;
      this._hookArrayForIncludedOnly(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Light2.prototype, "excludedMeshes", {
    get: function() {
      return this._excludedMeshes;
    },
    set: function(value) {
      this._excludedMeshes = value;
      this._hookArrayForExcluded(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Light2.prototype, "excludeWithLayerMask", {
    get: function() {
      return this._excludeWithLayerMask;
    },
    set: function(value) {
      this._excludeWithLayerMask = value;
      this._resyncMeshes();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Light2.prototype, "includeOnlyWithLayerMask", {
    get: function() {
      return this._includeOnlyWithLayerMask;
    },
    set: function(value) {
      this._includeOnlyWithLayerMask = value;
      this._resyncMeshes();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Light2.prototype, "lightmapMode", {
    get: function() {
      return this._lightmapMode;
    },
    set: function(value) {
      if (this._lightmapMode === value) {
        return;
      }
      this._lightmapMode = value;
      this._markMeshesAsLightDirty();
    },
    enumerable: false,
    configurable: true
  });
  Light2.prototype.transferTexturesToEffect = function(effect, lightIndex) {
    return this;
  };
  Light2.prototype._bindLight = function(lightIndex, scene, effect, useSpecular, rebuildInParallel) {
    if (rebuildInParallel === void 0) {
      rebuildInParallel = false;
    }
    var iAsString = lightIndex.toString();
    var needUpdate = false;
    if (rebuildInParallel && this._uniformBuffer._alreadyBound) {
      return;
    }
    this._uniformBuffer.bindToEffect(effect, "Light" + iAsString);
    if (this._renderId !== scene.getRenderId() || !this._uniformBuffer.useUbo) {
      this._renderId = scene.getRenderId();
      var scaledIntensity = this.getScaledIntensity();
      this.transferToEffect(effect, iAsString);
      this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);
      this._uniformBuffer.updateColor4("vLightDiffuse", TmpColors.Color3[0], this.range, iAsString);
      if (useSpecular) {
        this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);
        this._uniformBuffer.updateColor4("vLightSpecular", TmpColors.Color3[1], this.radius, iAsString);
      }
      needUpdate = true;
    }
    this.transferTexturesToEffect(effect, iAsString);
    if (scene.shadowsEnabled && this.shadowEnabled) {
      var shadowGenerator = this.getShadowGenerator();
      if (shadowGenerator) {
        shadowGenerator.bindShadowLight(iAsString, effect);
        needUpdate = true;
      }
    }
    if (needUpdate) {
      this._uniformBuffer.update();
    }
  };
  Light2.prototype.getClassName = function() {
    return "Light";
  };
  Light2.prototype.toString = function(fullDetails) {
    var ret = "Name: " + this.name;
    ret += ", type: " + ["Point", "Directional", "Spot", "Hemispheric"][this.getTypeID()];
    if (this.animations) {
      for (var i = 0; i < this.animations.length; i++) {
        ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
      }
    }
    if (fullDetails) {
    }
    return ret;
  };
  Light2.prototype._syncParentEnabledState = function() {
    _super.prototype._syncParentEnabledState.call(this);
    if (!this.isDisposed()) {
      this._resyncMeshes();
    }
  };
  Light2.prototype.setEnabled = function(value) {
    _super.prototype.setEnabled.call(this, value);
    this._resyncMeshes();
  };
  Light2.prototype.getShadowGenerator = function() {
    return this._shadowGenerator;
  };
  Light2.prototype.getAbsolutePosition = function() {
    return Vector3.Zero();
  };
  Light2.prototype.canAffectMesh = function(mesh) {
    if (!mesh) {
      return true;
    }
    if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {
      return false;
    }
    if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {
      return false;
    }
    if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {
      return false;
    }
    if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {
      return false;
    }
    return true;
  };
  Light2.CompareLightsPriority = function(a, b) {
    if (a.shadowEnabled !== b.shadowEnabled) {
      return (b.shadowEnabled ? 1 : 0) - (a.shadowEnabled ? 1 : 0);
    }
    return b.renderPriority - a.renderPriority;
  };
  Light2.prototype.dispose = function(doNotRecurse, disposeMaterialAndTextures) {
    if (disposeMaterialAndTextures === void 0) {
      disposeMaterialAndTextures = false;
    }
    if (this._shadowGenerator) {
      this._shadowGenerator.dispose();
      this._shadowGenerator = null;
    }
    this.getScene().stopAnimation(this);
    for (var _i = 0, _a = this.getScene().meshes; _i < _a.length; _i++) {
      var mesh = _a[_i];
      mesh._removeLightSource(this, true);
    }
    this._uniformBuffer.dispose();
    this.getScene().removeLight(this);
    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);
  };
  Light2.prototype.getTypeID = function() {
    return 0;
  };
  Light2.prototype.getScaledIntensity = function() {
    return this._photometricScale * this.intensity;
  };
  Light2.prototype.clone = function(name45, newParent) {
    if (newParent === void 0) {
      newParent = null;
    }
    var constructor = Light2.GetConstructorFromName(this.getTypeID(), name45, this.getScene());
    if (!constructor) {
      return null;
    }
    var clonedLight = SerializationHelper.Clone(constructor, this);
    if (newParent) {
      clonedLight.parent = newParent;
    }
    clonedLight.setEnabled(this.isEnabled());
    return clonedLight;
  };
  Light2.prototype.serialize = function() {
    var serializationObject = SerializationHelper.Serialize(this);
    serializationObject.type = this.getTypeID();
    if (this.parent) {
      serializationObject.parentId = this.parent.id;
    }
    if (this.excludedMeshes.length > 0) {
      serializationObject.excludedMeshesIds = [];
      this.excludedMeshes.forEach(function(mesh) {
        serializationObject.excludedMeshesIds.push(mesh.id);
      });
    }
    if (this.includedOnlyMeshes.length > 0) {
      serializationObject.includedOnlyMeshesIds = [];
      this.includedOnlyMeshes.forEach(function(mesh) {
        serializationObject.includedOnlyMeshesIds.push(mesh.id);
      });
    }
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    serializationObject.ranges = this.serializeAnimationRanges();
    return serializationObject;
  };
  Light2.GetConstructorFromName = function(type, name45, scene) {
    var constructorFunc = Node.Construct("Light_Type_" + type, name45, scene);
    if (constructorFunc) {
      return constructorFunc;
    }
    return null;
  };
  Light2.Parse = function(parsedLight, scene) {
    var constructor = Light2.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);
    if (!constructor) {
      return null;
    }
    var light = SerializationHelper.Parse(constructor, parsedLight, scene);
    if (parsedLight.excludedMeshesIds) {
      light._excludedMeshesIds = parsedLight.excludedMeshesIds;
    }
    if (parsedLight.includedOnlyMeshesIds) {
      light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;
    }
    if (parsedLight.parentId) {
      light._waitingParentId = parsedLight.parentId;
    }
    if (parsedLight.falloffType !== void 0) {
      light.falloffType = parsedLight.falloffType;
    }
    if (parsedLight.lightmapMode !== void 0) {
      light.lightmapMode = parsedLight.lightmapMode;
    }
    if (parsedLight.animations) {
      for (var animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {
        var parsedAnimation = parsedLight.animations[animationIndex];
        var internalClass = _TypeStore.GetClass("BABYLON.Animation");
        if (internalClass) {
          light.animations.push(internalClass.Parse(parsedAnimation));
        }
      }
      Node.ParseAnimationRanges(light, parsedLight, scene);
    }
    if (parsedLight.autoAnimate) {
      scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1);
    }
    return light;
  };
  Light2.prototype._hookArrayForExcluded = function(array) {
    var _this = this;
    var oldPush = array.push;
    array.push = function() {
      var items = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        items[_i2] = arguments[_i2];
      }
      var result = oldPush.apply(array, items);
      for (var _a = 0, items_1 = items; _a < items_1.length; _a++) {
        var item2 = items_1[_a];
        item2._resyncLightSource(_this);
      }
      return result;
    };
    var oldSplice = array.splice;
    array.splice = function(index, deleteCount) {
      var deleted = oldSplice.apply(array, [index, deleteCount]);
      for (var _i2 = 0, deleted_1 = deleted; _i2 < deleted_1.length; _i2++) {
        var item2 = deleted_1[_i2];
        item2._resyncLightSource(_this);
      }
      return deleted;
    };
    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
      var item = array_1[_i];
      item._resyncLightSource(this);
    }
  };
  Light2.prototype._hookArrayForIncludedOnly = function(array) {
    var _this = this;
    var oldPush = array.push;
    array.push = function() {
      var items = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        items[_i] = arguments[_i];
      }
      var result = oldPush.apply(array, items);
      _this._resyncMeshes();
      return result;
    };
    var oldSplice = array.splice;
    array.splice = function(index, deleteCount) {
      var deleted = oldSplice.apply(array, [index, deleteCount]);
      _this._resyncMeshes();
      return deleted;
    };
    this._resyncMeshes();
  };
  Light2.prototype._resyncMeshes = function() {
    for (var _i = 0, _a = this.getScene().meshes; _i < _a.length; _i++) {
      var mesh = _a[_i];
      mesh._resyncLightSource(this);
    }
  };
  Light2.prototype._markMeshesAsLightDirty = function() {
    for (var _i = 0, _a = this.getScene().meshes; _i < _a.length; _i++) {
      var mesh = _a[_i];
      if (mesh.lightSources.indexOf(this) !== -1) {
        mesh._markSubMeshesAsLightDirty();
      }
    }
  };
  Light2.prototype._computePhotometricScale = function() {
    this._photometricScale = this._getPhotometricScale();
    this.getScene().resetCachedMaterial();
  };
  Light2.prototype._getPhotometricScale = function() {
    var photometricScale = 0;
    var lightTypeID = this.getTypeID();
    var photometricMode = this.intensityMode;
    if (photometricMode === Light2.INTENSITYMODE_AUTOMATIC) {
      if (lightTypeID === Light2.LIGHTTYPEID_DIRECTIONALLIGHT) {
        photometricMode = Light2.INTENSITYMODE_ILLUMINANCE;
      } else {
        photometricMode = Light2.INTENSITYMODE_LUMINOUSINTENSITY;
      }
    }
    switch (lightTypeID) {
      case Light2.LIGHTTYPEID_POINTLIGHT:
      case Light2.LIGHTTYPEID_SPOTLIGHT:
        switch (photometricMode) {
          case Light2.INTENSITYMODE_LUMINOUSPOWER:
            photometricScale = 1 / (4 * Math.PI);
            break;
          case Light2.INTENSITYMODE_LUMINOUSINTENSITY:
            photometricScale = 1;
            break;
          case Light2.INTENSITYMODE_LUMINANCE:
            photometricScale = this.radius * this.radius;
            break;
        }
        break;
      case Light2.LIGHTTYPEID_DIRECTIONALLIGHT:
        switch (photometricMode) {
          case Light2.INTENSITYMODE_ILLUMINANCE:
            photometricScale = 1;
            break;
          case Light2.INTENSITYMODE_LUMINANCE:
            var apexAngleRadians = this.radius;
            apexAngleRadians = Math.max(apexAngleRadians, 1e-3);
            var solidAngle = 2 * Math.PI * (1 - Math.cos(apexAngleRadians));
            photometricScale = solidAngle;
            break;
        }
        break;
      case Light2.LIGHTTYPEID_HEMISPHERICLIGHT:
        photometricScale = 1;
        break;
    }
    return photometricScale;
  };
  Light2.prototype._reorderLightsInScene = function() {
    var scene = this.getScene();
    if (this._renderPriority != 0) {
      scene.requireLightSorting = true;
    }
    this.getScene().sortLightsByPriority();
  };
  Light2.FALLOFF_DEFAULT = 0;
  Light2.FALLOFF_PHYSICAL = 1;
  Light2.FALLOFF_GLTF = 2;
  Light2.FALLOFF_STANDARD = 3;
  Light2.LIGHTMAP_DEFAULT = 0;
  Light2.LIGHTMAP_SPECULAR = 1;
  Light2.LIGHTMAP_SHADOWSONLY = 2;
  Light2.INTENSITYMODE_AUTOMATIC = 0;
  Light2.INTENSITYMODE_LUMINOUSPOWER = 1;
  Light2.INTENSITYMODE_LUMINOUSINTENSITY = 2;
  Light2.INTENSITYMODE_ILLUMINANCE = 3;
  Light2.INTENSITYMODE_LUMINANCE = 4;
  Light2.LIGHTTYPEID_POINTLIGHT = 0;
  Light2.LIGHTTYPEID_DIRECTIONALLIGHT = 1;
  Light2.LIGHTTYPEID_SPOTLIGHT = 2;
  Light2.LIGHTTYPEID_HEMISPHERICLIGHT = 3;
  __decorate([
    serializeAsColor3()
  ], Light2.prototype, "diffuse", void 0);
  __decorate([
    serializeAsColor3()
  ], Light2.prototype, "specular", void 0);
  __decorate([
    serialize()
  ], Light2.prototype, "falloffType", void 0);
  __decorate([
    serialize()
  ], Light2.prototype, "intensity", void 0);
  __decorate([
    serialize()
  ], Light2.prototype, "range", null);
  __decorate([
    serialize()
  ], Light2.prototype, "intensityMode", null);
  __decorate([
    serialize()
  ], Light2.prototype, "radius", null);
  __decorate([
    serialize()
  ], Light2.prototype, "_renderPriority", void 0);
  __decorate([
    expandToProperty("_reorderLightsInScene")
  ], Light2.prototype, "renderPriority", void 0);
  __decorate([
    serialize("shadowEnabled")
  ], Light2.prototype, "_shadowEnabled", void 0);
  __decorate([
    serialize("excludeWithLayerMask")
  ], Light2.prototype, "_excludeWithLayerMask", void 0);
  __decorate([
    serialize("includeOnlyWithLayerMask")
  ], Light2.prototype, "_includeOnlyWithLayerMask", void 0);
  __decorate([
    serialize("lightmapMode")
  ], Light2.prototype, "_lightmapMode", void 0);
  return Light2;
}(Node);

// node_modules/@babylonjs/core/Collisions/intersectionInfo.js
var IntersectionInfo = function() {
  function IntersectionInfo2(bu, bv, distance) {
    this.bu = bu;
    this.bv = bv;
    this.distance = distance;
    this.faceId = 0;
    this.subMeshId = 0;
  }
  return IntersectionInfo2;
}();

// node_modules/@babylonjs/core/Meshes/subMesh.js
var SubMesh = function() {
  function SubMesh2(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox, addToMesh) {
    if (createBoundingBox === void 0) {
      createBoundingBox = true;
    }
    if (addToMesh === void 0) {
      addToMesh = true;
    }
    this.materialIndex = materialIndex;
    this.verticesStart = verticesStart;
    this.verticesCount = verticesCount;
    this.indexStart = indexStart;
    this.indexCount = indexCount;
    this._materialDefines = null;
    this._materialEffect = null;
    this._effectOverride = null;
    this._linesIndexCount = 0;
    this._linesIndexBuffer = null;
    this._lastColliderWorldVertices = null;
    this._lastColliderTransformMatrix = null;
    this._renderId = 0;
    this._alphaIndex = 0;
    this._distanceToCamera = 0;
    this._currentMaterial = null;
    this._mesh = mesh;
    this._renderingMesh = renderingMesh || mesh;
    if (addToMesh) {
      mesh.subMeshes.push(this);
    }
    this._trianglePlanes = [];
    this._id = mesh.subMeshes.length - 1;
    if (createBoundingBox) {
      this.refreshBoundingInfo();
      mesh.computeWorldMatrix(true);
    }
  }
  Object.defineProperty(SubMesh2.prototype, "materialDefines", {
    get: function() {
      return this._materialDefines;
    },
    set: function(defines) {
      this._materialDefines = defines;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SubMesh2.prototype, "effect", {
    get: function() {
      var _a;
      return (_a = this._effectOverride) !== null && _a !== void 0 ? _a : this._materialEffect;
    },
    enumerable: false,
    configurable: true
  });
  SubMesh2.prototype.setEffect = function(effect, defines) {
    if (defines === void 0) {
      defines = null;
    }
    if (this._materialEffect === effect) {
      if (!effect) {
        this._materialDefines = null;
      }
      return;
    }
    this._materialDefines = defines;
    this._materialEffect = effect;
  };
  SubMesh2.AddToMesh = function(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox) {
    if (createBoundingBox === void 0) {
      createBoundingBox = true;
    }
    return new SubMesh2(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox);
  };
  Object.defineProperty(SubMesh2.prototype, "IsGlobal", {
    get: function() {
      return this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices();
    },
    enumerable: false,
    configurable: true
  });
  SubMesh2.prototype.getBoundingInfo = function() {
    if (this.IsGlobal) {
      return this._mesh.getBoundingInfo();
    }
    return this._boundingInfo;
  };
  SubMesh2.prototype.setBoundingInfo = function(boundingInfo) {
    this._boundingInfo = boundingInfo;
    return this;
  };
  SubMesh2.prototype.getMesh = function() {
    return this._mesh;
  };
  SubMesh2.prototype.getRenderingMesh = function() {
    return this._renderingMesh;
  };
  SubMesh2.prototype.getReplacementMesh = function() {
    return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;
  };
  SubMesh2.prototype.getEffectiveMesh = function() {
    var replacementMesh = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;
    return replacementMesh ? replacementMesh : this._renderingMesh;
  };
  SubMesh2.prototype.getMaterial = function() {
    var rootMaterial = this._renderingMesh.material;
    if (rootMaterial === null || rootMaterial === void 0) {
      return this._mesh.getScene().defaultMaterial;
    } else if (this._IsMultiMaterial(rootMaterial)) {
      var effectiveMaterial = rootMaterial.getSubMaterial(this.materialIndex);
      if (this._currentMaterial !== effectiveMaterial) {
        this._currentMaterial = effectiveMaterial;
        this._materialDefines = null;
      }
      return effectiveMaterial;
    }
    return rootMaterial;
  };
  SubMesh2.prototype._IsMultiMaterial = function(material) {
    return material.getSubMaterial !== void 0;
  };
  SubMesh2.prototype.refreshBoundingInfo = function(data) {
    if (data === void 0) {
      data = null;
    }
    this._lastColliderWorldVertices = null;
    if (this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) {
      return this;
    }
    if (!data) {
      data = this._renderingMesh.getVerticesData(VertexBuffer.PositionKind);
    }
    if (!data) {
      this._boundingInfo = this._mesh.getBoundingInfo();
      return this;
    }
    var indices = this._renderingMesh.getIndices();
    var extend;
    if (this.indexStart === 0 && this.indexCount === indices.length) {
      var boundingInfo = this._renderingMesh.getBoundingInfo();
      extend = { minimum: boundingInfo.minimum.clone(), maximum: boundingInfo.maximum.clone() };
    } else {
      extend = extractMinAndMaxIndexed(data, indices, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);
    }
    if (this._boundingInfo) {
      this._boundingInfo.reConstruct(extend.minimum, extend.maximum);
    } else {
      this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);
    }
    return this;
  };
  SubMesh2.prototype._checkCollision = function(collider) {
    var boundingInfo = this.getBoundingInfo();
    return boundingInfo._checkCollision(collider);
  };
  SubMesh2.prototype.updateBoundingInfo = function(world) {
    var boundingInfo = this.getBoundingInfo();
    if (!boundingInfo) {
      this.refreshBoundingInfo();
      boundingInfo = this.getBoundingInfo();
    }
    if (boundingInfo) {
      boundingInfo.update(world);
    }
    return this;
  };
  SubMesh2.prototype.isInFrustum = function(frustumPlanes) {
    var boundingInfo = this.getBoundingInfo();
    if (!boundingInfo) {
      return false;
    }
    return boundingInfo.isInFrustum(frustumPlanes, this._mesh.cullingStrategy);
  };
  SubMesh2.prototype.isCompletelyInFrustum = function(frustumPlanes) {
    var boundingInfo = this.getBoundingInfo();
    if (!boundingInfo) {
      return false;
    }
    return boundingInfo.isCompletelyInFrustum(frustumPlanes);
  };
  SubMesh2.prototype.render = function(enableAlphaMode) {
    this._renderingMesh.render(this, enableAlphaMode, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : void 0);
    return this;
  };
  SubMesh2.prototype._getLinesIndexBuffer = function(indices, engine) {
    if (!this._linesIndexBuffer) {
      var linesIndices = [];
      for (var index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {
        linesIndices.push(indices[index], indices[index + 1], indices[index + 1], indices[index + 2], indices[index + 2], indices[index]);
      }
      this._linesIndexBuffer = engine.createIndexBuffer(linesIndices);
      this._linesIndexCount = linesIndices.length;
    }
    return this._linesIndexBuffer;
  };
  SubMesh2.prototype.canIntersects = function(ray) {
    var boundingInfo = this.getBoundingInfo();
    if (!boundingInfo) {
      return false;
    }
    return ray.intersectsBox(boundingInfo.boundingBox);
  };
  SubMesh2.prototype.intersects = function(ray, positions, indices, fastCheck, trianglePredicate) {
    var material = this.getMaterial();
    if (!material) {
      return null;
    }
    var step = 3;
    var checkStopper = false;
    switch (material.fillMode) {
      case 3:
      case 4:
      case 5:
      case 6:
      case 8:
        return null;
      case 7:
        step = 1;
        checkStopper = true;
        break;
      default:
        break;
    }
    if (this._mesh.getClassName() === "InstancedLinesMesh" || this._mesh.getClassName() === "LinesMesh") {
      if (!indices.length) {
        return this._intersectUnIndexedLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);
      }
      return this._intersectLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);
    } else {
      if (!indices.length && this._mesh._unIndexed) {
        return this._intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate);
      }
      return this._intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate);
    }
  };
  SubMesh2.prototype._intersectLines = function(ray, positions, indices, intersectionThreshold, fastCheck) {
    var intersectInfo = null;
    for (var index = this.indexStart; index < this.indexStart + this.indexCount; index += 2) {
      var p0 = positions[indices[index]];
      var p1 = positions[indices[index + 1]];
      var length = ray.intersectionSegment(p0, p1, intersectionThreshold);
      if (length < 0) {
        continue;
      }
      if (fastCheck || !intersectInfo || length < intersectInfo.distance) {
        intersectInfo = new IntersectionInfo(null, null, length);
        intersectInfo.faceId = index / 2;
        if (fastCheck) {
          break;
        }
      }
    }
    return intersectInfo;
  };
  SubMesh2.prototype._intersectUnIndexedLines = function(ray, positions, indices, intersectionThreshold, fastCheck) {
    var intersectInfo = null;
    for (var index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 2) {
      var p0 = positions[index];
      var p1 = positions[index + 1];
      var length = ray.intersectionSegment(p0, p1, intersectionThreshold);
      if (length < 0) {
        continue;
      }
      if (fastCheck || !intersectInfo || length < intersectInfo.distance) {
        intersectInfo = new IntersectionInfo(null, null, length);
        intersectInfo.faceId = index / 2;
        if (fastCheck) {
          break;
        }
      }
    }
    return intersectInfo;
  };
  SubMesh2.prototype._intersectTriangles = function(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate) {
    var intersectInfo = null;
    var faceID = -1;
    for (var index = this.indexStart; index < this.indexStart + this.indexCount; index += step) {
      faceID++;
      var indexA = indices[index];
      var indexB = indices[index + 1];
      var indexC = indices[index + 2];
      if (checkStopper && indexC === 4294967295) {
        index += 2;
        continue;
      }
      var p0 = positions[indexA];
      var p1 = positions[indexB];
      var p2 = positions[indexC];
      if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray)) {
        continue;
      }
      var currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);
      if (currentIntersectInfo) {
        if (currentIntersectInfo.distance < 0) {
          continue;
        }
        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {
          intersectInfo = currentIntersectInfo;
          intersectInfo.faceId = faceID;
          if (fastCheck) {
            break;
          }
        }
      }
    }
    return intersectInfo;
  };
  SubMesh2.prototype._intersectUnIndexedTriangles = function(ray, positions, indices, fastCheck, trianglePredicate) {
    var intersectInfo = null;
    for (var index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {
      var p0 = positions[index];
      var p1 = positions[index + 1];
      var p2 = positions[index + 2];
      if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray)) {
        continue;
      }
      var currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);
      if (currentIntersectInfo) {
        if (currentIntersectInfo.distance < 0) {
          continue;
        }
        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {
          intersectInfo = currentIntersectInfo;
          intersectInfo.faceId = index / 3;
          if (fastCheck) {
            break;
          }
        }
      }
    }
    return intersectInfo;
  };
  SubMesh2.prototype._rebuild = function() {
    if (this._linesIndexBuffer) {
      this._linesIndexBuffer = null;
    }
  };
  SubMesh2.prototype.clone = function(newMesh, newRenderingMesh) {
    var result = new SubMesh2(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, newMesh, newRenderingMesh, false);
    if (!this.IsGlobal) {
      var boundingInfo = this.getBoundingInfo();
      if (!boundingInfo) {
        return result;
      }
      result._boundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);
    }
    return result;
  };
  SubMesh2.prototype.dispose = function() {
    if (this._linesIndexBuffer) {
      this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer);
      this._linesIndexBuffer = null;
    }
    var index = this._mesh.subMeshes.indexOf(this);
    this._mesh.subMeshes.splice(index, 1);
  };
  SubMesh2.prototype.getClassName = function() {
    return "SubMesh";
  };
  SubMesh2.CreateFromIndices = function(materialIndex, startIndex, indexCount, mesh, renderingMesh) {
    var minVertexIndex = Number.MAX_VALUE;
    var maxVertexIndex = -Number.MAX_VALUE;
    var whatWillRender = renderingMesh || mesh;
    var indices = whatWillRender.getIndices();
    for (var index = startIndex; index < startIndex + indexCount; index++) {
      var vertexIndex = indices[index];
      if (vertexIndex < minVertexIndex) {
        minVertexIndex = vertexIndex;
      }
      if (vertexIndex > maxVertexIndex) {
        maxVertexIndex = vertexIndex;
      }
    }
    return new SubMesh2(materialIndex, minVertexIndex, maxVertexIndex - minVertexIndex + 1, startIndex, indexCount, mesh, renderingMesh);
  };
  return SubMesh2;
}();

// node_modules/@babylonjs/core/Materials/material.js
var Material = function() {
  function Material2(name45, scene, doNotAdd) {
    this.shadowDepthWrapper = null;
    this.allowShaderHotSwapping = true;
    this.metadata = null;
    this.reservedDataStore = null;
    this.checkReadyOnEveryCall = false;
    this.checkReadyOnlyOnce = false;
    this.state = "";
    this._alpha = 1;
    this._backFaceCulling = true;
    this.onCompiled = null;
    this.onError = null;
    this.getRenderTargetTextures = null;
    this.doNotSerialize = false;
    this._storeEffectOnSubMeshes = false;
    this.animations = null;
    this.onDisposeObservable = new Observable();
    this._onDisposeObserver = null;
    this._onUnBindObservable = null;
    this._onBindObserver = null;
    this._alphaMode = 2;
    this._needDepthPrePass = false;
    this.disableDepthWrite = false;
    this.disableColorWrite = false;
    this.forceDepthWrite = false;
    this.depthFunction = 0;
    this.separateCullingPass = false;
    this._fogEnabled = true;
    this.pointSize = 1;
    this.zOffset = 0;
    this._effect = null;
    this._useUBO = false;
    this._fillMode = Material2.TriangleFillMode;
    this._cachedDepthWriteState = false;
    this._cachedColorWriteState = false;
    this._cachedDepthFunctionState = 0;
    this._indexInSceneMaterialArray = -1;
    this.meshMap = null;
    this._forceAlphaTest = false;
    this._transparencyMode = null;
    this.name = name45;
    var idSubscript = 1;
    this._scene = scene || EngineStore.LastCreatedScene;
    this.id = name45 || Tools.RandomId();
    while (this._scene.getMaterialByID(this.id)) {
      this.id = name45 + " " + idSubscript++;
    }
    this.uniqueId = this._scene.getUniqueId();
    if (this._scene.useRightHandedSystem) {
      this.sideOrientation = Material2.ClockWiseSideOrientation;
    } else {
      this.sideOrientation = Material2.CounterClockWiseSideOrientation;
    }
    this._uniformBuffer = new UniformBuffer(this._scene.getEngine());
    this._useUBO = this.getScene().getEngine().supportsUniformBuffers;
    if (!doNotAdd) {
      this._scene.addMaterial(this);
    }
    if (this._scene.useMaterialMeshMap) {
      this.meshMap = {};
    }
  }
  Object.defineProperty(Material2.prototype, "canRenderToMRT", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "alpha", {
    get: function() {
      return this._alpha;
    },
    set: function(value) {
      if (this._alpha === value) {
        return;
      }
      this._alpha = value;
      this.markAsDirty(Material2.MiscDirtyFlag);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "backFaceCulling", {
    get: function() {
      return this._backFaceCulling;
    },
    set: function(value) {
      if (this._backFaceCulling === value) {
        return;
      }
      this._backFaceCulling = value;
      this.markAsDirty(Material2.TextureDirtyFlag);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "hasRenderTargetTextures", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "onDispose", {
    set: function(callback) {
      if (this._onDisposeObserver) {
        this.onDisposeObservable.remove(this._onDisposeObserver);
      }
      this._onDisposeObserver = this.onDisposeObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "onBindObservable", {
    get: function() {
      if (!this._onBindObservable) {
        this._onBindObservable = new Observable();
      }
      return this._onBindObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "onBind", {
    set: function(callback) {
      if (this._onBindObserver) {
        this.onBindObservable.remove(this._onBindObserver);
      }
      this._onBindObserver = this.onBindObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "onUnBindObservable", {
    get: function() {
      if (!this._onUnBindObservable) {
        this._onUnBindObservable = new Observable();
      }
      return this._onUnBindObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "onEffectCreatedObservable", {
    get: function() {
      if (!this._onEffectCreatedObservable) {
        this._onEffectCreatedObservable = new Observable();
      }
      return this._onEffectCreatedObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "alphaMode", {
    get: function() {
      return this._alphaMode;
    },
    set: function(value) {
      if (this._alphaMode === value) {
        return;
      }
      this._alphaMode = value;
      this.markAsDirty(Material2.TextureDirtyFlag);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "needDepthPrePass", {
    get: function() {
      return this._needDepthPrePass;
    },
    set: function(value) {
      if (this._needDepthPrePass === value) {
        return;
      }
      this._needDepthPrePass = value;
      if (this._needDepthPrePass) {
        this.checkReadyOnEveryCall = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "fogEnabled", {
    get: function() {
      return this._fogEnabled;
    },
    set: function(value) {
      if (this._fogEnabled === value) {
        return;
      }
      this._fogEnabled = value;
      this.markAsDirty(Material2.MiscDirtyFlag);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "wireframe", {
    get: function() {
      switch (this._fillMode) {
        case Material2.WireFrameFillMode:
        case Material2.LineListDrawMode:
        case Material2.LineLoopDrawMode:
        case Material2.LineStripDrawMode:
          return true;
      }
      return this._scene.forceWireframe;
    },
    set: function(value) {
      this.fillMode = value ? Material2.WireFrameFillMode : Material2.TriangleFillMode;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "pointsCloud", {
    get: function() {
      switch (this._fillMode) {
        case Material2.PointFillMode:
        case Material2.PointListDrawMode:
          return true;
      }
      return this._scene.forcePointsCloud;
    },
    set: function(value) {
      this.fillMode = value ? Material2.PointFillMode : Material2.TriangleFillMode;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "fillMode", {
    get: function() {
      return this._fillMode;
    },
    set: function(value) {
      if (this._fillMode === value) {
        return;
      }
      this._fillMode = value;
      this.markAsDirty(Material2.MiscDirtyFlag);
    },
    enumerable: false,
    configurable: true
  });
  Material2.prototype.toString = function(fullDetails) {
    var ret = "Name: " + this.name;
    if (fullDetails) {
    }
    return ret;
  };
  Material2.prototype.getClassName = function() {
    return "Material";
  };
  Object.defineProperty(Material2.prototype, "isFrozen", {
    get: function() {
      return this.checkReadyOnlyOnce;
    },
    enumerable: false,
    configurable: true
  });
  Material2.prototype.freeze = function() {
    this.markDirty();
    this.checkReadyOnlyOnce = true;
  };
  Material2.prototype.unfreeze = function() {
    this.markDirty();
    this.checkReadyOnlyOnce = false;
  };
  Material2.prototype.isReady = function(mesh, useInstances) {
    return true;
  };
  Material2.prototype.isReadyForSubMesh = function(mesh, subMesh, useInstances) {
    return false;
  };
  Material2.prototype.getEffect = function() {
    return this._effect;
  };
  Material2.prototype.getScene = function() {
    return this._scene;
  };
  Object.defineProperty(Material2.prototype, "transparencyMode", {
    get: function() {
      return this._transparencyMode;
    },
    set: function(value) {
      if (this._transparencyMode === value) {
        return;
      }
      this._transparencyMode = value;
      this._forceAlphaTest = value === Material2.MATERIAL_ALPHATESTANDBLEND;
      this._markAllSubMeshesAsTexturesAndMiscDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "_disableAlphaBlending", {
    get: function() {
      return this._transparencyMode === Material2.MATERIAL_OPAQUE || this._transparencyMode === Material2.MATERIAL_ALPHATEST;
    },
    enumerable: false,
    configurable: true
  });
  Material2.prototype.needAlphaBlending = function() {
    if (this._disableAlphaBlending) {
      return false;
    }
    return this.alpha < 1;
  };
  Material2.prototype.needAlphaBlendingForMesh = function(mesh) {
    if (this._disableAlphaBlending && mesh.visibility >= 1) {
      return false;
    }
    return this.needAlphaBlending() || mesh.visibility < 1 || mesh.hasVertexAlpha;
  };
  Material2.prototype.needAlphaTesting = function() {
    if (this._forceAlphaTest) {
      return true;
    }
    return false;
  };
  Material2.prototype._shouldTurnAlphaTestOn = function(mesh) {
    return !this.needAlphaBlendingForMesh(mesh) && this.needAlphaTesting();
  };
  Material2.prototype.getAlphaTestTexture = function() {
    return null;
  };
  Material2.prototype.markDirty = function() {
    var meshes = this.getScene().meshes;
    for (var _i = 0, meshes_1 = meshes; _i < meshes_1.length; _i++) {
      var mesh = meshes_1[_i];
      if (!mesh.subMeshes) {
        continue;
      }
      for (var _a = 0, _b = mesh.subMeshes; _a < _b.length; _a++) {
        var subMesh = _b[_a];
        if (subMesh.getMaterial() !== this) {
          continue;
        }
        if (!subMesh.effect) {
          continue;
        }
        subMesh.effect._wasPreviouslyReady = false;
      }
    }
  };
  Material2.prototype._preBind = function(effect, overrideOrientation) {
    if (overrideOrientation === void 0) {
      overrideOrientation = null;
    }
    var engine = this._scene.getEngine();
    var orientation = overrideOrientation == null ? this.sideOrientation : overrideOrientation;
    var reverse = orientation === Material2.ClockWiseSideOrientation;
    engine.enableEffect(effect ? effect : this._effect);
    engine.setState(this.backFaceCulling, this.zOffset, false, reverse);
    return reverse;
  };
  Material2.prototype.bind = function(world, mesh) {
  };
  Material2.prototype.bindForSubMesh = function(world, mesh, subMesh) {
  };
  Material2.prototype.bindOnlyWorldMatrix = function(world) {
  };
  Material2.prototype.bindSceneUniformBuffer = function(effect, sceneUbo) {
    sceneUbo.bindToEffect(effect, "Scene");
  };
  Material2.prototype.bindView = function(effect) {
    if (!this._useUBO) {
      effect.setMatrix("view", this.getScene().getViewMatrix());
    } else {
      this.bindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());
    }
  };
  Material2.prototype.bindViewProjection = function(effect) {
    if (!this._useUBO) {
      effect.setMatrix("viewProjection", this.getScene().getTransformMatrix());
    } else {
      this.bindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());
    }
  };
  Material2.prototype._afterBind = function(mesh) {
    this._scene._cachedMaterial = this;
    if (mesh) {
      this._scene._cachedVisibility = mesh.visibility;
    } else {
      this._scene._cachedVisibility = 1;
    }
    if (this._onBindObservable && mesh) {
      this._onBindObservable.notifyObservers(mesh);
    }
    if (this.disableDepthWrite) {
      var engine = this._scene.getEngine();
      this._cachedDepthWriteState = engine.getDepthWrite();
      engine.setDepthWrite(false);
    }
    if (this.disableColorWrite) {
      var engine = this._scene.getEngine();
      this._cachedColorWriteState = engine.getColorWrite();
      engine.setColorWrite(false);
    }
    if (this.depthFunction !== 0) {
      var engine = this._scene.getEngine();
      this._cachedDepthFunctionState = engine.getDepthFunction() || 0;
      engine.setDepthFunction(this.depthFunction);
    }
  };
  Material2.prototype.unbind = function() {
    if (this._onUnBindObservable) {
      this._onUnBindObservable.notifyObservers(this);
    }
    if (this.depthFunction !== 0) {
      var engine = this._scene.getEngine();
      engine.setDepthFunction(this._cachedDepthFunctionState);
    }
    if (this.disableDepthWrite) {
      var engine = this._scene.getEngine();
      engine.setDepthWrite(this._cachedDepthWriteState);
    }
    if (this.disableColorWrite) {
      var engine = this._scene.getEngine();
      engine.setColorWrite(this._cachedColorWriteState);
    }
  };
  Material2.prototype.getActiveTextures = function() {
    return [];
  };
  Material2.prototype.hasTexture = function(texture) {
    return false;
  };
  Material2.prototype.clone = function(name45) {
    return null;
  };
  Material2.prototype.getBindedMeshes = function() {
    var _this = this;
    if (this.meshMap) {
      var result = new Array();
      for (var meshId in this.meshMap) {
        var mesh = this.meshMap[meshId];
        if (mesh) {
          result.push(mesh);
        }
      }
      return result;
    } else {
      var meshes = this._scene.meshes;
      return meshes.filter(function(mesh2) {
        return mesh2.material === _this;
      });
    }
  };
  Material2.prototype.forceCompilation = function(mesh, onCompiled, options, onError) {
    var _this = this;
    var localOptions = __assign({ clipPlane: false, useInstances: false }, options);
    var scene = this.getScene();
    var currentHotSwapingState = this.allowShaderHotSwapping;
    this.allowShaderHotSwapping = false;
    var checkReady = function() {
      if (!_this._scene || !_this._scene.getEngine()) {
        return;
      }
      var clipPlaneState = scene.clipPlane;
      if (localOptions.clipPlane) {
        scene.clipPlane = new Plane(0, 0, 0, 1);
      }
      if (_this._storeEffectOnSubMeshes) {
        var allDone = true, lastError = null;
        if (mesh.subMeshes) {
          var tempSubMesh = new SubMesh(0, 0, 0, 0, 0, mesh, void 0, false, false);
          if (tempSubMesh._materialDefines) {
            tempSubMesh._materialDefines._renderId = -1;
          }
          if (!_this.isReadyForSubMesh(mesh, tempSubMesh, localOptions.useInstances)) {
            if (tempSubMesh.effect && tempSubMesh.effect.getCompilationError() && tempSubMesh.effect.allFallbacksProcessed()) {
              lastError = tempSubMesh.effect.getCompilationError();
            } else {
              allDone = false;
              setTimeout(checkReady, 16);
            }
          }
        }
        if (allDone) {
          _this.allowShaderHotSwapping = currentHotSwapingState;
          if (lastError) {
            if (onError) {
              onError(lastError);
            }
          }
          if (onCompiled) {
            onCompiled(_this);
          }
        }
      } else {
        if (_this.isReady()) {
          _this.allowShaderHotSwapping = currentHotSwapingState;
          if (onCompiled) {
            onCompiled(_this);
          }
        } else {
          setTimeout(checkReady, 16);
        }
      }
      if (localOptions.clipPlane) {
        scene.clipPlane = clipPlaneState;
      }
    };
    checkReady();
  };
  Material2.prototype.forceCompilationAsync = function(mesh, options) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      _this.forceCompilation(mesh, function() {
        resolve();
      }, options, function(reason) {
        reject(reason);
      });
    });
  };
  Material2.prototype.markAsDirty = function(flag) {
    if (this.getScene().blockMaterialDirtyMechanism) {
      return;
    }
    Material2._DirtyCallbackArray.length = 0;
    if (flag & Material2.TextureDirtyFlag) {
      Material2._DirtyCallbackArray.push(Material2._TextureDirtyCallBack);
    }
    if (flag & Material2.LightDirtyFlag) {
      Material2._DirtyCallbackArray.push(Material2._LightsDirtyCallBack);
    }
    if (flag & Material2.FresnelDirtyFlag) {
      Material2._DirtyCallbackArray.push(Material2._FresnelDirtyCallBack);
    }
    if (flag & Material2.AttributesDirtyFlag) {
      Material2._DirtyCallbackArray.push(Material2._AttributeDirtyCallBack);
    }
    if (flag & Material2.MiscDirtyFlag) {
      Material2._DirtyCallbackArray.push(Material2._MiscDirtyCallBack);
    }
    if (flag & Material2.PrePassDirtyFlag) {
      Material2._DirtyCallbackArray.push(Material2._PrePassDirtyCallBack);
    }
    if (Material2._DirtyCallbackArray.length) {
      this._markAllSubMeshesAsDirty(Material2._RunDirtyCallBacks);
    }
    this.getScene().resetCachedMaterial();
  };
  Material2.prototype._markAllSubMeshesAsDirty = function(func) {
    if (this.getScene().blockMaterialDirtyMechanism) {
      return;
    }
    var meshes = this.getScene().meshes;
    for (var _i = 0, meshes_2 = meshes; _i < meshes_2.length; _i++) {
      var mesh = meshes_2[_i];
      if (!mesh.subMeshes) {
        continue;
      }
      for (var _a = 0, _b = mesh.subMeshes; _a < _b.length; _a++) {
        var subMesh = _b[_a];
        if (subMesh.getMaterial() !== this) {
          continue;
        }
        if (!subMesh._materialDefines) {
          continue;
        }
        func(subMesh._materialDefines);
      }
    }
  };
  Material2.prototype._markScenePrePassDirty = function() {
    if (this.getScene().blockMaterialDirtyMechanism) {
      return;
    }
    var prePassRenderer = this.getScene().enablePrePassRenderer();
    if (prePassRenderer) {
      prePassRenderer.markAsDirty();
    }
  };
  Material2.prototype._markAllSubMeshesAsAllDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._AllDirtyCallBack);
  };
  Material2.prototype._markAllSubMeshesAsImageProcessingDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._ImageProcessingDirtyCallBack);
  };
  Material2.prototype._markAllSubMeshesAsTexturesDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._TextureDirtyCallBack);
  };
  Material2.prototype._markAllSubMeshesAsFresnelDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._FresnelDirtyCallBack);
  };
  Material2.prototype._markAllSubMeshesAsFresnelAndMiscDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._FresnelAndMiscDirtyCallBack);
  };
  Material2.prototype._markAllSubMeshesAsLightsDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._LightsDirtyCallBack);
  };
  Material2.prototype._markAllSubMeshesAsAttributesDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._AttributeDirtyCallBack);
  };
  Material2.prototype._markAllSubMeshesAsMiscDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._MiscDirtyCallBack);
  };
  Material2.prototype._markAllSubMeshesAsPrePassDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._MiscDirtyCallBack);
  };
  Material2.prototype._markAllSubMeshesAsTexturesAndMiscDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._TextureAndMiscDirtyCallBack);
  };
  Material2.prototype.setPrePassRenderer = function(prePassRenderer) {
    return false;
  };
  Material2.prototype.dispose = function(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {
    var scene = this.getScene();
    scene.stopAnimation(this);
    scene.freeProcessedMaterials();
    scene.removeMaterial(this);
    if (notBoundToMesh !== true) {
      if (this.meshMap) {
        for (var meshId in this.meshMap) {
          var mesh = this.meshMap[meshId];
          if (mesh) {
            mesh.material = null;
            this.releaseVertexArrayObject(mesh, forceDisposeEffect);
          }
        }
      } else {
        var meshes = scene.meshes;
        for (var _i = 0, meshes_3 = meshes; _i < meshes_3.length; _i++) {
          var mesh = meshes_3[_i];
          if (mesh.material === this && !mesh.sourceMesh) {
            mesh.material = null;
            this.releaseVertexArrayObject(mesh, forceDisposeEffect);
          }
        }
      }
    }
    this._uniformBuffer.dispose();
    if (forceDisposeEffect && this._effect) {
      if (!this._storeEffectOnSubMeshes) {
        this._effect.dispose();
      }
      this._effect = null;
    }
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    if (this._onBindObservable) {
      this._onBindObservable.clear();
    }
    if (this._onUnBindObservable) {
      this._onUnBindObservable.clear();
    }
    if (this._onEffectCreatedObservable) {
      this._onEffectCreatedObservable.clear();
    }
  };
  Material2.prototype.releaseVertexArrayObject = function(mesh, forceDisposeEffect) {
    if (mesh.geometry) {
      var geometry = mesh.geometry;
      if (this._storeEffectOnSubMeshes) {
        for (var _i = 0, _a = mesh.subMeshes; _i < _a.length; _i++) {
          var subMesh = _a[_i];
          geometry._releaseVertexArrayObject(subMesh._materialEffect);
          if (forceDisposeEffect && subMesh._materialEffect) {
            subMesh._materialEffect.dispose();
          }
        }
      } else {
        geometry._releaseVertexArrayObject(this._effect);
      }
    }
  };
  Material2.prototype.serialize = function() {
    return SerializationHelper.Serialize(this);
  };
  Material2.Parse = function(parsedMaterial, scene, rootUrl) {
    if (!parsedMaterial.customType) {
      parsedMaterial.customType = "BABYLON.StandardMaterial";
    } else if (parsedMaterial.customType === "BABYLON.PBRMaterial" && parsedMaterial.overloadedAlbedo) {
      parsedMaterial.customType = "BABYLON.LegacyPBRMaterial";
      if (!BABYLON.LegacyPBRMaterial) {
        Logger.Error("Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library.");
        return null;
      }
    }
    var materialType = Tools.Instantiate(parsedMaterial.customType);
    return materialType.Parse(parsedMaterial, scene, rootUrl);
  };
  Material2.TriangleFillMode = 0;
  Material2.WireFrameFillMode = 1;
  Material2.PointFillMode = 2;
  Material2.PointListDrawMode = 3;
  Material2.LineListDrawMode = 4;
  Material2.LineLoopDrawMode = 5;
  Material2.LineStripDrawMode = 6;
  Material2.TriangleStripDrawMode = 7;
  Material2.TriangleFanDrawMode = 8;
  Material2.ClockWiseSideOrientation = 0;
  Material2.CounterClockWiseSideOrientation = 1;
  Material2.TextureDirtyFlag = 1;
  Material2.LightDirtyFlag = 2;
  Material2.FresnelDirtyFlag = 4;
  Material2.AttributesDirtyFlag = 8;
  Material2.MiscDirtyFlag = 16;
  Material2.PrePassDirtyFlag = 32;
  Material2.AllDirtyFlag = 63;
  Material2.MATERIAL_OPAQUE = 0;
  Material2.MATERIAL_ALPHATEST = 1;
  Material2.MATERIAL_ALPHABLEND = 2;
  Material2.MATERIAL_ALPHATESTANDBLEND = 3;
  Material2.MATERIAL_NORMALBLENDMETHOD_WHITEOUT = 0;
  Material2.MATERIAL_NORMALBLENDMETHOD_RNM = 1;
  Material2._AllDirtyCallBack = function(defines) {
    return defines.markAllAsDirty();
  };
  Material2._ImageProcessingDirtyCallBack = function(defines) {
    return defines.markAsImageProcessingDirty();
  };
  Material2._TextureDirtyCallBack = function(defines) {
    return defines.markAsTexturesDirty();
  };
  Material2._FresnelDirtyCallBack = function(defines) {
    return defines.markAsFresnelDirty();
  };
  Material2._MiscDirtyCallBack = function(defines) {
    return defines.markAsMiscDirty();
  };
  Material2._PrePassDirtyCallBack = function(defines) {
    return defines.markAsPrePassDirty();
  };
  Material2._LightsDirtyCallBack = function(defines) {
    return defines.markAsLightDirty();
  };
  Material2._AttributeDirtyCallBack = function(defines) {
    return defines.markAsAttributesDirty();
  };
  Material2._FresnelAndMiscDirtyCallBack = function(defines) {
    Material2._FresnelDirtyCallBack(defines);
    Material2._MiscDirtyCallBack(defines);
  };
  Material2._TextureAndMiscDirtyCallBack = function(defines) {
    Material2._TextureDirtyCallBack(defines);
    Material2._MiscDirtyCallBack(defines);
  };
  Material2._DirtyCallbackArray = [];
  Material2._RunDirtyCallBacks = function(defines) {
    for (var _i = 0, _a = Material2._DirtyCallbackArray; _i < _a.length; _i++) {
      var cb = _a[_i];
      cb(defines);
    }
  };
  __decorate([
    serialize()
  ], Material2.prototype, "id", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "uniqueId", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "name", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "checkReadyOnEveryCall", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "checkReadyOnlyOnce", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "state", void 0);
  __decorate([
    serialize("alpha")
  ], Material2.prototype, "_alpha", void 0);
  __decorate([
    serialize("backFaceCulling")
  ], Material2.prototype, "_backFaceCulling", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "sideOrientation", void 0);
  __decorate([
    serialize("alphaMode")
  ], Material2.prototype, "_alphaMode", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "_needDepthPrePass", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "disableDepthWrite", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "disableColorWrite", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "forceDepthWrite", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "depthFunction", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "separateCullingPass", void 0);
  __decorate([
    serialize("fogEnabled")
  ], Material2.prototype, "_fogEnabled", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "pointSize", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "zOffset", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "pointsCloud", null);
  __decorate([
    serialize()
  ], Material2.prototype, "fillMode", null);
  __decorate([
    serialize()
  ], Material2.prototype, "transparencyMode", null);
  return Material2;
}();

// node_modules/@babylonjs/core/PostProcesses/postProcessManager.js
var PostProcessManager = function() {
  function PostProcessManager2(scene) {
    this._vertexBuffers = {};
    this._scene = scene;
  }
  PostProcessManager2.prototype._prepareBuffers = function() {
    if (this._vertexBuffers[VertexBuffer.PositionKind]) {
      return;
    }
    var vertices = [];
    vertices.push(1, 1);
    vertices.push(-1, 1);
    vertices.push(-1, -1);
    vertices.push(1, -1);
    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._scene.getEngine(), vertices, VertexBuffer.PositionKind, false, false, 2);
    this._buildIndexBuffer();
  };
  PostProcessManager2.prototype._buildIndexBuffer = function() {
    var indices = [];
    indices.push(0);
    indices.push(1);
    indices.push(2);
    indices.push(0);
    indices.push(2);
    indices.push(3);
    this._indexBuffer = this._scene.getEngine().createIndexBuffer(indices);
  };
  PostProcessManager2.prototype._rebuild = function() {
    var vb = this._vertexBuffers[VertexBuffer.PositionKind];
    if (!vb) {
      return;
    }
    vb._rebuild();
    this._buildIndexBuffer();
  };
  PostProcessManager2.prototype._prepareFrame = function(sourceTexture, postProcesses) {
    if (sourceTexture === void 0) {
      sourceTexture = null;
    }
    if (postProcesses === void 0) {
      postProcesses = null;
    }
    var camera = this._scene.activeCamera;
    if (!camera) {
      return false;
    }
    postProcesses = postProcesses || camera._postProcesses.filter(function(pp) {
      return pp != null;
    });
    if (!postProcesses || postProcesses.length === 0 || !this._scene.postProcessesEnabled) {
      return false;
    }
    postProcesses[0].activate(camera, sourceTexture, postProcesses !== null && postProcesses !== void 0);
    return true;
  };
  PostProcessManager2.prototype.directRender = function(postProcesses, targetTexture, forceFullscreenViewport, faceIndex, lodLevel, doNotBindFrambuffer) {
    if (targetTexture === void 0) {
      targetTexture = null;
    }
    if (forceFullscreenViewport === void 0) {
      forceFullscreenViewport = false;
    }
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lodLevel === void 0) {
      lodLevel = 0;
    }
    if (doNotBindFrambuffer === void 0) {
      doNotBindFrambuffer = false;
    }
    var engine = this._scene.getEngine();
    for (var index = 0; index < postProcesses.length; index++) {
      if (index < postProcesses.length - 1) {
        postProcesses[index + 1].activate(this._scene.activeCamera, targetTexture);
      } else {
        if (targetTexture) {
          engine.bindFramebuffer(targetTexture, faceIndex, void 0, void 0, forceFullscreenViewport, lodLevel);
        } else if (!doNotBindFrambuffer) {
          engine.restoreDefaultFramebuffer();
        }
      }
      var pp = postProcesses[index];
      var effect = pp.apply();
      if (effect) {
        pp.onBeforeRenderObservable.notifyObservers(effect);
        this._prepareBuffers();
        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
        engine.drawElementsType(Material.TriangleFillMode, 0, 6);
        pp.onAfterRenderObservable.notifyObservers(effect);
      }
    }
    engine.setDepthBuffer(true);
    engine.setDepthWrite(true);
  };
  PostProcessManager2.prototype._finalizeFrame = function(doNotPresent, targetTexture, faceIndex, postProcesses, forceFullscreenViewport) {
    if (forceFullscreenViewport === void 0) {
      forceFullscreenViewport = false;
    }
    var camera = this._scene.activeCamera;
    if (!camera) {
      return;
    }
    postProcesses = postProcesses || camera._postProcesses.filter(function(pp2) {
      return pp2 != null;
    });
    if (postProcesses.length === 0 || !this._scene.postProcessesEnabled) {
      return;
    }
    var engine = this._scene.getEngine();
    for (var index = 0, len = postProcesses.length; index < len; index++) {
      var pp = postProcesses[index];
      if (index < len - 1) {
        pp._outputTexture = postProcesses[index + 1].activate(camera, targetTexture);
      } else {
        if (targetTexture) {
          engine.bindFramebuffer(targetTexture, faceIndex, void 0, void 0, forceFullscreenViewport);
          pp._outputTexture = targetTexture;
        } else {
          engine.restoreDefaultFramebuffer();
          pp._outputTexture = null;
        }
      }
      if (doNotPresent) {
        break;
      }
      var effect = pp.apply();
      if (effect) {
        pp.onBeforeRenderObservable.notifyObservers(effect);
        this._prepareBuffers();
        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
        engine.drawElementsType(Material.TriangleFillMode, 0, 6);
        pp.onAfterRenderObservable.notifyObservers(effect);
      }
    }
    engine.setDepthBuffer(true);
    engine.setDepthWrite(true);
    engine.setAlphaMode(0);
  };
  PostProcessManager2.prototype.dispose = function() {
    var buffer = this._vertexBuffers[VertexBuffer.PositionKind];
    if (buffer) {
      buffer.dispose();
      this._vertexBuffers[VertexBuffer.PositionKind] = null;
    }
    if (this._indexBuffer) {
      this._scene.getEngine()._releaseBuffer(this._indexBuffer);
      this._indexBuffer = null;
    }
  };
  return PostProcessManager2;
}();

// node_modules/@babylonjs/core/Rendering/renderingGroup.js
var RenderingGroup = function() {
  function RenderingGroup2(index, scene, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {
    if (opaqueSortCompareFn === void 0) {
      opaqueSortCompareFn = null;
    }
    if (alphaTestSortCompareFn === void 0) {
      alphaTestSortCompareFn = null;
    }
    if (transparentSortCompareFn === void 0) {
      transparentSortCompareFn = null;
    }
    this.index = index;
    this._opaqueSubMeshes = new SmartArray(256);
    this._transparentSubMeshes = new SmartArray(256);
    this._alphaTestSubMeshes = new SmartArray(256);
    this._depthOnlySubMeshes = new SmartArray(256);
    this._particleSystems = new SmartArray(256);
    this._spriteManagers = new SmartArray(256);
    this._edgesRenderers = new SmartArrayNoDuplicate(16);
    this._scene = scene;
    this.opaqueSortCompareFn = opaqueSortCompareFn;
    this.alphaTestSortCompareFn = alphaTestSortCompareFn;
    this.transparentSortCompareFn = transparentSortCompareFn;
  }
  Object.defineProperty(RenderingGroup2.prototype, "opaqueSortCompareFn", {
    set: function(value) {
      this._opaqueSortCompareFn = value;
      if (value) {
        this._renderOpaque = this.renderOpaqueSorted;
      } else {
        this._renderOpaque = RenderingGroup2.renderUnsorted;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderingGroup2.prototype, "alphaTestSortCompareFn", {
    set: function(value) {
      this._alphaTestSortCompareFn = value;
      if (value) {
        this._renderAlphaTest = this.renderAlphaTestSorted;
      } else {
        this._renderAlphaTest = RenderingGroup2.renderUnsorted;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderingGroup2.prototype, "transparentSortCompareFn", {
    set: function(value) {
      if (value) {
        this._transparentSortCompareFn = value;
      } else {
        this._transparentSortCompareFn = RenderingGroup2.defaultTransparentSortCompare;
      }
      this._renderTransparent = this.renderTransparentSorted;
    },
    enumerable: false,
    configurable: true
  });
  RenderingGroup2.prototype.render = function(customRenderFunction, renderSprites, renderParticles, activeMeshes) {
    if (customRenderFunction) {
      customRenderFunction(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes, this._depthOnlySubMeshes);
      return;
    }
    var engine = this._scene.getEngine();
    if (this._depthOnlySubMeshes.length !== 0) {
      engine.setColorWrite(false);
      this._renderAlphaTest(this._depthOnlySubMeshes);
      engine.setColorWrite(true);
    }
    if (this._opaqueSubMeshes.length !== 0) {
      this._renderOpaque(this._opaqueSubMeshes);
    }
    if (this._alphaTestSubMeshes.length !== 0) {
      this._renderAlphaTest(this._alphaTestSubMeshes);
    }
    var stencilState = engine.getStencilBuffer();
    engine.setStencilBuffer(false);
    if (renderSprites) {
      this._renderSprites();
    }
    if (renderParticles) {
      this._renderParticles(activeMeshes);
    }
    if (this.onBeforeTransparentRendering) {
      this.onBeforeTransparentRendering();
    }
    if (this._transparentSubMeshes.length !== 0) {
      engine.setStencilBuffer(stencilState);
      this._renderTransparent(this._transparentSubMeshes);
      engine.setAlphaMode(0);
    }
    engine.setStencilBuffer(false);
    if (this._edgesRenderers.length) {
      for (var edgesRendererIndex = 0; edgesRendererIndex < this._edgesRenderers.length; edgesRendererIndex++) {
        this._edgesRenderers.data[edgesRendererIndex].render();
      }
      engine.setAlphaMode(0);
    }
    engine.setStencilBuffer(stencilState);
  };
  RenderingGroup2.prototype.renderOpaqueSorted = function(subMeshes) {
    return RenderingGroup2.renderSorted(subMeshes, this._opaqueSortCompareFn, this._scene.activeCamera, false);
  };
  RenderingGroup2.prototype.renderAlphaTestSorted = function(subMeshes) {
    return RenderingGroup2.renderSorted(subMeshes, this._alphaTestSortCompareFn, this._scene.activeCamera, false);
  };
  RenderingGroup2.prototype.renderTransparentSorted = function(subMeshes) {
    return RenderingGroup2.renderSorted(subMeshes, this._transparentSortCompareFn, this._scene.activeCamera, true);
  };
  RenderingGroup2.renderSorted = function(subMeshes, sortCompareFn, camera, transparent) {
    var subIndex = 0;
    var subMesh;
    var cameraPosition = camera ? camera.globalPosition : RenderingGroup2._zeroVector;
    for (; subIndex < subMeshes.length; subIndex++) {
      subMesh = subMeshes.data[subIndex];
      subMesh._alphaIndex = subMesh.getMesh().alphaIndex;
      subMesh._distanceToCamera = Vector3.Distance(subMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);
    }
    var sortedArray = subMeshes.data.slice(0, subMeshes.length);
    if (sortCompareFn) {
      sortedArray.sort(sortCompareFn);
    }
    for (subIndex = 0; subIndex < sortedArray.length; subIndex++) {
      subMesh = sortedArray[subIndex];
      if (transparent) {
        var material = subMesh.getMaterial();
        if (material && material.needDepthPrePass) {
          var engine = material.getScene().getEngine();
          engine.setColorWrite(false);
          engine.setAlphaMode(0);
          subMesh.render(false);
          engine.setColorWrite(true);
        }
      }
      subMesh.render(transparent);
    }
  };
  RenderingGroup2.renderUnsorted = function(subMeshes) {
    for (var subIndex = 0; subIndex < subMeshes.length; subIndex++) {
      var submesh = subMeshes.data[subIndex];
      submesh.render(false);
    }
  };
  RenderingGroup2.defaultTransparentSortCompare = function(a, b) {
    if (a._alphaIndex > b._alphaIndex) {
      return 1;
    }
    if (a._alphaIndex < b._alphaIndex) {
      return -1;
    }
    return RenderingGroup2.backToFrontSortCompare(a, b);
  };
  RenderingGroup2.backToFrontSortCompare = function(a, b) {
    if (a._distanceToCamera < b._distanceToCamera) {
      return 1;
    }
    if (a._distanceToCamera > b._distanceToCamera) {
      return -1;
    }
    return 0;
  };
  RenderingGroup2.frontToBackSortCompare = function(a, b) {
    if (a._distanceToCamera < b._distanceToCamera) {
      return -1;
    }
    if (a._distanceToCamera > b._distanceToCamera) {
      return 1;
    }
    return 0;
  };
  RenderingGroup2.prototype.prepare = function() {
    this._opaqueSubMeshes.reset();
    this._transparentSubMeshes.reset();
    this._alphaTestSubMeshes.reset();
    this._depthOnlySubMeshes.reset();
    this._particleSystems.reset();
    this._spriteManagers.reset();
    this._edgesRenderers.reset();
  };
  RenderingGroup2.prototype.dispose = function() {
    this._opaqueSubMeshes.dispose();
    this._transparentSubMeshes.dispose();
    this._alphaTestSubMeshes.dispose();
    this._depthOnlySubMeshes.dispose();
    this._particleSystems.dispose();
    this._spriteManagers.dispose();
    this._edgesRenderers.dispose();
  };
  RenderingGroup2.prototype.dispatch = function(subMesh, mesh, material) {
    if (mesh === void 0) {
      mesh = subMesh.getMesh();
    }
    if (material === void 0) {
      material = subMesh.getMaterial();
    }
    if (material === null || material === void 0) {
      return;
    }
    if (material.needAlphaBlendingForMesh(mesh)) {
      this._transparentSubMeshes.push(subMesh);
    } else if (material.needAlphaTesting()) {
      if (material.needDepthPrePass) {
        this._depthOnlySubMeshes.push(subMesh);
      }
      this._alphaTestSubMeshes.push(subMesh);
    } else {
      if (material.needDepthPrePass) {
        this._depthOnlySubMeshes.push(subMesh);
      }
      this._opaqueSubMeshes.push(subMesh);
    }
    mesh._renderingGroup = this;
    if (mesh._edgesRenderer && mesh._edgesRenderer.isEnabled) {
      this._edgesRenderers.pushNoDuplicate(mesh._edgesRenderer);
    }
  };
  RenderingGroup2.prototype.dispatchSprites = function(spriteManager) {
    this._spriteManagers.push(spriteManager);
  };
  RenderingGroup2.prototype.dispatchParticles = function(particleSystem) {
    this._particleSystems.push(particleSystem);
  };
  RenderingGroup2.prototype._renderParticles = function(activeMeshes) {
    if (this._particleSystems.length === 0) {
      return;
    }
    var activeCamera = this._scene.activeCamera;
    this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);
    for (var particleIndex = 0; particleIndex < this._particleSystems.length; particleIndex++) {
      var particleSystem = this._particleSystems.data[particleIndex];
      if ((activeCamera && activeCamera.layerMask & particleSystem.layerMask) === 0) {
        continue;
      }
      var emitter = particleSystem.emitter;
      if (!emitter.position || !activeMeshes || activeMeshes.indexOf(emitter) !== -1) {
        this._scene._activeParticles.addCount(particleSystem.render(), false);
      }
    }
    this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene);
  };
  RenderingGroup2.prototype._renderSprites = function() {
    if (!this._scene.spritesEnabled || this._spriteManagers.length === 0) {
      return;
    }
    var activeCamera = this._scene.activeCamera;
    this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);
    for (var id = 0; id < this._spriteManagers.length; id++) {
      var spriteManager = this._spriteManagers.data[id];
      if ((activeCamera && activeCamera.layerMask & spriteManager.layerMask) !== 0) {
        spriteManager.render();
      }
    }
    this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene);
  };
  RenderingGroup2._zeroVector = Vector3.Zero();
  return RenderingGroup2;
}();

// node_modules/@babylonjs/core/Rendering/renderingManager.js
var RenderingGroupInfo = function() {
  function RenderingGroupInfo2() {
  }
  return RenderingGroupInfo2;
}();
var RenderingManager = function() {
  function RenderingManager2(scene) {
    this._useSceneAutoClearSetup = false;
    this._renderingGroups = new Array();
    this._autoClearDepthStencil = {};
    this._customOpaqueSortCompareFn = {};
    this._customAlphaTestSortCompareFn = {};
    this._customTransparentSortCompareFn = {};
    this._renderingGroupInfo = new RenderingGroupInfo();
    this._scene = scene;
    for (var i = RenderingManager2.MIN_RENDERINGGROUPS; i < RenderingManager2.MAX_RENDERINGGROUPS; i++) {
      this._autoClearDepthStencil[i] = { autoClear: true, depth: true, stencil: true };
    }
  }
  RenderingManager2.prototype._clearDepthStencilBuffer = function(depth, stencil) {
    if (depth === void 0) {
      depth = true;
    }
    if (stencil === void 0) {
      stencil = true;
    }
    if (this._depthStencilBufferAlreadyCleaned) {
      return;
    }
    this._scene.getEngine().clear(null, false, depth, stencil);
    this._depthStencilBufferAlreadyCleaned = true;
  };
  RenderingManager2.prototype.render = function(customRenderFunction, activeMeshes, renderParticles, renderSprites) {
    var info = this._renderingGroupInfo;
    info.scene = this._scene;
    info.camera = this._scene.activeCamera;
    if (this._scene.spriteManagers && renderSprites) {
      for (var index = 0; index < this._scene.spriteManagers.length; index++) {
        var manager = this._scene.spriteManagers[index];
        this.dispatchSprites(manager);
      }
    }
    for (var index = RenderingManager2.MIN_RENDERINGGROUPS; index < RenderingManager2.MAX_RENDERINGGROUPS; index++) {
      this._depthStencilBufferAlreadyCleaned = index === RenderingManager2.MIN_RENDERINGGROUPS;
      var renderingGroup = this._renderingGroups[index];
      if (!renderingGroup) {
        continue;
      }
      var renderingGroupMask = Math.pow(2, index);
      info.renderingGroupId = index;
      this._scene.onBeforeRenderingGroupObservable.notifyObservers(info, renderingGroupMask);
      if (RenderingManager2.AUTOCLEAR) {
        var autoClear = this._useSceneAutoClearSetup ? this._scene.getAutoClearDepthStencilSetup(index) : this._autoClearDepthStencil[index];
        if (autoClear && autoClear.autoClear) {
          this._clearDepthStencilBuffer(autoClear.depth, autoClear.stencil);
        }
      }
      for (var _i = 0, _a = this._scene._beforeRenderingGroupDrawStage; _i < _a.length; _i++) {
        var step = _a[_i];
        step.action(index);
      }
      renderingGroup.render(customRenderFunction, renderSprites, renderParticles, activeMeshes);
      for (var _b = 0, _c = this._scene._afterRenderingGroupDrawStage; _b < _c.length; _b++) {
        var step = _c[_b];
        step.action(index);
      }
      this._scene.onAfterRenderingGroupObservable.notifyObservers(info, renderingGroupMask);
    }
  };
  RenderingManager2.prototype.reset = function() {
    for (var index = RenderingManager2.MIN_RENDERINGGROUPS; index < RenderingManager2.MAX_RENDERINGGROUPS; index++) {
      var renderingGroup = this._renderingGroups[index];
      if (renderingGroup) {
        renderingGroup.prepare();
      }
    }
  };
  RenderingManager2.prototype.dispose = function() {
    this.freeRenderingGroups();
    this._renderingGroups.length = 0;
    this._renderingGroupInfo = null;
  };
  RenderingManager2.prototype.freeRenderingGroups = function() {
    for (var index = RenderingManager2.MIN_RENDERINGGROUPS; index < RenderingManager2.MAX_RENDERINGGROUPS; index++) {
      var renderingGroup = this._renderingGroups[index];
      if (renderingGroup) {
        renderingGroup.dispose();
      }
    }
  };
  RenderingManager2.prototype._prepareRenderingGroup = function(renderingGroupId) {
    if (this._renderingGroups[renderingGroupId] === void 0) {
      this._renderingGroups[renderingGroupId] = new RenderingGroup(renderingGroupId, this._scene, this._customOpaqueSortCompareFn[renderingGroupId], this._customAlphaTestSortCompareFn[renderingGroupId], this._customTransparentSortCompareFn[renderingGroupId]);
    }
  };
  RenderingManager2.prototype.dispatchSprites = function(spriteManager) {
    var renderingGroupId = spriteManager.renderingGroupId || 0;
    this._prepareRenderingGroup(renderingGroupId);
    this._renderingGroups[renderingGroupId].dispatchSprites(spriteManager);
  };
  RenderingManager2.prototype.dispatchParticles = function(particleSystem) {
    var renderingGroupId = particleSystem.renderingGroupId || 0;
    this._prepareRenderingGroup(renderingGroupId);
    this._renderingGroups[renderingGroupId].dispatchParticles(particleSystem);
  };
  RenderingManager2.prototype.dispatch = function(subMesh, mesh, material) {
    if (mesh === void 0) {
      mesh = subMesh.getMesh();
    }
    var renderingGroupId = mesh.renderingGroupId || 0;
    this._prepareRenderingGroup(renderingGroupId);
    this._renderingGroups[renderingGroupId].dispatch(subMesh, mesh, material);
  };
  RenderingManager2.prototype.setRenderingOrder = function(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {
    if (opaqueSortCompareFn === void 0) {
      opaqueSortCompareFn = null;
    }
    if (alphaTestSortCompareFn === void 0) {
      alphaTestSortCompareFn = null;
    }
    if (transparentSortCompareFn === void 0) {
      transparentSortCompareFn = null;
    }
    this._customOpaqueSortCompareFn[renderingGroupId] = opaqueSortCompareFn;
    this._customAlphaTestSortCompareFn[renderingGroupId] = alphaTestSortCompareFn;
    this._customTransparentSortCompareFn[renderingGroupId] = transparentSortCompareFn;
    if (this._renderingGroups[renderingGroupId]) {
      var group = this._renderingGroups[renderingGroupId];
      group.opaqueSortCompareFn = this._customOpaqueSortCompareFn[renderingGroupId];
      group.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[renderingGroupId];
      group.transparentSortCompareFn = this._customTransparentSortCompareFn[renderingGroupId];
    }
  };
  RenderingManager2.prototype.setRenderingAutoClearDepthStencil = function(renderingGroupId, autoClearDepthStencil, depth, stencil) {
    if (depth === void 0) {
      depth = true;
    }
    if (stencil === void 0) {
      stencil = true;
    }
    this._autoClearDepthStencil[renderingGroupId] = {
      autoClear: autoClearDepthStencil,
      depth,
      stencil
    };
  };
  RenderingManager2.prototype.getAutoClearDepthStencilSetup = function(index) {
    return this._autoClearDepthStencil[index];
  };
  RenderingManager2.MAX_RENDERINGGROUPS = 4;
  RenderingManager2.MIN_RENDERINGGROUPS = 0;
  RenderingManager2.AUTOCLEAR = true;
  return RenderingManager2;
}();

// node_modules/@babylonjs/core/sceneComponent.js
var SceneComponentConstants = function() {
  function SceneComponentConstants2() {
  }
  SceneComponentConstants2.NAME_EFFECTLAYER = "EffectLayer";
  SceneComponentConstants2.NAME_LAYER = "Layer";
  SceneComponentConstants2.NAME_LENSFLARESYSTEM = "LensFlareSystem";
  SceneComponentConstants2.NAME_BOUNDINGBOXRENDERER = "BoundingBoxRenderer";
  SceneComponentConstants2.NAME_PARTICLESYSTEM = "ParticleSystem";
  SceneComponentConstants2.NAME_GAMEPAD = "Gamepad";
  SceneComponentConstants2.NAME_SIMPLIFICATIONQUEUE = "SimplificationQueue";
  SceneComponentConstants2.NAME_GEOMETRYBUFFERRENDERER = "GeometryBufferRenderer";
  SceneComponentConstants2.NAME_PREPASSRENDERER = "PrePassRenderer";
  SceneComponentConstants2.NAME_DEPTHRENDERER = "DepthRenderer";
  SceneComponentConstants2.NAME_POSTPROCESSRENDERPIPELINEMANAGER = "PostProcessRenderPipelineManager";
  SceneComponentConstants2.NAME_SPRITE = "Sprite";
  SceneComponentConstants2.NAME_SUBSURFACE = "SubSurface";
  SceneComponentConstants2.NAME_OUTLINERENDERER = "Outline";
  SceneComponentConstants2.NAME_PROCEDURALTEXTURE = "ProceduralTexture";
  SceneComponentConstants2.NAME_SHADOWGENERATOR = "ShadowGenerator";
  SceneComponentConstants2.NAME_OCTREE = "Octree";
  SceneComponentConstants2.NAME_PHYSICSENGINE = "PhysicsEngine";
  SceneComponentConstants2.NAME_AUDIO = "Audio";
  SceneComponentConstants2.STEP_ISREADYFORMESH_EFFECTLAYER = 0;
  SceneComponentConstants2.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER = 0;
  SceneComponentConstants2.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER = 0;
  SceneComponentConstants2.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER = 0;
  SceneComponentConstants2.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER = 1;
  SceneComponentConstants2.STEP_BEFORECAMERADRAW_EFFECTLAYER = 0;
  SceneComponentConstants2.STEP_BEFORECAMERADRAW_LAYER = 1;
  SceneComponentConstants2.STEP_BEFORECAMERADRAW_PREPASS = 2;
  SceneComponentConstants2.STEP_BEFORERENDERTARGETDRAW_LAYER = 0;
  SceneComponentConstants2.STEP_BEFORERENDERINGMESH_PREPASS = 0;
  SceneComponentConstants2.STEP_BEFORERENDERINGMESH_OUTLINE = 1;
  SceneComponentConstants2.STEP_AFTERRENDERINGMESH_PREPASS = 0;
  SceneComponentConstants2.STEP_AFTERRENDERINGMESH_OUTLINE = 1;
  SceneComponentConstants2.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW = 0;
  SceneComponentConstants2.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER = 1;
  SceneComponentConstants2.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE = 0;
  SceneComponentConstants2.STEP_BEFORECAMERAUPDATE_GAMEPAD = 1;
  SceneComponentConstants2.STEP_BEFORECLEAR_PROCEDURALTEXTURE = 0;
  SceneComponentConstants2.STEP_AFTERRENDERTARGETDRAW_LAYER = 0;
  SceneComponentConstants2.STEP_AFTERCAMERADRAW_EFFECTLAYER = 0;
  SceneComponentConstants2.STEP_AFTERCAMERADRAW_LENSFLARESYSTEM = 1;
  SceneComponentConstants2.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW = 2;
  SceneComponentConstants2.STEP_AFTERCAMERADRAW_LAYER = 3;
  SceneComponentConstants2.STEP_AFTERCAMERADRAW_PREPASS = 4;
  SceneComponentConstants2.STEP_AFTERRENDER_AUDIO = 0;
  SceneComponentConstants2.STEP_GATHERRENDERTARGETS_DEPTHRENDERER = 0;
  SceneComponentConstants2.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER = 1;
  SceneComponentConstants2.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR = 2;
  SceneComponentConstants2.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER = 3;
  SceneComponentConstants2.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER = 0;
  SceneComponentConstants2.STEP_BEFORECLEARSTAGE_PREPASS = 0;
  SceneComponentConstants2.STEP_POINTERMOVE_SPRITE = 0;
  SceneComponentConstants2.STEP_POINTERDOWN_SPRITE = 0;
  SceneComponentConstants2.STEP_POINTERUP_SPRITE = 0;
  return SceneComponentConstants2;
}();
var Stage = function(_super) {
  __extends(Stage2, _super);
  function Stage2(items) {
    return _super.apply(this, items) || this;
  }
  Stage2.Create = function() {
    return Object.create(Stage2.prototype);
  };
  Stage2.prototype.registerStep = function(index, component, action) {
    var i = 0;
    var maxIndex = Number.MAX_VALUE;
    for (; i < this.length; i++) {
      var step = this[i];
      maxIndex = step.index;
      if (index < maxIndex) {
        break;
      }
    }
    this.splice(i, 0, { index, component, action: action.bind(component) });
  };
  Stage2.prototype.clear = function() {
    this.length = 0;
  };
  return Stage2;
}(Array);

// node_modules/@babylonjs/core/Events/pointerEvents.js
var PointerEventTypes = function() {
  function PointerEventTypes2() {
  }
  PointerEventTypes2.POINTERDOWN = 1;
  PointerEventTypes2.POINTERUP = 2;
  PointerEventTypes2.POINTERMOVE = 4;
  PointerEventTypes2.POINTERWHEEL = 8;
  PointerEventTypes2.POINTERPICK = 16;
  PointerEventTypes2.POINTERTAP = 32;
  PointerEventTypes2.POINTERDOUBLETAP = 64;
  return PointerEventTypes2;
}();
var PointerInfoBase = function() {
  function PointerInfoBase2(type, event) {
    this.type = type;
    this.event = event;
  }
  return PointerInfoBase2;
}();
var PointerInfoPre = function(_super) {
  __extends(PointerInfoPre2, _super);
  function PointerInfoPre2(type, event, localX, localY) {
    var _this = _super.call(this, type, event) || this;
    _this.ray = null;
    _this.skipOnPointerObservable = false;
    _this.localPosition = new Vector2(localX, localY);
    return _this;
  }
  return PointerInfoPre2;
}(PointerInfoBase);
var PointerInfo = function(_super) {
  __extends(PointerInfo2, _super);
  function PointerInfo2(type, event, pickInfo) {
    var _this = _super.call(this, type, event) || this;
    _this.pickInfo = pickInfo;
    return _this;
  }
  return PointerInfo2;
}(PointerInfoBase);

// node_modules/@babylonjs/core/Events/keyboardEvents.js
var KeyboardEventTypes = function() {
  function KeyboardEventTypes2() {
  }
  KeyboardEventTypes2.KEYDOWN = 1;
  KeyboardEventTypes2.KEYUP = 2;
  return KeyboardEventTypes2;
}();
var KeyboardInfo = function() {
  function KeyboardInfo2(type, event) {
    this.type = type;
    this.event = event;
  }
  return KeyboardInfo2;
}();
var KeyboardInfoPre = function(_super) {
  __extends(KeyboardInfoPre2, _super);
  function KeyboardInfoPre2(type, event) {
    var _this = _super.call(this, type, event) || this;
    _this.type = type;
    _this.event = event;
    _this.skipOnPointerObservable = false;
    return _this;
  }
  return KeyboardInfoPre2;
}(KeyboardInfo);

// node_modules/@babylonjs/core/Inputs/scene.inputManager.js
var _ClickInfo = function() {
  function _ClickInfo2() {
    this._singleClick = false;
    this._doubleClick = false;
    this._hasSwiped = false;
    this._ignore = false;
  }
  Object.defineProperty(_ClickInfo2.prototype, "singleClick", {
    get: function() {
      return this._singleClick;
    },
    set: function(b) {
      this._singleClick = b;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(_ClickInfo2.prototype, "doubleClick", {
    get: function() {
      return this._doubleClick;
    },
    set: function(b) {
      this._doubleClick = b;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(_ClickInfo2.prototype, "hasSwiped", {
    get: function() {
      return this._hasSwiped;
    },
    set: function(b) {
      this._hasSwiped = b;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(_ClickInfo2.prototype, "ignore", {
    get: function() {
      return this._ignore;
    },
    set: function(b) {
      this._ignore = b;
    },
    enumerable: false,
    configurable: true
  });
  return _ClickInfo2;
}();
var InputManager = function() {
  function InputManager2(scene) {
    this._alreadyAttached = false;
    this._wheelEventName = "";
    this._meshPickProceed = false;
    this._currentPickResult = null;
    this._previousPickResult = null;
    this._totalPointersPressed = 0;
    this._doubleClickOccured = false;
    this._pointerX = 0;
    this._pointerY = 0;
    this._startingPointerPosition = new Vector2(0, 0);
    this._previousStartingPointerPosition = new Vector2(0, 0);
    this._startingPointerTime = 0;
    this._previousStartingPointerTime = 0;
    this._pointerCaptures = {};
    this._meshUnderPointerId = [];
    this._keyboardIsAttached = false;
    this._scene = scene;
  }
  Object.defineProperty(InputManager2.prototype, "meshUnderPointer", {
    get: function() {
      return this._pointerOverMesh;
    },
    enumerable: false,
    configurable: true
  });
  InputManager2.prototype.getMeshUnderPointerByPointerId = function(pointerId) {
    return this._meshUnderPointerId[pointerId];
  };
  Object.defineProperty(InputManager2.prototype, "unTranslatedPointer", {
    get: function() {
      return new Vector2(this._unTranslatedPointerX, this._unTranslatedPointerY);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputManager2.prototype, "pointerX", {
    get: function() {
      return this._pointerX;
    },
    set: function(value) {
      this._pointerX = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputManager2.prototype, "pointerY", {
    get: function() {
      return this._pointerY;
    },
    set: function(value) {
      this._pointerY = value;
    },
    enumerable: false,
    configurable: true
  });
  InputManager2.prototype._updatePointerPosition = function(evt) {
    var canvasRect = this._scene.getEngine().getInputElementClientRect();
    if (!canvasRect) {
      return;
    }
    this._pointerX = evt.clientX - canvasRect.left;
    this._pointerY = evt.clientY - canvasRect.top;
    this._unTranslatedPointerX = this._pointerX;
    this._unTranslatedPointerY = this._pointerY;
  };
  InputManager2.prototype._processPointerMove = function(pickResult, evt) {
    var scene = this._scene;
    var engine = scene.getEngine();
    var canvas = engine.getInputElement();
    if (!canvas) {
      return;
    }
    canvas.tabIndex = engine.canvasTabIndex;
    if (!scene.doNotHandleCursors) {
      canvas.style.cursor = scene.defaultCursor;
    }
    var isMeshPicked = pickResult && pickResult.hit && pickResult.pickedMesh ? true : false;
    if (isMeshPicked) {
      scene.setPointerOverMesh(pickResult.pickedMesh, evt.pointerId);
      if (this._pointerOverMesh && this._pointerOverMesh.actionManager && this._pointerOverMesh.actionManager.hasPointerTriggers) {
        if (!scene.doNotHandleCursors) {
          if (this._pointerOverMesh.actionManager.hoverCursor) {
            canvas.style.cursor = this._pointerOverMesh.actionManager.hoverCursor;
          } else {
            canvas.style.cursor = scene.hoverCursor;
          }
        }
      }
    } else {
      scene.setPointerOverMesh(null, evt.pointerId);
    }
    for (var _i = 0, _a = scene._pointerMoveStage; _i < _a.length; _i++) {
      var step = _a[_i];
      pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, isMeshPicked, canvas);
    }
    if (pickResult) {
      var type = evt.type === this._wheelEventName ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE;
      if (scene.onPointerMove) {
        scene.onPointerMove(evt, pickResult, type);
      }
      if (scene.onPointerObservable.hasObservers()) {
        var pi = new PointerInfo(type, evt, pickResult);
        this._setRayOnPointerInfo(pi);
        scene.onPointerObservable.notifyObservers(pi, type);
      }
    }
  };
  InputManager2.prototype._setRayOnPointerInfo = function(pointerInfo) {
    var scene = this._scene;
    if (pointerInfo.pickInfo && !pointerInfo.pickInfo._pickingUnavailable) {
      if (!pointerInfo.pickInfo.ray) {
        pointerInfo.pickInfo.ray = scene.createPickingRay(pointerInfo.event.offsetX, pointerInfo.event.offsetY, Matrix.Identity(), scene.activeCamera);
      }
    }
  };
  InputManager2.prototype._checkPrePointerObservable = function(pickResult, evt, type) {
    var scene = this._scene;
    var pi = new PointerInfoPre(type, evt, this._unTranslatedPointerX, this._unTranslatedPointerY);
    if (pickResult) {
      pi.ray = pickResult.ray;
    }
    scene.onPrePointerObservable.notifyObservers(pi, type);
    if (pi.skipOnPointerObservable) {
      return true;
    } else {
      return false;
    }
  };
  InputManager2.prototype.simulatePointerMove = function(pickResult, pointerEventInit) {
    var evt = new PointerEvent("pointermove", pointerEventInit);
    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERMOVE)) {
      return;
    }
    this._processPointerMove(pickResult, evt);
  };
  InputManager2.prototype.simulatePointerDown = function(pickResult, pointerEventInit) {
    var evt = new PointerEvent("pointerdown", pointerEventInit);
    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERDOWN)) {
      return;
    }
    this._processPointerDown(pickResult, evt);
  };
  InputManager2.prototype._processPointerDown = function(pickResult, evt) {
    var _this = this;
    var scene = this._scene;
    if (pickResult && pickResult.hit && pickResult.pickedMesh) {
      this._pickedDownMesh = pickResult.pickedMesh;
      var actionManager = pickResult.pickedMesh._getActionManagerForTrigger();
      if (actionManager) {
        if (actionManager.hasPickTriggers) {
          actionManager.processTrigger(5, ActionEvent.CreateNew(pickResult.pickedMesh, evt));
          switch (evt.button) {
            case 0:
              actionManager.processTrigger(2, ActionEvent.CreateNew(pickResult.pickedMesh, evt));
              break;
            case 1:
              actionManager.processTrigger(4, ActionEvent.CreateNew(pickResult.pickedMesh, evt));
              break;
            case 2:
              actionManager.processTrigger(3, ActionEvent.CreateNew(pickResult.pickedMesh, evt));
              break;
          }
        }
        if (actionManager.hasSpecificTrigger(8)) {
          window.setTimeout(function() {
            var pickResult2 = scene.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, function(mesh) {
              return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.actionManager && mesh.actionManager.hasSpecificTrigger(8) && mesh == _this._pickedDownMesh;
            }, false, scene.cameraToUseForPointers);
            if (pickResult2 && pickResult2.hit && pickResult2.pickedMesh && actionManager) {
              if (_this._totalPointersPressed !== 0 && Date.now() - _this._startingPointerTime > InputManager2.LongPressDelay && !_this._isPointerSwiping()) {
                _this._startingPointerTime = 0;
                actionManager.processTrigger(8, ActionEvent.CreateNew(pickResult2.pickedMesh, evt));
              }
            }
          }, InputManager2.LongPressDelay);
        }
      }
    } else {
      for (var _i = 0, _a = scene._pointerDownStage; _i < _a.length; _i++) {
        var step = _a[_i];
        pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt);
      }
    }
    if (pickResult) {
      var type = PointerEventTypes.POINTERDOWN;
      if (scene.onPointerDown) {
        scene.onPointerDown(evt, pickResult, type);
      }
      if (scene.onPointerObservable.hasObservers()) {
        var pi = new PointerInfo(type, evt, pickResult);
        this._setRayOnPointerInfo(pi);
        scene.onPointerObservable.notifyObservers(pi, type);
      }
    }
  };
  InputManager2.prototype._isPointerSwiping = function() {
    return Math.abs(this._startingPointerPosition.x - this._pointerX) > InputManager2.DragMovementThreshold || Math.abs(this._startingPointerPosition.y - this._pointerY) > InputManager2.DragMovementThreshold;
  };
  InputManager2.prototype.simulatePointerUp = function(pickResult, pointerEventInit, doubleTap) {
    var evt = new PointerEvent("pointerup", pointerEventInit);
    var clickInfo = new _ClickInfo();
    if (doubleTap) {
      clickInfo.doubleClick = true;
    } else {
      clickInfo.singleClick = true;
    }
    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERUP)) {
      return;
    }
    this._processPointerUp(pickResult, evt, clickInfo);
  };
  InputManager2.prototype._processPointerUp = function(pickResult, evt, clickInfo) {
    var scene = this._scene;
    if (pickResult && pickResult && pickResult.pickedMesh) {
      this._pickedUpMesh = pickResult.pickedMesh;
      if (this._pickedDownMesh === this._pickedUpMesh) {
        if (scene.onPointerPick) {
          scene.onPointerPick(evt, pickResult);
        }
        if (clickInfo.singleClick && !clickInfo.ignore && scene.onPointerObservable.hasObservers()) {
          var type_1 = PointerEventTypes.POINTERPICK;
          var pi = new PointerInfo(type_1, evt, pickResult);
          this._setRayOnPointerInfo(pi);
          scene.onPointerObservable.notifyObservers(pi, type_1);
        }
      }
      var actionManager = pickResult.pickedMesh._getActionManagerForTrigger();
      if (actionManager && !clickInfo.ignore) {
        actionManager.processTrigger(7, ActionEvent.CreateNew(pickResult.pickedMesh, evt));
        if (!clickInfo.hasSwiped && clickInfo.singleClick) {
          actionManager.processTrigger(1, ActionEvent.CreateNew(pickResult.pickedMesh, evt));
        }
        var doubleClickActionManager = pickResult.pickedMesh._getActionManagerForTrigger(6);
        if (clickInfo.doubleClick && doubleClickActionManager) {
          doubleClickActionManager.processTrigger(6, ActionEvent.CreateNew(pickResult.pickedMesh, evt));
        }
      }
    } else {
      if (!clickInfo.ignore) {
        for (var _i = 0, _a = scene._pointerUpStage; _i < _a.length; _i++) {
          var step = _a[_i];
          pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt);
        }
      }
    }
    if (this._pickedDownMesh && this._pickedDownMesh !== this._pickedUpMesh) {
      var pickedDownActionManager = this._pickedDownMesh._getActionManagerForTrigger(16);
      if (pickedDownActionManager) {
        pickedDownActionManager.processTrigger(16, ActionEvent.CreateNew(this._pickedDownMesh, evt));
      }
    }
    var type = 0;
    if (scene.onPointerObservable.hasObservers()) {
      if (!clickInfo.ignore && !clickInfo.hasSwiped) {
        if (clickInfo.singleClick && scene.onPointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {
          type = PointerEventTypes.POINTERTAP;
        } else if (clickInfo.doubleClick && scene.onPointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {
          type = PointerEventTypes.POINTERDOUBLETAP;
        }
        if (type) {
          var pi = new PointerInfo(type, evt, pickResult);
          this._setRayOnPointerInfo(pi);
          scene.onPointerObservable.notifyObservers(pi, type);
        }
      }
      if (!clickInfo.ignore) {
        type = PointerEventTypes.POINTERUP;
        var pi = new PointerInfo(type, evt, pickResult);
        this._setRayOnPointerInfo(pi);
        scene.onPointerObservable.notifyObservers(pi, type);
      }
    }
    if (scene.onPointerUp && !clickInfo.ignore) {
      scene.onPointerUp(evt, pickResult, type);
    }
  };
  InputManager2.prototype.isPointerCaptured = function(pointerId) {
    if (pointerId === void 0) {
      pointerId = 0;
    }
    return this._pointerCaptures[pointerId];
  };
  InputManager2.prototype.attachControl = function(attachUp, attachDown, attachMove, elementToAttachTo) {
    var _this = this;
    if (attachUp === void 0) {
      attachUp = true;
    }
    if (attachDown === void 0) {
      attachDown = true;
    }
    if (attachMove === void 0) {
      attachMove = true;
    }
    if (elementToAttachTo === void 0) {
      elementToAttachTo = null;
    }
    var scene = this._scene;
    if (!elementToAttachTo) {
      elementToAttachTo = scene.getEngine().getInputElement();
    }
    if (!elementToAttachTo) {
      return;
    }
    if (this._alreadyAttached) {
      this.detachControl();
    }
    this._alreadyAttachedTo = elementToAttachTo;
    var engine = scene.getEngine();
    this._initActionManager = function(act, clickInfo) {
      if (!_this._meshPickProceed) {
        var pickResult = scene.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, scene.pointerDownPredicate, false, scene.cameraToUseForPointers);
        _this._currentPickResult = pickResult;
        if (pickResult) {
          act = pickResult.hit && pickResult.pickedMesh ? pickResult.pickedMesh._getActionManagerForTrigger() : null;
        }
        _this._meshPickProceed = true;
      }
      return act;
    };
    this._delayedSimpleClick = function(btn, clickInfo, cb) {
      if (Date.now() - _this._previousStartingPointerTime > InputManager2.DoubleClickDelay && !_this._doubleClickOccured || btn !== _this._previousButtonPressed) {
        _this._doubleClickOccured = false;
        clickInfo.singleClick = true;
        clickInfo.ignore = false;
        cb(clickInfo, _this._currentPickResult);
      }
    };
    this._initClickEvent = function(obs1, obs2, evt, cb) {
      var clickInfo = new _ClickInfo();
      _this._currentPickResult = null;
      var act = null;
      var checkPicking = obs1.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs2.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs1.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);
      if (!checkPicking && AbstractActionManager) {
        act = _this._initActionManager(act, clickInfo);
        if (act) {
          checkPicking = act.hasPickTriggers;
        }
      }
      var needToIgnoreNext = false;
      if (checkPicking) {
        var btn = evt.button;
        clickInfo.hasSwiped = _this._isPointerSwiping();
        if (!clickInfo.hasSwiped) {
          var checkSingleClickImmediately = !InputManager2.ExclusiveDoubleClickMode;
          if (!checkSingleClickImmediately) {
            checkSingleClickImmediately = !obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) && !obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);
            if (checkSingleClickImmediately && !AbstractActionManager.HasSpecificTrigger(6)) {
              act = _this._initActionManager(act, clickInfo);
              if (act) {
                checkSingleClickImmediately = !act.hasSpecificTrigger(6);
              }
            }
          }
          if (checkSingleClickImmediately) {
            if (Date.now() - _this._previousStartingPointerTime > InputManager2.DoubleClickDelay || btn !== _this._previousButtonPressed) {
              clickInfo.singleClick = true;
              cb(clickInfo, _this._currentPickResult);
              needToIgnoreNext = true;
            }
          } else {
            _this._previousDelayedSimpleClickTimeout = _this._delayedSimpleClickTimeout;
            _this._delayedSimpleClickTimeout = window.setTimeout(_this._delayedSimpleClick.bind(_this, btn, clickInfo, cb), InputManager2.DoubleClickDelay);
          }
          var checkDoubleClick = obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);
          if (!checkDoubleClick && AbstractActionManager.HasSpecificTrigger(6)) {
            act = _this._initActionManager(act, clickInfo);
            if (act) {
              checkDoubleClick = act.hasSpecificTrigger(6);
            }
          }
          if (checkDoubleClick) {
            if (btn === _this._previousButtonPressed && Date.now() - _this._previousStartingPointerTime < InputManager2.DoubleClickDelay && !_this._doubleClickOccured) {
              if (!clickInfo.hasSwiped && !_this._isPointerSwiping()) {
                _this._previousStartingPointerTime = 0;
                _this._doubleClickOccured = true;
                clickInfo.doubleClick = true;
                clickInfo.ignore = false;
                if (InputManager2.ExclusiveDoubleClickMode && _this._previousDelayedSimpleClickTimeout) {
                  clearTimeout(_this._previousDelayedSimpleClickTimeout);
                }
                _this._previousDelayedSimpleClickTimeout = _this._delayedSimpleClickTimeout;
                cb(clickInfo, _this._currentPickResult);
              } else {
                _this._doubleClickOccured = false;
                _this._previousStartingPointerTime = _this._startingPointerTime;
                _this._previousStartingPointerPosition.x = _this._startingPointerPosition.x;
                _this._previousStartingPointerPosition.y = _this._startingPointerPosition.y;
                _this._previousButtonPressed = btn;
                if (InputManager2.ExclusiveDoubleClickMode) {
                  if (_this._previousDelayedSimpleClickTimeout) {
                    clearTimeout(_this._previousDelayedSimpleClickTimeout);
                  }
                  _this._previousDelayedSimpleClickTimeout = _this._delayedSimpleClickTimeout;
                  cb(clickInfo, _this._previousPickResult);
                } else {
                  cb(clickInfo, _this._currentPickResult);
                }
              }
              needToIgnoreNext = true;
            } else {
              _this._doubleClickOccured = false;
              _this._previousStartingPointerTime = _this._startingPointerTime;
              _this._previousStartingPointerPosition.x = _this._startingPointerPosition.x;
              _this._previousStartingPointerPosition.y = _this._startingPointerPosition.y;
              _this._previousButtonPressed = btn;
            }
          }
        }
      }
      if (!needToIgnoreNext) {
        cb(clickInfo, _this._currentPickResult);
      }
    };
    this._onPointerMove = function(evt) {
      if (evt.pointerId === void 0) {
        evt.pointerId = 0;
      }
      _this._updatePointerPosition(evt);
      if (_this._checkPrePointerObservable(null, evt, evt.type === _this._wheelEventName ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE)) {
        return;
      }
      if (!scene.cameraToUseForPointers && !scene.activeCamera) {
        return;
      }
      if (!scene.pointerMovePredicate) {
        scene.pointerMovePredicate = function(mesh) {
          return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (mesh.enablePointerMoveEvents || scene.constantlyUpdateMeshUnderPointer || mesh._getActionManagerForTrigger() != null) && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);
        };
      }
      var pickResult = scene.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, scene.pointerMovePredicate, false, scene.cameraToUseForPointers);
      _this._processPointerMove(pickResult, evt);
    };
    this._onPointerDown = function(evt) {
      _this._totalPointersPressed++;
      _this._pickedDownMesh = null;
      _this._meshPickProceed = false;
      if (evt.pointerId === void 0) {
        evt.pointerId = 0;
      }
      _this._updatePointerPosition(evt);
      if (scene.preventDefaultOnPointerDown && elementToAttachTo) {
        evt.preventDefault();
        elementToAttachTo.focus();
      }
      _this._startingPointerPosition.x = _this._pointerX;
      _this._startingPointerPosition.y = _this._pointerY;
      _this._startingPointerTime = Date.now();
      if (_this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOWN)) {
        return;
      }
      if (!scene.cameraToUseForPointers && !scene.activeCamera) {
        return;
      }
      _this._pointerCaptures[evt.pointerId] = true;
      if (!scene.pointerDownPredicate) {
        scene.pointerDownPredicate = function(mesh) {
          return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);
        };
      }
      _this._pickedDownMesh = null;
      var pickResult = scene.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, scene.pointerDownPredicate, false, scene.cameraToUseForPointers);
      _this._processPointerDown(pickResult, evt);
    };
    this._onPointerUp = function(evt) {
      if (_this._totalPointersPressed === 0) {
        return;
      }
      _this._totalPointersPressed--;
      _this._pickedUpMesh = null;
      _this._meshPickProceed = false;
      if (evt.pointerId === void 0) {
        evt.pointerId = 0;
      }
      _this._updatePointerPosition(evt);
      if (scene.preventDefaultOnPointerUp && elementToAttachTo) {
        evt.preventDefault();
        elementToAttachTo.focus();
      }
      _this._initClickEvent(scene.onPrePointerObservable, scene.onPointerObservable, evt, function(clickInfo, pickResult) {
        if (scene.onPrePointerObservable.hasObservers()) {
          if (!clickInfo.ignore) {
            if (!clickInfo.hasSwiped) {
              if (clickInfo.singleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {
                if (_this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERTAP)) {
                  return;
                }
              }
              if (clickInfo.doubleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {
                if (_this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOUBLETAP)) {
                  return;
                }
              }
            }
            if (_this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERUP)) {
              return;
            }
          }
        }
        if (!_this._pointerCaptures[evt.pointerId]) {
          return;
        }
        _this._pointerCaptures[evt.pointerId] = false;
        if (!scene.cameraToUseForPointers && !scene.activeCamera) {
          return;
        }
        if (!scene.pointerUpPredicate) {
          scene.pointerUpPredicate = function(mesh) {
            return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);
          };
        }
        if (!_this._meshPickProceed && (AbstractActionManager && AbstractActionManager.HasTriggers || scene.onPointerObservable.hasObservers())) {
          _this._initActionManager(null, clickInfo);
        }
        if (!pickResult) {
          pickResult = _this._currentPickResult;
        }
        _this._processPointerUp(pickResult, evt, clickInfo);
        _this._previousPickResult = _this._currentPickResult;
      });
    };
    this._onKeyDown = function(evt) {
      var type = KeyboardEventTypes.KEYDOWN;
      if (scene.onPreKeyboardObservable.hasObservers()) {
        var pi = new KeyboardInfoPre(type, evt);
        scene.onPreKeyboardObservable.notifyObservers(pi, type);
        if (pi.skipOnPointerObservable) {
          return;
        }
      }
      if (scene.onKeyboardObservable.hasObservers()) {
        var pi = new KeyboardInfo(type, evt);
        scene.onKeyboardObservable.notifyObservers(pi, type);
      }
      if (scene.actionManager) {
        scene.actionManager.processTrigger(14, ActionEvent.CreateNewFromScene(scene, evt));
      }
    };
    this._onKeyUp = function(evt) {
      var type = KeyboardEventTypes.KEYUP;
      if (scene.onPreKeyboardObservable.hasObservers()) {
        var pi = new KeyboardInfoPre(type, evt);
        scene.onPreKeyboardObservable.notifyObservers(pi, type);
        if (pi.skipOnPointerObservable) {
          return;
        }
      }
      if (scene.onKeyboardObservable.hasObservers()) {
        var pi = new KeyboardInfo(type, evt);
        scene.onKeyboardObservable.notifyObservers(pi, type);
      }
      if (scene.actionManager) {
        scene.actionManager.processTrigger(15, ActionEvent.CreateNewFromScene(scene, evt));
      }
    };
    var attachedFunction = function() {
      if (!elementToAttachTo || _this._keyboardIsAttached) {
        return;
      }
      elementToAttachTo.addEventListener("keydown", _this._onKeyDown, false);
      elementToAttachTo.addEventListener("keyup", _this._onKeyUp, false);
      _this._keyboardIsAttached = true;
    };
    this._onCanvasFocusObserver = engine.onCanvasFocusObservable.add(function() {
      if (document.activeElement === elementToAttachTo) {
        attachedFunction();
      }
      return attachedFunction;
    }());
    this._onCanvasBlurObserver = engine.onCanvasBlurObservable.add(function() {
      if (!elementToAttachTo) {
        return;
      }
      elementToAttachTo.removeEventListener("keydown", _this._onKeyDown);
      elementToAttachTo.removeEventListener("keyup", _this._onKeyUp);
      _this._keyboardIsAttached = false;
    });
    attachedFunction();
    var eventPrefix = Tools.GetPointerPrefix(engine);
    if (attachMove) {
      elementToAttachTo.addEventListener(eventPrefix + "move", this._onPointerMove, false);
      this._wheelEventName = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll";
      elementToAttachTo.addEventListener(this._wheelEventName, this._onPointerMove, false);
    }
    if (attachDown) {
      elementToAttachTo.addEventListener(eventPrefix + "down", this._onPointerDown, false);
    }
    if (attachUp) {
      var hostWindow = scene.getEngine().getHostWindow();
      if (hostWindow) {
        hostWindow.addEventListener(eventPrefix + "up", this._onPointerUp, false);
      }
    }
    this._alreadyAttached = true;
  };
  InputManager2.prototype.detachControl = function() {
    var engine = this._scene.getEngine();
    var eventPrefix = Tools.GetPointerPrefix(engine);
    if (!this._alreadyAttachedTo) {
      return;
    }
    if (!this._alreadyAttached) {
      return;
    }
    this._alreadyAttachedTo.removeEventListener(eventPrefix + "move", this._onPointerMove);
    this._alreadyAttachedTo.removeEventListener(this._wheelEventName, this._onPointerMove);
    this._alreadyAttachedTo.removeEventListener(eventPrefix + "down", this._onPointerDown);
    window.removeEventListener(eventPrefix + "up", this._onPointerUp);
    if (this._onCanvasBlurObserver) {
      engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);
    }
    if (this._onCanvasFocusObserver) {
      engine.onCanvasFocusObservable.remove(this._onCanvasFocusObserver);
    }
    this._alreadyAttachedTo.removeEventListener("keydown", this._onKeyDown);
    this._alreadyAttachedTo.removeEventListener("keyup", this._onKeyUp);
    if (!this._scene.doNotHandleCursors) {
      this._alreadyAttachedTo.style.cursor = this._scene.defaultCursor;
    }
    this._alreadyAttached = false;
  };
  InputManager2.prototype.setPointerOverMesh = function(mesh, pointerId) {
    if (pointerId === void 0) {
      pointerId = 0;
    }
    if (pointerId < 0) {
      pointerId = 0;
    }
    if (this._meshUnderPointerId[pointerId] === mesh) {
      return;
    }
    var underPointerMesh = this._meshUnderPointerId[pointerId];
    var actionManager;
    if (underPointerMesh) {
      actionManager = underPointerMesh._getActionManagerForTrigger(10);
      if (actionManager) {
        actionManager.processTrigger(10, ActionEvent.CreateNew(underPointerMesh, void 0, { pointerId }));
      }
    }
    this._meshUnderPointerId[pointerId] = mesh;
    this._pointerOverMesh = mesh;
    underPointerMesh = this._meshUnderPointerId[pointerId];
    if (underPointerMesh) {
      actionManager = underPointerMesh._getActionManagerForTrigger(9);
      if (actionManager) {
        actionManager.processTrigger(9, ActionEvent.CreateNew(underPointerMesh, void 0, { pointerId }));
      }
    }
  };
  InputManager2.prototype.getPointerOverMesh = function() {
    return this._pointerOverMesh;
  };
  InputManager2.DragMovementThreshold = 10;
  InputManager2.LongPressDelay = 500;
  InputManager2.DoubleClickDelay = 300;
  InputManager2.ExclusiveDoubleClickMode = false;
  return InputManager2;
}();

// node_modules/@babylonjs/core/Misc/uniqueIdGenerator.js
var UniqueIdGenerator = function() {
  function UniqueIdGenerator2() {
  }
  Object.defineProperty(UniqueIdGenerator2, "UniqueId", {
    get: function() {
      var result = this._UniqueIdCounter;
      this._UniqueIdCounter++;
      return result;
    },
    enumerable: false,
    configurable: true
  });
  UniqueIdGenerator2._UniqueIdCounter = 0;
  return UniqueIdGenerator2;
}();

// node_modules/@babylonjs/core/scene.js
var Scene = function(_super) {
  __extends(Scene2, _super);
  function Scene2(engine, options) {
    var _this = _super.call(this) || this;
    _this._inputManager = new InputManager(_this);
    _this.cameraToUseForPointers = null;
    _this._isScene = true;
    _this._blockEntityCollection = false;
    _this.autoClear = true;
    _this.autoClearDepthAndStencil = true;
    _this.clearColor = new Color4(0.2, 0.2, 0.3, 1);
    _this.ambientColor = new Color3(0, 0, 0);
    _this._environmentIntensity = 1;
    _this._forceWireframe = false;
    _this._skipFrustumClipping = false;
    _this._forcePointsCloud = false;
    _this.animationsEnabled = true;
    _this._animationPropertiesOverride = null;
    _this.useConstantAnimationDeltaTime = false;
    _this.constantlyUpdateMeshUnderPointer = false;
    _this.hoverCursor = "pointer";
    _this.defaultCursor = "";
    _this.doNotHandleCursors = false;
    _this.preventDefaultOnPointerDown = true;
    _this.preventDefaultOnPointerUp = true;
    _this.metadata = null;
    _this.reservedDataStore = null;
    _this.disableOfflineSupportExceptionRules = new Array();
    _this.onDisposeObservable = new Observable();
    _this._onDisposeObserver = null;
    _this.onBeforeRenderObservable = new Observable();
    _this._onBeforeRenderObserver = null;
    _this.onAfterRenderObservable = new Observable();
    _this.onAfterRenderCameraObservable = new Observable();
    _this._onAfterRenderObserver = null;
    _this.onBeforeAnimationsObservable = new Observable();
    _this.onAfterAnimationsObservable = new Observable();
    _this.onBeforeDrawPhaseObservable = new Observable();
    _this.onAfterDrawPhaseObservable = new Observable();
    _this.onReadyObservable = new Observable();
    _this.onBeforeCameraRenderObservable = new Observable();
    _this._onBeforeCameraRenderObserver = null;
    _this.onAfterCameraRenderObservable = new Observable();
    _this._onAfterCameraRenderObserver = null;
    _this.onBeforeActiveMeshesEvaluationObservable = new Observable();
    _this.onAfterActiveMeshesEvaluationObservable = new Observable();
    _this.onBeforeParticlesRenderingObservable = new Observable();
    _this.onAfterParticlesRenderingObservable = new Observable();
    _this.onDataLoadedObservable = new Observable();
    _this.onNewCameraAddedObservable = new Observable();
    _this.onCameraRemovedObservable = new Observable();
    _this.onNewLightAddedObservable = new Observable();
    _this.onLightRemovedObservable = new Observable();
    _this.onNewGeometryAddedObservable = new Observable();
    _this.onGeometryRemovedObservable = new Observable();
    _this.onNewTransformNodeAddedObservable = new Observable();
    _this.onTransformNodeRemovedObservable = new Observable();
    _this.onNewMeshAddedObservable = new Observable();
    _this.onMeshRemovedObservable = new Observable();
    _this.onNewSkeletonAddedObservable = new Observable();
    _this.onSkeletonRemovedObservable = new Observable();
    _this.onNewMaterialAddedObservable = new Observable();
    _this.onNewMultiMaterialAddedObservable = new Observable();
    _this.onMaterialRemovedObservable = new Observable();
    _this.onMultiMaterialRemovedObservable = new Observable();
    _this.onNewTextureAddedObservable = new Observable();
    _this.onTextureRemovedObservable = new Observable();
    _this.onBeforeRenderTargetsRenderObservable = new Observable();
    _this.onAfterRenderTargetsRenderObservable = new Observable();
    _this.onBeforeStepObservable = new Observable();
    _this.onAfterStepObservable = new Observable();
    _this.onActiveCameraChanged = new Observable();
    _this.onBeforeRenderingGroupObservable = new Observable();
    _this.onAfterRenderingGroupObservable = new Observable();
    _this.onMeshImportedObservable = new Observable();
    _this.onAnimationFileImportedObservable = new Observable();
    _this._registeredForLateAnimationBindings = new SmartArrayNoDuplicate(256);
    _this.onPrePointerObservable = new Observable();
    _this.onPointerObservable = new Observable();
    _this.onPreKeyboardObservable = new Observable();
    _this.onKeyboardObservable = new Observable();
    _this._useRightHandedSystem = false;
    _this._timeAccumulator = 0;
    _this._currentStepId = 0;
    _this._currentInternalStep = 0;
    _this._fogEnabled = true;
    _this._fogMode = Scene2.FOGMODE_NONE;
    _this.fogColor = new Color3(0.2, 0.2, 0.3);
    _this.fogDensity = 0.1;
    _this.fogStart = 0;
    _this.fogEnd = 1e3;
    _this.prePass = false;
    _this._shadowsEnabled = true;
    _this._lightsEnabled = true;
    _this.activeCameras = new Array();
    _this._texturesEnabled = true;
    _this.physicsEnabled = true;
    _this.particlesEnabled = true;
    _this.spritesEnabled = true;
    _this._skeletonsEnabled = true;
    _this.lensFlaresEnabled = true;
    _this.collisionsEnabled = true;
    _this.gravity = new Vector3(0, -9.807, 0);
    _this.postProcessesEnabled = true;
    _this.renderTargetsEnabled = true;
    _this.dumpNextRenderTargets = false;
    _this.customRenderTargets = new Array();
    _this.importedMeshesFiles = new Array();
    _this.probesEnabled = true;
    _this._meshesForIntersections = new SmartArrayNoDuplicate(256);
    _this.proceduralTexturesEnabled = true;
    _this._totalVertices = new PerfCounter();
    _this._activeIndices = new PerfCounter();
    _this._activeParticles = new PerfCounter();
    _this._activeBones = new PerfCounter();
    _this._animationTime = 0;
    _this.animationTimeScale = 1;
    _this._renderId = 0;
    _this._frameId = 0;
    _this._executeWhenReadyTimeoutId = -1;
    _this._intermediateRendering = false;
    _this._viewUpdateFlag = -1;
    _this._projectionUpdateFlag = -1;
    _this._toBeDisposed = new Array(256);
    _this._activeRequests = new Array();
    _this._pendingData = new Array();
    _this._isDisposed = false;
    _this.dispatchAllSubMeshesOfActiveMeshes = false;
    _this._activeMeshes = new SmartArray(256);
    _this._processedMaterials = new SmartArray(256);
    _this._renderTargets = new SmartArrayNoDuplicate(256);
    _this._activeParticleSystems = new SmartArray(256);
    _this._activeSkeletons = new SmartArrayNoDuplicate(32);
    _this._softwareSkinnedMeshes = new SmartArrayNoDuplicate(32);
    _this._activeAnimatables = new Array();
    _this._transformMatrix = Matrix.Zero();
    _this.requireLightSorting = false;
    _this._components = [];
    _this._serializableComponents = [];
    _this._transientComponents = [];
    _this._beforeCameraUpdateStage = Stage.Create();
    _this._beforeClearStage = Stage.Create();
    _this._gatherRenderTargetsStage = Stage.Create();
    _this._gatherActiveCameraRenderTargetsStage = Stage.Create();
    _this._isReadyForMeshStage = Stage.Create();
    _this._beforeEvaluateActiveMeshStage = Stage.Create();
    _this._evaluateSubMeshStage = Stage.Create();
    _this._preActiveMeshStage = Stage.Create();
    _this._cameraDrawRenderTargetStage = Stage.Create();
    _this._beforeCameraDrawStage = Stage.Create();
    _this._beforeRenderTargetDrawStage = Stage.Create();
    _this._beforeRenderingGroupDrawStage = Stage.Create();
    _this._beforeRenderingMeshStage = Stage.Create();
    _this._afterRenderingMeshStage = Stage.Create();
    _this._afterRenderingGroupDrawStage = Stage.Create();
    _this._afterCameraDrawStage = Stage.Create();
    _this._afterRenderTargetDrawStage = Stage.Create();
    _this._afterRenderStage = Stage.Create();
    _this._pointerMoveStage = Stage.Create();
    _this._pointerDownStage = Stage.Create();
    _this._pointerUpStage = Stage.Create();
    _this.geometriesByUniqueId = null;
    _this._defaultMeshCandidates = {
      data: [],
      length: 0
    };
    _this._defaultSubMeshCandidates = {
      data: [],
      length: 0
    };
    _this._preventFreeActiveMeshesAndRenderingGroups = false;
    _this._activeMeshesFrozen = false;
    _this._skipEvaluateActiveMeshesCompletely = false;
    _this._allowPostProcessClearColor = true;
    _this.getDeterministicFrameTime = function() {
      return _this._engine.getTimeStep();
    };
    _this._blockMaterialDirtyMechanism = false;
    var fullOptions = __assign({ useGeometryUniqueIdsMap: true, useMaterialMeshMap: true, useClonedMeshMap: true, virtual: false }, options);
    _this._engine = engine || EngineStore.LastCreatedEngine;
    if (!fullOptions.virtual) {
      EngineStore._LastCreatedScene = _this;
      _this._engine.scenes.push(_this);
    }
    _this._uid = null;
    _this._renderingManager = new RenderingManager(_this);
    if (PostProcessManager) {
      _this.postProcessManager = new PostProcessManager(_this);
    }
    if (DomManagement.IsWindowObjectExist()) {
      _this.attachControl();
    }
    _this._createUbo();
    if (ImageProcessingConfiguration) {
      _this._imageProcessingConfiguration = new ImageProcessingConfiguration();
    }
    _this.setDefaultCandidateProviders();
    if (fullOptions.useGeometryUniqueIdsMap) {
      _this.geometriesByUniqueId = {};
    }
    _this.useMaterialMeshMap = fullOptions.useMaterialMeshMap;
    _this.useClonedMeshMap = fullOptions.useClonedMeshMap;
    if (!options || !options.virtual) {
      _this._engine.onNewSceneAddedObservable.notifyObservers(_this);
    }
    return _this;
  }
  Scene2.DefaultMaterialFactory = function(scene) {
    throw _DevTools.WarnImport("StandardMaterial");
  };
  Scene2.CollisionCoordinatorFactory = function() {
    throw _DevTools.WarnImport("DefaultCollisionCoordinator");
  };
  Object.defineProperty(Scene2.prototype, "environmentTexture", {
    get: function() {
      return this._environmentTexture;
    },
    set: function(value) {
      if (this._environmentTexture === value) {
        return;
      }
      this._environmentTexture = value;
      this.markAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "environmentIntensity", {
    get: function() {
      return this._environmentIntensity;
    },
    set: function(value) {
      if (this._environmentIntensity === value) {
        return;
      }
      this._environmentIntensity = value;
      this.markAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "imageProcessingConfiguration", {
    get: function() {
      return this._imageProcessingConfiguration;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "forceWireframe", {
    get: function() {
      return this._forceWireframe;
    },
    set: function(value) {
      if (this._forceWireframe === value) {
        return;
      }
      this._forceWireframe = value;
      this.markAllMaterialsAsDirty(16);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "skipFrustumClipping", {
    get: function() {
      return this._skipFrustumClipping;
    },
    set: function(value) {
      if (this._skipFrustumClipping === value) {
        return;
      }
      this._skipFrustumClipping = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "forcePointsCloud", {
    get: function() {
      return this._forcePointsCloud;
    },
    set: function(value) {
      if (this._forcePointsCloud === value) {
        return;
      }
      this._forcePointsCloud = value;
      this.markAllMaterialsAsDirty(16);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "animationPropertiesOverride", {
    get: function() {
      return this._animationPropertiesOverride;
    },
    set: function(value) {
      this._animationPropertiesOverride = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "onDispose", {
    set: function(callback) {
      if (this._onDisposeObserver) {
        this.onDisposeObservable.remove(this._onDisposeObserver);
      }
      this._onDisposeObserver = this.onDisposeObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "beforeRender", {
    set: function(callback) {
      if (this._onBeforeRenderObserver) {
        this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
      }
      if (callback) {
        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "afterRender", {
    set: function(callback) {
      if (this._onAfterRenderObserver) {
        this.onAfterRenderObservable.remove(this._onAfterRenderObserver);
      }
      if (callback) {
        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "beforeCameraRender", {
    set: function(callback) {
      if (this._onBeforeCameraRenderObserver) {
        this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);
      }
      this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "afterCameraRender", {
    set: function(callback) {
      if (this._onAfterCameraRenderObserver) {
        this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);
      }
      this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "unTranslatedPointer", {
    get: function() {
      return this._inputManager.unTranslatedPointer;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2, "DragMovementThreshold", {
    get: function() {
      return InputManager.DragMovementThreshold;
    },
    set: function(value) {
      InputManager.DragMovementThreshold = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2, "LongPressDelay", {
    get: function() {
      return InputManager.LongPressDelay;
    },
    set: function(value) {
      InputManager.LongPressDelay = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2, "DoubleClickDelay", {
    get: function() {
      return InputManager.DoubleClickDelay;
    },
    set: function(value) {
      InputManager.DoubleClickDelay = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2, "ExclusiveDoubleClickMode", {
    get: function() {
      return InputManager.ExclusiveDoubleClickMode;
    },
    set: function(value) {
      InputManager.ExclusiveDoubleClickMode = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "useRightHandedSystem", {
    get: function() {
      return this._useRightHandedSystem;
    },
    set: function(value) {
      if (this._useRightHandedSystem === value) {
        return;
      }
      this._useRightHandedSystem = value;
      this.markAllMaterialsAsDirty(16);
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.setStepId = function(newStepId) {
    this._currentStepId = newStepId;
  };
  Scene2.prototype.getStepId = function() {
    return this._currentStepId;
  };
  Scene2.prototype.getInternalStep = function() {
    return this._currentInternalStep;
  };
  Object.defineProperty(Scene2.prototype, "fogEnabled", {
    get: function() {
      return this._fogEnabled;
    },
    set: function(value) {
      if (this._fogEnabled === value) {
        return;
      }
      this._fogEnabled = value;
      this.markAllMaterialsAsDirty(16);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "fogMode", {
    get: function() {
      return this._fogMode;
    },
    set: function(value) {
      if (this._fogMode === value) {
        return;
      }
      this._fogMode = value;
      this.markAllMaterialsAsDirty(16);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "shadowsEnabled", {
    get: function() {
      return this._shadowsEnabled;
    },
    set: function(value) {
      if (this._shadowsEnabled === value) {
        return;
      }
      this._shadowsEnabled = value;
      this.markAllMaterialsAsDirty(2);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "lightsEnabled", {
    get: function() {
      return this._lightsEnabled;
    },
    set: function(value) {
      if (this._lightsEnabled === value) {
        return;
      }
      this._lightsEnabled = value;
      this.markAllMaterialsAsDirty(2);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "activeCamera", {
    get: function() {
      return this._activeCamera;
    },
    set: function(value) {
      if (value === this._activeCamera) {
        return;
      }
      this._activeCamera = value;
      this.onActiveCameraChanged.notifyObservers(this);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "defaultMaterial", {
    get: function() {
      if (!this._defaultMaterial) {
        this._defaultMaterial = Scene2.DefaultMaterialFactory(this);
      }
      return this._defaultMaterial;
    },
    set: function(value) {
      this._defaultMaterial = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "texturesEnabled", {
    get: function() {
      return this._texturesEnabled;
    },
    set: function(value) {
      if (this._texturesEnabled === value) {
        return;
      }
      this._texturesEnabled = value;
      this.markAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "skeletonsEnabled", {
    get: function() {
      return this._skeletonsEnabled;
    },
    set: function(value) {
      if (this._skeletonsEnabled === value) {
        return;
      }
      this._skeletonsEnabled = value;
      this.markAllMaterialsAsDirty(8);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "collisionCoordinator", {
    get: function() {
      if (!this._collisionCoordinator) {
        this._collisionCoordinator = Scene2.CollisionCoordinatorFactory();
        this._collisionCoordinator.init(this);
      }
      return this._collisionCoordinator;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "frustumPlanes", {
    get: function() {
      return this._frustumPlanes;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype._registerTransientComponents = function() {
    if (this._transientComponents.length > 0) {
      for (var _i = 0, _a = this._transientComponents; _i < _a.length; _i++) {
        var component = _a[_i];
        component.register();
      }
      this._transientComponents = [];
    }
  };
  Scene2.prototype._addComponent = function(component) {
    this._components.push(component);
    this._transientComponents.push(component);
    var serializableComponent = component;
    if (serializableComponent.addFromContainer && serializableComponent.serialize) {
      this._serializableComponents.push(serializableComponent);
    }
  };
  Scene2.prototype._getComponent = function(name45) {
    for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
      var component = _a[_i];
      if (component.name === name45) {
        return component;
      }
    }
    return null;
  };
  Scene2.prototype.getClassName = function() {
    return "Scene";
  };
  Scene2.prototype._getDefaultMeshCandidates = function() {
    this._defaultMeshCandidates.data = this.meshes;
    this._defaultMeshCandidates.length = this.meshes.length;
    return this._defaultMeshCandidates;
  };
  Scene2.prototype._getDefaultSubMeshCandidates = function(mesh) {
    this._defaultSubMeshCandidates.data = mesh.subMeshes;
    this._defaultSubMeshCandidates.length = mesh.subMeshes.length;
    return this._defaultSubMeshCandidates;
  };
  Scene2.prototype.setDefaultCandidateProviders = function() {
    this.getActiveMeshCandidates = this._getDefaultMeshCandidates.bind(this);
    this.getActiveSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);
    this.getIntersectingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);
    this.getCollidingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);
  };
  Object.defineProperty(Scene2.prototype, "meshUnderPointer", {
    get: function() {
      return this._inputManager.meshUnderPointer;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "pointerX", {
    get: function() {
      return this._inputManager.pointerX;
    },
    set: function(value) {
      this._inputManager.pointerX = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "pointerY", {
    get: function() {
      return this._inputManager.pointerY;
    },
    set: function(value) {
      this._inputManager.pointerY = value;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.getCachedMaterial = function() {
    return this._cachedMaterial;
  };
  Scene2.prototype.getCachedEffect = function() {
    return this._cachedEffect;
  };
  Scene2.prototype.getCachedVisibility = function() {
    return this._cachedVisibility;
  };
  Scene2.prototype.isCachedMaterialInvalid = function(material, effect, visibility) {
    if (visibility === void 0) {
      visibility = 1;
    }
    return this._cachedEffect !== effect || this._cachedMaterial !== material || this._cachedVisibility !== visibility;
  };
  Scene2.prototype.getEngine = function() {
    return this._engine;
  };
  Scene2.prototype.getTotalVertices = function() {
    return this._totalVertices.current;
  };
  Object.defineProperty(Scene2.prototype, "totalVerticesPerfCounter", {
    get: function() {
      return this._totalVertices;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.getActiveIndices = function() {
    return this._activeIndices.current;
  };
  Object.defineProperty(Scene2.prototype, "totalActiveIndicesPerfCounter", {
    get: function() {
      return this._activeIndices;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.getActiveParticles = function() {
    return this._activeParticles.current;
  };
  Object.defineProperty(Scene2.prototype, "activeParticlesPerfCounter", {
    get: function() {
      return this._activeParticles;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.getActiveBones = function() {
    return this._activeBones.current;
  };
  Object.defineProperty(Scene2.prototype, "activeBonesPerfCounter", {
    get: function() {
      return this._activeBones;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.getActiveMeshes = function() {
    return this._activeMeshes;
  };
  Scene2.prototype.getAnimationRatio = function() {
    return this._animationRatio !== void 0 ? this._animationRatio : 1;
  };
  Scene2.prototype.getRenderId = function() {
    return this._renderId;
  };
  Scene2.prototype.getFrameId = function() {
    return this._frameId;
  };
  Scene2.prototype.incrementRenderId = function() {
    this._renderId++;
  };
  Scene2.prototype._createUbo = function() {
    this._sceneUbo = new UniformBuffer(this._engine, void 0, true);
    this._sceneUbo.addUniform("viewProjection", 16);
    this._sceneUbo.addUniform("view", 16);
  };
  Scene2.prototype.simulatePointerMove = function(pickResult, pointerEventInit) {
    this._inputManager.simulatePointerMove(pickResult, pointerEventInit);
    return this;
  };
  Scene2.prototype.simulatePointerDown = function(pickResult, pointerEventInit) {
    this._inputManager.simulatePointerDown(pickResult, pointerEventInit);
    return this;
  };
  Scene2.prototype.simulatePointerUp = function(pickResult, pointerEventInit, doubleTap) {
    this._inputManager.simulatePointerUp(pickResult, pointerEventInit, doubleTap);
    return this;
  };
  Scene2.prototype.isPointerCaptured = function(pointerId) {
    if (pointerId === void 0) {
      pointerId = 0;
    }
    return this._inputManager.isPointerCaptured(pointerId);
  };
  Scene2.prototype.attachControl = function(attachUp, attachDown, attachMove) {
    if (attachUp === void 0) {
      attachUp = true;
    }
    if (attachDown === void 0) {
      attachDown = true;
    }
    if (attachMove === void 0) {
      attachMove = true;
    }
    this._inputManager.attachControl(attachUp, attachDown, attachMove);
  };
  Scene2.prototype.detachControl = function() {
    this._inputManager.detachControl();
  };
  Scene2.prototype.isReady = function() {
    if (this._isDisposed) {
      return false;
    }
    var index;
    var engine = this.getEngine();
    if (!engine.areAllEffectsReady()) {
      return false;
    }
    if (this._pendingData.length > 0) {
      return false;
    }
    for (index = 0; index < this.meshes.length; index++) {
      var mesh = this.meshes[index];
      if (!mesh.isEnabled()) {
        continue;
      }
      if (!mesh.subMeshes || mesh.subMeshes.length === 0) {
        continue;
      }
      if (!mesh.isReady(true)) {
        return false;
      }
      var hardwareInstancedRendering = mesh.hasThinInstances || mesh.getClassName() === "InstancedMesh" || mesh.getClassName() === "InstancedLinesMesh" || engine.getCaps().instancedArrays && mesh.instances.length > 0;
      for (var _i = 0, _a = this._isReadyForMeshStage; _i < _a.length; _i++) {
        var step = _a[_i];
        if (!step.action(mesh, hardwareInstancedRendering)) {
          return false;
        }
      }
    }
    for (index = 0; index < this.geometries.length; index++) {
      var geometry = this.geometries[index];
      if (geometry.delayLoadState === 2) {
        return false;
      }
    }
    if (this.activeCameras && this.activeCameras.length > 0) {
      for (var _b = 0, _c = this.activeCameras; _b < _c.length; _b++) {
        var camera = _c[_b];
        if (!camera.isReady(true)) {
          return false;
        }
      }
    } else if (this.activeCamera) {
      if (!this.activeCamera.isReady(true)) {
        return false;
      }
    }
    for (var _d = 0, _e = this.particleSystems; _d < _e.length; _d++) {
      var particleSystem = _e[_d];
      if (!particleSystem.isReady()) {
        return false;
      }
    }
    return true;
  };
  Scene2.prototype.resetCachedMaterial = function() {
    this._cachedMaterial = null;
    this._cachedEffect = null;
    this._cachedVisibility = null;
  };
  Scene2.prototype.registerBeforeRender = function(func) {
    this.onBeforeRenderObservable.add(func);
  };
  Scene2.prototype.unregisterBeforeRender = function(func) {
    this.onBeforeRenderObservable.removeCallback(func);
  };
  Scene2.prototype.registerAfterRender = function(func) {
    this.onAfterRenderObservable.add(func);
  };
  Scene2.prototype.unregisterAfterRender = function(func) {
    this.onAfterRenderObservable.removeCallback(func);
  };
  Scene2.prototype._executeOnceBeforeRender = function(func) {
    var _this = this;
    var execFunc = function() {
      func();
      setTimeout(function() {
        _this.unregisterBeforeRender(execFunc);
      });
    };
    this.registerBeforeRender(execFunc);
  };
  Scene2.prototype.executeOnceBeforeRender = function(func, timeout) {
    var _this = this;
    if (timeout !== void 0) {
      setTimeout(function() {
        _this._executeOnceBeforeRender(func);
      }, timeout);
    } else {
      this._executeOnceBeforeRender(func);
    }
  };
  Scene2.prototype._addPendingData = function(data) {
    this._pendingData.push(data);
  };
  Scene2.prototype._removePendingData = function(data) {
    var wasLoading = this.isLoading;
    var index = this._pendingData.indexOf(data);
    if (index !== -1) {
      this._pendingData.splice(index, 1);
    }
    if (wasLoading && !this.isLoading) {
      this.onDataLoadedObservable.notifyObservers(this);
    }
  };
  Scene2.prototype.getWaitingItemsCount = function() {
    return this._pendingData.length;
  };
  Object.defineProperty(Scene2.prototype, "isLoading", {
    get: function() {
      return this._pendingData.length > 0;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.executeWhenReady = function(func) {
    var _this = this;
    this.onReadyObservable.add(func);
    if (this._executeWhenReadyTimeoutId !== -1) {
      return;
    }
    this._executeWhenReadyTimeoutId = setTimeout(function() {
      _this._checkIsReady();
    }, 150);
  };
  Scene2.prototype.whenReadyAsync = function() {
    var _this = this;
    return new Promise(function(resolve) {
      _this.executeWhenReady(function() {
        resolve();
      });
    });
  };
  Scene2.prototype._checkIsReady = function() {
    var _this = this;
    this._registerTransientComponents();
    if (this.isReady()) {
      this.onReadyObservable.notifyObservers(this);
      this.onReadyObservable.clear();
      this._executeWhenReadyTimeoutId = -1;
      return;
    }
    if (this._isDisposed) {
      this.onReadyObservable.clear();
      this._executeWhenReadyTimeoutId = -1;
      return;
    }
    this._executeWhenReadyTimeoutId = setTimeout(function() {
      _this._checkIsReady();
    }, 150);
  };
  Object.defineProperty(Scene2.prototype, "animatables", {
    get: function() {
      return this._activeAnimatables;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.resetLastAnimationTimeFrame = function() {
    this._animationTimeLast = PrecisionDate.Now;
  };
  Scene2.prototype.getViewMatrix = function() {
    return this._viewMatrix;
  };
  Scene2.prototype.getProjectionMatrix = function() {
    return this._projectionMatrix;
  };
  Scene2.prototype.getTransformMatrix = function() {
    return this._transformMatrix;
  };
  Scene2.prototype.setTransformMatrix = function(viewL, projectionL, viewR, projectionR) {
    if (this._viewUpdateFlag === viewL.updateFlag && this._projectionUpdateFlag === projectionL.updateFlag) {
      return;
    }
    this._viewUpdateFlag = viewL.updateFlag;
    this._projectionUpdateFlag = projectionL.updateFlag;
    this._viewMatrix = viewL;
    this._projectionMatrix = projectionL;
    this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
    if (!this._frustumPlanes) {
      this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);
    } else {
      Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);
    }
    if (this._multiviewSceneUbo && this._multiviewSceneUbo.useUbo) {
      this._updateMultiviewUbo(viewR, projectionR);
    } else if (this._sceneUbo.useUbo) {
      this._sceneUbo.updateMatrix("viewProjection", this._transformMatrix);
      this._sceneUbo.updateMatrix("view", this._viewMatrix);
      this._sceneUbo.update();
    }
  };
  Scene2.prototype.getSceneUniformBuffer = function() {
    return this._multiviewSceneUbo ? this._multiviewSceneUbo : this._sceneUbo;
  };
  Scene2.prototype.getUniqueId = function() {
    return UniqueIdGenerator.UniqueId;
  };
  Scene2.prototype.addMesh = function(newMesh, recursive) {
    var _this = this;
    if (recursive === void 0) {
      recursive = false;
    }
    if (this._blockEntityCollection) {
      return;
    }
    this.meshes.push(newMesh);
    newMesh._resyncLightSources();
    if (!newMesh.parent) {
      newMesh._addToSceneRootNodes();
    }
    this.onNewMeshAddedObservable.notifyObservers(newMesh);
    if (recursive) {
      newMesh.getChildMeshes().forEach(function(m) {
        _this.addMesh(m);
      });
    }
  };
  Scene2.prototype.removeMesh = function(toRemove, recursive) {
    var _this = this;
    if (recursive === void 0) {
      recursive = false;
    }
    var index = this.meshes.indexOf(toRemove);
    if (index !== -1) {
      this.meshes[index] = this.meshes[this.meshes.length - 1];
      this.meshes.pop();
      if (!toRemove.parent) {
        toRemove._removeFromSceneRootNodes();
      }
    }
    this.onMeshRemovedObservable.notifyObservers(toRemove);
    if (recursive) {
      toRemove.getChildMeshes().forEach(function(m) {
        _this.removeMesh(m);
      });
    }
    return index;
  };
  Scene2.prototype.addTransformNode = function(newTransformNode) {
    if (this._blockEntityCollection) {
      return;
    }
    newTransformNode._indexInSceneTransformNodesArray = this.transformNodes.length;
    this.transformNodes.push(newTransformNode);
    if (!newTransformNode.parent) {
      newTransformNode._addToSceneRootNodes();
    }
    this.onNewTransformNodeAddedObservable.notifyObservers(newTransformNode);
  };
  Scene2.prototype.removeTransformNode = function(toRemove) {
    var index = toRemove._indexInSceneTransformNodesArray;
    if (index !== -1) {
      if (index !== this.transformNodes.length - 1) {
        var lastNode = this.transformNodes[this.transformNodes.length - 1];
        this.transformNodes[index] = lastNode;
        lastNode._indexInSceneTransformNodesArray = index;
      }
      toRemove._indexInSceneTransformNodesArray = -1;
      this.transformNodes.pop();
      if (!toRemove.parent) {
        toRemove._removeFromSceneRootNodes();
      }
    }
    this.onTransformNodeRemovedObservable.notifyObservers(toRemove);
    return index;
  };
  Scene2.prototype.removeSkeleton = function(toRemove) {
    var index = this.skeletons.indexOf(toRemove);
    if (index !== -1) {
      this.skeletons.splice(index, 1);
      this.onSkeletonRemovedObservable.notifyObservers(toRemove);
    }
    return index;
  };
  Scene2.prototype.removeMorphTargetManager = function(toRemove) {
    var index = this.morphTargetManagers.indexOf(toRemove);
    if (index !== -1) {
      this.morphTargetManagers.splice(index, 1);
    }
    return index;
  };
  Scene2.prototype.removeLight = function(toRemove) {
    var index = this.lights.indexOf(toRemove);
    if (index !== -1) {
      for (var _i = 0, _a = this.meshes; _i < _a.length; _i++) {
        var mesh = _a[_i];
        mesh._removeLightSource(toRemove, false);
      }
      this.lights.splice(index, 1);
      this.sortLightsByPriority();
      if (!toRemove.parent) {
        toRemove._removeFromSceneRootNodes();
      }
    }
    this.onLightRemovedObservable.notifyObservers(toRemove);
    return index;
  };
  Scene2.prototype.removeCamera = function(toRemove) {
    var index = this.cameras.indexOf(toRemove);
    if (index !== -1) {
      this.cameras.splice(index, 1);
      if (!toRemove.parent) {
        toRemove._removeFromSceneRootNodes();
      }
    }
    if (this.activeCameras) {
      var index2 = this.activeCameras.indexOf(toRemove);
      if (index2 !== -1) {
        this.activeCameras.splice(index2, 1);
      }
    }
    if (this.activeCamera === toRemove) {
      if (this.cameras.length > 0) {
        this.activeCamera = this.cameras[0];
      } else {
        this.activeCamera = null;
      }
    }
    this.onCameraRemovedObservable.notifyObservers(toRemove);
    return index;
  };
  Scene2.prototype.removeParticleSystem = function(toRemove) {
    var index = this.particleSystems.indexOf(toRemove);
    if (index !== -1) {
      this.particleSystems.splice(index, 1);
    }
    return index;
  };
  Scene2.prototype.removeAnimation = function(toRemove) {
    var index = this.animations.indexOf(toRemove);
    if (index !== -1) {
      this.animations.splice(index, 1);
    }
    return index;
  };
  Scene2.prototype.stopAnimation = function(target, animationName, targetMask) {
  };
  Scene2.prototype.removeAnimationGroup = function(toRemove) {
    var index = this.animationGroups.indexOf(toRemove);
    if (index !== -1) {
      this.animationGroups.splice(index, 1);
    }
    return index;
  };
  Scene2.prototype.removeMultiMaterial = function(toRemove) {
    var index = this.multiMaterials.indexOf(toRemove);
    if (index !== -1) {
      this.multiMaterials.splice(index, 1);
    }
    this.onMultiMaterialRemovedObservable.notifyObservers(toRemove);
    return index;
  };
  Scene2.prototype.removeMaterial = function(toRemove) {
    var index = toRemove._indexInSceneMaterialArray;
    if (index !== -1 && index < this.materials.length) {
      if (index !== this.materials.length - 1) {
        var lastMaterial = this.materials[this.materials.length - 1];
        this.materials[index] = lastMaterial;
        lastMaterial._indexInSceneMaterialArray = index;
      }
      toRemove._indexInSceneMaterialArray = -1;
      this.materials.pop();
    }
    this.onMaterialRemovedObservable.notifyObservers(toRemove);
    return index;
  };
  Scene2.prototype.removeActionManager = function(toRemove) {
    var index = this.actionManagers.indexOf(toRemove);
    if (index !== -1) {
      this.actionManagers.splice(index, 1);
    }
    return index;
  };
  Scene2.prototype.removeTexture = function(toRemove) {
    var index = this.textures.indexOf(toRemove);
    if (index !== -1) {
      this.textures.splice(index, 1);
    }
    this.onTextureRemovedObservable.notifyObservers(toRemove);
    return index;
  };
  Scene2.prototype.addLight = function(newLight) {
    if (this._blockEntityCollection) {
      return;
    }
    this.lights.push(newLight);
    this.sortLightsByPriority();
    if (!newLight.parent) {
      newLight._addToSceneRootNodes();
    }
    for (var _i = 0, _a = this.meshes; _i < _a.length; _i++) {
      var mesh = _a[_i];
      if (mesh.lightSources.indexOf(newLight) === -1) {
        mesh.lightSources.push(newLight);
        mesh._resyncLightSources();
      }
    }
    this.onNewLightAddedObservable.notifyObservers(newLight);
  };
  Scene2.prototype.sortLightsByPriority = function() {
    if (this.requireLightSorting) {
      this.lights.sort(Light.CompareLightsPriority);
    }
  };
  Scene2.prototype.addCamera = function(newCamera) {
    if (this._blockEntityCollection) {
      return;
    }
    this.cameras.push(newCamera);
    this.onNewCameraAddedObservable.notifyObservers(newCamera);
    if (!newCamera.parent) {
      newCamera._addToSceneRootNodes();
    }
  };
  Scene2.prototype.addSkeleton = function(newSkeleton) {
    if (this._blockEntityCollection) {
      return;
    }
    this.skeletons.push(newSkeleton);
    this.onNewSkeletonAddedObservable.notifyObservers(newSkeleton);
  };
  Scene2.prototype.addParticleSystem = function(newParticleSystem) {
    if (this._blockEntityCollection) {
      return;
    }
    this.particleSystems.push(newParticleSystem);
  };
  Scene2.prototype.addAnimation = function(newAnimation) {
    if (this._blockEntityCollection) {
      return;
    }
    this.animations.push(newAnimation);
  };
  Scene2.prototype.addAnimationGroup = function(newAnimationGroup) {
    if (this._blockEntityCollection) {
      return;
    }
    this.animationGroups.push(newAnimationGroup);
  };
  Scene2.prototype.addMultiMaterial = function(newMultiMaterial) {
    if (this._blockEntityCollection) {
      return;
    }
    this.multiMaterials.push(newMultiMaterial);
    this.onNewMultiMaterialAddedObservable.notifyObservers(newMultiMaterial);
  };
  Scene2.prototype.addMaterial = function(newMaterial) {
    if (this._blockEntityCollection) {
      return;
    }
    newMaterial._indexInSceneMaterialArray = this.materials.length;
    this.materials.push(newMaterial);
    this.onNewMaterialAddedObservable.notifyObservers(newMaterial);
  };
  Scene2.prototype.addMorphTargetManager = function(newMorphTargetManager) {
    if (this._blockEntityCollection) {
      return;
    }
    this.morphTargetManagers.push(newMorphTargetManager);
  };
  Scene2.prototype.addGeometry = function(newGeometry) {
    if (this._blockEntityCollection) {
      return;
    }
    if (this.geometriesByUniqueId) {
      this.geometriesByUniqueId[newGeometry.uniqueId] = this.geometries.length;
    }
    this.geometries.push(newGeometry);
  };
  Scene2.prototype.addActionManager = function(newActionManager) {
    this.actionManagers.push(newActionManager);
  };
  Scene2.prototype.addTexture = function(newTexture) {
    if (this._blockEntityCollection) {
      return;
    }
    this.textures.push(newTexture);
    this.onNewTextureAddedObservable.notifyObservers(newTexture);
  };
  Scene2.prototype.switchActiveCamera = function(newCamera, attachControl) {
    if (attachControl === void 0) {
      attachControl = true;
    }
    var canvas = this._engine.getInputElement();
    if (!canvas) {
      return;
    }
    if (this.activeCamera) {
      this.activeCamera.detachControl();
    }
    this.activeCamera = newCamera;
    if (attachControl) {
      newCamera.attachControl();
    }
  };
  Scene2.prototype.setActiveCameraByID = function(id) {
    var camera = this.getCameraByID(id);
    if (camera) {
      this.activeCamera = camera;
      return camera;
    }
    return null;
  };
  Scene2.prototype.setActiveCameraByName = function(name45) {
    var camera = this.getCameraByName(name45);
    if (camera) {
      this.activeCamera = camera;
      return camera;
    }
    return null;
  };
  Scene2.prototype.getAnimationGroupByName = function(name45) {
    for (var index = 0; index < this.animationGroups.length; index++) {
      if (this.animationGroups[index].name === name45) {
        return this.animationGroups[index];
      }
    }
    return null;
  };
  Scene2.prototype.getMaterialByUniqueID = function(uniqueId) {
    for (var index = 0; index < this.materials.length; index++) {
      if (this.materials[index].uniqueId === uniqueId) {
        return this.materials[index];
      }
    }
    return null;
  };
  Scene2.prototype.getMaterialByID = function(id) {
    for (var index = 0; index < this.materials.length; index++) {
      if (this.materials[index].id === id) {
        return this.materials[index];
      }
    }
    return null;
  };
  Scene2.prototype.getLastMaterialByID = function(id) {
    for (var index = this.materials.length - 1; index >= 0; index--) {
      if (this.materials[index].id === id) {
        return this.materials[index];
      }
    }
    return null;
  };
  Scene2.prototype.getMaterialByName = function(name45) {
    for (var index = 0; index < this.materials.length; index++) {
      if (this.materials[index].name === name45) {
        return this.materials[index];
      }
    }
    return null;
  };
  Scene2.prototype.getTextureByUniqueID = function(uniqueId) {
    for (var index = 0; index < this.textures.length; index++) {
      if (this.textures[index].uniqueId === uniqueId) {
        return this.textures[index];
      }
    }
    return null;
  };
  Scene2.prototype.getCameraByID = function(id) {
    for (var index = 0; index < this.cameras.length; index++) {
      if (this.cameras[index].id === id) {
        return this.cameras[index];
      }
    }
    return null;
  };
  Scene2.prototype.getCameraByUniqueID = function(uniqueId) {
    for (var index = 0; index < this.cameras.length; index++) {
      if (this.cameras[index].uniqueId === uniqueId) {
        return this.cameras[index];
      }
    }
    return null;
  };
  Scene2.prototype.getCameraByName = function(name45) {
    for (var index = 0; index < this.cameras.length; index++) {
      if (this.cameras[index].name === name45) {
        return this.cameras[index];
      }
    }
    return null;
  };
  Scene2.prototype.getBoneByID = function(id) {
    for (var skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {
      var skeleton = this.skeletons[skeletonIndex];
      for (var boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {
        if (skeleton.bones[boneIndex].id === id) {
          return skeleton.bones[boneIndex];
        }
      }
    }
    return null;
  };
  Scene2.prototype.getBoneByName = function(name45) {
    for (var skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {
      var skeleton = this.skeletons[skeletonIndex];
      for (var boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {
        if (skeleton.bones[boneIndex].name === name45) {
          return skeleton.bones[boneIndex];
        }
      }
    }
    return null;
  };
  Scene2.prototype.getLightByName = function(name45) {
    for (var index = 0; index < this.lights.length; index++) {
      if (this.lights[index].name === name45) {
        return this.lights[index];
      }
    }
    return null;
  };
  Scene2.prototype.getLightByID = function(id) {
    for (var index = 0; index < this.lights.length; index++) {
      if (this.lights[index].id === id) {
        return this.lights[index];
      }
    }
    return null;
  };
  Scene2.prototype.getLightByUniqueID = function(uniqueId) {
    for (var index = 0; index < this.lights.length; index++) {
      if (this.lights[index].uniqueId === uniqueId) {
        return this.lights[index];
      }
    }
    return null;
  };
  Scene2.prototype.getParticleSystemByID = function(id) {
    for (var index = 0; index < this.particleSystems.length; index++) {
      if (this.particleSystems[index].id === id) {
        return this.particleSystems[index];
      }
    }
    return null;
  };
  Scene2.prototype.getGeometryByID = function(id) {
    for (var index = 0; index < this.geometries.length; index++) {
      if (this.geometries[index].id === id) {
        return this.geometries[index];
      }
    }
    return null;
  };
  Scene2.prototype._getGeometryByUniqueID = function(uniqueId) {
    if (this.geometriesByUniqueId) {
      var index_1 = this.geometriesByUniqueId[uniqueId];
      if (index_1 !== void 0) {
        return this.geometries[index_1];
      }
    } else {
      for (var index = 0; index < this.geometries.length; index++) {
        if (this.geometries[index].uniqueId === uniqueId) {
          return this.geometries[index];
        }
      }
    }
    return null;
  };
  Scene2.prototype.pushGeometry = function(geometry, force) {
    if (!force && this._getGeometryByUniqueID(geometry.uniqueId)) {
      return false;
    }
    this.addGeometry(geometry);
    this.onNewGeometryAddedObservable.notifyObservers(geometry);
    return true;
  };
  Scene2.prototype.removeGeometry = function(geometry) {
    var index;
    if (this.geometriesByUniqueId) {
      index = this.geometriesByUniqueId[geometry.uniqueId];
      if (index === void 0) {
        return false;
      }
    } else {
      index = this.geometries.indexOf(geometry);
      if (index < 0) {
        return false;
      }
    }
    if (index !== this.geometries.length - 1) {
      var lastGeometry = this.geometries[this.geometries.length - 1];
      if (lastGeometry) {
        this.geometries[index] = lastGeometry;
        if (this.geometriesByUniqueId) {
          this.geometriesByUniqueId[lastGeometry.uniqueId] = index;
          this.geometriesByUniqueId[geometry.uniqueId] = void 0;
        }
      }
    }
    this.geometries.pop();
    this.onGeometryRemovedObservable.notifyObservers(geometry);
    return true;
  };
  Scene2.prototype.getGeometries = function() {
    return this.geometries;
  };
  Scene2.prototype.getMeshByID = function(id) {
    for (var index = 0; index < this.meshes.length; index++) {
      if (this.meshes[index].id === id) {
        return this.meshes[index];
      }
    }
    return null;
  };
  Scene2.prototype.getMeshesByID = function(id) {
    return this.meshes.filter(function(m) {
      return m.id === id;
    });
  };
  Scene2.prototype.getTransformNodeByID = function(id) {
    for (var index = 0; index < this.transformNodes.length; index++) {
      if (this.transformNodes[index].id === id) {
        return this.transformNodes[index];
      }
    }
    return null;
  };
  Scene2.prototype.getTransformNodeByUniqueID = function(uniqueId) {
    for (var index = 0; index < this.transformNodes.length; index++) {
      if (this.transformNodes[index].uniqueId === uniqueId) {
        return this.transformNodes[index];
      }
    }
    return null;
  };
  Scene2.prototype.getTransformNodesByID = function(id) {
    return this.transformNodes.filter(function(m) {
      return m.id === id;
    });
  };
  Scene2.prototype.getMeshByUniqueID = function(uniqueId) {
    for (var index = 0; index < this.meshes.length; index++) {
      if (this.meshes[index].uniqueId === uniqueId) {
        return this.meshes[index];
      }
    }
    return null;
  };
  Scene2.prototype.getLastMeshByID = function(id) {
    for (var index = this.meshes.length - 1; index >= 0; index--) {
      if (this.meshes[index].id === id) {
        return this.meshes[index];
      }
    }
    return null;
  };
  Scene2.prototype.getLastEntryByID = function(id) {
    var index;
    for (index = this.meshes.length - 1; index >= 0; index--) {
      if (this.meshes[index].id === id) {
        return this.meshes[index];
      }
    }
    for (index = this.transformNodes.length - 1; index >= 0; index--) {
      if (this.transformNodes[index].id === id) {
        return this.transformNodes[index];
      }
    }
    for (index = this.cameras.length - 1; index >= 0; index--) {
      if (this.cameras[index].id === id) {
        return this.cameras[index];
      }
    }
    for (index = this.lights.length - 1; index >= 0; index--) {
      if (this.lights[index].id === id) {
        return this.lights[index];
      }
    }
    return null;
  };
  Scene2.prototype.getNodeByID = function(id) {
    var mesh = this.getMeshByID(id);
    if (mesh) {
      return mesh;
    }
    var transformNode = this.getTransformNodeByID(id);
    if (transformNode) {
      return transformNode;
    }
    var light = this.getLightByID(id);
    if (light) {
      return light;
    }
    var camera = this.getCameraByID(id);
    if (camera) {
      return camera;
    }
    var bone = this.getBoneByID(id);
    if (bone) {
      return bone;
    }
    return null;
  };
  Scene2.prototype.getNodeByName = function(name45) {
    var mesh = this.getMeshByName(name45);
    if (mesh) {
      return mesh;
    }
    var transformNode = this.getTransformNodeByName(name45);
    if (transformNode) {
      return transformNode;
    }
    var light = this.getLightByName(name45);
    if (light) {
      return light;
    }
    var camera = this.getCameraByName(name45);
    if (camera) {
      return camera;
    }
    var bone = this.getBoneByName(name45);
    if (bone) {
      return bone;
    }
    return null;
  };
  Scene2.prototype.getMeshByName = function(name45) {
    for (var index = 0; index < this.meshes.length; index++) {
      if (this.meshes[index].name === name45) {
        return this.meshes[index];
      }
    }
    return null;
  };
  Scene2.prototype.getTransformNodeByName = function(name45) {
    for (var index = 0; index < this.transformNodes.length; index++) {
      if (this.transformNodes[index].name === name45) {
        return this.transformNodes[index];
      }
    }
    return null;
  };
  Scene2.prototype.getLastSkeletonByID = function(id) {
    for (var index = this.skeletons.length - 1; index >= 0; index--) {
      if (this.skeletons[index].id === id) {
        return this.skeletons[index];
      }
    }
    return null;
  };
  Scene2.prototype.getSkeletonByUniqueId = function(uniqueId) {
    for (var index = 0; index < this.skeletons.length; index++) {
      if (this.skeletons[index].uniqueId === uniqueId) {
        return this.skeletons[index];
      }
    }
    return null;
  };
  Scene2.prototype.getSkeletonById = function(id) {
    for (var index = 0; index < this.skeletons.length; index++) {
      if (this.skeletons[index].id === id) {
        return this.skeletons[index];
      }
    }
    return null;
  };
  Scene2.prototype.getSkeletonByName = function(name45) {
    for (var index = 0; index < this.skeletons.length; index++) {
      if (this.skeletons[index].name === name45) {
        return this.skeletons[index];
      }
    }
    return null;
  };
  Scene2.prototype.getMorphTargetManagerById = function(id) {
    for (var index = 0; index < this.morphTargetManagers.length; index++) {
      if (this.morphTargetManagers[index].uniqueId === id) {
        return this.morphTargetManagers[index];
      }
    }
    return null;
  };
  Scene2.prototype.getMorphTargetById = function(id) {
    for (var managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {
      var morphTargetManager = this.morphTargetManagers[managerIndex];
      for (var index = 0; index < morphTargetManager.numTargets; ++index) {
        var target = morphTargetManager.getTarget(index);
        if (target.id === id) {
          return target;
        }
      }
    }
    return null;
  };
  Scene2.prototype.getMorphTargetByName = function(name45) {
    for (var managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {
      var morphTargetManager = this.morphTargetManagers[managerIndex];
      for (var index = 0; index < morphTargetManager.numTargets; ++index) {
        var target = morphTargetManager.getTarget(index);
        if (target.name === name45) {
          return target;
        }
      }
    }
    return null;
  };
  Scene2.prototype.getPostProcessByName = function(name45) {
    for (var postProcessIndex = 0; postProcessIndex < this.postProcesses.length; ++postProcessIndex) {
      var postProcess = this.postProcesses[postProcessIndex];
      if (postProcess.name === name45) {
        return postProcess;
      }
    }
    return null;
  };
  Scene2.prototype.isActiveMesh = function(mesh) {
    return this._activeMeshes.indexOf(mesh) !== -1;
  };
  Object.defineProperty(Scene2.prototype, "uid", {
    get: function() {
      if (!this._uid) {
        this._uid = Tools.RandomId();
      }
      return this._uid;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.addExternalData = function(key, data) {
    if (!this._externalData) {
      this._externalData = new StringDictionary();
    }
    return this._externalData.add(key, data);
  };
  Scene2.prototype.getExternalData = function(key) {
    if (!this._externalData) {
      return null;
    }
    return this._externalData.get(key);
  };
  Scene2.prototype.getOrAddExternalDataWithFactory = function(key, factory) {
    if (!this._externalData) {
      this._externalData = new StringDictionary();
    }
    return this._externalData.getOrAddWithFactory(key, factory);
  };
  Scene2.prototype.removeExternalData = function(key) {
    return this._externalData.remove(key);
  };
  Scene2.prototype._evaluateSubMesh = function(subMesh, mesh, initialMesh) {
    if (initialMesh.hasInstances || initialMesh.isAnInstance || this.dispatchAllSubMeshesOfActiveMeshes || this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh || mesh.subMeshes.length === 1 || subMesh.isInFrustum(this._frustumPlanes)) {
      for (var _i = 0, _a = this._evaluateSubMeshStage; _i < _a.length; _i++) {
        var step = _a[_i];
        step.action(mesh, subMesh);
      }
      var material = subMesh.getMaterial();
      if (material !== null && material !== void 0) {
        if (material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {
          if (this._processedMaterials.indexOf(material) === -1) {
            this._processedMaterials.push(material);
            this._renderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());
          }
        }
        this._renderingManager.dispatch(subMesh, mesh, material);
      }
    }
  };
  Scene2.prototype.freeProcessedMaterials = function() {
    this._processedMaterials.dispose();
  };
  Object.defineProperty(Scene2.prototype, "blockfreeActiveMeshesAndRenderingGroups", {
    get: function() {
      return this._preventFreeActiveMeshesAndRenderingGroups;
    },
    set: function(value) {
      if (this._preventFreeActiveMeshesAndRenderingGroups === value) {
        return;
      }
      if (value) {
        this.freeActiveMeshes();
        this.freeRenderingGroups();
      }
      this._preventFreeActiveMeshesAndRenderingGroups = value;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.freeActiveMeshes = function() {
    if (this.blockfreeActiveMeshesAndRenderingGroups) {
      return;
    }
    this._activeMeshes.dispose();
    if (this.activeCamera && this.activeCamera._activeMeshes) {
      this.activeCamera._activeMeshes.dispose();
    }
    if (this.activeCameras) {
      for (var i = 0; i < this.activeCameras.length; i++) {
        var activeCamera = this.activeCameras[i];
        if (activeCamera && activeCamera._activeMeshes) {
          activeCamera._activeMeshes.dispose();
        }
      }
    }
  };
  Scene2.prototype.freeRenderingGroups = function() {
    if (this.blockfreeActiveMeshesAndRenderingGroups) {
      return;
    }
    if (this._renderingManager) {
      this._renderingManager.freeRenderingGroups();
    }
    if (this.textures) {
      for (var i = 0; i < this.textures.length; i++) {
        var texture = this.textures[i];
        if (texture && texture.renderList) {
          texture.freeRenderingGroups();
        }
      }
    }
  };
  Scene2.prototype._isInIntermediateRendering = function() {
    return this._intermediateRendering;
  };
  Scene2.prototype.freezeActiveMeshes = function(skipEvaluateActiveMeshes, onSuccess, onError) {
    var _this = this;
    if (skipEvaluateActiveMeshes === void 0) {
      skipEvaluateActiveMeshes = false;
    }
    this.executeWhenReady(function() {
      if (!_this.activeCamera) {
        onError && onError("No active camera found");
        return;
      }
      if (!_this._frustumPlanes) {
        _this.setTransformMatrix(_this.activeCamera.getViewMatrix(), _this.activeCamera.getProjectionMatrix());
      }
      _this._evaluateActiveMeshes();
      _this._activeMeshesFrozen = true;
      _this._skipEvaluateActiveMeshesCompletely = skipEvaluateActiveMeshes;
      for (var index = 0; index < _this._activeMeshes.length; index++) {
        _this._activeMeshes.data[index]._freeze();
      }
      onSuccess && onSuccess();
    });
    return this;
  };
  Scene2.prototype.unfreezeActiveMeshes = function() {
    for (var index = 0; index < this.meshes.length; index++) {
      var mesh = this.meshes[index];
      if (mesh._internalAbstractMeshDataInfo) {
        mesh._internalAbstractMeshDataInfo._isActive = false;
      }
    }
    for (var index = 0; index < this._activeMeshes.length; index++) {
      this._activeMeshes.data[index]._unFreeze();
    }
    this._activeMeshesFrozen = false;
    return this;
  };
  Scene2.prototype._evaluateActiveMeshes = function() {
    if (this._activeMeshesFrozen && this._activeMeshes.length) {
      if (!this._skipEvaluateActiveMeshesCompletely) {
        var len_1 = this._activeMeshes.length;
        for (var i = 0; i < len_1; i++) {
          var mesh = this._activeMeshes.data[i];
          mesh.computeWorldMatrix();
        }
      }
      if (this._activeParticleSystems) {
        var psLength = this._activeParticleSystems.length;
        for (var i = 0; i < psLength; i++) {
          this._activeParticleSystems.data[i].animate();
        }
      }
      return;
    }
    if (!this.activeCamera) {
      return;
    }
    this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this);
    this.activeCamera._activeMeshes.reset();
    this._activeMeshes.reset();
    this._renderingManager.reset();
    this._processedMaterials.reset();
    this._activeParticleSystems.reset();
    this._activeSkeletons.reset();
    this._softwareSkinnedMeshes.reset();
    for (var _i = 0, _a = this._beforeEvaluateActiveMeshStage; _i < _a.length; _i++) {
      var step = _a[_i];
      step.action();
    }
    var meshes = this.getActiveMeshCandidates();
    var len = meshes.length;
    for (var i = 0; i < len; i++) {
      var mesh = meshes.data[i];
      mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = false;
      if (mesh.isBlocked) {
        continue;
      }
      this._totalVertices.addCount(mesh.getTotalVertices(), false);
      if (!mesh.isReady() || !mesh.isEnabled() || mesh.scaling.lengthSquared() === 0) {
        continue;
      }
      mesh.computeWorldMatrix();
      if (mesh.actionManager && mesh.actionManager.hasSpecificTriggers2(12, 13)) {
        this._meshesForIntersections.pushNoDuplicate(mesh);
      }
      var meshToRender = this.customLODSelector ? this.customLODSelector(mesh, this.activeCamera) : mesh.getLOD(this.activeCamera);
      mesh._internalAbstractMeshDataInfo._currentLOD = meshToRender;
      mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = true;
      if (meshToRender === void 0 || meshToRender === null) {
        continue;
      }
      if (meshToRender !== mesh && meshToRender.billboardMode !== TransformNode.BILLBOARDMODE_NONE) {
        meshToRender.computeWorldMatrix();
      }
      mesh._preActivate();
      if (mesh.isVisible && mesh.visibility > 0 && (mesh.layerMask & this.activeCamera.layerMask) !== 0 && (this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh || mesh.isInFrustum(this._frustumPlanes))) {
        this._activeMeshes.push(mesh);
        this.activeCamera._activeMeshes.push(mesh);
        if (meshToRender !== mesh) {
          meshToRender._activate(this._renderId, false);
        }
        for (var _b = 0, _c = this._preActiveMeshStage; _b < _c.length; _b++) {
          var step = _c[_b];
          step.action(mesh);
        }
        if (mesh._activate(this._renderId, false)) {
          if (!mesh.isAnInstance) {
            meshToRender._internalAbstractMeshDataInfo._onlyForInstances = false;
          } else {
            if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {
              meshToRender = mesh;
            }
          }
          meshToRender._internalAbstractMeshDataInfo._isActive = true;
          this._activeMesh(mesh, meshToRender);
        }
        mesh._postActivate();
      }
    }
    this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this);
    if (this.particlesEnabled) {
      this.onBeforeParticlesRenderingObservable.notifyObservers(this);
      for (var particleIndex = 0; particleIndex < this.particleSystems.length; particleIndex++) {
        var particleSystem = this.particleSystems[particleIndex];
        if (!particleSystem.isStarted() || !particleSystem.emitter) {
          continue;
        }
        var emitter = particleSystem.emitter;
        if (!emitter.position || emitter.isEnabled()) {
          this._activeParticleSystems.push(particleSystem);
          particleSystem.animate();
          this._renderingManager.dispatchParticles(particleSystem);
        }
      }
      this.onAfterParticlesRenderingObservable.notifyObservers(this);
    }
  };
  Scene2.prototype._activeMesh = function(sourceMesh, mesh) {
    if (this._skeletonsEnabled && mesh.skeleton !== null && mesh.skeleton !== void 0) {
      if (this._activeSkeletons.pushNoDuplicate(mesh.skeleton)) {
        mesh.skeleton.prepare();
      }
      if (!mesh.computeBonesUsingShaders) {
        this._softwareSkinnedMeshes.pushNoDuplicate(mesh);
      }
    }
    if (mesh !== void 0 && mesh !== null && mesh.subMeshes !== void 0 && mesh.subMeshes !== null && mesh.subMeshes.length > 0) {
      var subMeshes = this.getActiveSubMeshCandidates(mesh);
      var len = subMeshes.length;
      for (var i = 0; i < len; i++) {
        var subMesh = subMeshes.data[i];
        this._evaluateSubMesh(subMesh, mesh, sourceMesh);
      }
    }
  };
  Scene2.prototype.updateTransformMatrix = function(force) {
    if (!this.activeCamera) {
      return;
    }
    this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(force));
  };
  Scene2.prototype._bindFrameBuffer = function() {
    if (this.activeCamera && this.activeCamera._multiviewTexture) {
      this.activeCamera._multiviewTexture._bindFrameBuffer();
    } else if (this.activeCamera && this.activeCamera.outputRenderTarget) {
      var useMultiview = this.getEngine().getCaps().multiview && this.activeCamera.outputRenderTarget && this.activeCamera.outputRenderTarget.getViewCount() > 1;
      if (useMultiview) {
        this.activeCamera.outputRenderTarget._bindFrameBuffer();
      } else {
        var internalTexture = this.activeCamera.outputRenderTarget.getInternalTexture();
        if (internalTexture) {
          this.getEngine().bindFramebuffer(internalTexture);
        } else {
          Logger.Error("Camera contains invalid customDefaultRenderTarget");
        }
      }
    } else {
      this.getEngine().restoreDefaultFramebuffer();
    }
  };
  Scene2.prototype._renderForCamera = function(camera, rigParent) {
    if (camera && camera._skipRendering) {
      return;
    }
    var engine = this._engine;
    this._activeCamera = camera;
    if (!this.activeCamera) {
      throw new Error("Active camera not set");
    }
    engine.setViewport(this.activeCamera.viewport);
    this.resetCachedMaterial();
    this._renderId++;
    var useMultiview = this.getEngine().getCaps().multiview && camera.outputRenderTarget && camera.outputRenderTarget.getViewCount() > 1;
    if (useMultiview) {
      this.setTransformMatrix(camera._rigCameras[0].getViewMatrix(), camera._rigCameras[0].getProjectionMatrix(), camera._rigCameras[1].getViewMatrix(), camera._rigCameras[1].getProjectionMatrix());
    } else {
      this.updateTransformMatrix();
    }
    this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera);
    this._evaluateActiveMeshes();
    for (var softwareSkinnedMeshIndex = 0; softwareSkinnedMeshIndex < this._softwareSkinnedMeshes.length; softwareSkinnedMeshIndex++) {
      var mesh = this._softwareSkinnedMeshes.data[softwareSkinnedMeshIndex];
      mesh.applySkeleton(mesh.skeleton);
    }
    this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);
    if (camera.customRenderTargets && camera.customRenderTargets.length > 0) {
      this._renderTargets.concatWithNoDuplicate(camera.customRenderTargets);
    }
    if (rigParent && rigParent.customRenderTargets && rigParent.customRenderTargets.length > 0) {
      this._renderTargets.concatWithNoDuplicate(rigParent.customRenderTargets);
    }
    for (var _i = 0, _a = this._gatherActiveCameraRenderTargetsStage; _i < _a.length; _i++) {
      var step = _a[_i];
      step.action(this._renderTargets);
    }
    var needRebind = false;
    if (this.renderTargetsEnabled) {
      this._intermediateRendering = true;
      if (this._renderTargets.length > 0) {
        Tools.StartPerformanceCounter("Render targets", this._renderTargets.length > 0);
        for (var renderIndex = 0; renderIndex < this._renderTargets.length; renderIndex++) {
          var renderTarget = this._renderTargets.data[renderIndex];
          if (renderTarget._shouldRender()) {
            this._renderId++;
            var hasSpecialRenderTargetCamera = renderTarget.activeCamera && renderTarget.activeCamera !== this.activeCamera;
            renderTarget.render(hasSpecialRenderTargetCamera, this.dumpNextRenderTargets);
            needRebind = true;
          }
        }
        Tools.EndPerformanceCounter("Render targets", this._renderTargets.length > 0);
        this._renderId++;
      }
      for (var _b = 0, _c = this._cameraDrawRenderTargetStage; _b < _c.length; _b++) {
        var step = _c[_b];
        needRebind = step.action(this.activeCamera) || needRebind;
      }
      this._intermediateRendering = false;
      if (this.activeCamera && this.activeCamera.outputRenderTarget) {
        needRebind = true;
      }
    }
    if (needRebind && !this.prePass) {
      this._bindFrameBuffer();
    }
    this.onAfterRenderTargetsRenderObservable.notifyObservers(this);
    if (this.postProcessManager && !camera._multiviewTexture && !this.prePass) {
      this.postProcessManager._prepareFrame();
    }
    for (var _d = 0, _e = this._beforeCameraDrawStage; _d < _e.length; _d++) {
      var step = _e[_d];
      step.action(this.activeCamera);
    }
    this.onBeforeDrawPhaseObservable.notifyObservers(this);
    this._renderingManager.render(null, null, true, true);
    this.onAfterDrawPhaseObservable.notifyObservers(this);
    for (var _f = 0, _g = this._afterCameraDrawStage; _f < _g.length; _f++) {
      var step = _g[_f];
      step.action(this.activeCamera);
    }
    if (this.postProcessManager && !camera._multiviewTexture) {
      var texture = camera.outputRenderTarget ? camera.outputRenderTarget.getInternalTexture() : void 0;
      this.postProcessManager._finalizeFrame(camera.isIntermediate, texture);
    }
    this._renderTargets.reset();
    this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera);
  };
  Scene2.prototype._processSubCameras = function(camera) {
    if (camera.cameraRigMode === Camera.RIG_MODE_NONE || camera.outputRenderTarget && camera.outputRenderTarget.getViewCount() > 1 && this.getEngine().getCaps().multiview) {
      this._renderForCamera(camera);
      this.onAfterRenderCameraObservable.notifyObservers(camera);
      return;
    }
    if (camera._useMultiviewToSingleView) {
      this._renderMultiviewToSingleView(camera);
    } else {
      for (var index = 0; index < camera._rigCameras.length; index++) {
        this._renderForCamera(camera._rigCameras[index], camera);
      }
    }
    this._activeCamera = camera;
    this.setTransformMatrix(this._activeCamera.getViewMatrix(), this._activeCamera.getProjectionMatrix());
    this.onAfterRenderCameraObservable.notifyObservers(camera);
  };
  Scene2.prototype._checkIntersections = function() {
    for (var index = 0; index < this._meshesForIntersections.length; index++) {
      var sourceMesh = this._meshesForIntersections.data[index];
      if (!sourceMesh.actionManager) {
        continue;
      }
      for (var actionIndex = 0; sourceMesh.actionManager && actionIndex < sourceMesh.actionManager.actions.length; actionIndex++) {
        var action = sourceMesh.actionManager.actions[actionIndex];
        if (action.trigger === 12 || action.trigger === 13) {
          var parameters = action.getTriggerParameter();
          var otherMesh = parameters instanceof AbstractMesh ? parameters : parameters.mesh;
          var areIntersecting = otherMesh.intersectsMesh(sourceMesh, parameters.usePreciseIntersection);
          var currentIntersectionInProgress = sourceMesh._intersectionsInProgress.indexOf(otherMesh);
          if (areIntersecting && currentIntersectionInProgress === -1) {
            if (action.trigger === 12) {
              action._executeCurrent(ActionEvent.CreateNew(sourceMesh, void 0, otherMesh));
              sourceMesh._intersectionsInProgress.push(otherMesh);
            } else if (action.trigger === 13) {
              sourceMesh._intersectionsInProgress.push(otherMesh);
            }
          } else if (!areIntersecting && currentIntersectionInProgress > -1) {
            if (action.trigger === 13) {
              action._executeCurrent(ActionEvent.CreateNew(sourceMesh, void 0, otherMesh));
            }
            if (!sourceMesh.actionManager.hasSpecificTrigger(13, function(parameter) {
              var parameterMesh = parameter instanceof AbstractMesh ? parameter : parameter.mesh;
              return otherMesh === parameterMesh;
            }) || action.trigger === 13) {
              sourceMesh._intersectionsInProgress.splice(currentIntersectionInProgress, 1);
            }
          }
        }
      }
    }
  };
  Scene2.prototype._advancePhysicsEngineStep = function(step) {
  };
  Scene2.prototype._animate = function() {
  };
  Scene2.prototype.animate = function() {
    if (this._engine.isDeterministicLockStep()) {
      var deltaTime = Math.max(Scene2.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene2.MaxDeltaTime)) + this._timeAccumulator;
      var defaultFrameTime = this._engine.getTimeStep();
      var defaultFPS = 1e3 / defaultFrameTime / 1e3;
      var stepsTaken = 0;
      var maxSubSteps = this._engine.getLockstepMaxSteps();
      var internalSteps = Math.floor(deltaTime / defaultFrameTime);
      internalSteps = Math.min(internalSteps, maxSubSteps);
      while (deltaTime > 0 && stepsTaken < internalSteps) {
        this.onBeforeStepObservable.notifyObservers(this);
        this._animationRatio = defaultFrameTime * defaultFPS;
        this._animate();
        this.onAfterAnimationsObservable.notifyObservers(this);
        if (this.physicsEnabled) {
          this._advancePhysicsEngineStep(defaultFrameTime);
        }
        this.onAfterStepObservable.notifyObservers(this);
        this._currentStepId++;
        stepsTaken++;
        deltaTime -= defaultFrameTime;
      }
      this._timeAccumulator = deltaTime < 0 ? 0 : deltaTime;
    } else {
      var deltaTime = this.useConstantAnimationDeltaTime ? 16 : Math.max(Scene2.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene2.MaxDeltaTime));
      this._animationRatio = deltaTime * (60 / 1e3);
      this._animate();
      this.onAfterAnimationsObservable.notifyObservers(this);
      if (this.physicsEnabled) {
        this._advancePhysicsEngineStep(deltaTime);
      }
    }
  };
  Scene2.prototype.render = function(updateCameras, ignoreAnimations) {
    if (updateCameras === void 0) {
      updateCameras = true;
    }
    if (ignoreAnimations === void 0) {
      ignoreAnimations = false;
    }
    if (this.isDisposed) {
      return;
    }
    if (this.onReadyObservable.hasObservers() && this._executeWhenReadyTimeoutId === -1) {
      this._checkIsReady();
    }
    this._frameId++;
    this._registerTransientComponents();
    this._activeParticles.fetchNewFrame();
    this._totalVertices.fetchNewFrame();
    this._activeIndices.fetchNewFrame();
    this._activeBones.fetchNewFrame();
    this._meshesForIntersections.reset();
    this.resetCachedMaterial();
    this.onBeforeAnimationsObservable.notifyObservers(this);
    if (this.actionManager) {
      this.actionManager.processTrigger(11);
    }
    if (!ignoreAnimations) {
      this.animate();
    }
    for (var _i = 0, _a = this._beforeCameraUpdateStage; _i < _a.length; _i++) {
      var step = _a[_i];
      step.action();
    }
    if (updateCameras) {
      if (this.activeCameras && this.activeCameras.length > 0) {
        for (var cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {
          var camera = this.activeCameras[cameraIndex];
          camera.update();
          if (camera.cameraRigMode !== Camera.RIG_MODE_NONE) {
            for (var index = 0; index < camera._rigCameras.length; index++) {
              camera._rigCameras[index].update();
            }
          }
        }
      } else if (this.activeCamera) {
        this.activeCamera.update();
        if (this.activeCamera.cameraRigMode !== Camera.RIG_MODE_NONE) {
          for (var index = 0; index < this.activeCamera._rigCameras.length; index++) {
            this.activeCamera._rigCameras[index].update();
          }
        }
      }
    }
    this.onBeforeRenderObservable.notifyObservers(this);
    this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);
    var engine = this.getEngine();
    var currentActiveCamera = this.activeCamera;
    if (this.renderTargetsEnabled) {
      Tools.StartPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0);
      this._intermediateRendering = true;
      for (var customIndex = 0; customIndex < this.customRenderTargets.length; customIndex++) {
        var renderTarget = this.customRenderTargets[customIndex];
        if (renderTarget._shouldRender()) {
          this._renderId++;
          this.activeCamera = renderTarget.activeCamera || this.activeCamera;
          if (!this.activeCamera) {
            throw new Error("Active camera not set");
          }
          engine.setViewport(this.activeCamera.viewport);
          this.updateTransformMatrix();
          renderTarget.render(currentActiveCamera !== this.activeCamera, this.dumpNextRenderTargets);
        }
      }
      Tools.EndPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0);
      this._intermediateRendering = false;
      this._renderId++;
    }
    this.activeCamera = currentActiveCamera;
    if (this._activeCamera && this._activeCamera.cameraRigMode !== Camera.RIG_MODE_CUSTOM && !this.prePass) {
      this._bindFrameBuffer();
    }
    this.onAfterRenderTargetsRenderObservable.notifyObservers(this);
    for (var _b = 0, _c = this._beforeClearStage; _b < _c.length; _b++) {
      var step = _c[_b];
      step.action();
    }
    if ((this.autoClearDepthAndStencil || this.autoClear) && !this.prePass) {
      this._engine.clear(this.clearColor, this.autoClear || this.forceWireframe || this.forcePointsCloud, this.autoClearDepthAndStencil, this.autoClearDepthAndStencil);
    }
    for (var _d = 0, _e = this._gatherRenderTargetsStage; _d < _e.length; _d++) {
      var step = _e[_d];
      step.action(this._renderTargets);
    }
    if (this.activeCameras && this.activeCameras.length > 0) {
      for (var cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {
        if (cameraIndex > 0) {
          this._engine.clear(null, false, true, true);
        }
        this._processSubCameras(this.activeCameras[cameraIndex]);
      }
    } else {
      if (!this.activeCamera) {
        throw new Error("No camera defined");
      }
      this._processSubCameras(this.activeCamera);
    }
    this._checkIntersections();
    for (var _f = 0, _g = this._afterRenderStage; _f < _g.length; _f++) {
      var step = _g[_f];
      step.action();
    }
    if (this.afterRender) {
      this.afterRender();
    }
    this.onAfterRenderObservable.notifyObservers(this);
    if (this._toBeDisposed.length) {
      for (var index = 0; index < this._toBeDisposed.length; index++) {
        var data = this._toBeDisposed[index];
        if (data) {
          data.dispose();
        }
      }
      this._toBeDisposed = [];
    }
    if (this.dumpNextRenderTargets) {
      this.dumpNextRenderTargets = false;
    }
    this._activeBones.addCount(0, true);
    this._activeIndices.addCount(0, true);
    this._activeParticles.addCount(0, true);
  };
  Scene2.prototype.freezeMaterials = function() {
    for (var i = 0; i < this.materials.length; i++) {
      this.materials[i].freeze();
    }
  };
  Scene2.prototype.unfreezeMaterials = function() {
    for (var i = 0; i < this.materials.length; i++) {
      this.materials[i].unfreeze();
    }
  };
  Scene2.prototype.dispose = function() {
    this.beforeRender = null;
    this.afterRender = null;
    if (EngineStore._LastCreatedScene === this) {
      EngineStore._LastCreatedScene = null;
    }
    this.skeletons = [];
    this.morphTargetManagers = [];
    this._transientComponents = [];
    this._isReadyForMeshStage.clear();
    this._beforeEvaluateActiveMeshStage.clear();
    this._evaluateSubMeshStage.clear();
    this._preActiveMeshStage.clear();
    this._cameraDrawRenderTargetStage.clear();
    this._beforeCameraDrawStage.clear();
    this._beforeRenderTargetDrawStage.clear();
    this._beforeRenderingGroupDrawStage.clear();
    this._beforeRenderingMeshStage.clear();
    this._afterRenderingMeshStage.clear();
    this._afterRenderingGroupDrawStage.clear();
    this._afterCameraDrawStage.clear();
    this._afterRenderTargetDrawStage.clear();
    this._afterRenderStage.clear();
    this._beforeCameraUpdateStage.clear();
    this._beforeClearStage.clear();
    this._gatherRenderTargetsStage.clear();
    this._gatherActiveCameraRenderTargetsStage.clear();
    this._pointerMoveStage.clear();
    this._pointerDownStage.clear();
    this._pointerUpStage.clear();
    for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
      var component = _a[_i];
      component.dispose();
    }
    this.importedMeshesFiles = new Array();
    if (this.stopAllAnimations) {
      this.stopAllAnimations();
    }
    this.resetCachedMaterial();
    if (this.activeCamera) {
      this.activeCamera._activeMeshes.dispose();
      this.activeCamera = null;
    }
    this._activeMeshes.dispose();
    this._renderingManager.dispose();
    this._processedMaterials.dispose();
    this._activeParticleSystems.dispose();
    this._activeSkeletons.dispose();
    this._softwareSkinnedMeshes.dispose();
    this._renderTargets.dispose();
    this._registeredForLateAnimationBindings.dispose();
    this._meshesForIntersections.dispose();
    this._toBeDisposed = [];
    for (var _b = 0, _c = this._activeRequests; _b < _c.length; _b++) {
      var request = _c[_b];
      request.abort();
    }
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    this.onBeforeRenderObservable.clear();
    this.onAfterRenderObservable.clear();
    this.onBeforeRenderTargetsRenderObservable.clear();
    this.onAfterRenderTargetsRenderObservable.clear();
    this.onAfterStepObservable.clear();
    this.onBeforeStepObservable.clear();
    this.onBeforeActiveMeshesEvaluationObservable.clear();
    this.onAfterActiveMeshesEvaluationObservable.clear();
    this.onBeforeParticlesRenderingObservable.clear();
    this.onAfterParticlesRenderingObservable.clear();
    this.onBeforeDrawPhaseObservable.clear();
    this.onAfterDrawPhaseObservable.clear();
    this.onBeforeAnimationsObservable.clear();
    this.onAfterAnimationsObservable.clear();
    this.onDataLoadedObservable.clear();
    this.onBeforeRenderingGroupObservable.clear();
    this.onAfterRenderingGroupObservable.clear();
    this.onMeshImportedObservable.clear();
    this.onBeforeCameraRenderObservable.clear();
    this.onAfterCameraRenderObservable.clear();
    this.onReadyObservable.clear();
    this.onNewCameraAddedObservable.clear();
    this.onCameraRemovedObservable.clear();
    this.onNewLightAddedObservable.clear();
    this.onLightRemovedObservable.clear();
    this.onNewGeometryAddedObservable.clear();
    this.onGeometryRemovedObservable.clear();
    this.onNewTransformNodeAddedObservable.clear();
    this.onTransformNodeRemovedObservable.clear();
    this.onNewMeshAddedObservable.clear();
    this.onMeshRemovedObservable.clear();
    this.onNewSkeletonAddedObservable.clear();
    this.onSkeletonRemovedObservable.clear();
    this.onNewMaterialAddedObservable.clear();
    this.onNewMultiMaterialAddedObservable.clear();
    this.onMaterialRemovedObservable.clear();
    this.onMultiMaterialRemovedObservable.clear();
    this.onNewTextureAddedObservable.clear();
    this.onTextureRemovedObservable.clear();
    this.onPrePointerObservable.clear();
    this.onPointerObservable.clear();
    this.onPreKeyboardObservable.clear();
    this.onKeyboardObservable.clear();
    this.onActiveCameraChanged.clear();
    this.detachControl();
    var canvas = this._engine.getInputElement();
    if (canvas) {
      var index;
      for (index = 0; index < this.cameras.length; index++) {
        this.cameras[index].detachControl();
      }
    }
    while (this.animationGroups.length) {
      this.animationGroups[0].dispose();
    }
    while (this.lights.length) {
      this.lights[0].dispose();
    }
    while (this.meshes.length) {
      this.meshes[0].dispose(true);
    }
    while (this.transformNodes.length) {
      this.transformNodes[0].dispose(true);
    }
    while (this.cameras.length) {
      this.cameras[0].dispose();
    }
    if (this._defaultMaterial) {
      this._defaultMaterial.dispose();
    }
    while (this.multiMaterials.length) {
      this.multiMaterials[0].dispose();
    }
    while (this.materials.length) {
      this.materials[0].dispose();
    }
    while (this.particleSystems.length) {
      this.particleSystems[0].dispose();
    }
    while (this.postProcesses.length) {
      this.postProcesses[0].dispose();
    }
    while (this.textures.length) {
      this.textures[0].dispose();
    }
    this._sceneUbo.dispose();
    if (this._multiviewSceneUbo) {
      this._multiviewSceneUbo.dispose();
    }
    this.postProcessManager.dispose();
    index = this._engine.scenes.indexOf(this);
    if (index > -1) {
      this._engine.scenes.splice(index, 1);
    }
    this._engine.wipeCaches(true);
    this._isDisposed = true;
  };
  Object.defineProperty(Scene2.prototype, "isDisposed", {
    get: function() {
      return this._isDisposed;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.clearCachedVertexData = function() {
    for (var meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {
      var mesh = this.meshes[meshIndex];
      var geometry = mesh.geometry;
      if (geometry) {
        geometry._indices = [];
        for (var vbName in geometry._vertexBuffers) {
          if (!geometry._vertexBuffers.hasOwnProperty(vbName)) {
            continue;
          }
          geometry._vertexBuffers[vbName]._buffer._data = null;
        }
      }
    }
  };
  Scene2.prototype.cleanCachedTextureBuffer = function() {
    for (var _i = 0, _a = this.textures; _i < _a.length; _i++) {
      var baseTexture = _a[_i];
      var buffer = baseTexture._buffer;
      if (buffer) {
        baseTexture._buffer = null;
      }
    }
  };
  Scene2.prototype.getWorldExtends = function(filterPredicate) {
    var min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    var max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    filterPredicate = filterPredicate || function() {
      return true;
    };
    this.meshes.filter(filterPredicate).forEach(function(mesh) {
      mesh.computeWorldMatrix(true);
      if (!mesh.subMeshes || mesh.subMeshes.length === 0 || mesh.infiniteDistance) {
        return;
      }
      var boundingInfo = mesh.getBoundingInfo();
      var minBox = boundingInfo.boundingBox.minimumWorld;
      var maxBox = boundingInfo.boundingBox.maximumWorld;
      Vector3.CheckExtends(minBox, min, max);
      Vector3.CheckExtends(maxBox, min, max);
    });
    return {
      min,
      max
    };
  };
  Scene2.prototype.createPickingRay = function(x, y, world, camera, cameraViewSpace) {
    if (cameraViewSpace === void 0) {
      cameraViewSpace = false;
    }
    throw _DevTools.WarnImport("Ray");
  };
  Scene2.prototype.createPickingRayToRef = function(x, y, world, result, camera, cameraViewSpace) {
    if (cameraViewSpace === void 0) {
      cameraViewSpace = false;
    }
    throw _DevTools.WarnImport("Ray");
  };
  Scene2.prototype.createPickingRayInCameraSpace = function(x, y, camera) {
    throw _DevTools.WarnImport("Ray");
  };
  Scene2.prototype.createPickingRayInCameraSpaceToRef = function(x, y, result, camera) {
    throw _DevTools.WarnImport("Ray");
  };
  Scene2.prototype.pick = function(x, y, predicate, fastCheck, camera, trianglePredicate) {
    var pi = new PickingInfo();
    pi._pickingUnavailable = true;
    return pi;
  };
  Scene2.prototype.pickWithBoundingInfo = function(x, y, predicate, fastCheck, camera) {
    var pi = new PickingInfo();
    pi._pickingUnavailable = true;
    return pi;
  };
  Scene2.prototype.pickWithRay = function(ray, predicate, fastCheck, trianglePredicate) {
    throw _DevTools.WarnImport("Ray");
  };
  Scene2.prototype.multiPick = function(x, y, predicate, camera, trianglePredicate) {
    throw _DevTools.WarnImport("Ray");
  };
  Scene2.prototype.multiPickWithRay = function(ray, predicate, trianglePredicate) {
    throw _DevTools.WarnImport("Ray");
  };
  Scene2.prototype.setPointerOverMesh = function(mesh, pointerId) {
    this._inputManager.setPointerOverMesh(mesh, pointerId);
  };
  Scene2.prototype.getPointerOverMesh = function() {
    return this._inputManager.getPointerOverMesh();
  };
  Scene2.prototype._rebuildGeometries = function() {
    for (var _i = 0, _a = this.geometries; _i < _a.length; _i++) {
      var geometry = _a[_i];
      geometry._rebuild();
    }
    for (var _b = 0, _c = this.meshes; _b < _c.length; _b++) {
      var mesh = _c[_b];
      mesh._rebuild();
    }
    if (this.postProcessManager) {
      this.postProcessManager._rebuild();
    }
    for (var _d = 0, _e = this._components; _d < _e.length; _d++) {
      var component = _e[_d];
      component.rebuild();
    }
    for (var _f = 0, _g = this.particleSystems; _f < _g.length; _f++) {
      var system = _g[_f];
      system.rebuild();
    }
  };
  Scene2.prototype._rebuildTextures = function() {
    for (var _i = 0, _a = this.textures; _i < _a.length; _i++) {
      var texture = _a[_i];
      texture._rebuild();
    }
    this.markAllMaterialsAsDirty(1);
  };
  Scene2.prototype._getByTags = function(list, tagsQuery, forEach) {
    if (tagsQuery === void 0) {
      return list;
    }
    var listByTags = [];
    forEach = forEach || function(item2) {
      return;
    };
    for (var i in list) {
      var item = list[i];
      if (Tags && Tags.MatchesQuery(item, tagsQuery)) {
        listByTags.push(item);
        forEach(item);
      }
    }
    return listByTags;
  };
  Scene2.prototype.getMeshesByTags = function(tagsQuery, forEach) {
    return this._getByTags(this.meshes, tagsQuery, forEach);
  };
  Scene2.prototype.getCamerasByTags = function(tagsQuery, forEach) {
    return this._getByTags(this.cameras, tagsQuery, forEach);
  };
  Scene2.prototype.getLightsByTags = function(tagsQuery, forEach) {
    return this._getByTags(this.lights, tagsQuery, forEach);
  };
  Scene2.prototype.getMaterialByTags = function(tagsQuery, forEach) {
    return this._getByTags(this.materials, tagsQuery, forEach).concat(this._getByTags(this.multiMaterials, tagsQuery, forEach));
  };
  Scene2.prototype.getTransformNodesByTags = function(tagsQuery, forEach) {
    return this._getByTags(this.transformNodes, tagsQuery, forEach);
  };
  Scene2.prototype.setRenderingOrder = function(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {
    if (opaqueSortCompareFn === void 0) {
      opaqueSortCompareFn = null;
    }
    if (alphaTestSortCompareFn === void 0) {
      alphaTestSortCompareFn = null;
    }
    if (transparentSortCompareFn === void 0) {
      transparentSortCompareFn = null;
    }
    this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);
  };
  Scene2.prototype.setRenderingAutoClearDepthStencil = function(renderingGroupId, autoClearDepthStencil, depth, stencil) {
    if (depth === void 0) {
      depth = true;
    }
    if (stencil === void 0) {
      stencil = true;
    }
    this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth, stencil);
  };
  Scene2.prototype.getAutoClearDepthStencilSetup = function(index) {
    return this._renderingManager.getAutoClearDepthStencilSetup(index);
  };
  Object.defineProperty(Scene2.prototype, "blockMaterialDirtyMechanism", {
    get: function() {
      return this._blockMaterialDirtyMechanism;
    },
    set: function(value) {
      if (this._blockMaterialDirtyMechanism === value) {
        return;
      }
      this._blockMaterialDirtyMechanism = value;
      if (!value) {
        this.markAllMaterialsAsDirty(63);
      }
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.markAllMaterialsAsDirty = function(flag, predicate) {
    if (this._blockMaterialDirtyMechanism) {
      return;
    }
    for (var _i = 0, _a = this.materials; _i < _a.length; _i++) {
      var material = _a[_i];
      if (predicate && !predicate(material)) {
        continue;
      }
      material.markAsDirty(flag);
    }
  };
  Scene2.prototype._loadFile = function(url, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError) {
    var _this = this;
    var request = FileTools.LoadFile(url, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : void 0, useArrayBuffer, onError);
    this._activeRequests.push(request);
    request.onCompleteObservable.add(function(request2) {
      _this._activeRequests.splice(_this._activeRequests.indexOf(request2), 1);
    });
    return request;
  };
  Scene2.prototype._loadFileAsync = function(url, onProgress, useOfflineSupport, useArrayBuffer) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      _this._loadFile(url, function(data) {
        resolve(data);
      }, onProgress, useOfflineSupport, useArrayBuffer, function(request, exception) {
        reject(exception);
      });
    });
  };
  Scene2.prototype._requestFile = function(url, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {
    var _this = this;
    var request = FileTools.RequestFile(url, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : void 0, useArrayBuffer, onError, onOpened);
    this._activeRequests.push(request);
    request.onCompleteObservable.add(function(request2) {
      _this._activeRequests.splice(_this._activeRequests.indexOf(request2), 1);
    });
    return request;
  };
  Scene2.prototype._requestFileAsync = function(url, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      _this._requestFile(url, function(data) {
        resolve(data);
      }, onProgress, useOfflineSupport, useArrayBuffer, function(error) {
        reject(error);
      }, onOpened);
    });
  };
  Scene2.prototype._readFile = function(file, onSuccess, onProgress, useArrayBuffer, onError) {
    var _this = this;
    var request = FileTools.ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);
    this._activeRequests.push(request);
    request.onCompleteObservable.add(function(request2) {
      _this._activeRequests.splice(_this._activeRequests.indexOf(request2), 1);
    });
    return request;
  };
  Scene2.prototype._readFileAsync = function(file, onProgress, useArrayBuffer) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      _this._readFile(file, function(data) {
        resolve(data);
      }, onProgress, useArrayBuffer, function(error) {
        reject(error);
      });
    });
  };
  Scene2.FOGMODE_NONE = 0;
  Scene2.FOGMODE_EXP = 1;
  Scene2.FOGMODE_EXP2 = 2;
  Scene2.FOGMODE_LINEAR = 3;
  Scene2.MinDeltaTime = 1;
  Scene2.MaxDeltaTime = 1e3;
  return Scene2;
}(AbstractScene);

// node_modules/@babylonjs/core/Loading/sceneLoaderFlags.js
var SceneLoaderFlags = function() {
  function SceneLoaderFlags2() {
  }
  Object.defineProperty(SceneLoaderFlags2, "ForceFullSceneLoadingForIncremental", {
    get: function() {
      return SceneLoaderFlags2._ForceFullSceneLoadingForIncremental;
    },
    set: function(value) {
      SceneLoaderFlags2._ForceFullSceneLoadingForIncremental = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneLoaderFlags2, "ShowLoadingScreen", {
    get: function() {
      return SceneLoaderFlags2._ShowLoadingScreen;
    },
    set: function(value) {
      SceneLoaderFlags2._ShowLoadingScreen = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneLoaderFlags2, "loggingLevel", {
    get: function() {
      return SceneLoaderFlags2._loggingLevel;
    },
    set: function(value) {
      SceneLoaderFlags2._loggingLevel = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneLoaderFlags2, "CleanBoneMatrixWeights", {
    get: function() {
      return SceneLoaderFlags2._CleanBoneMatrixWeights;
    },
    set: function(value) {
      SceneLoaderFlags2._CleanBoneMatrixWeights = value;
    },
    enumerable: false,
    configurable: true
  });
  SceneLoaderFlags2._ForceFullSceneLoadingForIncremental = false;
  SceneLoaderFlags2._ShowLoadingScreen = true;
  SceneLoaderFlags2._CleanBoneMatrixWeights = false;
  SceneLoaderFlags2._loggingLevel = 0;
  return SceneLoaderFlags2;
}();

// node_modules/@babylonjs/core/Meshes/geometry.js
var Geometry = function() {
  function Geometry2(id, scene, vertexData, updatable, mesh) {
    if (updatable === void 0) {
      updatable = false;
    }
    if (mesh === void 0) {
      mesh = null;
    }
    this.delayLoadState = 0;
    this._totalVertices = 0;
    this._isDisposed = false;
    this._indexBufferIsUpdatable = false;
    this._positionsCache = [];
    this.useBoundingInfoFromGeometry = false;
    this.id = id;
    this.uniqueId = scene.getUniqueId();
    this._engine = scene.getEngine();
    this._meshes = [];
    this._scene = scene;
    this._vertexBuffers = {};
    this._indices = [];
    this._updatable = updatable;
    if (vertexData) {
      this.setAllVerticesData(vertexData, updatable);
    } else {
      this._totalVertices = 0;
      this._indices = [];
    }
    if (this._engine.getCaps().vertexArrayObject) {
      this._vertexArrayObjects = {};
    }
    if (mesh) {
      this.applyToMesh(mesh);
      mesh.computeWorldMatrix(true);
    }
  }
  Object.defineProperty(Geometry2.prototype, "boundingBias", {
    get: function() {
      return this._boundingBias;
    },
    set: function(value) {
      if (this._boundingBias) {
        this._boundingBias.copyFrom(value);
      } else {
        this._boundingBias = value.clone();
      }
      this._updateBoundingInfo(true, null);
    },
    enumerable: false,
    configurable: true
  });
  Geometry2.CreateGeometryForMesh = function(mesh) {
    var geometry = new Geometry2(Geometry2.RandomId(), mesh.getScene());
    geometry.applyToMesh(mesh);
    return geometry;
  };
  Object.defineProperty(Geometry2.prototype, "meshes", {
    get: function() {
      return this._meshes;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Geometry2.prototype, "extend", {
    get: function() {
      return this._extend;
    },
    enumerable: false,
    configurable: true
  });
  Geometry2.prototype.getScene = function() {
    return this._scene;
  };
  Geometry2.prototype.getEngine = function() {
    return this._engine;
  };
  Geometry2.prototype.isReady = function() {
    return this.delayLoadState === 1 || this.delayLoadState === 0;
  };
  Object.defineProperty(Geometry2.prototype, "doNotSerialize", {
    get: function() {
      for (var index = 0; index < this._meshes.length; index++) {
        if (!this._meshes[index].doNotSerialize) {
          return false;
        }
      }
      return true;
    },
    enumerable: false,
    configurable: true
  });
  Geometry2.prototype._rebuild = function() {
    if (this._vertexArrayObjects) {
      this._vertexArrayObjects = {};
    }
    if (this._meshes.length !== 0 && this._indices) {
      this._indexBuffer = this._engine.createIndexBuffer(this._indices);
    }
    for (var key in this._vertexBuffers) {
      var vertexBuffer = this._vertexBuffers[key];
      vertexBuffer._rebuild();
    }
  };
  Geometry2.prototype.setAllVerticesData = function(vertexData, updatable) {
    vertexData.applyToGeometry(this, updatable);
    this.notifyUpdate();
  };
  Geometry2.prototype.setVerticesData = function(kind, data, updatable, stride) {
    if (updatable === void 0) {
      updatable = false;
    }
    if (updatable && Array.isArray(data)) {
      data = new Float32Array(data);
    }
    var buffer = new VertexBuffer(this._engine, data, kind, updatable, this._meshes.length === 0, stride);
    this.setVerticesBuffer(buffer);
  };
  Geometry2.prototype.removeVerticesData = function(kind) {
    if (this._vertexBuffers[kind]) {
      this._vertexBuffers[kind].dispose();
      delete this._vertexBuffers[kind];
    }
  };
  Geometry2.prototype.setVerticesBuffer = function(buffer, totalVertices) {
    if (totalVertices === void 0) {
      totalVertices = null;
    }
    var kind = buffer.getKind();
    if (this._vertexBuffers[kind]) {
      this._vertexBuffers[kind].dispose();
    }
    this._vertexBuffers[kind] = buffer;
    if (kind === VertexBuffer.PositionKind) {
      var data = buffer.getData();
      if (totalVertices != null) {
        this._totalVertices = totalVertices;
      } else {
        if (data != null) {
          this._totalVertices = data.length / (buffer.byteStride / 4);
        }
      }
      this._updateExtend(data);
      this._resetPointsArrayCache();
      var meshes = this._meshes;
      var numOfMeshes = meshes.length;
      for (var index = 0; index < numOfMeshes; index++) {
        var mesh = meshes[index];
        mesh._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);
        mesh._createGlobalSubMesh(false);
        mesh.computeWorldMatrix(true);
      }
    }
    this.notifyUpdate(kind);
    if (this._vertexArrayObjects) {
      this._disposeVertexArrayObjects();
      this._vertexArrayObjects = {};
    }
  };
  Geometry2.prototype.updateVerticesDataDirectly = function(kind, data, offset, useBytes) {
    if (useBytes === void 0) {
      useBytes = false;
    }
    var vertexBuffer = this.getVertexBuffer(kind);
    if (!vertexBuffer) {
      return;
    }
    vertexBuffer.updateDirectly(data, offset, useBytes);
    this.notifyUpdate(kind);
  };
  Geometry2.prototype.updateVerticesData = function(kind, data, updateExtends) {
    if (updateExtends === void 0) {
      updateExtends = false;
    }
    var vertexBuffer = this.getVertexBuffer(kind);
    if (!vertexBuffer) {
      return;
    }
    vertexBuffer.update(data);
    if (kind === VertexBuffer.PositionKind) {
      this._updateBoundingInfo(updateExtends, data);
    }
    this.notifyUpdate(kind);
  };
  Geometry2.prototype._updateBoundingInfo = function(updateExtends, data) {
    if (updateExtends) {
      this._updateExtend(data);
    }
    this._resetPointsArrayCache();
    if (updateExtends) {
      var meshes = this._meshes;
      for (var _i = 0, meshes_1 = meshes; _i < meshes_1.length; _i++) {
        var mesh = meshes_1[_i];
        if (mesh._boundingInfo) {
          mesh._boundingInfo.reConstruct(this._extend.minimum, this._extend.maximum);
        } else {
          mesh._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);
        }
        var subMeshes = mesh.subMeshes;
        for (var _a = 0, subMeshes_1 = subMeshes; _a < subMeshes_1.length; _a++) {
          var subMesh = subMeshes_1[_a];
          subMesh.refreshBoundingInfo();
        }
      }
    }
  };
  Geometry2.prototype._bind = function(effect, indexToBind) {
    if (!effect) {
      return;
    }
    if (indexToBind === void 0) {
      indexToBind = this._indexBuffer;
    }
    var vbs = this.getVertexBuffers();
    if (!vbs) {
      return;
    }
    if (indexToBind != this._indexBuffer || !this._vertexArrayObjects) {
      this._engine.bindBuffers(vbs, indexToBind, effect);
      return;
    }
    if (!this._vertexArrayObjects[effect.key]) {
      this._vertexArrayObjects[effect.key] = this._engine.recordVertexArrayObject(vbs, indexToBind, effect);
    }
    this._engine.bindVertexArrayObject(this._vertexArrayObjects[effect.key], indexToBind);
  };
  Geometry2.prototype.getTotalVertices = function() {
    if (!this.isReady()) {
      return 0;
    }
    return this._totalVertices;
  };
  Geometry2.prototype.getVerticesData = function(kind, copyWhenShared, forceCopy) {
    var vertexBuffer = this.getVertexBuffer(kind);
    if (!vertexBuffer) {
      return null;
    }
    var data = vertexBuffer.getData();
    if (!data) {
      return null;
    }
    var tightlyPackedByteStride = vertexBuffer.getSize() * VertexBuffer.GetTypeByteLength(vertexBuffer.type);
    var count = this._totalVertices * vertexBuffer.getSize();
    if (vertexBuffer.type !== VertexBuffer.FLOAT || vertexBuffer.byteStride !== tightlyPackedByteStride) {
      var copy_1 = [];
      vertexBuffer.forEach(count, function(value) {
        return copy_1.push(value);
      });
      return copy_1;
    }
    if (!(data instanceof Array || data instanceof Float32Array) || vertexBuffer.byteOffset !== 0 || data.length !== count) {
      if (data instanceof Array) {
        var offset = vertexBuffer.byteOffset / 4;
        return Tools.Slice(data, offset, offset + count);
      } else if (data instanceof ArrayBuffer) {
        return new Float32Array(data, vertexBuffer.byteOffset, count);
      } else {
        var offset = data.byteOffset + vertexBuffer.byteOffset;
        if (forceCopy || copyWhenShared && this._meshes.length !== 1) {
          var result = new Float32Array(count);
          var source = new Float32Array(data.buffer, offset, count);
          result.set(source);
          return result;
        }
        var remainder = offset % 4;
        if (remainder) {
          offset = Math.max(0, offset - remainder);
        }
        return new Float32Array(data.buffer, offset, count);
      }
    }
    if (forceCopy || copyWhenShared && this._meshes.length !== 1) {
      return Tools.Slice(data);
    }
    return data;
  };
  Geometry2.prototype.isVertexBufferUpdatable = function(kind) {
    var vb = this._vertexBuffers[kind];
    if (!vb) {
      return false;
    }
    return vb.isUpdatable();
  };
  Geometry2.prototype.getVertexBuffer = function(kind) {
    if (!this.isReady()) {
      return null;
    }
    return this._vertexBuffers[kind];
  };
  Geometry2.prototype.getVertexBuffers = function() {
    if (!this.isReady()) {
      return null;
    }
    return this._vertexBuffers;
  };
  Geometry2.prototype.isVerticesDataPresent = function(kind) {
    if (!this._vertexBuffers) {
      if (this._delayInfo) {
        return this._delayInfo.indexOf(kind) !== -1;
      }
      return false;
    }
    return this._vertexBuffers[kind] !== void 0;
  };
  Geometry2.prototype.getVerticesDataKinds = function() {
    var result = [];
    var kind;
    if (!this._vertexBuffers && this._delayInfo) {
      for (kind in this._delayInfo) {
        result.push(kind);
      }
    } else {
      for (kind in this._vertexBuffers) {
        result.push(kind);
      }
    }
    return result;
  };
  Geometry2.prototype.updateIndices = function(indices, offset, gpuMemoryOnly) {
    if (gpuMemoryOnly === void 0) {
      gpuMemoryOnly = false;
    }
    if (!this._indexBuffer) {
      return;
    }
    if (!this._indexBufferIsUpdatable) {
      this.setIndices(indices, null, true);
    } else {
      var needToUpdateSubMeshes = indices.length !== this._indices.length;
      if (!gpuMemoryOnly) {
        this._indices = indices.slice();
      }
      this._engine.updateDynamicIndexBuffer(this._indexBuffer, indices, offset);
      if (needToUpdateSubMeshes) {
        for (var _i = 0, _a = this._meshes; _i < _a.length; _i++) {
          var mesh = _a[_i];
          mesh._createGlobalSubMesh(true);
        }
      }
    }
  };
  Geometry2.prototype.setIndices = function(indices, totalVertices, updatable) {
    if (totalVertices === void 0) {
      totalVertices = null;
    }
    if (updatable === void 0) {
      updatable = false;
    }
    if (this._indexBuffer) {
      this._engine._releaseBuffer(this._indexBuffer);
    }
    this._disposeVertexArrayObjects();
    this._indices = indices;
    this._indexBufferIsUpdatable = updatable;
    if (this._meshes.length !== 0 && this._indices) {
      this._indexBuffer = this._engine.createIndexBuffer(this._indices, updatable);
    }
    if (totalVertices != void 0) {
      this._totalVertices = totalVertices;
    }
    for (var _i = 0, _a = this._meshes; _i < _a.length; _i++) {
      var mesh = _a[_i];
      mesh._createGlobalSubMesh(true);
    }
    this.notifyUpdate();
  };
  Geometry2.prototype.getTotalIndices = function() {
    if (!this.isReady()) {
      return 0;
    }
    return this._indices.length;
  };
  Geometry2.prototype.getIndices = function(copyWhenShared, forceCopy) {
    if (!this.isReady()) {
      return null;
    }
    var orig = this._indices;
    if (!forceCopy && (!copyWhenShared || this._meshes.length === 1)) {
      return orig;
    } else {
      var len = orig.length;
      var copy = [];
      for (var i = 0; i < len; i++) {
        copy.push(orig[i]);
      }
      return copy;
    }
  };
  Geometry2.prototype.getIndexBuffer = function() {
    if (!this.isReady()) {
      return null;
    }
    return this._indexBuffer;
  };
  Geometry2.prototype._releaseVertexArrayObject = function(effect) {
    if (effect === void 0) {
      effect = null;
    }
    if (!effect || !this._vertexArrayObjects) {
      return;
    }
    if (this._vertexArrayObjects[effect.key]) {
      this._engine.releaseVertexArrayObject(this._vertexArrayObjects[effect.key]);
      delete this._vertexArrayObjects[effect.key];
    }
  };
  Geometry2.prototype.releaseForMesh = function(mesh, shouldDispose) {
    var meshes = this._meshes;
    var index = meshes.indexOf(mesh);
    if (index === -1) {
      return;
    }
    meshes.splice(index, 1);
    mesh._geometry = null;
    if (meshes.length === 0 && shouldDispose) {
      this.dispose();
    }
  };
  Geometry2.prototype.applyToMesh = function(mesh) {
    if (mesh._geometry === this) {
      return;
    }
    var previousGeometry = mesh._geometry;
    if (previousGeometry) {
      previousGeometry.releaseForMesh(mesh);
    }
    var meshes = this._meshes;
    mesh._geometry = this;
    this._scene.pushGeometry(this);
    meshes.push(mesh);
    if (this.isReady()) {
      this._applyToMesh(mesh);
    } else {
      mesh._boundingInfo = this._boundingInfo;
    }
  };
  Geometry2.prototype._updateExtend = function(data) {
    if (data === void 0) {
      data = null;
    }
    if (this.useBoundingInfoFromGeometry && this._boundingInfo) {
      this._extend = {
        minimum: this._boundingInfo.minimum.clone(),
        maximum: this._boundingInfo.maximum.clone()
      };
    } else {
      if (!data) {
        data = this.getVerticesData(VertexBuffer.PositionKind);
      }
      this._extend = extractMinAndMax(data, 0, this._totalVertices, this.boundingBias, 3);
    }
  };
  Geometry2.prototype._applyToMesh = function(mesh) {
    var numOfMeshes = this._meshes.length;
    for (var kind in this._vertexBuffers) {
      if (numOfMeshes === 1) {
        this._vertexBuffers[kind].create();
      }
      var buffer = this._vertexBuffers[kind].getBuffer();
      if (buffer) {
        buffer.references = numOfMeshes;
      }
      if (kind === VertexBuffer.PositionKind) {
        if (!this._extend) {
          this._updateExtend();
        }
        mesh._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);
        mesh._createGlobalSubMesh(false);
        mesh._updateBoundingInfo();
      }
    }
    if (numOfMeshes === 1 && this._indices && this._indices.length > 0) {
      this._indexBuffer = this._engine.createIndexBuffer(this._indices);
    }
    if (this._indexBuffer) {
      this._indexBuffer.references = numOfMeshes;
    }
    mesh._syncGeometryWithMorphTargetManager();
    mesh.synchronizeInstances();
  };
  Geometry2.prototype.notifyUpdate = function(kind) {
    if (this.onGeometryUpdated) {
      this.onGeometryUpdated(this, kind);
    }
    for (var _i = 0, _a = this._meshes; _i < _a.length; _i++) {
      var mesh = _a[_i];
      mesh._markSubMeshesAsAttributesDirty();
    }
  };
  Geometry2.prototype.load = function(scene, onLoaded) {
    if (this.delayLoadState === 2) {
      return;
    }
    if (this.isReady()) {
      if (onLoaded) {
        onLoaded();
      }
      return;
    }
    this.delayLoadState = 2;
    this._queueLoad(scene, onLoaded);
  };
  Geometry2.prototype._queueLoad = function(scene, onLoaded) {
    var _this = this;
    if (!this.delayLoadingFile) {
      return;
    }
    scene._addPendingData(this);
    scene._loadFile(this.delayLoadingFile, function(data) {
      if (!_this._delayLoadingFunction) {
        return;
      }
      _this._delayLoadingFunction(JSON.parse(data), _this);
      _this.delayLoadState = 1;
      _this._delayInfo = [];
      scene._removePendingData(_this);
      var meshes = _this._meshes;
      var numOfMeshes = meshes.length;
      for (var index = 0; index < numOfMeshes; index++) {
        _this._applyToMesh(meshes[index]);
      }
      if (onLoaded) {
        onLoaded();
      }
    }, void 0, true);
  };
  Geometry2.prototype.toLeftHanded = function() {
    var tIndices = this.getIndices(false);
    if (tIndices != null && tIndices.length > 0) {
      for (var i = 0; i < tIndices.length; i += 3) {
        var tTemp = tIndices[i + 0];
        tIndices[i + 0] = tIndices[i + 2];
        tIndices[i + 2] = tTemp;
      }
      this.setIndices(tIndices);
    }
    var tPositions = this.getVerticesData(VertexBuffer.PositionKind, false);
    if (tPositions != null && tPositions.length > 0) {
      for (var i = 0; i < tPositions.length; i += 3) {
        tPositions[i + 2] = -tPositions[i + 2];
      }
      this.setVerticesData(VertexBuffer.PositionKind, tPositions, false);
    }
    var tNormals = this.getVerticesData(VertexBuffer.NormalKind, false);
    if (tNormals != null && tNormals.length > 0) {
      for (var i = 0; i < tNormals.length; i += 3) {
        tNormals[i + 2] = -tNormals[i + 2];
      }
      this.setVerticesData(VertexBuffer.NormalKind, tNormals, false);
    }
  };
  Geometry2.prototype._resetPointsArrayCache = function() {
    this._positions = null;
  };
  Geometry2.prototype._generatePointsArray = function() {
    if (this._positions) {
      return true;
    }
    var data = this.getVerticesData(VertexBuffer.PositionKind);
    if (!data || data.length === 0) {
      return false;
    }
    for (var index = this._positionsCache.length * 3, arrayIdx = this._positionsCache.length; index < data.length; index += 3, ++arrayIdx) {
      this._positionsCache[arrayIdx] = Vector3.FromArray(data, index);
    }
    for (var index = 0, arrayIdx = 0; index < data.length; index += 3, ++arrayIdx) {
      this._positionsCache[arrayIdx].set(data[0 + index], data[1 + index], data[2 + index]);
    }
    this._positionsCache.length = data.length / 3;
    this._positions = this._positionsCache;
    return true;
  };
  Geometry2.prototype.isDisposed = function() {
    return this._isDisposed;
  };
  Geometry2.prototype._disposeVertexArrayObjects = function() {
    if (this._vertexArrayObjects) {
      for (var kind in this._vertexArrayObjects) {
        this._engine.releaseVertexArrayObject(this._vertexArrayObjects[kind]);
      }
      this._vertexArrayObjects = {};
    }
  };
  Geometry2.prototype.dispose = function() {
    var meshes = this._meshes;
    var numOfMeshes = meshes.length;
    var index;
    for (index = 0; index < numOfMeshes; index++) {
      this.releaseForMesh(meshes[index]);
    }
    this._meshes = [];
    this._disposeVertexArrayObjects();
    for (var kind in this._vertexBuffers) {
      this._vertexBuffers[kind].dispose();
    }
    this._vertexBuffers = {};
    this._totalVertices = 0;
    if (this._indexBuffer) {
      this._engine._releaseBuffer(this._indexBuffer);
    }
    this._indexBuffer = null;
    this._indices = [];
    this.delayLoadState = 0;
    this.delayLoadingFile = null;
    this._delayLoadingFunction = null;
    this._delayInfo = [];
    this._boundingInfo = null;
    this._scene.removeGeometry(this);
    this._isDisposed = true;
  };
  Geometry2.prototype.copy = function(id) {
    var vertexData = new VertexData();
    vertexData.indices = [];
    var indices = this.getIndices();
    if (indices) {
      for (var index = 0; index < indices.length; index++) {
        vertexData.indices.push(indices[index]);
      }
    }
    var updatable = false;
    var stopChecking = false;
    var kind;
    for (kind in this._vertexBuffers) {
      var data = this.getVerticesData(kind);
      if (data) {
        if (data instanceof Float32Array) {
          vertexData.set(new Float32Array(data), kind);
        } else {
          vertexData.set(data.slice(0), kind);
        }
        if (!stopChecking) {
          var vb = this.getVertexBuffer(kind);
          if (vb) {
            updatable = vb.isUpdatable();
            stopChecking = !updatable;
          }
        }
      }
    }
    var geometry = new Geometry2(id, this._scene, vertexData, updatable);
    geometry.delayLoadState = this.delayLoadState;
    geometry.delayLoadingFile = this.delayLoadingFile;
    geometry._delayLoadingFunction = this._delayLoadingFunction;
    for (kind in this._delayInfo) {
      geometry._delayInfo = geometry._delayInfo || [];
      geometry._delayInfo.push(kind);
    }
    geometry._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);
    return geometry;
  };
  Geometry2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.id = this.id;
    serializationObject.updatable = this._updatable;
    if (Tags && Tags.HasTags(this)) {
      serializationObject.tags = Tags.GetTags(this);
    }
    return serializationObject;
  };
  Geometry2.prototype.toNumberArray = function(origin) {
    if (Array.isArray(origin)) {
      return origin;
    } else {
      return Array.prototype.slice.call(origin);
    }
  };
  Geometry2.prototype.serializeVerticeData = function() {
    var serializationObject = this.serialize();
    if (this.isVerticesDataPresent(VertexBuffer.PositionKind)) {
      serializationObject.positions = this.toNumberArray(this.getVerticesData(VertexBuffer.PositionKind));
      if (this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {
        serializationObject.positions._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      serializationObject.normals = this.toNumberArray(this.getVerticesData(VertexBuffer.NormalKind));
      if (this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {
        serializationObject.normals._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.TangentKind)) {
      serializationObject.tangets = this.toNumberArray(this.getVerticesData(VertexBuffer.TangentKind));
      if (this.isVertexBufferUpdatable(VertexBuffer.TangentKind)) {
        serializationObject.tangets._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.UVKind)) {
      serializationObject.uvs = this.toNumberArray(this.getVerticesData(VertexBuffer.UVKind));
      if (this.isVertexBufferUpdatable(VertexBuffer.UVKind)) {
        serializationObject.uvs._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
      serializationObject.uv2s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV2Kind));
      if (this.isVertexBufferUpdatable(VertexBuffer.UV2Kind)) {
        serializationObject.uv2s._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.UV3Kind)) {
      serializationObject.uv3s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV3Kind));
      if (this.isVertexBufferUpdatable(VertexBuffer.UV3Kind)) {
        serializationObject.uv3s._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.UV4Kind)) {
      serializationObject.uv4s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV4Kind));
      if (this.isVertexBufferUpdatable(VertexBuffer.UV4Kind)) {
        serializationObject.uv4s._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.UV5Kind)) {
      serializationObject.uv5s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV5Kind));
      if (this.isVertexBufferUpdatable(VertexBuffer.UV5Kind)) {
        serializationObject.uv5s._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.UV6Kind)) {
      serializationObject.uv6s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV6Kind));
      if (this.isVertexBufferUpdatable(VertexBuffer.UV6Kind)) {
        serializationObject.uv6s._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.ColorKind)) {
      serializationObject.colors = this.toNumberArray(this.getVerticesData(VertexBuffer.ColorKind));
      if (this.isVertexBufferUpdatable(VertexBuffer.ColorKind)) {
        serializationObject.colors._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {
      serializationObject.matricesIndices = this.toNumberArray(this.getVerticesData(VertexBuffer.MatricesIndicesKind));
      serializationObject.matricesIndices._isExpanded = true;
      if (this.isVertexBufferUpdatable(VertexBuffer.MatricesIndicesKind)) {
        serializationObject.matricesIndices._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
      serializationObject.matricesWeights = this.toNumberArray(this.getVerticesData(VertexBuffer.MatricesWeightsKind));
      if (this.isVertexBufferUpdatable(VertexBuffer.MatricesWeightsKind)) {
        serializationObject.matricesWeights._updatable = true;
      }
    }
    serializationObject.indices = this.toNumberArray(this.getIndices());
    return serializationObject;
  };
  Geometry2.ExtractFromMesh = function(mesh, id) {
    var geometry = mesh._geometry;
    if (!geometry) {
      return null;
    }
    return geometry.copy(id);
  };
  Geometry2.RandomId = function() {
    return Tools.RandomId();
  };
  Geometry2._ImportGeometry = function(parsedGeometry, mesh) {
    var scene = mesh.getScene();
    var geometryId = parsedGeometry.geometryId;
    if (geometryId) {
      var geometry = scene.getGeometryByID(geometryId);
      if (geometry) {
        geometry.applyToMesh(mesh);
      }
    } else if (parsedGeometry instanceof ArrayBuffer) {
      var binaryInfo = mesh._binaryInfo;
      if (binaryInfo.positionsAttrDesc && binaryInfo.positionsAttrDesc.count > 0) {
        var positionsData = new Float32Array(parsedGeometry, binaryInfo.positionsAttrDesc.offset, binaryInfo.positionsAttrDesc.count);
        mesh.setVerticesData(VertexBuffer.PositionKind, positionsData, false);
      }
      if (binaryInfo.normalsAttrDesc && binaryInfo.normalsAttrDesc.count > 0) {
        var normalsData = new Float32Array(parsedGeometry, binaryInfo.normalsAttrDesc.offset, binaryInfo.normalsAttrDesc.count);
        mesh.setVerticesData(VertexBuffer.NormalKind, normalsData, false);
      }
      if (binaryInfo.tangetsAttrDesc && binaryInfo.tangetsAttrDesc.count > 0) {
        var tangentsData = new Float32Array(parsedGeometry, binaryInfo.tangetsAttrDesc.offset, binaryInfo.tangetsAttrDesc.count);
        mesh.setVerticesData(VertexBuffer.TangentKind, tangentsData, false);
      }
      if (binaryInfo.uvsAttrDesc && binaryInfo.uvsAttrDesc.count > 0) {
        var uvsData = new Float32Array(parsedGeometry, binaryInfo.uvsAttrDesc.offset, binaryInfo.uvsAttrDesc.count);
        mesh.setVerticesData(VertexBuffer.UVKind, uvsData, false);
      }
      if (binaryInfo.uvs2AttrDesc && binaryInfo.uvs2AttrDesc.count > 0) {
        var uvs2Data = new Float32Array(parsedGeometry, binaryInfo.uvs2AttrDesc.offset, binaryInfo.uvs2AttrDesc.count);
        mesh.setVerticesData(VertexBuffer.UV2Kind, uvs2Data, false);
      }
      if (binaryInfo.uvs3AttrDesc && binaryInfo.uvs3AttrDesc.count > 0) {
        var uvs3Data = new Float32Array(parsedGeometry, binaryInfo.uvs3AttrDesc.offset, binaryInfo.uvs3AttrDesc.count);
        mesh.setVerticesData(VertexBuffer.UV3Kind, uvs3Data, false);
      }
      if (binaryInfo.uvs4AttrDesc && binaryInfo.uvs4AttrDesc.count > 0) {
        var uvs4Data = new Float32Array(parsedGeometry, binaryInfo.uvs4AttrDesc.offset, binaryInfo.uvs4AttrDesc.count);
        mesh.setVerticesData(VertexBuffer.UV4Kind, uvs4Data, false);
      }
      if (binaryInfo.uvs5AttrDesc && binaryInfo.uvs5AttrDesc.count > 0) {
        var uvs5Data = new Float32Array(parsedGeometry, binaryInfo.uvs5AttrDesc.offset, binaryInfo.uvs5AttrDesc.count);
        mesh.setVerticesData(VertexBuffer.UV5Kind, uvs5Data, false);
      }
      if (binaryInfo.uvs6AttrDesc && binaryInfo.uvs6AttrDesc.count > 0) {
        var uvs6Data = new Float32Array(parsedGeometry, binaryInfo.uvs6AttrDesc.offset, binaryInfo.uvs6AttrDesc.count);
        mesh.setVerticesData(VertexBuffer.UV6Kind, uvs6Data, false);
      }
      if (binaryInfo.colorsAttrDesc && binaryInfo.colorsAttrDesc.count > 0) {
        var colorsData = new Float32Array(parsedGeometry, binaryInfo.colorsAttrDesc.offset, binaryInfo.colorsAttrDesc.count);
        mesh.setVerticesData(VertexBuffer.ColorKind, colorsData, false, binaryInfo.colorsAttrDesc.stride);
      }
      if (binaryInfo.matricesIndicesAttrDesc && binaryInfo.matricesIndicesAttrDesc.count > 0) {
        var matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesAttrDesc.offset, binaryInfo.matricesIndicesAttrDesc.count);
        var floatIndices = [];
        for (var i = 0; i < matricesIndicesData.length; i++) {
          var index = matricesIndicesData[i];
          floatIndices.push(index & 255);
          floatIndices.push((index & 65280) >> 8);
          floatIndices.push((index & 16711680) >> 16);
          floatIndices.push(index >> 24 & 255);
        }
        mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, false);
      }
      if (binaryInfo.matricesIndicesExtraAttrDesc && binaryInfo.matricesIndicesExtraAttrDesc.count > 0) {
        var matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesExtraAttrDesc.offset, binaryInfo.matricesIndicesExtraAttrDesc.count);
        var floatIndices = [];
        for (var i = 0; i < matricesIndicesData.length; i++) {
          var index = matricesIndicesData[i];
          floatIndices.push(index & 255);
          floatIndices.push((index & 65280) >> 8);
          floatIndices.push((index & 16711680) >> 16);
          floatIndices.push(index >> 24 & 255);
        }
        mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, false);
      }
      if (binaryInfo.matricesWeightsAttrDesc && binaryInfo.matricesWeightsAttrDesc.count > 0) {
        var matricesWeightsData = new Float32Array(parsedGeometry, binaryInfo.matricesWeightsAttrDesc.offset, binaryInfo.matricesWeightsAttrDesc.count);
        mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsData, false);
      }
      if (binaryInfo.indicesAttrDesc && binaryInfo.indicesAttrDesc.count > 0) {
        var indicesData = new Int32Array(parsedGeometry, binaryInfo.indicesAttrDesc.offset, binaryInfo.indicesAttrDesc.count);
        mesh.setIndices(indicesData, null);
      }
      if (binaryInfo.subMeshesAttrDesc && binaryInfo.subMeshesAttrDesc.count > 0) {
        var subMeshesData = new Int32Array(parsedGeometry, binaryInfo.subMeshesAttrDesc.offset, binaryInfo.subMeshesAttrDesc.count * 5);
        mesh.subMeshes = [];
        for (var i = 0; i < binaryInfo.subMeshesAttrDesc.count; i++) {
          var materialIndex = subMeshesData[i * 5 + 0];
          var verticesStart = subMeshesData[i * 5 + 1];
          var verticesCount = subMeshesData[i * 5 + 2];
          var indexStart = subMeshesData[i * 5 + 3];
          var indexCount = subMeshesData[i * 5 + 4];
          SubMesh.AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh);
        }
      }
    } else if (parsedGeometry.positions && parsedGeometry.normals && parsedGeometry.indices) {
      mesh.setVerticesData(VertexBuffer.PositionKind, parsedGeometry.positions, parsedGeometry.positions._updatable);
      mesh.setVerticesData(VertexBuffer.NormalKind, parsedGeometry.normals, parsedGeometry.normals._updatable);
      if (parsedGeometry.tangents) {
        mesh.setVerticesData(VertexBuffer.TangentKind, parsedGeometry.tangents, parsedGeometry.tangents._updatable);
      }
      if (parsedGeometry.uvs) {
        mesh.setVerticesData(VertexBuffer.UVKind, parsedGeometry.uvs, parsedGeometry.uvs._updatable);
      }
      if (parsedGeometry.uvs2) {
        mesh.setVerticesData(VertexBuffer.UV2Kind, parsedGeometry.uvs2, parsedGeometry.uvs2._updatable);
      }
      if (parsedGeometry.uvs3) {
        mesh.setVerticesData(VertexBuffer.UV3Kind, parsedGeometry.uvs3, parsedGeometry.uvs3._updatable);
      }
      if (parsedGeometry.uvs4) {
        mesh.setVerticesData(VertexBuffer.UV4Kind, parsedGeometry.uvs4, parsedGeometry.uvs4._updatable);
      }
      if (parsedGeometry.uvs5) {
        mesh.setVerticesData(VertexBuffer.UV5Kind, parsedGeometry.uvs5, parsedGeometry.uvs5._updatable);
      }
      if (parsedGeometry.uvs6) {
        mesh.setVerticesData(VertexBuffer.UV6Kind, parsedGeometry.uvs6, parsedGeometry.uvs6._updatable);
      }
      if (parsedGeometry.colors) {
        mesh.setVerticesData(VertexBuffer.ColorKind, Color4.CheckColors4(parsedGeometry.colors, parsedGeometry.positions.length / 3), parsedGeometry.colors._updatable);
      }
      if (parsedGeometry.matricesIndices) {
        if (!parsedGeometry.matricesIndices._isExpanded) {
          var floatIndices = [];
          for (var i = 0; i < parsedGeometry.matricesIndices.length; i++) {
            var matricesIndex = parsedGeometry.matricesIndices[i];
            floatIndices.push(matricesIndex & 255);
            floatIndices.push((matricesIndex & 65280) >> 8);
            floatIndices.push((matricesIndex & 16711680) >> 16);
            floatIndices.push(matricesIndex >> 24 & 255);
          }
          mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, parsedGeometry.matricesIndices._updatable);
        } else {
          delete parsedGeometry.matricesIndices._isExpanded;
          mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, parsedGeometry.matricesIndices, parsedGeometry.matricesIndices._updatable);
        }
      }
      if (parsedGeometry.matricesIndicesExtra) {
        if (!parsedGeometry.matricesIndicesExtra._isExpanded) {
          var floatIndices = [];
          for (var i = 0; i < parsedGeometry.matricesIndicesExtra.length; i++) {
            var matricesIndex = parsedGeometry.matricesIndicesExtra[i];
            floatIndices.push(matricesIndex & 255);
            floatIndices.push((matricesIndex & 65280) >> 8);
            floatIndices.push((matricesIndex & 16711680) >> 16);
            floatIndices.push(matricesIndex >> 24 & 255);
          }
          mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, parsedGeometry.matricesIndicesExtra._updatable);
        } else {
          delete parsedGeometry.matricesIndices._isExpanded;
          mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, parsedGeometry.matricesIndicesExtra, parsedGeometry.matricesIndicesExtra._updatable);
        }
      }
      if (parsedGeometry.matricesWeights) {
        Geometry2._CleanMatricesWeights(parsedGeometry, mesh);
        mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, parsedGeometry.matricesWeights, parsedGeometry.matricesWeights._updatable);
      }
      if (parsedGeometry.matricesWeightsExtra) {
        mesh.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, parsedGeometry.matricesWeightsExtra, parsedGeometry.matricesWeights._updatable);
      }
      mesh.setIndices(parsedGeometry.indices, null);
    }
    if (parsedGeometry.subMeshes) {
      mesh.subMeshes = [];
      for (var subIndex = 0; subIndex < parsedGeometry.subMeshes.length; subIndex++) {
        var parsedSubMesh = parsedGeometry.subMeshes[subIndex];
        SubMesh.AddToMesh(parsedSubMesh.materialIndex, parsedSubMesh.verticesStart, parsedSubMesh.verticesCount, parsedSubMesh.indexStart, parsedSubMesh.indexCount, mesh);
      }
    }
    if (mesh._shouldGenerateFlatShading) {
      mesh.convertToFlatShadedMesh();
      mesh._shouldGenerateFlatShading = false;
    }
    mesh.computeWorldMatrix(true);
    scene.onMeshImportedObservable.notifyObservers(mesh);
  };
  Geometry2._CleanMatricesWeights = function(parsedGeometry, mesh) {
    var epsilon = 1e-3;
    if (!SceneLoaderFlags.CleanBoneMatrixWeights) {
      return;
    }
    var noInfluenceBoneIndex = 0;
    if (parsedGeometry.skeletonId > -1) {
      var skeleton = mesh.getScene().getLastSkeletonByID(parsedGeometry.skeletonId);
      if (!skeleton) {
        return;
      }
      noInfluenceBoneIndex = skeleton.bones.length;
    } else {
      return;
    }
    var matricesIndices = mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);
    var matricesIndicesExtra = mesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);
    var matricesWeights = parsedGeometry.matricesWeights;
    var matricesWeightsExtra = parsedGeometry.matricesWeightsExtra;
    var influencers = parsedGeometry.numBoneInfluencer;
    var size = matricesWeights.length;
    for (var i = 0; i < size; i += 4) {
      var weight = 0;
      var firstZeroWeight = -1;
      for (var j = 0; j < 4; j++) {
        var w = matricesWeights[i + j];
        weight += w;
        if (w < epsilon && firstZeroWeight < 0) {
          firstZeroWeight = j;
        }
      }
      if (matricesWeightsExtra) {
        for (var j = 0; j < 4; j++) {
          var w = matricesWeightsExtra[i + j];
          weight += w;
          if (w < epsilon && firstZeroWeight < 0) {
            firstZeroWeight = j + 4;
          }
        }
      }
      if (firstZeroWeight < 0 || firstZeroWeight > influencers - 1) {
        firstZeroWeight = influencers - 1;
      }
      if (weight > epsilon) {
        var mweight = 1 / weight;
        for (var j = 0; j < 4; j++) {
          matricesWeights[i + j] *= mweight;
        }
        if (matricesWeightsExtra) {
          for (var j = 0; j < 4; j++) {
            matricesWeightsExtra[i + j] *= mweight;
          }
        }
      } else {
        if (firstZeroWeight >= 4) {
          matricesWeightsExtra[i + firstZeroWeight - 4] = 1 - weight;
          matricesIndicesExtra[i + firstZeroWeight - 4] = noInfluenceBoneIndex;
        } else {
          matricesWeights[i + firstZeroWeight] = 1 - weight;
          matricesIndices[i + firstZeroWeight] = noInfluenceBoneIndex;
        }
      }
    }
    mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, matricesIndices);
    if (parsedGeometry.matricesWeightsExtra) {
      mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, matricesIndicesExtra);
    }
  };
  Geometry2.Parse = function(parsedVertexData, scene, rootUrl) {
    if (scene.getGeometryByID(parsedVertexData.id)) {
      return null;
    }
    var geometry = new Geometry2(parsedVertexData.id, scene, void 0, parsedVertexData.updatable);
    if (Tags) {
      Tags.AddTagsTo(geometry, parsedVertexData.tags);
    }
    if (parsedVertexData.delayLoadingFile) {
      geometry.delayLoadState = 4;
      geometry.delayLoadingFile = rootUrl + parsedVertexData.delayLoadingFile;
      geometry._boundingInfo = new BoundingInfo(Vector3.FromArray(parsedVertexData.boundingBoxMinimum), Vector3.FromArray(parsedVertexData.boundingBoxMaximum));
      geometry._delayInfo = [];
      if (parsedVertexData.hasUVs) {
        geometry._delayInfo.push(VertexBuffer.UVKind);
      }
      if (parsedVertexData.hasUVs2) {
        geometry._delayInfo.push(VertexBuffer.UV2Kind);
      }
      if (parsedVertexData.hasUVs3) {
        geometry._delayInfo.push(VertexBuffer.UV3Kind);
      }
      if (parsedVertexData.hasUVs4) {
        geometry._delayInfo.push(VertexBuffer.UV4Kind);
      }
      if (parsedVertexData.hasUVs5) {
        geometry._delayInfo.push(VertexBuffer.UV5Kind);
      }
      if (parsedVertexData.hasUVs6) {
        geometry._delayInfo.push(VertexBuffer.UV6Kind);
      }
      if (parsedVertexData.hasColors) {
        geometry._delayInfo.push(VertexBuffer.ColorKind);
      }
      if (parsedVertexData.hasMatricesIndices) {
        geometry._delayInfo.push(VertexBuffer.MatricesIndicesKind);
      }
      if (parsedVertexData.hasMatricesWeights) {
        geometry._delayInfo.push(VertexBuffer.MatricesWeightsKind);
      }
      geometry._delayLoadingFunction = VertexData.ImportVertexData;
    } else {
      VertexData.ImportVertexData(parsedVertexData, geometry);
    }
    scene.pushGeometry(geometry, true);
    return geometry;
  };
  return Geometry2;
}();

// node_modules/@babylonjs/core/Materials/multiMaterial.js
var MultiMaterial = function(_super) {
  __extends(MultiMaterial2, _super);
  function MultiMaterial2(name45, scene) {
    var _this = _super.call(this, name45, scene, true) || this;
    scene.multiMaterials.push(_this);
    _this.subMaterials = new Array();
    _this._storeEffectOnSubMeshes = true;
    return _this;
  }
  Object.defineProperty(MultiMaterial2.prototype, "subMaterials", {
    get: function() {
      return this._subMaterials;
    },
    set: function(value) {
      this._subMaterials = value;
      this._hookArray(value);
    },
    enumerable: false,
    configurable: true
  });
  MultiMaterial2.prototype.getChildren = function() {
    return this.subMaterials;
  };
  MultiMaterial2.prototype._hookArray = function(array) {
    var _this = this;
    var oldPush = array.push;
    array.push = function() {
      var items = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        items[_i] = arguments[_i];
      }
      var result = oldPush.apply(array, items);
      _this._markAllSubMeshesAsTexturesDirty();
      return result;
    };
    var oldSplice = array.splice;
    array.splice = function(index, deleteCount) {
      var deleted = oldSplice.apply(array, [index, deleteCount]);
      _this._markAllSubMeshesAsTexturesDirty();
      return deleted;
    };
  };
  MultiMaterial2.prototype.getSubMaterial = function(index) {
    if (index < 0 || index >= this.subMaterials.length) {
      return this.getScene().defaultMaterial;
    }
    return this.subMaterials[index];
  };
  MultiMaterial2.prototype.getActiveTextures = function() {
    var _a;
    return (_a = _super.prototype.getActiveTextures.call(this)).concat.apply(_a, this.subMaterials.map(function(subMaterial) {
      if (subMaterial) {
        return subMaterial.getActiveTextures();
      } else {
        return [];
      }
    }));
  };
  MultiMaterial2.prototype.hasTexture = function(texture) {
    var _a;
    if (_super.prototype.hasTexture.call(this, texture)) {
      return true;
    }
    for (var i = 0; i < this.subMaterials.length; i++) {
      if ((_a = this.subMaterials[i]) === null || _a === void 0 ? void 0 : _a.hasTexture(texture)) {
        return true;
      }
    }
    return false;
  };
  MultiMaterial2.prototype.getClassName = function() {
    return "MultiMaterial";
  };
  MultiMaterial2.prototype.isReadyForSubMesh = function(mesh, subMesh, useInstances) {
    for (var index = 0; index < this.subMaterials.length; index++) {
      var subMaterial = this.subMaterials[index];
      if (subMaterial) {
        if (subMaterial._storeEffectOnSubMeshes) {
          if (!subMaterial.isReadyForSubMesh(mesh, subMesh, useInstances)) {
            return false;
          }
          continue;
        }
        if (!subMaterial.isReady(mesh)) {
          return false;
        }
      }
    }
    return true;
  };
  MultiMaterial2.prototype.clone = function(name45, cloneChildren) {
    var newMultiMaterial = new MultiMaterial2(name45, this.getScene());
    for (var index = 0; index < this.subMaterials.length; index++) {
      var subMaterial = null;
      var current = this.subMaterials[index];
      if (cloneChildren && current) {
        subMaterial = current.clone(name45 + "-" + current.name);
      } else {
        subMaterial = this.subMaterials[index];
      }
      newMultiMaterial.subMaterials.push(subMaterial);
    }
    return newMultiMaterial;
  };
  MultiMaterial2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.name = this.name;
    serializationObject.id = this.id;
    if (Tags) {
      serializationObject.tags = Tags.GetTags(this);
    }
    serializationObject.materials = [];
    for (var matIndex = 0; matIndex < this.subMaterials.length; matIndex++) {
      var subMat = this.subMaterials[matIndex];
      if (subMat) {
        serializationObject.materials.push(subMat.id);
      } else {
        serializationObject.materials.push(null);
      }
    }
    return serializationObject;
  };
  MultiMaterial2.prototype.dispose = function(forceDisposeEffect, forceDisposeTextures, forceDisposeChildren) {
    var scene = this.getScene();
    if (!scene) {
      return;
    }
    if (forceDisposeChildren) {
      for (var index = 0; index < this.subMaterials.length; index++) {
        var subMaterial = this.subMaterials[index];
        if (subMaterial) {
          subMaterial.dispose(forceDisposeEffect, forceDisposeTextures);
        }
      }
    }
    var index = scene.multiMaterials.indexOf(this);
    if (index >= 0) {
      scene.multiMaterials.splice(index, 1);
    }
    _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures);
  };
  MultiMaterial2.ParseMultiMaterial = function(parsedMultiMaterial, scene) {
    var multiMaterial = new MultiMaterial2(parsedMultiMaterial.name, scene);
    multiMaterial.id = parsedMultiMaterial.id;
    if (Tags) {
      Tags.AddTagsTo(multiMaterial, parsedMultiMaterial.tags);
    }
    for (var matIndex = 0; matIndex < parsedMultiMaterial.materials.length; matIndex++) {
      var subMatId = parsedMultiMaterial.materials[matIndex];
      if (subMatId) {
        multiMaterial.subMaterials.push(scene.getLastMaterialByID(subMatId));
      } else {
        multiMaterial.subMaterials.push(null);
      }
    }
    return multiMaterial;
  };
  return MultiMaterial2;
}(Material);
_TypeStore.RegisteredTypes["BABYLON.MultiMaterial"] = MultiMaterial;

// node_modules/@babylonjs/core/Meshes/meshLODLevel.js
var MeshLODLevel = function() {
  function MeshLODLevel2(distance, mesh) {
    this.distance = distance;
    this.mesh = mesh;
  }
  return MeshLODLevel2;
}();

// node_modules/@babylonjs/core/Meshes/mesh.js
var _CreationDataStorage = function() {
  function _CreationDataStorage2() {
  }
  return _CreationDataStorage2;
}();
var _InstanceDataStorage = function() {
  function _InstanceDataStorage2() {
    this.visibleInstances = {};
    this.batchCache = new _InstancesBatch();
    this.instancesBufferSize = 32 * 16 * 4;
  }
  return _InstanceDataStorage2;
}();
var _InstancesBatch = function() {
  function _InstancesBatch2() {
    this.mustReturn = false;
    this.visibleInstances = new Array();
    this.renderSelf = new Array();
    this.hardwareInstancedRendering = new Array();
  }
  return _InstancesBatch2;
}();
var _ThinInstanceDataStorage = function() {
  function _ThinInstanceDataStorage2() {
    this.instancesCount = 0;
    this.matrixBuffer = null;
    this.matrixBufferSize = 32 * 16;
    this.boundingVectors = [];
    this.worldMatrices = null;
  }
  return _ThinInstanceDataStorage2;
}();
var _InternalMeshDataInfo = function() {
  function _InternalMeshDataInfo2() {
    this._areNormalsFrozen = false;
    this._source = null;
    this.meshMap = null;
    this._preActivateId = -1;
    this._LODLevels = new Array();
    this._morphTargetManager = null;
  }
  return _InternalMeshDataInfo2;
}();
var Mesh = function(_super) {
  __extends(Mesh2, _super);
  function Mesh2(name45, scene, parent, source, doNotCloneChildren, clonePhysicsImpostor) {
    if (scene === void 0) {
      scene = null;
    }
    if (parent === void 0) {
      parent = null;
    }
    if (source === void 0) {
      source = null;
    }
    if (clonePhysicsImpostor === void 0) {
      clonePhysicsImpostor = true;
    }
    var _this = _super.call(this, name45, scene) || this;
    _this._internalMeshDataInfo = new _InternalMeshDataInfo();
    _this.delayLoadState = 0;
    _this.instances = new Array();
    _this._creationDataStorage = null;
    _this._geometry = null;
    _this._instanceDataStorage = new _InstanceDataStorage();
    _this._thinInstanceDataStorage = new _ThinInstanceDataStorage();
    _this._effectiveMaterial = null;
    _this._shouldGenerateFlatShading = false;
    _this._originalBuilderSideOrientation = Mesh2.DEFAULTSIDE;
    _this.overrideMaterialSideOrientation = null;
    scene = _this.getScene();
    if (source) {
      if (source._geometry) {
        source._geometry.applyToMesh(_this);
      }
      DeepCopier.DeepCopy(source, _this, [
        "name",
        "material",
        "skeleton",
        "instances",
        "parent",
        "uniqueId",
        "source",
        "metadata",
        "morphTargetManager",
        "hasInstances",
        "source",
        "worldMatrixInstancedBuffer",
        "hasLODLevels",
        "geometry",
        "isBlocked",
        "areNormalsFrozen",
        "facetNb",
        "isFacetDataEnabled",
        "lightSources",
        "useBones",
        "isAnInstance",
        "collider",
        "edgesRenderer",
        "forward",
        "up",
        "right",
        "absolutePosition",
        "absoluteScaling",
        "absoluteRotationQuaternion",
        "isWorldMatrixFrozen",
        "nonUniformScaling",
        "behaviors",
        "worldMatrixFromCache",
        "hasThinInstances",
        "cloneMeshMap"
      ], ["_poseMatrix"]);
      _this._internalMeshDataInfo._source = source;
      if (scene.useClonedMeshMap) {
        if (!source._internalMeshDataInfo.meshMap) {
          source._internalMeshDataInfo.meshMap = {};
        }
        source._internalMeshDataInfo.meshMap[_this.uniqueId] = _this;
      }
      _this._originalBuilderSideOrientation = source._originalBuilderSideOrientation;
      _this._creationDataStorage = source._creationDataStorage;
      if (source._ranges) {
        var ranges = source._ranges;
        for (var name45 in ranges) {
          if (!ranges.hasOwnProperty(name45)) {
            continue;
          }
          if (!ranges[name45]) {
            continue;
          }
          _this.createAnimationRange(name45, ranges[name45].from, ranges[name45].to);
        }
      }
      if (source.metadata && source.metadata.clone) {
        _this.metadata = source.metadata.clone();
      } else {
        _this.metadata = source.metadata;
      }
      if (Tags && Tags.HasTags(source)) {
        Tags.AddTagsTo(_this, Tags.GetTags(source, true));
      }
      _this.setEnabled(source.isEnabled());
      _this.parent = source.parent;
      _this.setPivotMatrix(source.getPivotMatrix());
      _this.id = name45 + "." + source.id;
      _this.material = source.material;
      var index;
      if (!doNotCloneChildren) {
        var directDescendants = source.getDescendants(true);
        for (var index_1 = 0; index_1 < directDescendants.length; index_1++) {
          var child = directDescendants[index_1];
          if (child.clone) {
            child.clone(name45 + "." + child.name, _this);
          }
        }
      }
      if (source.morphTargetManager) {
        _this.morphTargetManager = source.morphTargetManager;
      }
      if (scene.getPhysicsEngine) {
        var physicsEngine = scene.getPhysicsEngine();
        if (clonePhysicsImpostor && physicsEngine) {
          var impostor = physicsEngine.getImpostorForPhysicsObject(source);
          if (impostor) {
            _this.physicsImpostor = impostor.clone(_this);
          }
        }
      }
      for (index = 0; index < scene.particleSystems.length; index++) {
        var system = scene.particleSystems[index];
        if (system.emitter === source) {
          system.clone(system.name, _this);
        }
      }
      _this.refreshBoundingInfo();
      _this.computeWorldMatrix(true);
    }
    if (parent !== null) {
      _this.parent = parent;
    }
    _this._instanceDataStorage.hardwareInstancedRendering = _this.getEngine().getCaps().instancedArrays;
    return _this;
  }
  Mesh2._GetDefaultSideOrientation = function(orientation) {
    return orientation || Mesh2.FRONTSIDE;
  };
  Object.defineProperty(Mesh2.prototype, "computeBonesUsingShaders", {
    get: function() {
      return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {
        return;
      }
      if (value && this._internalMeshDataInfo._sourcePositions) {
        this.setVerticesData(VertexBuffer.PositionKind, this._internalMeshDataInfo._sourcePositions.slice(), true);
        if (this._internalMeshDataInfo._sourceNormals) {
          this.setVerticesData(VertexBuffer.NormalKind, this._internalMeshDataInfo._sourceNormals.slice(), true);
        }
      }
      this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;
      this._markSubMeshesAsAttributesDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "onBeforeRenderObservable", {
    get: function() {
      if (!this._internalMeshDataInfo._onBeforeRenderObservable) {
        this._internalMeshDataInfo._onBeforeRenderObservable = new Observable();
      }
      return this._internalMeshDataInfo._onBeforeRenderObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "onBeforeBindObservable", {
    get: function() {
      if (!this._internalMeshDataInfo._onBeforeBindObservable) {
        this._internalMeshDataInfo._onBeforeBindObservable = new Observable();
      }
      return this._internalMeshDataInfo._onBeforeBindObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "onAfterRenderObservable", {
    get: function() {
      if (!this._internalMeshDataInfo._onAfterRenderObservable) {
        this._internalMeshDataInfo._onAfterRenderObservable = new Observable();
      }
      return this._internalMeshDataInfo._onAfterRenderObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "onBeforeDrawObservable", {
    get: function() {
      if (!this._internalMeshDataInfo._onBeforeDrawObservable) {
        this._internalMeshDataInfo._onBeforeDrawObservable = new Observable();
      }
      return this._internalMeshDataInfo._onBeforeDrawObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "onBeforeDraw", {
    set: function(callback) {
      if (this._onBeforeDrawObserver) {
        this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver);
      }
      this._onBeforeDrawObserver = this.onBeforeDrawObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "hasInstances", {
    get: function() {
      return this.instances.length > 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "hasThinInstances", {
    get: function() {
      var _a;
      return ((_a = this._thinInstanceDataStorage.instancesCount) !== null && _a !== void 0 ? _a : 0) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "morphTargetManager", {
    get: function() {
      return this._internalMeshDataInfo._morphTargetManager;
    },
    set: function(value) {
      if (this._internalMeshDataInfo._morphTargetManager === value) {
        return;
      }
      this._internalMeshDataInfo._morphTargetManager = value;
      this._syncGeometryWithMorphTargetManager();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "source", {
    get: function() {
      return this._internalMeshDataInfo._source;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "cloneMeshMap", {
    get: function() {
      return this._internalMeshDataInfo.meshMap;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "isUnIndexed", {
    get: function() {
      return this._unIndexed;
    },
    set: function(value) {
      if (this._unIndexed !== value) {
        this._unIndexed = value;
        this._markSubMeshesAsAttributesDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "worldMatrixInstancedBuffer", {
    get: function() {
      return this._instanceDataStorage.instancesData;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "manualUpdateOfWorldMatrixInstancedBuffer", {
    get: function() {
      return this._instanceDataStorage.manualUpdate;
    },
    set: function(value) {
      this._instanceDataStorage.manualUpdate = value;
    },
    enumerable: false,
    configurable: true
  });
  Mesh2.prototype.instantiateHierarchy = function(newParent, options, onNewNodeCreated) {
    if (newParent === void 0) {
      newParent = null;
    }
    var instance = this.getTotalVertices() > 0 && (!options || !options.doNotInstantiate) ? this.createInstance("instance of " + (this.name || this.id)) : this.clone("Clone of " + (this.name || this.id), newParent || this.parent, true);
    if (instance) {
      instance.parent = newParent || this.parent;
      instance.position = this.position.clone();
      instance.scaling = this.scaling.clone();
      if (this.rotationQuaternion) {
        instance.rotationQuaternion = this.rotationQuaternion.clone();
      } else {
        instance.rotation = this.rotation.clone();
      }
      if (onNewNodeCreated) {
        onNewNodeCreated(this, instance);
      }
    }
    for (var _i = 0, _a = this.getChildTransformNodes(true); _i < _a.length; _i++) {
      var child = _a[_i];
      child.instantiateHierarchy(instance, options, onNewNodeCreated);
    }
    return instance;
  };
  Mesh2.prototype.getClassName = function() {
    return "Mesh";
  };
  Object.defineProperty(Mesh2.prototype, "_isMesh", {
    get: function() {
      return true;
    },
    enumerable: false,
    configurable: true
  });
  Mesh2.prototype.toString = function(fullDetails) {
    var ret = _super.prototype.toString.call(this, fullDetails);
    ret += ", n vertices: " + this.getTotalVertices();
    ret += ", parent: " + (this._waitingParentId ? this._waitingParentId : this.parent ? this.parent.name : "NONE");
    if (this.animations) {
      for (var i = 0; i < this.animations.length; i++) {
        ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
      }
    }
    if (fullDetails) {
      if (this._geometry) {
        var ib = this.getIndices();
        var vb = this.getVerticesData(VertexBuffer.PositionKind);
        if (vb && ib) {
          ret += ", flat shading: " + (vb.length / 3 === ib.length ? "YES" : "NO");
        }
      } else {
        ret += ", flat shading: UNKNOWN";
      }
    }
    return ret;
  };
  Mesh2.prototype._unBindEffect = function() {
    _super.prototype._unBindEffect.call(this);
    for (var _i = 0, _a = this.instances; _i < _a.length; _i++) {
      var instance = _a[_i];
      instance._unBindEffect();
    }
  };
  Object.defineProperty(Mesh2.prototype, "hasLODLevels", {
    get: function() {
      return this._internalMeshDataInfo._LODLevels.length > 0;
    },
    enumerable: false,
    configurable: true
  });
  Mesh2.prototype.getLODLevels = function() {
    return this._internalMeshDataInfo._LODLevels;
  };
  Mesh2.prototype._sortLODLevels = function() {
    this._internalMeshDataInfo._LODLevels.sort(function(a, b) {
      if (a.distance < b.distance) {
        return 1;
      }
      if (a.distance > b.distance) {
        return -1;
      }
      return 0;
    });
  };
  Mesh2.prototype.addLODLevel = function(distance, mesh) {
    if (mesh && mesh._masterMesh) {
      Logger.Warn("You cannot use a mesh as LOD level twice");
      return this;
    }
    var level = new MeshLODLevel(distance, mesh);
    this._internalMeshDataInfo._LODLevels.push(level);
    if (mesh) {
      mesh._masterMesh = this;
    }
    this._sortLODLevels();
    return this;
  };
  Mesh2.prototype.getLODLevelAtDistance = function(distance) {
    var internalDataInfo = this._internalMeshDataInfo;
    for (var index = 0; index < internalDataInfo._LODLevels.length; index++) {
      var level = internalDataInfo._LODLevels[index];
      if (level.distance === distance) {
        return level.mesh;
      }
    }
    return null;
  };
  Mesh2.prototype.removeLODLevel = function(mesh) {
    var internalDataInfo = this._internalMeshDataInfo;
    for (var index = 0; index < internalDataInfo._LODLevels.length; index++) {
      if (internalDataInfo._LODLevels[index].mesh === mesh) {
        internalDataInfo._LODLevels.splice(index, 1);
        if (mesh) {
          mesh._masterMesh = null;
        }
      }
    }
    this._sortLODLevels();
    return this;
  };
  Mesh2.prototype.getLOD = function(camera, boundingSphere) {
    var internalDataInfo = this._internalMeshDataInfo;
    if (!internalDataInfo._LODLevels || internalDataInfo._LODLevels.length === 0) {
      return this;
    }
    var bSphere;
    if (boundingSphere) {
      bSphere = boundingSphere;
    } else {
      var boundingInfo = this.getBoundingInfo();
      bSphere = boundingInfo.boundingSphere;
    }
    var distanceToCamera = bSphere.centerWorld.subtract(camera.globalPosition).length();
    if (internalDataInfo._LODLevels[internalDataInfo._LODLevels.length - 1].distance > distanceToCamera) {
      if (this.onLODLevelSelection) {
        this.onLODLevelSelection(distanceToCamera, this, this);
      }
      return this;
    }
    for (var index = 0; index < internalDataInfo._LODLevels.length; index++) {
      var level = internalDataInfo._LODLevels[index];
      if (level.distance < distanceToCamera) {
        if (level.mesh) {
          if (level.mesh.delayLoadState === 4) {
            level.mesh._checkDelayState();
            return this;
          }
          if (level.mesh.delayLoadState === 2) {
            return this;
          }
          level.mesh._preActivate();
          level.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);
        }
        if (this.onLODLevelSelection) {
          this.onLODLevelSelection(distanceToCamera, this, level.mesh);
        }
        return level.mesh;
      }
    }
    if (this.onLODLevelSelection) {
      this.onLODLevelSelection(distanceToCamera, this, this);
    }
    return this;
  };
  Object.defineProperty(Mesh2.prototype, "geometry", {
    get: function() {
      return this._geometry;
    },
    enumerable: false,
    configurable: true
  });
  Mesh2.prototype.getTotalVertices = function() {
    if (this._geometry === null || this._geometry === void 0) {
      return 0;
    }
    return this._geometry.getTotalVertices();
  };
  Mesh2.prototype.getVerticesData = function(kind, copyWhenShared, forceCopy) {
    if (!this._geometry) {
      return null;
    }
    return this._geometry.getVerticesData(kind, copyWhenShared, forceCopy);
  };
  Mesh2.prototype.getVertexBuffer = function(kind) {
    if (!this._geometry) {
      return null;
    }
    return this._geometry.getVertexBuffer(kind);
  };
  Mesh2.prototype.isVerticesDataPresent = function(kind) {
    if (!this._geometry) {
      if (this._delayInfo) {
        return this._delayInfo.indexOf(kind) !== -1;
      }
      return false;
    }
    return this._geometry.isVerticesDataPresent(kind);
  };
  Mesh2.prototype.isVertexBufferUpdatable = function(kind) {
    if (!this._geometry) {
      if (this._delayInfo) {
        return this._delayInfo.indexOf(kind) !== -1;
      }
      return false;
    }
    return this._geometry.isVertexBufferUpdatable(kind);
  };
  Mesh2.prototype.getVerticesDataKinds = function() {
    if (!this._geometry) {
      var result = new Array();
      if (this._delayInfo) {
        this._delayInfo.forEach(function(kind) {
          result.push(kind);
        });
      }
      return result;
    }
    return this._geometry.getVerticesDataKinds();
  };
  Mesh2.prototype.getTotalIndices = function() {
    if (!this._geometry) {
      return 0;
    }
    return this._geometry.getTotalIndices();
  };
  Mesh2.prototype.getIndices = function(copyWhenShared, forceCopy) {
    if (!this._geometry) {
      return [];
    }
    return this._geometry.getIndices(copyWhenShared, forceCopy);
  };
  Object.defineProperty(Mesh2.prototype, "isBlocked", {
    get: function() {
      return this._masterMesh !== null && this._masterMesh !== void 0;
    },
    enumerable: false,
    configurable: true
  });
  Mesh2.prototype.isReady = function(completeCheck, forceInstanceSupport) {
    var _a, _b, _c, _d, _e, _f;
    if (completeCheck === void 0) {
      completeCheck = false;
    }
    if (forceInstanceSupport === void 0) {
      forceInstanceSupport = false;
    }
    if (this.delayLoadState === 2) {
      return false;
    }
    if (!_super.prototype.isReady.call(this, completeCheck)) {
      return false;
    }
    if (!this.subMeshes || this.subMeshes.length === 0) {
      return true;
    }
    if (!completeCheck) {
      return true;
    }
    var engine = this.getEngine();
    var scene = this.getScene();
    var hardwareInstancedRendering = forceInstanceSupport || engine.getCaps().instancedArrays && (this.instances.length > 0 || this.hasThinInstances);
    this.computeWorldMatrix();
    var mat = this.material || scene.defaultMaterial;
    if (mat) {
      if (mat._storeEffectOnSubMeshes) {
        for (var _i = 0, _g = this.subMeshes; _i < _g.length; _i++) {
          var subMesh = _g[_i];
          var effectiveMaterial = subMesh.getMaterial();
          if (effectiveMaterial) {
            if (effectiveMaterial._storeEffectOnSubMeshes) {
              if (!effectiveMaterial.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {
                return false;
              }
            } else {
              if (!effectiveMaterial.isReady(this, hardwareInstancedRendering)) {
                return false;
              }
            }
          }
        }
      } else {
        if (!mat.isReady(this, hardwareInstancedRendering)) {
          return false;
        }
      }
    }
    for (var _h = 0, _j = this.lightSources; _h < _j.length; _h++) {
      var light = _j[_h];
      var generator = light.getShadowGenerator();
      if (generator && (!((_a = generator.getShadowMap()) === null || _a === void 0 ? void 0 : _a.renderList) || ((_b = generator.getShadowMap()) === null || _b === void 0 ? void 0 : _b.renderList) && ((_d = (_c = generator.getShadowMap()) === null || _c === void 0 ? void 0 : _c.renderList) === null || _d === void 0 ? void 0 : _d.indexOf(this)) !== -1)) {
        for (var _k = 0, _l = this.subMeshes; _k < _l.length; _k++) {
          var subMesh = _l[_k];
          if (!generator.isReady(subMesh, hardwareInstancedRendering, (_f = (_e = subMesh.getMaterial()) === null || _e === void 0 ? void 0 : _e.needAlphaBlendingForMesh(this)) !== null && _f !== void 0 ? _f : false)) {
            return false;
          }
        }
      }
    }
    for (var _m = 0, _o = this._internalMeshDataInfo._LODLevels; _m < _o.length; _m++) {
      var lod = _o[_m];
      if (lod.mesh && !lod.mesh.isReady(hardwareInstancedRendering)) {
        return false;
      }
    }
    return true;
  };
  Object.defineProperty(Mesh2.prototype, "areNormalsFrozen", {
    get: function() {
      return this._internalMeshDataInfo._areNormalsFrozen;
    },
    enumerable: false,
    configurable: true
  });
  Mesh2.prototype.freezeNormals = function() {
    this._internalMeshDataInfo._areNormalsFrozen = true;
    return this;
  };
  Mesh2.prototype.unfreezeNormals = function() {
    this._internalMeshDataInfo._areNormalsFrozen = false;
    return this;
  };
  Object.defineProperty(Mesh2.prototype, "overridenInstanceCount", {
    set: function(count) {
      this._instanceDataStorage.overridenInstanceCount = count;
    },
    enumerable: false,
    configurable: true
  });
  Mesh2.prototype._preActivate = function() {
    var internalDataInfo = this._internalMeshDataInfo;
    var sceneRenderId = this.getScene().getRenderId();
    if (internalDataInfo._preActivateId === sceneRenderId) {
      return this;
    }
    internalDataInfo._preActivateId = sceneRenderId;
    this._instanceDataStorage.visibleInstances = null;
    return this;
  };
  Mesh2.prototype._preActivateForIntermediateRendering = function(renderId) {
    if (this._instanceDataStorage.visibleInstances) {
      this._instanceDataStorage.visibleInstances.intermediateDefaultRenderId = renderId;
    }
    return this;
  };
  Mesh2.prototype._registerInstanceForRenderId = function(instance, renderId) {
    if (!this._instanceDataStorage.visibleInstances) {
      this._instanceDataStorage.visibleInstances = {
        defaultRenderId: renderId,
        selfDefaultRenderId: this._renderId
      };
    }
    if (!this._instanceDataStorage.visibleInstances[renderId]) {
      if (this._instanceDataStorage.previousRenderId !== void 0 && this._instanceDataStorage.isFrozen) {
        this._instanceDataStorage.visibleInstances[this._instanceDataStorage.previousRenderId] = null;
      }
      this._instanceDataStorage.previousRenderId = renderId;
      this._instanceDataStorage.visibleInstances[renderId] = new Array();
    }
    this._instanceDataStorage.visibleInstances[renderId].push(instance);
    return this;
  };
  Mesh2.prototype._afterComputeWorldMatrix = function() {
    _super.prototype._afterComputeWorldMatrix.call(this);
    if (!this.hasThinInstances) {
      return;
    }
    if (!this.doNotSyncBoundingInfo) {
      this.thinInstanceRefreshBoundingInfo(false);
    }
  };
  Mesh2.prototype._postActivate = function() {
    if (this.edgesShareWithInstances && this.edgesRenderer && this.edgesRenderer.isEnabled && this._renderingGroup) {
      this._renderingGroup._edgesRenderers.pushNoDuplicate(this.edgesRenderer);
      this.edgesRenderer.customInstances.push(this.getWorldMatrix());
    }
  };
  Mesh2.prototype.refreshBoundingInfo = function(applySkeleton) {
    if (applySkeleton === void 0) {
      applySkeleton = false;
    }
    if (this._boundingInfo && this._boundingInfo.isLocked) {
      return this;
    }
    var bias = this.geometry ? this.geometry.boundingBias : null;
    this._refreshBoundingInfo(this._getPositionData(applySkeleton), bias);
    return this;
  };
  Mesh2.prototype._createGlobalSubMesh = function(force) {
    var totalVertices = this.getTotalVertices();
    if (!totalVertices || !this.getIndices()) {
      return null;
    }
    if (this.subMeshes && this.subMeshes.length > 0) {
      var ib = this.getIndices();
      if (!ib) {
        return null;
      }
      var totalIndices = ib.length;
      var needToRecreate = false;
      if (force) {
        needToRecreate = true;
      } else {
        for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {
          var submesh = _a[_i];
          if (submesh.indexStart + submesh.indexCount > totalIndices) {
            needToRecreate = true;
            break;
          }
          if (submesh.verticesStart + submesh.verticesCount > totalVertices) {
            needToRecreate = true;
            break;
          }
        }
      }
      if (!needToRecreate) {
        return this.subMeshes[0];
      }
    }
    this.releaseSubMeshes();
    return new SubMesh(0, 0, totalVertices, 0, this.getTotalIndices(), this);
  };
  Mesh2.prototype.subdivide = function(count) {
    if (count < 1) {
      return;
    }
    var totalIndices = this.getTotalIndices();
    var subdivisionSize = totalIndices / count | 0;
    var offset = 0;
    while (subdivisionSize % 3 !== 0) {
      subdivisionSize++;
    }
    this.releaseSubMeshes();
    for (var index = 0; index < count; index++) {
      if (offset >= totalIndices) {
        break;
      }
      SubMesh.CreateFromIndices(0, offset, index === count - 1 ? totalIndices - offset : subdivisionSize, this);
      offset += subdivisionSize;
    }
    this.synchronizeInstances();
  };
  Mesh2.prototype.setVerticesData = function(kind, data, updatable, stride) {
    if (updatable === void 0) {
      updatable = false;
    }
    if (!this._geometry) {
      var vertexData = new VertexData();
      vertexData.set(data, kind);
      var scene = this.getScene();
      new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);
    } else {
      this._geometry.setVerticesData(kind, data, updatable, stride);
    }
    return this;
  };
  Mesh2.prototype.removeVerticesData = function(kind) {
    if (!this._geometry) {
      return;
    }
    this._geometry.removeVerticesData(kind);
  };
  Mesh2.prototype.markVerticesDataAsUpdatable = function(kind, updatable) {
    if (updatable === void 0) {
      updatable = true;
    }
    var vb = this.getVertexBuffer(kind);
    if (!vb || vb.isUpdatable() === updatable) {
      return;
    }
    this.setVerticesData(kind, this.getVerticesData(kind), updatable);
  };
  Mesh2.prototype.setVerticesBuffer = function(buffer) {
    if (!this._geometry) {
      this._geometry = Geometry.CreateGeometryForMesh(this);
    }
    this._geometry.setVerticesBuffer(buffer);
    return this;
  };
  Mesh2.prototype.updateVerticesData = function(kind, data, updateExtends, makeItUnique) {
    if (!this._geometry) {
      return this;
    }
    if (!makeItUnique) {
      this._geometry.updateVerticesData(kind, data, updateExtends);
    } else {
      this.makeGeometryUnique();
      this.updateVerticesData(kind, data, updateExtends, false);
    }
    return this;
  };
  Mesh2.prototype.updateMeshPositions = function(positionFunction, computeNormals) {
    if (computeNormals === void 0) {
      computeNormals = true;
    }
    var positions = this.getVerticesData(VertexBuffer.PositionKind);
    if (!positions) {
      return this;
    }
    positionFunction(positions);
    this.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);
    if (computeNormals) {
      var indices = this.getIndices();
      var normals = this.getVerticesData(VertexBuffer.NormalKind);
      if (!normals) {
        return this;
      }
      VertexData.ComputeNormals(positions, indices, normals);
      this.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);
    }
    return this;
  };
  Mesh2.prototype.makeGeometryUnique = function() {
    if (!this._geometry) {
      return this;
    }
    if (this._geometry.meshes.length === 1) {
      return this;
    }
    var oldGeometry = this._geometry;
    var geometry = this._geometry.copy(Geometry.RandomId());
    oldGeometry.releaseForMesh(this, true);
    geometry.applyToMesh(this);
    return this;
  };
  Mesh2.prototype.setIndices = function(indices, totalVertices, updatable) {
    if (totalVertices === void 0) {
      totalVertices = null;
    }
    if (updatable === void 0) {
      updatable = false;
    }
    if (!this._geometry) {
      var vertexData = new VertexData();
      vertexData.indices = indices;
      var scene = this.getScene();
      new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);
    } else {
      this._geometry.setIndices(indices, totalVertices, updatable);
    }
    return this;
  };
  Mesh2.prototype.updateIndices = function(indices, offset, gpuMemoryOnly) {
    if (gpuMemoryOnly === void 0) {
      gpuMemoryOnly = false;
    }
    if (!this._geometry) {
      return this;
    }
    this._geometry.updateIndices(indices, offset, gpuMemoryOnly);
    return this;
  };
  Mesh2.prototype.toLeftHanded = function() {
    if (!this._geometry) {
      return this;
    }
    this._geometry.toLeftHanded();
    return this;
  };
  Mesh2.prototype._bind = function(subMesh, effect, fillMode) {
    if (!this._geometry) {
      return this;
    }
    var engine = this.getScene().getEngine();
    var indexToBind;
    if (this._unIndexed) {
      indexToBind = null;
    } else {
      switch (fillMode) {
        case Material.PointFillMode:
          indexToBind = null;
          break;
        case Material.WireFrameFillMode:
          indexToBind = subMesh._getLinesIndexBuffer(this.getIndices(), engine);
          break;
        default:
        case Material.TriangleFillMode:
          indexToBind = this._geometry.getIndexBuffer();
          break;
      }
    }
    this._geometry._bind(effect, indexToBind);
    return this;
  };
  Mesh2.prototype._draw = function(subMesh, fillMode, instancesCount) {
    if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {
      return this;
    }
    if (this._internalMeshDataInfo._onBeforeDrawObservable) {
      this._internalMeshDataInfo._onBeforeDrawObservable.notifyObservers(this);
    }
    var scene = this.getScene();
    var engine = scene.getEngine();
    if (this._unIndexed || fillMode == Material.PointFillMode) {
      engine.drawArraysType(fillMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);
    } else if (fillMode == Material.WireFrameFillMode) {
      engine.drawElementsType(fillMode, 0, subMesh._linesIndexCount, instancesCount);
    } else {
      engine.drawElementsType(fillMode, subMesh.indexStart, subMesh.indexCount, instancesCount);
    }
    return this;
  };
  Mesh2.prototype.registerBeforeRender = function(func) {
    this.onBeforeRenderObservable.add(func);
    return this;
  };
  Mesh2.prototype.unregisterBeforeRender = function(func) {
    this.onBeforeRenderObservable.removeCallback(func);
    return this;
  };
  Mesh2.prototype.registerAfterRender = function(func) {
    this.onAfterRenderObservable.add(func);
    return this;
  };
  Mesh2.prototype.unregisterAfterRender = function(func) {
    this.onAfterRenderObservable.removeCallback(func);
    return this;
  };
  Mesh2.prototype._getInstancesRenderList = function(subMeshId, isReplacementMode) {
    if (isReplacementMode === void 0) {
      isReplacementMode = false;
    }
    if (this._instanceDataStorage.isFrozen && this._instanceDataStorage.previousBatch) {
      return this._instanceDataStorage.previousBatch;
    }
    var scene = this.getScene();
    var isInIntermediateRendering = scene._isInIntermediateRendering();
    var onlyForInstances = isInIntermediateRendering ? this._internalAbstractMeshDataInfo._onlyForInstancesIntermediate : this._internalAbstractMeshDataInfo._onlyForInstances;
    var batchCache = this._instanceDataStorage.batchCache;
    batchCache.mustReturn = false;
    batchCache.renderSelf[subMeshId] = isReplacementMode || !onlyForInstances && this.isEnabled() && this.isVisible;
    batchCache.visibleInstances[subMeshId] = null;
    if (this._instanceDataStorage.visibleInstances && !isReplacementMode) {
      var visibleInstances = this._instanceDataStorage.visibleInstances;
      var currentRenderId = scene.getRenderId();
      var defaultRenderId = isInIntermediateRendering ? visibleInstances.intermediateDefaultRenderId : visibleInstances.defaultRenderId;
      batchCache.visibleInstances[subMeshId] = visibleInstances[currentRenderId];
      if (!batchCache.visibleInstances[subMeshId] && defaultRenderId) {
        batchCache.visibleInstances[subMeshId] = visibleInstances[defaultRenderId];
      }
    }
    batchCache.hardwareInstancedRendering[subMeshId] = !isReplacementMode && this._instanceDataStorage.hardwareInstancedRendering && batchCache.visibleInstances[subMeshId] !== null && batchCache.visibleInstances[subMeshId] !== void 0;
    this._instanceDataStorage.previousBatch = batchCache;
    return batchCache;
  };
  Mesh2.prototype._renderWithInstances = function(subMesh, fillMode, batch, effect, engine) {
    var visibleInstances = batch.visibleInstances[subMesh._id];
    if (!visibleInstances) {
      return this;
    }
    var instanceStorage = this._instanceDataStorage;
    var currentInstancesBufferSize = instanceStorage.instancesBufferSize;
    var instancesBuffer = instanceStorage.instancesBuffer;
    var matricesCount = visibleInstances.length + 1;
    var bufferSize = matricesCount * 16 * 4;
    while (instanceStorage.instancesBufferSize < bufferSize) {
      instanceStorage.instancesBufferSize *= 2;
    }
    if (!instanceStorage.instancesData || currentInstancesBufferSize != instanceStorage.instancesBufferSize) {
      instanceStorage.instancesData = new Float32Array(instanceStorage.instancesBufferSize / 4);
    }
    var offset = 0;
    var instancesCount = 0;
    var renderSelf = batch.renderSelf[subMesh._id];
    var needUpdateBuffer = !instancesBuffer || currentInstancesBufferSize !== instanceStorage.instancesBufferSize;
    if (!this._instanceDataStorage.manualUpdate && (!instanceStorage.isFrozen || needUpdateBuffer)) {
      var world = this._effectiveMesh.getWorldMatrix();
      if (renderSelf) {
        world.copyToArray(instanceStorage.instancesData, offset);
        offset += 16;
        instancesCount++;
      }
      if (visibleInstances) {
        for (var instanceIndex = 0; instanceIndex < visibleInstances.length; instanceIndex++) {
          var instance = visibleInstances[instanceIndex];
          instance.getWorldMatrix().copyToArray(instanceStorage.instancesData, offset);
          offset += 16;
          instancesCount++;
        }
      }
    } else {
      instancesCount = (renderSelf ? 1 : 0) + visibleInstances.length;
    }
    if (needUpdateBuffer) {
      if (instancesBuffer) {
        instancesBuffer.dispose();
      }
      instancesBuffer = new Buffer2(engine, instanceStorage.instancesData, true, 16, false, true);
      instanceStorage.instancesBuffer = instancesBuffer;
      this.setVerticesBuffer(instancesBuffer.createVertexBuffer("world0", 0, 4));
      this.setVerticesBuffer(instancesBuffer.createVertexBuffer("world1", 4, 4));
      this.setVerticesBuffer(instancesBuffer.createVertexBuffer("world2", 8, 4));
      this.setVerticesBuffer(instancesBuffer.createVertexBuffer("world3", 12, 4));
    } else {
      if (!this._instanceDataStorage.isFrozen) {
        instancesBuffer.updateDirectly(instanceStorage.instancesData, 0, instancesCount);
      }
    }
    this._processInstancedBuffers(visibleInstances, renderSelf);
    this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false);
    this._bind(subMesh, effect, fillMode);
    this._draw(subMesh, fillMode, instancesCount);
    engine.unbindInstanceAttributes();
    return this;
  };
  Mesh2.prototype._renderWithThinInstances = function(subMesh, fillMode, effect, engine) {
    var _a, _b;
    var instancesCount = (_b = (_a = this._thinInstanceDataStorage) === null || _a === void 0 ? void 0 : _a.instancesCount) !== null && _b !== void 0 ? _b : 0;
    this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false);
    this._bind(subMesh, effect, fillMode);
    this._draw(subMesh, fillMode, instancesCount);
    engine.unbindInstanceAttributes();
  };
  Mesh2.prototype._processInstancedBuffers = function(visibleInstances, renderSelf) {
  };
  Mesh2.prototype._processRendering = function(renderingMesh, subMesh, effect, fillMode, batch, hardwareInstancedRendering, onBeforeDraw, effectiveMaterial) {
    var scene = this.getScene();
    var engine = scene.getEngine();
    if (hardwareInstancedRendering && subMesh.getRenderingMesh().hasThinInstances) {
      this._renderWithThinInstances(subMesh, fillMode, effect, engine);
      return this;
    }
    if (hardwareInstancedRendering) {
      this._renderWithInstances(subMesh, fillMode, batch, effect, engine);
    } else {
      var instanceCount = 0;
      if (batch.renderSelf[subMesh._id]) {
        if (onBeforeDraw) {
          onBeforeDraw(false, renderingMesh._effectiveMesh.getWorldMatrix(), effectiveMaterial);
        }
        instanceCount++;
        this._draw(subMesh, fillMode, this._instanceDataStorage.overridenInstanceCount);
      }
      var visibleInstancesForSubMesh = batch.visibleInstances[subMesh._id];
      if (visibleInstancesForSubMesh) {
        var visibleInstanceCount = visibleInstancesForSubMesh.length;
        instanceCount += visibleInstanceCount;
        for (var instanceIndex = 0; instanceIndex < visibleInstanceCount; instanceIndex++) {
          var instance = visibleInstancesForSubMesh[instanceIndex];
          var world = instance.getWorldMatrix();
          if (onBeforeDraw) {
            onBeforeDraw(true, world, effectiveMaterial);
          }
          this._draw(subMesh, fillMode);
        }
      }
      scene._activeIndices.addCount(subMesh.indexCount * instanceCount, false);
    }
    return this;
  };
  Mesh2.prototype._rebuild = function() {
    if (this._instanceDataStorage.instancesBuffer) {
      this._instanceDataStorage.instancesBuffer.dispose();
      this._instanceDataStorage.instancesBuffer = null;
    }
    _super.prototype._rebuild.call(this);
  };
  Mesh2.prototype._freeze = function() {
    if (!this.subMeshes) {
      return;
    }
    for (var index = 0; index < this.subMeshes.length; index++) {
      this._getInstancesRenderList(index);
    }
    this._effectiveMaterial = null;
    this._instanceDataStorage.isFrozen = true;
  };
  Mesh2.prototype._unFreeze = function() {
    this._instanceDataStorage.isFrozen = false;
    this._instanceDataStorage.previousBatch = null;
  };
  Mesh2.prototype.render = function(subMesh, enableAlphaMode, effectiveMeshReplacement) {
    var scene = this.getScene();
    if (this._internalAbstractMeshDataInfo._isActiveIntermediate) {
      this._internalAbstractMeshDataInfo._isActiveIntermediate = false;
    } else {
      this._internalAbstractMeshDataInfo._isActive = false;
    }
    if (this._checkOcclusionQuery()) {
      return this;
    }
    var batch = this._getInstancesRenderList(subMesh._id, !!effectiveMeshReplacement);
    if (batch.mustReturn) {
      return this;
    }
    if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {
      return this;
    }
    if (this._internalMeshDataInfo._onBeforeRenderObservable) {
      this._internalMeshDataInfo._onBeforeRenderObservable.notifyObservers(this);
    }
    var engine = scene.getEngine();
    var hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || subMesh.getRenderingMesh().hasThinInstances;
    var instanceDataStorage = this._instanceDataStorage;
    var material = subMesh.getMaterial();
    if (!material) {
      return this;
    }
    if (!instanceDataStorage.isFrozen || !this._effectiveMaterial || this._effectiveMaterial !== material) {
      if (material._storeEffectOnSubMeshes) {
        if (!material.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {
          return this;
        }
      } else if (!material.isReady(this, hardwareInstancedRendering)) {
        return this;
      }
      this._effectiveMaterial = material;
    }
    if (enableAlphaMode) {
      engine.setAlphaMode(this._effectiveMaterial.alphaMode);
    }
    var effect;
    if (this._effectiveMaterial._storeEffectOnSubMeshes) {
      effect = subMesh.effect;
    } else {
      effect = this._effectiveMaterial.getEffect();
    }
    for (var _i = 0, _a = scene._beforeRenderingMeshStage; _i < _a.length; _i++) {
      var step = _a[_i];
      step.action(this, subMesh, batch, effect);
    }
    if (!effect) {
      return this;
    }
    var effectiveMesh = effectiveMeshReplacement || this._effectiveMesh;
    var sideOrientation;
    if (!instanceDataStorage.isFrozen && (this._effectiveMaterial.backFaceCulling || this.overrideMaterialSideOrientation !== null)) {
      var mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();
      sideOrientation = this.overrideMaterialSideOrientation;
      if (sideOrientation == null) {
        sideOrientation = this._effectiveMaterial.sideOrientation;
      }
      if (mainDeterminant < 0) {
        sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;
      }
      instanceDataStorage.sideOrientation = sideOrientation;
    } else {
      sideOrientation = instanceDataStorage.sideOrientation;
    }
    var reverse = this._effectiveMaterial._preBind(effect, sideOrientation);
    if (this._effectiveMaterial.forceDepthWrite) {
      engine.setDepthWrite(true);
    }
    var fillMode = scene.forcePointsCloud ? Material.PointFillMode : scene.forceWireframe ? Material.WireFrameFillMode : this._effectiveMaterial.fillMode;
    if (this._internalMeshDataInfo._onBeforeBindObservable) {
      this._internalMeshDataInfo._onBeforeBindObservable.notifyObservers(this);
    }
    if (!hardwareInstancedRendering) {
      this._bind(subMesh, effect, fillMode);
    }
    var world = effectiveMesh.getWorldMatrix();
    if (this._effectiveMaterial._storeEffectOnSubMeshes) {
      this._effectiveMaterial.bindForSubMesh(world, this, subMesh);
    } else {
      this._effectiveMaterial.bind(world, this);
    }
    if (!this._effectiveMaterial.backFaceCulling && this._effectiveMaterial.separateCullingPass) {
      engine.setState(true, this._effectiveMaterial.zOffset, false, !reverse);
      this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._effectiveMaterial);
      engine.setState(true, this._effectiveMaterial.zOffset, false, reverse);
    }
    this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._effectiveMaterial);
    this._effectiveMaterial.unbind();
    for (var _b = 0, _c = scene._afterRenderingMeshStage; _b < _c.length; _b++) {
      var step = _c[_b];
      step.action(this, subMesh, batch, effect);
    }
    if (this._internalMeshDataInfo._onAfterRenderObservable) {
      this._internalMeshDataInfo._onAfterRenderObservable.notifyObservers(this);
    }
    return this;
  };
  Mesh2.prototype._onBeforeDraw = function(isInstance, world, effectiveMaterial) {
    if (isInstance && effectiveMaterial) {
      effectiveMaterial.bindOnlyWorldMatrix(world);
    }
  };
  Mesh2.prototype.cleanMatrixWeights = function() {
    if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
      if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {
        this.normalizeSkinWeightsAndExtra();
      } else {
        this.normalizeSkinFourWeights();
      }
    }
  };
  Mesh2.prototype.normalizeSkinFourWeights = function() {
    var matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
    var numWeights = matricesWeights.length;
    for (var a = 0; a < numWeights; a += 4) {
      var t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];
      if (t === 0) {
        matricesWeights[a] = 1;
      } else {
        var recip = 1 / t;
        matricesWeights[a] *= recip;
        matricesWeights[a + 1] *= recip;
        matricesWeights[a + 2] *= recip;
        matricesWeights[a + 3] *= recip;
      }
    }
    this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);
  };
  Mesh2.prototype.normalizeSkinWeightsAndExtra = function() {
    var matricesWeightsExtra = this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);
    var matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
    var numWeights = matricesWeights.length;
    for (var a = 0; a < numWeights; a += 4) {
      var t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];
      t += matricesWeightsExtra[a] + matricesWeightsExtra[a + 1] + matricesWeightsExtra[a + 2] + matricesWeightsExtra[a + 3];
      if (t === 0) {
        matricesWeights[a] = 1;
      } else {
        var recip = 1 / t;
        matricesWeights[a] *= recip;
        matricesWeights[a + 1] *= recip;
        matricesWeights[a + 2] *= recip;
        matricesWeights[a + 3] *= recip;
        matricesWeightsExtra[a] *= recip;
        matricesWeightsExtra[a + 1] *= recip;
        matricesWeightsExtra[a + 2] *= recip;
        matricesWeightsExtra[a + 3] *= recip;
      }
    }
    this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);
    this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsExtra);
  };
  Mesh2.prototype.validateSkinning = function() {
    var matricesWeightsExtra = this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);
    var matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
    if (matricesWeights === null || this.skeleton == null) {
      return { skinned: false, valid: true, report: "not skinned" };
    }
    var numWeights = matricesWeights.length;
    var numberNotSorted = 0;
    var missingWeights = 0;
    var maxUsedWeights = 0;
    var numberNotNormalized = 0;
    var numInfluences = matricesWeightsExtra === null ? 4 : 8;
    var usedWeightCounts = new Array();
    for (var a = 0; a <= numInfluences; a++) {
      usedWeightCounts[a] = 0;
    }
    var toleranceEpsilon = 1e-3;
    for (var a = 0; a < numWeights; a += 4) {
      var lastWeight = matricesWeights[a];
      var t = lastWeight;
      var usedWeights = t === 0 ? 0 : 1;
      for (var b = 1; b < numInfluences; b++) {
        var d = b < 4 ? matricesWeights[a + b] : matricesWeightsExtra[a + b - 4];
        if (d > lastWeight) {
          numberNotSorted++;
        }
        if (d !== 0) {
          usedWeights++;
        }
        t += d;
        lastWeight = d;
      }
      usedWeightCounts[usedWeights]++;
      if (usedWeights > maxUsedWeights) {
        maxUsedWeights = usedWeights;
      }
      if (t === 0) {
        missingWeights++;
      } else {
        var recip = 1 / t;
        var tolerance = 0;
        for (b = 0; b < numInfluences; b++) {
          if (b < 4) {
            tolerance += Math.abs(matricesWeights[a + b] - matricesWeights[a + b] * recip);
          } else {
            tolerance += Math.abs(matricesWeightsExtra[a + b - 4] - matricesWeightsExtra[a + b - 4] * recip);
          }
        }
        if (tolerance > toleranceEpsilon) {
          numberNotNormalized++;
        }
      }
    }
    var numBones = this.skeleton.bones.length;
    var matricesIndices = this.getVerticesData(VertexBuffer.MatricesIndicesKind);
    var matricesIndicesExtra = this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);
    var numBadBoneIndices = 0;
    for (var a = 0; a < numWeights; a += 4) {
      for (var b = 0; b < numInfluences; b++) {
        var index = b < 4 ? matricesIndices[a + b] : matricesIndicesExtra[a + b - 4];
        if (index >= numBones || index < 0) {
          numBadBoneIndices++;
        }
      }
    }
    var output = "Number of Weights = " + numWeights / 4 + "\nMaximum influences = " + maxUsedWeights + "\nMissing Weights = " + missingWeights + "\nNot Sorted = " + numberNotSorted + "\nNot Normalized = " + numberNotNormalized + "\nWeightCounts = [" + usedWeightCounts + "]\nNumber of bones = " + numBones + "\nBad Bone Indices = " + numBadBoneIndices;
    return { skinned: true, valid: missingWeights === 0 && numberNotNormalized === 0 && numBadBoneIndices === 0, report: output };
  };
  Mesh2.prototype._checkDelayState = function() {
    var scene = this.getScene();
    if (this._geometry) {
      this._geometry.load(scene);
    } else if (this.delayLoadState === 4) {
      this.delayLoadState = 2;
      this._queueLoad(scene);
    }
    return this;
  };
  Mesh2.prototype._queueLoad = function(scene) {
    var _this = this;
    scene._addPendingData(this);
    var getBinaryData = this.delayLoadingFile.indexOf(".babylonbinarymeshdata") !== -1;
    Tools.LoadFile(this.delayLoadingFile, function(data) {
      if (data instanceof ArrayBuffer) {
        _this._delayLoadingFunction(data, _this);
      } else {
        _this._delayLoadingFunction(JSON.parse(data), _this);
      }
      _this.instances.forEach(function(instance) {
        instance.refreshBoundingInfo();
        instance._syncSubMeshes();
      });
      _this.delayLoadState = 1;
      scene._removePendingData(_this);
    }, function() {
    }, scene.offlineProvider, getBinaryData);
    return this;
  };
  Mesh2.prototype.isInFrustum = function(frustumPlanes) {
    if (this.delayLoadState === 2) {
      return false;
    }
    if (!_super.prototype.isInFrustum.call(this, frustumPlanes)) {
      return false;
    }
    this._checkDelayState();
    return true;
  };
  Mesh2.prototype.setMaterialByID = function(id) {
    var materials = this.getScene().materials;
    var index;
    for (index = materials.length - 1; index > -1; index--) {
      if (materials[index].id === id) {
        this.material = materials[index];
        return this;
      }
    }
    var multiMaterials = this.getScene().multiMaterials;
    for (index = multiMaterials.length - 1; index > -1; index--) {
      if (multiMaterials[index].id === id) {
        this.material = multiMaterials[index];
        return this;
      }
    }
    return this;
  };
  Mesh2.prototype.getAnimatables = function() {
    var results = new Array();
    if (this.material) {
      results.push(this.material);
    }
    if (this.skeleton) {
      results.push(this.skeleton);
    }
    return results;
  };
  Mesh2.prototype.bakeTransformIntoVertices = function(transform) {
    if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {
      return this;
    }
    var submeshes = this.subMeshes.splice(0);
    this._resetPointsArrayCache();
    var data = this.getVerticesData(VertexBuffer.PositionKind);
    var temp = new Array();
    var index;
    for (index = 0; index < data.length; index += 3) {
      Vector3.TransformCoordinates(Vector3.FromArray(data, index), transform).toArray(temp, index);
    }
    this.setVerticesData(VertexBuffer.PositionKind, temp, this.getVertexBuffer(VertexBuffer.PositionKind).isUpdatable());
    if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      data = this.getVerticesData(VertexBuffer.NormalKind);
      temp = [];
      for (index = 0; index < data.length; index += 3) {
        Vector3.TransformNormal(Vector3.FromArray(data, index), transform).normalize().toArray(temp, index);
      }
      this.setVerticesData(VertexBuffer.NormalKind, temp, this.getVertexBuffer(VertexBuffer.NormalKind).isUpdatable());
    }
    if (transform.m[0] * transform.m[5] * transform.m[10] < 0) {
      this.flipFaces();
    }
    this.releaseSubMeshes();
    this.subMeshes = submeshes;
    return this;
  };
  Mesh2.prototype.bakeCurrentTransformIntoVertices = function(bakeIndependenlyOfChildren) {
    if (bakeIndependenlyOfChildren === void 0) {
      bakeIndependenlyOfChildren = true;
    }
    this.bakeTransformIntoVertices(this.computeWorldMatrix(true));
    this.resetLocalMatrix(bakeIndependenlyOfChildren);
    return this;
  };
  Object.defineProperty(Mesh2.prototype, "_positions", {
    get: function() {
      if (this._geometry) {
        return this._geometry._positions;
      }
      return null;
    },
    enumerable: false,
    configurable: true
  });
  Mesh2.prototype._resetPointsArrayCache = function() {
    if (this._geometry) {
      this._geometry._resetPointsArrayCache();
    }
    return this;
  };
  Mesh2.prototype._generatePointsArray = function() {
    if (this._geometry) {
      return this._geometry._generatePointsArray();
    }
    return false;
  };
  Mesh2.prototype.clone = function(name45, newParent, doNotCloneChildren, clonePhysicsImpostor) {
    if (name45 === void 0) {
      name45 = "";
    }
    if (newParent === void 0) {
      newParent = null;
    }
    if (clonePhysicsImpostor === void 0) {
      clonePhysicsImpostor = true;
    }
    return new Mesh2(name45, this.getScene(), newParent, this, doNotCloneChildren, clonePhysicsImpostor);
  };
  Mesh2.prototype.dispose = function(doNotRecurse, disposeMaterialAndTextures) {
    if (disposeMaterialAndTextures === void 0) {
      disposeMaterialAndTextures = false;
    }
    this.morphTargetManager = null;
    if (this._geometry) {
      this._geometry.releaseForMesh(this, true);
    }
    var internalDataInfo = this._internalMeshDataInfo;
    if (internalDataInfo._onBeforeDrawObservable) {
      internalDataInfo._onBeforeDrawObservable.clear();
    }
    if (internalDataInfo._onBeforeBindObservable) {
      internalDataInfo._onBeforeBindObservable.clear();
    }
    if (internalDataInfo._onBeforeRenderObservable) {
      internalDataInfo._onBeforeRenderObservable.clear();
    }
    if (internalDataInfo._onAfterRenderObservable) {
      internalDataInfo._onAfterRenderObservable.clear();
    }
    if (this._scene.useClonedMeshMap) {
      if (internalDataInfo.meshMap) {
        for (var uniqueId in internalDataInfo.meshMap) {
          var mesh = internalDataInfo.meshMap[uniqueId];
          if (mesh) {
            mesh._internalMeshDataInfo._source = null;
            internalDataInfo.meshMap[uniqueId] = void 0;
          }
        }
      }
      if (internalDataInfo._source && internalDataInfo._source._internalMeshDataInfo.meshMap) {
        internalDataInfo._source._internalMeshDataInfo.meshMap[this.uniqueId] = void 0;
      }
    } else {
      var meshes = this.getScene().meshes;
      for (var _i = 0, meshes_1 = meshes; _i < meshes_1.length; _i++) {
        var abstractMesh = meshes_1[_i];
        var mesh = abstractMesh;
        if (mesh._internalMeshDataInfo && mesh._internalMeshDataInfo._source && mesh._internalMeshDataInfo._source === this) {
          mesh._internalMeshDataInfo._source = null;
        }
      }
    }
    internalDataInfo._source = null;
    this._disposeInstanceSpecificData();
    this._disposeThinInstanceSpecificData();
    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);
  };
  Mesh2.prototype._disposeInstanceSpecificData = function() {
  };
  Mesh2.prototype._disposeThinInstanceSpecificData = function() {
  };
  Mesh2.prototype.applyDisplacementMap = function(url, minHeight, maxHeight, onSuccess, uvOffset, uvScale, forceUpdate) {
    var _this = this;
    if (forceUpdate === void 0) {
      forceUpdate = false;
    }
    var scene = this.getScene();
    var onload = function(img) {
      var heightMapWidth = img.width;
      var heightMapHeight = img.height;
      var canvas = CanvasGenerator.CreateCanvas(heightMapWidth, heightMapHeight);
      var context = canvas.getContext("2d");
      context.drawImage(img, 0, 0);
      var buffer = context.getImageData(0, 0, heightMapWidth, heightMapHeight).data;
      _this.applyDisplacementMapFromBuffer(buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale, forceUpdate);
      if (onSuccess) {
        onSuccess(_this);
      }
    };
    Tools.LoadImage(url, onload, function() {
    }, scene.offlineProvider);
    return this;
  };
  Mesh2.prototype.applyDisplacementMapFromBuffer = function(buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale, forceUpdate) {
    if (forceUpdate === void 0) {
      forceUpdate = false;
    }
    if (!this.isVerticesDataPresent(VertexBuffer.PositionKind) || !this.isVerticesDataPresent(VertexBuffer.NormalKind) || !this.isVerticesDataPresent(VertexBuffer.UVKind)) {
      Logger.Warn("Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing");
      return this;
    }
    var positions = this.getVerticesData(VertexBuffer.PositionKind, true, true);
    var normals = this.getVerticesData(VertexBuffer.NormalKind);
    var uvs = this.getVerticesData(VertexBuffer.UVKind);
    var position = Vector3.Zero();
    var normal = Vector3.Zero();
    var uv = Vector2.Zero();
    uvOffset = uvOffset || Vector2.Zero();
    uvScale = uvScale || new Vector2(1, 1);
    for (var index = 0; index < positions.length; index += 3) {
      Vector3.FromArrayToRef(positions, index, position);
      Vector3.FromArrayToRef(normals, index, normal);
      Vector2.FromArrayToRef(uvs, index / 3 * 2, uv);
      var u = Math.abs(uv.x * uvScale.x + uvOffset.x % 1) * (heightMapWidth - 1) % heightMapWidth | 0;
      var v = Math.abs(uv.y * uvScale.y + uvOffset.y % 1) * (heightMapHeight - 1) % heightMapHeight | 0;
      var pos = (u + v * heightMapWidth) * 4;
      var r = buffer[pos] / 255;
      var g = buffer[pos + 1] / 255;
      var b = buffer[pos + 2] / 255;
      var gradient = r * 0.3 + g * 0.59 + b * 0.11;
      normal.normalize();
      normal.scaleInPlace(minHeight + (maxHeight - minHeight) * gradient);
      position = position.add(normal);
      position.toArray(positions, index);
    }
    VertexData.ComputeNormals(positions, this.getIndices(), normals);
    if (forceUpdate) {
      this.setVerticesData(VertexBuffer.PositionKind, positions);
      this.setVerticesData(VertexBuffer.NormalKind, normals);
    } else {
      this.updateVerticesData(VertexBuffer.PositionKind, positions);
      this.updateVerticesData(VertexBuffer.NormalKind, normals);
    }
    return this;
  };
  Mesh2.prototype.convertToFlatShadedMesh = function() {
    var kinds = this.getVerticesDataKinds();
    var vbs = {};
    var data = {};
    var newdata = {};
    var updatableNormals = false;
    var kindIndex;
    var kind;
    for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
      kind = kinds[kindIndex];
      var vertexBuffer = this.getVertexBuffer(kind);
      if (kind === VertexBuffer.NormalKind) {
        updatableNormals = vertexBuffer.isUpdatable();
        kinds.splice(kindIndex, 1);
        kindIndex--;
        continue;
      }
      vbs[kind] = vertexBuffer;
      data[kind] = vbs[kind].getData();
      newdata[kind] = [];
    }
    var previousSubmeshes = this.subMeshes.slice(0);
    var indices = this.getIndices();
    var totalIndices = this.getTotalIndices();
    var index;
    for (index = 0; index < totalIndices; index++) {
      var vertexIndex = indices[index];
      for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
        kind = kinds[kindIndex];
        var stride = vbs[kind].getStrideSize();
        for (var offset = 0; offset < stride; offset++) {
          newdata[kind].push(data[kind][vertexIndex * stride + offset]);
        }
      }
    }
    var normals = [];
    var positions = newdata[VertexBuffer.PositionKind];
    for (index = 0; index < totalIndices; index += 3) {
      indices[index] = index;
      indices[index + 1] = index + 1;
      indices[index + 2] = index + 2;
      var p1 = Vector3.FromArray(positions, index * 3);
      var p2 = Vector3.FromArray(positions, (index + 1) * 3);
      var p3 = Vector3.FromArray(positions, (index + 2) * 3);
      var p1p2 = p1.subtract(p2);
      var p3p2 = p3.subtract(p2);
      var normal = Vector3.Normalize(Vector3.Cross(p1p2, p3p2));
      for (var localIndex = 0; localIndex < 3; localIndex++) {
        normals.push(normal.x);
        normals.push(normal.y);
        normals.push(normal.z);
      }
    }
    this.setIndices(indices);
    this.setVerticesData(VertexBuffer.NormalKind, normals, updatableNormals);
    for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
      kind = kinds[kindIndex];
      this.setVerticesData(kind, newdata[kind], vbs[kind].isUpdatable());
    }
    this.releaseSubMeshes();
    for (var submeshIndex = 0; submeshIndex < previousSubmeshes.length; submeshIndex++) {
      var previousOne = previousSubmeshes[submeshIndex];
      SubMesh.AddToMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);
    }
    this.synchronizeInstances();
    return this;
  };
  Mesh2.prototype.convertToUnIndexedMesh = function() {
    var kinds = this.getVerticesDataKinds();
    var vbs = {};
    var data = {};
    var newdata = {};
    var kindIndex;
    var kind;
    for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
      kind = kinds[kindIndex];
      var vertexBuffer = this.getVertexBuffer(kind);
      vbs[kind] = vertexBuffer;
      data[kind] = vbs[kind].getData();
      newdata[kind] = [];
    }
    var previousSubmeshes = this.subMeshes.slice(0);
    var indices = this.getIndices();
    var totalIndices = this.getTotalIndices();
    var index;
    for (index = 0; index < totalIndices; index++) {
      var vertexIndex = indices[index];
      for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
        kind = kinds[kindIndex];
        var stride = vbs[kind].getStrideSize();
        for (var offset = 0; offset < stride; offset++) {
          newdata[kind].push(data[kind][vertexIndex * stride + offset]);
        }
      }
    }
    for (index = 0; index < totalIndices; index += 3) {
      indices[index] = index;
      indices[index + 1] = index + 1;
      indices[index + 2] = index + 2;
    }
    this.setIndices(indices);
    for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
      kind = kinds[kindIndex];
      this.setVerticesData(kind, newdata[kind], vbs[kind].isUpdatable());
    }
    this.releaseSubMeshes();
    for (var submeshIndex = 0; submeshIndex < previousSubmeshes.length; submeshIndex++) {
      var previousOne = previousSubmeshes[submeshIndex];
      SubMesh.AddToMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);
    }
    this._unIndexed = true;
    this.synchronizeInstances();
    return this;
  };
  Mesh2.prototype.flipFaces = function(flipNormals) {
    if (flipNormals === void 0) {
      flipNormals = false;
    }
    var vertex_data = VertexData.ExtractFromMesh(this);
    var i;
    if (flipNormals && this.isVerticesDataPresent(VertexBuffer.NormalKind) && vertex_data.normals) {
      for (i = 0; i < vertex_data.normals.length; i++) {
        vertex_data.normals[i] *= -1;
      }
    }
    if (vertex_data.indices) {
      var temp;
      for (i = 0; i < vertex_data.indices.length; i += 3) {
        temp = vertex_data.indices[i + 1];
        vertex_data.indices[i + 1] = vertex_data.indices[i + 2];
        vertex_data.indices[i + 2] = temp;
      }
    }
    vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));
    return this;
  };
  Mesh2.prototype.increaseVertices = function(numberPerEdge) {
    var vertex_data = VertexData.ExtractFromMesh(this);
    var uvs = vertex_data.uvs;
    var currentIndices = vertex_data.indices;
    var positions = vertex_data.positions;
    var normals = vertex_data.normals;
    if (!currentIndices || !positions || !normals || !uvs) {
      Logger.Warn("VertexData contains null entries");
    } else {
      var segments = numberPerEdge + 1;
      var tempIndices = new Array();
      for (var i = 0; i < segments + 1; i++) {
        tempIndices[i] = new Array();
      }
      var a;
      var b;
      var deltaPosition = new Vector3(0, 0, 0);
      var deltaNormal = new Vector3(0, 0, 0);
      var deltaUV = new Vector2(0, 0);
      var indices = new Array();
      var vertexIndex = new Array();
      var side = new Array();
      var len;
      var positionPtr = positions.length;
      var uvPtr = uvs.length;
      for (var i = 0; i < currentIndices.length; i += 3) {
        vertexIndex[0] = currentIndices[i];
        vertexIndex[1] = currentIndices[i + 1];
        vertexIndex[2] = currentIndices[i + 2];
        for (var j = 0; j < 3; j++) {
          a = vertexIndex[j];
          b = vertexIndex[(j + 1) % 3];
          if (side[a] === void 0 && side[b] === void 0) {
            side[a] = new Array();
            side[b] = new Array();
          } else {
            if (side[a] === void 0) {
              side[a] = new Array();
            }
            if (side[b] === void 0) {
              side[b] = new Array();
            }
          }
          if (side[a][b] === void 0 && side[b][a] === void 0) {
            side[a][b] = [];
            deltaPosition.x = (positions[3 * b] - positions[3 * a]) / segments;
            deltaPosition.y = (positions[3 * b + 1] - positions[3 * a + 1]) / segments;
            deltaPosition.z = (positions[3 * b + 2] - positions[3 * a + 2]) / segments;
            deltaNormal.x = (normals[3 * b] - normals[3 * a]) / segments;
            deltaNormal.y = (normals[3 * b + 1] - normals[3 * a + 1]) / segments;
            deltaNormal.z = (normals[3 * b + 2] - normals[3 * a + 2]) / segments;
            deltaUV.x = (uvs[2 * b] - uvs[2 * a]) / segments;
            deltaUV.y = (uvs[2 * b + 1] - uvs[2 * a + 1]) / segments;
            side[a][b].push(a);
            for (var k = 1; k < segments; k++) {
              side[a][b].push(positions.length / 3);
              positions[positionPtr] = positions[3 * a] + k * deltaPosition.x;
              normals[positionPtr++] = normals[3 * a] + k * deltaNormal.x;
              positions[positionPtr] = positions[3 * a + 1] + k * deltaPosition.y;
              normals[positionPtr++] = normals[3 * a + 1] + k * deltaNormal.y;
              positions[positionPtr] = positions[3 * a + 2] + k * deltaPosition.z;
              normals[positionPtr++] = normals[3 * a + 2] + k * deltaNormal.z;
              uvs[uvPtr++] = uvs[2 * a] + k * deltaUV.x;
              uvs[uvPtr++] = uvs[2 * a + 1] + k * deltaUV.y;
            }
            side[a][b].push(b);
            side[b][a] = new Array();
            len = side[a][b].length;
            for (var idx = 0; idx < len; idx++) {
              side[b][a][idx] = side[a][b][len - 1 - idx];
            }
          }
        }
        tempIndices[0][0] = currentIndices[i];
        tempIndices[1][0] = side[currentIndices[i]][currentIndices[i + 1]][1];
        tempIndices[1][1] = side[currentIndices[i]][currentIndices[i + 2]][1];
        for (var k = 2; k < segments; k++) {
          tempIndices[k][0] = side[currentIndices[i]][currentIndices[i + 1]][k];
          tempIndices[k][k] = side[currentIndices[i]][currentIndices[i + 2]][k];
          deltaPosition.x = (positions[3 * tempIndices[k][k]] - positions[3 * tempIndices[k][0]]) / k;
          deltaPosition.y = (positions[3 * tempIndices[k][k] + 1] - positions[3 * tempIndices[k][0] + 1]) / k;
          deltaPosition.z = (positions[3 * tempIndices[k][k] + 2] - positions[3 * tempIndices[k][0] + 2]) / k;
          deltaNormal.x = (normals[3 * tempIndices[k][k]] - normals[3 * tempIndices[k][0]]) / k;
          deltaNormal.y = (normals[3 * tempIndices[k][k] + 1] - normals[3 * tempIndices[k][0] + 1]) / k;
          deltaNormal.z = (normals[3 * tempIndices[k][k] + 2] - normals[3 * tempIndices[k][0] + 2]) / k;
          deltaUV.x = (uvs[2 * tempIndices[k][k]] - uvs[2 * tempIndices[k][0]]) / k;
          deltaUV.y = (uvs[2 * tempIndices[k][k] + 1] - uvs[2 * tempIndices[k][0] + 1]) / k;
          for (var j = 1; j < k; j++) {
            tempIndices[k][j] = positions.length / 3;
            positions[positionPtr] = positions[3 * tempIndices[k][0]] + j * deltaPosition.x;
            normals[positionPtr++] = normals[3 * tempIndices[k][0]] + j * deltaNormal.x;
            positions[positionPtr] = positions[3 * tempIndices[k][0] + 1] + j * deltaPosition.y;
            normals[positionPtr++] = normals[3 * tempIndices[k][0] + 1] + j * deltaNormal.y;
            positions[positionPtr] = positions[3 * tempIndices[k][0] + 2] + j * deltaPosition.z;
            normals[positionPtr++] = normals[3 * tempIndices[k][0] + 2] + j * deltaNormal.z;
            uvs[uvPtr++] = uvs[2 * tempIndices[k][0]] + j * deltaUV.x;
            uvs[uvPtr++] = uvs[2 * tempIndices[k][0] + 1] + j * deltaUV.y;
          }
        }
        tempIndices[segments] = side[currentIndices[i + 1]][currentIndices[i + 2]];
        indices.push(tempIndices[0][0], tempIndices[1][0], tempIndices[1][1]);
        for (var k = 1; k < segments; k++) {
          for (var j = 0; j < k; j++) {
            indices.push(tempIndices[k][j], tempIndices[k + 1][j], tempIndices[k + 1][j + 1]);
            indices.push(tempIndices[k][j], tempIndices[k + 1][j + 1], tempIndices[k][j + 1]);
          }
          indices.push(tempIndices[k][j], tempIndices[k + 1][j], tempIndices[k + 1][j + 1]);
        }
      }
      vertex_data.indices = indices;
      vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));
    }
  };
  Mesh2.prototype.forceSharedVertices = function() {
    var vertex_data = VertexData.ExtractFromMesh(this);
    var currentUVs = vertex_data.uvs;
    var currentIndices = vertex_data.indices;
    var currentPositions = vertex_data.positions;
    var currentColors = vertex_data.colors;
    if (currentIndices === void 0 || currentPositions === void 0 || currentIndices === null || currentPositions === null) {
      Logger.Warn("VertexData contains empty entries");
    } else {
      var positions = new Array();
      var indices = new Array();
      var uvs = new Array();
      var colors = new Array();
      var pstring = new Array();
      var indexPtr = 0;
      var uniquePositions = {};
      var ptr;
      var facet;
      for (var i = 0; i < currentIndices.length; i += 3) {
        facet = [currentIndices[i], currentIndices[i + 1], currentIndices[i + 2]];
        pstring = new Array();
        for (var j = 0; j < 3; j++) {
          pstring[j] = "";
          for (var k = 0; k < 3; k++) {
            if (Math.abs(currentPositions[3 * facet[j] + k]) < 1e-8) {
              currentPositions[3 * facet[j] + k] = 0;
            }
            pstring[j] += currentPositions[3 * facet[j] + k] + "|";
          }
        }
        if (!(pstring[0] == pstring[1] || pstring[0] == pstring[2] || pstring[1] == pstring[2])) {
          for (var j = 0; j < 3; j++) {
            ptr = uniquePositions[pstring[j]];
            if (ptr === void 0) {
              uniquePositions[pstring[j]] = indexPtr;
              ptr = indexPtr++;
              for (var k = 0; k < 3; k++) {
                positions.push(currentPositions[3 * facet[j] + k]);
              }
              if (currentColors !== null && currentColors !== void 0) {
                for (var k = 0; k < 4; k++) {
                  colors.push(currentColors[4 * facet[j] + k]);
                }
              }
              if (currentUVs !== null && currentUVs !== void 0) {
                for (var k = 0; k < 2; k++) {
                  uvs.push(currentUVs[2 * facet[j] + k]);
                }
              }
            }
            indices.push(ptr);
          }
        }
      }
      var normals = new Array();
      VertexData.ComputeNormals(positions, indices, normals);
      vertex_data.positions = positions;
      vertex_data.indices = indices;
      vertex_data.normals = normals;
      if (currentUVs !== null && currentUVs !== void 0) {
        vertex_data.uvs = uvs;
      }
      if (currentColors !== null && currentColors !== void 0) {
        vertex_data.colors = colors;
      }
      vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));
    }
  };
  Mesh2._instancedMeshFactory = function(name45, mesh) {
    throw _DevTools.WarnImport("InstancedMesh");
  };
  Mesh2._PhysicsImpostorParser = function(scene, physicObject, jsonObject) {
    throw _DevTools.WarnImport("PhysicsImpostor");
  };
  Mesh2.prototype.createInstance = function(name45) {
    var geometry = this.geometry;
    if (geometry && geometry.meshes.length > 1) {
      var others = geometry.meshes.slice(0);
      for (var _i = 0, others_1 = others; _i < others_1.length; _i++) {
        var other = others_1[_i];
        if (other === this) {
          continue;
        }
        other.makeGeometryUnique();
      }
    }
    return Mesh2._instancedMeshFactory(name45, this);
  };
  Mesh2.prototype.synchronizeInstances = function() {
    if (this._geometry && this._geometry.meshes.length !== 1 && this.instances.length) {
      this.makeGeometryUnique();
    }
    for (var instanceIndex = 0; instanceIndex < this.instances.length; instanceIndex++) {
      var instance = this.instances[instanceIndex];
      instance._syncSubMeshes();
    }
    return this;
  };
  Mesh2.prototype.optimizeIndices = function(successCallback) {
    var _this = this;
    var indices = this.getIndices();
    var positions = this.getVerticesData(VertexBuffer.PositionKind);
    if (!positions || !indices) {
      return this;
    }
    var vectorPositions = new Array();
    for (var pos = 0; pos < positions.length; pos = pos + 3) {
      vectorPositions.push(Vector3.FromArray(positions, pos));
    }
    var dupes = new Array();
    AsyncLoop.SyncAsyncForLoop(vectorPositions.length, 40, function(iteration) {
      var realPos = vectorPositions.length - 1 - iteration;
      var testedPosition = vectorPositions[realPos];
      for (var j = 0; j < realPos; ++j) {
        var againstPosition = vectorPositions[j];
        if (testedPosition.equals(againstPosition)) {
          dupes[realPos] = j;
          break;
        }
      }
    }, function() {
      for (var i = 0; i < indices.length; ++i) {
        indices[i] = dupes[indices[i]] || indices[i];
      }
      var originalSubMeshes = _this.subMeshes.slice(0);
      _this.setIndices(indices);
      _this.subMeshes = originalSubMeshes;
      if (successCallback) {
        successCallback(_this);
      }
    });
    return this;
  };
  Mesh2.prototype.serialize = function(serializationObject) {
    serializationObject.name = this.name;
    serializationObject.id = this.id;
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.type = this.getClassName();
    if (Tags && Tags.HasTags(this)) {
      serializationObject.tags = Tags.GetTags(this);
    }
    serializationObject.position = this.position.asArray();
    if (this.rotationQuaternion) {
      serializationObject.rotationQuaternion = this.rotationQuaternion.asArray();
    } else if (this.rotation) {
      serializationObject.rotation = this.rotation.asArray();
    }
    serializationObject.scaling = this.scaling.asArray();
    if (this._postMultiplyPivotMatrix) {
      serializationObject.pivotMatrix = this.getPivotMatrix().asArray();
    } else {
      serializationObject.localMatrix = this.getPivotMatrix().asArray();
    }
    serializationObject.isEnabled = this.isEnabled(false);
    serializationObject.isVisible = this.isVisible;
    serializationObject.infiniteDistance = this.infiniteDistance;
    serializationObject.pickable = this.isPickable;
    serializationObject.receiveShadows = this.receiveShadows;
    serializationObject.billboardMode = this.billboardMode;
    serializationObject.visibility = this.visibility;
    serializationObject.checkCollisions = this.checkCollisions;
    serializationObject.isBlocker = this.isBlocker;
    serializationObject.overrideMaterialSideOrientation = this.overrideMaterialSideOrientation;
    if (this.parent) {
      serializationObject.parentId = this.parent.id;
    }
    serializationObject.isUnIndexed = this.isUnIndexed;
    var geometry = this._geometry;
    if (geometry) {
      var geometryId = geometry.id;
      serializationObject.geometryId = geometryId;
      serializationObject.subMeshes = [];
      for (var subIndex = 0; subIndex < this.subMeshes.length; subIndex++) {
        var subMesh = this.subMeshes[subIndex];
        serializationObject.subMeshes.push({
          materialIndex: subMesh.materialIndex,
          verticesStart: subMesh.verticesStart,
          verticesCount: subMesh.verticesCount,
          indexStart: subMesh.indexStart,
          indexCount: subMesh.indexCount
        });
      }
    }
    if (this.material) {
      if (!this.material.doNotSerialize) {
        serializationObject.materialId = this.material.id;
      }
    } else {
      this.material = null;
    }
    if (this.morphTargetManager) {
      serializationObject.morphTargetManagerId = this.morphTargetManager.uniqueId;
    }
    if (this.skeleton) {
      serializationObject.skeletonId = this.skeleton.id;
      serializationObject.numBoneInfluencers = this.numBoneInfluencers;
    }
    if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {
      var impostor = this.getPhysicsImpostor();
      if (impostor) {
        serializationObject.physicsMass = impostor.getParam("mass");
        serializationObject.physicsFriction = impostor.getParam("friction");
        serializationObject.physicsRestitution = impostor.getParam("mass");
        serializationObject.physicsImpostor = impostor.type;
      }
    }
    if (this.metadata) {
      serializationObject.metadata = this.metadata;
    }
    serializationObject.instances = [];
    for (var index = 0; index < this.instances.length; index++) {
      var instance = this.instances[index];
      if (instance.doNotSerialize) {
        continue;
      }
      var serializationInstance = {
        name: instance.name,
        id: instance.id,
        isEnabled: instance.isEnabled(false),
        isVisible: instance.isVisible,
        isPickable: instance.isPickable,
        checkCollisions: instance.checkCollisions,
        position: instance.position.asArray(),
        scaling: instance.scaling.asArray()
      };
      if (instance.parent) {
        serializationInstance.parentId = instance.parent.id;
      }
      if (instance.rotationQuaternion) {
        serializationInstance.rotationQuaternion = instance.rotationQuaternion.asArray();
      } else if (instance.rotation) {
        serializationInstance.rotation = instance.rotation.asArray();
      }
      if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {
        var impostor = instance.getPhysicsImpostor();
        if (impostor) {
          serializationInstance.physicsMass = impostor.getParam("mass");
          serializationInstance.physicsFriction = impostor.getParam("friction");
          serializationInstance.physicsRestitution = impostor.getParam("mass");
          serializationInstance.physicsImpostor = impostor.type;
        }
      }
      if (instance.metadata) {
        serializationInstance.metadata = instance.metadata;
      }
      serializationObject.instances.push(serializationInstance);
      SerializationHelper.AppendSerializedAnimations(instance, serializationInstance);
      serializationInstance.ranges = instance.serializeAnimationRanges();
    }
    if (this._thinInstanceDataStorage.instancesCount && this._thinInstanceDataStorage.matrixData) {
      serializationObject.thinInstances = {
        instancesCount: this._thinInstanceDataStorage.instancesCount,
        matrixData: Tools.SliceToArray(this._thinInstanceDataStorage.matrixData),
        matrixBufferSize: this._thinInstanceDataStorage.matrixBufferSize
      };
      if (this._userThinInstanceBuffersStorage) {
        var userThinInstance = {
          data: {},
          sizes: {},
          strides: {}
        };
        for (var kind in this._userThinInstanceBuffersStorage.data) {
          userThinInstance.data[kind] = Tools.SliceToArray(this._userThinInstanceBuffersStorage.data[kind]);
          userThinInstance.sizes[kind] = this._userThinInstanceBuffersStorage.sizes[kind];
          userThinInstance.strides[kind] = this._userThinInstanceBuffersStorage.strides[kind];
        }
        serializationObject.thinInstances.userThinInstance = userThinInstance;
      }
    }
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    serializationObject.ranges = this.serializeAnimationRanges();
    serializationObject.layerMask = this.layerMask;
    serializationObject.alphaIndex = this.alphaIndex;
    serializationObject.hasVertexAlpha = this.hasVertexAlpha;
    serializationObject.overlayAlpha = this.overlayAlpha;
    serializationObject.overlayColor = this.overlayColor.asArray();
    serializationObject.renderOverlay = this.renderOverlay;
    serializationObject.applyFog = this.applyFog;
    if (this.actionManager) {
      serializationObject.actions = this.actionManager.serialize(this.name);
    }
  };
  Mesh2.prototype._syncGeometryWithMorphTargetManager = function() {
    if (!this.geometry) {
      return;
    }
    this._markSubMeshesAsAttributesDirty();
    var morphTargetManager = this._internalMeshDataInfo._morphTargetManager;
    if (morphTargetManager && morphTargetManager.vertexCount) {
      if (morphTargetManager.vertexCount !== this.getTotalVertices()) {
        Logger.Error("Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count.");
        this.morphTargetManager = null;
        return;
      }
      for (var index = 0; index < morphTargetManager.numInfluencers; index++) {
        var morphTarget = morphTargetManager.getActiveTarget(index);
        var positions = morphTarget.getPositions();
        if (!positions) {
          Logger.Error("Invalid morph target. Target must have positions.");
          return;
        }
        this.geometry.setVerticesData(VertexBuffer.PositionKind + index, positions, false, 3);
        var normals = morphTarget.getNormals();
        if (normals) {
          this.geometry.setVerticesData(VertexBuffer.NormalKind + index, normals, false, 3);
        }
        var tangents = morphTarget.getTangents();
        if (tangents) {
          this.geometry.setVerticesData(VertexBuffer.TangentKind + index, tangents, false, 3);
        }
        var uvs = morphTarget.getUVs();
        if (uvs) {
          this.geometry.setVerticesData(VertexBuffer.UVKind + "_" + index, uvs, false, 2);
        }
      }
    } else {
      var index = 0;
      while (this.geometry.isVerticesDataPresent(VertexBuffer.PositionKind + index)) {
        this.geometry.removeVerticesData(VertexBuffer.PositionKind + index);
        if (this.geometry.isVerticesDataPresent(VertexBuffer.NormalKind + index)) {
          this.geometry.removeVerticesData(VertexBuffer.NormalKind + index);
        }
        if (this.geometry.isVerticesDataPresent(VertexBuffer.TangentKind + index)) {
          this.geometry.removeVerticesData(VertexBuffer.TangentKind + index);
        }
        if (this.geometry.isVerticesDataPresent(VertexBuffer.UVKind + index)) {
          this.geometry.removeVerticesData(VertexBuffer.UVKind + "_" + index);
        }
        index++;
      }
    }
  };
  Mesh2.Parse = function(parsedMesh, scene, rootUrl) {
    var mesh;
    if (parsedMesh.type && parsedMesh.type === "GroundMesh") {
      mesh = Mesh2._GroundMeshParser(parsedMesh, scene);
    } else {
      mesh = new Mesh2(parsedMesh.name, scene);
    }
    mesh.id = parsedMesh.id;
    if (Tags) {
      Tags.AddTagsTo(mesh, parsedMesh.tags);
    }
    mesh.position = Vector3.FromArray(parsedMesh.position);
    if (parsedMesh.metadata !== void 0) {
      mesh.metadata = parsedMesh.metadata;
    }
    if (parsedMesh.rotationQuaternion) {
      mesh.rotationQuaternion = Quaternion.FromArray(parsedMesh.rotationQuaternion);
    } else if (parsedMesh.rotation) {
      mesh.rotation = Vector3.FromArray(parsedMesh.rotation);
    }
    mesh.scaling = Vector3.FromArray(parsedMesh.scaling);
    if (parsedMesh.localMatrix) {
      mesh.setPreTransformMatrix(Matrix.FromArray(parsedMesh.localMatrix));
    } else if (parsedMesh.pivotMatrix) {
      mesh.setPivotMatrix(Matrix.FromArray(parsedMesh.pivotMatrix));
    }
    mesh.setEnabled(parsedMesh.isEnabled);
    mesh.isVisible = parsedMesh.isVisible;
    mesh.infiniteDistance = parsedMesh.infiniteDistance;
    mesh.showBoundingBox = parsedMesh.showBoundingBox;
    mesh.showSubMeshesBoundingBox = parsedMesh.showSubMeshesBoundingBox;
    if (parsedMesh.applyFog !== void 0) {
      mesh.applyFog = parsedMesh.applyFog;
    }
    if (parsedMesh.pickable !== void 0) {
      mesh.isPickable = parsedMesh.pickable;
    }
    if (parsedMesh.alphaIndex !== void 0) {
      mesh.alphaIndex = parsedMesh.alphaIndex;
    }
    mesh.receiveShadows = parsedMesh.receiveShadows;
    mesh.billboardMode = parsedMesh.billboardMode;
    if (parsedMesh.visibility !== void 0) {
      mesh.visibility = parsedMesh.visibility;
    }
    mesh.checkCollisions = parsedMesh.checkCollisions;
    mesh.overrideMaterialSideOrientation = parsedMesh.overrideMaterialSideOrientation;
    if (parsedMesh.isBlocker !== void 0) {
      mesh.isBlocker = parsedMesh.isBlocker;
    }
    mesh._shouldGenerateFlatShading = parsedMesh.useFlatShading;
    if (parsedMesh.freezeWorldMatrix) {
      mesh._waitingData.freezeWorldMatrix = parsedMesh.freezeWorldMatrix;
    }
    if (parsedMesh.parentId) {
      mesh._waitingParentId = parsedMesh.parentId;
    }
    if (parsedMesh.actions !== void 0) {
      mesh._waitingData.actions = parsedMesh.actions;
    }
    if (parsedMesh.overlayAlpha !== void 0) {
      mesh.overlayAlpha = parsedMesh.overlayAlpha;
    }
    if (parsedMesh.overlayColor !== void 0) {
      mesh.overlayColor = Color3.FromArray(parsedMesh.overlayColor);
    }
    if (parsedMesh.renderOverlay !== void 0) {
      mesh.renderOverlay = parsedMesh.renderOverlay;
    }
    mesh.isUnIndexed = !!parsedMesh.isUnIndexed;
    mesh.hasVertexAlpha = parsedMesh.hasVertexAlpha;
    if (parsedMesh.delayLoadingFile) {
      mesh.delayLoadState = 4;
      mesh.delayLoadingFile = rootUrl + parsedMesh.delayLoadingFile;
      mesh._boundingInfo = new BoundingInfo(Vector3.FromArray(parsedMesh.boundingBoxMinimum), Vector3.FromArray(parsedMesh.boundingBoxMaximum));
      if (parsedMesh._binaryInfo) {
        mesh._binaryInfo = parsedMesh._binaryInfo;
      }
      mesh._delayInfo = [];
      if (parsedMesh.hasUVs) {
        mesh._delayInfo.push(VertexBuffer.UVKind);
      }
      if (parsedMesh.hasUVs2) {
        mesh._delayInfo.push(VertexBuffer.UV2Kind);
      }
      if (parsedMesh.hasUVs3) {
        mesh._delayInfo.push(VertexBuffer.UV3Kind);
      }
      if (parsedMesh.hasUVs4) {
        mesh._delayInfo.push(VertexBuffer.UV4Kind);
      }
      if (parsedMesh.hasUVs5) {
        mesh._delayInfo.push(VertexBuffer.UV5Kind);
      }
      if (parsedMesh.hasUVs6) {
        mesh._delayInfo.push(VertexBuffer.UV6Kind);
      }
      if (parsedMesh.hasColors) {
        mesh._delayInfo.push(VertexBuffer.ColorKind);
      }
      if (parsedMesh.hasMatricesIndices) {
        mesh._delayInfo.push(VertexBuffer.MatricesIndicesKind);
      }
      if (parsedMesh.hasMatricesWeights) {
        mesh._delayInfo.push(VertexBuffer.MatricesWeightsKind);
      }
      mesh._delayLoadingFunction = Geometry._ImportGeometry;
      if (SceneLoaderFlags.ForceFullSceneLoadingForIncremental) {
        mesh._checkDelayState();
      }
    } else {
      Geometry._ImportGeometry(parsedMesh, mesh);
    }
    if (parsedMesh.materialId) {
      mesh.setMaterialByID(parsedMesh.materialId);
    } else {
      mesh.material = null;
    }
    if (parsedMesh.morphTargetManagerId > -1) {
      mesh.morphTargetManager = scene.getMorphTargetManagerById(parsedMesh.morphTargetManagerId);
    }
    if (parsedMesh.skeletonId !== void 0 && parsedMesh.skeletonId !== null) {
      mesh.skeleton = scene.getLastSkeletonByID(parsedMesh.skeletonId);
      if (parsedMesh.numBoneInfluencers) {
        mesh.numBoneInfluencers = parsedMesh.numBoneInfluencers;
      }
    }
    if (parsedMesh.animations) {
      for (var animationIndex = 0; animationIndex < parsedMesh.animations.length; animationIndex++) {
        var parsedAnimation = parsedMesh.animations[animationIndex];
        var internalClass = _TypeStore.GetClass("BABYLON.Animation");
        if (internalClass) {
          mesh.animations.push(internalClass.Parse(parsedAnimation));
        }
      }
      Node.ParseAnimationRanges(mesh, parsedMesh, scene);
    }
    if (parsedMesh.autoAnimate) {
      scene.beginAnimation(mesh, parsedMesh.autoAnimateFrom, parsedMesh.autoAnimateTo, parsedMesh.autoAnimateLoop, parsedMesh.autoAnimateSpeed || 1);
    }
    if (parsedMesh.layerMask && !isNaN(parsedMesh.layerMask)) {
      mesh.layerMask = Math.abs(parseInt(parsedMesh.layerMask));
    } else {
      mesh.layerMask = 268435455;
    }
    if (parsedMesh.physicsImpostor) {
      Mesh2._PhysicsImpostorParser(scene, mesh, parsedMesh);
    }
    if (parsedMesh.lodMeshIds) {
      mesh._waitingData.lods = {
        ids: parsedMesh.lodMeshIds,
        distances: parsedMesh.lodDistances ? parsedMesh.lodDistances : null,
        coverages: parsedMesh.lodCoverages ? parsedMesh.lodCoverages : null
      };
    }
    if (parsedMesh.instances) {
      for (var index = 0; index < parsedMesh.instances.length; index++) {
        var parsedInstance = parsedMesh.instances[index];
        var instance = mesh.createInstance(parsedInstance.name);
        if (parsedInstance.id) {
          instance.id = parsedInstance.id;
        }
        if (Tags) {
          if (parsedInstance.tags) {
            Tags.AddTagsTo(instance, parsedInstance.tags);
          } else {
            Tags.AddTagsTo(instance, parsedMesh.tags);
          }
        }
        instance.position = Vector3.FromArray(parsedInstance.position);
        if (parsedInstance.metadata !== void 0) {
          instance.metadata = parsedInstance.metadata;
        }
        if (parsedInstance.parentId) {
          instance._waitingParentId = parsedInstance.parentId;
        }
        if (parsedInstance.isEnabled !== void 0 && parsedInstance.isEnabled !== null) {
          instance.setEnabled(parsedInstance.isEnabled);
        }
        if (parsedInstance.isVisible !== void 0 && parsedInstance.isVisible !== null) {
          instance.isVisible = parsedInstance.isVisible;
        }
        if (parsedInstance.isPickable !== void 0 && parsedInstance.isPickable !== null) {
          instance.isPickable = parsedInstance.isPickable;
        }
        if (parsedInstance.rotationQuaternion) {
          instance.rotationQuaternion = Quaternion.FromArray(parsedInstance.rotationQuaternion);
        } else if (parsedInstance.rotation) {
          instance.rotation = Vector3.FromArray(parsedInstance.rotation);
        }
        instance.scaling = Vector3.FromArray(parsedInstance.scaling);
        if (parsedInstance.checkCollisions != void 0 && parsedInstance.checkCollisions != null) {
          instance.checkCollisions = parsedInstance.checkCollisions;
        }
        if (parsedInstance.pickable != void 0 && parsedInstance.pickable != null) {
          instance.isPickable = parsedInstance.pickable;
        }
        if (parsedInstance.showBoundingBox != void 0 && parsedInstance.showBoundingBox != null) {
          instance.showBoundingBox = parsedInstance.showBoundingBox;
        }
        if (parsedInstance.showSubMeshesBoundingBox != void 0 && parsedInstance.showSubMeshesBoundingBox != null) {
          instance.showSubMeshesBoundingBox = parsedInstance.showSubMeshesBoundingBox;
        }
        if (parsedInstance.alphaIndex != void 0 && parsedInstance.showSubMeshesBoundingBox != null) {
          instance.alphaIndex = parsedInstance.alphaIndex;
        }
        if (parsedInstance.physicsImpostor) {
          Mesh2._PhysicsImpostorParser(scene, instance, parsedInstance);
        }
        if (parsedInstance.animations) {
          for (animationIndex = 0; animationIndex < parsedInstance.animations.length; animationIndex++) {
            parsedAnimation = parsedInstance.animations[animationIndex];
            var internalClass = _TypeStore.GetClass("BABYLON.Animation");
            if (internalClass) {
              instance.animations.push(internalClass.Parse(parsedAnimation));
            }
          }
          Node.ParseAnimationRanges(instance, parsedInstance, scene);
          if (parsedInstance.autoAnimate) {
            scene.beginAnimation(instance, parsedInstance.autoAnimateFrom, parsedInstance.autoAnimateTo, parsedInstance.autoAnimateLoop, parsedInstance.autoAnimateSpeed || 1);
          }
        }
      }
    }
    if (parsedMesh.thinInstances) {
      var thinInstances = parsedMesh.thinInstances;
      if (thinInstances.matrixData) {
        mesh.thinInstanceSetBuffer("matrix", new Float32Array(thinInstances.matrixData), 16, false);
        mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;
        mesh._thinInstanceDataStorage.instancesCount = thinInstances.instancesCount;
      } else {
        mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;
      }
      if (parsedMesh.thinInstances.userThinInstance) {
        var userThinInstance = parsedMesh.thinInstances.userThinInstance;
        for (var kind in userThinInstance.data) {
          mesh.thinInstanceSetBuffer(kind, new Float32Array(userThinInstance.data[kind]), userThinInstance.strides[kind], false);
          mesh._userThinInstanceBuffersStorage.sizes[kind] = userThinInstance.sizes[kind];
        }
      }
    }
    return mesh;
  };
  Mesh2.CreateRibbon = function(name45, pathArray, closeArray, closePath, offset, scene, updatable, sideOrientation, instance) {
    throw _DevTools.WarnImport("MeshBuilder");
  };
  Mesh2.CreateDisc = function(name45, radius, tessellation, scene, updatable, sideOrientation) {
    if (scene === void 0) {
      scene = null;
    }
    throw _DevTools.WarnImport("MeshBuilder");
  };
  Mesh2.CreateBox = function(name45, size, scene, updatable, sideOrientation) {
    if (scene === void 0) {
      scene = null;
    }
    throw _DevTools.WarnImport("MeshBuilder");
  };
  Mesh2.CreateSphere = function(name45, segments, diameter, scene, updatable, sideOrientation) {
    throw _DevTools.WarnImport("MeshBuilder");
  };
  Mesh2.CreateHemisphere = function(name45, segments, diameter, scene) {
    throw _DevTools.WarnImport("MeshBuilder");
  };
  Mesh2.CreateCylinder = function(name45, height, diameterTop, diameterBottom, tessellation, subdivisions, scene, updatable, sideOrientation) {
    throw _DevTools.WarnImport("MeshBuilder");
  };
  Mesh2.CreateTorus = function(name45, diameter, thickness, tessellation, scene, updatable, sideOrientation) {
    throw _DevTools.WarnImport("MeshBuilder");
  };
  Mesh2.CreateTorusKnot = function(name45, radius, tube, radialSegments, tubularSegments, p, q, scene, updatable, sideOrientation) {
    throw _DevTools.WarnImport("MeshBuilder");
  };
  Mesh2.CreateLines = function(name45, points, scene, updatable, instance) {
    if (scene === void 0) {
      scene = null;
    }
    if (updatable === void 0) {
      updatable = false;
    }
    if (instance === void 0) {
      instance = null;
    }
    throw _DevTools.WarnImport("MeshBuilder");
  };
  Mesh2.CreateDashedLines = function(name45, points, dashSize, gapSize, dashNb, scene, updatable, instance) {
    if (scene === void 0) {
      scene = null;
    }
    throw _DevTools.WarnImport("MeshBuilder");
  };
  Mesh2.CreatePolygon = function(name45, shape, scene, holes, updatable, sideOrientation, earcutInjection) {
    if (earcutInjection === void 0) {
      earcutInjection = earcut;
    }
    throw _DevTools.WarnImport("MeshBuilder");
  };
  Mesh2.ExtrudePolygon = function(name45, shape, depth, scene, holes, updatable, sideOrientation, earcutInjection) {
    if (earcutInjection === void 0) {
      earcutInjection = earcut;
    }
    throw _DevTools.WarnImport("MeshBuilder");
  };
  Mesh2.ExtrudeShape = function(name45, shape, path, scale, rotation, cap, scene, updatable, sideOrientation, instance) {
    if (scene === void 0) {
      scene = null;
    }
    throw _DevTools.WarnImport("MeshBuilder");
  };
  Mesh2.ExtrudeShapeCustom = function(name45, shape, path, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, scene, updatable, sideOrientation, instance) {
    throw _DevTools.WarnImport("MeshBuilder");
  };
  Mesh2.CreateLathe = function(name45, shape, radius, tessellation, scene, updatable, sideOrientation) {
    throw _DevTools.WarnImport("MeshBuilder");
  };
  Mesh2.CreatePlane = function(name45, size, scene, updatable, sideOrientation) {
    throw _DevTools.WarnImport("MeshBuilder");
  };
  Mesh2.CreateGround = function(name45, width, height, subdivisions, scene, updatable) {
    throw _DevTools.WarnImport("MeshBuilder");
  };
  Mesh2.CreateTiledGround = function(name45, xmin, zmin, xmax, zmax, subdivisions, precision, scene, updatable) {
    throw _DevTools.WarnImport("MeshBuilder");
  };
  Mesh2.CreateGroundFromHeightMap = function(name45, url, width, height, subdivisions, minHeight, maxHeight, scene, updatable, onReady, alphaFilter) {
    throw _DevTools.WarnImport("MeshBuilder");
  };
  Mesh2.CreateTube = function(name45, path, radius, tessellation, radiusFunction, cap, scene, updatable, sideOrientation, instance) {
    throw _DevTools.WarnImport("MeshBuilder");
  };
  Mesh2.CreatePolyhedron = function(name45, options, scene) {
    throw _DevTools.WarnImport("MeshBuilder");
  };
  Mesh2.CreateIcoSphere = function(name45, options, scene) {
    throw _DevTools.WarnImport("MeshBuilder");
  };
  Mesh2.CreateDecal = function(name45, sourceMesh, position, normal, size, angle) {
    throw _DevTools.WarnImport("MeshBuilder");
  };
  Mesh2.CreateCapsule = function(name45, options, scene) {
    throw _DevTools.WarnImport("MeshBuilder");
  };
  Mesh2.prototype.setPositionsForCPUSkinning = function() {
    var internalDataInfo = this._internalMeshDataInfo;
    if (!internalDataInfo._sourcePositions) {
      var source = this.getVerticesData(VertexBuffer.PositionKind);
      if (!source) {
        return internalDataInfo._sourcePositions;
      }
      internalDataInfo._sourcePositions = new Float32Array(source);
      if (!this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {
        this.setVerticesData(VertexBuffer.PositionKind, source, true);
      }
    }
    return internalDataInfo._sourcePositions;
  };
  Mesh2.prototype.setNormalsForCPUSkinning = function() {
    var internalDataInfo = this._internalMeshDataInfo;
    if (!internalDataInfo._sourceNormals) {
      var source = this.getVerticesData(VertexBuffer.NormalKind);
      if (!source) {
        return internalDataInfo._sourceNormals;
      }
      internalDataInfo._sourceNormals = new Float32Array(source);
      if (!this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {
        this.setVerticesData(VertexBuffer.NormalKind, source, true);
      }
    }
    return internalDataInfo._sourceNormals;
  };
  Mesh2.prototype.applySkeleton = function(skeleton) {
    if (!this.geometry) {
      return this;
    }
    if (this.geometry._softwareSkinningFrameId == this.getScene().getFrameId()) {
      return this;
    }
    this.geometry._softwareSkinningFrameId = this.getScene().getFrameId();
    if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {
      return this;
    }
    if (!this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {
      return this;
    }
    if (!this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
      return this;
    }
    var hasNormals = this.isVerticesDataPresent(VertexBuffer.NormalKind);
    var internalDataInfo = this._internalMeshDataInfo;
    if (!internalDataInfo._sourcePositions) {
      var submeshes = this.subMeshes.slice();
      this.setPositionsForCPUSkinning();
      this.subMeshes = submeshes;
    }
    if (hasNormals && !internalDataInfo._sourceNormals) {
      this.setNormalsForCPUSkinning();
    }
    var positionsData = this.getVerticesData(VertexBuffer.PositionKind);
    if (!positionsData) {
      return this;
    }
    if (!(positionsData instanceof Float32Array)) {
      positionsData = new Float32Array(positionsData);
    }
    var normalsData = this.getVerticesData(VertexBuffer.NormalKind);
    if (hasNormals) {
      if (!normalsData) {
        return this;
      }
      if (!(normalsData instanceof Float32Array)) {
        normalsData = new Float32Array(normalsData);
      }
    }
    var matricesIndicesData = this.getVerticesData(VertexBuffer.MatricesIndicesKind);
    var matricesWeightsData = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
    if (!matricesWeightsData || !matricesIndicesData) {
      return this;
    }
    var needExtras = this.numBoneInfluencers > 4;
    var matricesIndicesExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;
    var matricesWeightsExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;
    var skeletonMatrices = skeleton.getTransformMatrices(this);
    var tempVector3 = Vector3.Zero();
    var finalMatrix = new Matrix();
    var tempMatrix = new Matrix();
    var matWeightIdx = 0;
    var inf;
    for (var index = 0; index < positionsData.length; index += 3, matWeightIdx += 4) {
      var weight;
      for (inf = 0; inf < 4; inf++) {
        weight = matricesWeightsData[matWeightIdx + inf];
        if (weight > 0) {
          Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);
          finalMatrix.addToSelf(tempMatrix);
        }
      }
      if (needExtras) {
        for (inf = 0; inf < 4; inf++) {
          weight = matricesWeightsExtraData[matWeightIdx + inf];
          if (weight > 0) {
            Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);
            finalMatrix.addToSelf(tempMatrix);
          }
        }
      }
      Vector3.TransformCoordinatesFromFloatsToRef(internalDataInfo._sourcePositions[index], internalDataInfo._sourcePositions[index + 1], internalDataInfo._sourcePositions[index + 2], finalMatrix, tempVector3);
      tempVector3.toArray(positionsData, index);
      if (hasNormals) {
        Vector3.TransformNormalFromFloatsToRef(internalDataInfo._sourceNormals[index], internalDataInfo._sourceNormals[index + 1], internalDataInfo._sourceNormals[index + 2], finalMatrix, tempVector3);
        tempVector3.toArray(normalsData, index);
      }
      finalMatrix.reset();
    }
    this.updateVerticesData(VertexBuffer.PositionKind, positionsData);
    if (hasNormals) {
      this.updateVerticesData(VertexBuffer.NormalKind, normalsData);
    }
    return this;
  };
  Mesh2.MinMax = function(meshes) {
    var minVector = null;
    var maxVector = null;
    meshes.forEach(function(mesh) {
      var boundingInfo = mesh.getBoundingInfo();
      var boundingBox = boundingInfo.boundingBox;
      if (!minVector || !maxVector) {
        minVector = boundingBox.minimumWorld;
        maxVector = boundingBox.maximumWorld;
      } else {
        minVector.minimizeInPlace(boundingBox.minimumWorld);
        maxVector.maximizeInPlace(boundingBox.maximumWorld);
      }
    });
    if (!minVector || !maxVector) {
      return {
        min: Vector3.Zero(),
        max: Vector3.Zero()
      };
    }
    return {
      min: minVector,
      max: maxVector
    };
  };
  Mesh2.Center = function(meshesOrMinMaxVector) {
    var minMaxVector = meshesOrMinMaxVector instanceof Array ? Mesh2.MinMax(meshesOrMinMaxVector) : meshesOrMinMaxVector;
    return Vector3.Center(minMaxVector.min, minMaxVector.max);
  };
  Mesh2.MergeMeshes = function(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials) {
    if (disposeSource === void 0) {
      disposeSource = true;
    }
    var index;
    if (!allow32BitsIndices) {
      var totalVertices = 0;
      for (index = 0; index < meshes.length; index++) {
        if (meshes[index]) {
          totalVertices += meshes[index].getTotalVertices();
          if (totalVertices >= 65536) {
            Logger.Warn("Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices");
            return null;
          }
        }
      }
    }
    if (multiMultiMaterials) {
      var newMultiMaterial = null;
      var subIndex;
      var matIndex;
      subdivideWithSubMeshes = false;
    }
    var materialArray = new Array();
    var materialIndexArray = new Array();
    var vertexData = null;
    var otherVertexData;
    var indiceArray = new Array();
    var source = null;
    for (index = 0; index < meshes.length; index++) {
      if (meshes[index]) {
        var mesh = meshes[index];
        if (mesh.isAnInstance) {
          Logger.Warn("Cannot merge instance meshes.");
          return null;
        }
        var wm = mesh.computeWorldMatrix(true);
        otherVertexData = VertexData.ExtractFromMesh(mesh, true, true);
        otherVertexData.transform(wm);
        if (vertexData) {
          vertexData.merge(otherVertexData, allow32BitsIndices);
        } else {
          vertexData = otherVertexData;
          source = mesh;
        }
        if (subdivideWithSubMeshes) {
          indiceArray.push(mesh.getTotalIndices());
        }
        if (multiMultiMaterials) {
          if (mesh.material) {
            var material = mesh.material;
            if (material instanceof MultiMaterial) {
              for (matIndex = 0; matIndex < material.subMaterials.length; matIndex++) {
                if (materialArray.indexOf(material.subMaterials[matIndex]) < 0) {
                  materialArray.push(material.subMaterials[matIndex]);
                }
              }
              for (subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {
                materialIndexArray.push(materialArray.indexOf(material.subMaterials[mesh.subMeshes[subIndex].materialIndex]));
                indiceArray.push(mesh.subMeshes[subIndex].indexCount);
              }
            } else {
              if (materialArray.indexOf(material) < 0) {
                materialArray.push(material);
              }
              for (subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {
                materialIndexArray.push(materialArray.indexOf(material));
                indiceArray.push(mesh.subMeshes[subIndex].indexCount);
              }
            }
          } else {
            for (subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {
              materialIndexArray.push(0);
              indiceArray.push(mesh.subMeshes[subIndex].indexCount);
            }
          }
        }
      }
    }
    source = source;
    if (!meshSubclass) {
      meshSubclass = new Mesh2(source.name + "_merged", source.getScene());
    }
    vertexData.applyToMesh(meshSubclass);
    meshSubclass.checkCollisions = source.checkCollisions;
    meshSubclass.overrideMaterialSideOrientation = source.overrideMaterialSideOrientation;
    if (disposeSource) {
      for (index = 0; index < meshes.length; index++) {
        if (meshes[index]) {
          meshes[index].dispose();
        }
      }
    }
    if (subdivideWithSubMeshes || multiMultiMaterials) {
      meshSubclass.releaseSubMeshes();
      index = 0;
      var offset = 0;
      while (index < indiceArray.length) {
        SubMesh.CreateFromIndices(0, offset, indiceArray[index], meshSubclass);
        offset += indiceArray[index];
        index++;
      }
    }
    if (multiMultiMaterials) {
      newMultiMaterial = new MultiMaterial(source.name + "_merged", source.getScene());
      newMultiMaterial.subMaterials = materialArray;
      for (subIndex = 0; subIndex < meshSubclass.subMeshes.length; subIndex++) {
        meshSubclass.subMeshes[subIndex].materialIndex = materialIndexArray[subIndex];
      }
      meshSubclass.material = newMultiMaterial;
    } else {
      meshSubclass.material = source.material;
    }
    return meshSubclass;
  };
  Mesh2.prototype.addInstance = function(instance) {
    instance._indexInSourceMeshInstanceArray = this.instances.length;
    this.instances.push(instance);
  };
  Mesh2.prototype.removeInstance = function(instance) {
    var index = instance._indexInSourceMeshInstanceArray;
    if (index != -1) {
      if (index !== this.instances.length - 1) {
        var last = this.instances[this.instances.length - 1];
        this.instances[index] = last;
        last._indexInSourceMeshInstanceArray = index;
      }
      instance._indexInSourceMeshInstanceArray = -1;
      this.instances.pop();
    }
  };
  Mesh2.FRONTSIDE = VertexData.FRONTSIDE;
  Mesh2.BACKSIDE = VertexData.BACKSIDE;
  Mesh2.DOUBLESIDE = VertexData.DOUBLESIDE;
  Mesh2.DEFAULTSIDE = VertexData.DEFAULTSIDE;
  Mesh2.NO_CAP = 0;
  Mesh2.CAP_START = 1;
  Mesh2.CAP_END = 2;
  Mesh2.CAP_ALL = 3;
  Mesh2.NO_FLIP = 0;
  Mesh2.FLIP_TILE = 1;
  Mesh2.ROTATE_TILE = 2;
  Mesh2.FLIP_ROW = 3;
  Mesh2.ROTATE_ROW = 4;
  Mesh2.FLIP_N_ROTATE_TILE = 5;
  Mesh2.FLIP_N_ROTATE_ROW = 6;
  Mesh2.CENTER = 0;
  Mesh2.LEFT = 1;
  Mesh2.RIGHT = 2;
  Mesh2.TOP = 3;
  Mesh2.BOTTOM = 4;
  Mesh2._GroundMeshParser = function(parsedMesh, scene) {
    throw _DevTools.WarnImport("GroundMesh");
  };
  return Mesh2;
}(AbstractMesh);
_TypeStore.RegisteredTypes["BABYLON.Mesh"] = Mesh;

// node_modules/@babylonjs/core/Materials/Textures/thinTexture.js
var ThinTexture = function() {
  function ThinTexture2(internalTexture) {
    this._wrapU = 1;
    this._wrapV = 1;
    this.wrapR = 1;
    this.anisotropicFilteringLevel = 4;
    this.delayLoadState = 0;
    this._texture = null;
    this._engine = null;
    this._cachedSize = Size.Zero();
    this._cachedBaseSize = Size.Zero();
    this._texture = internalTexture;
    if (this._texture) {
      this._engine = this._texture.getEngine();
    }
  }
  Object.defineProperty(ThinTexture2.prototype, "wrapU", {
    get: function() {
      return this._wrapU;
    },
    set: function(value) {
      this._wrapU = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinTexture2.prototype, "wrapV", {
    get: function() {
      return this._wrapV;
    },
    set: function(value) {
      this._wrapV = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinTexture2.prototype, "coordinatesMode", {
    get: function() {
      return 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinTexture2.prototype, "isCube", {
    get: function() {
      if (!this._texture) {
        return false;
      }
      return this._texture.isCube;
    },
    set: function(value) {
      if (!this._texture) {
        return;
      }
      this._texture.isCube = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinTexture2.prototype, "is3D", {
    get: function() {
      if (!this._texture) {
        return false;
      }
      return this._texture.is3D;
    },
    set: function(value) {
      if (!this._texture) {
        return;
      }
      this._texture.is3D = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinTexture2.prototype, "is2DArray", {
    get: function() {
      if (!this._texture) {
        return false;
      }
      return this._texture.is2DArray;
    },
    set: function(value) {
      if (!this._texture) {
        return;
      }
      this._texture.is2DArray = value;
    },
    enumerable: false,
    configurable: true
  });
  ThinTexture2.prototype.getClassName = function() {
    return "ThinTexture";
  };
  ThinTexture2.prototype.isReady = function() {
    if (this.delayLoadState === 4) {
      this.delayLoad();
      return false;
    }
    if (this._texture) {
      return this._texture.isReady;
    }
    return false;
  };
  ThinTexture2.prototype.delayLoad = function() {
  };
  ThinTexture2.prototype.getInternalTexture = function() {
    return this._texture;
  };
  ThinTexture2.prototype.getSize = function() {
    if (this._texture) {
      if (this._texture.width) {
        this._cachedSize.width = this._texture.width;
        this._cachedSize.height = this._texture.height;
        return this._cachedSize;
      }
      if (this._texture._size) {
        this._cachedSize.width = this._texture._size;
        this._cachedSize.height = this._texture._size;
        return this._cachedSize;
      }
    }
    return this._cachedSize;
  };
  ThinTexture2.prototype.getBaseSize = function() {
    if (!this.isReady() || !this._texture) {
      this._cachedBaseSize.width = 0;
      this._cachedBaseSize.height = 0;
      return this._cachedBaseSize;
    }
    if (this._texture._size) {
      this._cachedBaseSize.width = this._texture._size;
      this._cachedBaseSize.height = this._texture._size;
      return this._cachedBaseSize;
    }
    this._cachedBaseSize.width = this._texture.baseWidth;
    this._cachedBaseSize.height = this._texture.baseHeight;
    return this._cachedBaseSize;
  };
  ThinTexture2.prototype.updateSamplingMode = function(samplingMode) {
    if (this._texture && this._engine) {
      this._engine.updateTextureSamplingMode(samplingMode, this._texture);
    }
  };
  ThinTexture2.prototype.releaseInternalTexture = function() {
    if (this._texture) {
      this._texture.dispose();
      this._texture = null;
    }
  };
  ThinTexture2.prototype.dispose = function() {
    if (this._texture) {
      this.releaseInternalTexture();
      this._engine = null;
    }
  };
  return ThinTexture2;
}();

// node_modules/@babylonjs/core/Materials/Textures/baseTexture.js
var BaseTexture = function(_super) {
  __extends(BaseTexture2, _super);
  function BaseTexture2(sceneOrEngine) {
    var _this = _super.call(this, null) || this;
    _this.metadata = null;
    _this.reservedDataStore = null;
    _this._hasAlpha = false;
    _this.getAlphaFromRGB = false;
    _this.level = 1;
    _this.coordinatesIndex = 0;
    _this._coordinatesMode = 0;
    _this.wrapR = 1;
    _this.anisotropicFilteringLevel = BaseTexture2.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;
    _this._isCube = false;
    _this._gammaSpace = true;
    _this.invertZ = false;
    _this.lodLevelInAlpha = false;
    _this.isRenderTarget = false;
    _this._prefiltered = false;
    _this.animations = new Array();
    _this.onDisposeObservable = new Observable();
    _this._onDisposeObserver = null;
    _this._scene = null;
    _this._texture = null;
    _this._uid = null;
    if (sceneOrEngine) {
      if (BaseTexture2._isScene(sceneOrEngine)) {
        _this._scene = sceneOrEngine;
      } else {
        _this._engine = sceneOrEngine;
      }
    } else {
      _this._scene = EngineStore.LastCreatedScene;
    }
    if (_this._scene) {
      _this.uniqueId = _this._scene.getUniqueId();
      _this._scene.addTexture(_this);
      _this._engine = _this._scene.getEngine();
    }
    _this._uid = null;
    return _this;
  }
  Object.defineProperty(BaseTexture2.prototype, "hasAlpha", {
    get: function() {
      return this._hasAlpha;
    },
    set: function(value) {
      if (this._hasAlpha === value) {
        return;
      }
      this._hasAlpha = value;
      if (this._scene) {
        this._scene.markAllMaterialsAsDirty(1 | 16);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "coordinatesMode", {
    get: function() {
      return this._coordinatesMode;
    },
    set: function(value) {
      if (this._coordinatesMode === value) {
        return;
      }
      this._coordinatesMode = value;
      if (this._scene) {
        this._scene.markAllMaterialsAsDirty(1);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "wrapU", {
    get: function() {
      return this._wrapU;
    },
    set: function(value) {
      this._wrapU = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "wrapV", {
    get: function() {
      return this._wrapV;
    },
    set: function(value) {
      this._wrapV = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "isCube", {
    get: function() {
      if (!this._texture) {
        return this._isCube;
      }
      return this._texture.isCube;
    },
    set: function(value) {
      if (!this._texture) {
        this._isCube = value;
      } else {
        this._texture.isCube = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "is3D", {
    get: function() {
      if (!this._texture) {
        return false;
      }
      return this._texture.is3D;
    },
    set: function(value) {
      if (!this._texture) {
        return;
      }
      this._texture.is3D = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "is2DArray", {
    get: function() {
      if (!this._texture) {
        return false;
      }
      return this._texture.is2DArray;
    },
    set: function(value) {
      if (!this._texture) {
        return;
      }
      this._texture.is2DArray = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "gammaSpace", {
    get: function() {
      if (!this._texture) {
        return this._gammaSpace;
      } else {
        if (this._texture._gammaSpace === null) {
          this._texture._gammaSpace = this._gammaSpace;
        }
      }
      return this._texture._gammaSpace;
    },
    set: function(gamma) {
      if (!this._texture) {
        if (this._gammaSpace === gamma) {
          return;
        }
        this._gammaSpace = gamma;
      } else {
        if (this._texture._gammaSpace === gamma) {
          return;
        }
        this._texture._gammaSpace = gamma;
      }
      this._markAllSubMeshesAsTexturesDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "isRGBD", {
    get: function() {
      return this._texture != null && this._texture._isRGBD;
    },
    set: function(value) {
      if (this._texture) {
        this._texture._isRGBD = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "noMipmap", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "lodGenerationOffset", {
    get: function() {
      if (this._texture) {
        return this._texture._lodGenerationOffset;
      }
      return 0;
    },
    set: function(value) {
      if (this._texture) {
        this._texture._lodGenerationOffset = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "lodGenerationScale", {
    get: function() {
      if (this._texture) {
        return this._texture._lodGenerationScale;
      }
      return 0;
    },
    set: function(value) {
      if (this._texture) {
        this._texture._lodGenerationScale = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "linearSpecularLOD", {
    get: function() {
      if (this._texture) {
        return this._texture._linearSpecularLOD;
      }
      return false;
    },
    set: function(value) {
      if (this._texture) {
        this._texture._linearSpecularLOD = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "irradianceTexture", {
    get: function() {
      if (this._texture) {
        return this._texture._irradianceTexture;
      }
      return null;
    },
    set: function(value) {
      if (this._texture) {
        this._texture._irradianceTexture = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "uid", {
    get: function() {
      if (!this._uid) {
        this._uid = GUID.RandomId();
      }
      return this._uid;
    },
    enumerable: false,
    configurable: true
  });
  BaseTexture2.prototype.toString = function() {
    return this.name;
  };
  BaseTexture2.prototype.getClassName = function() {
    return "BaseTexture";
  };
  Object.defineProperty(BaseTexture2.prototype, "onDispose", {
    set: function(callback) {
      if (this._onDisposeObserver) {
        this.onDisposeObservable.remove(this._onDisposeObserver);
      }
      this._onDisposeObserver = this.onDisposeObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "isBlocking", {
    get: function() {
      return true;
    },
    enumerable: false,
    configurable: true
  });
  BaseTexture2.prototype.getScene = function() {
    return this._scene;
  };
  BaseTexture2.prototype._getEngine = function() {
    return this._engine;
  };
  BaseTexture2.prototype.checkTransformsAreIdentical = function(texture) {
    return texture !== null;
  };
  BaseTexture2.prototype.getTextureMatrix = function() {
    return Matrix.IdentityReadOnly;
  };
  BaseTexture2.prototype.getReflectionTextureMatrix = function() {
    return Matrix.IdentityReadOnly;
  };
  BaseTexture2.prototype.isReadyOrNotBlocking = function() {
    return !this.isBlocking || this.isReady();
  };
  BaseTexture2.prototype.scale = function(ratio) {
  };
  Object.defineProperty(BaseTexture2.prototype, "canRescale", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  BaseTexture2.prototype._getFromCache = function(url, noMipmap, sampling, invertY) {
    var engine = this._getEngine();
    if (!engine) {
      return null;
    }
    var texturesCache = engine.getLoadedTexturesCache();
    for (var index = 0; index < texturesCache.length; index++) {
      var texturesCacheEntry = texturesCache[index];
      if (invertY === void 0 || invertY === texturesCacheEntry.invertY) {
        if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {
          if (!sampling || sampling === texturesCacheEntry.samplingMode) {
            texturesCacheEntry.incrementReferences();
            return texturesCacheEntry;
          }
        }
      }
    }
    return null;
  };
  BaseTexture2.prototype._rebuild = function() {
  };
  BaseTexture2.prototype.clone = function() {
    return null;
  };
  Object.defineProperty(BaseTexture2.prototype, "textureType", {
    get: function() {
      if (!this._texture) {
        return 0;
      }
      return this._texture.type !== void 0 ? this._texture.type : 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "textureFormat", {
    get: function() {
      if (!this._texture) {
        return 5;
      }
      return this._texture.format !== void 0 ? this._texture.format : 5;
    },
    enumerable: false,
    configurable: true
  });
  BaseTexture2.prototype._markAllSubMeshesAsTexturesDirty = function() {
    var scene = this.getScene();
    if (!scene) {
      return;
    }
    scene.markAllMaterialsAsDirty(1);
  };
  BaseTexture2.prototype.readPixels = function(faceIndex, level, buffer) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (level === void 0) {
      level = 0;
    }
    if (buffer === void 0) {
      buffer = null;
    }
    if (!this._texture) {
      return null;
    }
    var size = this.getSize();
    var width = size.width;
    var height = size.height;
    var engine = this._getEngine();
    if (!engine) {
      return null;
    }
    if (level != 0) {
      width = width / Math.pow(2, level);
      height = height / Math.pow(2, level);
      width = Math.round(width);
      height = Math.round(height);
    }
    try {
      if (this._texture.isCube) {
        return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer);
      }
      return engine._readTexturePixels(this._texture, width, height, -1, level, buffer);
    } catch (e) {
      return null;
    }
  };
  Object.defineProperty(BaseTexture2.prototype, "_lodTextureHigh", {
    get: function() {
      if (this._texture) {
        return this._texture._lodTextureHigh;
      }
      return null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "_lodTextureMid", {
    get: function() {
      if (this._texture) {
        return this._texture._lodTextureMid;
      }
      return null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "_lodTextureLow", {
    get: function() {
      if (this._texture) {
        return this._texture._lodTextureLow;
      }
      return null;
    },
    enumerable: false,
    configurable: true
  });
  BaseTexture2.prototype.dispose = function() {
    if (this._scene) {
      if (this._scene.stopAnimation) {
        this._scene.stopAnimation(this);
      }
      this._scene._removePendingData(this);
      var index = this._scene.textures.indexOf(this);
      if (index >= 0) {
        this._scene.textures.splice(index, 1);
      }
      this._scene.onTextureRemovedObservable.notifyObservers(this);
      this._scene = null;
    }
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    _super.prototype.dispose.call(this);
  };
  BaseTexture2.prototype.serialize = function() {
    if (!this.name) {
      return null;
    }
    var serializationObject = SerializationHelper.Serialize(this);
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    return serializationObject;
  };
  BaseTexture2.WhenAllReady = function(textures, callback) {
    var numRemaining = textures.length;
    if (numRemaining === 0) {
      callback();
      return;
    }
    for (var i = 0; i < textures.length; i++) {
      var texture = textures[i];
      if (texture.isReady()) {
        if (--numRemaining === 0) {
          callback();
        }
      } else {
        var onLoadObservable = texture.onLoadObservable;
        if (onLoadObservable) {
          onLoadObservable.addOnce(function() {
            if (--numRemaining === 0) {
              callback();
            }
          });
        }
      }
    }
  };
  BaseTexture2._isScene = function(sceneOrEngine) {
    return sceneOrEngine.getClassName() === "Scene";
  };
  BaseTexture2.DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "uniqueId", void 0);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "name", void 0);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "metadata", void 0);
  __decorate([
    serialize("hasAlpha")
  ], BaseTexture2.prototype, "_hasAlpha", void 0);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "getAlphaFromRGB", void 0);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "level", void 0);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "coordinatesIndex", void 0);
  __decorate([
    serialize("coordinatesMode")
  ], BaseTexture2.prototype, "_coordinatesMode", void 0);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "wrapU", null);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "wrapV", null);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "wrapR", void 0);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "anisotropicFilteringLevel", void 0);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "isCube", null);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "is3D", null);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "is2DArray", null);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "gammaSpace", null);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "invertZ", void 0);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "lodLevelInAlpha", void 0);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "lodGenerationOffset", null);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "lodGenerationScale", null);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "linearSpecularLOD", null);
  __decorate([
    serializeAsTexture()
  ], BaseTexture2.prototype, "irradianceTexture", null);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "isRenderTarget", void 0);
  return BaseTexture2;
}(ThinTexture);

// node_modules/@babylonjs/core/Misc/copyTools.js
var CopyTools = function() {
  function CopyTools2() {
  }
  CopyTools2.GenerateBase64StringFromTexture = function(texture, faceIndex, level) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (level === void 0) {
      level = 0;
    }
    var internalTexture = texture.getInternalTexture();
    if (!internalTexture) {
      return null;
    }
    var pixels = texture.readPixels(faceIndex, level);
    if (!pixels) {
      return null;
    }
    var size = texture.getSize();
    var width = size.width;
    var height = size.height;
    if (pixels instanceof Float32Array) {
      var len = pixels.byteLength / pixels.BYTES_PER_ELEMENT;
      var npixels = new Uint8Array(len);
      while (--len >= 0) {
        var val = pixels[len];
        if (val < 0) {
          val = 0;
        } else if (val > 1) {
          val = 1;
        }
        npixels[len] = val * 255;
      }
      pixels = npixels;
    }
    var canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    var ctx = canvas.getContext("2d");
    if (!ctx) {
      return null;
    }
    var imageData = ctx.createImageData(width, height);
    var castData = imageData.data;
    castData.set(pixels);
    ctx.putImageData(imageData, 0, 0);
    if (internalTexture.invertY) {
      var canvas2 = document.createElement("canvas");
      canvas2.width = width;
      canvas2.height = height;
      var ctx2 = canvas2.getContext("2d");
      if (!ctx2) {
        return null;
      }
      ctx2.translate(0, height);
      ctx2.scale(1, -1);
      ctx2.drawImage(canvas, 0, 0);
      return canvas2.toDataURL("image/png");
    }
    return canvas.toDataURL("image/png");
  };
  return CopyTools2;
}();

// node_modules/@babylonjs/core/Materials/Textures/texture.js
var Texture = function(_super) {
  __extends(Texture2, _super);
  function Texture2(url, sceneOrEngine, noMipmap, invertY, samplingMode, onLoad, onError, buffer, deleteBuffer, format, mimeType, loaderOptions) {
    if (noMipmap === void 0) {
      noMipmap = false;
    }
    if (invertY === void 0) {
      invertY = true;
    }
    if (samplingMode === void 0) {
      samplingMode = Texture2.TRILINEAR_SAMPLINGMODE;
    }
    if (onLoad === void 0) {
      onLoad = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (buffer === void 0) {
      buffer = null;
    }
    if (deleteBuffer === void 0) {
      deleteBuffer = false;
    }
    var _this = _super.call(this, sceneOrEngine) || this;
    _this.url = null;
    _this.uOffset = 0;
    _this.vOffset = 0;
    _this.uScale = 1;
    _this.vScale = 1;
    _this.uAng = 0;
    _this.vAng = 0;
    _this.wAng = 0;
    _this.uRotationCenter = 0.5;
    _this.vRotationCenter = 0.5;
    _this.wRotationCenter = 0.5;
    _this.homogeneousRotationInUVTransform = false;
    _this.inspectableCustomProperties = null;
    _this._noMipmap = false;
    _this._invertY = false;
    _this._rowGenerationMatrix = null;
    _this._cachedTextureMatrix = null;
    _this._projectionModeMatrix = null;
    _this._t0 = null;
    _this._t1 = null;
    _this._t2 = null;
    _this._cachedUOffset = -1;
    _this._cachedVOffset = -1;
    _this._cachedUScale = 0;
    _this._cachedVScale = 0;
    _this._cachedUAng = -1;
    _this._cachedVAng = -1;
    _this._cachedWAng = -1;
    _this._cachedProjectionMatrixId = -1;
    _this._cachedURotationCenter = -1;
    _this._cachedVRotationCenter = -1;
    _this._cachedWRotationCenter = -1;
    _this._cachedHomogeneousRotationInUVTransform = false;
    _this._cachedCoordinatesMode = -1;
    _this._initialSamplingMode = Texture2.BILINEAR_SAMPLINGMODE;
    _this._buffer = null;
    _this._deleteBuffer = false;
    _this._format = null;
    _this._delayedOnLoad = null;
    _this._delayedOnError = null;
    _this.onLoadObservable = new Observable();
    _this._isBlocking = true;
    _this.name = url || "";
    _this.url = url;
    _this._noMipmap = noMipmap;
    _this._invertY = invertY;
    _this._initialSamplingMode = samplingMode;
    _this._buffer = buffer;
    _this._deleteBuffer = deleteBuffer;
    _this._mimeType = mimeType;
    _this._loaderOptions = loaderOptions;
    if (format) {
      _this._format = format;
    }
    var scene = _this.getScene();
    var engine = _this._getEngine();
    if (!engine) {
      return _this;
    }
    engine.onBeforeTextureInitObservable.notifyObservers(_this);
    var load = function() {
      if (_this._texture) {
        if (_this._texture._invertVScale) {
          _this.vScale *= -1;
          _this.vOffset += 1;
        }
        if (_this._texture._cachedWrapU !== null) {
          _this.wrapU = _this._texture._cachedWrapU;
          _this._texture._cachedWrapU = null;
        }
        if (_this._texture._cachedWrapV !== null) {
          _this.wrapV = _this._texture._cachedWrapV;
          _this._texture._cachedWrapV = null;
        }
        if (_this._texture._cachedWrapR !== null) {
          _this.wrapR = _this._texture._cachedWrapR;
          _this._texture._cachedWrapR = null;
        }
      }
      if (_this.onLoadObservable.hasObservers()) {
        _this.onLoadObservable.notifyObservers(_this);
      }
      if (onLoad) {
        onLoad();
      }
      if (!_this.isBlocking && scene) {
        scene.resetCachedMaterial();
      }
    };
    if (!_this.url) {
      _this._delayedOnLoad = load;
      _this._delayedOnError = onError;
      return _this;
    }
    _this._texture = _this._getFromCache(_this.url, noMipmap, samplingMode, invertY);
    if (!_this._texture) {
      if (!scene || !scene.useDelayedTextureLoading) {
        _this._texture = engine.createTexture(_this.url, noMipmap, invertY, scene, samplingMode, load, onError, _this._buffer, void 0, _this._format, null, mimeType, loaderOptions);
        if (deleteBuffer) {
          _this._buffer = null;
        }
      } else {
        _this.delayLoadState = 4;
        _this._delayedOnLoad = load;
        _this._delayedOnError = onError;
      }
    } else {
      if (_this._texture.isReady) {
        TimingTools.SetImmediate(function() {
          return load();
        });
      } else {
        _this._texture.onLoadedObservable.add(load);
      }
    }
    return _this;
  }
  Object.defineProperty(Texture2.prototype, "noMipmap", {
    get: function() {
      return this._noMipmap;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Texture2.prototype, "mimeType", {
    get: function() {
      return this._mimeType;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Texture2.prototype, "isBlocking", {
    get: function() {
      return this._isBlocking;
    },
    set: function(value) {
      this._isBlocking = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Texture2.prototype, "samplingMode", {
    get: function() {
      if (!this._texture) {
        return this._initialSamplingMode;
      }
      return this._texture.samplingMode;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Texture2.prototype, "invertY", {
    get: function() {
      return this._invertY;
    },
    enumerable: false,
    configurable: true
  });
  Texture2.prototype.updateURL = function(url, buffer, onLoad) {
    if (buffer === void 0) {
      buffer = null;
    }
    if (this.url) {
      this.releaseInternalTexture();
      this.getScene().markAllMaterialsAsDirty(1);
    }
    if (!this.name || StringTools.StartsWith(this.name, "data:")) {
      this.name = url;
    }
    this.url = url;
    this._buffer = buffer;
    this.delayLoadState = 4;
    if (onLoad) {
      this._delayedOnLoad = onLoad;
    }
    this.delayLoad();
  };
  Texture2.prototype.delayLoad = function() {
    if (this.delayLoadState !== 4) {
      return;
    }
    var scene = this.getScene();
    if (!scene) {
      return;
    }
    this.delayLoadState = 1;
    this._texture = this._getFromCache(this.url, this._noMipmap, this.samplingMode, this._invertY);
    if (!this._texture) {
      this._texture = scene.getEngine().createTexture(this.url, this._noMipmap, this._invertY, scene, this.samplingMode, this._delayedOnLoad, this._delayedOnError, this._buffer, null, this._format, null, this._mimeType, this._loaderOptions);
      if (this._deleteBuffer) {
        this._buffer = null;
      }
    } else {
      if (this._delayedOnLoad) {
        if (this._texture.isReady) {
          TimingTools.SetImmediate(this._delayedOnLoad);
        } else {
          this._texture.onLoadedObservable.add(this._delayedOnLoad);
        }
      }
    }
    this._delayedOnLoad = null;
    this._delayedOnError = null;
  };
  Texture2.prototype._prepareRowForTextureGeneration = function(x, y, z, t) {
    x *= this._cachedUScale;
    y *= this._cachedVScale;
    x -= this.uRotationCenter * this._cachedUScale;
    y -= this.vRotationCenter * this._cachedVScale;
    z -= this.wRotationCenter;
    Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, this._rowGenerationMatrix, t);
    t.x += this.uRotationCenter * this._cachedUScale + this._cachedUOffset;
    t.y += this.vRotationCenter * this._cachedVScale + this._cachedVOffset;
    t.z += this.wRotationCenter;
  };
  Texture2.prototype.checkTransformsAreIdentical = function(texture) {
    return texture !== null && this.uOffset === texture.uOffset && this.vOffset === texture.vOffset && this.uScale === texture.uScale && this.vScale === texture.vScale && this.uAng === texture.uAng && this.vAng === texture.vAng && this.wAng === texture.wAng;
  };
  Texture2.prototype.getTextureMatrix = function(uBase) {
    var _this = this;
    if (uBase === void 0) {
      uBase = 1;
    }
    if (this.uOffset === this._cachedUOffset && this.vOffset === this._cachedVOffset && this.uScale * uBase === this._cachedUScale && this.vScale === this._cachedVScale && this.uAng === this._cachedUAng && this.vAng === this._cachedVAng && this.wAng === this._cachedWAng && this.uRotationCenter === this._cachedURotationCenter && this.vRotationCenter === this._cachedVRotationCenter && this.wRotationCenter === this._cachedWRotationCenter && this.homogeneousRotationInUVTransform === this._cachedHomogeneousRotationInUVTransform) {
      return this._cachedTextureMatrix;
    }
    this._cachedUOffset = this.uOffset;
    this._cachedVOffset = this.vOffset;
    this._cachedUScale = this.uScale * uBase;
    this._cachedVScale = this.vScale;
    this._cachedUAng = this.uAng;
    this._cachedVAng = this.vAng;
    this._cachedWAng = this.wAng;
    this._cachedURotationCenter = this.uRotationCenter;
    this._cachedVRotationCenter = this.vRotationCenter;
    this._cachedWRotationCenter = this.wRotationCenter;
    this._cachedHomogeneousRotationInUVTransform = this.homogeneousRotationInUVTransform;
    if (!this._cachedTextureMatrix || !this._rowGenerationMatrix) {
      this._cachedTextureMatrix = Matrix.Zero();
      this._rowGenerationMatrix = new Matrix();
      this._t0 = Vector3.Zero();
      this._t1 = Vector3.Zero();
      this._t2 = Vector3.Zero();
    }
    Matrix.RotationYawPitchRollToRef(this.vAng, this.uAng, this.wAng, this._rowGenerationMatrix);
    if (this.homogeneousRotationInUVTransform) {
      Matrix.TranslationToRef(-this._cachedURotationCenter, -this._cachedVRotationCenter, -this._cachedWRotationCenter, TmpVectors.Matrix[0]);
      Matrix.TranslationToRef(this._cachedURotationCenter, this._cachedVRotationCenter, this._cachedWRotationCenter, TmpVectors.Matrix[1]);
      Matrix.ScalingToRef(this._cachedUScale, this._cachedVScale, 0, TmpVectors.Matrix[2]);
      Matrix.TranslationToRef(this._cachedUOffset, this._cachedVOffset, 0, TmpVectors.Matrix[3]);
      TmpVectors.Matrix[0].multiplyToRef(this._rowGenerationMatrix, this._cachedTextureMatrix);
      this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[1], this._cachedTextureMatrix);
      this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[2], this._cachedTextureMatrix);
      this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[3], this._cachedTextureMatrix);
      this._cachedTextureMatrix.setRowFromFloats(2, this._cachedTextureMatrix.m[12], this._cachedTextureMatrix.m[13], this._cachedTextureMatrix.m[14], 1);
    } else {
      this._prepareRowForTextureGeneration(0, 0, 0, this._t0);
      this._prepareRowForTextureGeneration(1, 0, 0, this._t1);
      this._prepareRowForTextureGeneration(0, 1, 0, this._t2);
      this._t1.subtractInPlace(this._t0);
      this._t2.subtractInPlace(this._t0);
      Matrix.FromValuesToRef(this._t1.x, this._t1.y, this._t1.z, 0, this._t2.x, this._t2.y, this._t2.z, 0, this._t0.x, this._t0.y, this._t0.z, 0, 0, 0, 0, 1, this._cachedTextureMatrix);
    }
    var scene = this.getScene();
    if (!scene) {
      return this._cachedTextureMatrix;
    }
    scene.markAllMaterialsAsDirty(1, function(mat) {
      return mat.hasTexture(_this);
    });
    return this._cachedTextureMatrix;
  };
  Texture2.prototype.getReflectionTextureMatrix = function() {
    var _this = this;
    var scene = this.getScene();
    if (!scene) {
      return this._cachedTextureMatrix;
    }
    if (this.uOffset === this._cachedUOffset && this.vOffset === this._cachedVOffset && this.uScale === this._cachedUScale && this.vScale === this._cachedVScale && this.coordinatesMode === this._cachedCoordinatesMode) {
      if (this.coordinatesMode === Texture2.PROJECTION_MODE) {
        if (this._cachedProjectionMatrixId === scene.getProjectionMatrix().updateFlag) {
          return this._cachedTextureMatrix;
        }
      } else {
        return this._cachedTextureMatrix;
      }
    }
    if (!this._cachedTextureMatrix) {
      this._cachedTextureMatrix = Matrix.Zero();
    }
    if (!this._projectionModeMatrix) {
      this._projectionModeMatrix = Matrix.Zero();
    }
    this._cachedUOffset = this.uOffset;
    this._cachedVOffset = this.vOffset;
    this._cachedUScale = this.uScale;
    this._cachedVScale = this.vScale;
    this._cachedCoordinatesMode = this.coordinatesMode;
    switch (this.coordinatesMode) {
      case Texture2.PLANAR_MODE:
        Matrix.IdentityToRef(this._cachedTextureMatrix);
        this._cachedTextureMatrix[0] = this.uScale;
        this._cachedTextureMatrix[5] = this.vScale;
        this._cachedTextureMatrix[12] = this.uOffset;
        this._cachedTextureMatrix[13] = this.vOffset;
        break;
      case Texture2.PROJECTION_MODE:
        Matrix.FromValuesToRef(0.5, 0, 0, 0, 0, -0.5, 0, 0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, this._projectionModeMatrix);
        var projectionMatrix = scene.getProjectionMatrix();
        this._cachedProjectionMatrixId = projectionMatrix.updateFlag;
        projectionMatrix.multiplyToRef(this._projectionModeMatrix, this._cachedTextureMatrix);
        break;
      default:
        Matrix.IdentityToRef(this._cachedTextureMatrix);
        break;
    }
    scene.markAllMaterialsAsDirty(1, function(mat) {
      return mat.getActiveTextures().indexOf(_this) !== -1;
    });
    return this._cachedTextureMatrix;
  };
  Texture2.prototype.clone = function() {
    var _this = this;
    return SerializationHelper.Clone(function() {
      return new Texture2(_this._texture ? _this._texture.url : null, _this.getScene(), _this._noMipmap, _this._invertY, _this.samplingMode, void 0, void 0, _this._texture ? _this._texture._buffer : void 0);
    }, this);
  };
  Texture2.prototype.serialize = function() {
    var savedName = this.name;
    if (!Texture2.SerializeBuffers) {
      if (StringTools.StartsWith(this.name, "data:")) {
        this.name = "";
      }
    }
    if (StringTools.StartsWith(this.name, "data:") && this.url === this.name) {
      this.url = "";
    }
    var serializationObject = _super.prototype.serialize.call(this);
    if (!serializationObject) {
      return null;
    }
    if (Texture2.SerializeBuffers || Texture2.ForceSerializeBuffers) {
      if (typeof this._buffer === "string" && this._buffer.substr(0, 5) === "data:") {
        serializationObject.base64String = this._buffer;
        serializationObject.name = serializationObject.name.replace("data:", "");
      } else if (this.url && StringTools.StartsWith(this.url, "data:") && this._buffer instanceof Uint8Array) {
        serializationObject.base64String = "data:image/png;base64," + StringTools.EncodeArrayBufferToBase64(this._buffer);
      } else if (Texture2.ForceSerializeBuffers) {
        serializationObject.base64String = CopyTools.GenerateBase64StringFromTexture(this);
      }
    }
    serializationObject.invertY = this._invertY;
    serializationObject.samplingMode = this.samplingMode;
    this.name = savedName;
    return serializationObject;
  };
  Texture2.prototype.getClassName = function() {
    return "Texture";
  };
  Texture2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this.onLoadObservable.clear();
    this._delayedOnLoad = null;
    this._delayedOnError = null;
  };
  Texture2.Parse = function(parsedTexture, scene, rootUrl) {
    if (parsedTexture.customType) {
      var customTexture = InstantiationTools.Instantiate(parsedTexture.customType);
      var parsedCustomTexture = customTexture.Parse(parsedTexture, scene, rootUrl);
      if (parsedTexture.samplingMode && parsedCustomTexture.updateSamplingMode && parsedCustomTexture._samplingMode) {
        if (parsedCustomTexture._samplingMode !== parsedTexture.samplingMode) {
          parsedCustomTexture.updateSamplingMode(parsedTexture.samplingMode);
        }
      }
      return parsedCustomTexture;
    }
    if (parsedTexture.isCube && !parsedTexture.isRenderTarget) {
      return Texture2._CubeTextureParser(parsedTexture, scene, rootUrl);
    }
    if (!parsedTexture.name && !parsedTexture.isRenderTarget) {
      return null;
    }
    var onLoaded = function() {
      if (texture && texture._texture) {
        texture._texture._cachedWrapU = null;
        texture._texture._cachedWrapV = null;
        texture._texture._cachedWrapR = null;
      }
      if (parsedTexture.samplingMode) {
        var sampling = parsedTexture.samplingMode;
        if (texture && texture.samplingMode !== sampling) {
          texture.updateSamplingMode(sampling);
        }
      }
      if (texture && parsedTexture.animations) {
        for (var animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {
          var parsedAnimation = parsedTexture.animations[animationIndex];
          var internalClass = _TypeStore.GetClass("BABYLON.Animation");
          if (internalClass) {
            texture.animations.push(internalClass.Parse(parsedAnimation));
          }
        }
      }
    };
    var texture = SerializationHelper.Parse(function() {
      var generateMipMaps = true;
      if (parsedTexture.noMipmap) {
        generateMipMaps = false;
      }
      if (parsedTexture.mirrorPlane) {
        var mirrorTexture = Texture2._CreateMirror(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps);
        mirrorTexture._waitingRenderList = parsedTexture.renderList;
        mirrorTexture.mirrorPlane = Plane.FromArray(parsedTexture.mirrorPlane);
        onLoaded();
        return mirrorTexture;
      } else if (parsedTexture.isRenderTarget) {
        var renderTargetTexture = null;
        if (parsedTexture.isCube) {
          if (scene.reflectionProbes) {
            for (var index = 0; index < scene.reflectionProbes.length; index++) {
              var probe = scene.reflectionProbes[index];
              if (probe.name === parsedTexture.name) {
                return probe.cubeTexture;
              }
            }
          }
        } else {
          renderTargetTexture = Texture2._CreateRenderTargetTexture(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps);
          renderTargetTexture._waitingRenderList = parsedTexture.renderList;
        }
        onLoaded();
        return renderTargetTexture;
      } else {
        var texture2;
        if (parsedTexture.base64String) {
          texture2 = Texture2.CreateFromBase64String(parsedTexture.base64String, parsedTexture.name, scene, !generateMipMaps, parsedTexture.invertY, void 0, onLoaded);
        } else {
          var url = void 0;
          if (parsedTexture.name && parsedTexture.name.indexOf("://") > 0) {
            url = parsedTexture.name;
          } else {
            url = rootUrl + parsedTexture.name;
          }
          if (StringTools.StartsWith(parsedTexture.url, "data:") || Texture2.UseSerializedUrlIfAny && parsedTexture.url) {
            url = parsedTexture.url;
          }
          texture2 = new Texture2(url, scene, !generateMipMaps, parsedTexture.invertY, void 0, onLoaded);
        }
        return texture2;
      }
    }, parsedTexture, scene);
    return texture;
  };
  Texture2.CreateFromBase64String = function(data, name45, scene, noMipmap, invertY, samplingMode, onLoad, onError, format) {
    if (samplingMode === void 0) {
      samplingMode = Texture2.TRILINEAR_SAMPLINGMODE;
    }
    if (onLoad === void 0) {
      onLoad = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (format === void 0) {
      format = 5;
    }
    return new Texture2("data:" + name45, scene, noMipmap, invertY, samplingMode, onLoad, onError, data, false, format);
  };
  Texture2.LoadFromDataString = function(name45, buffer, scene, deleteBuffer, noMipmap, invertY, samplingMode, onLoad, onError, format) {
    if (deleteBuffer === void 0) {
      deleteBuffer = false;
    }
    if (noMipmap === void 0) {
      noMipmap = false;
    }
    if (invertY === void 0) {
      invertY = true;
    }
    if (samplingMode === void 0) {
      samplingMode = Texture2.TRILINEAR_SAMPLINGMODE;
    }
    if (onLoad === void 0) {
      onLoad = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (format === void 0) {
      format = 5;
    }
    if (name45.substr(0, 5) !== "data:") {
      name45 = "data:" + name45;
    }
    return new Texture2(name45, scene, noMipmap, invertY, samplingMode, onLoad, onError, buffer, deleteBuffer, format);
  };
  Texture2.SerializeBuffers = true;
  Texture2.ForceSerializeBuffers = false;
  Texture2._CubeTextureParser = function(jsonTexture, scene, rootUrl) {
    throw _DevTools.WarnImport("CubeTexture");
  };
  Texture2._CreateMirror = function(name45, renderTargetSize, scene, generateMipMaps) {
    throw _DevTools.WarnImport("MirrorTexture");
  };
  Texture2._CreateRenderTargetTexture = function(name45, renderTargetSize, scene, generateMipMaps) {
    throw _DevTools.WarnImport("RenderTargetTexture");
  };
  Texture2.NEAREST_SAMPLINGMODE = 1;
  Texture2.NEAREST_NEAREST_MIPLINEAR = 8;
  Texture2.BILINEAR_SAMPLINGMODE = 2;
  Texture2.LINEAR_LINEAR_MIPNEAREST = 11;
  Texture2.TRILINEAR_SAMPLINGMODE = 3;
  Texture2.LINEAR_LINEAR_MIPLINEAR = 3;
  Texture2.NEAREST_NEAREST_MIPNEAREST = 4;
  Texture2.NEAREST_LINEAR_MIPNEAREST = 5;
  Texture2.NEAREST_LINEAR_MIPLINEAR = 6;
  Texture2.NEAREST_LINEAR = 7;
  Texture2.NEAREST_NEAREST = 1;
  Texture2.LINEAR_NEAREST_MIPNEAREST = 9;
  Texture2.LINEAR_NEAREST_MIPLINEAR = 10;
  Texture2.LINEAR_LINEAR = 2;
  Texture2.LINEAR_NEAREST = 12;
  Texture2.EXPLICIT_MODE = 0;
  Texture2.SPHERICAL_MODE = 1;
  Texture2.PLANAR_MODE = 2;
  Texture2.CUBIC_MODE = 3;
  Texture2.PROJECTION_MODE = 4;
  Texture2.SKYBOX_MODE = 5;
  Texture2.INVCUBIC_MODE = 6;
  Texture2.EQUIRECTANGULAR_MODE = 7;
  Texture2.FIXED_EQUIRECTANGULAR_MODE = 8;
  Texture2.FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;
  Texture2.CLAMP_ADDRESSMODE = 0;
  Texture2.WRAP_ADDRESSMODE = 1;
  Texture2.MIRROR_ADDRESSMODE = 2;
  Texture2.UseSerializedUrlIfAny = false;
  __decorate([
    serialize()
  ], Texture2.prototype, "url", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "uOffset", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "vOffset", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "uScale", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "vScale", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "uAng", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "vAng", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "wAng", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "uRotationCenter", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "vRotationCenter", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "wRotationCenter", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "homogeneousRotationInUVTransform", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "isBlocking", null);
  return Texture2;
}(BaseTexture);
_TypeStore.RegisteredTypes["BABYLON.Texture"] = Texture;
SerializationHelper._TextureParser = Texture.Parse;

// node_modules/@babylonjs/core/Lights/hemisphericLight.js
Node.AddNodeConstructor("Light_Type_3", function(name45, scene) {
  return function() {
    return new HemisphericLight(name45, Vector3.Zero(), scene);
  };
});
var HemisphericLight = function(_super) {
  __extends(HemisphericLight2, _super);
  function HemisphericLight2(name45, direction, scene) {
    var _this = _super.call(this, name45, scene) || this;
    _this.groundColor = new Color3(0, 0, 0);
    _this.direction = direction || Vector3.Up();
    return _this;
  }
  HemisphericLight2.prototype._buildUniformLayout = function() {
    this._uniformBuffer.addUniform("vLightData", 4);
    this._uniformBuffer.addUniform("vLightDiffuse", 4);
    this._uniformBuffer.addUniform("vLightSpecular", 4);
    this._uniformBuffer.addUniform("vLightGround", 3);
    this._uniformBuffer.addUniform("shadowsInfo", 3);
    this._uniformBuffer.addUniform("depthValues", 2);
    this._uniformBuffer.create();
  };
  HemisphericLight2.prototype.getClassName = function() {
    return "HemisphericLight";
  };
  HemisphericLight2.prototype.setDirectionToTarget = function(target) {
    this.direction = Vector3.Normalize(target.subtract(Vector3.Zero()));
    return this.direction;
  };
  HemisphericLight2.prototype.getShadowGenerator = function() {
    return null;
  };
  HemisphericLight2.prototype.transferToEffect = function(effect, lightIndex) {
    var normalizeDirection = Vector3.Normalize(this.direction);
    this._uniformBuffer.updateFloat4("vLightData", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, 0, lightIndex);
    this._uniformBuffer.updateColor3("vLightGround", this.groundColor.scale(this.intensity), lightIndex);
    return this;
  };
  HemisphericLight2.prototype.transferToNodeMaterialEffect = function(effect, lightDataUniformName) {
    var normalizeDirection = Vector3.Normalize(this.direction);
    effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);
    return this;
  };
  HemisphericLight2.prototype.computeWorldMatrix = function() {
    if (!this._worldMatrix) {
      this._worldMatrix = Matrix.Identity();
    }
    return this._worldMatrix;
  };
  HemisphericLight2.prototype.getTypeID = function() {
    return Light.LIGHTTYPEID_HEMISPHERICLIGHT;
  };
  HemisphericLight2.prototype.prepareLightSpecificDefines = function(defines, lightIndex) {
    defines["HEMILIGHT" + lightIndex] = true;
  };
  __decorate([
    serializeAsColor3()
  ], HemisphericLight2.prototype, "groundColor", void 0);
  __decorate([
    serializeAsVector3()
  ], HemisphericLight2.prototype, "direction", void 0);
  return HemisphericLight2;
}(Light);

// node_modules/@babylonjs/core/Materials/pushMaterial.js
var PushMaterial = function(_super) {
  __extends(PushMaterial2, _super);
  function PushMaterial2(name45, scene) {
    var _this = _super.call(this, name45, scene) || this;
    _this._normalMatrix = new Matrix();
    _this._storeEffectOnSubMeshes = true;
    return _this;
  }
  PushMaterial2.prototype.getEffect = function() {
    return this._activeEffect;
  };
  PushMaterial2.prototype.isReady = function(mesh, useInstances) {
    if (!mesh) {
      return false;
    }
    if (!mesh.subMeshes || mesh.subMeshes.length === 0) {
      return true;
    }
    return this.isReadyForSubMesh(mesh, mesh.subMeshes[0], useInstances);
  };
  PushMaterial2.prototype._isReadyForSubMesh = function(subMesh) {
    var defines = subMesh._materialDefines;
    if (!this.checkReadyOnEveryCall && subMesh.effect && defines) {
      if (defines._renderId === this.getScene().getRenderId()) {
        return true;
      }
    }
    return false;
  };
  PushMaterial2.prototype.bindOnlyWorldMatrix = function(world) {
    this._activeEffect.setMatrix("world", world);
  };
  PushMaterial2.prototype.bindOnlyNormalMatrix = function(normalMatrix) {
    this._activeEffect.setMatrix("normalMatrix", normalMatrix);
  };
  PushMaterial2.prototype.bind = function(world, mesh) {
    if (!mesh) {
      return;
    }
    this.bindForSubMesh(world, mesh, mesh.subMeshes[0]);
  };
  PushMaterial2.prototype._afterBind = function(mesh, effect) {
    if (effect === void 0) {
      effect = null;
    }
    _super.prototype._afterBind.call(this, mesh);
    this.getScene()._cachedEffect = effect;
  };
  PushMaterial2.prototype._mustRebind = function(scene, effect, visibility) {
    if (visibility === void 0) {
      visibility = 1;
    }
    return scene.isCachedMaterialInvalid(this, effect, visibility);
  };
  return PushMaterial2;
}(Material);

// node_modules/@babylonjs/core/Materials/thinMaterialHelper.js
var ThinMaterialHelper = function() {
  function ThinMaterialHelper2() {
  }
  ThinMaterialHelper2.BindClipPlane = function(effect, holder) {
    if (holder.clipPlane) {
      var clipPlane = holder.clipPlane;
      effect.setFloat4("vClipPlane", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);
    }
    if (holder.clipPlane2) {
      var clipPlane = holder.clipPlane2;
      effect.setFloat4("vClipPlane2", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);
    }
    if (holder.clipPlane3) {
      var clipPlane = holder.clipPlane3;
      effect.setFloat4("vClipPlane3", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);
    }
    if (holder.clipPlane4) {
      var clipPlane = holder.clipPlane4;
      effect.setFloat4("vClipPlane4", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);
    }
    if (holder.clipPlane5) {
      var clipPlane = holder.clipPlane5;
      effect.setFloat4("vClipPlane5", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);
    }
    if (holder.clipPlane6) {
      var clipPlane = holder.clipPlane6;
      effect.setFloat4("vClipPlane6", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);
    }
  };
  return ThinMaterialHelper2;
}();

// node_modules/@babylonjs/core/Materials/materialHelper.js
var MaterialHelper = function() {
  function MaterialHelper2() {
  }
  MaterialHelper2.BindEyePosition = function(effect, scene, variableName) {
    if (variableName === void 0) {
      variableName = "vEyePosition";
    }
    if (scene._forcedViewPosition) {
      effect.setVector3(variableName, scene._forcedViewPosition);
      return;
    }
    var globalPosition = scene.activeCamera.globalPosition;
    if (!globalPosition) {
      globalPosition = scene.activeCamera.devicePosition;
    }
    effect.setVector3(variableName, scene._mirroredCameraPosition ? scene._mirroredCameraPosition : globalPosition);
  };
  MaterialHelper2.PrepareDefinesForMergedUV = function(texture, defines, key) {
    defines._needUVs = true;
    defines[key] = true;
    if (texture.getTextureMatrix().isIdentityAs3x2()) {
      defines[key + "DIRECTUV"] = texture.coordinatesIndex + 1;
      if (texture.coordinatesIndex === 0) {
        defines["MAINUV1"] = true;
      } else {
        defines["MAINUV2"] = true;
      }
    } else {
      defines[key + "DIRECTUV"] = 0;
    }
  };
  MaterialHelper2.BindTextureMatrix = function(texture, uniformBuffer, key) {
    var matrix = texture.getTextureMatrix();
    uniformBuffer.updateMatrix(key + "Matrix", matrix);
  };
  MaterialHelper2.GetFogState = function(mesh, scene) {
    return scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE;
  };
  MaterialHelper2.PrepareDefinesForMisc = function(mesh, scene, useLogarithmicDepth, pointsCloud, fogEnabled, alphaTest, defines) {
    if (defines._areMiscDirty) {
      defines["LOGARITHMICDEPTH"] = useLogarithmicDepth;
      defines["POINTSIZE"] = pointsCloud;
      defines["FOG"] = fogEnabled && this.GetFogState(mesh, scene);
      defines["NONUNIFORMSCALING"] = mesh.nonUniformScaling;
      defines["ALPHATEST"] = alphaTest;
    }
  };
  MaterialHelper2.PrepareDefinesForFrameBoundValues = function(scene, engine, defines, useInstances, useClipPlane, useThinInstances) {
    if (useClipPlane === void 0) {
      useClipPlane = null;
    }
    if (useThinInstances === void 0) {
      useThinInstances = false;
    }
    var changed = false;
    var useClipPlane1 = false;
    var useClipPlane2 = false;
    var useClipPlane3 = false;
    var useClipPlane4 = false;
    var useClipPlane5 = false;
    var useClipPlane6 = false;
    useClipPlane1 = useClipPlane == null ? scene.clipPlane !== void 0 && scene.clipPlane !== null : useClipPlane;
    useClipPlane2 = useClipPlane == null ? scene.clipPlane2 !== void 0 && scene.clipPlane2 !== null : useClipPlane;
    useClipPlane3 = useClipPlane == null ? scene.clipPlane3 !== void 0 && scene.clipPlane3 !== null : useClipPlane;
    useClipPlane4 = useClipPlane == null ? scene.clipPlane4 !== void 0 && scene.clipPlane4 !== null : useClipPlane;
    useClipPlane5 = useClipPlane == null ? scene.clipPlane5 !== void 0 && scene.clipPlane5 !== null : useClipPlane;
    useClipPlane6 = useClipPlane == null ? scene.clipPlane6 !== void 0 && scene.clipPlane6 !== null : useClipPlane;
    if (defines["CLIPPLANE"] !== useClipPlane1) {
      defines["CLIPPLANE"] = useClipPlane1;
      changed = true;
    }
    if (defines["CLIPPLANE2"] !== useClipPlane2) {
      defines["CLIPPLANE2"] = useClipPlane2;
      changed = true;
    }
    if (defines["CLIPPLANE3"] !== useClipPlane3) {
      defines["CLIPPLANE3"] = useClipPlane3;
      changed = true;
    }
    if (defines["CLIPPLANE4"] !== useClipPlane4) {
      defines["CLIPPLANE4"] = useClipPlane4;
      changed = true;
    }
    if (defines["CLIPPLANE5"] !== useClipPlane5) {
      defines["CLIPPLANE5"] = useClipPlane5;
      changed = true;
    }
    if (defines["CLIPPLANE6"] !== useClipPlane6) {
      defines["CLIPPLANE6"] = useClipPlane6;
      changed = true;
    }
    if (defines["DEPTHPREPASS"] !== !engine.getColorWrite()) {
      defines["DEPTHPREPASS"] = !defines["DEPTHPREPASS"];
      changed = true;
    }
    if (defines["INSTANCES"] !== useInstances) {
      defines["INSTANCES"] = useInstances;
      changed = true;
    }
    if (defines["THIN_INSTANCES"] !== useThinInstances) {
      defines["THIN_INSTANCES"] = useThinInstances;
      changed = true;
    }
    if (changed) {
      defines.markAsUnprocessed();
    }
  };
  MaterialHelper2.PrepareDefinesForBones = function(mesh, defines) {
    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
      defines["NUM_BONE_INFLUENCERS"] = mesh.numBoneInfluencers;
      var materialSupportsBoneTexture = defines["BONETEXTURE"] !== void 0;
      if (mesh.skeleton.isUsingTextureForMatrices && materialSupportsBoneTexture) {
        defines["BONETEXTURE"] = true;
      } else {
        defines["BonesPerMesh"] = mesh.skeleton.bones.length + 1;
        defines["BONETEXTURE"] = materialSupportsBoneTexture ? false : void 0;
        var prePassRenderer = mesh.getScene().prePassRenderer;
        if (prePassRenderer && prePassRenderer.enabled) {
          var nonExcluded = prePassRenderer.excludedSkinnedMesh.indexOf(mesh) === -1;
          defines["BONES_VELOCITY_ENABLED"] = nonExcluded;
        }
      }
    } else {
      defines["NUM_BONE_INFLUENCERS"] = 0;
      defines["BonesPerMesh"] = 0;
    }
  };
  MaterialHelper2.PrepareDefinesForMorphTargets = function(mesh, defines) {
    var manager = mesh.morphTargetManager;
    if (manager) {
      defines["MORPHTARGETS_UV"] = manager.supportsUVs && defines["UV1"];
      defines["MORPHTARGETS_TANGENT"] = manager.supportsTangents && defines["TANGENT"];
      defines["MORPHTARGETS_NORMAL"] = manager.supportsNormals && defines["NORMAL"];
      defines["MORPHTARGETS"] = manager.numInfluencers > 0;
      defines["NUM_MORPH_INFLUENCERS"] = manager.numInfluencers;
    } else {
      defines["MORPHTARGETS_UV"] = false;
      defines["MORPHTARGETS_TANGENT"] = false;
      defines["MORPHTARGETS_NORMAL"] = false;
      defines["MORPHTARGETS"] = false;
      defines["NUM_MORPH_INFLUENCERS"] = 0;
    }
  };
  MaterialHelper2.PrepareDefinesForAttributes = function(mesh, defines, useVertexColor, useBones, useMorphTargets, useVertexAlpha) {
    if (useMorphTargets === void 0) {
      useMorphTargets = false;
    }
    if (useVertexAlpha === void 0) {
      useVertexAlpha = true;
    }
    if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {
      return false;
    }
    defines._normals = defines._needNormals;
    defines._uvs = defines._needUVs;
    defines["NORMAL"] = defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.NormalKind);
    if (defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {
      defines["TANGENT"] = true;
    }
    if (defines._needUVs) {
      defines["UV1"] = mesh.isVerticesDataPresent(VertexBuffer.UVKind);
      defines["UV2"] = mesh.isVerticesDataPresent(VertexBuffer.UV2Kind);
    } else {
      defines["UV1"] = false;
      defines["UV2"] = false;
    }
    if (useVertexColor) {
      var hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind);
      defines["VERTEXCOLOR"] = hasVertexColors;
      defines["VERTEXALPHA"] = mesh.hasVertexAlpha && hasVertexColors && useVertexAlpha;
    }
    if (useBones) {
      this.PrepareDefinesForBones(mesh, defines);
    }
    if (useMorphTargets) {
      this.PrepareDefinesForMorphTargets(mesh, defines);
    }
    return true;
  };
  MaterialHelper2.PrepareDefinesForMultiview = function(scene, defines) {
    if (scene.activeCamera) {
      var previousMultiview = defines.MULTIVIEW;
      defines.MULTIVIEW = scene.activeCamera.outputRenderTarget !== null && scene.activeCamera.outputRenderTarget.getViewCount() > 1;
      if (defines.MULTIVIEW != previousMultiview) {
        defines.markAsUnprocessed();
      }
    }
  };
  MaterialHelper2.PrepareDefinesForPrePass = function(scene, defines, canRenderToMRT) {
    var previousPrePass = defines.PREPASS;
    if (!defines._arePrePassDirty) {
      return;
    }
    var texturesList = [
      {
        type: 1,
        define: "PREPASS_POSITION",
        index: "PREPASS_POSITION_INDEX"
      },
      {
        type: 2,
        define: "PREPASS_VELOCITY",
        index: "PREPASS_VELOCITY_INDEX"
      },
      {
        type: 3,
        define: "PREPASS_REFLECTIVITY",
        index: "PREPASS_REFLECTIVITY_INDEX"
      },
      {
        type: 0,
        define: "PREPASS_IRRADIANCE",
        index: "PREPASS_IRRADIANCE_INDEX"
      },
      {
        type: 6,
        define: "PREPASS_ALBEDO",
        index: "PREPASS_ALBEDO_INDEX"
      },
      {
        type: 5,
        define: "PREPASS_DEPTHNORMAL",
        index: "PREPASS_DEPTHNORMAL_INDEX"
      }
    ];
    if (scene.prePassRenderer && scene.prePassRenderer.enabled && canRenderToMRT) {
      defines.PREPASS = true;
      defines.SCENE_MRT_COUNT = scene.prePassRenderer.mrtCount;
      for (var i = 0; i < texturesList.length; i++) {
        var index = scene.prePassRenderer.getIndex(texturesList[i].type);
        if (index !== -1) {
          defines[texturesList[i].define] = true;
          defines[texturesList[i].index] = index;
        } else {
          defines[texturesList[i].define] = false;
        }
      }
    } else {
      defines.PREPASS = false;
      for (var i = 0; i < texturesList.length; i++) {
        defines[texturesList[i].define] = false;
      }
    }
    if (defines.PREPASS != previousPrePass) {
      defines.markAsUnprocessed();
      defines.markAsImageProcessingDirty();
    }
  };
  MaterialHelper2.PrepareDefinesForLight = function(scene, mesh, light, lightIndex, defines, specularSupported, state) {
    state.needNormals = true;
    if (defines["LIGHT" + lightIndex] === void 0) {
      state.needRebuild = true;
    }
    defines["LIGHT" + lightIndex] = true;
    defines["SPOTLIGHT" + lightIndex] = false;
    defines["HEMILIGHT" + lightIndex] = false;
    defines["POINTLIGHT" + lightIndex] = false;
    defines["DIRLIGHT" + lightIndex] = false;
    light.prepareLightSpecificDefines(defines, lightIndex);
    defines["LIGHT_FALLOFF_PHYSICAL" + lightIndex] = false;
    defines["LIGHT_FALLOFF_GLTF" + lightIndex] = false;
    defines["LIGHT_FALLOFF_STANDARD" + lightIndex] = false;
    switch (light.falloffType) {
      case Light.FALLOFF_GLTF:
        defines["LIGHT_FALLOFF_GLTF" + lightIndex] = true;
        break;
      case Light.FALLOFF_PHYSICAL:
        defines["LIGHT_FALLOFF_PHYSICAL" + lightIndex] = true;
        break;
      case Light.FALLOFF_STANDARD:
        defines["LIGHT_FALLOFF_STANDARD" + lightIndex] = true;
        break;
    }
    if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {
      state.specularEnabled = true;
    }
    defines["SHADOW" + lightIndex] = false;
    defines["SHADOWCSM" + lightIndex] = false;
    defines["SHADOWCSMDEBUG" + lightIndex] = false;
    defines["SHADOWCSMNUM_CASCADES" + lightIndex] = false;
    defines["SHADOWCSMUSESHADOWMAXZ" + lightIndex] = false;
    defines["SHADOWCSMNOBLEND" + lightIndex] = false;
    defines["SHADOWCSM_RIGHTHANDED" + lightIndex] = false;
    defines["SHADOWPCF" + lightIndex] = false;
    defines["SHADOWPCSS" + lightIndex] = false;
    defines["SHADOWPOISSON" + lightIndex] = false;
    defines["SHADOWESM" + lightIndex] = false;
    defines["SHADOWCLOSEESM" + lightIndex] = false;
    defines["SHADOWCUBE" + lightIndex] = false;
    defines["SHADOWLOWQUALITY" + lightIndex] = false;
    defines["SHADOWMEDIUMQUALITY" + lightIndex] = false;
    if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {
      var shadowGenerator = light.getShadowGenerator();
      if (shadowGenerator) {
        var shadowMap = shadowGenerator.getShadowMap();
        if (shadowMap) {
          if (shadowMap.renderList && shadowMap.renderList.length > 0) {
            state.shadowEnabled = true;
            shadowGenerator.prepareDefines(defines, lightIndex);
          }
        }
      }
    }
    if (light.lightmapMode != Light.LIGHTMAP_DEFAULT) {
      state.lightmapMode = true;
      defines["LIGHTMAPEXCLUDED" + lightIndex] = true;
      defines["LIGHTMAPNOSPECULAR" + lightIndex] = light.lightmapMode == Light.LIGHTMAP_SHADOWSONLY;
    } else {
      defines["LIGHTMAPEXCLUDED" + lightIndex] = false;
      defines["LIGHTMAPNOSPECULAR" + lightIndex] = false;
    }
  };
  MaterialHelper2.PrepareDefinesForLights = function(scene, mesh, defines, specularSupported, maxSimultaneousLights, disableLighting) {
    if (maxSimultaneousLights === void 0) {
      maxSimultaneousLights = 4;
    }
    if (disableLighting === void 0) {
      disableLighting = false;
    }
    if (!defines._areLightsDirty) {
      return defines._needNormals;
    }
    var lightIndex = 0;
    var state = {
      needNormals: false,
      needRebuild: false,
      lightmapMode: false,
      shadowEnabled: false,
      specularEnabled: false
    };
    if (scene.lightsEnabled && !disableLighting) {
      for (var _i = 0, _a = mesh.lightSources; _i < _a.length; _i++) {
        var light = _a[_i];
        this.PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state);
        lightIndex++;
        if (lightIndex === maxSimultaneousLights) {
          break;
        }
      }
    }
    defines["SPECULARTERM"] = state.specularEnabled;
    defines["SHADOWS"] = state.shadowEnabled;
    for (var index = lightIndex; index < maxSimultaneousLights; index++) {
      if (defines["LIGHT" + index] !== void 0) {
        defines["LIGHT" + index] = false;
        defines["HEMILIGHT" + index] = false;
        defines["POINTLIGHT" + index] = false;
        defines["DIRLIGHT" + index] = false;
        defines["SPOTLIGHT" + index] = false;
        defines["SHADOW" + index] = false;
        defines["SHADOWCSM" + index] = false;
        defines["SHADOWCSMDEBUG" + index] = false;
        defines["SHADOWCSMNUM_CASCADES" + index] = false;
        defines["SHADOWCSMUSESHADOWMAXZ" + index] = false;
        defines["SHADOWCSMNOBLEND" + index] = false;
        defines["SHADOWCSM_RIGHTHANDED" + index] = false;
        defines["SHADOWPCF" + index] = false;
        defines["SHADOWPCSS" + index] = false;
        defines["SHADOWPOISSON" + index] = false;
        defines["SHADOWESM" + index] = false;
        defines["SHADOWCLOSEESM" + index] = false;
        defines["SHADOWCUBE" + index] = false;
        defines["SHADOWLOWQUALITY" + index] = false;
        defines["SHADOWMEDIUMQUALITY" + index] = false;
      }
    }
    var caps = scene.getEngine().getCaps();
    if (defines["SHADOWFLOAT"] === void 0) {
      state.needRebuild = true;
    }
    defines["SHADOWFLOAT"] = state.shadowEnabled && (caps.textureFloatRender && caps.textureFloatLinearFiltering || caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering);
    defines["LIGHTMAPEXCLUDED"] = state.lightmapMode;
    if (state.needRebuild) {
      defines.rebuild();
    }
    return state.needNormals;
  };
  MaterialHelper2.PrepareUniformsAndSamplersForLight = function(lightIndex, uniformsList, samplersList, projectedLightTexture, uniformBuffersList, updateOnlyBuffersList) {
    if (uniformBuffersList === void 0) {
      uniformBuffersList = null;
    }
    if (updateOnlyBuffersList === void 0) {
      updateOnlyBuffersList = false;
    }
    if (uniformBuffersList) {
      uniformBuffersList.push("Light" + lightIndex);
    }
    if (updateOnlyBuffersList) {
      return;
    }
    uniformsList.push("vLightData" + lightIndex, "vLightDiffuse" + lightIndex, "vLightSpecular" + lightIndex, "vLightDirection" + lightIndex, "vLightFalloff" + lightIndex, "vLightGround" + lightIndex, "lightMatrix" + lightIndex, "shadowsInfo" + lightIndex, "depthValues" + lightIndex);
    samplersList.push("shadowSampler" + lightIndex);
    samplersList.push("depthSampler" + lightIndex);
    uniformsList.push("viewFrustumZ" + lightIndex, "cascadeBlendFactor" + lightIndex, "lightSizeUVCorrection" + lightIndex, "depthCorrection" + lightIndex, "penumbraDarkness" + lightIndex, "frustumLengths" + lightIndex);
    if (projectedLightTexture) {
      samplersList.push("projectionLightSampler" + lightIndex);
      uniformsList.push("textureProjectionMatrix" + lightIndex);
    }
  };
  MaterialHelper2.PrepareUniformsAndSamplersList = function(uniformsListOrOptions, samplersList, defines, maxSimultaneousLights) {
    if (maxSimultaneousLights === void 0) {
      maxSimultaneousLights = 4;
    }
    var uniformsList;
    var uniformBuffersList = null;
    if (uniformsListOrOptions.uniformsNames) {
      var options = uniformsListOrOptions;
      uniformsList = options.uniformsNames;
      uniformBuffersList = options.uniformBuffersNames;
      samplersList = options.samplers;
      defines = options.defines;
      maxSimultaneousLights = options.maxSimultaneousLights || 0;
    } else {
      uniformsList = uniformsListOrOptions;
      if (!samplersList) {
        samplersList = [];
      }
    }
    for (var lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {
      if (!defines["LIGHT" + lightIndex]) {
        break;
      }
      this.PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, defines["PROJECTEDLIGHTTEXTURE" + lightIndex], uniformBuffersList);
    }
    if (defines["NUM_MORPH_INFLUENCERS"]) {
      uniformsList.push("morphTargetInfluences");
    }
  };
  MaterialHelper2.HandleFallbacksForShadows = function(defines, fallbacks, maxSimultaneousLights, rank) {
    if (maxSimultaneousLights === void 0) {
      maxSimultaneousLights = 4;
    }
    if (rank === void 0) {
      rank = 0;
    }
    var lightFallbackRank = 0;
    for (var lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {
      if (!defines["LIGHT" + lightIndex]) {
        break;
      }
      if (lightIndex > 0) {
        lightFallbackRank = rank + lightIndex;
        fallbacks.addFallback(lightFallbackRank, "LIGHT" + lightIndex);
      }
      if (!defines["SHADOWS"]) {
        if (defines["SHADOW" + lightIndex]) {
          fallbacks.addFallback(rank, "SHADOW" + lightIndex);
        }
        if (defines["SHADOWPCF" + lightIndex]) {
          fallbacks.addFallback(rank, "SHADOWPCF" + lightIndex);
        }
        if (defines["SHADOWPCSS" + lightIndex]) {
          fallbacks.addFallback(rank, "SHADOWPCSS" + lightIndex);
        }
        if (defines["SHADOWPOISSON" + lightIndex]) {
          fallbacks.addFallback(rank, "SHADOWPOISSON" + lightIndex);
        }
        if (defines["SHADOWESM" + lightIndex]) {
          fallbacks.addFallback(rank, "SHADOWESM" + lightIndex);
        }
        if (defines["SHADOWCLOSEESM" + lightIndex]) {
          fallbacks.addFallback(rank, "SHADOWCLOSEESM" + lightIndex);
        }
      }
    }
    return lightFallbackRank++;
  };
  MaterialHelper2.PrepareAttributesForMorphTargetsInfluencers = function(attribs, mesh, influencers) {
    this._TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = influencers;
    this.PrepareAttributesForMorphTargets(attribs, mesh, this._TmpMorphInfluencers);
  };
  MaterialHelper2.PrepareAttributesForMorphTargets = function(attribs, mesh, defines) {
    var influencers = defines["NUM_MORPH_INFLUENCERS"];
    if (influencers > 0 && EngineStore.LastCreatedEngine) {
      var maxAttributesCount = EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;
      var manager = mesh.morphTargetManager;
      var normal = manager && manager.supportsNormals && defines["NORMAL"];
      var tangent = manager && manager.supportsTangents && defines["TANGENT"];
      var uv = manager && manager.supportsUVs && defines["UV1"];
      for (var index = 0; index < influencers; index++) {
        attribs.push(VertexBuffer.PositionKind + index);
        if (normal) {
          attribs.push(VertexBuffer.NormalKind + index);
        }
        if (tangent) {
          attribs.push(VertexBuffer.TangentKind + index);
        }
        if (uv) {
          attribs.push(VertexBuffer.UVKind + "_" + index);
        }
        if (attribs.length > maxAttributesCount) {
          Logger.Error("Cannot add more vertex attributes for mesh " + mesh.name);
        }
      }
    }
  };
  MaterialHelper2.PrepareAttributesForBones = function(attribs, mesh, defines, fallbacks) {
    if (defines["NUM_BONE_INFLUENCERS"] > 0) {
      fallbacks.addCPUSkinningFallback(0, mesh);
      attribs.push(VertexBuffer.MatricesIndicesKind);
      attribs.push(VertexBuffer.MatricesWeightsKind);
      if (defines["NUM_BONE_INFLUENCERS"] > 4) {
        attribs.push(VertexBuffer.MatricesIndicesExtraKind);
        attribs.push(VertexBuffer.MatricesWeightsExtraKind);
      }
    }
  };
  MaterialHelper2.PrepareAttributesForInstances = function(attribs, defines) {
    if (defines["INSTANCES"] || defines["THIN_INSTANCES"]) {
      this.PushAttributesForInstances(attribs);
    }
  };
  MaterialHelper2.PushAttributesForInstances = function(attribs) {
    attribs.push("world0");
    attribs.push("world1");
    attribs.push("world2");
    attribs.push("world3");
  };
  MaterialHelper2.BindLightProperties = function(light, effect, lightIndex) {
    light.transferToEffect(effect, lightIndex + "");
  };
  MaterialHelper2.BindLight = function(light, lightIndex, scene, effect, useSpecular, rebuildInParallel) {
    if (rebuildInParallel === void 0) {
      rebuildInParallel = false;
    }
    light._bindLight(lightIndex, scene, effect, useSpecular, rebuildInParallel);
  };
  MaterialHelper2.BindLights = function(scene, mesh, effect, defines, maxSimultaneousLights, rebuildInParallel) {
    if (maxSimultaneousLights === void 0) {
      maxSimultaneousLights = 4;
    }
    if (rebuildInParallel === void 0) {
      rebuildInParallel = false;
    }
    var len = Math.min(mesh.lightSources.length, maxSimultaneousLights);
    for (var i = 0; i < len; i++) {
      var light = mesh.lightSources[i];
      this.BindLight(light, i, scene, effect, typeof defines === "boolean" ? defines : defines["SPECULARTERM"], rebuildInParallel);
    }
  };
  MaterialHelper2.BindFogParameters = function(scene, mesh, effect, linearSpace) {
    if (linearSpace === void 0) {
      linearSpace = false;
    }
    if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {
      effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);
      if (linearSpace) {
        scene.fogColor.toLinearSpaceToRef(this._tempFogColor);
        effect.setColor3("vFogColor", this._tempFogColor);
      } else {
        effect.setColor3("vFogColor", scene.fogColor);
      }
    }
  };
  MaterialHelper2.BindBonesParameters = function(mesh, effect, prePassConfiguration) {
    if (!effect || !mesh) {
      return;
    }
    if (mesh.computeBonesUsingShaders && effect._bonesComputationForcedToCPU) {
      mesh.computeBonesUsingShaders = false;
    }
    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
      var skeleton = mesh.skeleton;
      if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex("boneTextureWidth") > -1) {
        var boneTexture = skeleton.getTransformMatrixTexture(mesh);
        effect.setTexture("boneSampler", boneTexture);
        effect.setFloat("boneTextureWidth", 4 * (skeleton.bones.length + 1));
      } else {
        var matrices = skeleton.getTransformMatrices(mesh);
        if (matrices) {
          effect.setMatrices("mBones", matrices);
          if (prePassConfiguration && mesh.getScene().prePassRenderer && mesh.getScene().prePassRenderer.getIndex(2)) {
            if (prePassConfiguration.previousBones[mesh.uniqueId]) {
              effect.setMatrices("mPreviousBones", prePassConfiguration.previousBones[mesh.uniqueId]);
            }
            MaterialHelper2._CopyBonesTransformationMatrices(matrices, prePassConfiguration.previousBones[mesh.uniqueId]);
          }
        }
      }
    }
  };
  MaterialHelper2._CopyBonesTransformationMatrices = function(source, target) {
    target.set(source);
    return target;
  };
  MaterialHelper2.BindMorphTargetParameters = function(abstractMesh, effect) {
    var manager = abstractMesh.morphTargetManager;
    if (!abstractMesh || !manager) {
      return;
    }
    effect.setFloatArray("morphTargetInfluences", manager.influences);
  };
  MaterialHelper2.BindLogDepth = function(defines, effect, scene) {
    if (defines["LOGARITHMICDEPTH"]) {
      effect.setFloat("logarithmicDepthConstant", 2 / (Math.log(scene.activeCamera.maxZ + 1) / Math.LN2));
    }
  };
  MaterialHelper2.BindClipPlane = function(effect, scene) {
    ThinMaterialHelper.BindClipPlane(effect, scene);
  };
  MaterialHelper2._TmpMorphInfluencers = { "NUM_MORPH_INFLUENCERS": 0 };
  MaterialHelper2._tempFogColor = Color3.Black();
  return MaterialHelper2;
}();

// node_modules/@babylonjs/core/Materials/materialFlags.js
var MaterialFlags = function() {
  function MaterialFlags2() {
  }
  Object.defineProperty(MaterialFlags2, "DiffuseTextureEnabled", {
    get: function() {
      return this._DiffuseTextureEnabled;
    },
    set: function(value) {
      if (this._DiffuseTextureEnabled === value) {
        return;
      }
      this._DiffuseTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "DetailTextureEnabled", {
    get: function() {
      return this._DetailTextureEnabled;
    },
    set: function(value) {
      if (this._DetailTextureEnabled === value) {
        return;
      }
      this._DetailTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "AmbientTextureEnabled", {
    get: function() {
      return this._AmbientTextureEnabled;
    },
    set: function(value) {
      if (this._AmbientTextureEnabled === value) {
        return;
      }
      this._AmbientTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "OpacityTextureEnabled", {
    get: function() {
      return this._OpacityTextureEnabled;
    },
    set: function(value) {
      if (this._OpacityTextureEnabled === value) {
        return;
      }
      this._OpacityTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "ReflectionTextureEnabled", {
    get: function() {
      return this._ReflectionTextureEnabled;
    },
    set: function(value) {
      if (this._ReflectionTextureEnabled === value) {
        return;
      }
      this._ReflectionTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "EmissiveTextureEnabled", {
    get: function() {
      return this._EmissiveTextureEnabled;
    },
    set: function(value) {
      if (this._EmissiveTextureEnabled === value) {
        return;
      }
      this._EmissiveTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "SpecularTextureEnabled", {
    get: function() {
      return this._SpecularTextureEnabled;
    },
    set: function(value) {
      if (this._SpecularTextureEnabled === value) {
        return;
      }
      this._SpecularTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "BumpTextureEnabled", {
    get: function() {
      return this._BumpTextureEnabled;
    },
    set: function(value) {
      if (this._BumpTextureEnabled === value) {
        return;
      }
      this._BumpTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "LightmapTextureEnabled", {
    get: function() {
      return this._LightmapTextureEnabled;
    },
    set: function(value) {
      if (this._LightmapTextureEnabled === value) {
        return;
      }
      this._LightmapTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "RefractionTextureEnabled", {
    get: function() {
      return this._RefractionTextureEnabled;
    },
    set: function(value) {
      if (this._RefractionTextureEnabled === value) {
        return;
      }
      this._RefractionTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "ColorGradingTextureEnabled", {
    get: function() {
      return this._ColorGradingTextureEnabled;
    },
    set: function(value) {
      if (this._ColorGradingTextureEnabled === value) {
        return;
      }
      this._ColorGradingTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "FresnelEnabled", {
    get: function() {
      return this._FresnelEnabled;
    },
    set: function(value) {
      if (this._FresnelEnabled === value) {
        return;
      }
      this._FresnelEnabled = value;
      Engine.MarkAllMaterialsAsDirty(4);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "ClearCoatTextureEnabled", {
    get: function() {
      return this._ClearCoatTextureEnabled;
    },
    set: function(value) {
      if (this._ClearCoatTextureEnabled === value) {
        return;
      }
      this._ClearCoatTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "ClearCoatBumpTextureEnabled", {
    get: function() {
      return this._ClearCoatBumpTextureEnabled;
    },
    set: function(value) {
      if (this._ClearCoatBumpTextureEnabled === value) {
        return;
      }
      this._ClearCoatBumpTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "ClearCoatTintTextureEnabled", {
    get: function() {
      return this._ClearCoatTintTextureEnabled;
    },
    set: function(value) {
      if (this._ClearCoatTintTextureEnabled === value) {
        return;
      }
      this._ClearCoatTintTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "SheenTextureEnabled", {
    get: function() {
      return this._SheenTextureEnabled;
    },
    set: function(value) {
      if (this._SheenTextureEnabled === value) {
        return;
      }
      this._SheenTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "AnisotropicTextureEnabled", {
    get: function() {
      return this._AnisotropicTextureEnabled;
    },
    set: function(value) {
      if (this._AnisotropicTextureEnabled === value) {
        return;
      }
      this._AnisotropicTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "ThicknessTextureEnabled", {
    get: function() {
      return this._ThicknessTextureEnabled;
    },
    set: function(value) {
      if (this._ThicknessTextureEnabled === value) {
        return;
      }
      this._ThicknessTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  MaterialFlags2._DiffuseTextureEnabled = true;
  MaterialFlags2._DetailTextureEnabled = true;
  MaterialFlags2._AmbientTextureEnabled = true;
  MaterialFlags2._OpacityTextureEnabled = true;
  MaterialFlags2._ReflectionTextureEnabled = true;
  MaterialFlags2._EmissiveTextureEnabled = true;
  MaterialFlags2._SpecularTextureEnabled = true;
  MaterialFlags2._BumpTextureEnabled = true;
  MaterialFlags2._LightmapTextureEnabled = true;
  MaterialFlags2._RefractionTextureEnabled = true;
  MaterialFlags2._ColorGradingTextureEnabled = true;
  MaterialFlags2._FresnelEnabled = true;
  MaterialFlags2._ClearCoatTextureEnabled = true;
  MaterialFlags2._ClearCoatBumpTextureEnabled = true;
  MaterialFlags2._ClearCoatTintTextureEnabled = true;
  MaterialFlags2._SheenTextureEnabled = true;
  MaterialFlags2._AnisotropicTextureEnabled = true;
  MaterialFlags2._ThicknessTextureEnabled = true;
  return MaterialFlags2;
}();

// node_modules/@babylonjs/core/Materials/effectFallbacks.js
var EffectFallbacks = function() {
  function EffectFallbacks2() {
    this._defines = {};
    this._currentRank = 32;
    this._maxRank = -1;
    this._mesh = null;
  }
  EffectFallbacks2.prototype.unBindMesh = function() {
    this._mesh = null;
  };
  EffectFallbacks2.prototype.addFallback = function(rank, define) {
    if (!this._defines[rank]) {
      if (rank < this._currentRank) {
        this._currentRank = rank;
      }
      if (rank > this._maxRank) {
        this._maxRank = rank;
      }
      this._defines[rank] = new Array();
    }
    this._defines[rank].push(define);
  };
  EffectFallbacks2.prototype.addCPUSkinningFallback = function(rank, mesh) {
    this._mesh = mesh;
    if (rank < this._currentRank) {
      this._currentRank = rank;
    }
    if (rank > this._maxRank) {
      this._maxRank = rank;
    }
  };
  Object.defineProperty(EffectFallbacks2.prototype, "hasMoreFallbacks", {
    get: function() {
      return this._currentRank <= this._maxRank;
    },
    enumerable: false,
    configurable: true
  });
  EffectFallbacks2.prototype.reduce = function(currentDefines, effect) {
    if (this._mesh && this._mesh.computeBonesUsingShaders && this._mesh.numBoneInfluencers > 0) {
      this._mesh.computeBonesUsingShaders = false;
      currentDefines = currentDefines.replace("#define NUM_BONE_INFLUENCERS " + this._mesh.numBoneInfluencers, "#define NUM_BONE_INFLUENCERS 0");
      effect._bonesComputationForcedToCPU = true;
      var scene = this._mesh.getScene();
      for (var index = 0; index < scene.meshes.length; index++) {
        var otherMesh = scene.meshes[index];
        if (!otherMesh.material) {
          if (!this._mesh.material && otherMesh.computeBonesUsingShaders && otherMesh.numBoneInfluencers > 0) {
            otherMesh.computeBonesUsingShaders = false;
          }
          continue;
        }
        if (!otherMesh.computeBonesUsingShaders || otherMesh.numBoneInfluencers === 0) {
          continue;
        }
        if (otherMesh.material.getEffect() === effect) {
          otherMesh.computeBonesUsingShaders = false;
        } else if (otherMesh.subMeshes) {
          for (var _i = 0, _a = otherMesh.subMeshes; _i < _a.length; _i++) {
            var subMesh = _a[_i];
            var subMeshEffect = subMesh.effect;
            if (subMeshEffect === effect) {
              otherMesh.computeBonesUsingShaders = false;
              break;
            }
          }
        }
      }
    } else {
      var currentFallbacks = this._defines[this._currentRank];
      if (currentFallbacks) {
        for (var index = 0; index < currentFallbacks.length; index++) {
          currentDefines = currentDefines.replace("#define " + currentFallbacks[index], "");
        }
      }
      this._currentRank++;
    }
    return currentDefines;
  };
  return EffectFallbacks2;
}();

// node_modules/@babylonjs/core/Materials/prePassConfiguration.js
var PrePassConfiguration = function() {
  function PrePassConfiguration2() {
    this.previousWorldMatrices = {};
    this.previousBones = {};
  }
  PrePassConfiguration2.AddUniforms = function(uniforms) {
    uniforms.push("previousWorld", "previousViewProjection");
  };
  PrePassConfiguration2.AddSamplers = function(samplers) {
  };
  PrePassConfiguration2.prototype.bindForSubMesh = function(effect, scene, mesh, world, isFrozen) {
    if (scene.prePassRenderer && scene.prePassRenderer.enabled) {
      if (scene.prePassRenderer.getIndex(2) !== -1) {
        if (!this.previousWorldMatrices[mesh.uniqueId]) {
          this.previousWorldMatrices[mesh.uniqueId] = Matrix.Identity();
        }
        if (!this.previousViewProjection) {
          this.previousViewProjection = scene.getTransformMatrix();
        }
        effect.setMatrix("previousWorld", this.previousWorldMatrices[mesh.uniqueId]);
        effect.setMatrix("previousViewProjection", this.previousViewProjection);
        this.previousWorldMatrices[mesh.uniqueId] = world.clone();
        this.previousViewProjection = scene.getTransformMatrix().clone();
      }
    }
  };
  return PrePassConfiguration2;
}();

// node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultFragmentDeclaration.js
var name = "defaultFragmentDeclaration";
var shader = "uniform vec4 vDiffuseColor;\n#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\n#endif\nuniform vec3 vEmissiveColor;\nuniform float visibility;\n\n#ifdef DIFFUSE\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef AMBIENT\nuniform vec2 vAmbientInfos;\n#endif\n#ifdef OPACITY\nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\n#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform vec2 vTangentSpaceParams;\n#endif\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION)\nuniform mat4 view;\n#endif\n#ifdef REFRACTION\nuniform vec4 vRefractionInfos;\n#ifndef REFRACTIONMAP_3D\nuniform mat4 refractionMatrix;\n#endif\n#ifdef REFRACTIONFRESNEL\nuniform vec4 refractionLeftColor;\nuniform vec4 refractionRightColor;\n#endif\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM)\nuniform vec2 vSpecularInfos;\n#endif\n#ifdef DIFFUSEFRESNEL\nuniform vec4 diffuseLeftColor;\nuniform vec4 diffuseRightColor;\n#endif\n#ifdef OPACITYFRESNEL\nuniform vec4 opacityParts;\n#endif\n#ifdef EMISSIVEFRESNEL\nuniform vec4 emissiveLeftColor;\nuniform vec4 emissiveRightColor;\n#endif\n\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;\n#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION) || defined(REFLECTIONMAP_EQUIRECTANGULAR) || defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_SKYBOX)\nuniform mat4 reflectionMatrix;\n#endif\n#ifndef REFLECTIONMAP_SKYBOX\n#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)\nuniform vec3 vReflectionPosition;\nuniform vec3 vReflectionSize;\n#endif\n#endif\n#ifdef REFLECTIONFRESNEL\nuniform vec4 reflectionLeftColor;\nuniform vec4 reflectionRightColor;\n#endif\n#endif";
Effect.IncludesShadersStore[name] = shader;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultUboDeclaration.js
var name2 = "defaultUboDeclaration";
var shader2 = "layout(std140,column_major) uniform;\nuniform Material\n{\nvec4 diffuseLeftColor;\nvec4 diffuseRightColor;\nvec4 opacityParts;\nvec4 reflectionLeftColor;\nvec4 reflectionRightColor;\nvec4 refractionLeftColor;\nvec4 refractionRightColor;\nvec4 emissiveLeftColor;\nvec4 emissiveRightColor;\nvec2 vDiffuseInfos;\nvec2 vAmbientInfos;\nvec2 vOpacityInfos;\nvec2 vReflectionInfos;\nvec3 vReflectionPosition;\nvec3 vReflectionSize;\nvec2 vEmissiveInfos;\nvec2 vLightmapInfos;\nvec2 vSpecularInfos;\nvec3 vBumpInfos;\nmat4 diffuseMatrix;\nmat4 ambientMatrix;\nmat4 opacityMatrix;\nmat4 reflectionMatrix;\nmat4 emissiveMatrix;\nmat4 lightmapMatrix;\nmat4 specularMatrix;\nmat4 bumpMatrix;\nvec2 vTangentSpaceParams;\nfloat pointSize;\nmat4 refractionMatrix;\nvec4 vRefractionInfos;\nvec4 vSpecularColor;\nvec3 vEmissiveColor;\nfloat visibility;\nvec4 vDiffuseColor;\nvec4 vDetailInfos;\nmat4 detailMatrix;\n};\nuniform Scene {\nmat4 viewProjection;\n#ifdef MULTIVIEW\nmat4 viewProjectionR;\n#endif\nmat4 view;\n};\n";
Effect.IncludesShadersStore[name2] = shader2;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassDeclaration.js
var name3 = "prePassDeclaration";
var shader3 = "#ifdef PREPASS\n#extension GL_EXT_draw_buffers : require\n#ifdef WEBGL2\nlayout(location=0) out highp vec4 glFragData[{X}];\nhighp vec4 gl_FragColor;\n#endif\n#ifdef PREPASS_DEPTHNORMAL\nvarying highp vec3 vViewPos;\n#endif\n#ifdef PREPASS_VELOCITY\nvarying highp vec4 vCurrentPosition;\nvarying highp vec4 vPreviousPosition;\n#endif\n#endif\n";
Effect.IncludesShadersStore[name3] = shader3;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/helperFunctions.js
var name4 = "helperFunctions";
var shader4 = "const float PI=3.1415926535897932384626433832795;\nconst float HALF_MIN=5.96046448e-08;\nconst float LinearEncodePowerApprox=2.2;\nconst float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;\nconst vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);\nconst float Epsilon=0.0000001;\n#define saturate(x) clamp(x,0.0,1.0)\n#define absEps(x) abs(x)+Epsilon\n#define maxEps(x) max(x,Epsilon)\n#define saturateEps(x) clamp(x,Epsilon,1.0)\nmat3 transposeMat3(mat3 inMatrix) {\nvec3 i0=inMatrix[0];\nvec3 i1=inMatrix[1];\nvec3 i2=inMatrix[2];\nmat3 outMatrix=mat3(\nvec3(i0.x,i1.x,i2.x),\nvec3(i0.y,i1.y,i2.y),\nvec3(i0.z,i1.z,i2.z)\n);\nreturn outMatrix;\n}\n\nmat3 inverseMat3(mat3 inMatrix) {\nfloat a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];\nfloat a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];\nfloat a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];\nfloat b01=a22*a11-a12*a21;\nfloat b11=-a22*a10+a12*a20;\nfloat b21=a21*a10-a11*a20;\nfloat det=a00*b01+a01*b11+a02*b21;\nreturn mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),\nb11,(a22*a00-a02*a20),(-a12*a00+a02*a10),\nb21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;\n}\nfloat toLinearSpace(float color)\n{\nreturn pow(color,LinearEncodePowerApprox);\n}\nvec3 toLinearSpace(vec3 color)\n{\nreturn pow(color,vec3(LinearEncodePowerApprox));\n}\nvec4 toLinearSpace(vec4 color)\n{\nreturn vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);\n}\nvec3 toGammaSpace(vec3 color)\n{\nreturn pow(color,vec3(GammaEncodePowerApprox));\n}\nvec4 toGammaSpace(vec4 color)\n{\nreturn vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);\n}\nfloat toGammaSpace(float color)\n{\nreturn pow(color,GammaEncodePowerApprox);\n}\nfloat square(float value)\n{\nreturn value*value;\n}\nfloat pow5(float value) {\nfloat sq=value*value;\nreturn sq*sq*value;\n}\nfloat getLuminance(vec3 color)\n{\nreturn clamp(dot(color,LuminanceEncodeApprox),0.,1.);\n}\n\nfloat getRand(vec2 seed) {\nreturn fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);\n}\nfloat dither(vec2 seed,float varianceAmount) {\nfloat rand=getRand(seed);\nfloat dither=mix(-varianceAmount/255.0,varianceAmount/255.0,rand);\nreturn dither;\n}\n\nconst float rgbdMaxRange=255.0;\nvec4 toRGBD(vec3 color) {\nfloat maxRGB=maxEps(max(color.r,max(color.g,color.b)));\nfloat D=max(rgbdMaxRange/maxRGB,1.);\nD=clamp(floor(D)/255.0,0.,1.);\n\nvec3 rgb=color.rgb*D;\n\nrgb=toGammaSpace(rgb);\nreturn vec4(rgb,D);\n}\nvec3 fromRGBD(vec4 rgbd) {\n\nrgbd.rgb=toLinearSpace(rgbd.rgb);\n\nreturn rgbd.rgb/rgbd.a;\n}\n";
Effect.IncludesShadersStore[name4] = shader4;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration.js
var name5 = "lightFragmentDeclaration";
var shader5 = "#ifdef LIGHT{X}\nuniform vec4 vLightData{X};\nuniform vec4 vLightDiffuse{X};\n#ifdef SPECULARTERM\nuniform vec4 vLightSpecular{X};\n#else\nvec4 vLightSpecular{X}=vec4(0.);\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float cascadeBlendFactor{X};\nvarying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying vec4 vPositionFromCamera{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\nuniform highp sampler2DArray depthSampler{X};\nuniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float penumbraDarkness{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\n#else\nuniform highp sampler2DArray shadowSampler{X};\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\n(\nvec3 ( 1.5,0.0,0.0 ),\nvec3 ( 0.0,1.5,0.0 ),\nvec3 ( 0.0,0.0,5.5 ),\nvec3 ( 1.5,0.0,5.5 ),\nvec3 ( 1.5,1.5,0.0 ),\nvec3 ( 1.0,1.0,1.0 ),\nvec3 ( 0.0,1.0,5.5 ),\nvec3 ( 0.5,3.5,0.75 )\n);\nvec3 shadowDebug{X};\n#endif\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nint index{X}=-1;\n#else\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\n#endif\nfloat diff{X}=0.;\n#elif defined(SHADOWCUBE{X})\nuniform samplerCube shadowSampler{X};\n#else\nvarying vec4 vPositionFromLight{X};\nvarying float vDepthMetric{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DShadow shadowSampler{X};\nuniform highp sampler2D depthSampler{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DShadow shadowSampler{X};\n#else\nuniform sampler2D shadowSampler{X};\n#endif\nuniform mat4 lightMatrix{X};\n#endif\nuniform vec4 shadowsInfo{X};\nuniform vec2 depthValues{X};\n#endif\n#ifdef SPOTLIGHT{X}\nuniform vec4 vLightDirection{X};\nuniform vec4 vLightFalloff{X};\n#elif defined(POINTLIGHT{X})\nuniform vec4 vLightFalloff{X};\n#elif defined(HEMILIGHT{X})\nuniform vec3 vLightGround{X};\n#endif\n#ifdef PROJECTEDLIGHTTEXTURE{X}\nuniform mat4 textureProjectionMatrix{X};\nuniform sampler2D projectionLightSampler{X};\n#endif\n#endif";
Effect.IncludesShadersStore[name5] = shader5;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration.js
var name6 = "lightUboDeclaration";
var shader6 = "#ifdef LIGHT{X}\nuniform Light{X}\n{\nvec4 vLightData;\nvec4 vLightDiffuse;\nvec4 vLightSpecular;\n#ifdef SPOTLIGHT{X}\nvec4 vLightDirection;\nvec4 vLightFalloff;\n#elif defined(POINTLIGHT{X})\nvec4 vLightFalloff;\n#elif defined(HEMILIGHT{X})\nvec3 vLightGround;\n#endif\nvec4 shadowsInfo;\nvec2 depthValues;\n} light{X};\n#ifdef PROJECTEDLIGHTTEXTURE{X}\nuniform mat4 textureProjectionMatrix{X};\nuniform sampler2D projectionLightSampler{X};\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float cascadeBlendFactor{X};\nvarying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying vec4 vPositionFromCamera{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\nuniform highp sampler2DArray depthSampler{X};\nuniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float penumbraDarkness{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\n#else\nuniform highp sampler2DArray shadowSampler{X};\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\n(\nvec3 ( 1.5,0.0,0.0 ),\nvec3 ( 0.0,1.5,0.0 ),\nvec3 ( 0.0,0.0,5.5 ),\nvec3 ( 1.5,0.0,5.5 ),\nvec3 ( 1.5,1.5,0.0 ),\nvec3 ( 1.0,1.0,1.0 ),\nvec3 ( 0.0,1.0,5.5 ),\nvec3 ( 0.5,3.5,0.75 )\n);\nvec3 shadowDebug{X};\n#endif\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nint index{X}=-1;\n#else\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\n#endif\nfloat diff{X}=0.;\n#elif defined(SHADOWCUBE{X})\nuniform samplerCube shadowSampler{X};\n#else\nvarying vec4 vPositionFromLight{X};\nvarying float vDepthMetric{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DShadow shadowSampler{X};\nuniform highp sampler2D depthSampler{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DShadow shadowSampler{X};\n#else\nuniform sampler2D shadowSampler{X};\n#endif\nuniform mat4 lightMatrix{X};\n#endif\n#endif\n#endif";
Effect.IncludesShadersStore[name6] = shader6;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/lightsFragmentFunctions.js
var name7 = "lightsFragmentFunctions";
var shader7 = "\nstruct lightingInfo\n{\nvec3 diffuse;\n#ifdef SPECULARTERM\nvec3 specular;\n#endif\n#ifdef NDOTL\nfloat ndl;\n#endif\n};\nlightingInfo computeLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {\nlightingInfo result;\nvec3 lightVectorW;\nfloat attenuation=1.0;\nif (lightData.w == 0.)\n{\nvec3 direction=lightData.xyz-vPositionW;\nattenuation=max(0.,1.0-length(direction)/range);\nlightVectorW=normalize(direction);\n}\nelse\n{\nlightVectorW=normalize(-lightData.xyz);\n}\n\nfloat ndl=max(0.,dot(vNormal,lightVectorW));\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=ndl*diffuseColor*attenuation;\n#ifdef SPECULARTERM\n\nvec3 angleW=normalize(viewDirectionW+lightVectorW);\nfloat specComp=max(0.,dot(vNormal,angleW));\nspecComp=pow(specComp,max(1.,glossiness));\nresult.specular=specComp*specularColor*attenuation;\n#endif\nreturn result;\n}\nlightingInfo computeSpotLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec4 lightDirection,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {\nlightingInfo result;\nvec3 direction=lightData.xyz-vPositionW;\nvec3 lightVectorW=normalize(direction);\nfloat attenuation=max(0.,1.0-length(direction)/range);\n\nfloat cosAngle=max(0.,dot(lightDirection.xyz,-lightVectorW));\nif (cosAngle>=lightDirection.w)\n{\ncosAngle=max(0.,pow(cosAngle,lightData.w));\nattenuation*=cosAngle;\n\nfloat ndl=max(0.,dot(vNormal,lightVectorW));\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=ndl*diffuseColor*attenuation;\n#ifdef SPECULARTERM\n\nvec3 angleW=normalize(viewDirectionW+lightVectorW);\nfloat specComp=max(0.,dot(vNormal,angleW));\nspecComp=pow(specComp,max(1.,glossiness));\nresult.specular=specComp*specularColor*attenuation;\n#endif\nreturn result;\n}\nresult.diffuse=vec3(0.);\n#ifdef SPECULARTERM\nresult.specular=vec3(0.);\n#endif\n#ifdef NDOTL\nresult.ndl=0.;\n#endif\nreturn result;\n}\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,vec3 groundColor,float glossiness) {\nlightingInfo result;\n\nfloat ndl=dot(vNormal,lightData.xyz)*0.5+0.5;\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=mix(groundColor,diffuseColor,ndl);\n#ifdef SPECULARTERM\n\nvec3 angleW=normalize(viewDirectionW+lightData.xyz);\nfloat specComp=max(0.,dot(vNormal,angleW));\nspecComp=pow(specComp,max(1.,glossiness));\nresult.specular=specComp*specularColor;\n#endif\nreturn result;\n}\n#define inline\nvec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){\nvec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);\nstrq/=strq.w;\nvec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;\nreturn textureColor;\n}";
Effect.IncludesShadersStore[name7] = shader7;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsFragmentFunctions.js
var name8 = "shadowsFragmentFunctions";
var shader8 = "#ifdef SHADOWS\n#ifndef SHADOWFLOAT\n\nfloat unpack(vec4 color)\n{\nconst vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);\nreturn dot(color,bit_shift);\n}\n#endif\nfloat computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)\n{\nfloat mask=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));\nreturn mix(value,1.0,mask);\n}\n#define inline\nfloat computeShadowCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)\n{\nvec3 directionToLight=vPositionW-lightPosition;\nfloat depth=length(directionToLight);\ndepth=(depth+depthValues.x)/(depthValues.y);\ndepth=clamp(depth,0.,1.0);\ndirectionToLight=normalize(directionToLight);\ndirectionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadow=textureCube(shadowSampler,directionToLight).x;\n#endif\nreturn depth>shadow ? darkness : 1.0;\n}\n#define inline\nfloat computeShadowWithPoissonSamplingCube(vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)\n{\nvec3 directionToLight=vPositionW-lightPosition;\nfloat depth=length(directionToLight);\ndepth=(depth+depthValues.x)/(depthValues.y);\ndepth=clamp(depth,0.,1.0);\ndirectionToLight=normalize(directionToLight);\ndirectionToLight.y=-directionToLight.y;\nfloat visibility=1.;\nvec3 poissonDisk[4];\npoissonDisk[0]=vec3(-1.0,1.0,-1.0);\npoissonDisk[1]=vec3(1.0,-1.0,-1.0);\npoissonDisk[2]=vec3(-1.0,-1.0,-1.0);\npoissonDisk[3]=vec3(1.0,-1.0,1.0);\n\n#ifndef SHADOWFLOAT\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;\n#else\nif (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;\nif (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;\nif (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;\nif (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;\n#endif\nreturn min(1.0,visibility+darkness);\n}\n#define inline\nfloat computeShadowWithESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\n{\nvec3 directionToLight=vPositionW-lightPosition;\nfloat depth=length(directionToLight);\ndepth=(depth+depthValues.x)/(depthValues.y);\nfloat shadowPixelDepth=clamp(depth,0.,1.0);\ndirectionToLight=normalize(directionToLight);\ndirectionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\n#endif\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);\nreturn esm;\n}\n#define inline\nfloat computeShadowWithCloseESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\n{\nvec3 directionToLight=vPositionW-lightPosition;\nfloat depth=length(directionToLight);\ndepth=(depth+depthValues.x)/(depthValues.y);\nfloat shadowPixelDepth=clamp(depth,0.,1.0);\ndirectionToLight=normalize(directionToLight);\ndirectionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\n#endif\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);\nreturn esm;\n}\n#ifdef WEBGL2\n#define inline\nfloat computeShadowCSM(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray shadowSampler,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\nvec3 uvLayer=vec3(uv.x,uv.y,layer);\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(texture2D(shadowSampler,uvLayer));\n#else\nfloat shadow=texture2D(shadowSampler,uvLayer).x;\n#endif\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;\n}\n#endif\n#define inline\nfloat computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{\nreturn 1.0;\n}\nelse\n{\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(texture2D(shadowSampler,uv));\n#else\nfloat shadow=texture2D(shadowSampler,uv).x;\n#endif\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;\n}\n}\n#define inline\nfloat computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{\nreturn 1.0;\n}\nelse\n{\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\nfloat visibility=1.;\nvec2 poissonDisk[4];\npoissonDisk[0]=vec2(-0.94201624,-0.39906216);\npoissonDisk[1]=vec2(0.94558609,-0.76890725);\npoissonDisk[2]=vec2(-0.094184101,-0.92938870);\npoissonDisk[3]=vec2(0.34495938,0.29387760);\n\n#ifndef SHADOWFLOAT\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[0]*mapSize))<shadowPixelDepth) visibility-=0.25;\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[1]*mapSize))<shadowPixelDepth) visibility-=0.25;\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[2]*mapSize))<shadowPixelDepth) visibility-=0.25;\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[3]*mapSize))<shadowPixelDepth) visibility-=0.25;\n#else\nif (texture2D(shadowSampler,uv+poissonDisk[0]*mapSize).x<shadowPixelDepth) visibility-=0.25;\nif (texture2D(shadowSampler,uv+poissonDisk[1]*mapSize).x<shadowPixelDepth) visibility-=0.25;\nif (texture2D(shadowSampler,uv+poissonDisk[2]*mapSize).x<shadowPixelDepth) visibility-=0.25;\nif (texture2D(shadowSampler,uv+poissonDisk[3]*mapSize).x<shadowPixelDepth) visibility-=0.25;\n#endif\nreturn computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);\n}\n}\n#define inline\nfloat computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{\nreturn 1.0;\n}\nelse\n{\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(texture2D(shadowSampler,uv));\n#else\nfloat shadowMapSample=texture2D(shadowSampler,uv).x;\n#endif\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);\nreturn computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n#define inline\nfloat computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{\nreturn 1.0;\n}\nelse\n{\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(texture2D(shadowSampler,uv));\n#else\nfloat shadowMapSample=texture2D(shadowSampler,uv).x;\n#endif\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);\nreturn computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n#ifdef WEBGL2\n#define GREATEST_LESS_THAN_ONE 0.99999994\n\n#define inline\nfloat computeShadowWithCSMPCF1(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=clamp(uvDepth.z,0.,GREATEST_LESS_THAN_ONE);\nvec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);\nfloat shadow=texture(shadowSampler,uvDepthLayer);\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n\n\n\n#define inline\nfloat computeShadowWithCSMPCF3(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=clamp(uvDepth.z,0.,GREATEST_LESS_THAN_ONE);\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x;\nuv+=0.5;\nvec2 st=fract(uv);\nvec2 base_uv=floor(uv)-0.5;\nbase_uv*=shadowMapSizeAndInverse.y;\n\n\n\n\nvec2 uvw0=3.-2.*st;\nvec2 uvw1=1.+2.*st;\nvec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;\nvec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;\nfloat shadow=0.;\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));\nshadow=shadow/16.;\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n\n\n\n#define inline\nfloat computeShadowWithCSMPCF5(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=clamp(uvDepth.z,0.,GREATEST_LESS_THAN_ONE);\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x;\nuv+=0.5;\nvec2 st=fract(uv);\nvec2 base_uv=floor(uv)-0.5;\nbase_uv*=shadowMapSizeAndInverse.y;\n\n\nvec2 uvw0=4.-3.*st;\nvec2 uvw1=vec2(7.);\nvec2 uvw2=1.+3.*st;\nvec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;\nvec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;\nfloat shadow=0.;\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));\nshadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[0]),layer,uvDepth.z));\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));\nshadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[1]),layer,uvDepth.z));\nshadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[2]),layer,uvDepth.z));\nshadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[2]),layer,uvDepth.z));\nshadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[2]),layer,uvDepth.z));\nshadow=shadow/144.;\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n\n#define inline\nfloat computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)\n{\nif (depthMetric>1.0 || depthMetric<0.0) {\nreturn 1.0;\n}\nelse\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nfloat shadow=texture2D(shadowSampler,uvDepth);\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n\n\n\n#define inline\nfloat computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{\nif (depthMetric>1.0 || depthMetric<0.0) {\nreturn 1.0;\n}\nelse\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x;\nuv+=0.5;\nvec2 st=fract(uv);\nvec2 base_uv=floor(uv)-0.5;\nbase_uv*=shadowMapSizeAndInverse.y;\n\n\n\n\nvec2 uvw0=3.-2.*st;\nvec2 uvw1=1.+2.*st;\nvec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;\nvec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;\nfloat shadow=0.;\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z));\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z));\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z));\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z));\nshadow=shadow/16.;\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n\n\n\n#define inline\nfloat computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{\nif (depthMetric>1.0 || depthMetric<0.0) {\nreturn 1.0;\n}\nelse\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x;\nuv+=0.5;\nvec2 st=fract(uv);\nvec2 base_uv=floor(uv)-0.5;\nbase_uv*=shadowMapSizeAndInverse.y;\n\n\nvec2 uvw0=4.-3.*st;\nvec2 uvw1=vec2(7.);\nvec2 uvw2=1.+3.*st;\nvec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;\nvec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;\nfloat shadow=0.;\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z));\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z));\nshadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z));\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z));\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z));\nshadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z));\nshadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z));\nshadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z));\nshadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z));\nshadow=shadow/144.;\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n}\nconst vec3 PoissonSamplers32[64]=vec3[64](\nvec3(0.06407013,0.05409927,0.),\nvec3(0.7366577,0.5789394,0.),\nvec3(-0.6270542,-0.5320278,0.),\nvec3(-0.4096107,0.8411095,0.),\nvec3(0.6849564,-0.4990818,0.),\nvec3(-0.874181,-0.04579735,0.),\nvec3(0.9989998,0.0009880066,0.),\nvec3(-0.004920578,-0.9151649,0.),\nvec3(0.1805763,0.9747483,0.),\nvec3(-0.2138451,0.2635818,0.),\nvec3(0.109845,0.3884785,0.),\nvec3(0.06876755,-0.3581074,0.),\nvec3(0.374073,-0.7661266,0.),\nvec3(0.3079132,-0.1216763,0.),\nvec3(-0.3794335,-0.8271583,0.),\nvec3(-0.203878,-0.07715034,0.),\nvec3(0.5912697,0.1469799,0.),\nvec3(-0.88069,0.3031784,0.),\nvec3(0.5040108,0.8283722,0.),\nvec3(-0.5844124,0.5494877,0.),\nvec3(0.6017799,-0.1726654,0.),\nvec3(-0.5554981,0.1559997,0.),\nvec3(-0.3016369,-0.3900928,0.),\nvec3(-0.5550632,-0.1723762,0.),\nvec3(0.925029,0.2995041,0.),\nvec3(-0.2473137,0.5538505,0.),\nvec3(0.9183037,-0.2862392,0.),\nvec3(0.2469421,0.6718712,0.),\nvec3(0.3916397,-0.4328209,0.),\nvec3(-0.03576927,-0.6220032,0.),\nvec3(-0.04661255,0.7995201,0.),\nvec3(0.4402924,0.3640312,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.)\n);\nconst vec3 PoissonSamplers64[64]=vec3[64](\nvec3(-0.613392,0.617481,0.),\nvec3(0.170019,-0.040254,0.),\nvec3(-0.299417,0.791925,0.),\nvec3(0.645680,0.493210,0.),\nvec3(-0.651784,0.717887,0.),\nvec3(0.421003,0.027070,0.),\nvec3(-0.817194,-0.271096,0.),\nvec3(-0.705374,-0.668203,0.),\nvec3(0.977050,-0.108615,0.),\nvec3(0.063326,0.142369,0.),\nvec3(0.203528,0.214331,0.),\nvec3(-0.667531,0.326090,0.),\nvec3(-0.098422,-0.295755,0.),\nvec3(-0.885922,0.215369,0.),\nvec3(0.566637,0.605213,0.),\nvec3(0.039766,-0.396100,0.),\nvec3(0.751946,0.453352,0.),\nvec3(0.078707,-0.715323,0.),\nvec3(-0.075838,-0.529344,0.),\nvec3(0.724479,-0.580798,0.),\nvec3(0.222999,-0.215125,0.),\nvec3(-0.467574,-0.405438,0.),\nvec3(-0.248268,-0.814753,0.),\nvec3(0.354411,-0.887570,0.),\nvec3(0.175817,0.382366,0.),\nvec3(0.487472,-0.063082,0.),\nvec3(-0.084078,0.898312,0.),\nvec3(0.488876,-0.783441,0.),\nvec3(0.470016,0.217933,0.),\nvec3(-0.696890,-0.549791,0.),\nvec3(-0.149693,0.605762,0.),\nvec3(0.034211,0.979980,0.),\nvec3(0.503098,-0.308878,0.),\nvec3(-0.016205,-0.872921,0.),\nvec3(0.385784,-0.393902,0.),\nvec3(-0.146886,-0.859249,0.),\nvec3(0.643361,0.164098,0.),\nvec3(0.634388,-0.049471,0.),\nvec3(-0.688894,0.007843,0.),\nvec3(0.464034,-0.188818,0.),\nvec3(-0.440840,0.137486,0.),\nvec3(0.364483,0.511704,0.),\nvec3(0.034028,0.325968,0.),\nvec3(0.099094,-0.308023,0.),\nvec3(0.693960,-0.366253,0.),\nvec3(0.678884,-0.204688,0.),\nvec3(0.001801,0.780328,0.),\nvec3(0.145177,-0.898984,0.),\nvec3(0.062655,-0.611866,0.),\nvec3(0.315226,-0.604297,0.),\nvec3(-0.780145,0.486251,0.),\nvec3(-0.371868,0.882138,0.),\nvec3(0.200476,0.494430,0.),\nvec3(-0.494552,-0.711051,0.),\nvec3(0.612476,0.705252,0.),\nvec3(-0.578845,-0.768792,0.),\nvec3(-0.772454,-0.090976,0.),\nvec3(0.504440,0.372295,0.),\nvec3(0.155736,0.065157,0.),\nvec3(0.391522,0.849605,0.),\nvec3(-0.620106,-0.328104,0.),\nvec3(0.789239,-0.419965,0.),\nvec3(-0.545396,0.538133,0.),\nvec3(-0.178564,-0.596057,0.)\n);\n\n\n\n\n\n#define inline\nfloat computeShadowWithCSMPCSS(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=clamp(uvDepth.z,0.,GREATEST_LESS_THAN_ONE);\nvec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);\nfloat blockerDepth=0.0;\nfloat sumBlockerDepth=0.0;\nfloat numBlocker=0.0;\nfor (int i=0; i<searchTapCount; i ++) {\nblockerDepth=texture(depthSampler,vec3(uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer)).r;\nif (blockerDepth<depthMetric) {\nsumBlockerDepth+=blockerDepth;\nnumBlocker++;\n}\n}\nif (numBlocker<1.0) {\nreturn 1.0;\n}\nelse\n{\nfloat avgBlockerDepth=sumBlockerDepth/numBlocker;\n\nfloat AAOffset=shadowMapSizeInverse*10.;\n\n\nfloat penumbraRatio=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);\nvec4 filterRadius=vec4(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);\nfloat random=getRand(vPositionFromLight.xy);\nfloat rotationAngle=random*3.1415926;\nvec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));\nfloat shadow=0.;\nfor (int i=0; i<pcfTapCount; i++) {\nvec4 offset=vec4(poissonSamplers[i],0.);\n\noffset=vec4(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);\nshadow+=texture2D(shadowSampler,uvDepthLayer+offset*filterRadius);\n}\nshadow/=float(pcfTapCount);\n\nshadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));\n\nshadow=mix(darkness,1.,shadow);\n\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n\n\n\n\n\n#define inline\nfloat computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)\n{\nif (depthMetric>1.0 || depthMetric<0.0) {\nreturn 1.0;\n}\nelse\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nfloat blockerDepth=0.0;\nfloat sumBlockerDepth=0.0;\nfloat numBlocker=0.0;\nfor (int i=0; i<searchTapCount; i ++) {\nblockerDepth=texture(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy)).r;\nif (blockerDepth<depthMetric) {\nsumBlockerDepth+=blockerDepth;\nnumBlocker++;\n}\n}\nif (numBlocker<1.0) {\nreturn 1.0;\n}\nelse\n{\nfloat avgBlockerDepth=sumBlockerDepth/numBlocker;\n\nfloat AAOffset=shadowMapSizeInverse*10.;\n\n\nfloat penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);\nfloat filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;\nfloat random=getRand(vPositionFromLight.xy);\nfloat rotationAngle=random*3.1415926;\nvec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));\nfloat shadow=0.;\nfor (int i=0; i<pcfTapCount; i++) {\nvec3 offset=poissonSamplers[i];\n\noffset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);\nshadow+=texture2D(shadowSampler,uvDepth+offset*filterRadius);\n}\nshadow/=float(pcfTapCount);\n\nshadow=mix(shadow,1.,depthMetric-avgBlockerDepth);\n\nshadow=mix(darkness,1.,shadow);\n\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n}\n#define inline\nfloat computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{\nreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);\n}\n#define inline\nfloat computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{\nreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);\n}\n#define inline\nfloat computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{\nreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);\n}\n#define inline\nfloat computeShadowWithCSMPCSS16(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{\nreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\n}\n#define inline\nfloat computeShadowWithCSMPCSS32(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{\nreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\n}\n#define inline\nfloat computeShadowWithCSMPCSS64(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{\nreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\n}\n#endif\n#endif\n";
Effect.IncludesShadersStore[name8] = shader8;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/fresnelFunction.js
var name9 = "fresnelFunction";
var shader9 = "#ifdef FRESNEL\nfloat computeFresnelTerm(vec3 viewDirection,vec3 worldNormal,float bias,float power)\n{\nfloat fresnelTerm=pow(bias+abs(dot(viewDirection,worldNormal)),power);\nreturn clamp(fresnelTerm,0.,1.);\n}\n#endif";
Effect.IncludesShadersStore[name9] = shader9;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/reflectionFunction.js
var name10 = "reflectionFunction";
var shader10 = "vec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {\n\nvec3 invOrigVec=vec3(1.0,1.0,1.0)/origVec;\nvec3 halfSize=cubeSize*0.5;\nvec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;\nvec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;\n\nvec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);\n\nfloat distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);\n\nvec3 intersectPositionWS=vertexPos+origVec*distance;\n\nreturn intersectPositionWS-cubePos;\n}\nvec3 computeFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\n{\nfloat lon=atan(direction.z,direction.x);\nfloat lat=acos(direction.y);\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\nfloat s=sphereCoords.x*0.5+0.5;\nfloat t=sphereCoords.y;\nreturn vec3(s,t,0);\n}\nvec3 computeMirroredFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\n{\nfloat lon=atan(direction.z,direction.x);\nfloat lat=acos(direction.y);\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\nfloat s=sphereCoords.x*0.5+0.5;\nfloat t=sphereCoords.y;\nreturn vec3(1.0-s,t,0);\n}\nvec3 computeEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{\nvec3 cameraToVertex=normalize(worldPos.xyz-eyePosition);\nvec3 r=normalize(reflect(cameraToVertex,worldNormal));\nr=vec3(reflectionMatrix*vec4(r,0));\nfloat lon=atan(r.z,r.x);\nfloat lat=acos(r.y);\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\nfloat s=sphereCoords.x*0.5+0.5;\nfloat t=sphereCoords.y;\nreturn vec3(s,t,0);\n}\nvec3 computeSphericalCoords(vec4 worldPos,vec3 worldNormal,mat4 view,mat4 reflectionMatrix)\n{\nvec3 viewDir=normalize(vec3(view*worldPos));\nvec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));\nvec3 r=reflect(viewDir,viewNormal);\nr=vec3(reflectionMatrix*vec4(r,0));\nr.z=r.z-1.0;\nfloat m=2.0*length(r);\nreturn vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);\n}\nvec3 computePlanarCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{\nvec3 viewDir=worldPos.xyz-eyePosition;\nvec3 coords=normalize(reflect(viewDir,worldNormal));\nreturn vec3(reflectionMatrix*vec4(coords,1));\n}\nvec3 computeCubicCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{\nvec3 viewDir=normalize(worldPos.xyz-eyePosition);\n\nvec3 coords=reflect(viewDir,worldNormal);\ncoords=vec3(reflectionMatrix*vec4(coords,0));\n#ifdef INVERTCUBICMAP\ncoords.y*=-1.0;\n#endif\nreturn coords;\n}\nvec3 computeCubicLocalCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix,vec3 reflectionSize,vec3 reflectionPosition)\n{\nvec3 viewDir=normalize(worldPos.xyz-eyePosition);\n\nvec3 coords=reflect(viewDir,worldNormal);\ncoords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);\ncoords=vec3(reflectionMatrix*vec4(coords,0));\n#ifdef INVERTCUBICMAP\ncoords.y*=-1.0;\n#endif\nreturn coords;\n}\nvec3 computeProjectionCoords(vec4 worldPos,mat4 view,mat4 reflectionMatrix)\n{\nreturn vec3(reflectionMatrix*(view*worldPos));\n}\nvec3 computeSkyBoxCoords(vec3 positionW,mat4 reflectionMatrix)\n{\nreturn vec3(reflectionMatrix*vec4(positionW,1.));\n}\n#ifdef REFLECTION\nvec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)\n{\n#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\nvec3 direction=normalize(vDirectionW);\nreturn computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\nvec3 direction=normalize(vDirectionW);\nreturn computeFixedEquirectangularCoords(worldPos,worldNormal,direction);\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR\nreturn computeEquirectangularCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_SPHERICAL\nreturn computeSphericalCoords(worldPos,worldNormal,view,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_PLANAR\nreturn computePlanarCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_CUBIC\n#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC\nreturn computeCubicLocalCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix,vReflectionSize,vReflectionPosition);\n#else\nreturn computeCubicCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#endif\n#ifdef REFLECTIONMAP_PROJECTION\nreturn computeProjectionCoords(worldPos,view,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nreturn computeSkyBoxCoords(vPositionUVW,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_EXPLICIT\nreturn vec3(0,0,0);\n#endif\n}\n#endif";
Effect.IncludesShadersStore[name10] = shader10;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingDeclaration.js
var name11 = "imageProcessingDeclaration";
var shader11 = "#ifdef EXPOSURE\nuniform float exposureLinear;\n#endif\n#ifdef CONTRAST\nuniform float contrast;\n#endif\n#ifdef VIGNETTE\nuniform vec2 vInverseScreenSize;\nuniform vec4 vignetteSettings1;\nuniform vec4 vignetteSettings2;\n#endif\n#ifdef COLORCURVES\nuniform vec4 vCameraColorCurveNegative;\nuniform vec4 vCameraColorCurveNeutral;\nuniform vec4 vCameraColorCurvePositive;\n#endif\n#ifdef COLORGRADING\n#ifdef COLORGRADING3D\nuniform highp sampler3D txColorTransform;\n#else\nuniform sampler2D txColorTransform;\n#endif\nuniform vec4 colorTransformSettings;\n#endif";
Effect.IncludesShadersStore[name11] = shader11;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingFunctions.js
var name12 = "imageProcessingFunctions";
var shader12 = "#if defined(COLORGRADING) && !defined(COLORGRADING3D)\n\n#define inline\nvec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)\n{\nfloat sliceSize=2.0*sampler3dSetting.x;\n#ifdef SAMPLER3DGREENDEPTH\nfloat sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;\n#else\nfloat sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;\n#endif\nfloat sliceInteger=floor(sliceContinuous);\n\n\nfloat sliceFraction=sliceContinuous-sliceInteger;\n#ifdef SAMPLER3DGREENDEPTH\nvec2 sliceUV=color.rb;\n#else\nvec2 sliceUV=color.rg;\n#endif\nsliceUV.x*=sliceSize;\nsliceUV.x+=sliceInteger*sliceSize;\nsliceUV=saturate(sliceUV);\nvec4 slice0Color=texture2D(colorTransform,sliceUV);\nsliceUV.x+=sliceSize;\nsliceUV=saturate(sliceUV);\nvec4 slice1Color=texture2D(colorTransform,sliceUV);\nvec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);\n#ifdef SAMPLER3DBGRMAP\ncolor.rgb=result.rgb;\n#else\ncolor.rgb=result.bgr;\n#endif\nreturn color;\n}\n#endif\n#ifdef TONEMAPPING_ACES\n\n\n\n\n\nconst mat3 ACESInputMat=mat3(\nvec3(0.59719,0.07600,0.02840),\nvec3(0.35458,0.90834,0.13383),\nvec3(0.04823,0.01566,0.83777)\n);\n\nconst mat3 ACESOutputMat=mat3(\nvec3( 1.60475,-0.10208,-0.00327),\nvec3(-0.53108,1.10813,-0.07276),\nvec3(-0.07367,-0.00605,1.07602)\n);\nvec3 RRTAndODTFit(vec3 v)\n{\nvec3 a=v*(v+0.0245786)-0.000090537;\nvec3 b=v*(0.983729*v+0.4329510)+0.238081;\nreturn a/b;\n}\nvec3 ACESFitted(vec3 color)\n{\ncolor=ACESInputMat*color;\n\ncolor=RRTAndODTFit(color);\ncolor=ACESOutputMat*color;\n\ncolor=saturate(color);\nreturn color;\n}\n#endif\nvec4 applyImageProcessing(vec4 result) {\n#ifdef EXPOSURE\nresult.rgb*=exposureLinear;\n#endif\n#ifdef VIGNETTE\n\nvec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;\nviewportXY=viewportXY*2.0-1.0;\nvec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);\nfloat vignetteTerm=dot(vignetteXY1,vignetteXY1);\nfloat vignette=pow(vignetteTerm,vignetteSettings2.w);\n\nvec3 vignetteColor=vignetteSettings2.rgb;\n#ifdef VIGNETTEBLENDMODEMULTIPLY\nvec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);\nresult.rgb*=vignetteColorMultiplier;\n#endif\n#ifdef VIGNETTEBLENDMODEOPAQUE\nresult.rgb=mix(vignetteColor,result.rgb,vignette);\n#endif\n#endif\n#ifdef TONEMAPPING\n#ifdef TONEMAPPING_ACES\nresult.rgb=ACESFitted(result.rgb);\n#else\nconst float tonemappingCalibration=1.590579;\nresult.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);\n#endif\n#endif\n\nresult.rgb=toGammaSpace(result.rgb);\nresult.rgb=saturate(result.rgb);\n#ifdef CONTRAST\n\nvec3 resultHighContrast=result.rgb*result.rgb*(3.0-2.0*result.rgb);\nif (contrast<1.0) {\n\nresult.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);\n} else {\n\nresult.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);\n}\n#endif\n\n#ifdef COLORGRADING\nvec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;\n#ifdef COLORGRADING3D\nvec3 colorTransformOutput=texture(txColorTransform,colorTransformInput).rgb;\n#else\nvec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;\n#endif\nresult.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);\n#endif\n#ifdef COLORCURVES\n\nfloat luma=getLuminance(result.rgb);\nvec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));\nvec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;\nresult.rgb*=colorCurve.rgb;\nresult.rgb=mix(vec3(luma),result.rgb,colorCurve.a);\n#endif\nreturn result;\n}";
Effect.IncludesShadersStore[name12] = shader12;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentMainFunctions.js
var name13 = "bumpFragmentMainFunctions";
var shader13 = "#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)\n#if defined(TANGENT) && defined(NORMAL)\nvarying mat3 vTBN;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nuniform mat4 normalMatrix;\n#endif\nvec3 perturbNormalBase(mat3 cotangentFrame,vec3 normal,float scale)\n{\n#ifdef NORMALXYSCALE\nnormal=normalize(normal*vec3(scale,scale,1.0));\n#endif\nreturn normalize(cotangentFrame*normal);\n}\nvec3 perturbNormal(mat3 cotangentFrame,vec3 textureSample,float scale)\n{\nreturn perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);\n}\n\nmat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv,vec2 tangentSpaceParams)\n{\n\nuv=gl_FrontFacing ? uv : -uv;\n\nvec3 dp1=dFdx(p);\nvec3 dp2=dFdy(p);\nvec2 duv1=dFdx(uv);\nvec2 duv2=dFdy(uv);\n\nvec3 dp2perp=cross(dp2,normal);\nvec3 dp1perp=cross(normal,dp1);\nvec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;\nvec3 bitangent=dp2perp*duv1.y+dp1perp*duv2.y;\n\ntangent*=tangentSpaceParams.x;\nbitangent*=tangentSpaceParams.y;\n\nfloat invmax=inversesqrt(max(dot(tangent,tangent),dot(bitangent,bitangent)));\nreturn mat3(tangent*invmax,bitangent*invmax,normal);\n}\n#endif\n";
Effect.IncludesShadersStore[name13] = shader13;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentFunctions.js
var name14 = "bumpFragmentFunctions";
var shader14 = "#if defined(BUMP)\n#if BUMPDIRECTUV == 1\n#define vBumpUV vMainUV1\n#elif BUMPDIRECTUV == 2\n#define vBumpUV vMainUV2\n#else\nvarying vec2 vBumpUV;\n#endif\nuniform sampler2D bumpSampler;\nvec3 perturbNormal(mat3 cotangentFrame,vec2 uv)\n{\nreturn perturbNormal(cotangentFrame,texture2D(bumpSampler,uv).xyz,vBumpInfos.y);\n}\n#endif\n#if defined(DETAIL)\n#if DETAILDIRECTUV == 1\n#define vDetailUV vMainUV1\n#elif DETAILDIRECTUV == 2\n#define vDetailUV vMainUV2\n#else\nvarying vec2 vDetailUV;\n#endif\nuniform sampler2D detailSampler;\n#endif\n#if defined(BUMP)\nvec3 perturbNormal(mat3 cotangentFrame,vec3 color)\n{\nreturn perturbNormal(cotangentFrame,color,vBumpInfos.y);\n}\n\nmat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv)\n{\nreturn cotangent_frame(normal,p,uv,vTangentSpaceParams);\n}\n#endif\n#if defined(BUMP) && defined(PARALLAX)\nconst float minSamples=4.;\nconst float maxSamples=15.;\nconst int iMaxSamples=15;\n\nvec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {\nfloat parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;\nparallaxLimit*=parallaxScale;\nvec2 vOffsetDir=normalize(vViewDirCoT.xy);\nvec2 vMaxOffset=vOffsetDir*parallaxLimit;\nfloat numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));\nfloat stepSize=1.0/numSamples;\n\nfloat currRayHeight=1.0;\nvec2 vCurrOffset=vec2(0,0);\nvec2 vLastOffset=vec2(0,0);\nfloat lastSampledHeight=1.0;\nfloat currSampledHeight=1.0;\nfor (int i=0; i<iMaxSamples; i++)\n{\ncurrSampledHeight=texture2D(bumpSampler,vBumpUV+vCurrOffset).w;\n\nif (currSampledHeight>currRayHeight)\n{\nfloat delta1=currSampledHeight-currRayHeight;\nfloat delta2=(currRayHeight+stepSize)-lastSampledHeight;\nfloat ratio=delta1/(delta1+delta2);\nvCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;\n\nbreak;\n}\nelse\n{\ncurrRayHeight-=stepSize;\nvLastOffset=vCurrOffset;\nvCurrOffset+=stepSize*vMaxOffset;\nlastSampledHeight=currSampledHeight;\n}\n}\nreturn vCurrOffset;\n}\nvec2 parallaxOffset(vec3 viewDir,float heightScale)\n{\n\nfloat height=texture2D(bumpSampler,vBumpUV).w;\nvec2 texCoordOffset=heightScale*viewDir.xy*height;\nreturn -texCoordOffset;\n}\n#endif";
Effect.IncludesShadersStore[name14] = shader14;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration.js
var name15 = "clipPlaneFragmentDeclaration";
var shader15 = "#ifdef CLIPPLANE\nvarying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nvarying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nvarying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nvarying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nvarying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nvarying float fClipDistance6;\n#endif";
Effect.IncludesShadersStore[name15] = shader15;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthDeclaration.js
var name16 = "logDepthDeclaration";
var shader16 = "#ifdef LOGARITHMICDEPTH\nuniform float logarithmicDepthConstant;\nvarying float vFragmentDepth;\n#endif";
Effect.IncludesShadersStore[name16] = shader16;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration.js
var name17 = "fogFragmentDeclaration";
var shader17 = "#ifdef FOG\n#define FOGMODE_NONE 0.\n#define FOGMODE_EXP 1.\n#define FOGMODE_EXP2 2.\n#define FOGMODE_LINEAR 3.\n#define E 2.71828\nuniform vec4 vFogInfos;\nuniform vec3 vFogColor;\nvarying vec3 vFogDistance;\nfloat CalcFogFactor()\n{\nfloat fogCoeff=1.0;\nfloat fogStart=vFogInfos.y;\nfloat fogEnd=vFogInfos.z;\nfloat fogDensity=vFogInfos.w;\nfloat fogDistance=length(vFogDistance);\nif (FOGMODE_LINEAR == vFogInfos.x)\n{\nfogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);\n}\nelse if (FOGMODE_EXP == vFogInfos.x)\n{\nfogCoeff=1.0/pow(E,fogDistance*fogDensity);\n}\nelse if (FOGMODE_EXP2 == vFogInfos.x)\n{\nfogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);\n}\nreturn clamp(fogCoeff,0.0,1.0);\n}\n#endif";
Effect.IncludesShadersStore[name17] = shader17;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment.js
var name18 = "clipPlaneFragment";
var shader18 = "#ifdef CLIPPLANE\nif (fClipDistance>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE2\nif (fClipDistance2>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE3\nif (fClipDistance3>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE4\nif (fClipDistance4>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE5\nif (fClipDistance5>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE6\nif (fClipDistance6>0.0)\n{\ndiscard;\n}\n#endif";
Effect.IncludesShadersStore[name18] = shader18;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragment.js
var name19 = "bumpFragment";
var shader19 = "vec2 uvOffset=vec2(0.0,0.0);\n#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)\n#ifdef NORMALXYSCALE\nfloat normalScale=1.0;\n#elif defined(BUMP)\nfloat normalScale=vBumpInfos.y;\n#else\nfloat normalScale=1.0;\n#endif\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBN=vTBN;\n#elif defined(BUMP)\nmat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,vBumpUV);\n#else\nmat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,vDetailUV,vec2(1.,1.));\n#endif\n#elif defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBN=vTBN;\n#else\nmat3 TBN=cotangent_frame(normalW,vPositionW,vMainUV1,vec2(1.,1.));\n#endif\n#endif\n#ifdef PARALLAX\nmat3 invTBN=transposeMat3(TBN);\n#ifdef PARALLAXOCCLUSION\nuvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);\n#else\nuvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);\n#endif\n#endif\n#ifdef DETAIL\nvec4 detailColor=texture2D(detailSampler,vDetailUV+uvOffset);\nvec2 detailNormalRG=detailColor.wy*2.0-1.0;\nfloat detailNormalB=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));\nvec3 detailNormal=vec3(detailNormalRG,detailNormalB);\n#endif\n#ifdef BUMP\n#ifdef OBJECTSPACE_NORMALMAP\nnormalW=normalize(texture2D(bumpSampler,vBumpUV).xyz*2.0-1.0);\nnormalW=normalize(mat3(normalMatrix)*normalW);\n#elif !defined(DETAIL)\nnormalW=perturbNormal(TBN,vBumpUV+uvOffset);\n#else\nvec3 bumpNormal=texture2D(bumpSampler,vBumpUV+uvOffset).xyz*2.0-1.0;\n\n#if DETAIL_NORMALBLENDMETHOD == 0\ndetailNormal.xy*=vDetailInfos.z;\nvec3 blendedNormal=normalize(vec3(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));\n#elif DETAIL_NORMALBLENDMETHOD == 1\ndetailNormal.xy*=vDetailInfos.z;\nbumpNormal+=vec3(0.0,0.0,1.0);\ndetailNormal*=vec3(-1.0,-1.0,1.0);\nvec3 blendedNormal=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;\n#endif\nnormalW=perturbNormalBase(TBN,blendedNormal,vBumpInfos.y);\n#endif\n#elif defined(DETAIL)\ndetailNormal.xy*=vDetailInfos.z;\nnormalW=perturbNormalBase(TBN,detailNormal,vDetailInfos.z);\n#endif";
Effect.IncludesShadersStore[name19] = shader19;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/depthPrePass.js
var name20 = "depthPrePass";
var shader20 = "#ifdef DEPTHPREPASS\ngl_FragColor=vec4(0.,0.,0.,1.0);\nreturn;\n#endif";
Effect.IncludesShadersStore[name20] = shader20;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragment.js
var name21 = "lightFragment";
var shader21 = "#ifdef LIGHT{X}\n#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\n\n#else\n#ifdef PBR\n\n#ifdef SPOTLIGHT{X}\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(POINTLIGHT{X})\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(HEMILIGHT{X})\npreInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(DIRLIGHT{X})\npreInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#endif\npreInfo.NdotV=NdotV;\n\n#ifdef SPOTLIGHT{X}\n#ifdef LIGHT_FALLOFF_GLTF{X}\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\npreInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\npreInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\npreInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);\n#else\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\npreInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\n#endif\n#elif defined(POINTLIGHT{X})\n#ifdef LIGHT_FALLOFF_GLTF{X}\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\n#else\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\n#endif\n#else\npreInfo.attenuation=1.0;\n#endif\n\n\n#ifdef HEMILIGHT{X}\npreInfo.roughness=roughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\n\n#ifdef HEMILIGHT{X}\ninfo.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);\n#elif defined(SS_TRANSLUCENCY)\ninfo.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);\n#else\ninfo.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);\n#endif\n\n#ifdef SPECULARTERM\n#ifdef ANISOTROPIC\ninfo.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#else\ninfo.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#endif\n#endif\n\n#ifdef SHEEN\n#ifdef SHEEN_LINKWITHALBEDO\n\npreInfo.roughness=sheenOut.sheenIntensity;\n#else\n#ifdef HEMILIGHT{X}\npreInfo.roughness=sheenOut.sheenRoughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\n#endif\ninfo.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#endif\n\n#ifdef CLEARCOAT\n\n#ifdef HEMILIGHT{X}\npreInfo.roughness=clearcoatOut.clearCoatRoughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\ninfo.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);\n#ifdef CLEARCOAT_TINT\n\nabsorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);\ninfo.diffuse*=absorption;\n#ifdef SPECULARTERM\ninfo.specular*=absorption;\n#endif\n#endif\n\ninfo.diffuse*=info.clearCoat.w;\n#ifdef SPECULARTERM\ninfo.specular*=info.clearCoat.w;\n#endif\n#ifdef SHEEN\ninfo.sheen*=info.clearCoat.w;\n#endif\n#endif\n#else\n#ifdef SPOTLIGHT{X}\ninfo=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\n#elif defined(HEMILIGHT{X})\ninfo=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);\n#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\ninfo=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\n#endif\n#endif\n#ifdef PROJECTEDLIGHTTEXTURE{X}\ninfo.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightSampler{X},textureProjectionMatrix{X});\n#endif\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nfor (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++)\n{\n#ifdef SHADOWCSM_RIGHTHANDED{X}\ndiff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;\n#else\ndiff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;\n#endif\nif (diff{X}>=0.) {\nindex{X}=i;\nbreak;\n}\n}\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nif (index{X}>=0)\n#endif\n{\n#if defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#else\nshadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#endif\n#else\nshadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nshadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];\n#endif\n#ifndef SHADOWCSMNOBLEND{X}\nfloat frustumLength=frustumLengths{X}[index{X}];\nfloat diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};\nif (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)\n{\nindex{X}+=1;\nfloat nextShadow=0.;\n#if defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nnextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nnextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nnextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nnextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#elif defined(SHADOWMEDIUMQUALITY{X})\nnextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#else\nnextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#endif\n#else\nnextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\nshadow=mix(nextShadow,shadow,diffRatio);\n#ifdef SHADOWCSMDEBUG{X}\nshadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);\n#endif\n}\n#endif\n}\n#elif defined(SHADOWCLOSEESM{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithCloseESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\n#else\nshadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWESM{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\n#else\nshadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPOISSON{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithPoissonSamplingCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);\n#else\nshadow=computeShadowWithPoissonSampling(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithPCF1(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithPCF3(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithPCF5(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithPCSS16(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithPCSS32(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithPCSS64(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#else\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.depthValues);\n#else\nshadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#endif\n#ifdef SHADOWONLY\n#ifndef SHADOWINUSE\n#define SHADOWINUSE\n#endif\nglobalShadow+=shadow;\nshadowLightCount+=1.0;\n#endif\n#else\nshadow=1.;\n#endif\n#ifndef SHADOWONLY\n#ifdef CUSTOMUSERLIGHTING\ndiffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);\n#ifdef SPECULARTERM\nspecularBase+=computeCustomSpecularLighting(info,specularBase,shadow);\n#endif\n#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\ndiffuseBase+=lightmapColor.rgb*shadow;\n#ifdef SPECULARTERM\n#ifndef LIGHTMAPNOSPECULAR{X}\nspecularBase+=info.specular*shadow*lightmapColor.rgb;\n#endif\n#endif\n#ifdef CLEARCOAT\n#ifndef LIGHTMAPNOSPECULAR{X}\nclearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;\n#endif\n#endif\n#ifdef SHEEN\n#ifndef LIGHTMAPNOSPECULAR{X}\nsheenBase+=info.sheen.rgb*shadow;\n#endif\n#endif\n#else\n#ifdef SHADOWCSMDEBUG{X}\ndiffuseBase+=info.diffuse*shadowDebug{X};\n#else\ndiffuseBase+=info.diffuse*shadow;\n#endif\n#ifdef SPECULARTERM\nspecularBase+=info.specular*shadow;\n#endif\n#ifdef CLEARCOAT\nclearCoatBase+=info.clearCoat.rgb*shadow;\n#endif\n#ifdef SHEEN\nsheenBase+=info.sheen.rgb*shadow;\n#endif\n#endif\n#endif\n#endif";
Effect.IncludesShadersStore[name21] = shader21;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthFragment.js
var name22 = "logDepthFragment";
var shader22 = "#ifdef LOGARITHMICDEPTH\ngl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;\n#endif";
Effect.IncludesShadersStore[name22] = shader22;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/fogFragment.js
var name23 = "fogFragment";
var shader23 = "#ifdef FOG\nfloat fog=CalcFogFactor();\ncolor.rgb=fog*color.rgb+(1.0-fog)*vFogColor;\n#endif";
Effect.IncludesShadersStore[name23] = shader23;

// node_modules/@babylonjs/core/Shaders/default.fragment.js
var name24 = "defaultPixelShader";
var shader24 = "#include<__decl__defaultFragment>\n#if defined(BUMP) || !defined(NORMAL)\n#extension GL_OES_standard_derivatives : enable\n#endif\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\n#define CUSTOM_FRAGMENT_BEGIN\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n\n#define RECIPROCAL_PI2 0.15915494\nuniform vec3 vEyePosition;\nuniform vec3 vAmbientColor;\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#ifdef MAINUV1\nvarying vec2 vMainUV1;\n#endif\n#ifdef MAINUV2\nvarying vec2 vMainUV2;\n#endif\n\n#include<helperFunctions>\n\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n\n#ifdef DIFFUSE\n#if DIFFUSEDIRECTUV == 1\n#define vDiffuseUV vMainUV1\n#elif DIFFUSEDIRECTUV == 2\n#define vDiffuseUV vMainUV2\n#else\nvarying vec2 vDiffuseUV;\n#endif\nuniform sampler2D diffuseSampler;\n#endif\n#ifdef AMBIENT\n#if AMBIENTDIRECTUV == 1\n#define vAmbientUV vMainUV1\n#elif AMBIENTDIRECTUV == 2\n#define vAmbientUV vMainUV2\n#else\nvarying vec2 vAmbientUV;\n#endif\nuniform sampler2D ambientSampler;\n#endif\n#ifdef OPACITY\n#if OPACITYDIRECTUV == 1\n#define vOpacityUV vMainUV1\n#elif OPACITYDIRECTUV == 2\n#define vOpacityUV vMainUV2\n#else\nvarying vec2 vOpacityUV;\n#endif\nuniform sampler2D opacitySampler;\n#endif\n#ifdef EMISSIVE\n#if EMISSIVEDIRECTUV == 1\n#define vEmissiveUV vMainUV1\n#elif EMISSIVEDIRECTUV == 2\n#define vEmissiveUV vMainUV2\n#else\nvarying vec2 vEmissiveUV;\n#endif\nuniform sampler2D emissiveSampler;\n#endif\n#ifdef LIGHTMAP\n#if LIGHTMAPDIRECTUV == 1\n#define vLightmapUV vMainUV1\n#elif LIGHTMAPDIRECTUV == 2\n#define vLightmapUV vMainUV2\n#else\nvarying vec2 vLightmapUV;\n#endif\nuniform sampler2D lightmapSampler;\n#endif\n#ifdef REFRACTION\n#ifdef REFRACTIONMAP_3D\nuniform samplerCube refractionCubeSampler;\n#else\nuniform sampler2D refraction2DSampler;\n#endif\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM)\n#if SPECULARDIRECTUV == 1\n#define vSpecularUV vMainUV1\n#elif SPECULARDIRECTUV == 2\n#define vSpecularUV vMainUV2\n#else\nvarying vec2 vSpecularUV;\n#endif\nuniform sampler2D specularSampler;\n#endif\n#ifdef ALPHATEST\nuniform float alphaCutOff;\n#endif\n\n#include<fresnelFunction>\n\n#ifdef REFLECTION\n#ifdef REFLECTIONMAP_3D\nuniform samplerCube reflectionCubeSampler;\n#else\nuniform sampler2D reflection2DSampler;\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#else\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#endif\n#include<reflectionFunction>\n#endif\n#include<imageProcessingDeclaration>\n#include<imageProcessingFunctions>\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition-vPositionW);\n\nvec4 baseColor=vec4(1.,1.,1.,1.);\nvec3 diffuseColor=vDiffuseColor.rgb;\n\nfloat alpha=vDiffuseColor.a;\n\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=normalize(-cross(dFdx(vPositionW),dFdy(vPositionW)));\n#endif\n#include<bumpFragment>\n#ifdef TWOSIDEDLIGHTING\nnormalW=gl_FrontFacing ? normalW : -normalW;\n#endif\n#ifdef DIFFUSE\nbaseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);\n#if defined(ALPHATEST) && !defined(ALPHATEST_AFTERALLALPHACOMPUTATIONS)\nif (baseColor.a<alphaCutOff)\ndiscard;\n#endif\n#ifdef ALPHAFROMDIFFUSE\nalpha*=baseColor.a;\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_ALPHA\nbaseColor.rgb*=vDiffuseInfos.y;\n#endif\n#include<depthPrePass>\n#ifdef VERTEXCOLOR\nbaseColor.rgb*=vColor.rgb;\n#endif\n#ifdef DETAIL\nbaseColor.rgb=baseColor.rgb*2.0*mix(0.5,detailColor.r,vDetailInfos.y);\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE\n\nvec3 baseAmbientColor=vec3(1.,1.,1.);\n#ifdef AMBIENT\nbaseAmbientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\n\n#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;\nvec3 specularColor=vSpecularColor.rgb;\n#ifdef SPECULAR\nvec4 specularMapColor=texture2D(specularSampler,vSpecularUV+uvOffset);\nspecularColor=specularMapColor.rgb;\n#ifdef GLOSSINESS\nglossiness=glossiness*specularMapColor.a;\n#endif\n#endif\n#else\nfloat glossiness=0.;\n#endif\n\nvec3 diffuseBase=vec3(0.,0.,0.);\nlightingInfo info;\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif\nfloat shadow=1.;\n#ifdef LIGHTMAP\nvec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);\n#ifdef RGBDLIGHTMAP\nlightmapColor.rgb=fromRGBD(lightmapColor);\n#endif\nlightmapColor.rgb*=vLightmapInfos.y;\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\n\nvec4 refractionColor=vec4(0.,0.,0.,1.);\n#ifdef REFRACTION\nvec3 refractionVector=normalize(refract(-viewDirectionW,normalW,vRefractionInfos.y));\n#ifdef REFRACTIONMAP_3D\nrefractionVector.y=refractionVector.y*vRefractionInfos.w;\nif (dot(refractionVector,viewDirectionW)<1.0) {\nrefractionColor=textureCube(refractionCubeSampler,refractionVector);\n}\n#else\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));\nvec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;\nrefractionCoords.y=1.0-refractionCoords.y;\nrefractionColor=texture2D(refraction2DSampler,refractionCoords);\n#endif\n#ifdef RGBDREFRACTION\nrefractionColor.rgb=fromRGBD(refractionColor);\n#endif\n#ifdef IS_REFRACTION_LINEAR\nrefractionColor.rgb=toGammaSpace(refractionColor.rgb);\n#endif\nrefractionColor.rgb*=vRefractionInfos.x;\n#endif\n\nvec4 reflectionColor=vec4(0.,0.,0.,1.);\n#ifdef REFLECTION\nvec3 vReflectionUVW=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\n#ifdef REFLECTIONMAP_3D\n#ifdef ROUGHNESS\nfloat bias=vReflectionInfos.y;\n#ifdef SPECULARTERM\n#ifdef SPECULAR\n#ifdef GLOSSINESS\nbias*=(1.0-specularMapColor.a);\n#endif\n#endif\n#endif\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW,bias);\n#else\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW);\n#endif\n#else\nvec2 coords=vReflectionUVW.xy;\n#ifdef REFLECTIONMAP_PROJECTION\ncoords/=vReflectionUVW.z;\n#endif\ncoords.y=1.0-coords.y;\nreflectionColor=texture2D(reflection2DSampler,coords);\n#endif\n#ifdef RGBDREFLECTION\nreflectionColor.rgb=fromRGBD(reflectionColor);\n#endif\n#ifdef IS_REFLECTION_LINEAR\nreflectionColor.rgb=toGammaSpace(reflectionColor.rgb);\n#endif\nreflectionColor.rgb*=vReflectionInfos.x;\n#ifdef REFLECTIONFRESNEL\nfloat reflectionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,reflectionRightColor.a,reflectionLeftColor.a);\n#ifdef REFLECTIONFRESNELFROMSPECULAR\n#ifdef SPECULARTERM\nreflectionColor.rgb*=specularColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#else\nreflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#endif\n#else\nreflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#endif\n#endif\n#endif\n#ifdef REFRACTIONFRESNEL\nfloat refractionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,refractionRightColor.a,refractionLeftColor.a);\nrefractionColor.rgb*=refractionLeftColor.rgb*(1.0-refractionFresnelTerm)+refractionFresnelTerm*refractionRightColor.rgb;\n#endif\n#ifdef OPACITY\nvec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);\n#ifdef OPACITYRGB\nopacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);\nalpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* vOpacityInfos.y;\n#else\nalpha*=opacityMap.a*vOpacityInfos.y;\n#endif\n#endif\n#ifdef VERTEXALPHA\nalpha*=vColor.a;\n#endif\n#ifdef OPACITYFRESNEL\nfloat opacityFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,opacityParts.z,opacityParts.w);\nalpha+=opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*opacityParts.y;\n#endif\n#ifdef ALPHATEST\n#ifdef ALPHATEST_AFTERALLALPHACOMPUTATIONS\nif (alpha<alphaCutOff)\ndiscard;\n#endif\n#ifndef ALPHABLEND\n\nalpha=1.0;\n#endif\n#endif\n\nvec3 emissiveColor=vEmissiveColor;\n#ifdef EMISSIVE\nemissiveColor+=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb*vEmissiveInfos.y;\n#endif\n#ifdef EMISSIVEFRESNEL\nfloat emissiveFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,emissiveRightColor.a,emissiveLeftColor.a);\nemissiveColor*=emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*emissiveRightColor.rgb;\n#endif\n\n#ifdef DIFFUSEFRESNEL\nfloat diffuseFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,diffuseRightColor.a,diffuseLeftColor.a);\ndiffuseBase*=diffuseLeftColor.rgb*(1.0-diffuseFresnelTerm)+diffuseFresnelTerm*diffuseRightColor.rgb;\n#endif\n\n#ifdef EMISSIVEASILLUMINATION\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#else\n#ifdef LINKEMISSIVEWITHDIFFUSE\nvec3 finalDiffuse=clamp((diffuseBase+emissiveColor)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#else\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+emissiveColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#endif\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\n#ifdef SPECULAROVERALPHA\nalpha=clamp(alpha+dot(finalSpecular,vec3(0.3,0.59,0.11)),0.,1.);\n#endif\n#else\nvec3 finalSpecular=vec3(0.0);\n#endif\n#ifdef REFLECTIONOVERALPHA\nalpha=clamp(alpha+dot(reflectionColor.rgb,vec3(0.3,0.59,0.11)),0.,1.);\n#endif\n\n#ifdef EMISSIVEASILLUMINATION\nvec4 color=vec4(clamp(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+emissiveColor+refractionColor.rgb,0.0,1.0),alpha);\n#else\nvec4 color=vec4(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+refractionColor.rgb,alpha);\n#endif\n\n#ifdef LIGHTMAP\n#ifndef LIGHTMAPEXCLUDED\n#ifdef USELIGHTMAPASSHADOWMAP\ncolor.rgb*=lightmapColor.rgb;\n#else\ncolor.rgb+=lightmapColor.rgb;\n#endif\n#endif\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_FOG\ncolor.rgb=max(color.rgb,0.);\n#include<logDepthFragment>\n#include<fogFragment>\n\n\n#ifdef IMAGEPROCESSINGPOSTPROCESS\ncolor.rgb=toLinearSpace(color.rgb);\n#else\n#ifdef IMAGEPROCESSING\ncolor.rgb=toLinearSpace(color.rgb);\ncolor=applyImageProcessing(color);\n#endif\n#endif\ncolor.a*=visibility;\n#ifdef PREMULTIPLYALPHA\n\ncolor.rgb*=color.a;\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\n#ifdef PREPASS\ngl_FragData[0]=color;\n#ifdef PREPASS_POSITION\ngl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,1.0);\n#endif\n#ifdef PREPASS_VELOCITY\nvec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;\nvec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;\nvec2 velocity=abs(a-b);\nvelocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;\ngl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,1.0);\n#endif\n#ifdef PREPASS_IRRADIANCE\ngl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(0.0,0.0,0.0,1.0);\n#endif\n#ifdef PREPASS_DEPTHNORMAL\ngl_FragData[PREPASS_DEPTHNORMAL_INDEX]=vec4(vViewPos.z,(view*vec4(normalW,0.0)).rgb);\n#endif\n#ifdef PREPASS_ALBEDO\ngl_FragData[PREPASS_ALBEDO_INDEX]=vec4(0.0,0.0,0.0,1.0);\n#endif\n#ifdef PREPASS_REFLECTIVITY\n#if defined(SPECULAR)\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=specularMapColor;\n#else\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(0.0,0.0,0.0,1.0);\n#endif\n#endif\n#endif\n#if !defined(PREPASS) || defined(WEBGL2)\ngl_FragColor=color;\n#endif\n}\n";
Effect.ShadersStore[name24] = shader24;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultVertexDeclaration.js
var name25 = "defaultVertexDeclaration";
var shader25 = "\nuniform mat4 viewProjection;\nuniform mat4 view;\n#ifdef DIFFUSE\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef AMBIENT\nuniform mat4 ambientMatrix;\nuniform vec2 vAmbientInfos;\n#endif\n#ifdef OPACITY\nuniform mat4 opacityMatrix;\nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\nuniform mat4 emissiveMatrix;\n#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;\nuniform mat4 lightmapMatrix;\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM)\nuniform vec2 vSpecularInfos;\nuniform mat4 specularMatrix;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform mat4 bumpMatrix;\n#endif\n#ifdef REFLECTION\nuniform mat4 reflectionMatrix;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n";
Effect.IncludesShadersStore[name25] = shader25;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration.js
var name26 = "bonesDeclaration";
var shader26 = "#if NUM_BONE_INFLUENCERS>0\n#ifdef BONETEXTURE\nuniform sampler2D boneSampler;\nuniform float boneTextureWidth;\n#else\nuniform mat4 mBones[BonesPerMesh];\n#ifdef BONES_VELOCITY_ENABLED\nuniform mat4 mPreviousBones[BonesPerMesh];\n#endif\n#endif\nattribute vec4 matricesIndices;\nattribute vec4 matricesWeights;\n#if NUM_BONE_INFLUENCERS>4\nattribute vec4 matricesIndicesExtra;\nattribute vec4 matricesWeightsExtra;\n#endif\n#ifdef BONETEXTURE\n#define inline\nmat4 readMatrixFromRawSampler(sampler2D smp,float index)\n{\nfloat offset=index*4.0;\nfloat dx=1.0/boneTextureWidth;\nvec4 m0=texture2D(smp,vec2(dx*(offset+0.5),0.));\nvec4 m1=texture2D(smp,vec2(dx*(offset+1.5),0.));\nvec4 m2=texture2D(smp,vec2(dx*(offset+2.5),0.));\nvec4 m3=texture2D(smp,vec2(dx*(offset+3.5),0.));\nreturn mat4(m0,m1,m2,m3);\n}\n#endif\n#endif";
Effect.IncludesShadersStore[name26] = shader26;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration.js
var name27 = "instancesDeclaration";
var shader27 = "#ifdef INSTANCES\nattribute vec4 world0;\nattribute vec4 world1;\nattribute vec4 world2;\nattribute vec4 world3;\n#ifdef THIN_INSTANCES\nuniform mat4 world;\n#endif\n#else\nuniform mat4 world;\n#endif";
Effect.IncludesShadersStore[name27] = shader27;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassVertexDeclaration.js
var name28 = "prePassVertexDeclaration";
var shader28 = "#ifdef PREPASS\n#ifdef PREPASS_DEPTHNORMAL\nvarying vec3 vViewPos;\n#endif\n#ifdef PREPASS_VELOCITY\nuniform mat4 previousWorld;\nuniform mat4 previousViewProjection;\nvarying vec4 vCurrentPosition;\nvarying vec4 vPreviousPosition;\n#endif\n#endif";
Effect.IncludesShadersStore[name28] = shader28;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpVertexDeclaration.js
var name29 = "bumpVertexDeclaration";
var shader29 = "#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL)\nvarying mat3 vTBN;\n#endif\n#endif\n";
Effect.IncludesShadersStore[name29] = shader29;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration.js
var name30 = "clipPlaneVertexDeclaration";
var shader30 = "#ifdef CLIPPLANE\nuniform vec4 vClipPlane;\nvarying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nuniform vec4 vClipPlane2;\nvarying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nuniform vec4 vClipPlane3;\nvarying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nuniform vec4 vClipPlane4;\nvarying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nuniform vec4 vClipPlane5;\nvarying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nuniform vec4 vClipPlane6;\nvarying float fClipDistance6;\n#endif";
Effect.IncludesShadersStore[name30] = shader30;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration.js
var name31 = "fogVertexDeclaration";
var shader31 = "#ifdef FOG\nvarying vec3 vFogDistance;\n#endif";
Effect.IncludesShadersStore[name31] = shader31;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexGlobalDeclaration.js
var name32 = "morphTargetsVertexGlobalDeclaration";
var shader32 = "#ifdef MORPHTARGETS\nuniform float morphTargetInfluences[NUM_MORPH_INFLUENCERS];\n#endif";
Effect.IncludesShadersStore[name32] = shader32;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexDeclaration.js
var name33 = "morphTargetsVertexDeclaration";
var shader33 = "#ifdef MORPHTARGETS\nattribute vec3 position{X};\n#ifdef MORPHTARGETS_NORMAL\nattribute vec3 normal{X};\n#endif\n#ifdef MORPHTARGETS_TANGENT\nattribute vec3 tangent{X};\n#endif\n#ifdef MORPHTARGETS_UV\nattribute vec2 uv_{X};\n#endif\n#endif";
Effect.IncludesShadersStore[name33] = shader33;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertex.js
var name34 = "morphTargetsVertex";
var shader34 = "#ifdef MORPHTARGETS\npositionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];\n#ifdef MORPHTARGETS_NORMAL\nnormalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];\n#endif\n#ifdef MORPHTARGETS_TANGENT\ntangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];\n#endif\n#ifdef MORPHTARGETS_UV\nuvUpdated+=(uv_{X}-uv)*morphTargetInfluences[{X}];\n#endif\n#endif";
Effect.IncludesShadersStore[name34] = shader34;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesVertex.js
var name35 = "instancesVertex";
var shader35 = "#ifdef INSTANCES\nmat4 finalWorld=mat4(world0,world1,world2,world3);\n#ifdef THIN_INSTANCES\nfinalWorld=world*finalWorld;\n#endif\n#else\nmat4 finalWorld=world;\n#endif";
Effect.IncludesShadersStore[name35] = shader35;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesVertex.js
var name36 = "bonesVertex";
var shader36 = "#if NUM_BONE_INFLUENCERS>0\nmat4 influence;\n#ifdef BONETEXTURE\ninfluence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];\n#endif\n#else\ninfluence=mBones[int(matricesIndices[0])]*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence+=mBones[int(matricesIndices[1])]*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\ninfluence+=mBones[int(matricesIndices[2])]*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\ninfluence+=mBones[int(matricesIndices[3])]*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\ninfluence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\ninfluence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\ninfluence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\ninfluence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\n#endif\n#endif\nfinalWorld=finalWorld*influence;\n#endif";
Effect.IncludesShadersStore[name36] = shader36;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassVertex.js
var name37 = "prePassVertex";
var shader37 = "#ifdef PREPASS_DEPTHNORMAL\nvViewPos=(view*worldPos).rgb;\n#endif\n#if defined(PREPASS_VELOCITY) && defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*worldPos;\n#if NUM_BONE_INFLUENCERS>0\nmat4 previousInfluence;\npreviousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\npreviousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\npreviousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\npreviousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\n#endif\nvPreviousPosition=previousViewProjection*previousWorld*previousInfluence*vec4(positionUpdated,1.0);\n#else\nvPreviousPosition=previousViewProjection*previousWorld*vec4(positionUpdated,1.0);\n#endif\n#endif";
Effect.IncludesShadersStore[name37] = shader37;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpVertex.js
var name38 = "bumpVertex";
var shader38 = "#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL)\nvec3 tbnNormal=normalize(normalUpdated);\nvec3 tbnTangent=normalize(tangentUpdated.xyz);\nvec3 tbnBitangent=cross(tbnNormal,tbnTangent)*tangentUpdated.w;\nvTBN=mat3(finalWorld)*mat3(tbnTangent,tbnBitangent,tbnNormal);\n#endif\n#endif";
Effect.IncludesShadersStore[name38] = shader38;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertex.js
var name39 = "clipPlaneVertex";
var shader39 = "#ifdef CLIPPLANE\nfClipDistance=dot(worldPos,vClipPlane);\n#endif\n#ifdef CLIPPLANE2\nfClipDistance2=dot(worldPos,vClipPlane2);\n#endif\n#ifdef CLIPPLANE3\nfClipDistance3=dot(worldPos,vClipPlane3);\n#endif\n#ifdef CLIPPLANE4\nfClipDistance4=dot(worldPos,vClipPlane4);\n#endif\n#ifdef CLIPPLANE5\nfClipDistance5=dot(worldPos,vClipPlane5);\n#endif\n#ifdef CLIPPLANE6\nfClipDistance6=dot(worldPos,vClipPlane6);\n#endif";
Effect.IncludesShadersStore[name39] = shader39;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/fogVertex.js
var name40 = "fogVertex";
var shader40 = "#ifdef FOG\nvFogDistance=(view*worldPos).xyz;\n#endif";
Effect.IncludesShadersStore[name40] = shader40;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsVertex.js
var name41 = "shadowsVertex";
var shader41 = "#ifdef SHADOWS\n#if defined(SHADOWCSM{X})\nvPositionFromCamera{X}=view*worldPos;\nfor (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) {\nvPositionFromLight{X}[i]=lightMatrix{X}[i]*worldPos;\nvDepthMetric{X}[i]=((vPositionFromLight{X}[i].z+light{X}.depthValues.x)/(light{X}.depthValues.y));\n}\n#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})\nvPositionFromLight{X}=lightMatrix{X}*worldPos;\nvDepthMetric{X}=((vPositionFromLight{X}.z+light{X}.depthValues.x)/(light{X}.depthValues.y));\n#endif\n#endif";
Effect.IncludesShadersStore[name41] = shader41;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pointCloudVertex.js
var name42 = "pointCloudVertex";
var shader42 = "#ifdef POINTSIZE\ngl_PointSize=pointSize;\n#endif";
Effect.IncludesShadersStore[name42] = shader42;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthVertex.js
var name43 = "logDepthVertex";
var shader43 = "#ifdef LOGARITHMICDEPTH\nvFragmentDepth=1.0+gl_Position.w;\ngl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;\n#endif";
Effect.IncludesShadersStore[name43] = shader43;

// node_modules/@babylonjs/core/Shaders/default.vertex.js
var name44 = "defaultVertexShader";
var shader44 = "#include<__decl__defaultVertex>\n\n#define CUSTOM_VERTEX_BEGIN\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef TANGENT\nattribute vec4 tangent;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<helperFunctions>\n#include<bonesDeclaration>\n\n#include<instancesDeclaration>\n#include<prePassVertexDeclaration>\n#ifdef MAINUV1\nvarying vec2 vMainUV1;\n#endif\n#ifdef MAINUV2\nvarying vec2 vMainUV2;\n#endif\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV == 0\nvarying vec2 vDiffuseUV;\n#endif\n#if defined(DETAIL) && DETAILDIRECTUV == 0\nvarying vec2 vDetailUV;\n#endif\n#if defined(AMBIENT) && AMBIENTDIRECTUV == 0\nvarying vec2 vAmbientUV;\n#endif\n#if defined(OPACITY) && OPACITYDIRECTUV == 0\nvarying vec2 vOpacityUV;\n#endif\n#if defined(EMISSIVE) && EMISSIVEDIRECTUV == 0\nvarying vec2 vEmissiveUV;\n#endif\n#if defined(LIGHTMAP) && LIGHTMAPDIRECTUV == 0\nvarying vec2 vLightmapUV;\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM) && SPECULARDIRECTUV == 0\nvarying vec2 vSpecularUV;\n#endif\n#if defined(BUMP) && BUMPDIRECTUV == 0\nvarying vec2 vBumpUV;\n#endif\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<bumpVertexDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvec3 positionUpdated=position;\n#ifdef NORMAL\nvec3 normalUpdated=normal;\n#endif\n#ifdef TANGENT\nvec4 tangentUpdated=tangent;\n#endif\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvPositionUVW=positionUpdated;\n#endif\n#define CUSTOM_VERTEX_UPDATE_POSITION\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n#include<instancesVertex>\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\n\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);\nvPreviousPosition=previousViewProjection*previousWorld*vec4(positionUpdated,1.0);\n#endif\n#include<bonesVertex>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\n#ifdef NORMAL\nmat3 normalWorld=mat3(finalWorld);\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));\nvNormalW=normalize(normalWorld*vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\n#endif\nvNormalW=normalize(normalWorld*normalUpdated);\n#endif\n#endif\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR == 0u) {\ngl_Position=viewProjection*worldPos;\n} else {\ngl_Position=viewProjectionR*worldPos;\n}\n#else\ngl_Position=viewProjection*worldPos;\n#endif\nvPositionW=vec3(worldPos);\n#include<prePassVertex>\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));\n#endif\n\n#ifndef UV1\nvec2 uvUpdated=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef MAINUV1\nvMainUV1=uvUpdated;\n#endif\n#ifdef MAINUV2\nvMainUV2=uv2;\n#endif\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV == 0\nif (vDiffuseInfos.x == 0.)\n{\nvDiffuseUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(DETAIL) && DETAILDIRECTUV == 0\nif (vDetailInfos.x == 0.)\n{\nvDetailUV=vec2(detailMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvDetailUV=vec2(detailMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(AMBIENT) && AMBIENTDIRECTUV == 0\nif (vAmbientInfos.x == 0.)\n{\nvAmbientUV=vec2(ambientMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvAmbientUV=vec2(ambientMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(OPACITY) && OPACITYDIRECTUV == 0\nif (vOpacityInfos.x == 0.)\n{\nvOpacityUV=vec2(opacityMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvOpacityUV=vec2(opacityMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(EMISSIVE) && EMISSIVEDIRECTUV == 0\nif (vEmissiveInfos.x == 0.)\n{\nvEmissiveUV=vec2(emissiveMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvEmissiveUV=vec2(emissiveMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(LIGHTMAP) && LIGHTMAPDIRECTUV == 0\nif (vLightmapInfos.x == 0.)\n{\nvLightmapUV=vec2(lightmapMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvLightmapUV=vec2(lightmapMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM) && SPECULARDIRECTUV == 0\nif (vSpecularInfos.x == 0.)\n{\nvSpecularUV=vec2(specularMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvSpecularUV=vec2(specularMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(BUMP) && BUMPDIRECTUV == 0\nif (vBumpInfos.x == 0.)\n{\nvBumpUV=vec2(bumpMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvBumpUV=vec2(bumpMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#include<bumpVertex>\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#ifdef VERTEXCOLOR\n\nvColor=color;\n#endif\n#include<pointCloudVertex>\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}\n";
Effect.ShadersStore[name44] = shader44;

// node_modules/@babylonjs/core/Materials/material.detailMapConfiguration.js
var DetailMapConfiguration = function() {
  function DetailMapConfiguration2(markAllSubMeshesAsTexturesDirty) {
    this._texture = null;
    this.diffuseBlendLevel = 1;
    this.roughnessBlendLevel = 1;
    this.bumpLevel = 1;
    this._normalBlendMethod = Material.MATERIAL_NORMALBLENDMETHOD_WHITEOUT;
    this._isEnabled = false;
    this.isEnabled = false;
    this._internalMarkAllSubMeshesAsTexturesDirty = markAllSubMeshesAsTexturesDirty;
  }
  DetailMapConfiguration2.prototype._markAllSubMeshesAsTexturesDirty = function() {
    this._internalMarkAllSubMeshesAsTexturesDirty();
  };
  DetailMapConfiguration2.prototype.isReadyForSubMesh = function(defines, scene) {
    var engine = scene.getEngine();
    if (defines._areTexturesDirty && scene.texturesEnabled) {
      if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled) {
        if (!this._texture.isReady()) {
          return false;
        }
      }
    }
    return true;
  };
  DetailMapConfiguration2.prototype.prepareDefines = function(defines, scene) {
    if (this._isEnabled) {
      defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;
      var engine = scene.getEngine();
      if (defines._areTexturesDirty) {
        if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled && this._isEnabled) {
          MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, "DETAIL");
          defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;
        } else {
          defines.DETAIL = false;
        }
      }
    } else {
      defines.DETAIL = false;
    }
  };
  DetailMapConfiguration2.prototype.bindForSubMesh = function(uniformBuffer, scene, isFrozen) {
    if (!this._isEnabled) {
      return;
    }
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if (this._texture && MaterialFlags.DetailTextureEnabled) {
        uniformBuffer.updateFloat4("vDetailInfos", this._texture.coordinatesIndex, this.diffuseBlendLevel, this.bumpLevel, this.roughnessBlendLevel);
        MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "detail");
      }
    }
    if (scene.texturesEnabled) {
      if (this._texture && MaterialFlags.DetailTextureEnabled) {
        uniformBuffer.setTexture("detailSampler", this._texture);
      }
    }
  };
  DetailMapConfiguration2.prototype.hasTexture = function(texture) {
    if (this._texture === texture) {
      return true;
    }
    return false;
  };
  DetailMapConfiguration2.prototype.getActiveTextures = function(activeTextures) {
    if (this._texture) {
      activeTextures.push(this._texture);
    }
  };
  DetailMapConfiguration2.prototype.getAnimatables = function(animatables) {
    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
      animatables.push(this._texture);
    }
  };
  DetailMapConfiguration2.prototype.dispose = function(forceDisposeTextures) {
    var _a;
    if (forceDisposeTextures) {
      (_a = this._texture) === null || _a === void 0 ? void 0 : _a.dispose();
    }
  };
  DetailMapConfiguration2.prototype.getClassName = function() {
    return "DetailMap";
  };
  DetailMapConfiguration2.AddUniforms = function(uniforms) {
    uniforms.push("vDetailInfos");
  };
  DetailMapConfiguration2.AddSamplers = function(samplers) {
    samplers.push("detailSampler");
  };
  DetailMapConfiguration2.PrepareUniformBuffer = function(uniformBuffer) {
    uniformBuffer.addUniform("vDetailInfos", 4);
    uniformBuffer.addUniform("detailMatrix", 16);
  };
  DetailMapConfiguration2.prototype.copyTo = function(detailMap) {
    SerializationHelper.Clone(function() {
      return detailMap;
    }, this);
  };
  DetailMapConfiguration2.prototype.serialize = function() {
    return SerializationHelper.Serialize(this);
  };
  DetailMapConfiguration2.prototype.parse = function(source, scene, rootUrl) {
    var _this = this;
    SerializationHelper.Parse(function() {
      return _this;
    }, source, scene, rootUrl);
  };
  __decorate([
    serializeAsTexture("detailTexture"),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], DetailMapConfiguration2.prototype, "texture", void 0);
  __decorate([
    serialize()
  ], DetailMapConfiguration2.prototype, "diffuseBlendLevel", void 0);
  __decorate([
    serialize()
  ], DetailMapConfiguration2.prototype, "roughnessBlendLevel", void 0);
  __decorate([
    serialize()
  ], DetailMapConfiguration2.prototype, "bumpLevel", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], DetailMapConfiguration2.prototype, "normalBlendMethod", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], DetailMapConfiguration2.prototype, "isEnabled", void 0);
  return DetailMapConfiguration2;
}();

// node_modules/@babylonjs/core/Materials/standardMaterial.js
var onCreatedEffectParameters = { effect: null, subMesh: null };
var StandardMaterialDefines = function(_super) {
  __extends(StandardMaterialDefines2, _super);
  function StandardMaterialDefines2() {
    var _this = _super.call(this) || this;
    _this.MAINUV1 = false;
    _this.MAINUV2 = false;
    _this.DIFFUSE = false;
    _this.DIFFUSEDIRECTUV = 0;
    _this.DETAIL = false;
    _this.DETAILDIRECTUV = 0;
    _this.DETAIL_NORMALBLENDMETHOD = 0;
    _this.AMBIENT = false;
    _this.AMBIENTDIRECTUV = 0;
    _this.OPACITY = false;
    _this.OPACITYDIRECTUV = 0;
    _this.OPACITYRGB = false;
    _this.REFLECTION = false;
    _this.EMISSIVE = false;
    _this.EMISSIVEDIRECTUV = 0;
    _this.SPECULAR = false;
    _this.SPECULARDIRECTUV = 0;
    _this.BUMP = false;
    _this.BUMPDIRECTUV = 0;
    _this.PARALLAX = false;
    _this.PARALLAXOCCLUSION = false;
    _this.SPECULAROVERALPHA = false;
    _this.CLIPPLANE = false;
    _this.CLIPPLANE2 = false;
    _this.CLIPPLANE3 = false;
    _this.CLIPPLANE4 = false;
    _this.CLIPPLANE5 = false;
    _this.CLIPPLANE6 = false;
    _this.ALPHATEST = false;
    _this.DEPTHPREPASS = false;
    _this.ALPHAFROMDIFFUSE = false;
    _this.POINTSIZE = false;
    _this.FOG = false;
    _this.SPECULARTERM = false;
    _this.DIFFUSEFRESNEL = false;
    _this.OPACITYFRESNEL = false;
    _this.REFLECTIONFRESNEL = false;
    _this.REFRACTIONFRESNEL = false;
    _this.EMISSIVEFRESNEL = false;
    _this.FRESNEL = false;
    _this.NORMAL = false;
    _this.UV1 = false;
    _this.UV2 = false;
    _this.VERTEXCOLOR = false;
    _this.VERTEXALPHA = false;
    _this.NUM_BONE_INFLUENCERS = 0;
    _this.BonesPerMesh = 0;
    _this.BONETEXTURE = false;
    _this.BONES_VELOCITY_ENABLED = false;
    _this.INSTANCES = false;
    _this.THIN_INSTANCES = false;
    _this.GLOSSINESS = false;
    _this.ROUGHNESS = false;
    _this.EMISSIVEASILLUMINATION = false;
    _this.LINKEMISSIVEWITHDIFFUSE = false;
    _this.REFLECTIONFRESNELFROMSPECULAR = false;
    _this.LIGHTMAP = false;
    _this.LIGHTMAPDIRECTUV = 0;
    _this.OBJECTSPACE_NORMALMAP = false;
    _this.USELIGHTMAPASSHADOWMAP = false;
    _this.REFLECTIONMAP_3D = false;
    _this.REFLECTIONMAP_SPHERICAL = false;
    _this.REFLECTIONMAP_PLANAR = false;
    _this.REFLECTIONMAP_CUBIC = false;
    _this.USE_LOCAL_REFLECTIONMAP_CUBIC = false;
    _this.REFLECTIONMAP_PROJECTION = false;
    _this.REFLECTIONMAP_SKYBOX = false;
    _this.REFLECTIONMAP_EXPLICIT = false;
    _this.REFLECTIONMAP_EQUIRECTANGULAR = false;
    _this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
    _this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
    _this.INVERTCUBICMAP = false;
    _this.LOGARITHMICDEPTH = false;
    _this.REFRACTION = false;
    _this.REFRACTIONMAP_3D = false;
    _this.REFLECTIONOVERALPHA = false;
    _this.TWOSIDEDLIGHTING = false;
    _this.SHADOWFLOAT = false;
    _this.MORPHTARGETS = false;
    _this.MORPHTARGETS_NORMAL = false;
    _this.MORPHTARGETS_TANGENT = false;
    _this.MORPHTARGETS_UV = false;
    _this.NUM_MORPH_INFLUENCERS = 0;
    _this.NONUNIFORMSCALING = false;
    _this.PREMULTIPLYALPHA = false;
    _this.ALPHATEST_AFTERALLALPHACOMPUTATIONS = false;
    _this.ALPHABLEND = true;
    _this.PREPASS = false;
    _this.PREPASS_IRRADIANCE = false;
    _this.PREPASS_IRRADIANCE_INDEX = -1;
    _this.PREPASS_ALBEDO = false;
    _this.PREPASS_ALBEDO_INDEX = -1;
    _this.PREPASS_DEPTHNORMAL = false;
    _this.PREPASS_DEPTHNORMAL_INDEX = -1;
    _this.PREPASS_POSITION = false;
    _this.PREPASS_POSITION_INDEX = -1;
    _this.PREPASS_VELOCITY = false;
    _this.PREPASS_VELOCITY_INDEX = -1;
    _this.PREPASS_REFLECTIVITY = false;
    _this.PREPASS_REFLECTIVITY_INDEX = -1;
    _this.SCENE_MRT_COUNT = 0;
    _this.RGBDLIGHTMAP = false;
    _this.RGBDREFLECTION = false;
    _this.RGBDREFRACTION = false;
    _this.IMAGEPROCESSING = false;
    _this.VIGNETTE = false;
    _this.VIGNETTEBLENDMODEMULTIPLY = false;
    _this.VIGNETTEBLENDMODEOPAQUE = false;
    _this.TONEMAPPING = false;
    _this.TONEMAPPING_ACES = false;
    _this.CONTRAST = false;
    _this.COLORCURVES = false;
    _this.COLORGRADING = false;
    _this.COLORGRADING3D = false;
    _this.SAMPLER3DGREENDEPTH = false;
    _this.SAMPLER3DBGRMAP = false;
    _this.IMAGEPROCESSINGPOSTPROCESS = false;
    _this.MULTIVIEW = false;
    _this.IS_REFLECTION_LINEAR = false;
    _this.IS_REFRACTION_LINEAR = false;
    _this.EXPOSURE = false;
    _this.rebuild();
    return _this;
  }
  StandardMaterialDefines2.prototype.setReflectionMode = function(modeToEnable) {
    var modes = [
      "REFLECTIONMAP_CUBIC",
      "REFLECTIONMAP_EXPLICIT",
      "REFLECTIONMAP_PLANAR",
      "REFLECTIONMAP_PROJECTION",
      "REFLECTIONMAP_PROJECTION",
      "REFLECTIONMAP_SKYBOX",
      "REFLECTIONMAP_SPHERICAL",
      "REFLECTIONMAP_EQUIRECTANGULAR",
      "REFLECTIONMAP_EQUIRECTANGULAR_FIXED",
      "REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED"
    ];
    for (var _i = 0, modes_1 = modes; _i < modes_1.length; _i++) {
      var mode = modes_1[_i];
      this[mode] = mode === modeToEnable;
    }
  };
  return StandardMaterialDefines2;
}(MaterialDefines);
var StandardMaterial = function(_super) {
  __extends(StandardMaterial2, _super);
  function StandardMaterial2(name45, scene) {
    var _this = _super.call(this, name45, scene) || this;
    _this._diffuseTexture = null;
    _this._ambientTexture = null;
    _this._opacityTexture = null;
    _this._reflectionTexture = null;
    _this._emissiveTexture = null;
    _this._specularTexture = null;
    _this._bumpTexture = null;
    _this._lightmapTexture = null;
    _this._refractionTexture = null;
    _this.ambientColor = new Color3(0, 0, 0);
    _this.diffuseColor = new Color3(1, 1, 1);
    _this.specularColor = new Color3(1, 1, 1);
    _this.emissiveColor = new Color3(0, 0, 0);
    _this.specularPower = 64;
    _this._useAlphaFromDiffuseTexture = false;
    _this._useEmissiveAsIllumination = false;
    _this._linkEmissiveWithDiffuse = false;
    _this._useSpecularOverAlpha = false;
    _this._useReflectionOverAlpha = false;
    _this._disableLighting = false;
    _this._useObjectSpaceNormalMap = false;
    _this._useParallax = false;
    _this._useParallaxOcclusion = false;
    _this.parallaxScaleBias = 0.05;
    _this._roughness = 0;
    _this.indexOfRefraction = 0.98;
    _this.invertRefractionY = true;
    _this.alphaCutOff = 0.4;
    _this._useLightmapAsShadowmap = false;
    _this._useReflectionFresnelFromSpecular = false;
    _this._useGlossinessFromSpecularMapAlpha = false;
    _this._maxSimultaneousLights = 4;
    _this._invertNormalMapX = false;
    _this._invertNormalMapY = false;
    _this._twoSidedLighting = false;
    _this.detailMap = new DetailMapConfiguration(_this._markAllSubMeshesAsTexturesDirty.bind(_this));
    _this._renderTargets = new SmartArray(16);
    _this._worldViewProjectionMatrix = Matrix.Zero();
    _this._globalAmbientColor = new Color3(0, 0, 0);
    _this._rebuildInParallel = false;
    _this._attachImageProcessingConfiguration(null);
    _this.prePassConfiguration = new PrePassConfiguration();
    _this.getRenderTargetTextures = function() {
      _this._renderTargets.reset();
      if (StandardMaterial2.ReflectionTextureEnabled && _this._reflectionTexture && _this._reflectionTexture.isRenderTarget) {
        _this._renderTargets.push(_this._reflectionTexture);
      }
      if (StandardMaterial2.RefractionTextureEnabled && _this._refractionTexture && _this._refractionTexture.isRenderTarget) {
        _this._renderTargets.push(_this._refractionTexture);
      }
      return _this._renderTargets;
    };
    return _this;
  }
  Object.defineProperty(StandardMaterial2.prototype, "imageProcessingConfiguration", {
    get: function() {
      return this._imageProcessingConfiguration;
    },
    set: function(value) {
      this._attachImageProcessingConfiguration(value);
      this._markAllSubMeshesAsTexturesDirty();
    },
    enumerable: false,
    configurable: true
  });
  StandardMaterial2.prototype._attachImageProcessingConfiguration = function(configuration) {
    var _this = this;
    if (configuration === this._imageProcessingConfiguration) {
      return;
    }
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    if (!configuration) {
      this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;
    } else {
      this._imageProcessingConfiguration = configuration;
    }
    if (this._imageProcessingConfiguration) {
      this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(function() {
        _this._markAllSubMeshesAsImageProcessingDirty();
      });
    }
  };
  Object.defineProperty(StandardMaterial2.prototype, "cameraColorCurvesEnabled", {
    get: function() {
      return this.imageProcessingConfiguration.colorCurvesEnabled;
    },
    set: function(value) {
      this.imageProcessingConfiguration.colorCurvesEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2.prototype, "cameraColorGradingEnabled", {
    get: function() {
      return this.imageProcessingConfiguration.colorGradingEnabled;
    },
    set: function(value) {
      this.imageProcessingConfiguration.colorGradingEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2.prototype, "cameraToneMappingEnabled", {
    get: function() {
      return this._imageProcessingConfiguration.toneMappingEnabled;
    },
    set: function(value) {
      this._imageProcessingConfiguration.toneMappingEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2.prototype, "cameraExposure", {
    get: function() {
      return this._imageProcessingConfiguration.exposure;
    },
    set: function(value) {
      this._imageProcessingConfiguration.exposure = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2.prototype, "cameraContrast", {
    get: function() {
      return this._imageProcessingConfiguration.contrast;
    },
    set: function(value) {
      this._imageProcessingConfiguration.contrast = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2.prototype, "cameraColorGradingTexture", {
    get: function() {
      return this._imageProcessingConfiguration.colorGradingTexture;
    },
    set: function(value) {
      this._imageProcessingConfiguration.colorGradingTexture = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2.prototype, "cameraColorCurves", {
    get: function() {
      return this._imageProcessingConfiguration.colorCurves;
    },
    set: function(value) {
      this._imageProcessingConfiguration.colorCurves = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2.prototype, "canRenderToMRT", {
    get: function() {
      return true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2.prototype, "hasRenderTargetTextures", {
    get: function() {
      if (StandardMaterial2.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
        return true;
      }
      if (StandardMaterial2.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
        return true;
      }
      return false;
    },
    enumerable: false,
    configurable: true
  });
  StandardMaterial2.prototype.getClassName = function() {
    return "StandardMaterial";
  };
  Object.defineProperty(StandardMaterial2.prototype, "useLogarithmicDepth", {
    get: function() {
      return this._useLogarithmicDepth;
    },
    set: function(value) {
      this._useLogarithmicDepth = value && this.getScene().getEngine().getCaps().fragmentDepthSupported;
      this._markAllSubMeshesAsMiscDirty();
    },
    enumerable: false,
    configurable: true
  });
  StandardMaterial2.prototype.needAlphaBlending = function() {
    if (this._disableAlphaBlending) {
      return false;
    }
    return this.alpha < 1 || this._opacityTexture != null || this._shouldUseAlphaFromDiffuseTexture() || this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled;
  };
  StandardMaterial2.prototype.needAlphaTesting = function() {
    if (this._forceAlphaTest) {
      return true;
    }
    return this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === Material.MATERIAL_ALPHATEST);
  };
  StandardMaterial2.prototype._shouldUseAlphaFromDiffuseTexture = function() {
    return this._diffuseTexture != null && this._diffuseTexture.hasAlpha && this._useAlphaFromDiffuseTexture && this._transparencyMode !== Material.MATERIAL_OPAQUE;
  };
  StandardMaterial2.prototype._hasAlphaChannel = function() {
    return this._diffuseTexture != null && this._diffuseTexture.hasAlpha || this._opacityTexture != null;
  };
  StandardMaterial2.prototype.getAlphaTestTexture = function() {
    return this._diffuseTexture;
  };
  StandardMaterial2.prototype.isReadyForSubMesh = function(mesh, subMesh, useInstances) {
    if (useInstances === void 0) {
      useInstances = false;
    }
    if (subMesh.effect && this.isFrozen) {
      if (subMesh.effect._wasPreviouslyReady) {
        return true;
      }
    }
    if (!subMesh._materialDefines) {
      subMesh._materialDefines = new StandardMaterialDefines();
    }
    var scene = this.getScene();
    var defines = subMesh._materialDefines;
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    var engine = scene.getEngine();
    defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);
    MaterialHelper.PrepareDefinesForMultiview(scene, defines);
    MaterialHelper.PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT);
    if (defines._areTexturesDirty) {
      defines._needUVs = false;
      defines.MAINUV1 = false;
      defines.MAINUV2 = false;
      if (scene.texturesEnabled) {
        if (this._diffuseTexture && StandardMaterial2.DiffuseTextureEnabled) {
          if (!this._diffuseTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            MaterialHelper.PrepareDefinesForMergedUV(this._diffuseTexture, defines, "DIFFUSE");
          }
        } else {
          defines.DIFFUSE = false;
        }
        if (this._ambientTexture && StandardMaterial2.AmbientTextureEnabled) {
          if (!this._ambientTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            MaterialHelper.PrepareDefinesForMergedUV(this._ambientTexture, defines, "AMBIENT");
          }
        } else {
          defines.AMBIENT = false;
        }
        if (this._opacityTexture && StandardMaterial2.OpacityTextureEnabled) {
          if (!this._opacityTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            MaterialHelper.PrepareDefinesForMergedUV(this._opacityTexture, defines, "OPACITY");
            defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;
          }
        } else {
          defines.OPACITY = false;
        }
        if (this._reflectionTexture && StandardMaterial2.ReflectionTextureEnabled) {
          if (!this._reflectionTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            defines._needNormals = true;
            defines.REFLECTION = true;
            defines.ROUGHNESS = this._roughness > 0;
            defines.REFLECTIONOVERALPHA = this._useReflectionOverAlpha;
            defines.INVERTCUBICMAP = this._reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE;
            defines.REFLECTIONMAP_3D = this._reflectionTexture.isCube;
            defines.RGBDREFLECTION = this._reflectionTexture.isRGBD;
            switch (this._reflectionTexture.coordinatesMode) {
              case Texture.EXPLICIT_MODE:
                defines.setReflectionMode("REFLECTIONMAP_EXPLICIT");
                break;
              case Texture.PLANAR_MODE:
                defines.setReflectionMode("REFLECTIONMAP_PLANAR");
                break;
              case Texture.PROJECTION_MODE:
                defines.setReflectionMode("REFLECTIONMAP_PROJECTION");
                break;
              case Texture.SKYBOX_MODE:
                defines.setReflectionMode("REFLECTIONMAP_SKYBOX");
                break;
              case Texture.SPHERICAL_MODE:
                defines.setReflectionMode("REFLECTIONMAP_SPHERICAL");
                break;
              case Texture.EQUIRECTANGULAR_MODE:
                defines.setReflectionMode("REFLECTIONMAP_EQUIRECTANGULAR");
                break;
              case Texture.FIXED_EQUIRECTANGULAR_MODE:
                defines.setReflectionMode("REFLECTIONMAP_EQUIRECTANGULAR_FIXED");
                break;
              case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:
                defines.setReflectionMode("REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED");
                break;
              case Texture.CUBIC_MODE:
              case Texture.INVCUBIC_MODE:
              default:
                defines.setReflectionMode("REFLECTIONMAP_CUBIC");
                break;
            }
            defines.USE_LOCAL_REFLECTIONMAP_CUBIC = this._reflectionTexture.boundingBoxSize ? true : false;
          }
        } else {
          defines.REFLECTION = false;
        }
        if (this._emissiveTexture && StandardMaterial2.EmissiveTextureEnabled) {
          if (!this._emissiveTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            MaterialHelper.PrepareDefinesForMergedUV(this._emissiveTexture, defines, "EMISSIVE");
          }
        } else {
          defines.EMISSIVE = false;
        }
        if (this._lightmapTexture && StandardMaterial2.LightmapTextureEnabled) {
          if (!this._lightmapTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            MaterialHelper.PrepareDefinesForMergedUV(this._lightmapTexture, defines, "LIGHTMAP");
            defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;
            defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;
          }
        } else {
          defines.LIGHTMAP = false;
        }
        if (this._specularTexture && StandardMaterial2.SpecularTextureEnabled) {
          if (!this._specularTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            MaterialHelper.PrepareDefinesForMergedUV(this._specularTexture, defines, "SPECULAR");
            defines.GLOSSINESS = this._useGlossinessFromSpecularMapAlpha;
          }
        } else {
          defines.SPECULAR = false;
        }
        if (scene.getEngine().getCaps().standardDerivatives && this._bumpTexture && StandardMaterial2.BumpTextureEnabled) {
          if (!this._bumpTexture.isReady()) {
            return false;
          } else {
            MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture, defines, "BUMP");
            defines.PARALLAX = this._useParallax;
            defines.PARALLAXOCCLUSION = this._useParallaxOcclusion;
          }
          defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;
        } else {
          defines.BUMP = false;
        }
        if (this._refractionTexture && StandardMaterial2.RefractionTextureEnabled) {
          if (!this._refractionTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            defines._needUVs = true;
            defines.REFRACTION = true;
            defines.REFRACTIONMAP_3D = this._refractionTexture.isCube;
            defines.RGBDREFRACTION = this._refractionTexture.isRGBD;
          }
        } else {
          defines.REFRACTION = false;
        }
        defines.TWOSIDEDLIGHTING = !this._backFaceCulling && this._twoSidedLighting;
      } else {
        defines.DIFFUSE = false;
        defines.AMBIENT = false;
        defines.OPACITY = false;
        defines.REFLECTION = false;
        defines.EMISSIVE = false;
        defines.LIGHTMAP = false;
        defines.BUMP = false;
        defines.REFRACTION = false;
      }
      defines.ALPHAFROMDIFFUSE = this._shouldUseAlphaFromDiffuseTexture();
      defines.EMISSIVEASILLUMINATION = this._useEmissiveAsIllumination;
      defines.LINKEMISSIVEWITHDIFFUSE = this._linkEmissiveWithDiffuse;
      defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;
      defines.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8;
      defines.ALPHATEST_AFTERALLALPHACOMPUTATIONS = this.transparencyMode !== null;
      defines.ALPHABLEND = this.transparencyMode === null || this.needAlphaBlendingForMesh(mesh);
    }
    if (!this.detailMap.isReadyForSubMesh(defines, scene)) {
      return false;
    }
    if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
      if (!this._imageProcessingConfiguration.isReady()) {
        return false;
      }
      this._imageProcessingConfiguration.prepareDefines(defines);
      defines.IS_REFLECTION_LINEAR = this.reflectionTexture != null && !this.reflectionTexture.gammaSpace;
      defines.IS_REFRACTION_LINEAR = this.refractionTexture != null && !this.refractionTexture.gammaSpace;
    }
    if (defines._areFresnelDirty) {
      if (StandardMaterial2.FresnelEnabled) {
        if (this._diffuseFresnelParameters || this._opacityFresnelParameters || this._emissiveFresnelParameters || this._refractionFresnelParameters || this._reflectionFresnelParameters) {
          defines.DIFFUSEFRESNEL = this._diffuseFresnelParameters && this._diffuseFresnelParameters.isEnabled;
          defines.OPACITYFRESNEL = this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled;
          defines.REFLECTIONFRESNEL = this._reflectionFresnelParameters && this._reflectionFresnelParameters.isEnabled;
          defines.REFLECTIONFRESNELFROMSPECULAR = this._useReflectionFresnelFromSpecular;
          defines.REFRACTIONFRESNEL = this._refractionFresnelParameters && this._refractionFresnelParameters.isEnabled;
          defines.EMISSIVEFRESNEL = this._emissiveFresnelParameters && this._emissiveFresnelParameters.isEnabled;
          defines._needNormals = true;
          defines.FRESNEL = true;
        }
      } else {
        defines.FRESNEL = false;
      }
    }
    MaterialHelper.PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh) || this._forceAlphaTest, defines);
    MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true, true);
    MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, defines, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);
    this.detailMap.prepareDefines(defines, scene);
    if (defines.isDirty) {
      var lightDisposed = defines._areLightsDisposed;
      defines.markAsProcessed();
      var fallbacks = new EffectFallbacks();
      if (defines.REFLECTION) {
        fallbacks.addFallback(0, "REFLECTION");
      }
      if (defines.SPECULAR) {
        fallbacks.addFallback(0, "SPECULAR");
      }
      if (defines.BUMP) {
        fallbacks.addFallback(0, "BUMP");
      }
      if (defines.PARALLAX) {
        fallbacks.addFallback(1, "PARALLAX");
      }
      if (defines.PARALLAXOCCLUSION) {
        fallbacks.addFallback(0, "PARALLAXOCCLUSION");
      }
      if (defines.SPECULAROVERALPHA) {
        fallbacks.addFallback(0, "SPECULAROVERALPHA");
      }
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      if (defines.POINTSIZE) {
        fallbacks.addFallback(0, "POINTSIZE");
      }
      if (defines.LOGARITHMICDEPTH) {
        fallbacks.addFallback(0, "LOGARITHMICDEPTH");
      }
      MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights);
      if (defines.SPECULARTERM) {
        fallbacks.addFallback(0, "SPECULARTERM");
      }
      if (defines.DIFFUSEFRESNEL) {
        fallbacks.addFallback(1, "DIFFUSEFRESNEL");
      }
      if (defines.OPACITYFRESNEL) {
        fallbacks.addFallback(2, "OPACITYFRESNEL");
      }
      if (defines.REFLECTIONFRESNEL) {
        fallbacks.addFallback(3, "REFLECTIONFRESNEL");
      }
      if (defines.EMISSIVEFRESNEL) {
        fallbacks.addFallback(4, "EMISSIVEFRESNEL");
      }
      if (defines.FRESNEL) {
        fallbacks.addFallback(4, "FRESNEL");
      }
      if (defines.MULTIVIEW) {
        fallbacks.addFallback(0, "MULTIVIEW");
      }
      var attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
      MaterialHelper.PrepareAttributesForInstances(attribs, defines);
      MaterialHelper.PrepareAttributesForMorphTargets(attribs, mesh, defines);
      var shaderName = "default";
      var uniforms = [
        "world",
        "view",
        "viewProjection",
        "vEyePosition",
        "vLightsType",
        "vAmbientColor",
        "vDiffuseColor",
        "vSpecularColor",
        "vEmissiveColor",
        "visibility",
        "vFogInfos",
        "vFogColor",
        "pointSize",
        "vDiffuseInfos",
        "vAmbientInfos",
        "vOpacityInfos",
        "vReflectionInfos",
        "vEmissiveInfos",
        "vSpecularInfos",
        "vBumpInfos",
        "vLightmapInfos",
        "vRefractionInfos",
        "mBones",
        "vClipPlane",
        "vClipPlane2",
        "vClipPlane3",
        "vClipPlane4",
        "vClipPlane5",
        "vClipPlane6",
        "diffuseMatrix",
        "ambientMatrix",
        "opacityMatrix",
        "reflectionMatrix",
        "emissiveMatrix",
        "specularMatrix",
        "bumpMatrix",
        "normalMatrix",
        "lightmapMatrix",
        "refractionMatrix",
        "diffuseLeftColor",
        "diffuseRightColor",
        "opacityParts",
        "reflectionLeftColor",
        "reflectionRightColor",
        "emissiveLeftColor",
        "emissiveRightColor",
        "refractionLeftColor",
        "refractionRightColor",
        "vReflectionPosition",
        "vReflectionSize",
        "logarithmicDepthConstant",
        "vTangentSpaceParams",
        "alphaCutOff",
        "boneTextureWidth"
      ];
      var samplers = [
        "diffuseSampler",
        "ambientSampler",
        "opacitySampler",
        "reflectionCubeSampler",
        "reflection2DSampler",
        "emissiveSampler",
        "specularSampler",
        "bumpSampler",
        "lightmapSampler",
        "refractionCubeSampler",
        "refraction2DSampler",
        "boneSampler"
      ];
      var uniformBuffers = ["Material", "Scene"];
      DetailMapConfiguration.AddUniforms(uniforms);
      DetailMapConfiguration.AddSamplers(samplers);
      PrePassConfiguration.AddUniforms(uniforms);
      PrePassConfiguration.AddSamplers(uniforms);
      if (ImageProcessingConfiguration) {
        ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);
        ImageProcessingConfiguration.PrepareSamplers(samplers, defines);
      }
      MaterialHelper.PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: this._maxSimultaneousLights
      });
      var csnrOptions = {};
      if (this.customShaderNameResolve) {
        shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);
      }
      var join = defines.toString();
      var previousEffect = subMesh.effect;
      var effect = scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS },
        processFinalCode: csnrOptions.processFinalCode,
        multiTarget: defines.PREPASS
      }, engine);
      if (effect) {
        if (this._onEffectCreatedObservable) {
          onCreatedEffectParameters.effect = effect;
          onCreatedEffectParameters.subMesh = subMesh;
          this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);
        }
        if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {
          effect = previousEffect;
          this._rebuildInParallel = true;
          defines.markAsUnprocessed();
          if (lightDisposed) {
            defines._areLightsDisposed = true;
            return false;
          }
        } else {
          this._rebuildInParallel = false;
          scene.resetCachedMaterial();
          subMesh.setEffect(effect, defines);
          this.buildUniformLayout();
        }
      }
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    subMesh.effect._wasPreviouslyReady = true;
    return true;
  };
  StandardMaterial2.prototype.buildUniformLayout = function() {
    var ubo = this._uniformBuffer;
    ubo.addUniform("diffuseLeftColor", 4);
    ubo.addUniform("diffuseRightColor", 4);
    ubo.addUniform("opacityParts", 4);
    ubo.addUniform("reflectionLeftColor", 4);
    ubo.addUniform("reflectionRightColor", 4);
    ubo.addUniform("refractionLeftColor", 4);
    ubo.addUniform("refractionRightColor", 4);
    ubo.addUniform("emissiveLeftColor", 4);
    ubo.addUniform("emissiveRightColor", 4);
    ubo.addUniform("vDiffuseInfos", 2);
    ubo.addUniform("vAmbientInfos", 2);
    ubo.addUniform("vOpacityInfos", 2);
    ubo.addUniform("vReflectionInfos", 2);
    ubo.addUniform("vReflectionPosition", 3);
    ubo.addUniform("vReflectionSize", 3);
    ubo.addUniform("vEmissiveInfos", 2);
    ubo.addUniform("vLightmapInfos", 2);
    ubo.addUniform("vSpecularInfos", 2);
    ubo.addUniform("vBumpInfos", 3);
    ubo.addUniform("diffuseMatrix", 16);
    ubo.addUniform("ambientMatrix", 16);
    ubo.addUniform("opacityMatrix", 16);
    ubo.addUniform("reflectionMatrix", 16);
    ubo.addUniform("emissiveMatrix", 16);
    ubo.addUniform("lightmapMatrix", 16);
    ubo.addUniform("specularMatrix", 16);
    ubo.addUniform("bumpMatrix", 16);
    ubo.addUniform("vTangentSpaceParams", 2);
    ubo.addUniform("pointSize", 1);
    ubo.addUniform("refractionMatrix", 16);
    ubo.addUniform("vRefractionInfos", 4);
    ubo.addUniform("vSpecularColor", 4);
    ubo.addUniform("vEmissiveColor", 3);
    ubo.addUniform("visibility", 1);
    ubo.addUniform("vDiffuseColor", 4);
    DetailMapConfiguration.PrepareUniformBuffer(ubo);
    ubo.create();
  };
  StandardMaterial2.prototype.unbind = function() {
    if (this._activeEffect) {
      var needFlag = false;
      if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
        this._activeEffect.setTexture("reflection2DSampler", null);
        needFlag = true;
      }
      if (this._refractionTexture && this._refractionTexture.isRenderTarget) {
        this._activeEffect.setTexture("refraction2DSampler", null);
        needFlag = true;
      }
      if (needFlag) {
        this._markAllSubMeshesAsTexturesDirty();
      }
    }
    _super.prototype.unbind.call(this);
  };
  StandardMaterial2.prototype.bindForSubMesh = function(world, mesh, subMesh) {
    var scene = this.getScene();
    var defines = subMesh._materialDefines;
    if (!defines) {
      return;
    }
    var effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    if (!defines.INSTANCES || defines.THIN_INSTANCES) {
      this.bindOnlyWorldMatrix(world);
    }
    this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);
    if (defines.OBJECTSPACE_NORMALMAP) {
      world.toNormalMatrix(this._normalMatrix);
      this.bindOnlyNormalMatrix(this._normalMatrix);
    }
    var mustRebind = this._mustRebind(scene, effect, mesh.visibility);
    MaterialHelper.BindBonesParameters(mesh, effect);
    var ubo = this._uniformBuffer;
    if (mustRebind) {
      ubo.bindToEffect(effect, "Material");
      this.bindViewProjection(effect);
      if (!ubo.useUbo || !this.isFrozen || !ubo.isSync) {
        if (StandardMaterial2.FresnelEnabled && defines.FRESNEL) {
          if (this.diffuseFresnelParameters && this.diffuseFresnelParameters.isEnabled) {
            ubo.updateColor4("diffuseLeftColor", this.diffuseFresnelParameters.leftColor, this.diffuseFresnelParameters.power);
            ubo.updateColor4("diffuseRightColor", this.diffuseFresnelParameters.rightColor, this.diffuseFresnelParameters.bias);
          }
          if (this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled) {
            ubo.updateColor4("opacityParts", new Color3(this.opacityFresnelParameters.leftColor.toLuminance(), this.opacityFresnelParameters.rightColor.toLuminance(), this.opacityFresnelParameters.bias), this.opacityFresnelParameters.power);
          }
          if (this.reflectionFresnelParameters && this.reflectionFresnelParameters.isEnabled) {
            ubo.updateColor4("reflectionLeftColor", this.reflectionFresnelParameters.leftColor, this.reflectionFresnelParameters.power);
            ubo.updateColor4("reflectionRightColor", this.reflectionFresnelParameters.rightColor, this.reflectionFresnelParameters.bias);
          }
          if (this.refractionFresnelParameters && this.refractionFresnelParameters.isEnabled) {
            ubo.updateColor4("refractionLeftColor", this.refractionFresnelParameters.leftColor, this.refractionFresnelParameters.power);
            ubo.updateColor4("refractionRightColor", this.refractionFresnelParameters.rightColor, this.refractionFresnelParameters.bias);
          }
          if (this.emissiveFresnelParameters && this.emissiveFresnelParameters.isEnabled) {
            ubo.updateColor4("emissiveLeftColor", this.emissiveFresnelParameters.leftColor, this.emissiveFresnelParameters.power);
            ubo.updateColor4("emissiveRightColor", this.emissiveFresnelParameters.rightColor, this.emissiveFresnelParameters.bias);
          }
        }
        if (scene.texturesEnabled) {
          if (this._diffuseTexture && StandardMaterial2.DiffuseTextureEnabled) {
            ubo.updateFloat2("vDiffuseInfos", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);
            MaterialHelper.BindTextureMatrix(this._diffuseTexture, ubo, "diffuse");
          }
          if (this._ambientTexture && StandardMaterial2.AmbientTextureEnabled) {
            ubo.updateFloat2("vAmbientInfos", this._ambientTexture.coordinatesIndex, this._ambientTexture.level);
            MaterialHelper.BindTextureMatrix(this._ambientTexture, ubo, "ambient");
          }
          if (this._opacityTexture && StandardMaterial2.OpacityTextureEnabled) {
            ubo.updateFloat2("vOpacityInfos", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);
            MaterialHelper.BindTextureMatrix(this._opacityTexture, ubo, "opacity");
          }
          if (this._hasAlphaChannel()) {
            effect.setFloat("alphaCutOff", this.alphaCutOff);
          }
          if (this._reflectionTexture && StandardMaterial2.ReflectionTextureEnabled) {
            ubo.updateFloat2("vReflectionInfos", this._reflectionTexture.level, this.roughness);
            ubo.updateMatrix("reflectionMatrix", this._reflectionTexture.getReflectionTextureMatrix());
            if (this._reflectionTexture.boundingBoxSize) {
              var cubeTexture = this._reflectionTexture;
              ubo.updateVector3("vReflectionPosition", cubeTexture.boundingBoxPosition);
              ubo.updateVector3("vReflectionSize", cubeTexture.boundingBoxSize);
            }
          }
          if (this._emissiveTexture && StandardMaterial2.EmissiveTextureEnabled) {
            ubo.updateFloat2("vEmissiveInfos", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);
            MaterialHelper.BindTextureMatrix(this._emissiveTexture, ubo, "emissive");
          }
          if (this._lightmapTexture && StandardMaterial2.LightmapTextureEnabled) {
            ubo.updateFloat2("vLightmapInfos", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);
            MaterialHelper.BindTextureMatrix(this._lightmapTexture, ubo, "lightmap");
          }
          if (this._specularTexture && StandardMaterial2.SpecularTextureEnabled) {
            ubo.updateFloat2("vSpecularInfos", this._specularTexture.coordinatesIndex, this._specularTexture.level);
            MaterialHelper.BindTextureMatrix(this._specularTexture, ubo, "specular");
          }
          if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial2.BumpTextureEnabled) {
            ubo.updateFloat3("vBumpInfos", this._bumpTexture.coordinatesIndex, 1 / this._bumpTexture.level, this.parallaxScaleBias);
            MaterialHelper.BindTextureMatrix(this._bumpTexture, ubo, "bump");
            if (scene._mirroredCameraPosition) {
              ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? 1 : -1, this._invertNormalMapY ? 1 : -1);
            } else {
              ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? -1 : 1, this._invertNormalMapY ? -1 : 1);
            }
          }
          if (this._refractionTexture && StandardMaterial2.RefractionTextureEnabled) {
            var depth = 1;
            if (!this._refractionTexture.isCube) {
              ubo.updateMatrix("refractionMatrix", this._refractionTexture.getReflectionTextureMatrix());
              if (this._refractionTexture.depth) {
                depth = this._refractionTexture.depth;
              }
            }
            ubo.updateFloat4("vRefractionInfos", this._refractionTexture.level, this.indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);
          }
        }
        if (this.pointsCloud) {
          ubo.updateFloat("pointSize", this.pointSize);
        }
        if (defines.SPECULARTERM) {
          ubo.updateColor4("vSpecularColor", this.specularColor, this.specularPower);
        }
        ubo.updateColor3("vEmissiveColor", StandardMaterial2.EmissiveTextureEnabled ? this.emissiveColor : Color3.BlackReadOnly);
        ubo.updateColor4("vDiffuseColor", this.diffuseColor, this.alpha);
      }
      ubo.updateFloat("visibility", mesh.visibility);
      if (scene.texturesEnabled) {
        if (this._diffuseTexture && StandardMaterial2.DiffuseTextureEnabled) {
          effect.setTexture("diffuseSampler", this._diffuseTexture);
        }
        if (this._ambientTexture && StandardMaterial2.AmbientTextureEnabled) {
          effect.setTexture("ambientSampler", this._ambientTexture);
        }
        if (this._opacityTexture && StandardMaterial2.OpacityTextureEnabled) {
          effect.setTexture("opacitySampler", this._opacityTexture);
        }
        if (this._reflectionTexture && StandardMaterial2.ReflectionTextureEnabled) {
          if (this._reflectionTexture.isCube) {
            effect.setTexture("reflectionCubeSampler", this._reflectionTexture);
          } else {
            effect.setTexture("reflection2DSampler", this._reflectionTexture);
          }
        }
        if (this._emissiveTexture && StandardMaterial2.EmissiveTextureEnabled) {
          effect.setTexture("emissiveSampler", this._emissiveTexture);
        }
        if (this._lightmapTexture && StandardMaterial2.LightmapTextureEnabled) {
          effect.setTexture("lightmapSampler", this._lightmapTexture);
        }
        if (this._specularTexture && StandardMaterial2.SpecularTextureEnabled) {
          effect.setTexture("specularSampler", this._specularTexture);
        }
        if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial2.BumpTextureEnabled) {
          effect.setTexture("bumpSampler", this._bumpTexture);
        }
        if (this._refractionTexture && StandardMaterial2.RefractionTextureEnabled) {
          var depth = 1;
          if (this._refractionTexture.isCube) {
            effect.setTexture("refractionCubeSampler", this._refractionTexture);
          } else {
            effect.setTexture("refraction2DSampler", this._refractionTexture);
          }
        }
      }
      this.detailMap.bindForSubMesh(ubo, scene, this.isFrozen);
      MaterialHelper.BindClipPlane(effect, scene);
      scene.ambientColor.multiplyToRef(this.ambientColor, this._globalAmbientColor);
      MaterialHelper.BindEyePosition(effect, scene);
      effect.setColor3("vAmbientColor", this._globalAmbientColor);
    }
    if (mustRebind || !this.isFrozen) {
      if (scene.lightsEnabled && !this._disableLighting) {
        MaterialHelper.BindLights(scene, mesh, effect, defines, this._maxSimultaneousLights, this._rebuildInParallel);
      }
      if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE || this._reflectionTexture || this._refractionTexture) {
        this.bindView(effect);
      }
      MaterialHelper.BindFogParameters(scene, mesh, effect);
      if (defines.NUM_MORPH_INFLUENCERS) {
        MaterialHelper.BindMorphTargetParameters(mesh, effect);
      }
      if (this.useLogarithmicDepth) {
        MaterialHelper.BindLogDepth(defines, effect, scene);
      }
      if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {
        this._imageProcessingConfiguration.bind(this._activeEffect);
      }
    }
    ubo.update();
    this._afterBind(mesh, this._activeEffect);
  };
  StandardMaterial2.prototype.getAnimatables = function() {
    var results = [];
    if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {
      results.push(this._diffuseTexture);
    }
    if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {
      results.push(this._ambientTexture);
    }
    if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {
      results.push(this._opacityTexture);
    }
    if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {
      results.push(this._reflectionTexture);
    }
    if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {
      results.push(this._emissiveTexture);
    }
    if (this._specularTexture && this._specularTexture.animations && this._specularTexture.animations.length > 0) {
      results.push(this._specularTexture);
    }
    if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {
      results.push(this._bumpTexture);
    }
    if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {
      results.push(this._lightmapTexture);
    }
    if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {
      results.push(this._refractionTexture);
    }
    this.detailMap.getAnimatables(results);
    return results;
  };
  StandardMaterial2.prototype.getActiveTextures = function() {
    var activeTextures = _super.prototype.getActiveTextures.call(this);
    if (this._diffuseTexture) {
      activeTextures.push(this._diffuseTexture);
    }
    if (this._ambientTexture) {
      activeTextures.push(this._ambientTexture);
    }
    if (this._opacityTexture) {
      activeTextures.push(this._opacityTexture);
    }
    if (this._reflectionTexture) {
      activeTextures.push(this._reflectionTexture);
    }
    if (this._emissiveTexture) {
      activeTextures.push(this._emissiveTexture);
    }
    if (this._specularTexture) {
      activeTextures.push(this._specularTexture);
    }
    if (this._bumpTexture) {
      activeTextures.push(this._bumpTexture);
    }
    if (this._lightmapTexture) {
      activeTextures.push(this._lightmapTexture);
    }
    if (this._refractionTexture) {
      activeTextures.push(this._refractionTexture);
    }
    this.detailMap.getActiveTextures(activeTextures);
    return activeTextures;
  };
  StandardMaterial2.prototype.hasTexture = function(texture) {
    if (_super.prototype.hasTexture.call(this, texture)) {
      return true;
    }
    if (this._diffuseTexture === texture) {
      return true;
    }
    if (this._ambientTexture === texture) {
      return true;
    }
    if (this._opacityTexture === texture) {
      return true;
    }
    if (this._reflectionTexture === texture) {
      return true;
    }
    if (this._emissiveTexture === texture) {
      return true;
    }
    if (this._specularTexture === texture) {
      return true;
    }
    if (this._bumpTexture === texture) {
      return true;
    }
    if (this._lightmapTexture === texture) {
      return true;
    }
    if (this._refractionTexture === texture) {
      return true;
    }
    return this.detailMap.hasTexture(texture);
  };
  StandardMaterial2.prototype.dispose = function(forceDisposeEffect, forceDisposeTextures) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    if (forceDisposeTextures) {
      (_a = this._diffuseTexture) === null || _a === void 0 ? void 0 : _a.dispose();
      (_b = this._ambientTexture) === null || _b === void 0 ? void 0 : _b.dispose();
      (_c = this._opacityTexture) === null || _c === void 0 ? void 0 : _c.dispose();
      (_d = this._reflectionTexture) === null || _d === void 0 ? void 0 : _d.dispose();
      (_e = this._emissiveTexture) === null || _e === void 0 ? void 0 : _e.dispose();
      (_f = this._specularTexture) === null || _f === void 0 ? void 0 : _f.dispose();
      (_g = this._bumpTexture) === null || _g === void 0 ? void 0 : _g.dispose();
      (_h = this._lightmapTexture) === null || _h === void 0 ? void 0 : _h.dispose();
      (_j = this._refractionTexture) === null || _j === void 0 ? void 0 : _j.dispose();
    }
    this.detailMap.dispose(forceDisposeTextures);
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures);
  };
  StandardMaterial2.prototype.clone = function(name45) {
    var _this = this;
    var result = SerializationHelper.Clone(function() {
      return new StandardMaterial2(name45, _this.getScene());
    }, this);
    result.name = name45;
    result.id = name45;
    return result;
  };
  StandardMaterial2.prototype.serialize = function() {
    return SerializationHelper.Serialize(this);
  };
  StandardMaterial2.Parse = function(source, scene, rootUrl) {
    return SerializationHelper.Parse(function() {
      return new StandardMaterial2(source.name, scene);
    }, source, scene, rootUrl);
  };
  Object.defineProperty(StandardMaterial2, "DiffuseTextureEnabled", {
    get: function() {
      return MaterialFlags.DiffuseTextureEnabled;
    },
    set: function(value) {
      MaterialFlags.DiffuseTextureEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2, "DetailTextureEnabled", {
    get: function() {
      return MaterialFlags.DetailTextureEnabled;
    },
    set: function(value) {
      MaterialFlags.DetailTextureEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2, "AmbientTextureEnabled", {
    get: function() {
      return MaterialFlags.AmbientTextureEnabled;
    },
    set: function(value) {
      MaterialFlags.AmbientTextureEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2, "OpacityTextureEnabled", {
    get: function() {
      return MaterialFlags.OpacityTextureEnabled;
    },
    set: function(value) {
      MaterialFlags.OpacityTextureEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2, "ReflectionTextureEnabled", {
    get: function() {
      return MaterialFlags.ReflectionTextureEnabled;
    },
    set: function(value) {
      MaterialFlags.ReflectionTextureEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2, "EmissiveTextureEnabled", {
    get: function() {
      return MaterialFlags.EmissiveTextureEnabled;
    },
    set: function(value) {
      MaterialFlags.EmissiveTextureEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2, "SpecularTextureEnabled", {
    get: function() {
      return MaterialFlags.SpecularTextureEnabled;
    },
    set: function(value) {
      MaterialFlags.SpecularTextureEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2, "BumpTextureEnabled", {
    get: function() {
      return MaterialFlags.BumpTextureEnabled;
    },
    set: function(value) {
      MaterialFlags.BumpTextureEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2, "LightmapTextureEnabled", {
    get: function() {
      return MaterialFlags.LightmapTextureEnabled;
    },
    set: function(value) {
      MaterialFlags.LightmapTextureEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2, "RefractionTextureEnabled", {
    get: function() {
      return MaterialFlags.RefractionTextureEnabled;
    },
    set: function(value) {
      MaterialFlags.RefractionTextureEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2, "ColorGradingTextureEnabled", {
    get: function() {
      return MaterialFlags.ColorGradingTextureEnabled;
    },
    set: function(value) {
      MaterialFlags.ColorGradingTextureEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2, "FresnelEnabled", {
    get: function() {
      return MaterialFlags.FresnelEnabled;
    },
    set: function(value) {
      MaterialFlags.FresnelEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  __decorate([
    serializeAsTexture("diffuseTexture")
  ], StandardMaterial2.prototype, "_diffuseTexture", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
  ], StandardMaterial2.prototype, "diffuseTexture", void 0);
  __decorate([
    serializeAsTexture("ambientTexture")
  ], StandardMaterial2.prototype, "_ambientTexture", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "ambientTexture", void 0);
  __decorate([
    serializeAsTexture("opacityTexture")
  ], StandardMaterial2.prototype, "_opacityTexture", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
  ], StandardMaterial2.prototype, "opacityTexture", void 0);
  __decorate([
    serializeAsTexture("reflectionTexture")
  ], StandardMaterial2.prototype, "_reflectionTexture", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "reflectionTexture", void 0);
  __decorate([
    serializeAsTexture("emissiveTexture")
  ], StandardMaterial2.prototype, "_emissiveTexture", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "emissiveTexture", void 0);
  __decorate([
    serializeAsTexture("specularTexture")
  ], StandardMaterial2.prototype, "_specularTexture", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "specularTexture", void 0);
  __decorate([
    serializeAsTexture("bumpTexture")
  ], StandardMaterial2.prototype, "_bumpTexture", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "bumpTexture", void 0);
  __decorate([
    serializeAsTexture("lightmapTexture")
  ], StandardMaterial2.prototype, "_lightmapTexture", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "lightmapTexture", void 0);
  __decorate([
    serializeAsTexture("refractionTexture")
  ], StandardMaterial2.prototype, "_refractionTexture", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "refractionTexture", void 0);
  __decorate([
    serializeAsColor3("ambient")
  ], StandardMaterial2.prototype, "ambientColor", void 0);
  __decorate([
    serializeAsColor3("diffuse")
  ], StandardMaterial2.prototype, "diffuseColor", void 0);
  __decorate([
    serializeAsColor3("specular")
  ], StandardMaterial2.prototype, "specularColor", void 0);
  __decorate([
    serializeAsColor3("emissive")
  ], StandardMaterial2.prototype, "emissiveColor", void 0);
  __decorate([
    serialize()
  ], StandardMaterial2.prototype, "specularPower", void 0);
  __decorate([
    serialize("useAlphaFromDiffuseTexture")
  ], StandardMaterial2.prototype, "_useAlphaFromDiffuseTexture", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
  ], StandardMaterial2.prototype, "useAlphaFromDiffuseTexture", void 0);
  __decorate([
    serialize("useEmissiveAsIllumination")
  ], StandardMaterial2.prototype, "_useEmissiveAsIllumination", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "useEmissiveAsIllumination", void 0);
  __decorate([
    serialize("linkEmissiveWithDiffuse")
  ], StandardMaterial2.prototype, "_linkEmissiveWithDiffuse", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "linkEmissiveWithDiffuse", void 0);
  __decorate([
    serialize("useSpecularOverAlpha")
  ], StandardMaterial2.prototype, "_useSpecularOverAlpha", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "useSpecularOverAlpha", void 0);
  __decorate([
    serialize("useReflectionOverAlpha")
  ], StandardMaterial2.prototype, "_useReflectionOverAlpha", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "useReflectionOverAlpha", void 0);
  __decorate([
    serialize("disableLighting")
  ], StandardMaterial2.prototype, "_disableLighting", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsLightsDirty")
  ], StandardMaterial2.prototype, "disableLighting", void 0);
  __decorate([
    serialize("useObjectSpaceNormalMap")
  ], StandardMaterial2.prototype, "_useObjectSpaceNormalMap", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "useObjectSpaceNormalMap", void 0);
  __decorate([
    serialize("useParallax")
  ], StandardMaterial2.prototype, "_useParallax", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "useParallax", void 0);
  __decorate([
    serialize("useParallaxOcclusion")
  ], StandardMaterial2.prototype, "_useParallaxOcclusion", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "useParallaxOcclusion", void 0);
  __decorate([
    serialize()
  ], StandardMaterial2.prototype, "parallaxScaleBias", void 0);
  __decorate([
    serialize("roughness")
  ], StandardMaterial2.prototype, "_roughness", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "roughness", void 0);
  __decorate([
    serialize()
  ], StandardMaterial2.prototype, "indexOfRefraction", void 0);
  __decorate([
    serialize()
  ], StandardMaterial2.prototype, "invertRefractionY", void 0);
  __decorate([
    serialize()
  ], StandardMaterial2.prototype, "alphaCutOff", void 0);
  __decorate([
    serialize("useLightmapAsShadowmap")
  ], StandardMaterial2.prototype, "_useLightmapAsShadowmap", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "useLightmapAsShadowmap", void 0);
  __decorate([
    serializeAsFresnelParameters("diffuseFresnelParameters")
  ], StandardMaterial2.prototype, "_diffuseFresnelParameters", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsFresnelDirty")
  ], StandardMaterial2.prototype, "diffuseFresnelParameters", void 0);
  __decorate([
    serializeAsFresnelParameters("opacityFresnelParameters")
  ], StandardMaterial2.prototype, "_opacityFresnelParameters", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsFresnelAndMiscDirty")
  ], StandardMaterial2.prototype, "opacityFresnelParameters", void 0);
  __decorate([
    serializeAsFresnelParameters("reflectionFresnelParameters")
  ], StandardMaterial2.prototype, "_reflectionFresnelParameters", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsFresnelDirty")
  ], StandardMaterial2.prototype, "reflectionFresnelParameters", void 0);
  __decorate([
    serializeAsFresnelParameters("refractionFresnelParameters")
  ], StandardMaterial2.prototype, "_refractionFresnelParameters", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsFresnelDirty")
  ], StandardMaterial2.prototype, "refractionFresnelParameters", void 0);
  __decorate([
    serializeAsFresnelParameters("emissiveFresnelParameters")
  ], StandardMaterial2.prototype, "_emissiveFresnelParameters", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsFresnelDirty")
  ], StandardMaterial2.prototype, "emissiveFresnelParameters", void 0);
  __decorate([
    serialize("useReflectionFresnelFromSpecular")
  ], StandardMaterial2.prototype, "_useReflectionFresnelFromSpecular", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsFresnelDirty")
  ], StandardMaterial2.prototype, "useReflectionFresnelFromSpecular", void 0);
  __decorate([
    serialize("useGlossinessFromSpecularMapAlpha")
  ], StandardMaterial2.prototype, "_useGlossinessFromSpecularMapAlpha", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "useGlossinessFromSpecularMapAlpha", void 0);
  __decorate([
    serialize("maxSimultaneousLights")
  ], StandardMaterial2.prototype, "_maxSimultaneousLights", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsLightsDirty")
  ], StandardMaterial2.prototype, "maxSimultaneousLights", void 0);
  __decorate([
    serialize("invertNormalMapX")
  ], StandardMaterial2.prototype, "_invertNormalMapX", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "invertNormalMapX", void 0);
  __decorate([
    serialize("invertNormalMapY")
  ], StandardMaterial2.prototype, "_invertNormalMapY", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "invertNormalMapY", void 0);
  __decorate([
    serialize("twoSidedLighting")
  ], StandardMaterial2.prototype, "_twoSidedLighting", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "twoSidedLighting", void 0);
  __decorate([
    serialize()
  ], StandardMaterial2.prototype, "useLogarithmicDepth", null);
  return StandardMaterial2;
}(PushMaterial);
_TypeStore.RegisteredTypes["BABYLON.StandardMaterial"] = StandardMaterial;
Scene.DefaultMaterialFactory = function(scene) {
  return new StandardMaterial("default material", scene);
};

// node_modules/@babylonjs/core/Engines/constants.js
var Constants = function() {
  function Constants2() {
  }
  Constants2.ALPHA_DISABLE = 0;
  Constants2.ALPHA_ADD = 1;
  Constants2.ALPHA_COMBINE = 2;
  Constants2.ALPHA_SUBTRACT = 3;
  Constants2.ALPHA_MULTIPLY = 4;
  Constants2.ALPHA_MAXIMIZED = 5;
  Constants2.ALPHA_ONEONE = 6;
  Constants2.ALPHA_PREMULTIPLIED = 7;
  Constants2.ALPHA_PREMULTIPLIED_PORTERDUFF = 8;
  Constants2.ALPHA_INTERPOLATE = 9;
  Constants2.ALPHA_SCREENMODE = 10;
  Constants2.ALPHA_ONEONE_ONEONE = 11;
  Constants2.ALPHA_ALPHATOCOLOR = 12;
  Constants2.ALPHA_REVERSEONEMINUS = 13;
  Constants2.ALPHA_SRC_DSTONEMINUSSRCALPHA = 14;
  Constants2.ALPHA_ONEONE_ONEZERO = 15;
  Constants2.ALPHA_EXCLUSION = 16;
  Constants2.ALPHA_EQUATION_ADD = 0;
  Constants2.ALPHA_EQUATION_SUBSTRACT = 1;
  Constants2.ALPHA_EQUATION_REVERSE_SUBTRACT = 2;
  Constants2.ALPHA_EQUATION_MAX = 3;
  Constants2.ALPHA_EQUATION_MIN = 4;
  Constants2.ALPHA_EQUATION_DARKEN = 5;
  Constants2.DELAYLOADSTATE_NONE = 0;
  Constants2.DELAYLOADSTATE_LOADED = 1;
  Constants2.DELAYLOADSTATE_LOADING = 2;
  Constants2.DELAYLOADSTATE_NOTLOADED = 4;
  Constants2.NEVER = 512;
  Constants2.ALWAYS = 519;
  Constants2.LESS = 513;
  Constants2.EQUAL = 514;
  Constants2.LEQUAL = 515;
  Constants2.GREATER = 516;
  Constants2.GEQUAL = 518;
  Constants2.NOTEQUAL = 517;
  Constants2.KEEP = 7680;
  Constants2.REPLACE = 7681;
  Constants2.INCR = 7682;
  Constants2.DECR = 7683;
  Constants2.INVERT = 5386;
  Constants2.INCR_WRAP = 34055;
  Constants2.DECR_WRAP = 34056;
  Constants2.TEXTURE_CLAMP_ADDRESSMODE = 0;
  Constants2.TEXTURE_WRAP_ADDRESSMODE = 1;
  Constants2.TEXTURE_MIRROR_ADDRESSMODE = 2;
  Constants2.TEXTUREFORMAT_ALPHA = 0;
  Constants2.TEXTUREFORMAT_LUMINANCE = 1;
  Constants2.TEXTUREFORMAT_LUMINANCE_ALPHA = 2;
  Constants2.TEXTUREFORMAT_RGB = 4;
  Constants2.TEXTUREFORMAT_RGBA = 5;
  Constants2.TEXTUREFORMAT_RED = 6;
  Constants2.TEXTUREFORMAT_R = 6;
  Constants2.TEXTUREFORMAT_RG = 7;
  Constants2.TEXTUREFORMAT_RED_INTEGER = 8;
  Constants2.TEXTUREFORMAT_R_INTEGER = 8;
  Constants2.TEXTUREFORMAT_RG_INTEGER = 9;
  Constants2.TEXTUREFORMAT_RGB_INTEGER = 10;
  Constants2.TEXTUREFORMAT_RGBA_INTEGER = 11;
  Constants2.TEXTURETYPE_UNSIGNED_BYTE = 0;
  Constants2.TEXTURETYPE_UNSIGNED_INT = 0;
  Constants2.TEXTURETYPE_FLOAT = 1;
  Constants2.TEXTURETYPE_HALF_FLOAT = 2;
  Constants2.TEXTURETYPE_BYTE = 3;
  Constants2.TEXTURETYPE_SHORT = 4;
  Constants2.TEXTURETYPE_UNSIGNED_SHORT = 5;
  Constants2.TEXTURETYPE_INT = 6;
  Constants2.TEXTURETYPE_UNSIGNED_INTEGER = 7;
  Constants2.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 = 8;
  Constants2.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 = 9;
  Constants2.TEXTURETYPE_UNSIGNED_SHORT_5_6_5 = 10;
  Constants2.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV = 11;
  Constants2.TEXTURETYPE_UNSIGNED_INT_24_8 = 12;
  Constants2.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV = 13;
  Constants2.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV = 14;
  Constants2.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV = 15;
  Constants2.TEXTURE_NEAREST_SAMPLINGMODE = 1;
  Constants2.TEXTURE_NEAREST_NEAREST = 1;
  Constants2.TEXTURE_BILINEAR_SAMPLINGMODE = 2;
  Constants2.TEXTURE_LINEAR_LINEAR = 2;
  Constants2.TEXTURE_TRILINEAR_SAMPLINGMODE = 3;
  Constants2.TEXTURE_LINEAR_LINEAR_MIPLINEAR = 3;
  Constants2.TEXTURE_NEAREST_NEAREST_MIPNEAREST = 4;
  Constants2.TEXTURE_NEAREST_LINEAR_MIPNEAREST = 5;
  Constants2.TEXTURE_NEAREST_LINEAR_MIPLINEAR = 6;
  Constants2.TEXTURE_NEAREST_LINEAR = 7;
  Constants2.TEXTURE_NEAREST_NEAREST_MIPLINEAR = 8;
  Constants2.TEXTURE_LINEAR_NEAREST_MIPNEAREST = 9;
  Constants2.TEXTURE_LINEAR_NEAREST_MIPLINEAR = 10;
  Constants2.TEXTURE_LINEAR_LINEAR_MIPNEAREST = 11;
  Constants2.TEXTURE_LINEAR_NEAREST = 12;
  Constants2.TEXTURE_EXPLICIT_MODE = 0;
  Constants2.TEXTURE_SPHERICAL_MODE = 1;
  Constants2.TEXTURE_PLANAR_MODE = 2;
  Constants2.TEXTURE_CUBIC_MODE = 3;
  Constants2.TEXTURE_PROJECTION_MODE = 4;
  Constants2.TEXTURE_SKYBOX_MODE = 5;
  Constants2.TEXTURE_INVCUBIC_MODE = 6;
  Constants2.TEXTURE_EQUIRECTANGULAR_MODE = 7;
  Constants2.TEXTURE_FIXED_EQUIRECTANGULAR_MODE = 8;
  Constants2.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;
  Constants2.TEXTURE_FILTERING_QUALITY_OFFLINE = 4096;
  Constants2.TEXTURE_FILTERING_QUALITY_HIGH = 64;
  Constants2.TEXTURE_FILTERING_QUALITY_MEDIUM = 16;
  Constants2.TEXTURE_FILTERING_QUALITY_LOW = 8;
  Constants2.SCALEMODE_FLOOR = 1;
  Constants2.SCALEMODE_NEAREST = 2;
  Constants2.SCALEMODE_CEILING = 3;
  Constants2.MATERIAL_TextureDirtyFlag = 1;
  Constants2.MATERIAL_LightDirtyFlag = 2;
  Constants2.MATERIAL_FresnelDirtyFlag = 4;
  Constants2.MATERIAL_AttributesDirtyFlag = 8;
  Constants2.MATERIAL_MiscDirtyFlag = 16;
  Constants2.MATERIAL_PrePassDirtyFlag = 32;
  Constants2.MATERIAL_AllDirtyFlag = 63;
  Constants2.MATERIAL_TriangleFillMode = 0;
  Constants2.MATERIAL_WireFrameFillMode = 1;
  Constants2.MATERIAL_PointFillMode = 2;
  Constants2.MATERIAL_PointListDrawMode = 3;
  Constants2.MATERIAL_LineListDrawMode = 4;
  Constants2.MATERIAL_LineLoopDrawMode = 5;
  Constants2.MATERIAL_LineStripDrawMode = 6;
  Constants2.MATERIAL_TriangleStripDrawMode = 7;
  Constants2.MATERIAL_TriangleFanDrawMode = 8;
  Constants2.MATERIAL_ClockWiseSideOrientation = 0;
  Constants2.MATERIAL_CounterClockWiseSideOrientation = 1;
  Constants2.ACTION_NothingTrigger = 0;
  Constants2.ACTION_OnPickTrigger = 1;
  Constants2.ACTION_OnLeftPickTrigger = 2;
  Constants2.ACTION_OnRightPickTrigger = 3;
  Constants2.ACTION_OnCenterPickTrigger = 4;
  Constants2.ACTION_OnPickDownTrigger = 5;
  Constants2.ACTION_OnDoublePickTrigger = 6;
  Constants2.ACTION_OnPickUpTrigger = 7;
  Constants2.ACTION_OnPickOutTrigger = 16;
  Constants2.ACTION_OnLongPressTrigger = 8;
  Constants2.ACTION_OnPointerOverTrigger = 9;
  Constants2.ACTION_OnPointerOutTrigger = 10;
  Constants2.ACTION_OnEveryFrameTrigger = 11;
  Constants2.ACTION_OnIntersectionEnterTrigger = 12;
  Constants2.ACTION_OnIntersectionExitTrigger = 13;
  Constants2.ACTION_OnKeyDownTrigger = 14;
  Constants2.ACTION_OnKeyUpTrigger = 15;
  Constants2.PARTICLES_BILLBOARDMODE_Y = 2;
  Constants2.PARTICLES_BILLBOARDMODE_ALL = 7;
  Constants2.PARTICLES_BILLBOARDMODE_STRETCHED = 8;
  Constants2.MESHES_CULLINGSTRATEGY_STANDARD = 0;
  Constants2.MESHES_CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1;
  Constants2.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = 2;
  Constants2.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = 3;
  Constants2.SCENELOADER_NO_LOGGING = 0;
  Constants2.SCENELOADER_MINIMAL_LOGGING = 1;
  Constants2.SCENELOADER_SUMMARY_LOGGING = 2;
  Constants2.SCENELOADER_DETAILED_LOGGING = 3;
  Constants2.PREPASS_IRRADIANCE_TEXTURE_TYPE = 0;
  Constants2.PREPASS_POSITION_TEXTURE_TYPE = 1;
  Constants2.PREPASS_VELOCITY_TEXTURE_TYPE = 2;
  Constants2.PREPASS_REFLECTIVITY_TEXTURE_TYPE = 3;
  Constants2.PREPASS_COLOR_TEXTURE_TYPE = 4;
  Constants2.PREPASS_DEPTHNORMAL_TEXTURE_TYPE = 5;
  Constants2.PREPASS_ALBEDO_TEXTURE_TYPE = 6;
  return Constants2;
}();

export {
  __export,
  AbstractScene,
  AbstractActionManager,
  EventState,
  Observer,
  MultiObserver,
  Observable,
  Scalar,
  ToGammaSpace,
  ToLinearSpace,
  Epsilon,
  ArrayTools,
  _TypeStore,
  PerformanceConfigurator,
  Vector2,
  Vector3,
  Vector4,
  Quaternion,
  Matrix,
  TmpVectors,
  Color3,
  Color4,
  TmpColors,
  ActionEvent,
  __extends,
  __assign,
  __decorate,
  __awaiter,
  __generator,
  __spreadArrays,
  Logger,
  EngineStore,
  StringTools,
  DeepCopier,
  AndOrNotEvaluator,
  Tags,
  _DevTools,
  expandToProperty,
  serialize,
  serializeAsTexture,
  serializeAsColor3,
  serializeAsFresnelParameters,
  serializeAsVector2,
  serializeAsVector3,
  serializeAsMeshReference,
  serializeAsColorCurves,
  serializeAsColor4,
  serializeAsImageProcessingConfiguration,
  serializeAsQuaternion,
  serializeAsMatrix,
  serializeAsCameraReference,
  SerializationHelper,
  Node,
  Size,
  WebRequest,
  DomManagement,
  PrecisionDate,
  FilesInputStore,
  RetryStrategy,
  Effect,
  DepthCullingState,
  StencilState,
  AlphaState,
  RenderTargetCreationOptions,
  InternalTextureSource,
  InternalTexture,
  WebGL2ShaderProcessor,
  DataBuffer,
  WebGLDataBuffer,
  WebGLPipelineContext,
  CanvasGenerator,
  ThinEngine,
  LoadFileError,
  RequestFileError,
  ReadFileError,
  FileTools,
  PromisePolyfill,
  TimingTools,
  GUID,
  Tools,
  className,
  AsyncLoop,
  SmartArray,
  SmartArrayNoDuplicate,
  StringDictionary,
  Space,
  Axis,
  Coordinate,
  TransformNode,
  PerformanceMonitor,
  RollingAverage,
  PerfCounter,
  Engine,
  Buffer2 as Buffer,
  VertexBuffer,
  VertexData,
  PickingInfo,
  BoundingBox,
  BoundingSphere,
  BoundingInfo,
  _MeshCollisionData,
  extractMinAndMaxIndexed,
  extractMinAndMax,
  AbstractMesh,
  Viewport,
  Plane,
  Frustum,
  Camera,
  MaterialDefines,
  ColorCurves,
  ImageProcessingConfigurationDefines,
  ImageProcessingConfiguration,
  UniformBuffer,
  Light,
  IntersectionInfo,
  SubMesh,
  Material,
  PostProcessManager,
  RenderingGroup,
  RenderingGroupInfo,
  RenderingManager,
  SceneComponentConstants,
  Stage,
  PointerEventTypes,
  PointerInfoBase,
  PointerInfoPre,
  PointerInfo,
  KeyboardEventTypes,
  KeyboardInfo,
  KeyboardInfoPre,
  UniqueIdGenerator,
  Scene,
  SceneLoaderFlags,
  Geometry,
  MultiMaterial,
  MeshLODLevel,
  _CreationDataStorage,
  _InstancesBatch,
  Mesh,
  BaseTexture,
  CopyTools,
  Texture,
  HemisphericLight,
  PrePassConfiguration,
  PushMaterial,
  ThinMaterialHelper,
  MaterialHelper,
  MaterialFlags,
  EffectFallbacks,
  DetailMapConfiguration,
  StandardMaterialDefines,
  StandardMaterial,
  Constants
};
//# sourceMappingURL=chunk-FSGEGJV4.js.map
