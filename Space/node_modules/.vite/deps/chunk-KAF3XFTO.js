import {
  AbstractScene,
  ArrayTools,
  Axis,
  BaseTexture,
  Camera,
  Color3,
  Color4,
  Coordinate,
  DeepCopier,
  DetailMapConfiguration,
  Effect,
  EffectFallbacks,
  Engine,
  EngineStore,
  Epsilon,
  FileTools,
  FilesInputStore,
  ImageProcessingConfiguration,
  InternalTexture,
  InternalTextureSource,
  KeyboardEventTypes,
  Light,
  Logger,
  Material,
  MaterialDefines,
  MaterialFlags,
  MaterialHelper,
  Matrix,
  Mesh,
  Node,
  Observable,
  PointerEventTypes,
  PostProcessManager,
  PrePassConfiguration,
  PrecisionDate,
  PushMaterial,
  Quaternion,
  RenderTargetCreationOptions,
  RenderingManager,
  Scalar,
  Scene,
  SceneLoaderFlags,
  SerializationHelper,
  Size,
  SmartArray,
  Space,
  StringTools,
  Texture,
  ThinEngine,
  TmpColors,
  TmpVectors,
  ToLinearSpace,
  Tools,
  Vector2,
  Vector3,
  Vector4,
  VertexBuffer,
  VertexData,
  WebRequest,
  _DevTools,
  _TypeStore,
  __assign,
  __decorate,
  __extends,
  expandToProperty,
  serialize,
  serializeAsColor3,
  serializeAsColor4,
  serializeAsImageProcessingConfiguration,
  serializeAsMatrix,
  serializeAsMeshReference,
  serializeAsTexture,
  serializeAsVector2,
  serializeAsVector3
} from "./chunk-FSGEGJV4.js";

// node_modules/@babylonjs/core/Animations/animationKey.js
var AnimationKeyInterpolation;
(function(AnimationKeyInterpolation2) {
  AnimationKeyInterpolation2[AnimationKeyInterpolation2["STEP"] = 1] = "STEP";
})(AnimationKeyInterpolation || (AnimationKeyInterpolation = {}));

// node_modules/@babylonjs/core/Animations/animationRange.js
var AnimationRange = function() {
  function AnimationRange2(name42, from, to) {
    this.name = name42;
    this.from = from;
    this.to = to;
  }
  AnimationRange2.prototype.clone = function() {
    return new AnimationRange2(this.name, this.from, this.to);
  };
  return AnimationRange2;
}();

// node_modules/@babylonjs/core/Animations/animation.js
var _IAnimationState = function() {
  function _IAnimationState2() {
  }
  return _IAnimationState2;
}();
var Animation = function() {
  function Animation2(name42, targetProperty, framePerSecond, dataType, loopMode, enableBlending) {
    this.name = name42;
    this.targetProperty = targetProperty;
    this.framePerSecond = framePerSecond;
    this.dataType = dataType;
    this.loopMode = loopMode;
    this.enableBlending = enableBlending;
    this._runtimeAnimations = new Array();
    this._events = new Array();
    this.blendingSpeed = 0.01;
    this._ranges = {};
    this.targetPropertyPath = targetProperty.split(".");
    this.dataType = dataType;
    this.loopMode = loopMode === void 0 ? Animation2.ANIMATIONLOOPMODE_CYCLE : loopMode;
  }
  Animation2._PrepareAnimation = function(name42, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction) {
    var dataType = void 0;
    if (!isNaN(parseFloat(from)) && isFinite(from)) {
      dataType = Animation2.ANIMATIONTYPE_FLOAT;
    } else if (from instanceof Quaternion) {
      dataType = Animation2.ANIMATIONTYPE_QUATERNION;
    } else if (from instanceof Vector3) {
      dataType = Animation2.ANIMATIONTYPE_VECTOR3;
    } else if (from instanceof Vector2) {
      dataType = Animation2.ANIMATIONTYPE_VECTOR2;
    } else if (from instanceof Color3) {
      dataType = Animation2.ANIMATIONTYPE_COLOR3;
    } else if (from instanceof Color4) {
      dataType = Animation2.ANIMATIONTYPE_COLOR4;
    } else if (from instanceof Size) {
      dataType = Animation2.ANIMATIONTYPE_SIZE;
    }
    if (dataType == void 0) {
      return null;
    }
    var animation = new Animation2(name42, targetProperty, framePerSecond, dataType, loopMode);
    var keys = [{ frame: 0, value: from }, { frame: totalFrame, value: to }];
    animation.setKeys(keys);
    if (easingFunction !== void 0) {
      animation.setEasingFunction(easingFunction);
    }
    return animation;
  };
  Animation2.CreateAnimation = function(property, animationType, framePerSecond, easingFunction) {
    var animation = new Animation2(property + "Animation", property, framePerSecond, animationType, Animation2.ANIMATIONLOOPMODE_CONSTANT);
    animation.setEasingFunction(easingFunction);
    return animation;
  };
  Animation2.CreateAndStartAnimation = function(name42, node, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {
    var animation = Animation2._PrepareAnimation(name42, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);
    if (!animation) {
      return null;
    }
    return node.getScene().beginDirectAnimation(node, [animation], 0, totalFrame, animation.loopMode === 1, 1, onAnimationEnd);
  };
  Animation2.CreateAndStartHierarchyAnimation = function(name42, node, directDescendantsOnly, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {
    var animation = Animation2._PrepareAnimation(name42, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);
    if (!animation) {
      return null;
    }
    var scene = node.getScene();
    return scene.beginDirectHierarchyAnimation(node, directDescendantsOnly, [animation], 0, totalFrame, animation.loopMode === 1, 1, onAnimationEnd);
  };
  Animation2.CreateMergeAndStartAnimation = function(name42, node, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {
    var animation = Animation2._PrepareAnimation(name42, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);
    if (!animation) {
      return null;
    }
    node.animations.push(animation);
    return node.getScene().beginAnimation(node, 0, totalFrame, animation.loopMode === 1, 1, onAnimationEnd);
  };
  Animation2.MakeAnimationAdditive = function(sourceAnimation, referenceFrame, range, cloneOriginal, clonedName) {
    if (referenceFrame === void 0) {
      referenceFrame = 0;
    }
    if (cloneOriginal === void 0) {
      cloneOriginal = false;
    }
    var animation = sourceAnimation;
    if (cloneOriginal) {
      animation = sourceAnimation.clone();
      animation.name = clonedName || animation.name;
    }
    if (!animation._keys.length) {
      return animation;
    }
    referenceFrame = referenceFrame >= 0 ? referenceFrame : 0;
    var startIndex = 0;
    var firstKey = animation._keys[0];
    var endIndex = animation._keys.length - 1;
    var lastKey = animation._keys[endIndex];
    var valueStore = {
      referenceValue: firstKey.value,
      referencePosition: TmpVectors.Vector3[0],
      referenceQuaternion: TmpVectors.Quaternion[0],
      referenceScaling: TmpVectors.Vector3[1],
      keyPosition: TmpVectors.Vector3[2],
      keyQuaternion: TmpVectors.Quaternion[1],
      keyScaling: TmpVectors.Vector3[3]
    };
    var referenceFound = false;
    var from = firstKey.frame;
    var to = lastKey.frame;
    if (range) {
      var rangeValue = animation.getRange(range);
      if (rangeValue) {
        from = rangeValue.from;
        to = rangeValue.to;
      }
    }
    var fromKeyFound = firstKey.frame === from;
    var toKeyFound = lastKey.frame === to;
    if (animation._keys.length === 1) {
      var value = animation._getKeyValue(animation._keys[0]);
      valueStore.referenceValue = value.clone ? value.clone() : value;
      referenceFound = true;
    } else if (referenceFrame <= firstKey.frame) {
      var value = animation._getKeyValue(firstKey.value);
      valueStore.referenceValue = value.clone ? value.clone() : value;
      referenceFound = true;
    } else if (referenceFrame >= lastKey.frame) {
      var value = animation._getKeyValue(lastKey.value);
      valueStore.referenceValue = value.clone ? value.clone() : value;
      referenceFound = true;
    }
    var index = 0;
    while (!referenceFound || !fromKeyFound || !toKeyFound && index < animation._keys.length - 1) {
      var currentKey = animation._keys[index];
      var nextKey = animation._keys[index + 1];
      if (!referenceFound && referenceFrame >= currentKey.frame && referenceFrame <= nextKey.frame) {
        var value = void 0;
        if (referenceFrame === currentKey.frame) {
          value = animation._getKeyValue(currentKey.value);
        } else if (referenceFrame === nextKey.frame) {
          value = animation._getKeyValue(nextKey.value);
        } else {
          var animationState = {
            key: index,
            repeatCount: 0,
            loopMode: this.ANIMATIONLOOPMODE_CONSTANT
          };
          value = animation._interpolate(referenceFrame, animationState);
        }
        valueStore.referenceValue = value.clone ? value.clone() : value;
        referenceFound = true;
      }
      if (!fromKeyFound && from >= currentKey.frame && from <= nextKey.frame) {
        if (from === currentKey.frame) {
          startIndex = index;
        } else if (from === nextKey.frame) {
          startIndex = index + 1;
        } else {
          var animationState = {
            key: index,
            repeatCount: 0,
            loopMode: this.ANIMATIONLOOPMODE_CONSTANT
          };
          var value = animation._interpolate(from, animationState);
          var key = {
            frame: from,
            value: value.clone ? value.clone() : value
          };
          animation._keys.splice(index + 1, 0, key);
          startIndex = index + 1;
        }
        fromKeyFound = true;
      }
      if (!toKeyFound && to >= currentKey.frame && to <= nextKey.frame) {
        if (to === currentKey.frame) {
          endIndex = index;
        } else if (to === nextKey.frame) {
          endIndex = index + 1;
        } else {
          var animationState = {
            key: index,
            repeatCount: 0,
            loopMode: this.ANIMATIONLOOPMODE_CONSTANT
          };
          var value = animation._interpolate(to, animationState);
          var key = {
            frame: to,
            value: value.clone ? value.clone() : value
          };
          animation._keys.splice(index + 1, 0, key);
          endIndex = index + 1;
        }
        toKeyFound = true;
      }
      index++;
    }
    if (animation.dataType === Animation2.ANIMATIONTYPE_QUATERNION) {
      valueStore.referenceValue.normalize().conjugateInPlace();
    } else if (animation.dataType === Animation2.ANIMATIONTYPE_MATRIX) {
      valueStore.referenceValue.decompose(valueStore.referenceScaling, valueStore.referenceQuaternion, valueStore.referencePosition);
      valueStore.referenceQuaternion.normalize().conjugateInPlace();
    }
    for (var index = startIndex; index <= endIndex; index++) {
      var key = animation._keys[index];
      if (index && animation.dataType !== Animation2.ANIMATIONTYPE_FLOAT && key.value === firstKey.value) {
        continue;
      }
      switch (animation.dataType) {
        case Animation2.ANIMATIONTYPE_MATRIX:
          key.value.decompose(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition);
          valueStore.keyPosition.subtractInPlace(valueStore.referencePosition);
          valueStore.keyScaling.divideInPlace(valueStore.referenceScaling);
          valueStore.referenceQuaternion.multiplyToRef(valueStore.keyQuaternion, valueStore.keyQuaternion);
          Matrix.ComposeToRef(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition, key.value);
          break;
        case Animation2.ANIMATIONTYPE_QUATERNION:
          valueStore.referenceValue.multiplyToRef(key.value, key.value);
          break;
        case Animation2.ANIMATIONTYPE_VECTOR2:
        case Animation2.ANIMATIONTYPE_VECTOR3:
        case Animation2.ANIMATIONTYPE_COLOR3:
        case Animation2.ANIMATIONTYPE_COLOR4:
          key.value.subtractToRef(valueStore.referenceValue, key.value);
          break;
        case Animation2.ANIMATIONTYPE_SIZE:
          key.value.width -= valueStore.referenceValue.width;
          key.value.height -= valueStore.referenceValue.height;
          break;
        default:
          key.value -= valueStore.referenceValue;
      }
    }
    return animation;
  };
  Animation2.TransitionTo = function(property, targetValue, host, scene, frameRate, transition, duration, onAnimationEnd) {
    if (onAnimationEnd === void 0) {
      onAnimationEnd = null;
    }
    if (duration <= 0) {
      host[property] = targetValue;
      if (onAnimationEnd) {
        onAnimationEnd();
      }
      return null;
    }
    var endFrame = frameRate * (duration / 1e3);
    transition.setKeys([
      {
        frame: 0,
        value: host[property].clone ? host[property].clone() : host[property]
      },
      {
        frame: endFrame,
        value: targetValue
      }
    ]);
    if (!host.animations) {
      host.animations = [];
    }
    host.animations.push(transition);
    var animation = scene.beginAnimation(host, 0, endFrame, false);
    animation.onAnimationEnd = onAnimationEnd;
    return animation;
  };
  Object.defineProperty(Animation2.prototype, "runtimeAnimations", {
    get: function() {
      return this._runtimeAnimations;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Animation2.prototype, "hasRunningRuntimeAnimations", {
    get: function() {
      for (var _i = 0, _a = this._runtimeAnimations; _i < _a.length; _i++) {
        var runtimeAnimation = _a[_i];
        if (!runtimeAnimation.isStopped) {
          return true;
        }
      }
      return false;
    },
    enumerable: false,
    configurable: true
  });
  Animation2.prototype.toString = function(fullDetails) {
    var ret = "Name: " + this.name + ", property: " + this.targetProperty;
    ret += ", datatype: " + ["Float", "Vector3", "Quaternion", "Matrix", "Color3", "Vector2"][this.dataType];
    ret += ", nKeys: " + (this._keys ? this._keys.length : "none");
    ret += ", nRanges: " + (this._ranges ? Object.keys(this._ranges).length : "none");
    if (fullDetails) {
      ret += ", Ranges: {";
      var first = true;
      for (var name42 in this._ranges) {
        if (first) {
          ret += ", ";
          first = false;
        }
        ret += name42;
      }
      ret += "}";
    }
    return ret;
  };
  Animation2.prototype.addEvent = function(event) {
    this._events.push(event);
    this._events.sort(function(a, b) {
      return a.frame - b.frame;
    });
  };
  Animation2.prototype.removeEvents = function(frame) {
    for (var index = 0; index < this._events.length; index++) {
      if (this._events[index].frame === frame) {
        this._events.splice(index, 1);
        index--;
      }
    }
  };
  Animation2.prototype.getEvents = function() {
    return this._events;
  };
  Animation2.prototype.createRange = function(name42, from, to) {
    if (!this._ranges[name42]) {
      this._ranges[name42] = new AnimationRange(name42, from, to);
    }
  };
  Animation2.prototype.deleteRange = function(name42, deleteFrames) {
    if (deleteFrames === void 0) {
      deleteFrames = true;
    }
    var range = this._ranges[name42];
    if (!range) {
      return;
    }
    if (deleteFrames) {
      var from = range.from;
      var to = range.to;
      for (var key = this._keys.length - 1; key >= 0; key--) {
        if (this._keys[key].frame >= from && this._keys[key].frame <= to) {
          this._keys.splice(key, 1);
        }
      }
    }
    this._ranges[name42] = null;
  };
  Animation2.prototype.getRange = function(name42) {
    return this._ranges[name42];
  };
  Animation2.prototype.getKeys = function() {
    return this._keys;
  };
  Animation2.prototype.getHighestFrame = function() {
    var ret = 0;
    for (var key = 0, nKeys = this._keys.length; key < nKeys; key++) {
      if (ret < this._keys[key].frame) {
        ret = this._keys[key].frame;
      }
    }
    return ret;
  };
  Animation2.prototype.getEasingFunction = function() {
    return this._easingFunction;
  };
  Animation2.prototype.setEasingFunction = function(easingFunction) {
    this._easingFunction = easingFunction;
  };
  Animation2.prototype.floatInterpolateFunction = function(startValue, endValue, gradient) {
    return Scalar.Lerp(startValue, endValue, gradient);
  };
  Animation2.prototype.floatInterpolateFunctionWithTangents = function(startValue, outTangent, endValue, inTangent, gradient) {
    return Scalar.Hermite(startValue, outTangent, endValue, inTangent, gradient);
  };
  Animation2.prototype.quaternionInterpolateFunction = function(startValue, endValue, gradient) {
    return Quaternion.Slerp(startValue, endValue, gradient);
  };
  Animation2.prototype.quaternionInterpolateFunctionWithTangents = function(startValue, outTangent, endValue, inTangent, gradient) {
    return Quaternion.Hermite(startValue, outTangent, endValue, inTangent, gradient).normalize();
  };
  Animation2.prototype.vector3InterpolateFunction = function(startValue, endValue, gradient) {
    return Vector3.Lerp(startValue, endValue, gradient);
  };
  Animation2.prototype.vector3InterpolateFunctionWithTangents = function(startValue, outTangent, endValue, inTangent, gradient) {
    return Vector3.Hermite(startValue, outTangent, endValue, inTangent, gradient);
  };
  Animation2.prototype.vector2InterpolateFunction = function(startValue, endValue, gradient) {
    return Vector2.Lerp(startValue, endValue, gradient);
  };
  Animation2.prototype.vector2InterpolateFunctionWithTangents = function(startValue, outTangent, endValue, inTangent, gradient) {
    return Vector2.Hermite(startValue, outTangent, endValue, inTangent, gradient);
  };
  Animation2.prototype.sizeInterpolateFunction = function(startValue, endValue, gradient) {
    return Size.Lerp(startValue, endValue, gradient);
  };
  Animation2.prototype.color3InterpolateFunction = function(startValue, endValue, gradient) {
    return Color3.Lerp(startValue, endValue, gradient);
  };
  Animation2.prototype.color4InterpolateFunction = function(startValue, endValue, gradient) {
    return Color4.Lerp(startValue, endValue, gradient);
  };
  Animation2.prototype._getKeyValue = function(value) {
    if (typeof value === "function") {
      return value();
    }
    return value;
  };
  Animation2.prototype._interpolate = function(currentFrame, state) {
    if (state.loopMode === Animation2.ANIMATIONLOOPMODE_CONSTANT && state.repeatCount > 0) {
      return state.highLimitValue.clone ? state.highLimitValue.clone() : state.highLimitValue;
    }
    var keys = this._keys;
    if (keys.length === 1) {
      return this._getKeyValue(keys[0].value);
    }
    var startKeyIndex = state.key;
    if (keys[startKeyIndex].frame >= currentFrame) {
      while (startKeyIndex - 1 >= 0 && keys[startKeyIndex].frame >= currentFrame) {
        startKeyIndex--;
      }
    }
    for (var key = startKeyIndex; key < keys.length; key++) {
      var endKey = keys[key + 1];
      if (endKey.frame >= currentFrame) {
        state.key = key;
        var startKey = keys[key];
        var startValue = this._getKeyValue(startKey.value);
        if (startKey.interpolation === AnimationKeyInterpolation.STEP) {
          return startValue;
        }
        var endValue = this._getKeyValue(endKey.value);
        var useTangent = startKey.outTangent !== void 0 && endKey.inTangent !== void 0;
        var frameDelta = endKey.frame - startKey.frame;
        var gradient = (currentFrame - startKey.frame) / frameDelta;
        var easingFunction = this.getEasingFunction();
        if (easingFunction != null) {
          gradient = easingFunction.ease(gradient);
        }
        switch (this.dataType) {
          case Animation2.ANIMATIONTYPE_FLOAT:
            var floatValue = useTangent ? this.floatInterpolateFunctionWithTangents(startValue, startKey.outTangent * frameDelta, endValue, endKey.inTangent * frameDelta, gradient) : this.floatInterpolateFunction(startValue, endValue, gradient);
            switch (state.loopMode) {
              case Animation2.ANIMATIONLOOPMODE_CYCLE:
              case Animation2.ANIMATIONLOOPMODE_CONSTANT:
                return floatValue;
              case Animation2.ANIMATIONLOOPMODE_RELATIVE:
                return state.offsetValue * state.repeatCount + floatValue;
            }
            break;
          case Animation2.ANIMATIONTYPE_QUATERNION:
            var quatValue = useTangent ? this.quaternionInterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.quaternionInterpolateFunction(startValue, endValue, gradient);
            switch (state.loopMode) {
              case Animation2.ANIMATIONLOOPMODE_CYCLE:
              case Animation2.ANIMATIONLOOPMODE_CONSTANT:
                return quatValue;
              case Animation2.ANIMATIONLOOPMODE_RELATIVE:
                return quatValue.addInPlace(state.offsetValue.scale(state.repeatCount));
            }
            return quatValue;
          case Animation2.ANIMATIONTYPE_VECTOR3:
            var vec3Value = useTangent ? this.vector3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector3InterpolateFunction(startValue, endValue, gradient);
            switch (state.loopMode) {
              case Animation2.ANIMATIONLOOPMODE_CYCLE:
              case Animation2.ANIMATIONLOOPMODE_CONSTANT:
                return vec3Value;
              case Animation2.ANIMATIONLOOPMODE_RELATIVE:
                return vec3Value.add(state.offsetValue.scale(state.repeatCount));
            }
          case Animation2.ANIMATIONTYPE_VECTOR2:
            var vec2Value = useTangent ? this.vector2InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector2InterpolateFunction(startValue, endValue, gradient);
            switch (state.loopMode) {
              case Animation2.ANIMATIONLOOPMODE_CYCLE:
              case Animation2.ANIMATIONLOOPMODE_CONSTANT:
                return vec2Value;
              case Animation2.ANIMATIONLOOPMODE_RELATIVE:
                return vec2Value.add(state.offsetValue.scale(state.repeatCount));
            }
          case Animation2.ANIMATIONTYPE_SIZE:
            switch (state.loopMode) {
              case Animation2.ANIMATIONLOOPMODE_CYCLE:
              case Animation2.ANIMATIONLOOPMODE_CONSTANT:
                return this.sizeInterpolateFunction(startValue, endValue, gradient);
              case Animation2.ANIMATIONLOOPMODE_RELATIVE:
                return this.sizeInterpolateFunction(startValue, endValue, gradient).add(state.offsetValue.scale(state.repeatCount));
            }
          case Animation2.ANIMATIONTYPE_COLOR3:
            switch (state.loopMode) {
              case Animation2.ANIMATIONLOOPMODE_CYCLE:
              case Animation2.ANIMATIONLOOPMODE_CONSTANT:
                return this.color3InterpolateFunction(startValue, endValue, gradient);
              case Animation2.ANIMATIONLOOPMODE_RELATIVE:
                return this.color3InterpolateFunction(startValue, endValue, gradient).add(state.offsetValue.scale(state.repeatCount));
            }
          case Animation2.ANIMATIONTYPE_COLOR4:
            switch (state.loopMode) {
              case Animation2.ANIMATIONLOOPMODE_CYCLE:
              case Animation2.ANIMATIONLOOPMODE_CONSTANT:
                return this.color4InterpolateFunction(startValue, endValue, gradient);
              case Animation2.ANIMATIONLOOPMODE_RELATIVE:
                return this.color4InterpolateFunction(startValue, endValue, gradient).add(state.offsetValue.scale(state.repeatCount));
            }
          case Animation2.ANIMATIONTYPE_MATRIX:
            switch (state.loopMode) {
              case Animation2.ANIMATIONLOOPMODE_CYCLE:
              case Animation2.ANIMATIONLOOPMODE_CONSTANT:
                if (Animation2.AllowMatricesInterpolation) {
                  return this.matrixInterpolateFunction(startValue, endValue, gradient, state.workValue);
                }
              case Animation2.ANIMATIONLOOPMODE_RELATIVE:
                return startValue;
            }
          default:
            break;
        }
        break;
      }
    }
    return this._getKeyValue(keys[keys.length - 1].value);
  };
  Animation2.prototype.matrixInterpolateFunction = function(startValue, endValue, gradient, result) {
    if (Animation2.AllowMatrixDecomposeForInterpolation) {
      if (result) {
        Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);
        return result;
      }
      return Matrix.DecomposeLerp(startValue, endValue, gradient);
    }
    if (result) {
      Matrix.LerpToRef(startValue, endValue, gradient, result);
      return result;
    }
    return Matrix.Lerp(startValue, endValue, gradient);
  };
  Animation2.prototype.clone = function() {
    var clone = new Animation2(this.name, this.targetPropertyPath.join("."), this.framePerSecond, this.dataType, this.loopMode);
    clone.enableBlending = this.enableBlending;
    clone.blendingSpeed = this.blendingSpeed;
    if (this._keys) {
      clone.setKeys(this._keys);
    }
    if (this._ranges) {
      clone._ranges = {};
      for (var name42 in this._ranges) {
        var range = this._ranges[name42];
        if (!range) {
          continue;
        }
        clone._ranges[name42] = range.clone();
      }
    }
    return clone;
  };
  Animation2.prototype.setKeys = function(values) {
    this._keys = values.slice(0);
  };
  Animation2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.name = this.name;
    serializationObject.property = this.targetProperty;
    serializationObject.framePerSecond = this.framePerSecond;
    serializationObject.dataType = this.dataType;
    serializationObject.loopBehavior = this.loopMode;
    serializationObject.enableBlending = this.enableBlending;
    serializationObject.blendingSpeed = this.blendingSpeed;
    var dataType = this.dataType;
    serializationObject.keys = [];
    var keys = this.getKeys();
    for (var index = 0; index < keys.length; index++) {
      var animationKey = keys[index];
      var key = {};
      key.frame = animationKey.frame;
      switch (dataType) {
        case Animation2.ANIMATIONTYPE_FLOAT:
          key.values = [animationKey.value];
          if (animationKey.inTangent !== void 0) {
            key.values.push(animationKey.inTangent);
          }
          if (animationKey.outTangent !== void 0) {
            if (animationKey.inTangent === void 0) {
              key.values.push(void 0);
            }
            key.values.push(animationKey.outTangent);
          }
          break;
        case Animation2.ANIMATIONTYPE_QUATERNION:
        case Animation2.ANIMATIONTYPE_MATRIX:
        case Animation2.ANIMATIONTYPE_VECTOR3:
        case Animation2.ANIMATIONTYPE_COLOR3:
        case Animation2.ANIMATIONTYPE_COLOR4:
          key.values = animationKey.value.asArray();
          if (animationKey.inTangent != void 0) {
            key.values.push(animationKey.inTangent.asArray());
          }
          if (animationKey.outTangent != void 0) {
            if (animationKey.inTangent === void 0) {
              key.values.push(void 0);
            }
            key.values.push(animationKey.outTangent.asArray());
          }
          break;
      }
      serializationObject.keys.push(key);
    }
    serializationObject.ranges = [];
    for (var name42 in this._ranges) {
      var source = this._ranges[name42];
      if (!source) {
        continue;
      }
      var range = {};
      range.name = name42;
      range.from = source.from;
      range.to = source.to;
      serializationObject.ranges.push(range);
    }
    return serializationObject;
  };
  Animation2._UniversalLerp = function(left, right, amount) {
    var constructor = left.constructor;
    if (constructor.Lerp) {
      return constructor.Lerp(left, right, amount);
    } else if (constructor.Slerp) {
      return constructor.Slerp(left, right, amount);
    } else if (left.toFixed) {
      return left * (1 - amount) + amount * right;
    } else {
      return right;
    }
  };
  Animation2.Parse = function(parsedAnimation) {
    var animation = new Animation2(parsedAnimation.name, parsedAnimation.property, parsedAnimation.framePerSecond, parsedAnimation.dataType, parsedAnimation.loopBehavior);
    var dataType = parsedAnimation.dataType;
    var keys = [];
    var data;
    var index;
    if (parsedAnimation.enableBlending) {
      animation.enableBlending = parsedAnimation.enableBlending;
    }
    if (parsedAnimation.blendingSpeed) {
      animation.blendingSpeed = parsedAnimation.blendingSpeed;
    }
    for (index = 0; index < parsedAnimation.keys.length; index++) {
      var key = parsedAnimation.keys[index];
      var inTangent;
      var outTangent;
      switch (dataType) {
        case Animation2.ANIMATIONTYPE_FLOAT:
          data = key.values[0];
          if (key.values.length >= 1) {
            inTangent = key.values[1];
          }
          if (key.values.length >= 2) {
            outTangent = key.values[2];
          }
          break;
        case Animation2.ANIMATIONTYPE_QUATERNION:
          data = Quaternion.FromArray(key.values);
          if (key.values.length >= 8) {
            var _inTangent = Quaternion.FromArray(key.values.slice(4, 8));
            if (!_inTangent.equals(Quaternion.Zero())) {
              inTangent = _inTangent;
            }
          }
          if (key.values.length >= 12) {
            var _outTangent = Quaternion.FromArray(key.values.slice(8, 12));
            if (!_outTangent.equals(Quaternion.Zero())) {
              outTangent = _outTangent;
            }
          }
          break;
        case Animation2.ANIMATIONTYPE_MATRIX:
          data = Matrix.FromArray(key.values);
          break;
        case Animation2.ANIMATIONTYPE_COLOR3:
          data = Color3.FromArray(key.values);
          break;
        case Animation2.ANIMATIONTYPE_COLOR4:
          data = Color4.FromArray(key.values);
          break;
        case Animation2.ANIMATIONTYPE_VECTOR3:
        default:
          data = Vector3.FromArray(key.values);
          break;
      }
      var keyData = {};
      keyData.frame = key.frame;
      keyData.value = data;
      if (inTangent != void 0) {
        keyData.inTangent = inTangent;
      }
      if (outTangent != void 0) {
        keyData.outTangent = outTangent;
      }
      keys.push(keyData);
    }
    animation.setKeys(keys);
    if (parsedAnimation.ranges) {
      for (index = 0; index < parsedAnimation.ranges.length; index++) {
        data = parsedAnimation.ranges[index];
        animation.createRange(data.name, data.from, data.to);
      }
    }
    return animation;
  };
  Animation2.AppendSerializedAnimations = function(source, destination) {
    SerializationHelper.AppendSerializedAnimations(source, destination);
  };
  Animation2.ParseFromFileAsync = function(name42, url) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      var request = new WebRequest();
      request.addEventListener("readystatechange", function() {
        if (request.readyState == 4) {
          if (request.status == 200) {
            var serializationObject = JSON.parse(request.responseText);
            if (serializationObject.length) {
              var output = new Array();
              for (var _i = 0, serializationObject_1 = serializationObject; _i < serializationObject_1.length; _i++) {
                var serializedAnimation = serializationObject_1[_i];
                output.push(_this.Parse(serializedAnimation));
              }
              resolve(output);
            } else {
              var output = _this.Parse(serializationObject);
              if (name42) {
                output.name = name42;
              }
              resolve(output);
            }
          } else {
            reject("Unable to load the animation");
          }
        }
      });
      request.open("GET", url);
      request.send();
    });
  };
  Animation2.CreateFromSnippetAsync = function(snippetId) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      var request = new WebRequest();
      request.addEventListener("readystatechange", function() {
        if (request.readyState == 4) {
          if (request.status == 200) {
            var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
            if (snippet.animations) {
              var serializationObject = JSON.parse(snippet.animations);
              var output = new Array();
              for (var _i = 0, serializationObject_2 = serializationObject; _i < serializationObject_2.length; _i++) {
                var serializedAnimation = serializationObject_2[_i];
                output.push(_this.Parse(serializedAnimation));
              }
              resolve(output);
            } else {
              var serializationObject = JSON.parse(snippet.animation);
              var output = _this.Parse(serializationObject);
              output.snippetId = snippetId;
              resolve(output);
            }
          } else {
            reject("Unable to load the snippet " + snippetId);
          }
        }
      });
      request.open("GET", _this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
      request.send();
    });
  };
  Animation2.AllowMatricesInterpolation = false;
  Animation2.AllowMatrixDecomposeForInterpolation = true;
  Animation2.SnippetUrl = "https://snippet.babylonjs.com";
  Animation2.ANIMATIONTYPE_FLOAT = 0;
  Animation2.ANIMATIONTYPE_VECTOR3 = 1;
  Animation2.ANIMATIONTYPE_QUATERNION = 2;
  Animation2.ANIMATIONTYPE_MATRIX = 3;
  Animation2.ANIMATIONTYPE_COLOR3 = 4;
  Animation2.ANIMATIONTYPE_COLOR4 = 7;
  Animation2.ANIMATIONTYPE_VECTOR2 = 5;
  Animation2.ANIMATIONTYPE_SIZE = 6;
  Animation2.ANIMATIONLOOPMODE_RELATIVE = 0;
  Animation2.ANIMATIONLOOPMODE_CYCLE = 1;
  Animation2.ANIMATIONLOOPMODE_CONSTANT = 2;
  return Animation2;
}();
_TypeStore.RegisteredTypes["BABYLON.Animation"] = Animation;
Node._AnimationRangeFactory = function(name42, from, to) {
  return new AnimationRange(name42, from, to);
};

// node_modules/@babylonjs/core/Animations/runtimeAnimation.js
var _staticOffsetValueQuaternion = Object.freeze(new Quaternion(0, 0, 0, 0));
var _staticOffsetValueVector3 = Object.freeze(Vector3.Zero());
var _staticOffsetValueVector2 = Object.freeze(Vector2.Zero());
var _staticOffsetValueSize = Object.freeze(Size.Zero());
var _staticOffsetValueColor3 = Object.freeze(Color3.Black());
var RuntimeAnimation = function() {
  function RuntimeAnimation2(target, animation, scene, host) {
    var _this = this;
    this._events = new Array();
    this._currentFrame = 0;
    this._originalValue = new Array();
    this._originalBlendValue = null;
    this._offsetsCache = {};
    this._highLimitsCache = {};
    this._stopped = false;
    this._blendingFactor = 0;
    this._currentValue = null;
    this._currentActiveTarget = null;
    this._directTarget = null;
    this._targetPath = "";
    this._weight = 1;
    this._ratioOffset = 0;
    this._previousDelay = 0;
    this._previousRatio = 0;
    this._targetIsArray = false;
    this._animation = animation;
    this._target = target;
    this._scene = scene;
    this._host = host;
    this._activeTargets = [];
    animation._runtimeAnimations.push(this);
    this._animationState = {
      key: 0,
      repeatCount: 0,
      loopMode: this._getCorrectLoopMode()
    };
    if (this._animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {
      this._animationState.workValue = Matrix.Zero();
    }
    this._keys = this._animation.getKeys();
    this._minFrame = this._keys[0].frame;
    this._maxFrame = this._keys[this._keys.length - 1].frame;
    this._minValue = this._keys[0].value;
    this._maxValue = this._keys[this._keys.length - 1].value;
    if (this._minFrame !== 0) {
      var newKey = { frame: 0, value: this._minValue };
      this._keys.splice(0, 0, newKey);
    }
    if (this._target instanceof Array) {
      var index = 0;
      for (var _i = 0, _a = this._target; _i < _a.length; _i++) {
        var target_1 = _a[_i];
        this._preparePath(target_1, index);
        this._getOriginalValues(index);
        index++;
      }
      this._targetIsArray = true;
    } else {
      this._preparePath(this._target);
      this._getOriginalValues();
      this._targetIsArray = false;
      this._directTarget = this._activeTargets[0];
    }
    var events = animation.getEvents();
    if (events && events.length > 0) {
      events.forEach(function(e) {
        _this._events.push(e._clone());
      });
    }
    this._enableBlending = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.enableBlending : this._animation.enableBlending;
  }
  Object.defineProperty(RuntimeAnimation2.prototype, "currentFrame", {
    get: function() {
      return this._currentFrame;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RuntimeAnimation2.prototype, "weight", {
    get: function() {
      return this._weight;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RuntimeAnimation2.prototype, "currentValue", {
    get: function() {
      return this._currentValue;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RuntimeAnimation2.prototype, "targetPath", {
    get: function() {
      return this._targetPath;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RuntimeAnimation2.prototype, "target", {
    get: function() {
      return this._currentActiveTarget;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RuntimeAnimation2.prototype, "isAdditive", {
    get: function() {
      return this._host && this._host.isAdditive;
    },
    enumerable: false,
    configurable: true
  });
  RuntimeAnimation2.prototype._preparePath = function(target, targetIndex) {
    if (targetIndex === void 0) {
      targetIndex = 0;
    }
    var targetPropertyPath = this._animation.targetPropertyPath;
    if (targetPropertyPath.length > 1) {
      var property = target[targetPropertyPath[0]];
      for (var index = 1; index < targetPropertyPath.length - 1; index++) {
        property = property[targetPropertyPath[index]];
      }
      this._targetPath = targetPropertyPath[targetPropertyPath.length - 1];
      this._activeTargets[targetIndex] = property;
    } else {
      this._targetPath = targetPropertyPath[0];
      this._activeTargets[targetIndex] = target;
    }
  };
  Object.defineProperty(RuntimeAnimation2.prototype, "animation", {
    get: function() {
      return this._animation;
    },
    enumerable: false,
    configurable: true
  });
  RuntimeAnimation2.prototype.reset = function(restoreOriginal) {
    if (restoreOriginal === void 0) {
      restoreOriginal = false;
    }
    if (restoreOriginal) {
      if (this._target instanceof Array) {
        var index = 0;
        for (var _i = 0, _a = this._target; _i < _a.length; _i++) {
          var target = _a[_i];
          if (this._originalValue[index] !== void 0) {
            this._setValue(target, this._activeTargets[index], this._originalValue[index], -1, index);
          }
          index++;
        }
      } else {
        if (this._originalValue[0] !== void 0) {
          this._setValue(this._target, this._directTarget, this._originalValue[0], -1, 0);
        }
      }
    }
    this._offsetsCache = {};
    this._highLimitsCache = {};
    this._currentFrame = 0;
    this._blendingFactor = 0;
    for (var index = 0; index < this._events.length; index++) {
      this._events[index].isDone = false;
    }
  };
  RuntimeAnimation2.prototype.isStopped = function() {
    return this._stopped;
  };
  RuntimeAnimation2.prototype.dispose = function() {
    var index = this._animation.runtimeAnimations.indexOf(this);
    if (index > -1) {
      this._animation.runtimeAnimations.splice(index, 1);
    }
  };
  RuntimeAnimation2.prototype.setValue = function(currentValue, weight) {
    if (this._targetIsArray) {
      for (var index = 0; index < this._target.length; index++) {
        var target = this._target[index];
        this._setValue(target, this._activeTargets[index], currentValue, weight, index);
      }
      return;
    }
    this._setValue(this._target, this._directTarget, currentValue, weight, 0);
  };
  RuntimeAnimation2.prototype._getOriginalValues = function(targetIndex) {
    if (targetIndex === void 0) {
      targetIndex = 0;
    }
    var originalValue;
    var target = this._activeTargets[targetIndex];
    if (target.getRestPose && this._targetPath === "_matrix") {
      originalValue = target.getRestPose();
    } else {
      originalValue = target[this._targetPath];
    }
    if (originalValue && originalValue.clone) {
      this._originalValue[targetIndex] = originalValue.clone();
    } else {
      this._originalValue[targetIndex] = originalValue;
    }
  };
  RuntimeAnimation2.prototype._setValue = function(target, destination, currentValue, weight, targetIndex) {
    this._currentActiveTarget = destination;
    this._weight = weight;
    if (this._enableBlending && this._blendingFactor <= 1) {
      if (!this._originalBlendValue) {
        var originalValue = destination[this._targetPath];
        if (originalValue.clone) {
          this._originalBlendValue = originalValue.clone();
        } else {
          this._originalBlendValue = originalValue;
        }
      }
      if (this._originalBlendValue.m) {
        if (Animation.AllowMatrixDecomposeForInterpolation) {
          if (this._currentValue) {
            Matrix.DecomposeLerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);
          } else {
            this._currentValue = Matrix.DecomposeLerp(this._originalBlendValue, currentValue, this._blendingFactor);
          }
        } else {
          if (this._currentValue) {
            Matrix.LerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);
          } else {
            this._currentValue = Matrix.Lerp(this._originalBlendValue, currentValue, this._blendingFactor);
          }
        }
      } else {
        this._currentValue = Animation._UniversalLerp(this._originalBlendValue, currentValue, this._blendingFactor);
      }
      var blendingSpeed = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.blendingSpeed : this._animation.blendingSpeed;
      this._blendingFactor += blendingSpeed;
    } else {
      this._currentValue = currentValue;
    }
    if (weight !== -1) {
      this._scene._registerTargetForLateAnimationBinding(this, this._originalValue[targetIndex]);
    } else {
      destination[this._targetPath] = this._currentValue;
    }
    if (target.markAsDirty) {
      target.markAsDirty(this._animation.targetProperty);
    }
  };
  RuntimeAnimation2.prototype._getCorrectLoopMode = function() {
    if (this._target && this._target.animationPropertiesOverride) {
      return this._target.animationPropertiesOverride.loopMode;
    }
    return this._animation.loopMode;
  };
  RuntimeAnimation2.prototype.goToFrame = function(frame) {
    var keys = this._animation.getKeys();
    if (frame < keys[0].frame) {
      frame = keys[0].frame;
    } else if (frame > keys[keys.length - 1].frame) {
      frame = keys[keys.length - 1].frame;
    }
    var events = this._events;
    if (events.length) {
      for (var index = 0; index < events.length; index++) {
        if (!events[index].onlyOnce) {
          events[index].isDone = events[index].frame < frame;
        }
      }
    }
    this._currentFrame = frame;
    var currentValue = this._animation._interpolate(frame, this._animationState);
    this.setValue(currentValue, -1);
  };
  RuntimeAnimation2.prototype._prepareForSpeedRatioChange = function(newSpeedRatio) {
    var newRatio = this._previousDelay * (this._animation.framePerSecond * newSpeedRatio) / 1e3;
    this._ratioOffset = this._previousRatio - newRatio;
  };
  RuntimeAnimation2.prototype.animate = function(delay, from, to, loop, speedRatio, weight) {
    if (weight === void 0) {
      weight = -1;
    }
    var animation = this._animation;
    var targetPropertyPath = animation.targetPropertyPath;
    if (!targetPropertyPath || targetPropertyPath.length < 1) {
      this._stopped = true;
      return false;
    }
    var returnValue = true;
    if (from < this._minFrame || from > this._maxFrame) {
      from = this._minFrame;
    }
    if (to < this._minFrame || to > this._maxFrame) {
      to = this._maxFrame;
    }
    var range = to - from;
    var offsetValue;
    var ratio = delay * (animation.framePerSecond * speedRatio) / 1e3 + this._ratioOffset;
    var highLimitValue = 0;
    this._previousDelay = delay;
    this._previousRatio = ratio;
    if (!loop && (to >= from && ratio >= range)) {
      returnValue = false;
      highLimitValue = animation._getKeyValue(this._maxValue);
    } else if (!loop && (from >= to && ratio <= range)) {
      returnValue = false;
      highLimitValue = animation._getKeyValue(this._minValue);
    } else if (this._animationState.loopMode !== Animation.ANIMATIONLOOPMODE_CYCLE) {
      var keyOffset = to.toString() + from.toString();
      if (!this._offsetsCache[keyOffset]) {
        this._animationState.repeatCount = 0;
        this._animationState.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE;
        var fromValue = animation._interpolate(from, this._animationState);
        var toValue = animation._interpolate(to, this._animationState);
        this._animationState.loopMode = this._getCorrectLoopMode();
        switch (animation.dataType) {
          case Animation.ANIMATIONTYPE_FLOAT:
            this._offsetsCache[keyOffset] = toValue - fromValue;
            break;
          case Animation.ANIMATIONTYPE_QUATERNION:
            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);
            break;
          case Animation.ANIMATIONTYPE_VECTOR3:
            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);
          case Animation.ANIMATIONTYPE_VECTOR2:
            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);
          case Animation.ANIMATIONTYPE_SIZE:
            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);
          case Animation.ANIMATIONTYPE_COLOR3:
            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);
          default:
            break;
        }
        this._highLimitsCache[keyOffset] = toValue;
      }
      highLimitValue = this._highLimitsCache[keyOffset];
      offsetValue = this._offsetsCache[keyOffset];
    }
    if (offsetValue === void 0) {
      switch (animation.dataType) {
        case Animation.ANIMATIONTYPE_FLOAT:
          offsetValue = 0;
          break;
        case Animation.ANIMATIONTYPE_QUATERNION:
          offsetValue = _staticOffsetValueQuaternion;
          break;
        case Animation.ANIMATIONTYPE_VECTOR3:
          offsetValue = _staticOffsetValueVector3;
          break;
        case Animation.ANIMATIONTYPE_VECTOR2:
          offsetValue = _staticOffsetValueVector2;
          break;
        case Animation.ANIMATIONTYPE_SIZE:
          offsetValue = _staticOffsetValueSize;
          break;
        case Animation.ANIMATIONTYPE_COLOR3:
          offsetValue = _staticOffsetValueColor3;
      }
    }
    var currentFrame;
    if (this._host && this._host.syncRoot) {
      var syncRoot = this._host.syncRoot;
      var hostNormalizedFrame = (syncRoot.masterFrame - syncRoot.fromFrame) / (syncRoot.toFrame - syncRoot.fromFrame);
      currentFrame = from + (to - from) * hostNormalizedFrame;
    } else {
      currentFrame = returnValue && range !== 0 ? from + ratio % range : to;
    }
    var events = this._events;
    if (range > 0 && this.currentFrame > currentFrame || range < 0 && this.currentFrame < currentFrame) {
      this._onLoop();
      if (events.length) {
        for (var index = 0; index < events.length; index++) {
          if (!events[index].onlyOnce) {
            events[index].isDone = false;
          }
        }
      }
    }
    this._currentFrame = currentFrame;
    this._animationState.repeatCount = range === 0 ? 0 : ratio / range >> 0;
    this._animationState.highLimitValue = highLimitValue;
    this._animationState.offsetValue = offsetValue;
    var currentValue = animation._interpolate(currentFrame, this._animationState);
    this.setValue(currentValue, weight);
    if (events.length) {
      for (var index = 0; index < events.length; index++) {
        if (range > 0 && currentFrame >= events[index].frame && events[index].frame >= from || range < 0 && currentFrame <= events[index].frame && events[index].frame <= from) {
          var event = events[index];
          if (!event.isDone) {
            if (event.onlyOnce) {
              events.splice(index, 1);
              index--;
            }
            event.isDone = true;
            event.action(currentFrame);
          }
        }
      }
    }
    if (!returnValue) {
      this._stopped = true;
    }
    return returnValue;
  };
  return RuntimeAnimation2;
}();

// node_modules/@babylonjs/core/Bones/bone.js
var Bone = function(_super) {
  __extends(Bone2, _super);
  function Bone2(name42, skeleton, parentBone, localMatrix, restPose, baseMatrix, index) {
    if (parentBone === void 0) {
      parentBone = null;
    }
    if (localMatrix === void 0) {
      localMatrix = null;
    }
    if (restPose === void 0) {
      restPose = null;
    }
    if (baseMatrix === void 0) {
      baseMatrix = null;
    }
    if (index === void 0) {
      index = null;
    }
    var _this = _super.call(this, name42, skeleton.getScene()) || this;
    _this.name = name42;
    _this.children = new Array();
    _this.animations = new Array();
    _this._index = null;
    _this._absoluteTransform = new Matrix();
    _this._invertedAbsoluteTransform = new Matrix();
    _this._scalingDeterminant = 1;
    _this._worldTransform = new Matrix();
    _this._needToDecompose = true;
    _this._needToCompose = false;
    _this._linkedTransformNode = null;
    _this._waitingTransformNodeId = null;
    _this._skeleton = skeleton;
    _this._localMatrix = localMatrix ? localMatrix.clone() : Matrix.Identity();
    _this._restPose = restPose ? restPose : _this._localMatrix.clone();
    _this._bindPose = _this._localMatrix.clone();
    _this._baseMatrix = baseMatrix ? baseMatrix : _this._localMatrix.clone();
    _this._index = index;
    skeleton.bones.push(_this);
    _this.setParent(parentBone, false);
    if (baseMatrix || localMatrix) {
      _this._updateDifferenceMatrix();
    }
    return _this;
  }
  Object.defineProperty(Bone2.prototype, "_matrix", {
    get: function() {
      this._compose();
      return this._localMatrix;
    },
    set: function(value) {
      this._localMatrix.copyFrom(value);
      this._needToDecompose = true;
    },
    enumerable: false,
    configurable: true
  });
  Bone2.prototype.getClassName = function() {
    return "Bone";
  };
  Bone2.prototype.getSkeleton = function() {
    return this._skeleton;
  };
  Bone2.prototype.getParent = function() {
    return this._parent;
  };
  Bone2.prototype.getChildren = function() {
    return this.children;
  };
  Bone2.prototype.getIndex = function() {
    return this._index === null ? this.getSkeleton().bones.indexOf(this) : this._index;
  };
  Bone2.prototype.setParent = function(parent, updateDifferenceMatrix) {
    if (updateDifferenceMatrix === void 0) {
      updateDifferenceMatrix = true;
    }
    if (this._parent === parent) {
      return;
    }
    if (this._parent) {
      var index = this._parent.children.indexOf(this);
      if (index !== -1) {
        this._parent.children.splice(index, 1);
      }
    }
    this._parent = parent;
    if (this._parent) {
      this._parent.children.push(this);
    }
    if (updateDifferenceMatrix) {
      this._updateDifferenceMatrix();
    }
    this.markAsDirty();
  };
  Bone2.prototype.getLocalMatrix = function() {
    this._compose();
    return this._localMatrix;
  };
  Bone2.prototype.getBaseMatrix = function() {
    return this._baseMatrix;
  };
  Bone2.prototype.getRestPose = function() {
    return this._restPose;
  };
  Bone2.prototype.setRestPose = function(matrix) {
    this._restPose.copyFrom(matrix);
  };
  Bone2.prototype.getBindPose = function() {
    return this._bindPose;
  };
  Bone2.prototype.setBindPose = function(matrix) {
    this._bindPose.copyFrom(matrix);
  };
  Bone2.prototype.getWorldMatrix = function() {
    return this._worldTransform;
  };
  Bone2.prototype.returnToRest = function() {
    if (this._skeleton._numBonesWithLinkedTransformNode > 0) {
      this.updateMatrix(this._restPose, false, false);
    } else {
      this.updateMatrix(this._restPose, false, true);
    }
  };
  Bone2.prototype.getInvertedAbsoluteTransform = function() {
    return this._invertedAbsoluteTransform;
  };
  Bone2.prototype.getAbsoluteTransform = function() {
    return this._absoluteTransform;
  };
  Bone2.prototype.linkTransformNode = function(transformNode) {
    if (this._linkedTransformNode) {
      this._skeleton._numBonesWithLinkedTransformNode--;
    }
    this._linkedTransformNode = transformNode;
    if (this._linkedTransformNode) {
      this._skeleton._numBonesWithLinkedTransformNode++;
    }
  };
  Bone2.prototype.getTransformNode = function() {
    return this._linkedTransformNode;
  };
  Object.defineProperty(Bone2.prototype, "position", {
    get: function() {
      this._decompose();
      return this._localPosition;
    },
    set: function(newPosition) {
      this._decompose();
      this._localPosition.copyFrom(newPosition);
      this._markAsDirtyAndCompose();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Bone2.prototype, "rotation", {
    get: function() {
      return this.getRotation();
    },
    set: function(newRotation) {
      this.setRotation(newRotation);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Bone2.prototype, "rotationQuaternion", {
    get: function() {
      this._decompose();
      return this._localRotation;
    },
    set: function(newRotation) {
      this.setRotationQuaternion(newRotation);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Bone2.prototype, "scaling", {
    get: function() {
      return this.getScale();
    },
    set: function(newScaling) {
      this.setScale(newScaling);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Bone2.prototype, "animationPropertiesOverride", {
    get: function() {
      return this._skeleton.animationPropertiesOverride;
    },
    enumerable: false,
    configurable: true
  });
  Bone2.prototype._decompose = function() {
    if (!this._needToDecompose) {
      return;
    }
    this._needToDecompose = false;
    if (!this._localScaling) {
      this._localScaling = Vector3.Zero();
      this._localRotation = Quaternion.Zero();
      this._localPosition = Vector3.Zero();
    }
    this._localMatrix.decompose(this._localScaling, this._localRotation, this._localPosition);
  };
  Bone2.prototype._compose = function() {
    if (!this._needToCompose) {
      return;
    }
    if (!this._localScaling) {
      this._needToCompose = false;
      return;
    }
    this._needToCompose = false;
    Matrix.ComposeToRef(this._localScaling, this._localRotation, this._localPosition, this._localMatrix);
  };
  Bone2.prototype.updateMatrix = function(matrix, updateDifferenceMatrix, updateLocalMatrix) {
    if (updateDifferenceMatrix === void 0) {
      updateDifferenceMatrix = true;
    }
    if (updateLocalMatrix === void 0) {
      updateLocalMatrix = true;
    }
    this._baseMatrix.copyFrom(matrix);
    if (updateDifferenceMatrix) {
      this._updateDifferenceMatrix();
    }
    if (updateLocalMatrix) {
      this._needToCompose = false;
      this._localMatrix.copyFrom(matrix);
      this._markAsDirtyAndDecompose();
    } else {
      this.markAsDirty();
    }
  };
  Bone2.prototype._updateDifferenceMatrix = function(rootMatrix, updateChildren) {
    if (updateChildren === void 0) {
      updateChildren = true;
    }
    if (!rootMatrix) {
      rootMatrix = this._baseMatrix;
    }
    if (this._parent) {
      rootMatrix.multiplyToRef(this._parent._absoluteTransform, this._absoluteTransform);
    } else {
      this._absoluteTransform.copyFrom(rootMatrix);
    }
    this._absoluteTransform.invertToRef(this._invertedAbsoluteTransform);
    if (updateChildren) {
      for (var index = 0; index < this.children.length; index++) {
        this.children[index]._updateDifferenceMatrix();
      }
    }
    this._scalingDeterminant = this._absoluteTransform.determinant() < 0 ? -1 : 1;
  };
  Bone2.prototype.markAsDirty = function() {
    this._currentRenderId++;
    this._childUpdateId++;
    this._skeleton._markAsDirty();
  };
  Bone2.prototype._markAsDirtyAndCompose = function() {
    this.markAsDirty();
    this._needToCompose = true;
  };
  Bone2.prototype._markAsDirtyAndDecompose = function() {
    this.markAsDirty();
    this._needToDecompose = true;
  };
  Bone2.prototype.translate = function(vec, space, mesh) {
    if (space === void 0) {
      space = Space.LOCAL;
    }
    var lm = this.getLocalMatrix();
    if (space == Space.LOCAL) {
      lm.addAtIndex(12, vec.x);
      lm.addAtIndex(13, vec.y);
      lm.addAtIndex(14, vec.z);
    } else {
      var wm = null;
      if (mesh) {
        wm = mesh.getWorldMatrix();
      }
      this._skeleton.computeAbsoluteTransforms();
      var tmat = Bone2._tmpMats[0];
      var tvec = Bone2._tmpVecs[0];
      if (this._parent) {
        if (mesh && wm) {
          tmat.copyFrom(this._parent.getAbsoluteTransform());
          tmat.multiplyToRef(wm, tmat);
        } else {
          tmat.copyFrom(this._parent.getAbsoluteTransform());
        }
      } else {
        Matrix.IdentityToRef(tmat);
      }
      tmat.setTranslationFromFloats(0, 0, 0);
      tmat.invert();
      Vector3.TransformCoordinatesToRef(vec, tmat, tvec);
      lm.addAtIndex(12, tvec.x);
      lm.addAtIndex(13, tvec.y);
      lm.addAtIndex(14, tvec.z);
    }
    this._markAsDirtyAndDecompose();
  };
  Bone2.prototype.setPosition = function(position, space, mesh) {
    if (space === void 0) {
      space = Space.LOCAL;
    }
    var lm = this.getLocalMatrix();
    if (space == Space.LOCAL) {
      lm.setTranslationFromFloats(position.x, position.y, position.z);
    } else {
      var wm = null;
      if (mesh) {
        wm = mesh.getWorldMatrix();
      }
      this._skeleton.computeAbsoluteTransforms();
      var tmat = Bone2._tmpMats[0];
      var vec = Bone2._tmpVecs[0];
      if (this._parent) {
        if (mesh && wm) {
          tmat.copyFrom(this._parent.getAbsoluteTransform());
          tmat.multiplyToRef(wm, tmat);
        } else {
          tmat.copyFrom(this._parent.getAbsoluteTransform());
        }
        tmat.invert();
      } else {
        Matrix.IdentityToRef(tmat);
      }
      Vector3.TransformCoordinatesToRef(position, tmat, vec);
      lm.setTranslationFromFloats(vec.x, vec.y, vec.z);
    }
    this._markAsDirtyAndDecompose();
  };
  Bone2.prototype.setAbsolutePosition = function(position, mesh) {
    this.setPosition(position, Space.WORLD, mesh);
  };
  Bone2.prototype.scale = function(x, y, z, scaleChildren) {
    if (scaleChildren === void 0) {
      scaleChildren = false;
    }
    var locMat = this.getLocalMatrix();
    var scaleMat = Bone2._tmpMats[0];
    Matrix.ScalingToRef(x, y, z, scaleMat);
    scaleMat.multiplyToRef(locMat, locMat);
    scaleMat.invert();
    for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
      var child = _a[_i];
      var cm = child.getLocalMatrix();
      cm.multiplyToRef(scaleMat, cm);
      cm.multiplyAtIndex(12, x);
      cm.multiplyAtIndex(13, y);
      cm.multiplyAtIndex(14, z);
      child._markAsDirtyAndDecompose();
    }
    this._markAsDirtyAndDecompose();
    if (scaleChildren) {
      for (var _b = 0, _c = this.children; _b < _c.length; _b++) {
        var child = _c[_b];
        child.scale(x, y, z, scaleChildren);
      }
    }
  };
  Bone2.prototype.setScale = function(scale) {
    this._decompose();
    this._localScaling.copyFrom(scale);
    this._markAsDirtyAndCompose();
  };
  Bone2.prototype.getScale = function() {
    this._decompose();
    return this._localScaling;
  };
  Bone2.prototype.getScaleToRef = function(result) {
    this._decompose();
    result.copyFrom(this._localScaling);
  };
  Bone2.prototype.setYawPitchRoll = function(yaw, pitch, roll, space, mesh) {
    if (space === void 0) {
      space = Space.LOCAL;
    }
    if (space === Space.LOCAL) {
      var quat = Bone2._tmpQuat;
      Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, quat);
      this.setRotationQuaternion(quat, space, mesh);
      return;
    }
    var rotMatInv = Bone2._tmpMats[0];
    if (!this._getNegativeRotationToRef(rotMatInv, mesh)) {
      return;
    }
    var rotMat = Bone2._tmpMats[1];
    Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, rotMat);
    rotMatInv.multiplyToRef(rotMat, rotMat);
    this._rotateWithMatrix(rotMat, space, mesh);
  };
  Bone2.prototype.rotate = function(axis, amount, space, mesh) {
    if (space === void 0) {
      space = Space.LOCAL;
    }
    var rmat = Bone2._tmpMats[0];
    rmat.setTranslationFromFloats(0, 0, 0);
    Matrix.RotationAxisToRef(axis, amount, rmat);
    this._rotateWithMatrix(rmat, space, mesh);
  };
  Bone2.prototype.setAxisAngle = function(axis, angle, space, mesh) {
    if (space === void 0) {
      space = Space.LOCAL;
    }
    if (space === Space.LOCAL) {
      var quat = Bone2._tmpQuat;
      Quaternion.RotationAxisToRef(axis, angle, quat);
      this.setRotationQuaternion(quat, space, mesh);
      return;
    }
    var rotMatInv = Bone2._tmpMats[0];
    if (!this._getNegativeRotationToRef(rotMatInv, mesh)) {
      return;
    }
    var rotMat = Bone2._tmpMats[1];
    Matrix.RotationAxisToRef(axis, angle, rotMat);
    rotMatInv.multiplyToRef(rotMat, rotMat);
    this._rotateWithMatrix(rotMat, space, mesh);
  };
  Bone2.prototype.setRotation = function(rotation, space, mesh) {
    if (space === void 0) {
      space = Space.LOCAL;
    }
    this.setYawPitchRoll(rotation.y, rotation.x, rotation.z, space, mesh);
  };
  Bone2.prototype.setRotationQuaternion = function(quat, space, mesh) {
    if (space === void 0) {
      space = Space.LOCAL;
    }
    if (space === Space.LOCAL) {
      this._decompose();
      this._localRotation.copyFrom(quat);
      this._markAsDirtyAndCompose();
      return;
    }
    var rotMatInv = Bone2._tmpMats[0];
    if (!this._getNegativeRotationToRef(rotMatInv, mesh)) {
      return;
    }
    var rotMat = Bone2._tmpMats[1];
    Matrix.FromQuaternionToRef(quat, rotMat);
    rotMatInv.multiplyToRef(rotMat, rotMat);
    this._rotateWithMatrix(rotMat, space, mesh);
  };
  Bone2.prototype.setRotationMatrix = function(rotMat, space, mesh) {
    if (space === void 0) {
      space = Space.LOCAL;
    }
    if (space === Space.LOCAL) {
      var quat = Bone2._tmpQuat;
      Quaternion.FromRotationMatrixToRef(rotMat, quat);
      this.setRotationQuaternion(quat, space, mesh);
      return;
    }
    var rotMatInv = Bone2._tmpMats[0];
    if (!this._getNegativeRotationToRef(rotMatInv, mesh)) {
      return;
    }
    var rotMat2 = Bone2._tmpMats[1];
    rotMat2.copyFrom(rotMat);
    rotMatInv.multiplyToRef(rotMat, rotMat2);
    this._rotateWithMatrix(rotMat2, space, mesh);
  };
  Bone2.prototype._rotateWithMatrix = function(rmat, space, mesh) {
    if (space === void 0) {
      space = Space.LOCAL;
    }
    var lmat = this.getLocalMatrix();
    var lx = lmat.m[12];
    var ly = lmat.m[13];
    var lz = lmat.m[14];
    var parent = this.getParent();
    var parentScale = Bone2._tmpMats[3];
    var parentScaleInv = Bone2._tmpMats[4];
    if (parent && space == Space.WORLD) {
      if (mesh) {
        parentScale.copyFrom(mesh.getWorldMatrix());
        parent.getAbsoluteTransform().multiplyToRef(parentScale, parentScale);
      } else {
        parentScale.copyFrom(parent.getAbsoluteTransform());
      }
      parentScaleInv.copyFrom(parentScale);
      parentScaleInv.invert();
      lmat.multiplyToRef(parentScale, lmat);
      lmat.multiplyToRef(rmat, lmat);
      lmat.multiplyToRef(parentScaleInv, lmat);
    } else {
      if (space == Space.WORLD && mesh) {
        parentScale.copyFrom(mesh.getWorldMatrix());
        parentScaleInv.copyFrom(parentScale);
        parentScaleInv.invert();
        lmat.multiplyToRef(parentScale, lmat);
        lmat.multiplyToRef(rmat, lmat);
        lmat.multiplyToRef(parentScaleInv, lmat);
      } else {
        lmat.multiplyToRef(rmat, lmat);
      }
    }
    lmat.setTranslationFromFloats(lx, ly, lz);
    this.computeAbsoluteTransforms();
    this._markAsDirtyAndDecompose();
  };
  Bone2.prototype._getNegativeRotationToRef = function(rotMatInv, mesh) {
    var scaleMatrix = Bone2._tmpMats[2];
    rotMatInv.copyFrom(this.getAbsoluteTransform());
    if (mesh) {
      rotMatInv.multiplyToRef(mesh.getWorldMatrix(), rotMatInv);
      Matrix.ScalingToRef(mesh.scaling.x, mesh.scaling.y, mesh.scaling.z, scaleMatrix);
    }
    rotMatInv.invert();
    if (isNaN(rotMatInv.m[0])) {
      return false;
    }
    scaleMatrix.multiplyAtIndex(0, this._scalingDeterminant);
    rotMatInv.multiplyToRef(scaleMatrix, rotMatInv);
    return true;
  };
  Bone2.prototype.getPosition = function(space, mesh) {
    if (space === void 0) {
      space = Space.LOCAL;
    }
    if (mesh === void 0) {
      mesh = null;
    }
    var pos = Vector3.Zero();
    this.getPositionToRef(space, mesh, pos);
    return pos;
  };
  Bone2.prototype.getPositionToRef = function(space, mesh, result) {
    if (space === void 0) {
      space = Space.LOCAL;
    }
    if (space == Space.LOCAL) {
      var lm = this.getLocalMatrix();
      result.x = lm.m[12];
      result.y = lm.m[13];
      result.z = lm.m[14];
    } else {
      var wm = null;
      if (mesh) {
        wm = mesh.getWorldMatrix();
      }
      this._skeleton.computeAbsoluteTransforms();
      var tmat = Bone2._tmpMats[0];
      if (mesh && wm) {
        tmat.copyFrom(this.getAbsoluteTransform());
        tmat.multiplyToRef(wm, tmat);
      } else {
        tmat = this.getAbsoluteTransform();
      }
      result.x = tmat.m[12];
      result.y = tmat.m[13];
      result.z = tmat.m[14];
    }
  };
  Bone2.prototype.getAbsolutePosition = function(mesh) {
    if (mesh === void 0) {
      mesh = null;
    }
    var pos = Vector3.Zero();
    this.getPositionToRef(Space.WORLD, mesh, pos);
    return pos;
  };
  Bone2.prototype.getAbsolutePositionToRef = function(mesh, result) {
    this.getPositionToRef(Space.WORLD, mesh, result);
  };
  Bone2.prototype.computeAbsoluteTransforms = function() {
    this._compose();
    if (this._parent) {
      this._localMatrix.multiplyToRef(this._parent._absoluteTransform, this._absoluteTransform);
    } else {
      this._absoluteTransform.copyFrom(this._localMatrix);
      var poseMatrix = this._skeleton.getPoseMatrix();
      if (poseMatrix) {
        this._absoluteTransform.multiplyToRef(poseMatrix, this._absoluteTransform);
      }
    }
    var children = this.children;
    var len = children.length;
    for (var i = 0; i < len; i++) {
      children[i].computeAbsoluteTransforms();
    }
  };
  Bone2.prototype.getDirection = function(localAxis, mesh) {
    if (mesh === void 0) {
      mesh = null;
    }
    var result = Vector3.Zero();
    this.getDirectionToRef(localAxis, mesh, result);
    return result;
  };
  Bone2.prototype.getDirectionToRef = function(localAxis, mesh, result) {
    if (mesh === void 0) {
      mesh = null;
    }
    var wm = null;
    if (mesh) {
      wm = mesh.getWorldMatrix();
    }
    this._skeleton.computeAbsoluteTransforms();
    var mat = Bone2._tmpMats[0];
    mat.copyFrom(this.getAbsoluteTransform());
    if (mesh && wm) {
      mat.multiplyToRef(wm, mat);
    }
    Vector3.TransformNormalToRef(localAxis, mat, result);
    result.normalize();
  };
  Bone2.prototype.getRotation = function(space, mesh) {
    if (space === void 0) {
      space = Space.LOCAL;
    }
    if (mesh === void 0) {
      mesh = null;
    }
    var result = Vector3.Zero();
    this.getRotationToRef(space, mesh, result);
    return result;
  };
  Bone2.prototype.getRotationToRef = function(space, mesh, result) {
    if (space === void 0) {
      space = Space.LOCAL;
    }
    if (mesh === void 0) {
      mesh = null;
    }
    var quat = Bone2._tmpQuat;
    this.getRotationQuaternionToRef(space, mesh, quat);
    quat.toEulerAnglesToRef(result);
  };
  Bone2.prototype.getRotationQuaternion = function(space, mesh) {
    if (space === void 0) {
      space = Space.LOCAL;
    }
    if (mesh === void 0) {
      mesh = null;
    }
    var result = Quaternion.Identity();
    this.getRotationQuaternionToRef(space, mesh, result);
    return result;
  };
  Bone2.prototype.getRotationQuaternionToRef = function(space, mesh, result) {
    if (space === void 0) {
      space = Space.LOCAL;
    }
    if (mesh === void 0) {
      mesh = null;
    }
    if (space == Space.LOCAL) {
      this._decompose();
      result.copyFrom(this._localRotation);
    } else {
      var mat = Bone2._tmpMats[0];
      var amat = this.getAbsoluteTransform();
      if (mesh) {
        amat.multiplyToRef(mesh.getWorldMatrix(), mat);
      } else {
        mat.copyFrom(amat);
      }
      mat.multiplyAtIndex(0, this._scalingDeterminant);
      mat.multiplyAtIndex(1, this._scalingDeterminant);
      mat.multiplyAtIndex(2, this._scalingDeterminant);
      mat.decompose(void 0, result, void 0);
    }
  };
  Bone2.prototype.getRotationMatrix = function(space, mesh) {
    if (space === void 0) {
      space = Space.LOCAL;
    }
    var result = Matrix.Identity();
    this.getRotationMatrixToRef(space, mesh, result);
    return result;
  };
  Bone2.prototype.getRotationMatrixToRef = function(space, mesh, result) {
    if (space === void 0) {
      space = Space.LOCAL;
    }
    if (space == Space.LOCAL) {
      this.getLocalMatrix().getRotationMatrixToRef(result);
    } else {
      var mat = Bone2._tmpMats[0];
      var amat = this.getAbsoluteTransform();
      if (mesh) {
        amat.multiplyToRef(mesh.getWorldMatrix(), mat);
      } else {
        mat.copyFrom(amat);
      }
      mat.multiplyAtIndex(0, this._scalingDeterminant);
      mat.multiplyAtIndex(1, this._scalingDeterminant);
      mat.multiplyAtIndex(2, this._scalingDeterminant);
      mat.getRotationMatrixToRef(result);
    }
  };
  Bone2.prototype.getAbsolutePositionFromLocal = function(position, mesh) {
    if (mesh === void 0) {
      mesh = null;
    }
    var result = Vector3.Zero();
    this.getAbsolutePositionFromLocalToRef(position, mesh, result);
    return result;
  };
  Bone2.prototype.getAbsolutePositionFromLocalToRef = function(position, mesh, result) {
    if (mesh === void 0) {
      mesh = null;
    }
    var wm = null;
    if (mesh) {
      wm = mesh.getWorldMatrix();
    }
    this._skeleton.computeAbsoluteTransforms();
    var tmat = Bone2._tmpMats[0];
    if (mesh && wm) {
      tmat.copyFrom(this.getAbsoluteTransform());
      tmat.multiplyToRef(wm, tmat);
    } else {
      tmat = this.getAbsoluteTransform();
    }
    Vector3.TransformCoordinatesToRef(position, tmat, result);
  };
  Bone2.prototype.getLocalPositionFromAbsolute = function(position, mesh) {
    if (mesh === void 0) {
      mesh = null;
    }
    var result = Vector3.Zero();
    this.getLocalPositionFromAbsoluteToRef(position, mesh, result);
    return result;
  };
  Bone2.prototype.getLocalPositionFromAbsoluteToRef = function(position, mesh, result) {
    if (mesh === void 0) {
      mesh = null;
    }
    var wm = null;
    if (mesh) {
      wm = mesh.getWorldMatrix();
    }
    this._skeleton.computeAbsoluteTransforms();
    var tmat = Bone2._tmpMats[0];
    tmat.copyFrom(this.getAbsoluteTransform());
    if (mesh && wm) {
      tmat.multiplyToRef(wm, tmat);
    }
    tmat.invert();
    Vector3.TransformCoordinatesToRef(position, tmat, result);
  };
  Bone2.prototype.setCurrentPoseAsRest = function() {
    this.setRestPose(this.getLocalMatrix());
  };
  Bone2._tmpVecs = ArrayTools.BuildArray(2, Vector3.Zero);
  Bone2._tmpQuat = Quaternion.Identity();
  Bone2._tmpMats = ArrayTools.BuildArray(5, Matrix.Identity);
  return Bone2;
}(Node);

// node_modules/@babylonjs/core/Animations/animatable.js
var Animatable = function() {
  function Animatable2(scene, target, fromFrame, toFrame, loopAnimation, speedRatio, onAnimationEnd, animations, onAnimationLoop, isAdditive) {
    if (fromFrame === void 0) {
      fromFrame = 0;
    }
    if (toFrame === void 0) {
      toFrame = 100;
    }
    if (loopAnimation === void 0) {
      loopAnimation = false;
    }
    if (speedRatio === void 0) {
      speedRatio = 1;
    }
    if (isAdditive === void 0) {
      isAdditive = false;
    }
    this.target = target;
    this.fromFrame = fromFrame;
    this.toFrame = toFrame;
    this.loopAnimation = loopAnimation;
    this.onAnimationEnd = onAnimationEnd;
    this.onAnimationLoop = onAnimationLoop;
    this.isAdditive = isAdditive;
    this._localDelayOffset = null;
    this._pausedDelay = null;
    this._runtimeAnimations = new Array();
    this._paused = false;
    this._speedRatio = 1;
    this._weight = -1;
    this._syncRoot = null;
    this.disposeOnEnd = true;
    this.animationStarted = false;
    this.onAnimationEndObservable = new Observable();
    this.onAnimationLoopObservable = new Observable();
    this._scene = scene;
    if (animations) {
      this.appendAnimations(target, animations);
    }
    this._speedRatio = speedRatio;
    scene._activeAnimatables.push(this);
  }
  Object.defineProperty(Animatable2.prototype, "syncRoot", {
    get: function() {
      return this._syncRoot;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Animatable2.prototype, "masterFrame", {
    get: function() {
      if (this._runtimeAnimations.length === 0) {
        return 0;
      }
      return this._runtimeAnimations[0].currentFrame;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Animatable2.prototype, "weight", {
    get: function() {
      return this._weight;
    },
    set: function(value) {
      if (value === -1) {
        this._weight = -1;
        return;
      }
      this._weight = Math.min(Math.max(value, 0), 1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Animatable2.prototype, "speedRatio", {
    get: function() {
      return this._speedRatio;
    },
    set: function(value) {
      for (var index = 0; index < this._runtimeAnimations.length; index++) {
        var animation = this._runtimeAnimations[index];
        animation._prepareForSpeedRatioChange(value);
      }
      this._speedRatio = value;
    },
    enumerable: false,
    configurable: true
  });
  Animatable2.prototype.syncWith = function(root) {
    this._syncRoot = root;
    if (root) {
      var index = this._scene._activeAnimatables.indexOf(this);
      if (index > -1) {
        this._scene._activeAnimatables.splice(index, 1);
        this._scene._activeAnimatables.push(this);
      }
    }
    return this;
  };
  Animatable2.prototype.getAnimations = function() {
    return this._runtimeAnimations;
  };
  Animatable2.prototype.appendAnimations = function(target, animations) {
    var _this = this;
    for (var index = 0; index < animations.length; index++) {
      var animation = animations[index];
      var newRuntimeAnimation = new RuntimeAnimation(target, animation, this._scene, this);
      newRuntimeAnimation._onLoop = function() {
        _this.onAnimationLoopObservable.notifyObservers(_this);
        if (_this.onAnimationLoop) {
          _this.onAnimationLoop();
        }
      };
      this._runtimeAnimations.push(newRuntimeAnimation);
    }
  };
  Animatable2.prototype.getAnimationByTargetProperty = function(property) {
    var runtimeAnimations = this._runtimeAnimations;
    for (var index = 0; index < runtimeAnimations.length; index++) {
      if (runtimeAnimations[index].animation.targetProperty === property) {
        return runtimeAnimations[index].animation;
      }
    }
    return null;
  };
  Animatable2.prototype.getRuntimeAnimationByTargetProperty = function(property) {
    var runtimeAnimations = this._runtimeAnimations;
    for (var index = 0; index < runtimeAnimations.length; index++) {
      if (runtimeAnimations[index].animation.targetProperty === property) {
        return runtimeAnimations[index];
      }
    }
    return null;
  };
  Animatable2.prototype.reset = function() {
    var runtimeAnimations = this._runtimeAnimations;
    for (var index = 0; index < runtimeAnimations.length; index++) {
      runtimeAnimations[index].reset(true);
    }
    this._localDelayOffset = null;
    this._pausedDelay = null;
  };
  Animatable2.prototype.enableBlending = function(blendingSpeed) {
    var runtimeAnimations = this._runtimeAnimations;
    for (var index = 0; index < runtimeAnimations.length; index++) {
      runtimeAnimations[index].animation.enableBlending = true;
      runtimeAnimations[index].animation.blendingSpeed = blendingSpeed;
    }
  };
  Animatable2.prototype.disableBlending = function() {
    var runtimeAnimations = this._runtimeAnimations;
    for (var index = 0; index < runtimeAnimations.length; index++) {
      runtimeAnimations[index].animation.enableBlending = false;
    }
  };
  Animatable2.prototype.goToFrame = function(frame) {
    var runtimeAnimations = this._runtimeAnimations;
    if (runtimeAnimations[0]) {
      var fps = runtimeAnimations[0].animation.framePerSecond;
      var currentFrame = runtimeAnimations[0].currentFrame;
      var delay = this.speedRatio === 0 ? 0 : (frame - currentFrame) / fps * 1e3 / this.speedRatio;
      if (this._localDelayOffset === null) {
        this._localDelayOffset = 0;
      }
      this._localDelayOffset -= delay;
    }
    for (var index = 0; index < runtimeAnimations.length; index++) {
      runtimeAnimations[index].goToFrame(frame);
    }
  };
  Animatable2.prototype.pause = function() {
    if (this._paused) {
      return;
    }
    this._paused = true;
  };
  Animatable2.prototype.restart = function() {
    this._paused = false;
  };
  Animatable2.prototype._raiseOnAnimationEnd = function() {
    if (this.onAnimationEnd) {
      this.onAnimationEnd();
    }
    this.onAnimationEndObservable.notifyObservers(this);
  };
  Animatable2.prototype.stop = function(animationName, targetMask) {
    if (animationName || targetMask) {
      var idx = this._scene._activeAnimatables.indexOf(this);
      if (idx > -1) {
        var runtimeAnimations = this._runtimeAnimations;
        for (var index = runtimeAnimations.length - 1; index >= 0; index--) {
          var runtimeAnimation = runtimeAnimations[index];
          if (animationName && runtimeAnimation.animation.name != animationName) {
            continue;
          }
          if (targetMask && !targetMask(runtimeAnimation.target)) {
            continue;
          }
          runtimeAnimation.dispose();
          runtimeAnimations.splice(index, 1);
        }
        if (runtimeAnimations.length == 0) {
          this._scene._activeAnimatables.splice(idx, 1);
          this._raiseOnAnimationEnd();
        }
      }
    } else {
      var index = this._scene._activeAnimatables.indexOf(this);
      if (index > -1) {
        this._scene._activeAnimatables.splice(index, 1);
        var runtimeAnimations = this._runtimeAnimations;
        for (var index = 0; index < runtimeAnimations.length; index++) {
          runtimeAnimations[index].dispose();
        }
        this._raiseOnAnimationEnd();
      }
    }
  };
  Animatable2.prototype.waitAsync = function() {
    var _this = this;
    return new Promise(function(resolve, reject) {
      _this.onAnimationEndObservable.add(function() {
        resolve(_this);
      }, void 0, void 0, _this, true);
    });
  };
  Animatable2.prototype._animate = function(delay) {
    if (this._paused) {
      this.animationStarted = false;
      if (this._pausedDelay === null) {
        this._pausedDelay = delay;
      }
      return true;
    }
    if (this._localDelayOffset === null) {
      this._localDelayOffset = delay;
      this._pausedDelay = null;
    } else if (this._pausedDelay !== null) {
      this._localDelayOffset += delay - this._pausedDelay;
      this._pausedDelay = null;
    }
    if (this._weight === 0) {
      return true;
    }
    var running = false;
    var runtimeAnimations = this._runtimeAnimations;
    var index;
    for (index = 0; index < runtimeAnimations.length; index++) {
      var animation = runtimeAnimations[index];
      var isRunning = animation.animate(delay - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this._speedRatio, this._weight);
      running = running || isRunning;
    }
    this.animationStarted = running;
    if (!running) {
      if (this.disposeOnEnd) {
        index = this._scene._activeAnimatables.indexOf(this);
        this._scene._activeAnimatables.splice(index, 1);
        for (index = 0; index < runtimeAnimations.length; index++) {
          runtimeAnimations[index].dispose();
        }
      }
      this._raiseOnAnimationEnd();
      if (this.disposeOnEnd) {
        this.onAnimationEnd = null;
        this.onAnimationLoop = null;
        this.onAnimationLoopObservable.clear();
        this.onAnimationEndObservable.clear();
      }
    }
    return running;
  };
  return Animatable2;
}();
Scene.prototype._animate = function() {
  if (!this.animationsEnabled) {
    return;
  }
  var now = PrecisionDate.Now;
  if (!this._animationTimeLast) {
    if (this._pendingData.length > 0) {
      return;
    }
    this._animationTimeLast = now;
  }
  this.deltaTime = this.useConstantAnimationDeltaTime ? 16 : (now - this._animationTimeLast) * this.animationTimeScale;
  this._animationTimeLast = now;
  var animatables = this._activeAnimatables;
  if (animatables.length === 0) {
    return;
  }
  this._animationTime += this.deltaTime;
  var animationTime = this._animationTime;
  for (var index = 0; index < animatables.length; index++) {
    var animatable = animatables[index];
    if (!animatable._animate(animationTime) && animatable.disposeOnEnd) {
      index--;
    }
  }
  this._processLateAnimationBindings();
};
Scene.prototype.beginWeightedAnimation = function(target, from, to, weight, loop, speedRatio, onAnimationEnd, animatable, targetMask, onAnimationLoop, isAdditive) {
  if (weight === void 0) {
    weight = 1;
  }
  if (speedRatio === void 0) {
    speedRatio = 1;
  }
  if (isAdditive === void 0) {
    isAdditive = false;
  }
  var returnedAnimatable = this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, false, targetMask, onAnimationLoop, isAdditive);
  returnedAnimatable.weight = weight;
  return returnedAnimatable;
};
Scene.prototype.beginAnimation = function(target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop, isAdditive) {
  if (speedRatio === void 0) {
    speedRatio = 1;
  }
  if (stopCurrent === void 0) {
    stopCurrent = true;
  }
  if (isAdditive === void 0) {
    isAdditive = false;
  }
  if (from > to && speedRatio > 0) {
    speedRatio *= -1;
  }
  if (stopCurrent) {
    this.stopAnimation(target, void 0, targetMask);
  }
  if (!animatable) {
    animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, void 0, onAnimationLoop, isAdditive);
  }
  var shouldRunTargetAnimations = targetMask ? targetMask(target) : true;
  if (target.animations && shouldRunTargetAnimations) {
    animatable.appendAnimations(target, target.animations);
  }
  if (target.getAnimatables) {
    var animatables = target.getAnimatables();
    for (var index = 0; index < animatables.length; index++) {
      this.beginAnimation(animatables[index], from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop);
    }
  }
  animatable.reset();
  return animatable;
};
Scene.prototype.beginHierarchyAnimation = function(target, directDescendantsOnly, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop, isAdditive) {
  if (speedRatio === void 0) {
    speedRatio = 1;
  }
  if (stopCurrent === void 0) {
    stopCurrent = true;
  }
  if (isAdditive === void 0) {
    isAdditive = false;
  }
  var children = target.getDescendants(directDescendantsOnly);
  var result = [];
  result.push(this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, void 0, isAdditive));
  for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
    var child = children_1[_i];
    result.push(this.beginAnimation(child, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, void 0, isAdditive));
  }
  return result;
};
Scene.prototype.beginDirectAnimation = function(target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive) {
  if (isAdditive === void 0) {
    isAdditive = false;
  }
  if (speedRatio === void 0) {
    speedRatio = 1;
  }
  if (from > to && speedRatio > 0) {
    speedRatio *= -1;
  }
  var animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, animations, onAnimationLoop, isAdditive);
  return animatable;
};
Scene.prototype.beginDirectHierarchyAnimation = function(target, directDescendantsOnly, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive) {
  if (isAdditive === void 0) {
    isAdditive = false;
  }
  var children = target.getDescendants(directDescendantsOnly);
  var result = [];
  result.push(this.beginDirectAnimation(target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));
  for (var _i = 0, children_2 = children; _i < children_2.length; _i++) {
    var child = children_2[_i];
    result.push(this.beginDirectAnimation(child, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));
  }
  return result;
};
Scene.prototype.getAnimatableByTarget = function(target) {
  for (var index = 0; index < this._activeAnimatables.length; index++) {
    if (this._activeAnimatables[index].target === target) {
      return this._activeAnimatables[index];
    }
  }
  return null;
};
Scene.prototype.getAllAnimatablesByTarget = function(target) {
  var result = [];
  for (var index = 0; index < this._activeAnimatables.length; index++) {
    if (this._activeAnimatables[index].target === target) {
      result.push(this._activeAnimatables[index]);
    }
  }
  return result;
};
Scene.prototype.stopAnimation = function(target, animationName, targetMask) {
  var animatables = this.getAllAnimatablesByTarget(target);
  for (var _i = 0, animatables_1 = animatables; _i < animatables_1.length; _i++) {
    var animatable = animatables_1[_i];
    animatable.stop(animationName, targetMask);
  }
};
Scene.prototype.stopAllAnimations = function() {
  if (this._activeAnimatables) {
    for (var i = 0; i < this._activeAnimatables.length; i++) {
      this._activeAnimatables[i].stop();
    }
    this._activeAnimatables = [];
  }
  for (var _i = 0, _a = this.animationGroups; _i < _a.length; _i++) {
    var group = _a[_i];
    group.stop();
  }
};
Scene.prototype._registerTargetForLateAnimationBinding = function(runtimeAnimation, originalValue) {
  var target = runtimeAnimation.target;
  this._registeredForLateAnimationBindings.pushNoDuplicate(target);
  if (!target._lateAnimationHolders) {
    target._lateAnimationHolders = {};
  }
  if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {
    target._lateAnimationHolders[runtimeAnimation.targetPath] = {
      totalWeight: 0,
      totalAdditiveWeight: 0,
      animations: [],
      additiveAnimations: [],
      originalValue
    };
  }
  if (runtimeAnimation.isAdditive) {
    target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);
    target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;
  } else {
    target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);
    target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;
  }
};
Scene.prototype._processLateAnimationBindingsForMatrices = function(holder) {
  if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {
    return holder.originalValue;
  }
  var normalizer = 1;
  var finalPosition = TmpVectors.Vector3[0];
  var finalScaling = TmpVectors.Vector3[1];
  var finalQuaternion = TmpVectors.Quaternion[0];
  var startIndex = 0;
  var originalAnimation = holder.animations[0];
  var originalValue = holder.originalValue;
  var scale = 1;
  var skipOverride = false;
  if (holder.totalWeight < 1) {
    scale = 1 - holder.totalWeight;
    originalValue.decompose(finalScaling, finalQuaternion, finalPosition);
  } else {
    startIndex = 1;
    normalizer = holder.totalWeight;
    scale = originalAnimation.weight / normalizer;
    if (scale == 1) {
      if (holder.totalAdditiveWeight) {
        skipOverride = true;
      } else {
        return originalAnimation.currentValue;
      }
    }
    originalAnimation.currentValue.decompose(finalScaling, finalQuaternion, finalPosition);
  }
  if (!skipOverride) {
    finalScaling.scaleInPlace(scale);
    finalPosition.scaleInPlace(scale);
    finalQuaternion.scaleInPlace(scale);
    for (var animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {
      var runtimeAnimation = holder.animations[animIndex];
      if (runtimeAnimation.weight === 0) {
        continue;
      }
      var scale = runtimeAnimation.weight / normalizer;
      var currentPosition = TmpVectors.Vector3[2];
      var currentScaling = TmpVectors.Vector3[3];
      var currentQuaternion = TmpVectors.Quaternion[1];
      runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);
      currentScaling.scaleAndAddToRef(scale, finalScaling);
      currentQuaternion.scaleAndAddToRef(scale, finalQuaternion);
      currentPosition.scaleAndAddToRef(scale, finalPosition);
    }
  }
  for (var animIndex_1 = 0; animIndex_1 < holder.additiveAnimations.length; animIndex_1++) {
    var runtimeAnimation = holder.additiveAnimations[animIndex_1];
    if (runtimeAnimation.weight === 0) {
      continue;
    }
    var currentPosition = TmpVectors.Vector3[2];
    var currentScaling = TmpVectors.Vector3[3];
    var currentQuaternion = TmpVectors.Quaternion[1];
    runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);
    currentScaling.multiplyToRef(finalScaling, currentScaling);
    Vector3.LerpToRef(finalScaling, currentScaling, runtimeAnimation.weight, finalScaling);
    finalQuaternion.multiplyToRef(currentQuaternion, currentQuaternion);
    Quaternion.SlerpToRef(finalQuaternion, currentQuaternion, runtimeAnimation.weight, finalQuaternion);
    currentPosition.scaleAndAddToRef(runtimeAnimation.weight, finalPosition);
  }
  var workValue = originalAnimation ? originalAnimation._animationState.workValue : TmpVectors.Matrix[0].clone();
  Matrix.ComposeToRef(finalScaling, finalQuaternion, finalPosition, workValue);
  return workValue;
};
Scene.prototype._processLateAnimationBindingsForQuaternions = function(holder, refQuaternion) {
  if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {
    return refQuaternion;
  }
  var originalAnimation = holder.animations[0];
  var originalValue = holder.originalValue;
  var cumulativeQuaternion = refQuaternion;
  if (holder.totalWeight === 0 && holder.totalAdditiveWeight > 0) {
    cumulativeQuaternion.copyFrom(originalValue);
  } else if (holder.animations.length === 1) {
    Quaternion.SlerpToRef(originalValue, originalAnimation.currentValue, Math.min(1, holder.totalWeight), cumulativeQuaternion);
    if (holder.totalAdditiveWeight === 0) {
      return cumulativeQuaternion;
    }
  } else if (holder.animations.length > 1) {
    var normalizer = 1;
    var quaternions = void 0;
    var weights = void 0;
    if (holder.totalWeight < 1) {
      var scale = 1 - holder.totalWeight;
      quaternions = [];
      weights = [];
      quaternions.push(originalValue);
      weights.push(scale);
    } else {
      if (holder.animations.length === 2) {
        Quaternion.SlerpToRef(holder.animations[0].currentValue, holder.animations[1].currentValue, holder.animations[1].weight / holder.totalWeight, refQuaternion);
        if (holder.totalAdditiveWeight === 0) {
          return refQuaternion;
        }
      }
      quaternions = [];
      weights = [];
      normalizer = holder.totalWeight;
    }
    for (var animIndex = 0; animIndex < holder.animations.length; animIndex++) {
      var runtimeAnimation = holder.animations[animIndex];
      quaternions.push(runtimeAnimation.currentValue);
      weights.push(runtimeAnimation.weight / normalizer);
    }
    var cumulativeAmount = 0;
    for (var index = 0; index < quaternions.length; ) {
      if (!index) {
        Quaternion.SlerpToRef(quaternions[index], quaternions[index + 1], weights[index + 1] / (weights[index] + weights[index + 1]), refQuaternion);
        cumulativeQuaternion = refQuaternion;
        cumulativeAmount = weights[index] + weights[index + 1];
        index += 2;
        continue;
      }
      cumulativeAmount += weights[index];
      Quaternion.SlerpToRef(cumulativeQuaternion, quaternions[index], weights[index] / cumulativeAmount, cumulativeQuaternion);
      index++;
    }
  }
  for (var animIndex_2 = 0; animIndex_2 < holder.additiveAnimations.length; animIndex_2++) {
    var runtimeAnimation = holder.additiveAnimations[animIndex_2];
    if (runtimeAnimation.weight === 0) {
      continue;
    }
    cumulativeQuaternion.multiplyToRef(runtimeAnimation.currentValue, TmpVectors.Quaternion[0]);
    Quaternion.SlerpToRef(cumulativeQuaternion, TmpVectors.Quaternion[0], runtimeAnimation.weight, cumulativeQuaternion);
  }
  return cumulativeQuaternion;
};
Scene.prototype._processLateAnimationBindings = function() {
  if (!this._registeredForLateAnimationBindings.length) {
    return;
  }
  for (var index = 0; index < this._registeredForLateAnimationBindings.length; index++) {
    var target = this._registeredForLateAnimationBindings.data[index];
    for (var path in target._lateAnimationHolders) {
      var holder = target._lateAnimationHolders[path];
      var originalAnimation = holder.animations[0];
      var originalValue = holder.originalValue;
      var matrixDecomposeMode = Animation.AllowMatrixDecomposeForInterpolation && originalValue.m;
      var finalValue = target[path];
      if (matrixDecomposeMode) {
        finalValue = this._processLateAnimationBindingsForMatrices(holder);
      } else {
        var quaternionMode = originalValue.w !== void 0;
        if (quaternionMode) {
          finalValue = this._processLateAnimationBindingsForQuaternions(holder, finalValue || Quaternion.Identity());
        } else {
          var startIndex = 0;
          var normalizer = 1;
          if (holder.totalWeight < 1) {
            if (originalAnimation && originalValue.scale) {
              finalValue = originalValue.scale(1 - holder.totalWeight);
            } else if (originalAnimation) {
              finalValue = originalValue * (1 - holder.totalWeight);
            } else if (originalValue.clone) {
              finalValue = originalValue.clone();
            } else {
              finalValue = originalValue;
            }
          } else if (originalAnimation) {
            normalizer = holder.totalWeight;
            var scale_1 = originalAnimation.weight / normalizer;
            if (scale_1 !== 1) {
              if (originalAnimation.currentValue.scale) {
                finalValue = originalAnimation.currentValue.scale(scale_1);
              } else {
                finalValue = originalAnimation.currentValue * scale_1;
              }
            } else {
              finalValue = originalAnimation.currentValue;
            }
            startIndex = 1;
          }
          for (var animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {
            var runtimeAnimation = holder.animations[animIndex];
            var scale = runtimeAnimation.weight / normalizer;
            if (!scale) {
              continue;
            } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {
              runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);
            } else {
              finalValue += runtimeAnimation.currentValue * scale;
            }
          }
          for (var animIndex_3 = 0; animIndex_3 < holder.additiveAnimations.length; animIndex_3++) {
            var runtimeAnimation = holder.additiveAnimations[animIndex_3];
            var scale = runtimeAnimation.weight;
            if (!scale) {
              continue;
            } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {
              runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);
            } else {
              finalValue += runtimeAnimation.currentValue * scale;
            }
          }
        }
      }
      target[path] = finalValue;
    }
    target._lateAnimationHolders = {};
  }
  this._registeredForLateAnimationBindings.reset();
};
Bone.prototype.copyAnimationRange = function(source, rangeName, frameOffset, rescaleAsRequired, skelDimensionsRatio) {
  if (rescaleAsRequired === void 0) {
    rescaleAsRequired = false;
  }
  if (skelDimensionsRatio === void 0) {
    skelDimensionsRatio = null;
  }
  if (this.animations.length === 0) {
    this.animations.push(new Animation(this.name, "_matrix", source.animations[0].framePerSecond, Animation.ANIMATIONTYPE_MATRIX, 0));
    this.animations[0].setKeys([]);
  }
  var sourceRange = source.animations[0].getRange(rangeName);
  if (!sourceRange) {
    return false;
  }
  var from = sourceRange.from;
  var to = sourceRange.to;
  var sourceKeys = source.animations[0].getKeys();
  var sourceBoneLength = source.length;
  var sourceParent = source.getParent();
  var parent = this.getParent();
  var parentScalingReqd = rescaleAsRequired && sourceParent && sourceBoneLength && this.length && sourceBoneLength !== this.length;
  var parentRatio = parentScalingReqd && parent && sourceParent ? parent.length / sourceParent.length : 1;
  var dimensionsScalingReqd = rescaleAsRequired && !parent && skelDimensionsRatio && (skelDimensionsRatio.x !== 1 || skelDimensionsRatio.y !== 1 || skelDimensionsRatio.z !== 1);
  var destKeys = this.animations[0].getKeys();
  var orig;
  var origTranslation;
  var mat;
  for (var key = 0, nKeys = sourceKeys.length; key < nKeys; key++) {
    orig = sourceKeys[key];
    if (orig.frame >= from && orig.frame <= to) {
      if (rescaleAsRequired) {
        mat = orig.value.clone();
        if (parentScalingReqd) {
          origTranslation = mat.getTranslation();
          mat.setTranslation(origTranslation.scaleInPlace(parentRatio));
        } else if (dimensionsScalingReqd && skelDimensionsRatio) {
          origTranslation = mat.getTranslation();
          mat.setTranslation(origTranslation.multiplyInPlace(skelDimensionsRatio));
        } else {
          mat = orig.value;
        }
      } else {
        mat = orig.value;
      }
      destKeys.push({ frame: orig.frame + frameOffset, value: mat });
    }
  }
  this.animations[0].createRange(rangeName, from + frameOffset, to + frameOffset);
  return true;
};

// node_modules/@babylonjs/core/Animations/animationGroup.js
var TargetedAnimation = function() {
  function TargetedAnimation2() {
  }
  TargetedAnimation2.prototype.getClassName = function() {
    return "TargetedAnimation";
  };
  TargetedAnimation2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.animation = this.animation.serialize();
    serializationObject.targetId = this.target.id;
    return serializationObject;
  };
  return TargetedAnimation2;
}();
var AnimationGroup = function() {
  function AnimationGroup2(name42, scene) {
    if (scene === void 0) {
      scene = null;
    }
    this.name = name42;
    this._targetedAnimations = new Array();
    this._animatables = new Array();
    this._from = Number.MAX_VALUE;
    this._to = -Number.MAX_VALUE;
    this._speedRatio = 1;
    this._loopAnimation = false;
    this._isAdditive = false;
    this.onAnimationEndObservable = new Observable();
    this.onAnimationLoopObservable = new Observable();
    this.onAnimationGroupLoopObservable = new Observable();
    this.onAnimationGroupEndObservable = new Observable();
    this.onAnimationGroupPauseObservable = new Observable();
    this.onAnimationGroupPlayObservable = new Observable();
    this._scene = scene || EngineStore.LastCreatedScene;
    this.uniqueId = this._scene.getUniqueId();
    this._scene.addAnimationGroup(this);
  }
  Object.defineProperty(AnimationGroup2.prototype, "from", {
    get: function() {
      return this._from;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnimationGroup2.prototype, "to", {
    get: function() {
      return this._to;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnimationGroup2.prototype, "isStarted", {
    get: function() {
      return this._isStarted;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnimationGroup2.prototype, "isPlaying", {
    get: function() {
      return this._isStarted && !this._isPaused;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnimationGroup2.prototype, "speedRatio", {
    get: function() {
      return this._speedRatio;
    },
    set: function(value) {
      if (this._speedRatio === value) {
        return;
      }
      this._speedRatio = value;
      for (var index = 0; index < this._animatables.length; index++) {
        var animatable = this._animatables[index];
        animatable.speedRatio = this._speedRatio;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnimationGroup2.prototype, "loopAnimation", {
    get: function() {
      return this._loopAnimation;
    },
    set: function(value) {
      if (this._loopAnimation === value) {
        return;
      }
      this._loopAnimation = value;
      for (var index = 0; index < this._animatables.length; index++) {
        var animatable = this._animatables[index];
        animatable.loopAnimation = this._loopAnimation;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnimationGroup2.prototype, "isAdditive", {
    get: function() {
      return this._isAdditive;
    },
    set: function(value) {
      if (this._isAdditive === value) {
        return;
      }
      this._isAdditive = value;
      for (var index = 0; index < this._animatables.length; index++) {
        var animatable = this._animatables[index];
        animatable.isAdditive = this._isAdditive;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnimationGroup2.prototype, "targetedAnimations", {
    get: function() {
      return this._targetedAnimations;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnimationGroup2.prototype, "animatables", {
    get: function() {
      return this._animatables;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnimationGroup2.prototype, "children", {
    get: function() {
      return this._targetedAnimations;
    },
    enumerable: false,
    configurable: true
  });
  AnimationGroup2.prototype.addTargetedAnimation = function(animation, target) {
    var targetedAnimation = new TargetedAnimation();
    targetedAnimation.animation = animation;
    targetedAnimation.target = target;
    var keys = animation.getKeys();
    if (this._from > keys[0].frame) {
      this._from = keys[0].frame;
    }
    if (this._to < keys[keys.length - 1].frame) {
      this._to = keys[keys.length - 1].frame;
    }
    this._targetedAnimations.push(targetedAnimation);
    return targetedAnimation;
  };
  AnimationGroup2.prototype.normalize = function(beginFrame, endFrame) {
    if (beginFrame === void 0) {
      beginFrame = null;
    }
    if (endFrame === void 0) {
      endFrame = null;
    }
    if (beginFrame == null) {
      beginFrame = this._from;
    }
    if (endFrame == null) {
      endFrame = this._to;
    }
    for (var index = 0; index < this._targetedAnimations.length; index++) {
      var targetedAnimation = this._targetedAnimations[index];
      var keys = targetedAnimation.animation.getKeys();
      var startKey = keys[0];
      var endKey = keys[keys.length - 1];
      if (startKey.frame > beginFrame) {
        var newKey = {
          frame: beginFrame,
          value: startKey.value,
          inTangent: startKey.inTangent,
          outTangent: startKey.outTangent,
          interpolation: startKey.interpolation
        };
        keys.splice(0, 0, newKey);
      }
      if (endKey.frame < endFrame) {
        var newKey = {
          frame: endFrame,
          value: endKey.value,
          inTangent: endKey.inTangent,
          outTangent: endKey.outTangent,
          interpolation: endKey.interpolation
        };
        keys.push(newKey);
      }
    }
    this._from = beginFrame;
    this._to = endFrame;
    return this;
  };
  AnimationGroup2.prototype._processLoop = function(animatable, targetedAnimation, index) {
    var _this = this;
    animatable.onAnimationLoop = function() {
      _this.onAnimationLoopObservable.notifyObservers(targetedAnimation);
      if (_this._animationLoopFlags[index]) {
        return;
      }
      _this._animationLoopFlags[index] = true;
      _this._animationLoopCount++;
      if (_this._animationLoopCount === _this._targetedAnimations.length) {
        _this.onAnimationGroupLoopObservable.notifyObservers(_this);
        _this._animationLoopCount = 0;
        _this._animationLoopFlags = [];
      }
    };
  };
  AnimationGroup2.prototype.start = function(loop, speedRatio, from, to, isAdditive) {
    var _this = this;
    if (loop === void 0) {
      loop = false;
    }
    if (speedRatio === void 0) {
      speedRatio = 1;
    }
    if (this._isStarted || this._targetedAnimations.length === 0) {
      return this;
    }
    this._loopAnimation = loop;
    this._animationLoopCount = 0;
    this._animationLoopFlags = [];
    var _loop_1 = function() {
      var targetedAnimation = this_1._targetedAnimations[index];
      var animatable = this_1._scene.beginDirectAnimation(targetedAnimation.target, [targetedAnimation.animation], from !== void 0 ? from : this_1._from, to !== void 0 ? to : this_1._to, loop, speedRatio, void 0, void 0, isAdditive !== void 0 ? isAdditive : this_1._isAdditive);
      animatable.onAnimationEnd = function() {
        _this.onAnimationEndObservable.notifyObservers(targetedAnimation);
        _this._checkAnimationGroupEnded(animatable);
      };
      this_1._processLoop(animatable, targetedAnimation, index);
      this_1._animatables.push(animatable);
    };
    var this_1 = this;
    for (var index = 0; index < this._targetedAnimations.length; index++) {
      _loop_1();
    }
    this._speedRatio = speedRatio;
    if (from !== void 0 && to !== void 0) {
      if (from < to && this._speedRatio < 0) {
        var temp = to;
        to = from;
        from = temp;
      } else if (from > to && this._speedRatio > 0) {
        this._speedRatio = -speedRatio;
      }
    }
    this._isStarted = true;
    this._isPaused = false;
    this.onAnimationGroupPlayObservable.notifyObservers(this);
    return this;
  };
  AnimationGroup2.prototype.pause = function() {
    if (!this._isStarted) {
      return this;
    }
    this._isPaused = true;
    for (var index = 0; index < this._animatables.length; index++) {
      var animatable = this._animatables[index];
      animatable.pause();
    }
    this.onAnimationGroupPauseObservable.notifyObservers(this);
    return this;
  };
  AnimationGroup2.prototype.play = function(loop) {
    if (this.isStarted && this._animatables.length === this._targetedAnimations.length) {
      if (loop !== void 0) {
        this.loopAnimation = loop;
      }
      this.restart();
    } else {
      this.stop();
      this.start(loop, this._speedRatio);
    }
    this._isPaused = false;
    return this;
  };
  AnimationGroup2.prototype.reset = function() {
    if (!this._isStarted) {
      this.play();
      this.goToFrame(0);
      this.stop();
      return this;
    }
    for (var index = 0; index < this._animatables.length; index++) {
      var animatable = this._animatables[index];
      animatable.reset();
    }
    return this;
  };
  AnimationGroup2.prototype.restart = function() {
    if (!this._isStarted) {
      return this;
    }
    for (var index = 0; index < this._animatables.length; index++) {
      var animatable = this._animatables[index];
      animatable.restart();
    }
    this.onAnimationGroupPlayObservable.notifyObservers(this);
    return this;
  };
  AnimationGroup2.prototype.stop = function() {
    if (!this._isStarted) {
      return this;
    }
    var list = this._animatables.slice();
    for (var index = 0; index < list.length; index++) {
      list[index].stop();
    }
    this._isStarted = false;
    return this;
  };
  AnimationGroup2.prototype.setWeightForAllAnimatables = function(weight) {
    for (var index = 0; index < this._animatables.length; index++) {
      var animatable = this._animatables[index];
      animatable.weight = weight;
    }
    return this;
  };
  AnimationGroup2.prototype.syncAllAnimationsWith = function(root) {
    for (var index = 0; index < this._animatables.length; index++) {
      var animatable = this._animatables[index];
      animatable.syncWith(root);
    }
    return this;
  };
  AnimationGroup2.prototype.goToFrame = function(frame) {
    if (!this._isStarted) {
      return this;
    }
    for (var index = 0; index < this._animatables.length; index++) {
      var animatable = this._animatables[index];
      animatable.goToFrame(frame);
    }
    return this;
  };
  AnimationGroup2.prototype.dispose = function() {
    this._targetedAnimations = [];
    this._animatables = [];
    var index = this._scene.animationGroups.indexOf(this);
    if (index > -1) {
      this._scene.animationGroups.splice(index, 1);
    }
    this.onAnimationEndObservable.clear();
    this.onAnimationGroupEndObservable.clear();
    this.onAnimationGroupPauseObservable.clear();
    this.onAnimationGroupPlayObservable.clear();
    this.onAnimationLoopObservable.clear();
    this.onAnimationGroupLoopObservable.clear();
  };
  AnimationGroup2.prototype._checkAnimationGroupEnded = function(animatable) {
    var idx = this._animatables.indexOf(animatable);
    if (idx > -1) {
      this._animatables.splice(idx, 1);
    }
    if (this._animatables.length === 0) {
      this._isStarted = false;
      this.onAnimationGroupEndObservable.notifyObservers(this);
    }
  };
  AnimationGroup2.prototype.clone = function(newName, targetConverter) {
    var newGroup = new AnimationGroup2(newName || this.name, this._scene);
    for (var _i = 0, _a = this._targetedAnimations; _i < _a.length; _i++) {
      var targetAnimation = _a[_i];
      newGroup.addTargetedAnimation(targetAnimation.animation.clone(), targetConverter ? targetConverter(targetAnimation.target) : targetAnimation.target);
    }
    return newGroup;
  };
  AnimationGroup2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.name = this.name;
    serializationObject.from = this.from;
    serializationObject.to = this.to;
    serializationObject.targetedAnimations = [];
    for (var targetedAnimationIndex = 0; targetedAnimationIndex < this.targetedAnimations.length; targetedAnimationIndex++) {
      var targetedAnimation = this.targetedAnimations[targetedAnimationIndex];
      serializationObject.targetedAnimations[targetedAnimationIndex] = targetedAnimation.serialize();
    }
    return serializationObject;
  };
  AnimationGroup2.Parse = function(parsedAnimationGroup, scene) {
    var animationGroup = new AnimationGroup2(parsedAnimationGroup.name, scene);
    for (var i = 0; i < parsedAnimationGroup.targetedAnimations.length; i++) {
      var targetedAnimation = parsedAnimationGroup.targetedAnimations[i];
      var animation = Animation.Parse(targetedAnimation.animation);
      var id = targetedAnimation.targetId;
      if (targetedAnimation.animation.property === "influence") {
        var morphTarget = scene.getMorphTargetById(id);
        if (morphTarget) {
          animationGroup.addTargetedAnimation(animation, morphTarget);
        }
      } else {
        var targetNode = scene.getNodeByID(id);
        if (targetNode != null) {
          animationGroup.addTargetedAnimation(animation, targetNode);
        }
      }
    }
    if (parsedAnimationGroup.from !== null && parsedAnimationGroup.to !== null) {
      animationGroup.normalize(parsedAnimationGroup.from, parsedAnimationGroup.to);
    }
    return animationGroup;
  };
  AnimationGroup2.MakeAnimationAdditive = function(sourceAnimationGroup, referenceFrame, range, cloneOriginal, clonedName) {
    if (referenceFrame === void 0) {
      referenceFrame = 0;
    }
    if (cloneOriginal === void 0) {
      cloneOriginal = false;
    }
    var animationGroup = sourceAnimationGroup;
    if (cloneOriginal) {
      animationGroup = sourceAnimationGroup.clone(clonedName || animationGroup.name);
    }
    var targetedAnimations = animationGroup.targetedAnimations;
    for (var index = 0; index < targetedAnimations.length; index++) {
      var targetedAnimation = targetedAnimations[index];
      Animation.MakeAnimationAdditive(targetedAnimation.animation, referenceFrame, range);
    }
    animationGroup.isAdditive = true;
    return animationGroup;
  };
  AnimationGroup2.prototype.getClassName = function() {
    return "AnimationGroup";
  };
  AnimationGroup2.prototype.toString = function(fullDetails) {
    var ret = "Name: " + this.name;
    ret += ", type: " + this.getClassName();
    if (fullDetails) {
      ret += ", from: " + this._from;
      ret += ", to: " + this._to;
      ret += ", isStarted: " + this._isStarted;
      ret += ", speedRatio: " + this._speedRatio;
      ret += ", targetedAnimations length: " + this._targetedAnimations.length;
      ret += ", animatables length: " + this._animatables;
    }
    return ret;
  };
  return AnimationGroup2;
}();

// node_modules/@babylonjs/core/Animations/animationEvent.js
var AnimationEvent = function() {
  function AnimationEvent2(frame, action, onlyOnce) {
    this.frame = frame;
    this.action = action;
    this.onlyOnce = onlyOnce;
    this.isDone = false;
  }
  AnimationEvent2.prototype._clone = function() {
    return new AnimationEvent2(this.frame, this.action, this.onlyOnce);
  };
  return AnimationEvent2;
}();

// node_modules/@babylonjs/core/assetContainer.js
var KeepAssets = function(_super) {
  __extends(KeepAssets2, _super);
  function KeepAssets2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return KeepAssets2;
}(AbstractScene);
var InstantiatedEntries = function() {
  function InstantiatedEntries2() {
    this.rootNodes = [];
    this.skeletons = [];
    this.animationGroups = [];
  }
  return InstantiatedEntries2;
}();
var AssetContainer = function(_super) {
  __extends(AssetContainer2, _super);
  function AssetContainer2(scene) {
    var _this = _super.call(this) || this;
    _this._wasAddedToScene = false;
    _this.scene = scene;
    _this["sounds"] = [];
    _this["effectLayers"] = [];
    _this["layers"] = [];
    _this["lensFlareSystems"] = [];
    _this["proceduralTextures"] = [];
    _this["reflectionProbes"] = [];
    scene.onDisposeObservable.add(function() {
      if (!_this._wasAddedToScene) {
        _this.dispose();
      }
    });
    return _this;
  }
  AssetContainer2.prototype.instantiateModelsToScene = function(nameFunction, cloneMaterials) {
    var _this = this;
    if (cloneMaterials === void 0) {
      cloneMaterials = false;
    }
    var convertionMap = {};
    var storeMap = {};
    var result = new InstantiatedEntries();
    var alreadySwappedSkeletons = [];
    var alreadySwappedMaterials = [];
    var options = {
      doNotInstantiate: true
    };
    var onClone = function(source, clone) {
      convertionMap[source.uniqueId] = clone.uniqueId;
      storeMap[clone.uniqueId] = clone;
      if (nameFunction) {
        clone.name = nameFunction(source.name);
      }
      if (clone instanceof Mesh) {
        var clonedMesh = clone;
        if (clonedMesh.morphTargetManager) {
          var oldMorphTargetManager = source.morphTargetManager;
          clonedMesh.morphTargetManager = oldMorphTargetManager.clone();
          for (var index = 0; index < oldMorphTargetManager.numTargets; index++) {
            var oldTarget = oldMorphTargetManager.getTarget(index);
            var newTarget = clonedMesh.morphTargetManager.getTarget(index);
            convertionMap[oldTarget.uniqueId] = newTarget.uniqueId;
            storeMap[newTarget.uniqueId] = newTarget;
          }
        }
      }
    };
    this.transformNodes.forEach(function(o) {
      if (!o.parent) {
        var newOne = o.instantiateHierarchy(null, options, function(source, clone) {
          onClone(source, clone);
        });
        if (newOne) {
          result.rootNodes.push(newOne);
        }
      }
    });
    this.meshes.forEach(function(o) {
      if (!o.parent) {
        var newOne = o.instantiateHierarchy(null, options, function(source, clone) {
          onClone(source, clone);
          if (clone.material) {
            var mesh = clone;
            if (mesh.material) {
              if (cloneMaterials) {
                var sourceMaterial = source.material;
                if (alreadySwappedMaterials.indexOf(sourceMaterial) === -1) {
                  var swap = sourceMaterial.clone(nameFunction ? nameFunction(sourceMaterial.name) : "Clone of " + sourceMaterial.name);
                  alreadySwappedMaterials.push(sourceMaterial);
                  convertionMap[sourceMaterial.uniqueId] = swap.uniqueId;
                  storeMap[swap.uniqueId] = swap;
                  if (sourceMaterial.getClassName() === "MultiMaterial") {
                    var multi = sourceMaterial;
                    for (var _i = 0, _a = multi.subMaterials; _i < _a.length; _i++) {
                      var material = _a[_i];
                      if (!material) {
                        continue;
                      }
                      swap = material.clone(nameFunction ? nameFunction(material.name) : "Clone of " + material.name);
                      alreadySwappedMaterials.push(material);
                      convertionMap[material.uniqueId] = swap.uniqueId;
                      storeMap[swap.uniqueId] = swap;
                    }
                    multi.subMaterials = multi.subMaterials.map(function(m) {
                      return m && storeMap[convertionMap[m.uniqueId]];
                    });
                  }
                }
                mesh.material = storeMap[convertionMap[sourceMaterial.uniqueId]];
              } else {
                if (mesh.material.getClassName() === "MultiMaterial") {
                  if (_this.scene.multiMaterials.indexOf(mesh.material) === -1) {
                    _this.scene.addMultiMaterial(mesh.material);
                  }
                } else {
                  if (_this.scene.materials.indexOf(mesh.material) === -1) {
                    _this.scene.addMaterial(mesh.material);
                  }
                }
              }
            }
          }
        });
        if (newOne) {
          result.rootNodes.push(newOne);
        }
      }
    });
    this.skeletons.forEach(function(s) {
      var clone = s.clone(nameFunction ? nameFunction(s.name) : "Clone of " + s.name);
      if (s.overrideMesh) {
        clone.overrideMesh = storeMap[convertionMap[s.overrideMesh.uniqueId]];
      }
      for (var _i = 0, _a = _this.meshes; _i < _a.length; _i++) {
        var m = _a[_i];
        if (m.skeleton === s && !m.isAnInstance) {
          var copy = storeMap[convertionMap[m.uniqueId]];
          copy.skeleton = clone;
          if (alreadySwappedSkeletons.indexOf(clone) !== -1) {
            continue;
          }
          alreadySwappedSkeletons.push(clone);
          for (var _b = 0, _c = clone.bones; _b < _c.length; _b++) {
            var bone = _c[_b];
            if (bone._linkedTransformNode) {
              bone._linkedTransformNode = storeMap[convertionMap[bone._linkedTransformNode.uniqueId]];
            }
          }
        }
      }
      result.skeletons.push(clone);
    });
    this.animationGroups.forEach(function(o) {
      var clone = o.clone(o.name, function(oldTarget) {
        var newTarget = storeMap[convertionMap[oldTarget.uniqueId]];
        return newTarget || oldTarget;
      });
      result.animationGroups.push(clone);
    });
    return result;
  };
  AssetContainer2.prototype.addAllToScene = function() {
    var _this = this;
    this._wasAddedToScene = true;
    this.cameras.forEach(function(o) {
      _this.scene.addCamera(o);
    });
    this.lights.forEach(function(o) {
      _this.scene.addLight(o);
    });
    this.meshes.forEach(function(o) {
      _this.scene.addMesh(o);
    });
    this.skeletons.forEach(function(o) {
      _this.scene.addSkeleton(o);
    });
    this.animations.forEach(function(o) {
      _this.scene.addAnimation(o);
    });
    this.animationGroups.forEach(function(o) {
      _this.scene.addAnimationGroup(o);
    });
    this.multiMaterials.forEach(function(o) {
      _this.scene.addMultiMaterial(o);
    });
    this.materials.forEach(function(o) {
      _this.scene.addMaterial(o);
    });
    this.morphTargetManagers.forEach(function(o) {
      _this.scene.addMorphTargetManager(o);
    });
    this.geometries.forEach(function(o) {
      _this.scene.addGeometry(o);
    });
    this.transformNodes.forEach(function(o) {
      _this.scene.addTransformNode(o);
    });
    this.actionManagers.forEach(function(o) {
      _this.scene.addActionManager(o);
    });
    this.textures.forEach(function(o) {
      _this.scene.addTexture(o);
    });
    this.reflectionProbes.forEach(function(o) {
      _this.scene.addReflectionProbe(o);
    });
    if (this.environmentTexture) {
      this.scene.environmentTexture = this.environmentTexture;
    }
    for (var _i = 0, _a = this.scene._serializableComponents; _i < _a.length; _i++) {
      var component = _a[_i];
      component.addFromContainer(this);
    }
  };
  AssetContainer2.prototype.removeAllFromScene = function() {
    var _this = this;
    this._wasAddedToScene = false;
    this.cameras.forEach(function(o) {
      _this.scene.removeCamera(o);
    });
    this.lights.forEach(function(o) {
      _this.scene.removeLight(o);
    });
    this.meshes.forEach(function(o) {
      _this.scene.removeMesh(o);
    });
    this.skeletons.forEach(function(o) {
      _this.scene.removeSkeleton(o);
    });
    this.animations.forEach(function(o) {
      _this.scene.removeAnimation(o);
    });
    this.animationGroups.forEach(function(o) {
      _this.scene.removeAnimationGroup(o);
    });
    this.multiMaterials.forEach(function(o) {
      _this.scene.removeMultiMaterial(o);
    });
    this.materials.forEach(function(o) {
      _this.scene.removeMaterial(o);
    });
    this.morphTargetManagers.forEach(function(o) {
      _this.scene.removeMorphTargetManager(o);
    });
    this.geometries.forEach(function(o) {
      _this.scene.removeGeometry(o);
    });
    this.transformNodes.forEach(function(o) {
      _this.scene.removeTransformNode(o);
    });
    this.actionManagers.forEach(function(o) {
      _this.scene.removeActionManager(o);
    });
    this.textures.forEach(function(o) {
      _this.scene.removeTexture(o);
    });
    this.reflectionProbes.forEach(function(o) {
      _this.scene.removeReflectionProbe(o);
    });
    if (this.environmentTexture === this.scene.environmentTexture) {
      this.scene.environmentTexture = null;
    }
    for (var _i = 0, _a = this.scene._serializableComponents; _i < _a.length; _i++) {
      var component = _a[_i];
      component.removeFromContainer(this);
    }
  };
  AssetContainer2.prototype.dispose = function() {
    this.cameras.forEach(function(o) {
      o.dispose();
    });
    this.cameras = [];
    this.lights.forEach(function(o) {
      o.dispose();
    });
    this.lights = [];
    this.meshes.forEach(function(o) {
      o.dispose();
    });
    this.meshes = [];
    this.skeletons.forEach(function(o) {
      o.dispose();
    });
    this.skeletons = [];
    this.animationGroups.forEach(function(o) {
      o.dispose();
    });
    this.animationGroups = [];
    this.multiMaterials.forEach(function(o) {
      o.dispose();
    });
    this.multiMaterials = [];
    this.materials.forEach(function(o) {
      o.dispose();
    });
    this.materials = [];
    this.geometries.forEach(function(o) {
      o.dispose();
    });
    this.geometries = [];
    this.transformNodes.forEach(function(o) {
      o.dispose();
    });
    this.transformNodes = [];
    this.actionManagers.forEach(function(o) {
      o.dispose();
    });
    this.actionManagers = [];
    this.textures.forEach(function(o) {
      o.dispose();
    });
    this.textures = [];
    this.reflectionProbes.forEach(function(o) {
      o.dispose();
    });
    this.reflectionProbes = [];
    if (this.environmentTexture) {
      this.environmentTexture.dispose();
      this.environmentTexture = null;
    }
    for (var _i = 0, _a = this.scene._serializableComponents; _i < _a.length; _i++) {
      var component = _a[_i];
      component.removeFromContainer(this, true);
    }
  };
  AssetContainer2.prototype._moveAssets = function(sourceAssets, targetAssets, keepAssets) {
    if (!sourceAssets) {
      return;
    }
    for (var _i = 0, sourceAssets_1 = sourceAssets; _i < sourceAssets_1.length; _i++) {
      var asset = sourceAssets_1[_i];
      var move = true;
      if (keepAssets) {
        for (var _a = 0, keepAssets_1 = keepAssets; _a < keepAssets_1.length; _a++) {
          var keepAsset = keepAssets_1[_a];
          if (asset === keepAsset) {
            move = false;
            break;
          }
        }
      }
      if (move) {
        targetAssets.push(asset);
      }
    }
  };
  AssetContainer2.prototype.moveAllFromScene = function(keepAssets) {
    this._wasAddedToScene = false;
    if (keepAssets === void 0) {
      keepAssets = new KeepAssets();
    }
    for (var key in this) {
      if (this.hasOwnProperty(key)) {
        this[key] = this[key] || (key === "environmentTexture" ? null : []);
        this._moveAssets(this.scene[key], this[key], keepAssets[key]);
      }
    }
    this.environmentTexture = this.scene.environmentTexture;
    this.removeAllFromScene();
  };
  AssetContainer2.prototype.createRootMesh = function() {
    var rootMesh = new Mesh("assetContainerRootMesh", this.scene);
    this.meshes.forEach(function(m) {
      if (!m.parent) {
        rootMesh.addChild(m);
      }
    });
    this.meshes.unshift(rootMesh);
    return rootMesh;
  };
  AssetContainer2.prototype.mergeAnimationsTo = function(scene, animatables, targetConverter) {
    if (scene === void 0) {
      scene = EngineStore.LastCreatedScene;
    }
    if (targetConverter === void 0) {
      targetConverter = null;
    }
    if (!scene) {
      Logger.Error("No scene available to merge animations to");
      return [];
    }
    var _targetConverter = targetConverter ? targetConverter : function(target) {
      var node = null;
      var targetProperty = target.animations.length ? target.animations[0].targetProperty : "";
      var name42 = target.name.split(".").join("").split("_primitive")[0];
      switch (targetProperty) {
        case "position":
        case "rotationQuaternion":
          node = scene.getTransformNodeByName(target.name) || scene.getTransformNodeByName(name42);
          break;
        case "influence":
          node = scene.getMorphTargetByName(target.name) || scene.getMorphTargetByName(name42);
          break;
        default:
          node = scene.getNodeByName(target.name) || scene.getNodeByName(name42);
      }
      return node;
    };
    var nodesInAC = this.getNodes();
    nodesInAC.forEach(function(nodeInAC) {
      var nodeInScene = _targetConverter(nodeInAC);
      if (nodeInScene !== null) {
        var _loop_1 = function(animationInAC2) {
          var animationsWithSameProperty = nodeInScene.animations.filter(function(animationInScene) {
            return animationInScene.targetProperty === animationInAC2.targetProperty;
          });
          for (var _i2 = 0, animationsWithSameProperty_1 = animationsWithSameProperty; _i2 < animationsWithSameProperty_1.length; _i2++) {
            var animationWithSameProperty = animationsWithSameProperty_1[_i2];
            var index = nodeInScene.animations.indexOf(animationWithSameProperty, 0);
            if (index > -1) {
              nodeInScene.animations.splice(index, 1);
            }
          }
        };
        for (var _i = 0, _a = nodeInAC.animations; _i < _a.length; _i++) {
          var animationInAC = _a[_i];
          _loop_1(animationInAC);
        }
        nodeInScene.animations = nodeInScene.animations.concat(nodeInAC.animations);
      }
    });
    var newAnimationGroups = new Array();
    this.animationGroups.slice().forEach(function(animationGroupInAC) {
      newAnimationGroups.push(animationGroupInAC.clone(animationGroupInAC.name, _targetConverter));
      animationGroupInAC.animatables.forEach(function(animatable) {
        animatable.stop();
      });
    });
    animatables.forEach(function(animatable) {
      var target = _targetConverter(animatable.target);
      if (target) {
        scene.beginAnimation(target, animatable.fromFrame, animatable.toFrame, animatable.loopAnimation, animatable.speedRatio, animatable.onAnimationEnd ? animatable.onAnimationEnd : void 0, void 0, true, void 0, animatable.onAnimationLoop ? animatable.onAnimationLoop : void 0);
        scene.stopAnimation(animatable.target);
      }
    });
    return newAnimationGroups;
  };
  return AssetContainer2;
}(AbstractScene);

// node_modules/@babylonjs/core/Audio/sound.js
var Sound = function() {
  function Sound2(name42, urlOrArrayBuffer, scene, readyToPlayCallback, options) {
    var _this = this;
    if (readyToPlayCallback === void 0) {
      readyToPlayCallback = null;
    }
    var _a, _b, _c, _d;
    this.autoplay = false;
    this.loop = false;
    this.useCustomAttenuation = false;
    this.isPlaying = false;
    this.isPaused = false;
    this.spatialSound = false;
    this.refDistance = 1;
    this.rolloffFactor = 1;
    this.maxDistance = 100;
    this.distanceModel = "linear";
    this.metadata = null;
    this.onEndedObservable = new Observable();
    this._panningModel = "equalpower";
    this._playbackRate = 1;
    this._streaming = false;
    this._startTime = 0;
    this._startOffset = 0;
    this._position = Vector3.Zero();
    this._positionInEmitterSpace = false;
    this._localDirection = new Vector3(1, 0, 0);
    this._volume = 1;
    this._isReadyToPlay = false;
    this._isDirectional = false;
    this._coneInnerAngle = 360;
    this._coneOuterAngle = 360;
    this._coneOuterGain = 0;
    this._isOutputConnected = false;
    this._urlType = "Unknown";
    this.name = name42;
    this._scene = scene;
    Sound2._SceneComponentInitialization(scene);
    this._readyToPlayCallback = readyToPlayCallback;
    this._customAttenuationFunction = function(currentVolume, currentDistance, maxDistance, refDistance, rolloffFactor) {
      if (currentDistance < maxDistance) {
        return currentVolume * (1 - currentDistance / maxDistance);
      } else {
        return 0;
      }
    };
    if (options) {
      this.autoplay = options.autoplay || false;
      this.loop = options.loop || false;
      if (options.volume !== void 0) {
        this._volume = options.volume;
      }
      this.spatialSound = (_a = options.spatialSound) !== null && _a !== void 0 ? _a : false;
      this.maxDistance = (_b = options.maxDistance) !== null && _b !== void 0 ? _b : 100;
      this.useCustomAttenuation = (_c = options.useCustomAttenuation) !== null && _c !== void 0 ? _c : false;
      this.rolloffFactor = options.rolloffFactor || 1;
      this.refDistance = options.refDistance || 1;
      this.distanceModel = options.distanceModel || "linear";
      this._playbackRate = options.playbackRate || 1;
      this._streaming = (_d = options.streaming) !== null && _d !== void 0 ? _d : false;
      this._length = options.length;
      this._offset = options.offset;
    }
    if (Engine.audioEngine.canUseWebAudio && Engine.audioEngine.audioContext) {
      this._soundGain = Engine.audioEngine.audioContext.createGain();
      this._soundGain.gain.value = this._volume;
      this._inputAudioNode = this._soundGain;
      this._outputAudioNode = this._soundGain;
      if (this.spatialSound) {
        this._createSpatialParameters();
      }
      this._scene.mainSoundTrack.addSound(this);
      var validParameter = true;
      if (urlOrArrayBuffer) {
        try {
          if (typeof urlOrArrayBuffer === "string") {
            this._urlType = "String";
          } else if (urlOrArrayBuffer instanceof ArrayBuffer) {
            this._urlType = "ArrayBuffer";
          } else if (urlOrArrayBuffer instanceof MediaStream) {
            this._urlType = "MediaStream";
          } else if (Array.isArray(urlOrArrayBuffer)) {
            this._urlType = "Array";
          }
          var urls = [];
          var codecSupportedFound = false;
          switch (this._urlType) {
            case "MediaStream":
              this._streaming = true;
              this._isReadyToPlay = true;
              this._streamingSource = Engine.audioEngine.audioContext.createMediaStreamSource(urlOrArrayBuffer);
              if (this.autoplay) {
                this.play(0, this._offset, this._length);
              }
              if (this._readyToPlayCallback) {
                this._readyToPlayCallback();
              }
              break;
            case "ArrayBuffer":
              if (urlOrArrayBuffer.byteLength > 0) {
                codecSupportedFound = true;
                this._soundLoaded(urlOrArrayBuffer);
              }
              break;
            case "String":
              urls.push(urlOrArrayBuffer);
            case "Array":
              if (urls.length === 0) {
                urls = urlOrArrayBuffer;
              }
              for (var i = 0; i < urls.length; i++) {
                var url = urls[i];
                codecSupportedFound = options && options.skipCodecCheck || url.indexOf(".mp3", url.length - 4) !== -1 && Engine.audioEngine.isMP3supported || url.indexOf(".ogg", url.length - 4) !== -1 && Engine.audioEngine.isOGGsupported || url.indexOf(".wav", url.length - 4) !== -1 || url.indexOf(".m4a", url.length - 4) !== -1 || url.indexOf("blob:") !== -1;
                if (codecSupportedFound) {
                  if (!this._streaming) {
                    this._scene._loadFile(url, function(data) {
                      _this._soundLoaded(data);
                    }, void 0, true, true, function(exception) {
                      if (exception) {
                        Logger.Error("XHR " + exception.status + " error on: " + url + ".");
                      }
                      Logger.Error("Sound creation aborted.");
                      _this._scene.mainSoundTrack.removeSound(_this);
                    });
                  } else {
                    this._htmlAudioElement = new Audio(url);
                    this._htmlAudioElement.controls = false;
                    this._htmlAudioElement.loop = this.loop;
                    Tools.SetCorsBehavior(url, this._htmlAudioElement);
                    this._htmlAudioElement.preload = "auto";
                    this._htmlAudioElement.addEventListener("canplaythrough", function() {
                      _this._isReadyToPlay = true;
                      if (_this.autoplay) {
                        _this.play(0, _this._offset, _this._length);
                      }
                      if (_this._readyToPlayCallback) {
                        _this._readyToPlayCallback();
                      }
                    });
                    document.body.appendChild(this._htmlAudioElement);
                    this._htmlAudioElement.load();
                  }
                  break;
                }
              }
              break;
            default:
              validParameter = false;
              break;
          }
          if (!validParameter) {
            Logger.Error("Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.");
          } else {
            if (!codecSupportedFound) {
              this._isReadyToPlay = true;
              if (this._readyToPlayCallback) {
                window.setTimeout(function() {
                  if (_this._readyToPlayCallback) {
                    _this._readyToPlayCallback();
                  }
                }, 1e3);
              }
            }
          }
        } catch (ex) {
          Logger.Error("Unexpected error. Sound creation aborted.");
          this._scene.mainSoundTrack.removeSound(this);
        }
      }
    } else {
      this._scene.mainSoundTrack.addSound(this);
      if (!Engine.audioEngine.WarnedWebAudioUnsupported) {
        Logger.Error("Web Audio is not supported by your browser.");
        Engine.audioEngine.WarnedWebAudioUnsupported = true;
      }
      if (this._readyToPlayCallback) {
        window.setTimeout(function() {
          if (_this._readyToPlayCallback) {
            _this._readyToPlayCallback();
          }
        }, 1e3);
      }
    }
  }
  Object.defineProperty(Sound2.prototype, "currentTime", {
    get: function() {
      if (this._htmlAudioElement) {
        return this._htmlAudioElement.currentTime;
      }
      var currentTime = this._startOffset;
      if (this.isPlaying && Engine.audioEngine.audioContext) {
        currentTime += Engine.audioEngine.audioContext.currentTime - this._startTime;
      }
      return currentTime;
    },
    enumerable: false,
    configurable: true
  });
  Sound2.prototype.dispose = function() {
    if (Engine.audioEngine.canUseWebAudio) {
      if (this.isPlaying) {
        this.stop();
      }
      this._isReadyToPlay = false;
      if (this.soundTrackId === -1) {
        this._scene.mainSoundTrack.removeSound(this);
      } else if (this._scene.soundTracks) {
        this._scene.soundTracks[this.soundTrackId].removeSound(this);
      }
      if (this._soundGain) {
        this._soundGain.disconnect();
        this._soundGain = null;
      }
      if (this._soundPanner) {
        this._soundPanner.disconnect();
        this._soundPanner = null;
      }
      if (this._soundSource) {
        this._soundSource.disconnect();
        this._soundSource = null;
      }
      this._audioBuffer = null;
      if (this._htmlAudioElement) {
        this._htmlAudioElement.pause();
        this._htmlAudioElement.src = "";
        document.body.removeChild(this._htmlAudioElement);
      }
      if (this._streamingSource) {
        this._streamingSource.disconnect();
      }
      if (this._connectedTransformNode && this._registerFunc) {
        this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);
        this._connectedTransformNode = null;
      }
    }
  };
  Sound2.prototype.isReady = function() {
    return this._isReadyToPlay;
  };
  Sound2.prototype._soundLoaded = function(audioData) {
    var _this = this;
    if (!Engine.audioEngine.audioContext) {
      return;
    }
    Engine.audioEngine.audioContext.decodeAudioData(audioData, function(buffer) {
      _this._audioBuffer = buffer;
      _this._isReadyToPlay = true;
      if (_this.autoplay) {
        _this.play(0, _this._offset, _this._length);
      }
      if (_this._readyToPlayCallback) {
        _this._readyToPlayCallback();
      }
    }, function(err) {
      Logger.Error("Error while decoding audio data for: " + _this.name + " / Error: " + err);
    });
  };
  Sound2.prototype.setAudioBuffer = function(audioBuffer) {
    if (Engine.audioEngine.canUseWebAudio) {
      this._audioBuffer = audioBuffer;
      this._isReadyToPlay = true;
    }
  };
  Sound2.prototype.updateOptions = function(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    if (options) {
      this.loop = (_a = options.loop) !== null && _a !== void 0 ? _a : this.loop;
      this.maxDistance = (_b = options.maxDistance) !== null && _b !== void 0 ? _b : this.maxDistance;
      this.useCustomAttenuation = (_c = options.useCustomAttenuation) !== null && _c !== void 0 ? _c : this.useCustomAttenuation;
      this.rolloffFactor = (_d = options.rolloffFactor) !== null && _d !== void 0 ? _d : this.rolloffFactor;
      this.refDistance = (_e = options.refDistance) !== null && _e !== void 0 ? _e : this.refDistance;
      this.distanceModel = (_f = options.distanceModel) !== null && _f !== void 0 ? _f : this.distanceModel;
      this._playbackRate = (_g = options.playbackRate) !== null && _g !== void 0 ? _g : this._playbackRate;
      this._length = (_h = options.length) !== null && _h !== void 0 ? _h : void 0;
      this._offset = (_j = options.offset) !== null && _j !== void 0 ? _j : void 0;
      this._updateSpatialParameters();
      if (this.isPlaying) {
        if (this._streaming && this._htmlAudioElement) {
          this._htmlAudioElement.playbackRate = this._playbackRate;
          if (this._htmlAudioElement.loop !== this.loop) {
            this._htmlAudioElement.loop = this.loop;
          }
        } else {
          if (this._soundSource) {
            this._soundSource.playbackRate.value = this._playbackRate;
            if (this._soundSource.loop !== this.loop) {
              this._soundSource.loop = this.loop;
            }
            if (this._offset !== void 0 && this._soundSource.loopStart !== this._offset) {
              this._soundSource.loopStart = this._offset;
            }
            if (this._length !== void 0 && this._length !== this._soundSource.loopEnd) {
              this._soundSource.loopEnd = (this._offset | 0) + this._length;
            }
          }
        }
      }
    }
  };
  Sound2.prototype._createSpatialParameters = function() {
    if (Engine.audioEngine.canUseWebAudio && Engine.audioEngine.audioContext) {
      if (this._scene.headphone) {
        this._panningModel = "HRTF";
      }
      this._soundPanner = Engine.audioEngine.audioContext.createPanner();
      if (this._soundPanner && this._outputAudioNode) {
        this._updateSpatialParameters();
        this._soundPanner.connect(this._outputAudioNode);
        this._inputAudioNode = this._soundPanner;
      }
    }
  };
  Sound2.prototype._updateSpatialParameters = function() {
    if (this.spatialSound && this._soundPanner) {
      if (this.useCustomAttenuation) {
        this._soundPanner.distanceModel = "linear";
        this._soundPanner.maxDistance = Number.MAX_VALUE;
        this._soundPanner.refDistance = 1;
        this._soundPanner.rolloffFactor = 1;
        this._soundPanner.panningModel = this._panningModel;
      } else {
        this._soundPanner.distanceModel = this.distanceModel;
        this._soundPanner.maxDistance = this.maxDistance;
        this._soundPanner.refDistance = this.refDistance;
        this._soundPanner.rolloffFactor = this.rolloffFactor;
        this._soundPanner.panningModel = this._panningModel;
      }
    }
  };
  Sound2.prototype.switchPanningModelToHRTF = function() {
    this._panningModel = "HRTF";
    this._switchPanningModel();
  };
  Sound2.prototype.switchPanningModelToEqualPower = function() {
    this._panningModel = "equalpower";
    this._switchPanningModel();
  };
  Sound2.prototype._switchPanningModel = function() {
    if (Engine.audioEngine.canUseWebAudio && this.spatialSound && this._soundPanner) {
      this._soundPanner.panningModel = this._panningModel;
    }
  };
  Sound2.prototype.connectToSoundTrackAudioNode = function(soundTrackAudioNode) {
    if (Engine.audioEngine.canUseWebAudio && this._outputAudioNode) {
      if (this._isOutputConnected) {
        this._outputAudioNode.disconnect();
      }
      this._outputAudioNode.connect(soundTrackAudioNode);
      this._isOutputConnected = true;
    }
  };
  Sound2.prototype.setDirectionalCone = function(coneInnerAngle, coneOuterAngle, coneOuterGain) {
    if (coneOuterAngle < coneInnerAngle) {
      Logger.Error("setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.");
      return;
    }
    this._coneInnerAngle = coneInnerAngle;
    this._coneOuterAngle = coneOuterAngle;
    this._coneOuterGain = coneOuterGain;
    this._isDirectional = true;
    if (this.isPlaying && this.loop) {
      this.stop();
      this.play(0, this._offset, this._length);
    }
  };
  Object.defineProperty(Sound2.prototype, "directionalConeInnerAngle", {
    get: function() {
      return this._coneInnerAngle;
    },
    set: function(value) {
      if (value != this._coneInnerAngle) {
        if (this._coneOuterAngle < value) {
          Logger.Error("directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.");
          return;
        }
        this._coneInnerAngle = value;
        if (Engine.audioEngine.canUseWebAudio && this.spatialSound && this._soundPanner) {
          this._soundPanner.coneInnerAngle = this._coneInnerAngle;
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Sound2.prototype, "directionalConeOuterAngle", {
    get: function() {
      return this._coneOuterAngle;
    },
    set: function(value) {
      if (value != this._coneOuterAngle) {
        if (value < this._coneInnerAngle) {
          Logger.Error("directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.");
          return;
        }
        this._coneOuterAngle = value;
        if (Engine.audioEngine.canUseWebAudio && this.spatialSound && this._soundPanner) {
          this._soundPanner.coneOuterAngle = this._coneOuterAngle;
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  Sound2.prototype.setPosition = function(newPosition) {
    this._position = newPosition;
    if (Engine.audioEngine.canUseWebAudio && this.spatialSound && this._soundPanner && !isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {
      this._soundPanner.setPosition(this._position.x, this._position.y, this._position.z);
    }
  };
  Sound2.prototype.setLocalDirectionToMesh = function(newLocalDirection) {
    this._localDirection = newLocalDirection;
    if (Engine.audioEngine.canUseWebAudio && this._connectedTransformNode && this.isPlaying) {
      this._updateDirection();
    }
  };
  Sound2.prototype._updateDirection = function() {
    if (!this._connectedTransformNode || !this._soundPanner) {
      return;
    }
    var mat = this._connectedTransformNode.getWorldMatrix();
    var direction = Vector3.TransformNormal(this._localDirection, mat);
    direction.normalize();
    this._soundPanner.setOrientation(direction.x, direction.y, direction.z);
  };
  Sound2.prototype.updateDistanceFromListener = function() {
    if (Engine.audioEngine.canUseWebAudio && this._connectedTransformNode && this.useCustomAttenuation && this._soundGain && this._scene.activeCamera) {
      var distance = this._connectedTransformNode.getDistanceToCamera(this._scene.activeCamera);
      this._soundGain.gain.value = this._customAttenuationFunction(this._volume, distance, this.maxDistance, this.refDistance, this.rolloffFactor);
    }
  };
  Sound2.prototype.setAttenuationFunction = function(callback) {
    this._customAttenuationFunction = callback;
  };
  Sound2.prototype.play = function(time, offset, length) {
    var _this = this;
    if (this._isReadyToPlay && this._scene.audioEnabled && Engine.audioEngine.audioContext) {
      try {
        if (this._startOffset < 0) {
          time = -this._startOffset;
          this._startOffset = 0;
        }
        var startTime = time ? Engine.audioEngine.audioContext.currentTime + time : Engine.audioEngine.audioContext.currentTime;
        if (!this._soundSource || !this._streamingSource) {
          if (this.spatialSound && this._soundPanner) {
            if (!isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {
              this._soundPanner.setPosition(this._position.x, this._position.y, this._position.z);
            }
            if (this._isDirectional) {
              this._soundPanner.coneInnerAngle = this._coneInnerAngle;
              this._soundPanner.coneOuterAngle = this._coneOuterAngle;
              this._soundPanner.coneOuterGain = this._coneOuterGain;
              if (this._connectedTransformNode) {
                this._updateDirection();
              } else {
                this._soundPanner.setOrientation(this._localDirection.x, this._localDirection.y, this._localDirection.z);
              }
            }
          }
        }
        if (this._streaming) {
          if (!this._streamingSource) {
            this._streamingSource = Engine.audioEngine.audioContext.createMediaElementSource(this._htmlAudioElement);
            this._htmlAudioElement.onended = function() {
              _this._onended();
            };
            this._htmlAudioElement.playbackRate = this._playbackRate;
          }
          this._streamingSource.disconnect();
          if (this._inputAudioNode) {
            this._streamingSource.connect(this._inputAudioNode);
          }
          if (this._htmlAudioElement) {
            var tryToPlay = function() {
              if (Engine.audioEngine.unlocked) {
                var playPromise = _this._htmlAudioElement.play();
                if (playPromise !== void 0) {
                  playPromise.catch(function(error) {
                    Engine.audioEngine.lock();
                    if (_this.loop || _this.autoplay) {
                      Engine.audioEngine.onAudioUnlockedObservable.addOnce(function() {
                        tryToPlay();
                      });
                    }
                  });
                }
              } else {
                if (_this.loop || _this.autoplay) {
                  Engine.audioEngine.onAudioUnlockedObservable.addOnce(function() {
                    tryToPlay();
                  });
                }
              }
            };
            tryToPlay();
          }
        } else {
          var tryToPlay = function() {
            if (Engine.audioEngine.audioContext) {
              length = length || _this._length;
              offset = offset || _this._offset;
              if (_this._soundSource) {
                var oldSource_1 = _this._soundSource;
                oldSource_1.onended = function() {
                  oldSource_1.disconnect();
                };
              }
              _this._soundSource = Engine.audioEngine.audioContext.createBufferSource();
              if (_this._soundSource && _this._inputAudioNode) {
                _this._soundSource.buffer = _this._audioBuffer;
                _this._soundSource.connect(_this._inputAudioNode);
                _this._soundSource.loop = _this.loop;
                if (offset !== void 0) {
                  _this._soundSource.loopStart = offset;
                }
                if (length !== void 0) {
                  _this._soundSource.loopEnd = (offset | 0) + length;
                }
                _this._soundSource.playbackRate.value = _this._playbackRate;
                _this._soundSource.onended = function() {
                  _this._onended();
                };
                startTime = time ? Engine.audioEngine.audioContext.currentTime + time : Engine.audioEngine.audioContext.currentTime;
                var actualOffset = _this.isPaused ? _this._startOffset % _this._soundSource.buffer.duration : offset ? offset : 0;
                _this._soundSource.start(startTime, actualOffset, _this.loop ? void 0 : length);
              }
            }
          };
          if (Engine.audioEngine.audioContext.state === "suspended") {
            setTimeout(function() {
              if (Engine.audioEngine.audioContext.state === "suspended") {
                Engine.audioEngine.lock();
                if (_this.loop || _this.autoplay) {
                  Engine.audioEngine.onAudioUnlockedObservable.addOnce(function() {
                    tryToPlay();
                  });
                }
              } else {
                tryToPlay();
              }
            }, 500);
          } else {
            tryToPlay();
          }
        }
        this._startTime = startTime;
        this.isPlaying = true;
        this.isPaused = false;
      } catch (ex) {
        Logger.Error("Error while trying to play audio: " + this.name + ", " + ex.message);
      }
    }
  };
  Sound2.prototype._onended = function() {
    this.isPlaying = false;
    this._startOffset = 0;
    if (this.onended) {
      this.onended();
    }
    this.onEndedObservable.notifyObservers(this);
  };
  Sound2.prototype.stop = function(time) {
    var _this = this;
    if (this.isPlaying) {
      if (this._streaming) {
        if (this._htmlAudioElement) {
          this._htmlAudioElement.pause();
          if (this._htmlAudioElement.currentTime > 0) {
            this._htmlAudioElement.currentTime = 0;
          }
        } else {
          this._streamingSource.disconnect();
        }
        this.isPlaying = false;
      } else if (Engine.audioEngine.audioContext && this._soundSource) {
        var stopTime = time ? Engine.audioEngine.audioContext.currentTime + time : Engine.audioEngine.audioContext.currentTime;
        this._soundSource.stop(stopTime);
        this._soundSource.onended = function() {
          _this.isPlaying = false;
        };
        if (!this.isPaused) {
          this._startOffset = 0;
        }
      }
    }
  };
  Sound2.prototype.pause = function() {
    if (this.isPlaying) {
      this.isPaused = true;
      if (this._streaming) {
        if (this._htmlAudioElement) {
          this._htmlAudioElement.pause();
        } else {
          this._streamingSource.disconnect();
        }
      } else if (Engine.audioEngine.audioContext) {
        this.stop(0);
        this._startOffset += Engine.audioEngine.audioContext.currentTime - this._startTime;
      }
    }
  };
  Sound2.prototype.setVolume = function(newVolume, time) {
    if (Engine.audioEngine.canUseWebAudio && this._soundGain) {
      if (time && Engine.audioEngine.audioContext) {
        this._soundGain.gain.cancelScheduledValues(Engine.audioEngine.audioContext.currentTime);
        this._soundGain.gain.setValueAtTime(this._soundGain.gain.value, Engine.audioEngine.audioContext.currentTime);
        this._soundGain.gain.linearRampToValueAtTime(newVolume, Engine.audioEngine.audioContext.currentTime + time);
      } else {
        this._soundGain.gain.value = newVolume;
      }
    }
    this._volume = newVolume;
  };
  Sound2.prototype.setPlaybackRate = function(newPlaybackRate) {
    this._playbackRate = newPlaybackRate;
    if (this.isPlaying) {
      if (this._streaming && this._htmlAudioElement) {
        this._htmlAudioElement.playbackRate = this._playbackRate;
      } else if (this._soundSource) {
        this._soundSource.playbackRate.value = this._playbackRate;
      }
    }
  };
  Sound2.prototype.getVolume = function() {
    return this._volume;
  };
  Sound2.prototype.attachToMesh = function(transformNode) {
    var _this = this;
    if (this._connectedTransformNode && this._registerFunc) {
      this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);
      this._registerFunc = null;
    }
    this._connectedTransformNode = transformNode;
    if (!this.spatialSound) {
      this.spatialSound = true;
      this._createSpatialParameters();
      if (this.isPlaying && this.loop) {
        this.stop();
        this.play(0, this._offset, this._length);
      }
    }
    this._onRegisterAfterWorldMatrixUpdate(this._connectedTransformNode);
    this._registerFunc = function(transformNode2) {
      return _this._onRegisterAfterWorldMatrixUpdate(transformNode2);
    };
    this._connectedTransformNode.registerAfterWorldMatrixUpdate(this._registerFunc);
  };
  Sound2.prototype.detachFromMesh = function() {
    if (this._connectedTransformNode && this._registerFunc) {
      this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);
      this._registerFunc = null;
      this._connectedTransformNode = null;
    }
  };
  Sound2.prototype._onRegisterAfterWorldMatrixUpdate = function(node) {
    if (this._positionInEmitterSpace) {
      node.worldMatrixFromCache.invertToRef(TmpVectors.Matrix[0]);
      this.setPosition(TmpVectors.Matrix[0].getTranslation());
    } else {
      if (!node.getBoundingInfo) {
        this.setPosition(node.absolutePosition);
      } else {
        var mesh = node;
        var boundingInfo = mesh.getBoundingInfo();
        this.setPosition(boundingInfo.boundingSphere.centerWorld);
      }
    }
    if (Engine.audioEngine.canUseWebAudio && this._isDirectional && this.isPlaying) {
      this._updateDirection();
    }
  };
  Sound2.prototype.clone = function() {
    var _this = this;
    if (!this._streaming) {
      var setBufferAndRun = function() {
        if (_this._isReadyToPlay) {
          clonedSound._audioBuffer = _this.getAudioBuffer();
          clonedSound._isReadyToPlay = true;
          if (clonedSound.autoplay) {
            clonedSound.play(0, _this._offset, _this._length);
          }
        } else {
          window.setTimeout(setBufferAndRun, 300);
        }
      };
      var currentOptions = {
        autoplay: this.autoplay,
        loop: this.loop,
        volume: this._volume,
        spatialSound: this.spatialSound,
        maxDistance: this.maxDistance,
        useCustomAttenuation: this.useCustomAttenuation,
        rolloffFactor: this.rolloffFactor,
        refDistance: this.refDistance,
        distanceModel: this.distanceModel
      };
      var clonedSound = new Sound2(this.name + "_cloned", new ArrayBuffer(0), this._scene, null, currentOptions);
      if (this.useCustomAttenuation) {
        clonedSound.setAttenuationFunction(this._customAttenuationFunction);
      }
      clonedSound.setPosition(this._position);
      clonedSound.setPlaybackRate(this._playbackRate);
      setBufferAndRun();
      return clonedSound;
    } else {
      return null;
    }
  };
  Sound2.prototype.getAudioBuffer = function() {
    return this._audioBuffer;
  };
  Sound2.prototype.getSoundSource = function() {
    return this._soundSource;
  };
  Sound2.prototype.getSoundGain = function() {
    return this._soundGain;
  };
  Sound2.prototype.serialize = function() {
    var serializationObject = {
      name: this.name,
      url: this.name,
      autoplay: this.autoplay,
      loop: this.loop,
      volume: this._volume,
      spatialSound: this.spatialSound,
      maxDistance: this.maxDistance,
      rolloffFactor: this.rolloffFactor,
      refDistance: this.refDistance,
      distanceModel: this.distanceModel,
      playbackRate: this._playbackRate,
      panningModel: this._panningModel,
      soundTrackId: this.soundTrackId,
      metadata: this.metadata
    };
    if (this.spatialSound) {
      if (this._connectedTransformNode) {
        serializationObject.connectedMeshId = this._connectedTransformNode.id;
      }
      serializationObject.position = this._position.asArray();
      serializationObject.refDistance = this.refDistance;
      serializationObject.distanceModel = this.distanceModel;
      serializationObject.isDirectional = this._isDirectional;
      serializationObject.localDirectionToMesh = this._localDirection.asArray();
      serializationObject.coneInnerAngle = this._coneInnerAngle;
      serializationObject.coneOuterAngle = this._coneOuterAngle;
      serializationObject.coneOuterGain = this._coneOuterGain;
    }
    return serializationObject;
  };
  Sound2.Parse = function(parsedSound, scene, rootUrl, sourceSound) {
    var soundName = parsedSound.name;
    var soundUrl;
    if (parsedSound.url) {
      soundUrl = rootUrl + parsedSound.url;
    } else {
      soundUrl = rootUrl + soundName;
    }
    var options = {
      autoplay: parsedSound.autoplay,
      loop: parsedSound.loop,
      volume: parsedSound.volume,
      spatialSound: parsedSound.spatialSound,
      maxDistance: parsedSound.maxDistance,
      rolloffFactor: parsedSound.rolloffFactor,
      refDistance: parsedSound.refDistance,
      distanceModel: parsedSound.distanceModel,
      playbackRate: parsedSound.playbackRate
    };
    var newSound;
    if (!sourceSound) {
      newSound = new Sound2(soundName, soundUrl, scene, function() {
        scene._removePendingData(newSound);
      }, options);
      scene._addPendingData(newSound);
    } else {
      var setBufferAndRun = function() {
        if (sourceSound._isReadyToPlay) {
          newSound._audioBuffer = sourceSound.getAudioBuffer();
          newSound._isReadyToPlay = true;
          if (newSound.autoplay) {
            newSound.play(0, newSound._offset, newSound._length);
          }
        } else {
          window.setTimeout(setBufferAndRun, 300);
        }
      };
      newSound = new Sound2(soundName, new ArrayBuffer(0), scene, null, options);
      setBufferAndRun();
    }
    if (parsedSound.position) {
      var soundPosition = Vector3.FromArray(parsedSound.position);
      newSound.setPosition(soundPosition);
    }
    if (parsedSound.isDirectional) {
      newSound.setDirectionalCone(parsedSound.coneInnerAngle || 360, parsedSound.coneOuterAngle || 360, parsedSound.coneOuterGain || 0);
      if (parsedSound.localDirectionToMesh) {
        var localDirectionToMesh = Vector3.FromArray(parsedSound.localDirectionToMesh);
        newSound.setLocalDirectionToMesh(localDirectionToMesh);
      }
    }
    if (parsedSound.connectedMeshId) {
      var connectedMesh = scene.getMeshByID(parsedSound.connectedMeshId);
      if (connectedMesh) {
        newSound.attachToMesh(connectedMesh);
      }
    }
    if (parsedSound.metadata) {
      newSound.metadata = parsedSound.metadata;
    }
    return newSound;
  };
  Sound2._SceneComponentInitialization = function(_) {
    throw _DevTools.WarnImport("AudioSceneComponent");
  };
  return Sound2;
}();

// node_modules/@babylonjs/core/Audio/weightedsound.js
var WeightedSound = function() {
  function WeightedSound2(loop, sounds, weights) {
    var _this = this;
    this.loop = false;
    this._coneInnerAngle = 360;
    this._coneOuterAngle = 360;
    this._volume = 1;
    this.isPlaying = false;
    this.isPaused = false;
    this._sounds = [];
    this._weights = [];
    if (sounds.length !== weights.length) {
      throw new Error("Sounds length does not equal weights length");
    }
    this.loop = loop;
    this._weights = weights;
    var weightSum = 0;
    for (var _i = 0, weights_1 = weights; _i < weights_1.length; _i++) {
      var weight = weights_1[_i];
      weightSum += weight;
    }
    var invWeightSum = weightSum > 0 ? 1 / weightSum : 0;
    for (var i = 0; i < this._weights.length; i++) {
      this._weights[i] *= invWeightSum;
    }
    this._sounds = sounds;
    for (var _a = 0, _b = this._sounds; _a < _b.length; _a++) {
      var sound = _b[_a];
      sound.onEndedObservable.add(function() {
        _this._onended();
      });
    }
  }
  Object.defineProperty(WeightedSound2.prototype, "directionalConeInnerAngle", {
    get: function() {
      return this._coneInnerAngle;
    },
    set: function(value) {
      if (value !== this._coneInnerAngle) {
        if (this._coneOuterAngle < value) {
          Logger.Error("directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.");
          return;
        }
        this._coneInnerAngle = value;
        for (var _i = 0, _a = this._sounds; _i < _a.length; _i++) {
          var sound = _a[_i];
          sound.directionalConeInnerAngle = value;
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WeightedSound2.prototype, "directionalConeOuterAngle", {
    get: function() {
      return this._coneOuterAngle;
    },
    set: function(value) {
      if (value !== this._coneOuterAngle) {
        if (value < this._coneInnerAngle) {
          Logger.Error("directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.");
          return;
        }
        this._coneOuterAngle = value;
        for (var _i = 0, _a = this._sounds; _i < _a.length; _i++) {
          var sound = _a[_i];
          sound.directionalConeOuterAngle = value;
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WeightedSound2.prototype, "volume", {
    get: function() {
      return this._volume;
    },
    set: function(value) {
      if (value !== this._volume) {
        for (var _i = 0, _a = this._sounds; _i < _a.length; _i++) {
          var sound = _a[_i];
          sound.setVolume(value);
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  WeightedSound2.prototype._onended = function() {
    if (this._currentIndex !== void 0) {
      this._sounds[this._currentIndex].autoplay = false;
    }
    if (this.loop && this.isPlaying) {
      this.play();
    } else {
      this.isPlaying = false;
    }
  };
  WeightedSound2.prototype.pause = function() {
    this.isPaused = true;
    if (this._currentIndex !== void 0) {
      this._sounds[this._currentIndex].pause();
    }
  };
  WeightedSound2.prototype.stop = function() {
    this.isPlaying = false;
    if (this._currentIndex !== void 0) {
      this._sounds[this._currentIndex].stop();
    }
  };
  WeightedSound2.prototype.play = function(startOffset) {
    if (!this.isPaused) {
      this.stop();
      var randomValue = Math.random();
      var total = 0;
      for (var i = 0; i < this._weights.length; i++) {
        total += this._weights[i];
        if (randomValue <= total) {
          this._currentIndex = i;
          break;
        }
      }
    }
    var sound = this._sounds[this._currentIndex];
    if (sound.isReady()) {
      sound.play(0, this.isPaused ? void 0 : startOffset);
    } else {
      sound.autoplay = true;
    }
    this.isPlaying = true;
    this.isPaused = false;
  };
  return WeightedSound2;
}();

// node_modules/@babylonjs/core/Engines/Extensions/engine.rawTexture.js
ThinEngine.prototype.updateRawTexture = function(texture, data, format, invertY, compression, type) {
  if (compression === void 0) {
    compression = null;
  }
  if (type === void 0) {
    type = 0;
  }
  if (!texture) {
    return;
  }
  var internalSizedFomat = this._getRGBABufferInternalSizedFormat(type, format);
  var internalFormat = this._getInternalFormat(format);
  var textureType = this._getWebGLTextureType(type);
  this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
  this._unpackFlipY(invertY === void 0 ? true : invertY ? true : false);
  if (!this._doNotHandleContextLost) {
    texture._bufferView = data;
    texture.format = format;
    texture.type = type;
    texture.invertY = invertY;
    texture._compression = compression;
  }
  if (texture.width % 4 !== 0) {
    this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);
  }
  if (compression && data) {
    this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, this.getCaps().s3tc[compression], texture.width, texture.height, 0, data);
  } else {
    this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, data);
  }
  if (texture.generateMipMaps) {
    this._gl.generateMipmap(this._gl.TEXTURE_2D);
  }
  this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
  texture.isReady = true;
};
ThinEngine.prototype.createRawTexture = function(data, width, height, format, generateMipMaps, invertY, samplingMode, compression, type) {
  if (compression === void 0) {
    compression = null;
  }
  if (type === void 0) {
    type = 0;
  }
  var texture = new InternalTexture(this, InternalTextureSource.Raw);
  texture.baseWidth = width;
  texture.baseHeight = height;
  texture.width = width;
  texture.height = height;
  texture.format = format;
  texture.generateMipMaps = generateMipMaps;
  texture.samplingMode = samplingMode;
  texture.invertY = invertY;
  texture._compression = compression;
  texture.type = type;
  if (!this._doNotHandleContextLost) {
    texture._bufferView = data;
  }
  this.updateRawTexture(texture, data, format, invertY, compression, type);
  this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
  var filters = this._getSamplingParameters(samplingMode, generateMipMaps);
  this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, filters.mag);
  this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, filters.min);
  if (generateMipMaps) {
    this._gl.generateMipmap(this._gl.TEXTURE_2D);
  }
  this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
  this._internalTexturesCache.push(texture);
  return texture;
};
ThinEngine.prototype.createRawCubeTexture = function(data, size, format, type, generateMipMaps, invertY, samplingMode, compression) {
  if (compression === void 0) {
    compression = null;
  }
  var gl = this._gl;
  var texture = new InternalTexture(this, InternalTextureSource.CubeRaw);
  texture.isCube = true;
  texture.format = format;
  texture.type = type;
  if (!this._doNotHandleContextLost) {
    texture._bufferViewArray = data;
  }
  var textureType = this._getWebGLTextureType(type);
  var internalFormat = this._getInternalFormat(format);
  if (internalFormat === gl.RGB) {
    internalFormat = gl.RGBA;
  }
  if (textureType === gl.FLOAT && !this._caps.textureFloatLinearFiltering) {
    generateMipMaps = false;
    samplingMode = 1;
    Logger.Warn("Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.");
  } else if (textureType === this._gl.HALF_FLOAT_OES && !this._caps.textureHalfFloatLinearFiltering) {
    generateMipMaps = false;
    samplingMode = 1;
    Logger.Warn("Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.");
  } else if (textureType === gl.FLOAT && !this._caps.textureFloatRender) {
    generateMipMaps = false;
    Logger.Warn("Render to float textures is not supported. Mipmap generation forced to false.");
  } else if (textureType === gl.HALF_FLOAT && !this._caps.colorBufferFloat) {
    generateMipMaps = false;
    Logger.Warn("Render to half float textures is not supported. Mipmap generation forced to false.");
  }
  var width = size;
  var height = width;
  texture.width = width;
  texture.height = height;
  var isPot = !this.needPOTTextures || Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height);
  if (!isPot) {
    generateMipMaps = false;
  }
  if (data) {
    this.updateRawCubeTexture(texture, data, format, type, invertY, compression);
  }
  this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);
  if (data && generateMipMaps) {
    this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);
  }
  var filters = this._getSamplingParameters(samplingMode, generateMipMaps);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
  texture.generateMipMaps = generateMipMaps;
  return texture;
};
ThinEngine.prototype.updateRawCubeTexture = function(texture, data, format, type, invertY, compression, level) {
  if (compression === void 0) {
    compression = null;
  }
  if (level === void 0) {
    level = 0;
  }
  texture._bufferViewArray = data;
  texture.format = format;
  texture.type = type;
  texture.invertY = invertY;
  texture._compression = compression;
  var gl = this._gl;
  var textureType = this._getWebGLTextureType(type);
  var internalFormat = this._getInternalFormat(format);
  var internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);
  var needConversion = false;
  if (internalFormat === gl.RGB) {
    internalFormat = gl.RGBA;
    needConversion = true;
  }
  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
  this._unpackFlipY(invertY === void 0 ? true : invertY ? true : false);
  if (texture.width % 4 !== 0) {
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
  }
  for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
    var faceData = data[faceIndex];
    if (compression) {
      gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, this.getCaps().s3tc[compression], texture.width, texture.height, 0, faceData);
    } else {
      if (needConversion) {
        faceData = _convertRGBtoRGBATextureData(faceData, texture.width, texture.height, type);
      }
      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, faceData);
    }
  }
  var isPot = !this.needPOTTextures || Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height);
  if (isPot && texture.generateMipMaps && level === 0) {
    this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);
  }
  this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
  texture.isReady = true;
};
ThinEngine.prototype.createRawCubeTextureFromUrl = function(url, scene, size, format, type, noMipmap, callback, mipmapGenerator, onLoad, onError, samplingMode, invertY) {
  var _this = this;
  if (onLoad === void 0) {
    onLoad = null;
  }
  if (onError === void 0) {
    onError = null;
  }
  if (samplingMode === void 0) {
    samplingMode = 3;
  }
  if (invertY === void 0) {
    invertY = false;
  }
  var gl = this._gl;
  var texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);
  scene === null || scene === void 0 ? void 0 : scene._addPendingData(texture);
  texture.url = url;
  this._internalTexturesCache.push(texture);
  var onerror = function(request, exception) {
    scene === null || scene === void 0 ? void 0 : scene._removePendingData(texture);
    if (onError && request) {
      onError(request.status + " " + request.statusText, exception);
    }
  };
  var internalCallback = function(data) {
    var width = texture.width;
    var faceDataArrays = callback(data);
    if (!faceDataArrays) {
      return;
    }
    if (mipmapGenerator) {
      var textureType = _this._getWebGLTextureType(type);
      var internalFormat = _this._getInternalFormat(format);
      var internalSizedFomat = _this._getRGBABufferInternalSizedFormat(type);
      var needConversion = false;
      if (internalFormat === gl.RGB) {
        internalFormat = gl.RGBA;
        needConversion = true;
      }
      _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
      _this._unpackFlipY(false);
      var mipData = mipmapGenerator(faceDataArrays);
      for (var level = 0; level < mipData.length; level++) {
        var mipSize = width >> level;
        for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
          var mipFaceData = mipData[level][faceIndex];
          if (needConversion) {
            mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);
          }
          gl.texImage2D(faceIndex, level, internalSizedFomat, mipSize, mipSize, 0, internalFormat, textureType, mipFaceData);
        }
      }
      _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
    } else {
      _this.updateRawCubeTexture(texture, faceDataArrays, format, type, invertY);
    }
    texture.isReady = true;
    scene === null || scene === void 0 ? void 0 : scene._removePendingData(texture);
    if (onLoad) {
      onLoad();
    }
  };
  this._loadFile(url, function(data) {
    internalCallback(data);
  }, void 0, scene === null || scene === void 0 ? void 0 : scene.offlineProvider, true, onerror);
  return texture;
};
function _convertRGBtoRGBATextureData(rgbData, width, height, textureType) {
  var rgbaData;
  if (textureType === 1) {
    rgbaData = new Float32Array(width * height * 4);
  } else {
    rgbaData = new Uint32Array(width * height * 4);
  }
  for (var x = 0; x < width; x++) {
    for (var y = 0; y < height; y++) {
      var index = (y * width + x) * 3;
      var newIndex = (y * width + x) * 4;
      rgbaData[newIndex + 0] = rgbData[index + 0];
      rgbaData[newIndex + 1] = rgbData[index + 1];
      rgbaData[newIndex + 2] = rgbData[index + 2];
      rgbaData[newIndex + 3] = 1;
    }
  }
  return rgbaData;
}
function _makeCreateRawTextureFunction(is3D) {
  return function(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression, textureType) {
    if (compression === void 0) {
      compression = null;
    }
    if (textureType === void 0) {
      textureType = 0;
    }
    var target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;
    var source = is3D ? InternalTextureSource.Raw3D : InternalTextureSource.Raw2DArray;
    var texture = new InternalTexture(this, source);
    texture.baseWidth = width;
    texture.baseHeight = height;
    texture.baseDepth = depth;
    texture.width = width;
    texture.height = height;
    texture.depth = depth;
    texture.format = format;
    texture.type = textureType;
    texture.generateMipMaps = generateMipMaps;
    texture.samplingMode = samplingMode;
    if (is3D) {
      texture.is3D = true;
    } else {
      texture.is2DArray = true;
    }
    if (!this._doNotHandleContextLost) {
      texture._bufferView = data;
    }
    if (is3D) {
      this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);
    } else {
      this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);
    }
    this._bindTextureDirectly(target, texture, true);
    var filters = this._getSamplingParameters(samplingMode, generateMipMaps);
    this._gl.texParameteri(target, this._gl.TEXTURE_MAG_FILTER, filters.mag);
    this._gl.texParameteri(target, this._gl.TEXTURE_MIN_FILTER, filters.min);
    if (generateMipMaps) {
      this._gl.generateMipmap(target);
    }
    this._bindTextureDirectly(target, null);
    this._internalTexturesCache.push(texture);
    return texture;
  };
}
ThinEngine.prototype.createRawTexture2DArray = _makeCreateRawTextureFunction(false);
ThinEngine.prototype.createRawTexture3D = _makeCreateRawTextureFunction(true);
function _makeUpdateRawTextureFunction(is3D) {
  return function(texture, data, format, invertY, compression, textureType) {
    if (compression === void 0) {
      compression = null;
    }
    if (textureType === void 0) {
      textureType = 0;
    }
    var target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;
    var internalType = this._getWebGLTextureType(textureType);
    var internalFormat = this._getInternalFormat(format);
    var internalSizedFomat = this._getRGBABufferInternalSizedFormat(textureType, format);
    this._bindTextureDirectly(target, texture, true);
    this._unpackFlipY(invertY === void 0 ? true : invertY ? true : false);
    if (!this._doNotHandleContextLost) {
      texture._bufferView = data;
      texture.format = format;
      texture.invertY = invertY;
      texture._compression = compression;
    }
    if (texture.width % 4 !== 0) {
      this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);
    }
    if (compression && data) {
      this._gl.compressedTexImage3D(target, 0, this.getCaps().s3tc[compression], texture.width, texture.height, texture.depth, 0, data);
    } else {
      this._gl.texImage3D(target, 0, internalSizedFomat, texture.width, texture.height, texture.depth, 0, internalFormat, internalType, data);
    }
    if (texture.generateMipMaps) {
      this._gl.generateMipmap(target);
    }
    this._bindTextureDirectly(target, null);
    texture.isReady = true;
  };
}
ThinEngine.prototype.updateRawTexture2DArray = _makeUpdateRawTextureFunction(false);
ThinEngine.prototype.updateRawTexture3D = _makeUpdateRawTextureFunction(true);

// node_modules/@babylonjs/core/Materials/Textures/rawTexture.js
var RawTexture = function(_super) {
  __extends(RawTexture2, _super);
  function RawTexture2(data, width, height, format, sceneOrEngine, generateMipMaps, invertY, samplingMode, type) {
    if (generateMipMaps === void 0) {
      generateMipMaps = true;
    }
    if (invertY === void 0) {
      invertY = false;
    }
    if (samplingMode === void 0) {
      samplingMode = 3;
    }
    if (type === void 0) {
      type = 0;
    }
    var _this = _super.call(this, null, sceneOrEngine, !generateMipMaps, invertY) || this;
    _this.format = format;
    if (!_this._engine) {
      return _this;
    }
    _this._texture = _this._engine.createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, null, type);
    _this.wrapU = Texture.CLAMP_ADDRESSMODE;
    _this.wrapV = Texture.CLAMP_ADDRESSMODE;
    return _this;
  }
  RawTexture2.prototype.update = function(data) {
    this._getEngine().updateRawTexture(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type);
  };
  RawTexture2.CreateLuminanceTexture = function(data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode) {
    if (generateMipMaps === void 0) {
      generateMipMaps = true;
    }
    if (invertY === void 0) {
      invertY = false;
    }
    if (samplingMode === void 0) {
      samplingMode = 3;
    }
    return new RawTexture2(data, width, height, 1, sceneOrEngine, generateMipMaps, invertY, samplingMode);
  };
  RawTexture2.CreateLuminanceAlphaTexture = function(data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode) {
    if (generateMipMaps === void 0) {
      generateMipMaps = true;
    }
    if (invertY === void 0) {
      invertY = false;
    }
    if (samplingMode === void 0) {
      samplingMode = 3;
    }
    return new RawTexture2(data, width, height, 2, sceneOrEngine, generateMipMaps, invertY, samplingMode);
  };
  RawTexture2.CreateAlphaTexture = function(data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode) {
    if (generateMipMaps === void 0) {
      generateMipMaps = true;
    }
    if (invertY === void 0) {
      invertY = false;
    }
    if (samplingMode === void 0) {
      samplingMode = 3;
    }
    return new RawTexture2(data, width, height, 0, sceneOrEngine, generateMipMaps, invertY, samplingMode);
  };
  RawTexture2.CreateRGBTexture = function(data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode, type) {
    if (generateMipMaps === void 0) {
      generateMipMaps = true;
    }
    if (invertY === void 0) {
      invertY = false;
    }
    if (samplingMode === void 0) {
      samplingMode = 3;
    }
    if (type === void 0) {
      type = 0;
    }
    return new RawTexture2(data, width, height, 4, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);
  };
  RawTexture2.CreateRGBATexture = function(data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode, type) {
    if (generateMipMaps === void 0) {
      generateMipMaps = true;
    }
    if (invertY === void 0) {
      invertY = false;
    }
    if (samplingMode === void 0) {
      samplingMode = 3;
    }
    if (type === void 0) {
      type = 0;
    }
    return new RawTexture2(data, width, height, 5, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);
  };
  RawTexture2.CreateRTexture = function(data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode, type) {
    if (generateMipMaps === void 0) {
      generateMipMaps = true;
    }
    if (invertY === void 0) {
      invertY = false;
    }
    if (samplingMode === void 0) {
      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;
    }
    if (type === void 0) {
      type = 1;
    }
    return new RawTexture2(data, width, height, 6, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);
  };
  return RawTexture2;
}(Texture);

// node_modules/@babylonjs/core/Bones/skeleton.js
var Skeleton = function() {
  function Skeleton2(name42, id, scene) {
    this.name = name42;
    this.id = id;
    this.bones = new Array();
    this.needInitialSkinMatrix = false;
    this.overrideMesh = null;
    this._isDirty = true;
    this._meshesWithPoseMatrix = new Array();
    this._identity = Matrix.Identity();
    this._ranges = {};
    this._lastAbsoluteTransformsUpdateId = -1;
    this._canUseTextureForBones = false;
    this._uniqueId = 0;
    this._numBonesWithLinkedTransformNode = 0;
    this._hasWaitingData = null;
    this._waitingOverrideMeshId = null;
    this.doNotSerialize = false;
    this._useTextureToStoreBoneMatrices = true;
    this._animationPropertiesOverride = null;
    this.onBeforeComputeObservable = new Observable();
    this.bones = [];
    this._scene = scene || EngineStore.LastCreatedScene;
    this._uniqueId = this._scene.getUniqueId();
    this._scene.addSkeleton(this);
    this._isDirty = true;
    var engineCaps = this._scene.getEngine().getCaps();
    this._canUseTextureForBones = engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;
  }
  Object.defineProperty(Skeleton2.prototype, "useTextureToStoreBoneMatrices", {
    get: function() {
      return this._useTextureToStoreBoneMatrices;
    },
    set: function(value) {
      this._useTextureToStoreBoneMatrices = value;
      this._markAsDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Skeleton2.prototype, "animationPropertiesOverride", {
    get: function() {
      if (!this._animationPropertiesOverride) {
        return this._scene.animationPropertiesOverride;
      }
      return this._animationPropertiesOverride;
    },
    set: function(value) {
      this._animationPropertiesOverride = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Skeleton2.prototype, "isUsingTextureForMatrices", {
    get: function() {
      return this.useTextureToStoreBoneMatrices && this._canUseTextureForBones;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Skeleton2.prototype, "uniqueId", {
    get: function() {
      return this._uniqueId;
    },
    enumerable: false,
    configurable: true
  });
  Skeleton2.prototype.getClassName = function() {
    return "Skeleton";
  };
  Skeleton2.prototype.getChildren = function() {
    return this.bones.filter(function(b) {
      return !b.getParent();
    });
  };
  Skeleton2.prototype.getTransformMatrices = function(mesh) {
    if (this.needInitialSkinMatrix && mesh._bonesTransformMatrices) {
      return mesh._bonesTransformMatrices;
    }
    if (!this._transformMatrices) {
      this.prepare();
    }
    return this._transformMatrices;
  };
  Skeleton2.prototype.getTransformMatrixTexture = function(mesh) {
    if (this.needInitialSkinMatrix && mesh._transformMatrixTexture) {
      return mesh._transformMatrixTexture;
    }
    return this._transformMatrixTexture;
  };
  Skeleton2.prototype.getScene = function() {
    return this._scene;
  };
  Skeleton2.prototype.toString = function(fullDetails) {
    var ret = "Name: " + this.name + ", nBones: " + this.bones.length;
    ret += ", nAnimationRanges: " + (this._ranges ? Object.keys(this._ranges).length : "none");
    if (fullDetails) {
      ret += ", Ranges: {";
      var first = true;
      for (var name_1 in this._ranges) {
        if (first) {
          ret += ", ";
          first = false;
        }
        ret += name_1;
      }
      ret += "}";
    }
    return ret;
  };
  Skeleton2.prototype.getBoneIndexByName = function(name42) {
    for (var boneIndex = 0, cache = this.bones.length; boneIndex < cache; boneIndex++) {
      if (this.bones[boneIndex].name === name42) {
        return boneIndex;
      }
    }
    return -1;
  };
  Skeleton2.prototype.createAnimationRange = function(name42, from, to) {
    if (!this._ranges[name42]) {
      this._ranges[name42] = new AnimationRange(name42, from, to);
      for (var i = 0, nBones = this.bones.length; i < nBones; i++) {
        if (this.bones[i].animations[0]) {
          this.bones[i].animations[0].createRange(name42, from, to);
        }
      }
    }
  };
  Skeleton2.prototype.deleteAnimationRange = function(name42, deleteFrames) {
    if (deleteFrames === void 0) {
      deleteFrames = true;
    }
    for (var i = 0, nBones = this.bones.length; i < nBones; i++) {
      if (this.bones[i].animations[0]) {
        this.bones[i].animations[0].deleteRange(name42, deleteFrames);
      }
    }
    this._ranges[name42] = null;
  };
  Skeleton2.prototype.getAnimationRange = function(name42) {
    return this._ranges[name42] || null;
  };
  Skeleton2.prototype.getAnimationRanges = function() {
    var animationRanges = [];
    var name42;
    for (name42 in this._ranges) {
      animationRanges.push(this._ranges[name42]);
    }
    return animationRanges;
  };
  Skeleton2.prototype.copyAnimationRange = function(source, name42, rescaleAsRequired) {
    if (rescaleAsRequired === void 0) {
      rescaleAsRequired = false;
    }
    if (this._ranges[name42] || !source.getAnimationRange(name42)) {
      return false;
    }
    var ret = true;
    var frameOffset = this._getHighestAnimationFrame() + 1;
    var boneDict = {};
    var sourceBones = source.bones;
    var nBones;
    var i;
    for (i = 0, nBones = sourceBones.length; i < nBones; i++) {
      boneDict[sourceBones[i].name] = sourceBones[i];
    }
    if (this.bones.length !== sourceBones.length) {
      Logger.Warn("copyAnimationRange: this rig has " + this.bones.length + " bones, while source as " + sourceBones.length);
      ret = false;
    }
    var skelDimensionsRatio = rescaleAsRequired && this.dimensionsAtRest && source.dimensionsAtRest ? this.dimensionsAtRest.divide(source.dimensionsAtRest) : null;
    for (i = 0, nBones = this.bones.length; i < nBones; i++) {
      var boneName = this.bones[i].name;
      var sourceBone = boneDict[boneName];
      if (sourceBone) {
        ret = ret && this.bones[i].copyAnimationRange(sourceBone, name42, frameOffset, rescaleAsRequired, skelDimensionsRatio);
      } else {
        Logger.Warn("copyAnimationRange: not same rig, missing source bone " + boneName);
        ret = false;
      }
    }
    var range = source.getAnimationRange(name42);
    if (range) {
      this._ranges[name42] = new AnimationRange(name42, range.from + frameOffset, range.to + frameOffset);
    }
    return ret;
  };
  Skeleton2.prototype.returnToRest = function() {
    var _localScaling = TmpVectors.Vector3[0];
    var _localRotation = TmpVectors.Quaternion[0];
    var _localPosition = TmpVectors.Vector3[1];
    for (var index = 0; index < this.bones.length; index++) {
      var bone = this.bones[index];
      if (bone._index !== -1) {
        bone.returnToRest();
        if (bone._linkedTransformNode) {
          bone.getRestPose().decompose(_localScaling, _localRotation, _localPosition);
          bone._linkedTransformNode.position = _localPosition.clone();
          bone._linkedTransformNode.rotationQuaternion = _localRotation.clone();
          bone._linkedTransformNode.scaling = _localScaling.clone();
        }
      }
    }
  };
  Skeleton2.prototype._getHighestAnimationFrame = function() {
    var ret = 0;
    for (var i = 0, nBones = this.bones.length; i < nBones; i++) {
      if (this.bones[i].animations[0]) {
        var highest = this.bones[i].animations[0].getHighestFrame();
        if (ret < highest) {
          ret = highest;
        }
      }
    }
    return ret;
  };
  Skeleton2.prototype.beginAnimation = function(name42, loop, speedRatio, onAnimationEnd) {
    var range = this.getAnimationRange(name42);
    if (!range) {
      return null;
    }
    return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);
  };
  Skeleton2.MakeAnimationAdditive = function(skeleton, referenceFrame, range) {
    if (referenceFrame === void 0) {
      referenceFrame = 0;
    }
    var rangeValue = skeleton.getAnimationRange(range);
    if (!rangeValue) {
      return null;
    }
    var sceneAnimatables = skeleton._scene.getAllAnimatablesByTarget(skeleton);
    var rangeAnimatable = null;
    for (var index = 0; index < sceneAnimatables.length; index++) {
      var sceneAnimatable = sceneAnimatables[index];
      if (sceneAnimatable.fromFrame === (rangeValue === null || rangeValue === void 0 ? void 0 : rangeValue.from) && sceneAnimatable.toFrame === (rangeValue === null || rangeValue === void 0 ? void 0 : rangeValue.to)) {
        rangeAnimatable = sceneAnimatable;
        break;
      }
    }
    var animatables = skeleton.getAnimatables();
    for (var index = 0; index < animatables.length; index++) {
      var animatable = animatables[index];
      var animations = animatable.animations;
      if (!animations) {
        continue;
      }
      for (var animIndex = 0; animIndex < animations.length; animIndex++) {
        Animation.MakeAnimationAdditive(animations[animIndex], referenceFrame, range);
      }
    }
    if (rangeAnimatable) {
      rangeAnimatable.isAdditive = true;
    }
    return skeleton;
  };
  Skeleton2.prototype._markAsDirty = function() {
    this._isDirty = true;
  };
  Skeleton2.prototype._registerMeshWithPoseMatrix = function(mesh) {
    this._meshesWithPoseMatrix.push(mesh);
  };
  Skeleton2.prototype._unregisterMeshWithPoseMatrix = function(mesh) {
    var index = this._meshesWithPoseMatrix.indexOf(mesh);
    if (index > -1) {
      this._meshesWithPoseMatrix.splice(index, 1);
    }
  };
  Skeleton2.prototype._computeTransformMatrices = function(targetMatrix, initialSkinMatrix) {
    this.onBeforeComputeObservable.notifyObservers(this);
    for (var index = 0; index < this.bones.length; index++) {
      var bone = this.bones[index];
      bone._childUpdateId++;
      var parentBone = bone.getParent();
      if (parentBone) {
        bone.getLocalMatrix().multiplyToRef(parentBone.getWorldMatrix(), bone.getWorldMatrix());
      } else {
        if (initialSkinMatrix) {
          bone.getLocalMatrix().multiplyToRef(initialSkinMatrix, bone.getWorldMatrix());
        } else {
          bone.getWorldMatrix().copyFrom(bone.getLocalMatrix());
        }
      }
      if (bone._index !== -1) {
        var mappedIndex = bone._index === null ? index : bone._index;
        bone.getInvertedAbsoluteTransform().multiplyToArray(bone.getWorldMatrix(), targetMatrix, mappedIndex * 16);
      }
    }
    this._identity.copyToArray(targetMatrix, this.bones.length * 16);
  };
  Skeleton2.prototype.prepare = function() {
    if (this._numBonesWithLinkedTransformNode > 0) {
      for (var _i = 0, _a = this.bones; _i < _a.length; _i++) {
        var bone_1 = _a[_i];
        if (bone_1._linkedTransformNode) {
          bone_1._linkedTransformNode.computeWorldMatrix();
          bone_1._matrix = bone_1._linkedTransformNode._localMatrix;
          bone_1.markAsDirty();
        }
      }
    }
    if (!this._isDirty) {
      return;
    }
    if (this.needInitialSkinMatrix) {
      for (var index = 0; index < this._meshesWithPoseMatrix.length; index++) {
        var mesh = this._meshesWithPoseMatrix[index];
        var poseMatrix = mesh.getPoseMatrix();
        if (!mesh._bonesTransformMatrices || mesh._bonesTransformMatrices.length !== 16 * (this.bones.length + 1)) {
          mesh._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1));
        }
        if (this._synchronizedWithMesh !== mesh) {
          this._synchronizedWithMesh = mesh;
          for (var boneIndex = 0; boneIndex < this.bones.length; boneIndex++) {
            var bone = this.bones[boneIndex];
            if (!bone.getParent()) {
              var matrix = bone.getBaseMatrix();
              matrix.multiplyToRef(poseMatrix, TmpVectors.Matrix[1]);
              bone._updateDifferenceMatrix(TmpVectors.Matrix[1]);
            }
          }
          if (this.isUsingTextureForMatrices) {
            var textureWidth = (this.bones.length + 1) * 4;
            if (!mesh._transformMatrixTexture || mesh._transformMatrixTexture.getSize().width !== textureWidth) {
              if (mesh._transformMatrixTexture) {
                mesh._transformMatrixTexture.dispose();
              }
              mesh._transformMatrixTexture = RawTexture.CreateRGBATexture(mesh._bonesTransformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);
            }
          }
        }
        this._computeTransformMatrices(mesh._bonesTransformMatrices, poseMatrix);
        if (this.isUsingTextureForMatrices && mesh._transformMatrixTexture) {
          mesh._transformMatrixTexture.update(mesh._bonesTransformMatrices);
        }
      }
    } else {
      if (!this._transformMatrices || this._transformMatrices.length !== 16 * (this.bones.length + 1)) {
        this._transformMatrices = new Float32Array(16 * (this.bones.length + 1));
        if (this.isUsingTextureForMatrices) {
          if (this._transformMatrixTexture) {
            this._transformMatrixTexture.dispose();
          }
          this._transformMatrixTexture = RawTexture.CreateRGBATexture(this._transformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);
        }
      }
      this._computeTransformMatrices(this._transformMatrices, null);
      if (this.isUsingTextureForMatrices && this._transformMatrixTexture) {
        this._transformMatrixTexture.update(this._transformMatrices);
      }
    }
    this._isDirty = false;
    this._scene._activeBones.addCount(this.bones.length, false);
  };
  Skeleton2.prototype.getAnimatables = function() {
    if (!this._animatables || this._animatables.length !== this.bones.length) {
      this._animatables = [];
      for (var index = 0; index < this.bones.length; index++) {
        this._animatables.push(this.bones[index]);
      }
    }
    return this._animatables;
  };
  Skeleton2.prototype.clone = function(name42, id) {
    var result = new Skeleton2(name42, id || name42, this._scene);
    result.needInitialSkinMatrix = this.needInitialSkinMatrix;
    result.overrideMesh = this.overrideMesh;
    for (var index = 0; index < this.bones.length; index++) {
      var source = this.bones[index];
      var parentBone = null;
      var parent_1 = source.getParent();
      if (parent_1) {
        var parentIndex = this.bones.indexOf(parent_1);
        parentBone = result.bones[parentIndex];
      }
      var bone = new Bone(source.name, result, parentBone, source.getBaseMatrix().clone(), source.getRestPose().clone());
      bone._index = source._index;
      if (source._linkedTransformNode) {
        bone.linkTransformNode(source._linkedTransformNode);
      }
      DeepCopier.DeepCopy(source.animations, bone.animations);
    }
    if (this._ranges) {
      result._ranges = {};
      for (var rangeName in this._ranges) {
        var range = this._ranges[rangeName];
        if (range) {
          result._ranges[rangeName] = range.clone();
        }
      }
    }
    this._isDirty = true;
    return result;
  };
  Skeleton2.prototype.enableBlending = function(blendingSpeed) {
    if (blendingSpeed === void 0) {
      blendingSpeed = 0.01;
    }
    this.bones.forEach(function(bone) {
      bone.animations.forEach(function(animation) {
        animation.enableBlending = true;
        animation.blendingSpeed = blendingSpeed;
      });
    });
  };
  Skeleton2.prototype.dispose = function() {
    this._meshesWithPoseMatrix = [];
    this.getScene().stopAnimation(this);
    this.getScene().removeSkeleton(this);
    if (this._transformMatrixTexture) {
      this._transformMatrixTexture.dispose();
      this._transformMatrixTexture = null;
    }
  };
  Skeleton2.prototype.serialize = function() {
    var _a, _b;
    var serializationObject = {};
    serializationObject.name = this.name;
    serializationObject.id = this.id;
    if (this.dimensionsAtRest) {
      serializationObject.dimensionsAtRest = this.dimensionsAtRest.asArray();
    }
    serializationObject.bones = [];
    serializationObject.needInitialSkinMatrix = this.needInitialSkinMatrix;
    serializationObject.overrideMeshId = (_a = this.overrideMesh) === null || _a === void 0 ? void 0 : _a.id;
    for (var index = 0; index < this.bones.length; index++) {
      var bone = this.bones[index];
      var parent_2 = bone.getParent();
      var serializedBone = {
        parentBoneIndex: parent_2 ? this.bones.indexOf(parent_2) : -1,
        index: bone.getIndex(),
        name: bone.name,
        matrix: bone.getBaseMatrix().toArray(),
        rest: bone.getRestPose().toArray(),
        linkedTransformNodeId: (_b = bone.getTransformNode()) === null || _b === void 0 ? void 0 : _b.id
      };
      serializationObject.bones.push(serializedBone);
      if (bone.length) {
        serializedBone.length = bone.length;
      }
      if (bone.metadata) {
        serializedBone.metadata = bone.metadata;
      }
      if (bone.animations && bone.animations.length > 0) {
        serializedBone.animation = bone.animations[0].serialize();
      }
      serializationObject.ranges = [];
      for (var name42 in this._ranges) {
        var source = this._ranges[name42];
        if (!source) {
          continue;
        }
        var range = {};
        range.name = name42;
        range.from = source.from;
        range.to = source.to;
        serializationObject.ranges.push(range);
      }
    }
    return serializationObject;
  };
  Skeleton2.Parse = function(parsedSkeleton, scene) {
    var skeleton = new Skeleton2(parsedSkeleton.name, parsedSkeleton.id, scene);
    if (parsedSkeleton.dimensionsAtRest) {
      skeleton.dimensionsAtRest = Vector3.FromArray(parsedSkeleton.dimensionsAtRest);
    }
    skeleton.needInitialSkinMatrix = parsedSkeleton.needInitialSkinMatrix;
    if (parsedSkeleton.overrideMeshId) {
      skeleton._hasWaitingData = true;
      skeleton._waitingOverrideMeshId = parsedSkeleton.overrideMeshId;
    }
    var index;
    for (index = 0; index < parsedSkeleton.bones.length; index++) {
      var parsedBone = parsedSkeleton.bones[index];
      var parsedBoneIndex = parsedSkeleton.bones[index].index;
      var parentBone = null;
      if (parsedBone.parentBoneIndex > -1) {
        parentBone = skeleton.bones[parsedBone.parentBoneIndex];
      }
      var rest = parsedBone.rest ? Matrix.FromArray(parsedBone.rest) : null;
      var bone = new Bone(parsedBone.name, skeleton, parentBone, Matrix.FromArray(parsedBone.matrix), rest, null, parsedBoneIndex);
      if (parsedBone.id !== void 0 && parsedBone.id !== null) {
        bone.id = parsedBone.id;
      }
      if (parsedBone.length) {
        bone.length = parsedBone.length;
      }
      if (parsedBone.metadata) {
        bone.metadata = parsedBone.metadata;
      }
      if (parsedBone.animation) {
        bone.animations.push(Animation.Parse(parsedBone.animation));
      }
      if (parsedBone.linkedTransformNodeId !== void 0 && parsedBone.linkedTransformNodeId !== null) {
        skeleton._hasWaitingData = true;
        bone._waitingTransformNodeId = parsedBone.linkedTransformNodeId;
      }
    }
    if (parsedSkeleton.ranges) {
      for (index = 0; index < parsedSkeleton.ranges.length; index++) {
        var data = parsedSkeleton.ranges[index];
        skeleton.createAnimationRange(data.name, data.from, data.to);
      }
    }
    return skeleton;
  };
  Skeleton2.prototype.computeAbsoluteTransforms = function(forceUpdate) {
    if (forceUpdate === void 0) {
      forceUpdate = false;
    }
    var renderId = this._scene.getRenderId();
    if (this._lastAbsoluteTransformsUpdateId != renderId || forceUpdate) {
      this.bones[0].computeAbsoluteTransforms();
      this._lastAbsoluteTransformsUpdateId = renderId;
    }
  };
  Skeleton2.prototype.getPoseMatrix = function() {
    var poseMatrix = null;
    if (this._meshesWithPoseMatrix.length > 0) {
      poseMatrix = this._meshesWithPoseMatrix[0].getPoseMatrix();
    }
    return poseMatrix;
  };
  Skeleton2.prototype.sortBones = function() {
    var bones = new Array();
    var visited = new Array(this.bones.length);
    for (var index = 0; index < this.bones.length; index++) {
      this._sortBones(index, bones, visited);
    }
    this.bones = bones;
  };
  Skeleton2.prototype._sortBones = function(index, bones, visited) {
    if (visited[index]) {
      return;
    }
    visited[index] = true;
    var bone = this.bones[index];
    if (bone._index === void 0) {
      bone._index = index;
    }
    var parentBone = bone.getParent();
    if (parentBone) {
      this._sortBones(this.bones.indexOf(parentBone), bones, visited);
    }
    bones.push(bone);
  };
  Skeleton2.prototype.setCurrentPoseAsRest = function() {
    this.bones.forEach(function(b) {
      b.setCurrentPoseAsRest();
    });
  };
  return Skeleton2;
}();

// node_modules/@babylonjs/core/Cameras/cameraInputsManager.js
var CameraInputTypes = {};
var CameraInputsManager = function() {
  function CameraInputsManager2(camera) {
    this.attachedToElement = false;
    this.attached = {};
    this.camera = camera;
    this.checkInputs = function() {
    };
  }
  CameraInputsManager2.prototype.add = function(input) {
    var type = input.getSimpleName();
    if (this.attached[type]) {
      Logger.Warn("camera input of type " + type + " already exists on camera");
      return;
    }
    this.attached[type] = input;
    input.camera = this.camera;
    if (input.checkInputs) {
      this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));
    }
    if (this.attachedToElement) {
      input.attachControl();
    }
  };
  CameraInputsManager2.prototype.remove = function(inputToRemove) {
    for (var cam in this.attached) {
      var input = this.attached[cam];
      if (input === inputToRemove) {
        input.detachControl();
        input.camera = null;
        delete this.attached[cam];
        this.rebuildInputCheck();
      }
    }
  };
  CameraInputsManager2.prototype.removeByType = function(inputType) {
    for (var cam in this.attached) {
      var input = this.attached[cam];
      if (input.getClassName() === inputType) {
        input.detachControl();
        input.camera = null;
        delete this.attached[cam];
        this.rebuildInputCheck();
      }
    }
  };
  CameraInputsManager2.prototype._addCheckInputs = function(fn) {
    var current = this.checkInputs;
    return function() {
      current();
      fn();
    };
  };
  CameraInputsManager2.prototype.attachInput = function(input) {
    if (this.attachedToElement) {
      input.attachControl(this.noPreventDefault);
    }
  };
  CameraInputsManager2.prototype.attachElement = function(noPreventDefault) {
    if (noPreventDefault === void 0) {
      noPreventDefault = false;
    }
    if (this.attachedToElement) {
      return;
    }
    noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;
    this.attachedToElement = true;
    this.noPreventDefault = noPreventDefault;
    for (var cam in this.attached) {
      this.attached[cam].attachControl(noPreventDefault);
    }
  };
  CameraInputsManager2.prototype.detachElement = function(disconnect) {
    if (disconnect === void 0) {
      disconnect = false;
    }
    for (var cam in this.attached) {
      this.attached[cam].detachControl();
      if (disconnect) {
        this.attached[cam].camera = null;
      }
    }
    this.attachedToElement = false;
  };
  CameraInputsManager2.prototype.rebuildInputCheck = function() {
    this.checkInputs = function() {
    };
    for (var cam in this.attached) {
      var input = this.attached[cam];
      if (input.checkInputs) {
        this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));
      }
    }
  };
  CameraInputsManager2.prototype.clear = function() {
    if (this.attachedToElement) {
      this.detachElement(true);
    }
    this.attached = {};
    this.attachedToElement = false;
    this.checkInputs = function() {
    };
  };
  CameraInputsManager2.prototype.serialize = function(serializedCamera) {
    var inputs = {};
    for (var cam in this.attached) {
      var input = this.attached[cam];
      var res = SerializationHelper.Serialize(input);
      inputs[input.getClassName()] = res;
    }
    serializedCamera.inputsmgr = inputs;
  };
  CameraInputsManager2.prototype.parse = function(parsedCamera) {
    var parsedInputs = parsedCamera.inputsmgr;
    if (parsedInputs) {
      this.clear();
      for (var n in parsedInputs) {
        var construct = CameraInputTypes[n];
        if (construct) {
          var parsedinput = parsedInputs[n];
          var input = SerializationHelper.Parse(function() {
            return new construct();
          }, parsedinput, null);
          this.add(input);
        }
      }
    } else {
      for (var n in this.attached) {
        var construct = CameraInputTypes[this.attached[n].getClassName()];
        if (construct) {
          var input = SerializationHelper.Parse(function() {
            return new construct();
          }, parsedCamera, null);
          this.remove(this.attached[n]);
          this.add(input);
        }
      }
    }
  };
  return CameraInputsManager2;
}();

// node_modules/@babylonjs/core/Cameras/Inputs/freeCameraKeyboardMoveInput.js
var FreeCameraKeyboardMoveInput = function() {
  function FreeCameraKeyboardMoveInput2() {
    this.keysUp = [38];
    this.keysUpward = [33];
    this.keysDown = [40];
    this.keysDownward = [34];
    this.keysLeft = [37];
    this.keysRight = [39];
    this._keys = new Array();
  }
  FreeCameraKeyboardMoveInput2.prototype.attachControl = function(noPreventDefault) {
    var _this = this;
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    if (this._onCanvasBlurObserver) {
      return;
    }
    this._scene = this.camera.getScene();
    this._engine = this._scene.getEngine();
    this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(function() {
      _this._keys = [];
    });
    this._onKeyboardObserver = this._scene.onKeyboardObservable.add(function(info) {
      var evt = info.event;
      if (!evt.metaKey) {
        if (info.type === KeyboardEventTypes.KEYDOWN) {
          if (_this.keysUp.indexOf(evt.keyCode) !== -1 || _this.keysDown.indexOf(evt.keyCode) !== -1 || _this.keysLeft.indexOf(evt.keyCode) !== -1 || _this.keysRight.indexOf(evt.keyCode) !== -1 || _this.keysUpward.indexOf(evt.keyCode) !== -1 || _this.keysDownward.indexOf(evt.keyCode) !== -1) {
            var index = _this._keys.indexOf(evt.keyCode);
            if (index === -1) {
              _this._keys.push(evt.keyCode);
            }
            if (!noPreventDefault) {
              evt.preventDefault();
            }
          }
        } else {
          if (_this.keysUp.indexOf(evt.keyCode) !== -1 || _this.keysDown.indexOf(evt.keyCode) !== -1 || _this.keysLeft.indexOf(evt.keyCode) !== -1 || _this.keysRight.indexOf(evt.keyCode) !== -1 || _this.keysUpward.indexOf(evt.keyCode) !== -1 || _this.keysDownward.indexOf(evt.keyCode) !== -1) {
            var index = _this._keys.indexOf(evt.keyCode);
            if (index >= 0) {
              _this._keys.splice(index, 1);
            }
            if (!noPreventDefault) {
              evt.preventDefault();
            }
          }
        }
      }
    });
  };
  FreeCameraKeyboardMoveInput2.prototype.detachControl = function(ignored) {
    if (this._scene) {
      if (this._onKeyboardObserver) {
        this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);
      }
      if (this._onCanvasBlurObserver) {
        this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);
      }
      this._onKeyboardObserver = null;
      this._onCanvasBlurObserver = null;
    }
    this._keys = [];
  };
  FreeCameraKeyboardMoveInput2.prototype.checkInputs = function() {
    if (this._onKeyboardObserver) {
      var camera = this.camera;
      for (var index = 0; index < this._keys.length; index++) {
        var keyCode = this._keys[index];
        var speed = camera._computeLocalCameraSpeed();
        if (this.keysLeft.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(-speed, 0, 0);
        } else if (this.keysUp.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(0, 0, speed);
        } else if (this.keysRight.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(speed, 0, 0);
        } else if (this.keysDown.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(0, 0, -speed);
        } else if (this.keysUpward.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(0, speed, 0);
        } else if (this.keysDownward.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(0, -speed, 0);
        }
        if (camera.getScene().useRightHandedSystem) {
          camera._localDirection.z *= -1;
        }
        camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);
        Vector3.TransformNormalToRef(camera._localDirection, camera._cameraTransformMatrix, camera._transformedDirection);
        camera.cameraDirection.addInPlace(camera._transformedDirection);
      }
    }
  };
  FreeCameraKeyboardMoveInput2.prototype.getClassName = function() {
    return "FreeCameraKeyboardMoveInput";
  };
  FreeCameraKeyboardMoveInput2.prototype._onLostFocus = function() {
    this._keys = [];
  };
  FreeCameraKeyboardMoveInput2.prototype.getSimpleName = function() {
    return "keyboard";
  };
  __decorate([
    serialize()
  ], FreeCameraKeyboardMoveInput2.prototype, "keysUp", void 0);
  __decorate([
    serialize()
  ], FreeCameraKeyboardMoveInput2.prototype, "keysUpward", void 0);
  __decorate([
    serialize()
  ], FreeCameraKeyboardMoveInput2.prototype, "keysDown", void 0);
  __decorate([
    serialize()
  ], FreeCameraKeyboardMoveInput2.prototype, "keysDownward", void 0);
  __decorate([
    serialize()
  ], FreeCameraKeyboardMoveInput2.prototype, "keysLeft", void 0);
  __decorate([
    serialize()
  ], FreeCameraKeyboardMoveInput2.prototype, "keysRight", void 0);
  return FreeCameraKeyboardMoveInput2;
}();
CameraInputTypes["FreeCameraKeyboardMoveInput"] = FreeCameraKeyboardMoveInput;

// node_modules/@babylonjs/core/Cameras/Inputs/freeCameraMouseInput.js
var FreeCameraMouseInput = function() {
  function FreeCameraMouseInput2(touchEnabled) {
    if (touchEnabled === void 0) {
      touchEnabled = true;
    }
    this.touchEnabled = touchEnabled;
    this.buttons = [0, 1, 2];
    this.angularSensibility = 2e3;
    this.previousPosition = null;
    this.onPointerMovedObservable = new Observable();
    this._allowCameraRotation = true;
  }
  FreeCameraMouseInput2.prototype.attachControl = function(noPreventDefault) {
    var _this = this;
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    var engine = this.camera.getEngine();
    var element = engine.getInputElement();
    if (!this._pointerInput) {
      this._pointerInput = function(p) {
        var evt = p.event;
        if (engine.isInVRExclusivePointerMode) {
          return;
        }
        if (!_this.touchEnabled && evt.pointerType === "touch") {
          return;
        }
        if (p.type !== PointerEventTypes.POINTERMOVE && _this.buttons.indexOf(evt.button) === -1) {
          return;
        }
        var srcElement = evt.srcElement || evt.target;
        if (p.type === PointerEventTypes.POINTERDOWN && srcElement) {
          try {
            srcElement.setPointerCapture(evt.pointerId);
          } catch (e) {
          }
          _this.previousPosition = {
            x: evt.clientX,
            y: evt.clientY
          };
          if (!noPreventDefault) {
            evt.preventDefault();
            element && element.focus();
          }
          if (engine.isPointerLock && _this._onMouseMove) {
            _this._onMouseMove(p.event);
          }
        } else if (p.type === PointerEventTypes.POINTERUP && srcElement) {
          try {
            srcElement.releasePointerCapture(evt.pointerId);
          } catch (e) {
          }
          _this.previousPosition = null;
          if (!noPreventDefault) {
            evt.preventDefault();
          }
        } else if (p.type === PointerEventTypes.POINTERMOVE) {
          if (!_this.previousPosition) {
            if (engine.isPointerLock && _this._onMouseMove) {
              _this._onMouseMove(p.event);
            }
            return;
          }
          var offsetX = evt.clientX - _this.previousPosition.x;
          var offsetY = evt.clientY - _this.previousPosition.y;
          if (_this.camera.getScene().useRightHandedSystem) {
            offsetX *= -1;
          }
          if (_this.camera.parent && _this.camera.parent._getWorldMatrixDeterminant() < 0) {
            offsetX *= -1;
          }
          if (_this._allowCameraRotation) {
            _this.camera.cameraRotation.y += offsetX / _this.angularSensibility;
            _this.camera.cameraRotation.x += offsetY / _this.angularSensibility;
          }
          _this.onPointerMovedObservable.notifyObservers({ offsetX, offsetY });
          _this.previousPosition = {
            x: evt.clientX,
            y: evt.clientY
          };
          if (!noPreventDefault) {
            evt.preventDefault();
          }
        }
      };
    }
    this._onMouseMove = function(evt) {
      if (!engine.isPointerLock) {
        return;
      }
      if (engine.isInVRExclusivePointerMode) {
        return;
      }
      var offsetX = evt.movementX || evt.mozMovementX || evt.webkitMovementX || evt.msMovementX || 0;
      if (_this.camera.getScene().useRightHandedSystem) {
        offsetX *= -1;
      }
      if (_this.camera.parent && _this.camera.parent._getWorldMatrixDeterminant() < 0) {
        offsetX *= -1;
      }
      _this.camera.cameraRotation.y += offsetX / _this.angularSensibility;
      var offsetY = evt.movementY || evt.mozMovementY || evt.webkitMovementY || evt.msMovementY || 0;
      _this.camera.cameraRotation.x += offsetY / _this.angularSensibility;
      _this.previousPosition = null;
      if (!noPreventDefault) {
        evt.preventDefault();
      }
    };
    this._observer = this.camera.getScene().onPointerObservable.add(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);
    element && element.addEventListener("contextmenu", this.onContextMenu.bind(this), false);
  };
  FreeCameraMouseInput2.prototype.onContextMenu = function(evt) {
    evt.preventDefault();
  };
  FreeCameraMouseInput2.prototype.detachControl = function(ignored) {
    if (this._observer) {
      this.camera.getScene().onPointerObservable.remove(this._observer);
      if (this.onContextMenu) {
        var engine = this.camera.getEngine();
        var element = engine.getInputElement();
        element && element.removeEventListener("contextmenu", this.onContextMenu);
      }
      if (this.onPointerMovedObservable) {
        this.onPointerMovedObservable.clear();
      }
      this._observer = null;
      this._onMouseMove = null;
      this.previousPosition = null;
    }
  };
  FreeCameraMouseInput2.prototype.getClassName = function() {
    return "FreeCameraMouseInput";
  };
  FreeCameraMouseInput2.prototype.getSimpleName = function() {
    return "mouse";
  };
  __decorate([
    serialize()
  ], FreeCameraMouseInput2.prototype, "buttons", void 0);
  __decorate([
    serialize()
  ], FreeCameraMouseInput2.prototype, "angularSensibility", void 0);
  return FreeCameraMouseInput2;
}();
CameraInputTypes["FreeCameraMouseInput"] = FreeCameraMouseInput;

// node_modules/@babylonjs/core/Cameras/Inputs/BaseCameraMouseWheelInput.js
var BaseCameraMouseWheelInput = function() {
  function BaseCameraMouseWheelInput2() {
    this.wheelPrecisionX = 3;
    this.wheelPrecisionY = 3;
    this.wheelPrecisionZ = 3;
    this.onChangedObservable = new Observable();
    this._wheelDeltaX = 0;
    this._wheelDeltaY = 0;
    this._wheelDeltaZ = 0;
    this._ffMultiplier = 12;
    this._normalize = 120;
  }
  BaseCameraMouseWheelInput2.prototype.attachControl = function(noPreventDefault) {
    var _this = this;
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    this._wheel = function(pointer) {
      if (pointer.type !== PointerEventTypes.POINTERWHEEL) {
        return;
      }
      var event = pointer.event;
      var platformScale = event.deltaMode === WheelEvent.DOM_DELTA_LINE ? _this._ffMultiplier : 1;
      if (event.deltaY !== void 0) {
        _this._wheelDeltaX += _this.wheelPrecisionX * platformScale * event.deltaX / _this._normalize;
        _this._wheelDeltaY -= _this.wheelPrecisionY * platformScale * event.deltaY / _this._normalize;
        _this._wheelDeltaZ += _this.wheelPrecisionZ * platformScale * event.deltaZ / _this._normalize;
      } else if (event.wheelDeltaY !== void 0) {
        _this._wheelDeltaX += _this.wheelPrecisionX * platformScale * event.wheelDeltaX / _this._normalize;
        _this._wheelDeltaY -= _this.wheelPrecisionY * platformScale * event.wheelDeltaY / _this._normalize;
        _this._wheelDeltaZ += _this.wheelPrecisionZ * platformScale * event.wheelDeltaZ / _this._normalize;
      } else if (event.wheelDelta) {
        _this._wheelDeltaY -= _this.wheelPrecisionY * event.wheelDelta / _this._normalize;
      }
      if (event.preventDefault) {
        if (!noPreventDefault) {
          event.preventDefault();
        }
      }
    };
    this._observer = this.camera.getScene().onPointerObservable.add(this._wheel, PointerEventTypes.POINTERWHEEL);
  };
  BaseCameraMouseWheelInput2.prototype.detachControl = function(ignored) {
    if (this._observer) {
      this.camera.getScene().onPointerObservable.remove(this._observer);
      this._observer = null;
      this._wheel = null;
    }
    if (this.onChangedObservable) {
      this.onChangedObservable.clear();
    }
  };
  BaseCameraMouseWheelInput2.prototype.checkInputs = function() {
    this.onChangedObservable.notifyObservers({
      wheelDeltaX: this._wheelDeltaX,
      wheelDeltaY: this._wheelDeltaY,
      wheelDeltaZ: this._wheelDeltaZ
    });
    this._wheelDeltaX = 0;
    this._wheelDeltaY = 0;
    this._wheelDeltaZ = 0;
  };
  BaseCameraMouseWheelInput2.prototype.getClassName = function() {
    return "BaseCameraMouseWheelInput";
  };
  BaseCameraMouseWheelInput2.prototype.getSimpleName = function() {
    return "mousewheel";
  };
  __decorate([
    serialize()
  ], BaseCameraMouseWheelInput2.prototype, "wheelPrecisionX", void 0);
  __decorate([
    serialize()
  ], BaseCameraMouseWheelInput2.prototype, "wheelPrecisionY", void 0);
  __decorate([
    serialize()
  ], BaseCameraMouseWheelInput2.prototype, "wheelPrecisionZ", void 0);
  return BaseCameraMouseWheelInput2;
}();

// node_modules/@babylonjs/core/Cameras/Inputs/freeCameraMouseWheelInput.js
var _CameraProperty;
(function(_CameraProperty2) {
  _CameraProperty2[_CameraProperty2["MoveRelative"] = 0] = "MoveRelative";
  _CameraProperty2[_CameraProperty2["RotateRelative"] = 1] = "RotateRelative";
  _CameraProperty2[_CameraProperty2["MoveScene"] = 2] = "MoveScene";
})(_CameraProperty || (_CameraProperty = {}));
var FreeCameraMouseWheelInput = function(_super) {
  __extends(FreeCameraMouseWheelInput2, _super);
  function FreeCameraMouseWheelInput2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._moveRelative = Vector3.Zero();
    _this._rotateRelative = Vector3.Zero();
    _this._moveScene = Vector3.Zero();
    _this._wheelXAction = _CameraProperty.MoveRelative;
    _this._wheelXActionCoordinate = Coordinate.X;
    _this._wheelYAction = _CameraProperty.MoveRelative;
    _this._wheelYActionCoordinate = Coordinate.Z;
    _this._wheelZAction = null;
    _this._wheelZActionCoordinate = null;
    return _this;
  }
  FreeCameraMouseWheelInput2.prototype.getClassName = function() {
    return "FreeCameraMouseWheelInput";
  };
  Object.defineProperty(FreeCameraMouseWheelInput2.prototype, "wheelXMoveRelative", {
    get: function() {
      if (this._wheelXAction !== _CameraProperty.MoveRelative) {
        return null;
      }
      return this._wheelXActionCoordinate;
    },
    set: function(axis) {
      if (axis === null && this._wheelXAction !== _CameraProperty.MoveRelative) {
        return;
      }
      this._wheelXAction = _CameraProperty.MoveRelative;
      this._wheelXActionCoordinate = axis;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FreeCameraMouseWheelInput2.prototype, "wheelYMoveRelative", {
    get: function() {
      if (this._wheelYAction !== _CameraProperty.MoveRelative) {
        return null;
      }
      return this._wheelYActionCoordinate;
    },
    set: function(axis) {
      if (axis === null && this._wheelYAction !== _CameraProperty.MoveRelative) {
        return;
      }
      this._wheelYAction = _CameraProperty.MoveRelative;
      this._wheelYActionCoordinate = axis;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FreeCameraMouseWheelInput2.prototype, "wheelZMoveRelative", {
    get: function() {
      if (this._wheelZAction !== _CameraProperty.MoveRelative) {
        return null;
      }
      return this._wheelZActionCoordinate;
    },
    set: function(axis) {
      if (axis === null && this._wheelZAction !== _CameraProperty.MoveRelative) {
        return;
      }
      this._wheelZAction = _CameraProperty.MoveRelative;
      this._wheelZActionCoordinate = axis;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FreeCameraMouseWheelInput2.prototype, "wheelXRotateRelative", {
    get: function() {
      if (this._wheelXAction !== _CameraProperty.RotateRelative) {
        return null;
      }
      return this._wheelXActionCoordinate;
    },
    set: function(axis) {
      if (axis === null && this._wheelXAction !== _CameraProperty.RotateRelative) {
        return;
      }
      this._wheelXAction = _CameraProperty.RotateRelative;
      this._wheelXActionCoordinate = axis;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FreeCameraMouseWheelInput2.prototype, "wheelYRotateRelative", {
    get: function() {
      if (this._wheelYAction !== _CameraProperty.RotateRelative) {
        return null;
      }
      return this._wheelYActionCoordinate;
    },
    set: function(axis) {
      if (axis === null && this._wheelYAction !== _CameraProperty.RotateRelative) {
        return;
      }
      this._wheelYAction = _CameraProperty.RotateRelative;
      this._wheelYActionCoordinate = axis;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FreeCameraMouseWheelInput2.prototype, "wheelZRotateRelative", {
    get: function() {
      if (this._wheelZAction !== _CameraProperty.RotateRelative) {
        return null;
      }
      return this._wheelZActionCoordinate;
    },
    set: function(axis) {
      if (axis === null && this._wheelZAction !== _CameraProperty.RotateRelative) {
        return;
      }
      this._wheelZAction = _CameraProperty.RotateRelative;
      this._wheelZActionCoordinate = axis;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FreeCameraMouseWheelInput2.prototype, "wheelXMoveScene", {
    get: function() {
      if (this._wheelXAction !== _CameraProperty.MoveScene) {
        return null;
      }
      return this._wheelXActionCoordinate;
    },
    set: function(axis) {
      if (axis === null && this._wheelXAction !== _CameraProperty.MoveScene) {
        return;
      }
      this._wheelXAction = _CameraProperty.MoveScene;
      this._wheelXActionCoordinate = axis;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FreeCameraMouseWheelInput2.prototype, "wheelYMoveScene", {
    get: function() {
      if (this._wheelYAction !== _CameraProperty.MoveScene) {
        return null;
      }
      return this._wheelYActionCoordinate;
    },
    set: function(axis) {
      if (axis === null && this._wheelYAction !== _CameraProperty.MoveScene) {
        return;
      }
      this._wheelYAction = _CameraProperty.MoveScene;
      this._wheelYActionCoordinate = axis;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FreeCameraMouseWheelInput2.prototype, "wheelZMoveScene", {
    get: function() {
      if (this._wheelZAction !== _CameraProperty.MoveScene) {
        return null;
      }
      return this._wheelZActionCoordinate;
    },
    set: function(axis) {
      if (axis === null && this._wheelZAction !== _CameraProperty.MoveScene) {
        return;
      }
      this._wheelZAction = _CameraProperty.MoveScene;
      this._wheelZActionCoordinate = axis;
    },
    enumerable: false,
    configurable: true
  });
  FreeCameraMouseWheelInput2.prototype.checkInputs = function() {
    if (this._wheelDeltaX === 0 && this._wheelDeltaY === 0 && this._wheelDeltaZ == 0) {
      return;
    }
    this._moveRelative.setAll(0);
    this._rotateRelative.setAll(0);
    this._moveScene.setAll(0);
    this._updateCamera();
    if (this.camera.getScene().useRightHandedSystem) {
      this._moveRelative.z *= -1;
    }
    var cameraTransformMatrix = Matrix.Zero();
    this.camera.getViewMatrix().invertToRef(cameraTransformMatrix);
    var transformedDirection = Vector3.Zero();
    Vector3.TransformNormalToRef(this._moveRelative, cameraTransformMatrix, transformedDirection);
    this.camera.cameraRotation.x += this._rotateRelative.x / 200;
    this.camera.cameraRotation.y += this._rotateRelative.y / 200;
    this.camera.cameraDirection.addInPlace(transformedDirection);
    this.camera.cameraDirection.addInPlace(this._moveScene);
    _super.prototype.checkInputs.call(this);
  };
  FreeCameraMouseWheelInput2.prototype._updateCamera = function() {
    var moveRelative = this._moveRelative;
    var rotateRelative = this._rotateRelative;
    var moveScene = this._moveScene;
    var updateCameraProperty = function(value, cameraProperty, coordinate) {
      if (value === 0) {
        return;
      }
      if (cameraProperty === null || coordinate === null) {
        return;
      }
      var action = null;
      switch (cameraProperty) {
        case _CameraProperty.MoveRelative:
          action = moveRelative;
          break;
        case _CameraProperty.RotateRelative:
          action = rotateRelative;
          break;
        case _CameraProperty.MoveScene:
          action = moveScene;
          break;
      }
      switch (coordinate) {
        case Coordinate.X:
          action.set(value, 0, 0);
          break;
        case Coordinate.Y:
          action.set(0, value, 0);
          break;
        case Coordinate.Z:
          action.set(0, 0, value);
          break;
      }
    };
    updateCameraProperty(this._wheelDeltaX, this._wheelXAction, this._wheelXActionCoordinate);
    updateCameraProperty(this._wheelDeltaY, this._wheelYAction, this._wheelYActionCoordinate);
    updateCameraProperty(this._wheelDeltaZ, this._wheelZAction, this._wheelZActionCoordinate);
  };
  __decorate([
    serialize()
  ], FreeCameraMouseWheelInput2.prototype, "wheelXMoveRelative", null);
  __decorate([
    serialize()
  ], FreeCameraMouseWheelInput2.prototype, "wheelYMoveRelative", null);
  __decorate([
    serialize()
  ], FreeCameraMouseWheelInput2.prototype, "wheelZMoveRelative", null);
  __decorate([
    serialize()
  ], FreeCameraMouseWheelInput2.prototype, "wheelXRotateRelative", null);
  __decorate([
    serialize()
  ], FreeCameraMouseWheelInput2.prototype, "wheelYRotateRelative", null);
  __decorate([
    serialize()
  ], FreeCameraMouseWheelInput2.prototype, "wheelZRotateRelative", null);
  __decorate([
    serialize()
  ], FreeCameraMouseWheelInput2.prototype, "wheelXMoveScene", null);
  __decorate([
    serialize()
  ], FreeCameraMouseWheelInput2.prototype, "wheelYMoveScene", null);
  __decorate([
    serialize()
  ], FreeCameraMouseWheelInput2.prototype, "wheelZMoveScene", null);
  return FreeCameraMouseWheelInput2;
}(BaseCameraMouseWheelInput);
CameraInputTypes["FreeCameraMouseWheelInput"] = FreeCameraMouseWheelInput;

// node_modules/@babylonjs/core/Cameras/Inputs/freeCameraTouchInput.js
var FreeCameraTouchInput = function() {
  function FreeCameraTouchInput2(allowMouse) {
    if (allowMouse === void 0) {
      allowMouse = false;
    }
    this.allowMouse = allowMouse;
    this.touchAngularSensibility = 2e5;
    this.touchMoveSensibility = 250;
    this._offsetX = null;
    this._offsetY = null;
    this._pointerPressed = new Array();
  }
  FreeCameraTouchInput2.prototype.attachControl = function(noPreventDefault) {
    var _this = this;
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    var previousPosition = null;
    if (this._pointerInput === void 0) {
      this._onLostFocus = function() {
        _this._offsetX = null;
        _this._offsetY = null;
      };
      this._pointerInput = function(p) {
        var evt = p.event;
        var isMouseEvent = !_this.camera.getEngine().hostInformation.isMobile && evt instanceof MouseEvent;
        if (!_this.allowMouse && (evt.pointerType === "mouse" || isMouseEvent)) {
          return;
        }
        if (p.type === PointerEventTypes.POINTERDOWN) {
          if (!noPreventDefault) {
            evt.preventDefault();
          }
          _this._pointerPressed.push(evt.pointerId);
          if (_this._pointerPressed.length !== 1) {
            return;
          }
          previousPosition = {
            x: evt.clientX,
            y: evt.clientY
          };
        } else if (p.type === PointerEventTypes.POINTERUP) {
          if (!noPreventDefault) {
            evt.preventDefault();
          }
          var index = _this._pointerPressed.indexOf(evt.pointerId);
          if (index === -1) {
            return;
          }
          _this._pointerPressed.splice(index, 1);
          if (index != 0) {
            return;
          }
          previousPosition = null;
          _this._offsetX = null;
          _this._offsetY = null;
        } else if (p.type === PointerEventTypes.POINTERMOVE) {
          if (!noPreventDefault) {
            evt.preventDefault();
          }
          if (!previousPosition) {
            return;
          }
          var index = _this._pointerPressed.indexOf(evt.pointerId);
          if (index != 0) {
            return;
          }
          _this._offsetX = evt.clientX - previousPosition.x;
          _this._offsetY = -(evt.clientY - previousPosition.y);
        }
      };
    }
    this._observer = this.camera.getScene().onPointerObservable.add(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);
    if (this._onLostFocus) {
      var engine = this.camera.getEngine();
      var element = engine.getInputElement();
      element && element.addEventListener("blur", this._onLostFocus);
    }
  };
  FreeCameraTouchInput2.prototype.detachControl = function(ignored) {
    if (this._pointerInput) {
      if (this._observer) {
        this.camera.getScene().onPointerObservable.remove(this._observer);
        this._observer = null;
      }
      if (this._onLostFocus) {
        var engine = this.camera.getEngine();
        var element = engine.getInputElement();
        element && element.removeEventListener("blur", this._onLostFocus);
        this._onLostFocus = null;
      }
      this._pointerPressed = [];
      this._offsetX = null;
      this._offsetY = null;
    }
  };
  FreeCameraTouchInput2.prototype.checkInputs = function() {
    if (this._offsetX === null || this._offsetY === null) {
      return;
    }
    if (this._offsetX === 0 && this._offsetY === 0) {
      return;
    }
    var camera = this.camera;
    camera.cameraRotation.y = this._offsetX / this.touchAngularSensibility;
    if (this._pointerPressed.length > 1) {
      camera.cameraRotation.x = -this._offsetY / this.touchAngularSensibility;
    } else {
      var speed = camera._computeLocalCameraSpeed();
      var direction = new Vector3(0, 0, speed * this._offsetY / this.touchMoveSensibility);
      Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, camera._cameraRotationMatrix);
      camera.cameraDirection.addInPlace(Vector3.TransformCoordinates(direction, camera._cameraRotationMatrix));
    }
  };
  FreeCameraTouchInput2.prototype.getClassName = function() {
    return "FreeCameraTouchInput";
  };
  FreeCameraTouchInput2.prototype.getSimpleName = function() {
    return "touch";
  };
  __decorate([
    serialize()
  ], FreeCameraTouchInput2.prototype, "touchAngularSensibility", void 0);
  __decorate([
    serialize()
  ], FreeCameraTouchInput2.prototype, "touchMoveSensibility", void 0);
  return FreeCameraTouchInput2;
}();
CameraInputTypes["FreeCameraTouchInput"] = FreeCameraTouchInput;

// node_modules/@babylonjs/core/Cameras/freeCameraInputsManager.js
var FreeCameraInputsManager = function(_super) {
  __extends(FreeCameraInputsManager2, _super);
  function FreeCameraInputsManager2(camera) {
    var _this = _super.call(this, camera) || this;
    _this._mouseInput = null;
    _this._mouseWheelInput = null;
    return _this;
  }
  FreeCameraInputsManager2.prototype.addKeyboard = function() {
    this.add(new FreeCameraKeyboardMoveInput());
    return this;
  };
  FreeCameraInputsManager2.prototype.addMouse = function(touchEnabled) {
    if (touchEnabled === void 0) {
      touchEnabled = true;
    }
    if (!this._mouseInput) {
      this._mouseInput = new FreeCameraMouseInput(touchEnabled);
      this.add(this._mouseInput);
    }
    return this;
  };
  FreeCameraInputsManager2.prototype.removeMouse = function() {
    if (this._mouseInput) {
      this.remove(this._mouseInput);
    }
    return this;
  };
  FreeCameraInputsManager2.prototype.addMouseWheel = function() {
    if (!this._mouseWheelInput) {
      this._mouseWheelInput = new FreeCameraMouseWheelInput();
      this.add(this._mouseWheelInput);
    }
    return this;
  };
  FreeCameraInputsManager2.prototype.removeMouseWheel = function() {
    if (this._mouseWheelInput) {
      this.remove(this._mouseWheelInput);
    }
    return this;
  };
  FreeCameraInputsManager2.prototype.addTouch = function() {
    this.add(new FreeCameraTouchInput());
    return this;
  };
  FreeCameraInputsManager2.prototype.clear = function() {
    _super.prototype.clear.call(this);
    this._mouseInput = null;
  };
  return FreeCameraInputsManager2;
}(CameraInputsManager);

// node_modules/@babylonjs/core/Cameras/targetCamera.js
var TargetCamera = function(_super) {
  __extends(TargetCamera2, _super);
  function TargetCamera2(name42, position, scene, setActiveOnSceneIfNoneActive) {
    if (setActiveOnSceneIfNoneActive === void 0) {
      setActiveOnSceneIfNoneActive = true;
    }
    var _this = _super.call(this, name42, position, scene, setActiveOnSceneIfNoneActive) || this;
    _this._tmpUpVector = Vector3.Zero();
    _this._tmpTargetVector = Vector3.Zero();
    _this.cameraDirection = new Vector3(0, 0, 0);
    _this.cameraRotation = new Vector2(0, 0);
    _this.ignoreParentScaling = false;
    _this.updateUpVectorFromRotation = false;
    _this._tmpQuaternion = new Quaternion();
    _this.rotation = new Vector3(0, 0, 0);
    _this.speed = 2;
    _this.noRotationConstraint = false;
    _this.invertRotation = false;
    _this.inverseRotationSpeed = 0.2;
    _this.lockedTarget = null;
    _this._currentTarget = Vector3.Zero();
    _this._initialFocalDistance = 1;
    _this._viewMatrix = Matrix.Zero();
    _this._camMatrix = Matrix.Zero();
    _this._cameraTransformMatrix = Matrix.Zero();
    _this._cameraRotationMatrix = Matrix.Zero();
    _this._referencePoint = new Vector3(0, 0, 1);
    _this._transformedReferencePoint = Vector3.Zero();
    _this._defaultUp = Vector3.Up();
    _this._cachedRotationZ = 0;
    _this._cachedQuaternionRotationZ = 0;
    return _this;
  }
  TargetCamera2.prototype.getFrontPosition = function(distance) {
    this.getWorldMatrix();
    var direction = this.getTarget().subtract(this.position);
    direction.normalize();
    direction.scaleInPlace(distance);
    return this.globalPosition.add(direction);
  };
  TargetCamera2.prototype._getLockedTargetPosition = function() {
    if (!this.lockedTarget) {
      return null;
    }
    if (this.lockedTarget.absolutePosition) {
      this.lockedTarget.computeWorldMatrix();
    }
    return this.lockedTarget.absolutePosition || this.lockedTarget;
  };
  TargetCamera2.prototype.storeState = function() {
    this._storedPosition = this.position.clone();
    this._storedRotation = this.rotation.clone();
    if (this.rotationQuaternion) {
      this._storedRotationQuaternion = this.rotationQuaternion.clone();
    }
    return _super.prototype.storeState.call(this);
  };
  TargetCamera2.prototype._restoreStateValues = function() {
    if (!_super.prototype._restoreStateValues.call(this)) {
      return false;
    }
    this.position = this._storedPosition.clone();
    this.rotation = this._storedRotation.clone();
    if (this.rotationQuaternion) {
      this.rotationQuaternion = this._storedRotationQuaternion.clone();
    }
    this.cameraDirection.copyFromFloats(0, 0, 0);
    this.cameraRotation.copyFromFloats(0, 0);
    return true;
  };
  TargetCamera2.prototype._initCache = function() {
    _super.prototype._initCache.call(this);
    this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
  };
  TargetCamera2.prototype._updateCache = function(ignoreParentClass) {
    if (!ignoreParentClass) {
      _super.prototype._updateCache.call(this);
    }
    var lockedTargetPosition = this._getLockedTargetPosition();
    if (!lockedTargetPosition) {
      this._cache.lockedTarget = null;
    } else {
      if (!this._cache.lockedTarget) {
        this._cache.lockedTarget = lockedTargetPosition.clone();
      } else {
        this._cache.lockedTarget.copyFrom(lockedTargetPosition);
      }
    }
    this._cache.rotation.copyFrom(this.rotation);
    if (this.rotationQuaternion) {
      this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);
    }
  };
  TargetCamera2.prototype._isSynchronizedViewMatrix = function() {
    if (!_super.prototype._isSynchronizedViewMatrix.call(this)) {
      return false;
    }
    var lockedTargetPosition = this._getLockedTargetPosition();
    return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) && (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation));
  };
  TargetCamera2.prototype._computeLocalCameraSpeed = function() {
    var engine = this.getEngine();
    return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100));
  };
  TargetCamera2.prototype.setTarget = function(target) {
    this.upVector.normalize();
    this._initialFocalDistance = target.subtract(this.position).length();
    if (this.position.z === target.z) {
      this.position.z += Epsilon;
    }
    this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);
    Matrix.LookAtLHToRef(this.position, target, this._defaultUp, this._camMatrix);
    this._camMatrix.invert();
    this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);
    var vDir = target.subtract(this.position);
    if (vDir.x >= 0) {
      this.rotation.y = -Math.atan(vDir.z / vDir.x) + Math.PI / 2;
    } else {
      this.rotation.y = -Math.atan(vDir.z / vDir.x) - Math.PI / 2;
    }
    this.rotation.z = 0;
    if (isNaN(this.rotation.x)) {
      this.rotation.x = 0;
    }
    if (isNaN(this.rotation.y)) {
      this.rotation.y = 0;
    }
    if (isNaN(this.rotation.z)) {
      this.rotation.z = 0;
    }
    if (this.rotationQuaternion) {
      Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);
    }
  };
  Object.defineProperty(TargetCamera2.prototype, "target", {
    get: function() {
      return this.getTarget();
    },
    set: function(value) {
      this.setTarget(value);
    },
    enumerable: false,
    configurable: true
  });
  TargetCamera2.prototype.getTarget = function() {
    return this._currentTarget;
  };
  TargetCamera2.prototype._decideIfNeedsToMove = function() {
    return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;
  };
  TargetCamera2.prototype._updatePosition = function() {
    if (this.parent) {
      this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);
      Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);
      this.position.addInPlace(TmpVectors.Vector3[0]);
      return;
    }
    this.position.addInPlace(this.cameraDirection);
  };
  TargetCamera2.prototype._checkInputs = function() {
    var directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1;
    var needToMove = this._decideIfNeedsToMove();
    var needToRotate = Math.abs(this.cameraRotation.x) > 0 || Math.abs(this.cameraRotation.y) > 0;
    if (needToMove) {
      this._updatePosition();
    }
    if (needToRotate) {
      if (this.rotationQuaternion) {
        this.rotationQuaternion.toEulerAnglesToRef(this.rotation);
      }
      this.rotation.x += this.cameraRotation.x * directionMultiplier;
      this.rotation.y += this.cameraRotation.y * directionMultiplier;
      if (!this.noRotationConstraint) {
        var limit = 1.570796;
        if (this.rotation.x > limit) {
          this.rotation.x = limit;
        }
        if (this.rotation.x < -limit) {
          this.rotation.x = -limit;
        }
      }
      if (this.rotationQuaternion) {
        var len = this.rotation.lengthSquared();
        if (len) {
          Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);
        }
      }
    }
    if (needToMove) {
      if (Math.abs(this.cameraDirection.x) < this.speed * Epsilon) {
        this.cameraDirection.x = 0;
      }
      if (Math.abs(this.cameraDirection.y) < this.speed * Epsilon) {
        this.cameraDirection.y = 0;
      }
      if (Math.abs(this.cameraDirection.z) < this.speed * Epsilon) {
        this.cameraDirection.z = 0;
      }
      this.cameraDirection.scaleInPlace(this.inertia);
    }
    if (needToRotate) {
      if (Math.abs(this.cameraRotation.x) < this.speed * Epsilon) {
        this.cameraRotation.x = 0;
      }
      if (Math.abs(this.cameraRotation.y) < this.speed * Epsilon) {
        this.cameraRotation.y = 0;
      }
      this.cameraRotation.scaleInPlace(this.inertia);
    }
    _super.prototype._checkInputs.call(this);
  };
  TargetCamera2.prototype._updateCameraRotationMatrix = function() {
    if (this.rotationQuaternion) {
      this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);
    } else {
      Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);
    }
  };
  TargetCamera2.prototype._rotateUpVectorWithCameraRotationMatrix = function() {
    Vector3.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector);
    return this;
  };
  TargetCamera2.prototype._getViewMatrix = function() {
    if (this.lockedTarget) {
      this.setTarget(this._getLockedTargetPosition());
    }
    this._updateCameraRotationMatrix();
    if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {
      this._rotateUpVectorWithCameraRotationMatrix();
      this._cachedQuaternionRotationZ = this.rotationQuaternion.z;
    } else if (this._cachedRotationZ != this.rotation.z) {
      this._rotateUpVectorWithCameraRotationMatrix();
      this._cachedRotationZ = this.rotation.z;
    }
    Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);
    this.position.addToRef(this._transformedReferencePoint, this._currentTarget);
    if (this.updateUpVectorFromRotation) {
      if (this.rotationQuaternion) {
        Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);
      } else {
        Quaternion.FromEulerVectorToRef(this.rotation, this._tmpQuaternion);
        Axis.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector);
      }
    }
    this._computeViewMatrix(this.position, this._currentTarget, this.upVector);
    return this._viewMatrix;
  };
  TargetCamera2.prototype._computeViewMatrix = function(position, target, up) {
    if (this.ignoreParentScaling) {
      if (this.parent) {
        var parentWorldMatrix = this.parent.getWorldMatrix();
        Vector3.TransformCoordinatesToRef(position, parentWorldMatrix, this._globalPosition);
        Vector3.TransformCoordinatesToRef(target, parentWorldMatrix, this._tmpTargetVector);
        Vector3.TransformNormalToRef(up, parentWorldMatrix, this._tmpUpVector);
        this._markSyncedWithParent();
      } else {
        this._globalPosition.copyFrom(position);
        this._tmpTargetVector.copyFrom(target);
        this._tmpUpVector.copyFrom(up);
      }
      if (this.getScene().useRightHandedSystem) {
        Matrix.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);
      } else {
        Matrix.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);
      }
      return;
    }
    if (this.getScene().useRightHandedSystem) {
      Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);
    } else {
      Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);
    }
    if (this.parent) {
      var parentWorldMatrix = this.parent.getWorldMatrix();
      this._viewMatrix.invert();
      this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);
      this._viewMatrix.getTranslationToRef(this._globalPosition);
      this._viewMatrix.invert();
      this._markSyncedWithParent();
    } else {
      this._globalPosition.copyFrom(position);
    }
  };
  TargetCamera2.prototype.createRigCamera = function(name42, cameraIndex) {
    if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {
      var rigCamera = new TargetCamera2(name42, this.position.clone(), this.getScene());
      rigCamera.isRigCamera = true;
      rigCamera.rigParent = this;
      if (this.cameraRigMode === Camera.RIG_MODE_VR || this.cameraRigMode === Camera.RIG_MODE_WEBVR) {
        if (!this.rotationQuaternion) {
          this.rotationQuaternion = new Quaternion();
        }
        rigCamera._cameraRigParams = {};
        rigCamera.rotationQuaternion = new Quaternion();
      }
      return rigCamera;
    }
    return null;
  };
  TargetCamera2.prototype._updateRigCameras = function() {
    var camLeft = this._rigCameras[0];
    var camRight = this._rigCameras[1];
    this.computeWorldMatrix();
    switch (this.cameraRigMode) {
      case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
      case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:
      case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:
        var leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;
        var rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;
        this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);
        this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);
        break;
      case Camera.RIG_MODE_VR:
        if (camLeft.rotationQuaternion) {
          camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);
          camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);
        } else {
          camLeft.rotation.copyFrom(this.rotation);
          camRight.rotation.copyFrom(this.rotation);
        }
        camLeft.position.copyFrom(this.position);
        camRight.position.copyFrom(this.position);
        break;
    }
    _super.prototype._updateRigCameras.call(this);
  };
  TargetCamera2.prototype._getRigCamPositionAndTarget = function(halfSpace, rigCamera) {
    var target = this.getTarget();
    target.subtractToRef(this.position, TargetCamera2._TargetFocalPoint);
    TargetCamera2._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);
    var newFocalTarget = TargetCamera2._TargetFocalPoint.addInPlace(this.position);
    Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, TargetCamera2._TargetTransformMatrix);
    TargetCamera2._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), TargetCamera2._RigCamTransformMatrix);
    Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, TargetCamera2._TargetTransformMatrix);
    TargetCamera2._RigCamTransformMatrix.multiplyToRef(TargetCamera2._TargetTransformMatrix, TargetCamera2._RigCamTransformMatrix);
    Vector3.TransformCoordinatesToRef(this.position, TargetCamera2._RigCamTransformMatrix, rigCamera.position);
    rigCamera.setTarget(newFocalTarget);
  };
  TargetCamera2.prototype.getClassName = function() {
    return "TargetCamera";
  };
  TargetCamera2._RigCamTransformMatrix = new Matrix();
  TargetCamera2._TargetTransformMatrix = new Matrix();
  TargetCamera2._TargetFocalPoint = new Vector3();
  __decorate([
    serializeAsVector3()
  ], TargetCamera2.prototype, "rotation", void 0);
  __decorate([
    serialize()
  ], TargetCamera2.prototype, "speed", void 0);
  __decorate([
    serializeAsMeshReference("lockedTargetId")
  ], TargetCamera2.prototype, "lockedTarget", void 0);
  return TargetCamera2;
}(Camera);

// node_modules/@babylonjs/core/Cameras/freeCamera.js
var FreeCamera = function(_super) {
  __extends(FreeCamera2, _super);
  function FreeCamera2(name42, position, scene, setActiveOnSceneIfNoneActive) {
    if (setActiveOnSceneIfNoneActive === void 0) {
      setActiveOnSceneIfNoneActive = true;
    }
    var _this = _super.call(this, name42, position, scene, setActiveOnSceneIfNoneActive) || this;
    _this.ellipsoid = new Vector3(0.5, 1, 0.5);
    _this.ellipsoidOffset = new Vector3(0, 0, 0);
    _this.checkCollisions = false;
    _this.applyGravity = false;
    _this._needMoveForGravity = false;
    _this._oldPosition = Vector3.Zero();
    _this._diffPosition = Vector3.Zero();
    _this._newPosition = Vector3.Zero();
    _this._collisionMask = -1;
    _this._onCollisionPositionChange = function(collisionId, newPosition, collidedMesh) {
      if (collidedMesh === void 0) {
        collidedMesh = null;
      }
      var updatePosition = function(newPos) {
        _this._newPosition.copyFrom(newPos);
        _this._newPosition.subtractToRef(_this._oldPosition, _this._diffPosition);
        if (_this._diffPosition.length() > Engine.CollisionsEpsilon) {
          _this.position.addInPlace(_this._diffPosition);
          if (_this.onCollide && collidedMesh) {
            _this.onCollide(collidedMesh);
          }
        }
      };
      updatePosition(newPosition);
    };
    _this.inputs = new FreeCameraInputsManager(_this);
    _this.inputs.addKeyboard().addMouse();
    return _this;
  }
  Object.defineProperty(FreeCamera2.prototype, "angularSensibility", {
    get: function() {
      var mouse = this.inputs.attached["mouse"];
      if (mouse) {
        return mouse.angularSensibility;
      }
      return 0;
    },
    set: function(value) {
      var mouse = this.inputs.attached["mouse"];
      if (mouse) {
        mouse.angularSensibility = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FreeCamera2.prototype, "keysUp", {
    get: function() {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        return keyboard.keysUp;
      }
      return [];
    },
    set: function(value) {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        keyboard.keysUp = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FreeCamera2.prototype, "keysUpward", {
    get: function() {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        return keyboard.keysUpward;
      }
      return [];
    },
    set: function(value) {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        keyboard.keysUpward = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FreeCamera2.prototype, "keysDown", {
    get: function() {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        return keyboard.keysDown;
      }
      return [];
    },
    set: function(value) {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        keyboard.keysDown = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FreeCamera2.prototype, "keysDownward", {
    get: function() {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        return keyboard.keysDownward;
      }
      return [];
    },
    set: function(value) {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        keyboard.keysDownward = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FreeCamera2.prototype, "keysLeft", {
    get: function() {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        return keyboard.keysLeft;
      }
      return [];
    },
    set: function(value) {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        keyboard.keysLeft = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FreeCamera2.prototype, "keysRight", {
    get: function() {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        return keyboard.keysRight;
      }
      return [];
    },
    set: function(value) {
      var keyboard = this.inputs.attached["keyboard"];
      if (keyboard) {
        keyboard.keysRight = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  FreeCamera2.prototype.attachControl = function(ignored, noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    this.inputs.attachElement(noPreventDefault);
  };
  FreeCamera2.prototype.detachControl = function(ignored) {
    this.inputs.detachElement();
    this.cameraDirection = new Vector3(0, 0, 0);
    this.cameraRotation = new Vector2(0, 0);
  };
  Object.defineProperty(FreeCamera2.prototype, "collisionMask", {
    get: function() {
      return this._collisionMask;
    },
    set: function(mask) {
      this._collisionMask = !isNaN(mask) ? mask : -1;
    },
    enumerable: false,
    configurable: true
  });
  FreeCamera2.prototype._collideWithWorld = function(displacement) {
    var globalPosition;
    if (this.parent) {
      globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());
    } else {
      globalPosition = this.position;
    }
    globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);
    this._oldPosition.addInPlace(this.ellipsoidOffset);
    var coordinator = this.getScene().collisionCoordinator;
    if (!this._collider) {
      this._collider = coordinator.createCollider();
    }
    this._collider._radius = this.ellipsoid;
    this._collider.collisionMask = this._collisionMask;
    var actualDisplacement = displacement;
    if (this.applyGravity) {
      actualDisplacement = displacement.add(this.getScene().gravity);
    }
    coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);
  };
  FreeCamera2.prototype._checkInputs = function() {
    if (!this._localDirection) {
      this._localDirection = Vector3.Zero();
      this._transformedDirection = Vector3.Zero();
    }
    this.inputs.checkInputs();
    _super.prototype._checkInputs.call(this);
  };
  FreeCamera2.prototype._decideIfNeedsToMove = function() {
    return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;
  };
  FreeCamera2.prototype._updatePosition = function() {
    if (this.checkCollisions && this.getScene().collisionsEnabled) {
      this._collideWithWorld(this.cameraDirection);
    } else {
      _super.prototype._updatePosition.call(this);
    }
  };
  FreeCamera2.prototype.dispose = function() {
    this.inputs.clear();
    _super.prototype.dispose.call(this);
  };
  FreeCamera2.prototype.getClassName = function() {
    return "FreeCamera";
  };
  __decorate([
    serializeAsVector3()
  ], FreeCamera2.prototype, "ellipsoid", void 0);
  __decorate([
    serializeAsVector3()
  ], FreeCamera2.prototype, "ellipsoidOffset", void 0);
  __decorate([
    serialize()
  ], FreeCamera2.prototype, "checkCollisions", void 0);
  __decorate([
    serialize()
  ], FreeCamera2.prototype, "applyGravity", void 0);
  return FreeCamera2;
}(TargetCamera);

// node_modules/@babylonjs/core/Shaders/postprocess.vertex.js
var name = "postprocessVertexShader";
var shader = "\nattribute vec2 position;\nuniform vec2 scale;\n\nvarying vec2 vUV;\nconst vec2 madd=vec2(0.5,0.5);\nvoid main(void) {\nvUV=(position*madd+madd)*scale;\ngl_Position=vec4(position,0.0,1.0);\n}";
Effect.ShadersStore[name] = shader;

// node_modules/@babylonjs/core/Engines/Extensions/engine.renderTarget.js
ThinEngine.prototype.createRenderTargetTexture = function(size, options) {
  var fullOptions = new RenderTargetCreationOptions();
  if (options !== void 0 && typeof options === "object") {
    fullOptions.generateMipMaps = options.generateMipMaps;
    fullOptions.generateDepthBuffer = !!options.generateDepthBuffer;
    fullOptions.generateStencilBuffer = !!options.generateStencilBuffer;
    fullOptions.type = options.type === void 0 ? 0 : options.type;
    fullOptions.samplingMode = options.samplingMode === void 0 ? 3 : options.samplingMode;
    fullOptions.format = options.format === void 0 ? 5 : options.format;
  } else {
    fullOptions.generateMipMaps = options;
    fullOptions.generateDepthBuffer = true;
    fullOptions.generateStencilBuffer = false;
    fullOptions.type = 0;
    fullOptions.samplingMode = 3;
    fullOptions.format = 5;
  }
  if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {
    fullOptions.samplingMode = 1;
  } else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {
    fullOptions.samplingMode = 1;
  }
  if (fullOptions.type === 1 && !this._caps.textureFloat) {
    fullOptions.type = 0;
    Logger.Warn("Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type");
  }
  var gl = this._gl;
  var texture = new InternalTexture(this, InternalTextureSource.RenderTarget);
  var width = size.width || size;
  var height = size.height || size;
  var layers = size.layers || 0;
  var filters = this._getSamplingParameters(fullOptions.samplingMode, fullOptions.generateMipMaps ? true : false);
  var target = layers !== 0 ? gl.TEXTURE_2D_ARRAY : gl.TEXTURE_2D;
  var sizedFormat = this._getRGBABufferInternalSizedFormat(fullOptions.type, fullOptions.format);
  var internalFormat = this._getInternalFormat(fullOptions.format);
  var type = this._getWebGLTextureType(fullOptions.type);
  this._bindTextureDirectly(target, texture);
  if (layers !== 0) {
    texture.is2DArray = true;
    gl.texImage3D(target, 0, sizedFormat, width, height, layers, 0, internalFormat, type, null);
  } else {
    gl.texImage2D(target, 0, sizedFormat, width, height, 0, internalFormat, type, null);
  }
  gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, filters.mag);
  gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, filters.min);
  gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  if (fullOptions.generateMipMaps) {
    this._gl.generateMipmap(target);
  }
  this._bindTextureDirectly(target, null);
  var currentFrameBuffer = this._currentFramebuffer;
  var framebuffer = gl.createFramebuffer();
  this._bindUnboundFramebuffer(framebuffer);
  texture._depthStencilBuffer = this._setupFramebufferDepthAttachments(fullOptions.generateStencilBuffer ? true : false, fullOptions.generateDepthBuffer, width, height);
  if (!texture.is2DArray) {
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture._webGLTexture, 0);
  }
  this._bindUnboundFramebuffer(currentFrameBuffer);
  texture._framebuffer = framebuffer;
  texture.baseWidth = width;
  texture.baseHeight = height;
  texture.width = width;
  texture.height = height;
  texture.depth = layers;
  texture.isReady = true;
  texture.samples = 1;
  texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;
  texture.samplingMode = fullOptions.samplingMode;
  texture.type = fullOptions.type;
  texture.format = fullOptions.format;
  texture._generateDepthBuffer = fullOptions.generateDepthBuffer;
  texture._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;
  this._internalTexturesCache.push(texture);
  return texture;
};
ThinEngine.prototype.createDepthStencilTexture = function(size, options) {
  if (options.isCube) {
    var width = size.width || size;
    return this._createDepthStencilCubeTexture(width, options);
  } else {
    return this._createDepthStencilTexture(size, options);
  }
};
ThinEngine.prototype._createDepthStencilTexture = function(size, options) {
  var gl = this._gl;
  var layers = size.layers || 0;
  var target = layers !== 0 ? gl.TEXTURE_2D_ARRAY : gl.TEXTURE_2D;
  var internalTexture = new InternalTexture(this, InternalTextureSource.Depth);
  if (!this._caps.depthTextureExtension) {
    Logger.Error("Depth texture is not supported by your browser or hardware.");
    return internalTexture;
  }
  var internalOptions = __assign({ bilinearFiltering: false, comparisonFunction: 0, generateStencil: false }, options);
  this._bindTextureDirectly(target, internalTexture, true);
  this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.bilinearFiltering, internalOptions.comparisonFunction);
  var type = internalOptions.generateStencil ? gl.UNSIGNED_INT_24_8 : gl.UNSIGNED_INT;
  var internalFormat = internalOptions.generateStencil ? gl.DEPTH_STENCIL : gl.DEPTH_COMPONENT;
  var sizedFormat = internalFormat;
  if (this.webGLVersion > 1) {
    sizedFormat = internalOptions.generateStencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
  }
  if (internalTexture.is2DArray) {
    gl.texImage3D(target, 0, sizedFormat, internalTexture.width, internalTexture.height, layers, 0, internalFormat, type, null);
  } else {
    gl.texImage2D(target, 0, sizedFormat, internalTexture.width, internalTexture.height, 0, internalFormat, type, null);
  }
  this._bindTextureDirectly(target, null);
  return internalTexture;
};

// node_modules/@babylonjs/core/PostProcesses/postProcess.js
var PostProcess = function() {
  function PostProcess2(name42, fragmentUrl, parameters, samplers, options, camera, samplingMode, engine, reusable, defines, textureType, vertexUrl, indexParameters, blockCompilation, textureFormat) {
    if (samplingMode === void 0) {
      samplingMode = 1;
    }
    if (defines === void 0) {
      defines = null;
    }
    if (textureType === void 0) {
      textureType = 0;
    }
    if (vertexUrl === void 0) {
      vertexUrl = "postprocess";
    }
    if (blockCompilation === void 0) {
      blockCompilation = false;
    }
    if (textureFormat === void 0) {
      textureFormat = 5;
    }
    this.width = -1;
    this.height = -1;
    this.nodeMaterialSource = null;
    this._outputTexture = null;
    this.autoClear = true;
    this.alphaMode = 0;
    this.animations = new Array();
    this.enablePixelPerfectMode = false;
    this.forceFullscreenViewport = true;
    this.scaleMode = 1;
    this.alwaysForcePOT = false;
    this._samples = 1;
    this.adaptScaleToCurrentViewport = false;
    this._reusable = false;
    this._textures = new SmartArray(2);
    this._currentRenderTextureInd = 0;
    this._scaleRatio = new Vector2(1, 1);
    this._texelSize = Vector2.Zero();
    this.onActivateObservable = new Observable();
    this.onSizeChangedObservable = new Observable();
    this.onApplyObservable = new Observable();
    this.onBeforeRenderObservable = new Observable();
    this.onAfterRenderObservable = new Observable();
    this.name = name42;
    if (camera != null) {
      this._camera = camera;
      this._scene = camera.getScene();
      camera.attachPostProcess(this);
      this._engine = this._scene.getEngine();
      this._scene.postProcesses.push(this);
      this.uniqueId = this._scene.getUniqueId();
    } else if (engine) {
      this._engine = engine;
      this._engine.postProcesses.push(this);
    }
    this._options = options;
    this.renderTargetSamplingMode = samplingMode ? samplingMode : 1;
    this._reusable = reusable || false;
    this._textureType = textureType;
    this._textureFormat = textureFormat;
    this._samplers = samplers || [];
    this._samplers.push("textureSampler");
    this._fragmentUrl = fragmentUrl;
    this._vertexUrl = vertexUrl;
    this._parameters = parameters || [];
    this._parameters.push("scale");
    this._indexParameters = indexParameters;
    if (!blockCompilation) {
      this.updateEffect(defines);
    }
  }
  Object.defineProperty(PostProcess2.prototype, "samples", {
    get: function() {
      return this._samples;
    },
    set: function(n) {
      var _this = this;
      this._samples = Math.min(n, this._engine.getCaps().maxMSAASamples);
      this._textures.forEach(function(texture) {
        if (texture.samples !== _this._samples) {
          _this._engine.updateRenderTargetTextureSampleCount(texture, _this._samples);
        }
      });
    },
    enumerable: false,
    configurable: true
  });
  PostProcess2.prototype.getEffectName = function() {
    return this._fragmentUrl;
  };
  Object.defineProperty(PostProcess2.prototype, "onActivate", {
    set: function(callback) {
      if (this._onActivateObserver) {
        this.onActivateObservable.remove(this._onActivateObserver);
      }
      if (callback) {
        this._onActivateObserver = this.onActivateObservable.add(callback);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PostProcess2.prototype, "onSizeChanged", {
    set: function(callback) {
      if (this._onSizeChangedObserver) {
        this.onSizeChangedObservable.remove(this._onSizeChangedObserver);
      }
      this._onSizeChangedObserver = this.onSizeChangedObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PostProcess2.prototype, "onApply", {
    set: function(callback) {
      if (this._onApplyObserver) {
        this.onApplyObservable.remove(this._onApplyObserver);
      }
      this._onApplyObserver = this.onApplyObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PostProcess2.prototype, "onBeforeRender", {
    set: function(callback) {
      if (this._onBeforeRenderObserver) {
        this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
      }
      this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PostProcess2.prototype, "onAfterRender", {
    set: function(callback) {
      if (this._onAfterRenderObserver) {
        this.onAfterRenderObservable.remove(this._onAfterRenderObserver);
      }
      this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PostProcess2.prototype, "inputTexture", {
    get: function() {
      return this._textures.data[this._currentRenderTextureInd];
    },
    set: function(value) {
      this._forcedOutputTexture = value;
    },
    enumerable: false,
    configurable: true
  });
  PostProcess2.prototype.restoreDefaultInputTexture = function() {
    this._forcedOutputTexture = null;
  };
  PostProcess2.prototype.getCamera = function() {
    return this._camera;
  };
  Object.defineProperty(PostProcess2.prototype, "texelSize", {
    get: function() {
      if (this._shareOutputWithPostProcess) {
        return this._shareOutputWithPostProcess.texelSize;
      }
      if (this._forcedOutputTexture) {
        this._texelSize.copyFromFloats(1 / this._forcedOutputTexture.width, 1 / this._forcedOutputTexture.height);
      }
      return this._texelSize;
    },
    enumerable: false,
    configurable: true
  });
  PostProcess2.prototype.getClassName = function() {
    return "PostProcess";
  };
  PostProcess2.prototype.getEngine = function() {
    return this._engine;
  };
  PostProcess2.prototype.getEffect = function() {
    return this._effect;
  };
  PostProcess2.prototype.shareOutputWith = function(postProcess) {
    this._disposeTextures();
    this._shareOutputWithPostProcess = postProcess;
    return this;
  };
  PostProcess2.prototype.useOwnOutput = function() {
    if (this._textures.length == 0) {
      this._textures = new SmartArray(2);
    }
    this._shareOutputWithPostProcess = null;
  };
  PostProcess2.prototype.updateEffect = function(defines, uniforms, samplers, indexParameters, onCompiled, onError, vertexUrl, fragmentUrl) {
    if (defines === void 0) {
      defines = null;
    }
    if (uniforms === void 0) {
      uniforms = null;
    }
    if (samplers === void 0) {
      samplers = null;
    }
    this._effect = this._engine.createEffect({ vertex: vertexUrl !== null && vertexUrl !== void 0 ? vertexUrl : this._vertexUrl, fragment: fragmentUrl !== null && fragmentUrl !== void 0 ? fragmentUrl : this._fragmentUrl }, ["position"], uniforms || this._parameters, samplers || this._samplers, defines !== null ? defines : "", void 0, onCompiled, onError, indexParameters || this._indexParameters);
  };
  PostProcess2.prototype.isReusable = function() {
    return this._reusable;
  };
  PostProcess2.prototype.markTextureDirty = function() {
    this.width = -1;
  };
  PostProcess2.prototype.activate = function(camera, sourceTexture, forceDepthStencil) {
    var _this = this;
    if (sourceTexture === void 0) {
      sourceTexture = null;
    }
    camera = camera || this._camera;
    var scene = camera.getScene();
    var engine = scene.getEngine();
    var maxSize = engine.getCaps().maxTextureSize;
    var requiredWidth = (sourceTexture ? sourceTexture.width : this._engine.getRenderWidth(true)) * this._options | 0;
    var requiredHeight = (sourceTexture ? sourceTexture.height : this._engine.getRenderHeight(true)) * this._options | 0;
    var webVRCamera = camera.parent;
    if (webVRCamera && (webVRCamera.leftCamera == camera || webVRCamera.rightCamera == camera)) {
      requiredWidth /= 2;
    }
    var desiredWidth = this._options.width || requiredWidth;
    var desiredHeight = this._options.height || requiredHeight;
    var needMipMaps = this.renderTargetSamplingMode !== 7 && this.renderTargetSamplingMode !== 1 && this.renderTargetSamplingMode !== 2;
    if (!this._shareOutputWithPostProcess && !this._forcedOutputTexture) {
      if (this.adaptScaleToCurrentViewport) {
        var currentViewport = engine.currentViewport;
        if (currentViewport) {
          desiredWidth *= currentViewport.width;
          desiredHeight *= currentViewport.height;
        }
      }
      if (needMipMaps || this.alwaysForcePOT) {
        if (!this._options.width) {
          desiredWidth = engine.needPOTTextures ? Engine.GetExponentOfTwo(desiredWidth, maxSize, this.scaleMode) : desiredWidth;
        }
        if (!this._options.height) {
          desiredHeight = engine.needPOTTextures ? Engine.GetExponentOfTwo(desiredHeight, maxSize, this.scaleMode) : desiredHeight;
        }
      }
      if (this.width !== desiredWidth || this.height !== desiredHeight) {
        if (this._textures.length > 0) {
          for (var i = 0; i < this._textures.length; i++) {
            this._engine._releaseTexture(this._textures.data[i]);
          }
          this._textures.reset();
        }
        this.width = desiredWidth;
        this.height = desiredHeight;
        var textureSize = { width: this.width, height: this.height };
        var textureOptions = {
          generateMipMaps: needMipMaps,
          generateDepthBuffer: forceDepthStencil || camera._postProcesses.indexOf(this) === 0,
          generateStencilBuffer: (forceDepthStencil || camera._postProcesses.indexOf(this) === 0) && this._engine.isStencilEnable,
          samplingMode: this.renderTargetSamplingMode,
          type: this._textureType,
          format: this._textureFormat
        };
        this._textures.push(this._engine.createRenderTargetTexture(textureSize, textureOptions));
        if (this._reusable) {
          this._textures.push(this._engine.createRenderTargetTexture(textureSize, textureOptions));
        }
        this._texelSize.copyFromFloats(1 / this.width, 1 / this.height);
        this.onSizeChangedObservable.notifyObservers(this);
      }
      this._textures.forEach(function(texture) {
        if (texture.samples !== _this.samples) {
          _this._engine.updateRenderTargetTextureSampleCount(texture, _this.samples);
        }
      });
    }
    var target;
    if (this._shareOutputWithPostProcess) {
      target = this._shareOutputWithPostProcess.inputTexture;
    } else if (this._forcedOutputTexture) {
      target = this._forcedOutputTexture;
      this.width = this._forcedOutputTexture.width;
      this.height = this._forcedOutputTexture.height;
    } else {
      target = this.inputTexture;
    }
    if (this.enablePixelPerfectMode) {
      this._scaleRatio.copyFromFloats(requiredWidth / desiredWidth, requiredHeight / desiredHeight);
      this._engine.bindFramebuffer(target, 0, requiredWidth, requiredHeight, this.forceFullscreenViewport);
    } else {
      this._scaleRatio.copyFromFloats(1, 1);
      this._engine.bindFramebuffer(target, 0, void 0, void 0, this.forceFullscreenViewport);
    }
    this.onActivateObservable.notifyObservers(camera);
    if (this.autoClear && this.alphaMode === 0) {
      this._engine.clear(this.clearColor ? this.clearColor : scene.clearColor, scene._allowPostProcessClearColor, true, true);
    }
    if (this._reusable) {
      this._currentRenderTextureInd = (this._currentRenderTextureInd + 1) % 2;
    }
    return target;
  };
  Object.defineProperty(PostProcess2.prototype, "isSupported", {
    get: function() {
      return this._effect.isSupported;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PostProcess2.prototype, "aspectRatio", {
    get: function() {
      if (this._shareOutputWithPostProcess) {
        return this._shareOutputWithPostProcess.aspectRatio;
      }
      if (this._forcedOutputTexture) {
        return this._forcedOutputTexture.width / this._forcedOutputTexture.height;
      }
      return this.width / this.height;
    },
    enumerable: false,
    configurable: true
  });
  PostProcess2.prototype.isReady = function() {
    return this._effect && this._effect.isReady();
  };
  PostProcess2.prototype.apply = function() {
    if (!this._effect || !this._effect.isReady()) {
      return null;
    }
    this._engine.enableEffect(this._effect);
    this._engine.setState(false);
    this._engine.setDepthBuffer(false);
    this._engine.setDepthWrite(false);
    this._engine.setAlphaMode(this.alphaMode);
    if (this.alphaConstants) {
      this.getEngine().setAlphaConstants(this.alphaConstants.r, this.alphaConstants.g, this.alphaConstants.b, this.alphaConstants.a);
    }
    var source;
    if (this._shareOutputWithPostProcess) {
      source = this._shareOutputWithPostProcess.inputTexture;
    } else if (this._forcedOutputTexture) {
      source = this._forcedOutputTexture;
    } else {
      source = this.inputTexture;
    }
    this._effect._bindTexture("textureSampler", source);
    this._effect.setVector2("scale", this._scaleRatio);
    this.onApplyObservable.notifyObservers(this._effect);
    return this._effect;
  };
  PostProcess2.prototype._disposeTextures = function() {
    if (this._shareOutputWithPostProcess || this._forcedOutputTexture) {
      return;
    }
    if (this._textures.length > 0) {
      for (var i = 0; i < this._textures.length; i++) {
        this._engine._releaseTexture(this._textures.data[i]);
      }
    }
    this._textures.dispose();
  };
  PostProcess2.prototype.setPrePassRenderer = function(prePassRenderer) {
    if (this._prePassEffectConfiguration) {
      this._prePassEffectConfiguration = prePassRenderer.addEffectConfiguration(this._prePassEffectConfiguration);
      this._prePassEffectConfiguration.enabled = true;
      return true;
    }
    return false;
  };
  PostProcess2.prototype.dispose = function(camera) {
    camera = camera || this._camera;
    this._disposeTextures();
    var index;
    if (this._scene) {
      index = this._scene.postProcesses.indexOf(this);
      if (index !== -1) {
        this._scene.postProcesses.splice(index, 1);
      }
    }
    index = this._engine.postProcesses.indexOf(this);
    if (index !== -1) {
      this._engine.postProcesses.splice(index, 1);
    }
    if (!camera) {
      return;
    }
    camera.detachPostProcess(this);
    index = camera._postProcesses.indexOf(this);
    if (index === 0 && camera._postProcesses.length > 0) {
      var firstPostProcess = this._camera._getFirstPostProcess();
      if (firstPostProcess) {
        firstPostProcess.markTextureDirty();
      }
    }
    this.onActivateObservable.clear();
    this.onAfterRenderObservable.clear();
    this.onApplyObservable.clear();
    this.onBeforeRenderObservable.clear();
    this.onSizeChangedObservable.clear();
  };
  PostProcess2.prototype.serialize = function() {
    var serializationObject = SerializationHelper.Serialize(this);
    serializationObject.customType = "BABYLON." + this.getClassName();
    serializationObject.cameraId = this.getCamera().id;
    serializationObject.reusable = this._reusable;
    serializationObject.options = this._options;
    serializationObject.textureType = this._textureType;
    return serializationObject;
  };
  PostProcess2.Parse = function(parsedPostProcess, scene, rootUrl) {
    var postProcessType = _TypeStore.GetClass(parsedPostProcess.customType);
    if (!postProcessType || !postProcessType._Parse) {
      return null;
    }
    var camera = scene.getCameraByID(parsedPostProcess.cameraId);
    if (!camera) {
      return null;
    }
    return postProcessType._Parse(parsedPostProcess, camera, scene, rootUrl);
  };
  __decorate([
    serialize()
  ], PostProcess2.prototype, "uniqueId", void 0);
  __decorate([
    serialize()
  ], PostProcess2.prototype, "name", void 0);
  __decorate([
    serialize()
  ], PostProcess2.prototype, "width", void 0);
  __decorate([
    serialize()
  ], PostProcess2.prototype, "height", void 0);
  __decorate([
    serialize()
  ], PostProcess2.prototype, "renderTargetSamplingMode", void 0);
  __decorate([
    serializeAsColor4()
  ], PostProcess2.prototype, "clearColor", void 0);
  __decorate([
    serialize()
  ], PostProcess2.prototype, "autoClear", void 0);
  __decorate([
    serialize()
  ], PostProcess2.prototype, "alphaMode", void 0);
  __decorate([
    serialize()
  ], PostProcess2.prototype, "alphaConstants", void 0);
  __decorate([
    serialize()
  ], PostProcess2.prototype, "enablePixelPerfectMode", void 0);
  __decorate([
    serialize()
  ], PostProcess2.prototype, "forceFullscreenViewport", void 0);
  __decorate([
    serialize()
  ], PostProcess2.prototype, "scaleMode", void 0);
  __decorate([
    serialize()
  ], PostProcess2.prototype, "alwaysForcePOT", void 0);
  __decorate([
    serialize("samples")
  ], PostProcess2.prototype, "_samples", void 0);
  __decorate([
    serialize()
  ], PostProcess2.prototype, "adaptScaleToCurrentViewport", void 0);
  return PostProcess2;
}();
_TypeStore.RegisteredTypes["BABYLON.PostProcess"] = PostProcess;

// node_modules/@babylonjs/core/Engines/Extensions/engine.renderTargetCube.js
ThinEngine.prototype.createRenderTargetCubeTexture = function(size, options) {
  var fullOptions = __assign({ generateMipMaps: true, generateDepthBuffer: true, generateStencilBuffer: false, type: 0, samplingMode: 3, format: 5 }, options);
  fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && fullOptions.generateStencilBuffer;
  if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {
    fullOptions.samplingMode = 1;
  } else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {
    fullOptions.samplingMode = 1;
  }
  var gl = this._gl;
  var texture = new InternalTexture(this, InternalTextureSource.RenderTarget);
  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
  var filters = this._getSamplingParameters(fullOptions.samplingMode, fullOptions.generateMipMaps);
  if (fullOptions.type === 1 && !this._caps.textureFloat) {
    fullOptions.type = 0;
    Logger.Warn("Float textures are not supported. Cube render target forced to TEXTURETYPE_UNESIGNED_BYTE type");
  }
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  for (var face = 0; face < 6; face++) {
    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, this._getRGBABufferInternalSizedFormat(fullOptions.type, fullOptions.format), size, size, 0, this._getInternalFormat(fullOptions.format), this._getWebGLTextureType(fullOptions.type), null);
  }
  var framebuffer = gl.createFramebuffer();
  this._bindUnboundFramebuffer(framebuffer);
  texture._depthStencilBuffer = this._setupFramebufferDepthAttachments(fullOptions.generateStencilBuffer, fullOptions.generateDepthBuffer, size, size);
  if (fullOptions.generateMipMaps) {
    gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
  }
  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
  this._bindUnboundFramebuffer(null);
  texture._framebuffer = framebuffer;
  texture.width = size;
  texture.height = size;
  texture.isReady = true;
  texture.isCube = true;
  texture.samples = 1;
  texture.generateMipMaps = fullOptions.generateMipMaps;
  texture.samplingMode = fullOptions.samplingMode;
  texture.type = fullOptions.type;
  texture.format = fullOptions.format;
  texture._generateDepthBuffer = fullOptions.generateDepthBuffer;
  texture._generateStencilBuffer = fullOptions.generateStencilBuffer;
  this._internalTexturesCache.push(texture);
  return texture;
};

// node_modules/@babylonjs/core/Materials/Textures/renderTargetTexture.js
var RenderTargetTexture = function(_super) {
  __extends(RenderTargetTexture2, _super);
  function RenderTargetTexture2(name42, size, scene, generateMipMaps, doNotChangeAspectRatio, type, isCube, samplingMode, generateDepthBuffer, generateStencilBuffer, isMulti, format, delayAllocation) {
    if (doNotChangeAspectRatio === void 0) {
      doNotChangeAspectRatio = true;
    }
    if (type === void 0) {
      type = 0;
    }
    if (isCube === void 0) {
      isCube = false;
    }
    if (samplingMode === void 0) {
      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;
    }
    if (generateDepthBuffer === void 0) {
      generateDepthBuffer = true;
    }
    if (generateStencilBuffer === void 0) {
      generateStencilBuffer = false;
    }
    if (isMulti === void 0) {
      isMulti = false;
    }
    if (format === void 0) {
      format = 5;
    }
    if (delayAllocation === void 0) {
      delayAllocation = false;
    }
    var _this = _super.call(this, null, scene, !generateMipMaps) || this;
    _this.renderParticles = true;
    _this.renderSprites = false;
    _this.ignoreCameraViewport = false;
    _this.onBeforeBindObservable = new Observable();
    _this.onAfterUnbindObservable = new Observable();
    _this.onBeforeRenderObservable = new Observable();
    _this.onAfterRenderObservable = new Observable();
    _this.onClearObservable = new Observable();
    _this.onResizeObservable = new Observable();
    _this._currentRefreshId = -1;
    _this._refreshRate = 1;
    _this._samples = 1;
    _this.boundingBoxPosition = Vector3.Zero();
    scene = _this.getScene();
    if (!scene) {
      return _this;
    }
    _this._coordinatesMode = Texture.PROJECTION_MODE;
    _this.renderList = new Array();
    _this.name = name42;
    _this.isRenderTarget = true;
    _this._initialSizeParameter = size;
    _this._processSizeParameter(size);
    _this._resizeObserver = _this.getScene().getEngine().onResizeObservable.add(function() {
    });
    _this._generateMipMaps = generateMipMaps ? true : false;
    _this._doNotChangeAspectRatio = doNotChangeAspectRatio;
    _this._renderingManager = new RenderingManager(scene);
    _this._renderingManager._useSceneAutoClearSetup = true;
    if (isMulti) {
      return _this;
    }
    _this._renderTargetOptions = {
      generateMipMaps,
      type,
      format,
      samplingMode,
      generateDepthBuffer,
      generateStencilBuffer
    };
    if (samplingMode === Texture.NEAREST_SAMPLINGMODE) {
      _this.wrapU = Texture.CLAMP_ADDRESSMODE;
      _this.wrapV = Texture.CLAMP_ADDRESSMODE;
    }
    if (!delayAllocation) {
      if (isCube) {
        _this._texture = scene.getEngine().createRenderTargetCubeTexture(_this.getRenderSize(), _this._renderTargetOptions);
        _this.coordinatesMode = Texture.INVCUBIC_MODE;
        _this._textureMatrix = Matrix.Identity();
      } else {
        _this._texture = scene.getEngine().createRenderTargetTexture(_this._size, _this._renderTargetOptions);
      }
    }
    return _this;
  }
  Object.defineProperty(RenderTargetTexture2.prototype, "renderList", {
    get: function() {
      return this._renderList;
    },
    set: function(value) {
      this._renderList = value;
      if (this._renderList) {
        this._hookArray(this._renderList);
      }
    },
    enumerable: false,
    configurable: true
  });
  RenderTargetTexture2.prototype._hookArray = function(array) {
    var _this = this;
    var oldPush = array.push;
    array.push = function() {
      var items = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        items[_i] = arguments[_i];
      }
      var wasEmpty = array.length === 0;
      var result = oldPush.apply(array, items);
      if (wasEmpty && _this.getScene()) {
        _this.getScene().meshes.forEach(function(mesh) {
          mesh._markSubMeshesAsLightDirty();
        });
      }
      return result;
    };
    var oldSplice = array.splice;
    array.splice = function(index, deleteCount) {
      var deleted = oldSplice.apply(array, [index, deleteCount]);
      if (array.length === 0) {
        _this.getScene().meshes.forEach(function(mesh) {
          mesh._markSubMeshesAsLightDirty();
        });
      }
      return deleted;
    };
  };
  Object.defineProperty(RenderTargetTexture2.prototype, "onAfterUnbind", {
    set: function(callback) {
      if (this._onAfterUnbindObserver) {
        this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);
      }
      this._onAfterUnbindObserver = this.onAfterUnbindObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTargetTexture2.prototype, "onBeforeRender", {
    set: function(callback) {
      if (this._onBeforeRenderObserver) {
        this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
      }
      this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTargetTexture2.prototype, "onAfterRender", {
    set: function(callback) {
      if (this._onAfterRenderObserver) {
        this.onAfterRenderObservable.remove(this._onAfterRenderObserver);
      }
      this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTargetTexture2.prototype, "onClear", {
    set: function(callback) {
      if (this._onClearObserver) {
        this.onClearObservable.remove(this._onClearObserver);
      }
      this._onClearObserver = this.onClearObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTargetTexture2.prototype, "renderTargetOptions", {
    get: function() {
      return this._renderTargetOptions;
    },
    enumerable: false,
    configurable: true
  });
  RenderTargetTexture2.prototype._onRatioRescale = function() {
    if (this._sizeRatio) {
      this.resize(this._initialSizeParameter);
    }
  };
  Object.defineProperty(RenderTargetTexture2.prototype, "boundingBoxSize", {
    get: function() {
      return this._boundingBoxSize;
    },
    set: function(value) {
      if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {
        return;
      }
      this._boundingBoxSize = value;
      var scene = this.getScene();
      if (scene) {
        scene.markAllMaterialsAsDirty(1);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTargetTexture2.prototype, "depthStencilTexture", {
    get: function() {
      var _a;
      return ((_a = this.getInternalTexture()) === null || _a === void 0 ? void 0 : _a._depthStencilTexture) || null;
    },
    enumerable: false,
    configurable: true
  });
  RenderTargetTexture2.prototype.createDepthStencilTexture = function(comparisonFunction, bilinearFiltering, generateStencil) {
    if (comparisonFunction === void 0) {
      comparisonFunction = 0;
    }
    if (bilinearFiltering === void 0) {
      bilinearFiltering = true;
    }
    if (generateStencil === void 0) {
      generateStencil = false;
    }
    var internalTexture = this.getInternalTexture();
    if (!this.getScene() || !internalTexture) {
      return;
    }
    var engine = this.getScene().getEngine();
    internalTexture._depthStencilTexture = engine.createDepthStencilTexture(this._size, {
      bilinearFiltering,
      comparisonFunction,
      generateStencil,
      isCube: this.isCube
    });
  };
  RenderTargetTexture2.prototype._processSizeParameter = function(size) {
    if (size.ratio) {
      this._sizeRatio = size.ratio;
      var engine = this._getEngine();
      this._size = {
        width: this._bestReflectionRenderTargetDimension(engine.getRenderWidth(), this._sizeRatio),
        height: this._bestReflectionRenderTargetDimension(engine.getRenderHeight(), this._sizeRatio)
      };
    } else {
      this._size = size;
    }
  };
  Object.defineProperty(RenderTargetTexture2.prototype, "samples", {
    get: function() {
      return this._samples;
    },
    set: function(value) {
      if (this._samples === value) {
        return;
      }
      var scene = this.getScene();
      if (!scene) {
        return;
      }
      this._samples = scene.getEngine().updateRenderTargetTextureSampleCount(this._texture, value);
    },
    enumerable: false,
    configurable: true
  });
  RenderTargetTexture2.prototype.resetRefreshCounter = function() {
    this._currentRefreshId = -1;
  };
  Object.defineProperty(RenderTargetTexture2.prototype, "refreshRate", {
    get: function() {
      return this._refreshRate;
    },
    set: function(value) {
      this._refreshRate = value;
      this.resetRefreshCounter();
    },
    enumerable: false,
    configurable: true
  });
  RenderTargetTexture2.prototype.addPostProcess = function(postProcess) {
    if (!this._postProcessManager) {
      var scene = this.getScene();
      if (!scene) {
        return;
      }
      this._postProcessManager = new PostProcessManager(scene);
      this._postProcesses = new Array();
    }
    this._postProcesses.push(postProcess);
    this._postProcesses[0].autoClear = false;
  };
  RenderTargetTexture2.prototype.clearPostProcesses = function(dispose) {
    if (dispose === void 0) {
      dispose = false;
    }
    if (!this._postProcesses) {
      return;
    }
    if (dispose) {
      for (var _i = 0, _a = this._postProcesses; _i < _a.length; _i++) {
        var postProcess = _a[_i];
        postProcess.dispose();
      }
    }
    this._postProcesses = [];
  };
  RenderTargetTexture2.prototype.removePostProcess = function(postProcess) {
    if (!this._postProcesses) {
      return;
    }
    var index = this._postProcesses.indexOf(postProcess);
    if (index === -1) {
      return;
    }
    this._postProcesses.splice(index, 1);
    if (this._postProcesses.length > 0) {
      this._postProcesses[0].autoClear = false;
    }
  };
  RenderTargetTexture2.prototype._shouldRender = function() {
    if (this._currentRefreshId === -1) {
      this._currentRefreshId = 1;
      return true;
    }
    if (this.refreshRate === this._currentRefreshId) {
      this._currentRefreshId = 1;
      return true;
    }
    this._currentRefreshId++;
    return false;
  };
  RenderTargetTexture2.prototype.getRenderSize = function() {
    return this.getRenderWidth();
  };
  RenderTargetTexture2.prototype.getRenderWidth = function() {
    if (this._size.width) {
      return this._size.width;
    }
    return this._size;
  };
  RenderTargetTexture2.prototype.getRenderHeight = function() {
    if (this._size.width) {
      return this._size.height;
    }
    return this._size;
  };
  RenderTargetTexture2.prototype.getRenderLayers = function() {
    var layers = this._size.layers;
    if (layers) {
      return layers;
    }
    return 0;
  };
  Object.defineProperty(RenderTargetTexture2.prototype, "canRescale", {
    get: function() {
      return true;
    },
    enumerable: false,
    configurable: true
  });
  RenderTargetTexture2.prototype.scale = function(ratio) {
    var newSize = Math.max(1, this.getRenderSize() * ratio);
    this.resize(newSize);
  };
  RenderTargetTexture2.prototype.getReflectionTextureMatrix = function() {
    if (this.isCube) {
      return this._textureMatrix;
    }
    return _super.prototype.getReflectionTextureMatrix.call(this);
  };
  RenderTargetTexture2.prototype.resize = function(size) {
    var wasCube = this.isCube;
    this.releaseInternalTexture();
    var scene = this.getScene();
    if (!scene) {
      return;
    }
    this._processSizeParameter(size);
    if (wasCube) {
      this._texture = scene.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions);
    } else {
      this._texture = scene.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions);
    }
    if (this.onResizeObservable.hasObservers()) {
      this.onResizeObservable.notifyObservers(this);
    }
  };
  RenderTargetTexture2.prototype.render = function(useCameraPostProcess, dumpForDebug) {
    if (useCameraPostProcess === void 0) {
      useCameraPostProcess = false;
    }
    if (dumpForDebug === void 0) {
      dumpForDebug = false;
    }
    var scene = this.getScene();
    if (!scene) {
      return;
    }
    var engine = scene.getEngine();
    if (this.useCameraPostProcesses !== void 0) {
      useCameraPostProcess = this.useCameraPostProcesses;
    }
    if (this._waitingRenderList) {
      this.renderList = [];
      for (var index = 0; index < this._waitingRenderList.length; index++) {
        var id = this._waitingRenderList[index];
        var mesh_1 = scene.getMeshByID(id);
        if (mesh_1) {
          this.renderList.push(mesh_1);
        }
      }
      this._waitingRenderList = void 0;
    }
    if (this.renderListPredicate) {
      if (this.renderList) {
        this.renderList.length = 0;
      } else {
        this.renderList = [];
      }
      var scene = this.getScene();
      if (!scene) {
        return;
      }
      var sceneMeshes = scene.meshes;
      for (var index = 0; index < sceneMeshes.length; index++) {
        var mesh = sceneMeshes[index];
        if (this.renderListPredicate(mesh)) {
          this.renderList.push(mesh);
        }
      }
    }
    this.onBeforeBindObservable.notifyObservers(this);
    var camera;
    if (this.activeCamera) {
      camera = this.activeCamera;
      engine.setViewport(this.activeCamera.viewport, this.getRenderWidth(), this.getRenderHeight());
      if (this.activeCamera !== scene.activeCamera) {
        scene.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(true));
      }
    } else {
      camera = scene.activeCamera;
      if (camera) {
        engine.setViewport(camera.viewport, this.getRenderWidth(), this.getRenderHeight());
      }
    }
    this._defaultRenderListPrepared = false;
    if (this.is2DArray) {
      for (var layer = 0; layer < this.getRenderLayers(); layer++) {
        this.renderToTarget(0, useCameraPostProcess, dumpForDebug, layer, camera);
        scene.incrementRenderId();
        scene.resetCachedMaterial();
      }
    } else if (this.isCube) {
      for (var face = 0; face < 6; face++) {
        this.renderToTarget(face, useCameraPostProcess, dumpForDebug, void 0, camera);
        scene.incrementRenderId();
        scene.resetCachedMaterial();
      }
    } else {
      this.renderToTarget(0, useCameraPostProcess, dumpForDebug, void 0, camera);
    }
    this.onAfterUnbindObservable.notifyObservers(this);
    if (scene.activeCamera) {
      if (scene.getEngine().scenes.length > 1 || this.activeCamera && this.activeCamera !== scene.activeCamera) {
        scene.setTransformMatrix(scene.activeCamera.getViewMatrix(), scene.activeCamera.getProjectionMatrix(true));
      }
      engine.setViewport(scene.activeCamera.viewport);
    }
    scene.resetCachedMaterial();
  };
  RenderTargetTexture2.prototype._bestReflectionRenderTargetDimension = function(renderDimension, scale) {
    var minimum = 128;
    var x = renderDimension * scale;
    var curved = Engine.NearestPOT(x + minimum * minimum / (minimum + x));
    return Math.min(Engine.FloorPOT(renderDimension), curved);
  };
  RenderTargetTexture2.prototype._prepareRenderingManager = function(currentRenderList, currentRenderListLength, camera, checkLayerMask) {
    var scene = this.getScene();
    if (!scene) {
      return;
    }
    this._renderingManager.reset();
    var sceneRenderId = scene.getRenderId();
    for (var meshIndex = 0; meshIndex < currentRenderListLength; meshIndex++) {
      var mesh = currentRenderList[meshIndex];
      if (mesh && !mesh.isBlocked) {
        if (this.customIsReadyFunction) {
          if (!this.customIsReadyFunction(mesh, this.refreshRate)) {
            this.resetRefreshCounter();
            continue;
          }
        } else if (!mesh.isReady(this.refreshRate === 0)) {
          this.resetRefreshCounter();
          continue;
        }
        if (!mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate && scene.activeCamera) {
          mesh._internalAbstractMeshDataInfo._currentLOD = scene.customLODSelector ? scene.customLODSelector(mesh, scene.activeCamera) : mesh.getLOD(scene.activeCamera);
          mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = true;
        }
        if (!mesh._internalAbstractMeshDataInfo._currentLOD) {
          continue;
        }
        var meshToRender = mesh._internalAbstractMeshDataInfo._currentLOD;
        meshToRender._preActivateForIntermediateRendering(sceneRenderId);
        var isMasked = void 0;
        if (checkLayerMask && camera) {
          isMasked = (mesh.layerMask & camera.layerMask) === 0;
        } else {
          isMasked = false;
        }
        if (mesh.isEnabled() && mesh.isVisible && mesh.subMeshes && !isMasked) {
          if (meshToRender !== mesh) {
            meshToRender._activate(sceneRenderId, true);
          }
          if (mesh._activate(sceneRenderId, true) && mesh.subMeshes.length) {
            if (!mesh.isAnInstance) {
              meshToRender._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = false;
            } else {
              if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {
                meshToRender = mesh;
              }
            }
            meshToRender._internalAbstractMeshDataInfo._isActiveIntermediate = true;
            for (var subIndex = 0; subIndex < meshToRender.subMeshes.length; subIndex++) {
              var subMesh = meshToRender.subMeshes[subIndex];
              this._renderingManager.dispatch(subMesh, meshToRender);
            }
          }
        }
      }
    }
    for (var particleIndex = 0; particleIndex < scene.particleSystems.length; particleIndex++) {
      var particleSystem = scene.particleSystems[particleIndex];
      var emitter = particleSystem.emitter;
      if (!particleSystem.isStarted() || !emitter || !emitter.position || !emitter.isEnabled()) {
        continue;
      }
      if (currentRenderList.indexOf(emitter) >= 0) {
        this._renderingManager.dispatchParticles(particleSystem);
      }
    }
  };
  RenderTargetTexture2.prototype._bindFrameBuffer = function(faceIndex, layer) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (layer === void 0) {
      layer = 0;
    }
    var scene = this.getScene();
    if (!scene) {
      return;
    }
    var engine = scene.getEngine();
    if (this._texture) {
      engine.bindFramebuffer(this._texture, this.isCube ? faceIndex : void 0, void 0, void 0, this.ignoreCameraViewport, 0, layer);
    }
  };
  RenderTargetTexture2.prototype.unbindFrameBuffer = function(engine, faceIndex) {
    var _this = this;
    if (!this._texture) {
      return;
    }
    engine.unBindFramebuffer(this._texture, this.isCube, function() {
      _this.onAfterRenderObservable.notifyObservers(faceIndex);
    });
  };
  RenderTargetTexture2.prototype.renderToTarget = function(faceIndex, useCameraPostProcess, dumpForDebug, layer, camera) {
    if (layer === void 0) {
      layer = 0;
    }
    if (camera === void 0) {
      camera = null;
    }
    var scene = this.getScene();
    if (!scene) {
      return;
    }
    var engine = scene.getEngine();
    if (!this._texture) {
      return;
    }
    if (this._postProcessManager) {
      this._postProcessManager._prepareFrame(this._texture, this._postProcesses);
    } else if (!useCameraPostProcess || !scene.postProcessManager._prepareFrame(this._texture)) {
      this._bindFrameBuffer(faceIndex, layer);
    }
    if (this.is2DArray) {
      this.onBeforeRenderObservable.notifyObservers(layer);
    } else {
      this.onBeforeRenderObservable.notifyObservers(faceIndex);
    }
    var currentRenderList = null;
    var defaultRenderList = this.renderList ? this.renderList : scene.getActiveMeshes().data;
    var defaultRenderListLength = this.renderList ? this.renderList.length : scene.getActiveMeshes().length;
    if (this.getCustomRenderList) {
      currentRenderList = this.getCustomRenderList(this.is2DArray ? layer : faceIndex, defaultRenderList, defaultRenderListLength);
    }
    if (!currentRenderList) {
      if (!this._defaultRenderListPrepared) {
        this._prepareRenderingManager(defaultRenderList, defaultRenderListLength, camera, !this.renderList);
        this._defaultRenderListPrepared = true;
      }
      currentRenderList = defaultRenderList;
    } else {
      this._prepareRenderingManager(currentRenderList, currentRenderList.length, camera, false);
    }
    if (this.onClearObservable.hasObservers()) {
      this.onClearObservable.notifyObservers(engine);
    } else {
      engine.clear(this.clearColor || scene.clearColor, true, true, true);
    }
    if (!this._doNotChangeAspectRatio) {
      scene.updateTransformMatrix(true);
    }
    for (var _i = 0, _a = scene._beforeRenderTargetDrawStage; _i < _a.length; _i++) {
      var step = _a[_i];
      step.action(this);
    }
    this._renderingManager.render(this.customRenderFunction, currentRenderList, this.renderParticles, this.renderSprites);
    for (var _b = 0, _c = scene._afterRenderTargetDrawStage; _b < _c.length; _b++) {
      var step = _c[_b];
      step.action(this);
    }
    if (this._postProcessManager) {
      this._postProcessManager._finalizeFrame(false, this._texture, faceIndex, this._postProcesses, this.ignoreCameraViewport);
    } else if (useCameraPostProcess) {
      scene.postProcessManager._finalizeFrame(false, this._texture, faceIndex);
    }
    if (!this._doNotChangeAspectRatio) {
      scene.updateTransformMatrix(true);
    }
    if (dumpForDebug) {
      Tools.DumpFramebuffer(this.getRenderWidth(), this.getRenderHeight(), engine);
    }
    if (!this.isCube || faceIndex === 5) {
      if (this.isCube) {
        if (faceIndex === 5) {
          engine.generateMipMapsForCubemap(this._texture);
        }
      }
      this.unbindFrameBuffer(engine, faceIndex);
    } else {
      this.onAfterRenderObservable.notifyObservers(faceIndex);
    }
  };
  RenderTargetTexture2.prototype.setRenderingOrder = function(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {
    if (opaqueSortCompareFn === void 0) {
      opaqueSortCompareFn = null;
    }
    if (alphaTestSortCompareFn === void 0) {
      alphaTestSortCompareFn = null;
    }
    if (transparentSortCompareFn === void 0) {
      transparentSortCompareFn = null;
    }
    this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);
  };
  RenderTargetTexture2.prototype.setRenderingAutoClearDepthStencil = function(renderingGroupId, autoClearDepthStencil) {
    this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);
    this._renderingManager._useSceneAutoClearSetup = false;
  };
  RenderTargetTexture2.prototype.clone = function() {
    var textureSize = this.getSize();
    var newTexture = new RenderTargetTexture2(this.name, textureSize, this.getScene(), this._renderTargetOptions.generateMipMaps, this._doNotChangeAspectRatio, this._renderTargetOptions.type, this.isCube, this._renderTargetOptions.samplingMode, this._renderTargetOptions.generateDepthBuffer, this._renderTargetOptions.generateStencilBuffer);
    newTexture.hasAlpha = this.hasAlpha;
    newTexture.level = this.level;
    newTexture.coordinatesMode = this.coordinatesMode;
    if (this.renderList) {
      newTexture.renderList = this.renderList.slice(0);
    }
    return newTexture;
  };
  RenderTargetTexture2.prototype.serialize = function() {
    if (!this.name) {
      return null;
    }
    var serializationObject = _super.prototype.serialize.call(this);
    serializationObject.renderTargetSize = this.getRenderSize();
    serializationObject.renderList = [];
    if (this.renderList) {
      for (var index = 0; index < this.renderList.length; index++) {
        serializationObject.renderList.push(this.renderList[index].id);
      }
    }
    return serializationObject;
  };
  RenderTargetTexture2.prototype.disposeFramebufferObjects = function() {
    var objBuffer = this.getInternalTexture();
    var scene = this.getScene();
    if (objBuffer && scene) {
      scene.getEngine()._releaseFramebufferObjects(objBuffer);
    }
  };
  RenderTargetTexture2.prototype.dispose = function() {
    this.onResizeObservable.clear();
    this.onClearObservable.clear();
    this.onAfterRenderObservable.clear();
    this.onAfterUnbindObservable.clear();
    this.onBeforeBindObservable.clear();
    this.onBeforeRenderObservable.clear();
    if (this._postProcessManager) {
      this._postProcessManager.dispose();
      this._postProcessManager = null;
    }
    this.clearPostProcesses(true);
    if (this._resizeObserver) {
      this.getScene().getEngine().onResizeObservable.remove(this._resizeObserver);
      this._resizeObserver = null;
    }
    this.renderList = null;
    var scene = this.getScene();
    if (!scene) {
      return;
    }
    var index = scene.customRenderTargets.indexOf(this);
    if (index >= 0) {
      scene.customRenderTargets.splice(index, 1);
    }
    for (var _i = 0, _a = scene.cameras; _i < _a.length; _i++) {
      var camera = _a[_i];
      index = camera.customRenderTargets.indexOf(this);
      if (index >= 0) {
        camera.customRenderTargets.splice(index, 1);
      }
    }
    if (this.depthStencilTexture) {
      this.getScene().getEngine()._releaseTexture(this.depthStencilTexture);
    }
    _super.prototype.dispose.call(this);
  };
  RenderTargetTexture2.prototype._rebuild = function() {
    if (this.refreshRate === RenderTargetTexture2.REFRESHRATE_RENDER_ONCE) {
      this.refreshRate = RenderTargetTexture2.REFRESHRATE_RENDER_ONCE;
    }
    if (this._postProcessManager) {
      this._postProcessManager._rebuild();
    }
  };
  RenderTargetTexture2.prototype.freeRenderingGroups = function() {
    if (this._renderingManager) {
      this._renderingManager.freeRenderingGroups();
    }
  };
  RenderTargetTexture2.prototype.getViewCount = function() {
    return 1;
  };
  RenderTargetTexture2.REFRESHRATE_RENDER_ONCE = 0;
  RenderTargetTexture2.REFRESHRATE_RENDER_ONEVERYFRAME = 1;
  RenderTargetTexture2.REFRESHRATE_RENDER_ONEVERYTWOFRAMES = 2;
  return RenderTargetTexture2;
}(Texture);
Texture._CreateRenderTargetTexture = function(name42, renderTargetSize, scene, generateMipMaps) {
  return new RenderTargetTexture(name42, renderTargetSize, scene, generateMipMaps);
};

// node_modules/@babylonjs/core/Materials/shaderMaterial.js
var onCreatedEffectParameters = { effect: null, subMesh: null };
var ShaderMaterial = function(_super) {
  __extends(ShaderMaterial2, _super);
  function ShaderMaterial2(name42, scene, shaderPath, options) {
    if (options === void 0) {
      options = {};
    }
    var _this = _super.call(this, name42, scene) || this;
    _this._textures = {};
    _this._textureArrays = {};
    _this._floats = {};
    _this._ints = {};
    _this._floatsArrays = {};
    _this._colors3 = {};
    _this._colors3Arrays = {};
    _this._colors4 = {};
    _this._colors4Arrays = {};
    _this._vectors2 = {};
    _this._vectors3 = {};
    _this._vectors4 = {};
    _this._matrices = {};
    _this._matrixArrays = {};
    _this._matrices3x3 = {};
    _this._matrices2x2 = {};
    _this._vectors2Arrays = {};
    _this._vectors3Arrays = {};
    _this._vectors4Arrays = {};
    _this._cachedWorldViewMatrix = new Matrix();
    _this._cachedWorldViewProjectionMatrix = new Matrix();
    _this._multiview = false;
    _this._shaderPath = shaderPath;
    _this._options = __assign({ needAlphaBlending: false, needAlphaTesting: false, attributes: ["position", "normal", "uv"], uniforms: ["worldViewProjection"], uniformBuffers: [], samplers: [], defines: [] }, options);
    return _this;
  }
  Object.defineProperty(ShaderMaterial2.prototype, "shaderPath", {
    get: function() {
      return this._shaderPath;
    },
    set: function(shaderPath) {
      this._shaderPath = shaderPath;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShaderMaterial2.prototype, "options", {
    get: function() {
      return this._options;
    },
    enumerable: false,
    configurable: true
  });
  ShaderMaterial2.prototype.getClassName = function() {
    return "ShaderMaterial";
  };
  ShaderMaterial2.prototype.needAlphaBlending = function() {
    return this.alpha < 1 || this._options.needAlphaBlending;
  };
  ShaderMaterial2.prototype.needAlphaTesting = function() {
    return this._options.needAlphaTesting;
  };
  ShaderMaterial2.prototype._checkUniform = function(uniformName) {
    if (this._options.uniforms.indexOf(uniformName) === -1) {
      this._options.uniforms.push(uniformName);
    }
  };
  ShaderMaterial2.prototype.setTexture = function(name42, texture) {
    if (this._options.samplers.indexOf(name42) === -1) {
      this._options.samplers.push(name42);
    }
    this._textures[name42] = texture;
    return this;
  };
  ShaderMaterial2.prototype.setTextureArray = function(name42, textures) {
    if (this._options.samplers.indexOf(name42) === -1) {
      this._options.samplers.push(name42);
    }
    this._checkUniform(name42);
    this._textureArrays[name42] = textures;
    return this;
  };
  ShaderMaterial2.prototype.setFloat = function(name42, value) {
    this._checkUniform(name42);
    this._floats[name42] = value;
    return this;
  };
  ShaderMaterial2.prototype.setInt = function(name42, value) {
    this._checkUniform(name42);
    this._ints[name42] = value;
    return this;
  };
  ShaderMaterial2.prototype.setFloats = function(name42, value) {
    this._checkUniform(name42);
    this._floatsArrays[name42] = value;
    return this;
  };
  ShaderMaterial2.prototype.setColor3 = function(name42, value) {
    this._checkUniform(name42);
    this._colors3[name42] = value;
    return this;
  };
  ShaderMaterial2.prototype.setColor3Array = function(name42, value) {
    this._checkUniform(name42);
    this._colors3Arrays[name42] = value.reduce(function(arr, color) {
      color.toArray(arr, arr.length);
      return arr;
    }, []);
    return this;
  };
  ShaderMaterial2.prototype.setColor4 = function(name42, value) {
    this._checkUniform(name42);
    this._colors4[name42] = value;
    return this;
  };
  ShaderMaterial2.prototype.setColor4Array = function(name42, value) {
    this._checkUniform(name42);
    this._colors4Arrays[name42] = value.reduce(function(arr, color) {
      color.toArray(arr, arr.length);
      return arr;
    }, []);
    return this;
  };
  ShaderMaterial2.prototype.setVector2 = function(name42, value) {
    this._checkUniform(name42);
    this._vectors2[name42] = value;
    return this;
  };
  ShaderMaterial2.prototype.setVector3 = function(name42, value) {
    this._checkUniform(name42);
    this._vectors3[name42] = value;
    return this;
  };
  ShaderMaterial2.prototype.setVector4 = function(name42, value) {
    this._checkUniform(name42);
    this._vectors4[name42] = value;
    return this;
  };
  ShaderMaterial2.prototype.setMatrix = function(name42, value) {
    this._checkUniform(name42);
    this._matrices[name42] = value;
    return this;
  };
  ShaderMaterial2.prototype.setMatrices = function(name42, value) {
    this._checkUniform(name42);
    var float32Array = new Float32Array(value.length * 16);
    for (var index = 0; index < value.length; index++) {
      var matrix = value[index];
      matrix.copyToArray(float32Array, index * 16);
    }
    this._matrixArrays[name42] = float32Array;
    return this;
  };
  ShaderMaterial2.prototype.setMatrix3x3 = function(name42, value) {
    this._checkUniform(name42);
    this._matrices3x3[name42] = value;
    return this;
  };
  ShaderMaterial2.prototype.setMatrix2x2 = function(name42, value) {
    this._checkUniform(name42);
    this._matrices2x2[name42] = value;
    return this;
  };
  ShaderMaterial2.prototype.setArray2 = function(name42, value) {
    this._checkUniform(name42);
    this._vectors2Arrays[name42] = value;
    return this;
  };
  ShaderMaterial2.prototype.setArray3 = function(name42, value) {
    this._checkUniform(name42);
    this._vectors3Arrays[name42] = value;
    return this;
  };
  ShaderMaterial2.prototype.setArray4 = function(name42, value) {
    this._checkUniform(name42);
    this._vectors4Arrays[name42] = value;
    return this;
  };
  ShaderMaterial2.prototype._checkCache = function(mesh, useInstances) {
    if (!mesh) {
      return true;
    }
    if (this._effect && this._effect.defines.indexOf("#define INSTANCES") !== -1 !== useInstances) {
      return false;
    }
    return true;
  };
  ShaderMaterial2.prototype.isReadyForSubMesh = function(mesh, subMesh, useInstances) {
    return this.isReady(mesh, useInstances);
  };
  ShaderMaterial2.prototype.isReady = function(mesh, useInstances) {
    var _a, _b;
    if (this._effect && this.isFrozen) {
      if (this._effect._wasPreviouslyReady) {
        return true;
      }
    }
    var scene = this.getScene();
    var engine = scene.getEngine();
    if (!this.checkReadyOnEveryCall) {
      if (this._renderId === scene.getRenderId()) {
        if (this._checkCache(mesh, useInstances)) {
          return true;
        }
      }
    }
    var defines = [];
    var attribs = [];
    var fallbacks = new EffectFallbacks();
    if (engine.getCaps().multiview && scene.activeCamera && scene.activeCamera.outputRenderTarget && scene.activeCamera.outputRenderTarget.getViewCount() > 1) {
      this._multiview = true;
      defines.push("#define MULTIVIEW");
      if (this._options.uniforms.indexOf("viewProjection") !== -1 && this._options.uniforms.push("viewProjectionR") === -1) {
        this._options.uniforms.push("viewProjectionR");
      }
    }
    for (var index = 0; index < this._options.defines.length; index++) {
      defines.push(this._options.defines[index]);
    }
    for (var index = 0; index < this._options.attributes.length; index++) {
      attribs.push(this._options.attributes[index]);
    }
    if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorKind)) {
      attribs.push(VertexBuffer.ColorKind);
      defines.push("#define VERTEXCOLOR");
    }
    if (useInstances) {
      defines.push("#define INSTANCES");
      MaterialHelper.PushAttributesForInstances(attribs);
      if (mesh === null || mesh === void 0 ? void 0 : mesh.hasThinInstances) {
        defines.push("#define THIN_INSTANCES");
      }
    }
    var numInfluencers = 0;
    if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
      attribs.push(VertexBuffer.MatricesIndicesKind);
      attribs.push(VertexBuffer.MatricesWeightsKind);
      if (mesh.numBoneInfluencers > 4) {
        attribs.push(VertexBuffer.MatricesIndicesExtraKind);
        attribs.push(VertexBuffer.MatricesWeightsExtraKind);
      }
      var skeleton = mesh.skeleton;
      numInfluencers = mesh.numBoneInfluencers;
      defines.push("#define NUM_BONE_INFLUENCERS " + numInfluencers);
      fallbacks.addCPUSkinningFallback(0, mesh);
      if (skeleton.isUsingTextureForMatrices) {
        defines.push("#define BONETEXTURE");
        if (this._options.uniforms.indexOf("boneTextureWidth") === -1) {
          this._options.uniforms.push("boneTextureWidth");
        }
        if (this._options.samplers.indexOf("boneSampler") === -1) {
          this._options.samplers.push("boneSampler");
        }
      } else {
        defines.push("#define BonesPerMesh " + (skeleton.bones.length + 1));
        if (this._options.uniforms.indexOf("mBones") === -1) {
          this._options.uniforms.push("mBones");
        }
      }
    } else {
      defines.push("#define NUM_BONE_INFLUENCERS 0");
    }
    for (var name42 in this._textures) {
      if (!this._textures[name42].isReady()) {
        return false;
      }
    }
    if (mesh && this._shouldTurnAlphaTestOn(mesh)) {
      defines.push("#define ALPHATEST");
    }
    var shaderName = this._shaderPath, uniforms = this._options.uniforms, uniformBuffers = this._options.uniformBuffers, samplers = this._options.samplers;
    if (this.customShaderNameResolve) {
      uniforms = uniforms.slice();
      uniformBuffers = uniformBuffers.slice();
      samplers = samplers.slice();
      shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs);
    }
    var previousEffect = this._effect;
    var join = defines.join("\n");
    if (this._cachedDefines !== join) {
      this._cachedDefines = join;
      this._effect = engine.createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousMorphTargets: numInfluencers }
      }, engine);
      if (this._onEffectCreatedObservable) {
        onCreatedEffectParameters.effect = this._effect;
        this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);
      }
    }
    if ((_b = !((_a = this._effect) === null || _a === void 0 ? void 0 : _a.isReady())) !== null && _b !== void 0 ? _b : true) {
      return false;
    }
    if (previousEffect !== this._effect) {
      scene.resetCachedMaterial();
    }
    this._renderId = scene.getRenderId();
    this._effect._wasPreviouslyReady = true;
    return true;
  };
  ShaderMaterial2.prototype.bindOnlyWorldMatrix = function(world, effectOverride) {
    var scene = this.getScene();
    var effect = effectOverride !== null && effectOverride !== void 0 ? effectOverride : this._effect;
    if (!effect) {
      return;
    }
    if (this._options.uniforms.indexOf("world") !== -1) {
      effect.setMatrix("world", world);
    }
    if (this._options.uniforms.indexOf("worldView") !== -1) {
      world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);
      effect.setMatrix("worldView", this._cachedWorldViewMatrix);
    }
    if (this._options.uniforms.indexOf("worldViewProjection") !== -1) {
      world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);
      effect.setMatrix("worldViewProjection", this._cachedWorldViewProjectionMatrix);
    }
  };
  ShaderMaterial2.prototype.bindForSubMesh = function(world, mesh, subMesh) {
    this.bind(world, mesh, subMesh._effectOverride);
  };
  ShaderMaterial2.prototype.bind = function(world, mesh, effectOverride) {
    this.bindOnlyWorldMatrix(world, effectOverride);
    var effect = effectOverride !== null && effectOverride !== void 0 ? effectOverride : this._effect;
    if (effect && this.getScene().getCachedMaterial() !== this) {
      if (this._options.uniforms.indexOf("view") !== -1) {
        effect.setMatrix("view", this.getScene().getViewMatrix());
      }
      if (this._options.uniforms.indexOf("projection") !== -1) {
        effect.setMatrix("projection", this.getScene().getProjectionMatrix());
      }
      if (this._options.uniforms.indexOf("viewProjection") !== -1) {
        effect.setMatrix("viewProjection", this.getScene().getTransformMatrix());
        if (this._multiview) {
          effect.setMatrix("viewProjectionR", this.getScene()._transformMatrixR);
        }
      }
      if (this.getScene().activeCamera && this._options.uniforms.indexOf("cameraPosition") !== -1) {
        effect.setVector3("cameraPosition", this.getScene().activeCamera.globalPosition);
      }
      MaterialHelper.BindBonesParameters(mesh, effect);
      var name42;
      for (name42 in this._textures) {
        effect.setTexture(name42, this._textures[name42]);
      }
      for (name42 in this._textureArrays) {
        effect.setTextureArray(name42, this._textureArrays[name42]);
      }
      for (name42 in this._ints) {
        effect.setInt(name42, this._ints[name42]);
      }
      for (name42 in this._floats) {
        effect.setFloat(name42, this._floats[name42]);
      }
      for (name42 in this._floatsArrays) {
        effect.setArray(name42, this._floatsArrays[name42]);
      }
      for (name42 in this._colors3) {
        effect.setColor3(name42, this._colors3[name42]);
      }
      for (name42 in this._colors3Arrays) {
        effect.setArray3(name42, this._colors3Arrays[name42]);
      }
      for (name42 in this._colors4) {
        var color = this._colors4[name42];
        effect.setFloat4(name42, color.r, color.g, color.b, color.a);
      }
      for (name42 in this._colors4Arrays) {
        effect.setArray4(name42, this._colors4Arrays[name42]);
      }
      for (name42 in this._vectors2) {
        effect.setVector2(name42, this._vectors2[name42]);
      }
      for (name42 in this._vectors3) {
        effect.setVector3(name42, this._vectors3[name42]);
      }
      for (name42 in this._vectors4) {
        effect.setVector4(name42, this._vectors4[name42]);
      }
      for (name42 in this._matrices) {
        effect.setMatrix(name42, this._matrices[name42]);
      }
      for (name42 in this._matrixArrays) {
        effect.setMatrices(name42, this._matrixArrays[name42]);
      }
      for (name42 in this._matrices3x3) {
        effect.setMatrix3x3(name42, this._matrices3x3[name42]);
      }
      for (name42 in this._matrices2x2) {
        effect.setMatrix2x2(name42, this._matrices2x2[name42]);
      }
      for (name42 in this._vectors2Arrays) {
        effect.setArray2(name42, this._vectors2Arrays[name42]);
      }
      for (name42 in this._vectors3Arrays) {
        effect.setArray3(name42, this._vectors3Arrays[name42]);
      }
      for (name42 in this._vectors4Arrays) {
        effect.setArray4(name42, this._vectors4Arrays[name42]);
      }
    }
    var seffect = this._effect;
    this._effect = effect;
    this._afterBind(mesh);
    this._effect = seffect;
  };
  ShaderMaterial2.prototype._afterBind = function(mesh) {
    _super.prototype._afterBind.call(this, mesh);
    this.getScene()._cachedEffect = this._effect;
  };
  ShaderMaterial2.prototype.getActiveTextures = function() {
    var activeTextures = _super.prototype.getActiveTextures.call(this);
    for (var name42 in this._textures) {
      activeTextures.push(this._textures[name42]);
    }
    for (var name42 in this._textureArrays) {
      var array = this._textureArrays[name42];
      for (var index = 0; index < array.length; index++) {
        activeTextures.push(array[index]);
      }
    }
    return activeTextures;
  };
  ShaderMaterial2.prototype.hasTexture = function(texture) {
    if (_super.prototype.hasTexture.call(this, texture)) {
      return true;
    }
    for (var name42 in this._textures) {
      if (this._textures[name42] === texture) {
        return true;
      }
    }
    for (var name42 in this._textureArrays) {
      var array = this._textureArrays[name42];
      for (var index = 0; index < array.length; index++) {
        if (array[index] === texture) {
          return true;
        }
      }
    }
    return false;
  };
  ShaderMaterial2.prototype.clone = function(name42) {
    var _this = this;
    var result = SerializationHelper.Clone(function() {
      return new ShaderMaterial2(name42, _this.getScene(), _this._shaderPath, _this._options);
    }, this);
    result.name = name42;
    result.id = name42;
    if (typeof result._shaderPath === "object") {
      result._shaderPath = __assign({}, result._shaderPath);
    }
    this._options = __assign({}, this._options);
    Object.keys(this._options).forEach(function(propName) {
      var propValue = _this._options[propName];
      if (Array.isArray(propValue)) {
        _this._options[propName] = propValue.slice(0);
      }
    });
    for (var key in this._textures) {
      result.setTexture(key, this._textures[key]);
    }
    for (var key in this._floats) {
      result.setFloat(key, this._floats[key]);
    }
    for (var key in this._floatsArrays) {
      result.setFloats(key, this._floatsArrays[key]);
    }
    for (var key in this._colors3) {
      result.setColor3(key, this._colors3[key]);
    }
    for (var key in this._colors4) {
      result.setColor4(key, this._colors4[key]);
    }
    for (var key in this._vectors2) {
      result.setVector2(key, this._vectors2[key]);
    }
    for (var key in this._vectors3) {
      result.setVector3(key, this._vectors3[key]);
    }
    for (var key in this._vectors4) {
      result.setVector4(key, this._vectors4[key]);
    }
    for (var key in this._matrices) {
      result.setMatrix(key, this._matrices[key]);
    }
    for (var key in this._matrices3x3) {
      result.setMatrix3x3(key, this._matrices3x3[key]);
    }
    for (var key in this._matrices2x2) {
      result.setMatrix2x2(key, this._matrices2x2[key]);
    }
    return result;
  };
  ShaderMaterial2.prototype.dispose = function(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {
    if (forceDisposeTextures) {
      var name42;
      for (name42 in this._textures) {
        this._textures[name42].dispose();
      }
      for (name42 in this._textureArrays) {
        var array = this._textureArrays[name42];
        for (var index = 0; index < array.length; index++) {
          array[index].dispose();
        }
      }
    }
    this._textures = {};
    _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures, notBoundToMesh);
  };
  ShaderMaterial2.prototype.serialize = function() {
    var serializationObject = SerializationHelper.Serialize(this);
    serializationObject.customType = "BABYLON.ShaderMaterial";
    serializationObject.options = this._options;
    serializationObject.shaderPath = this._shaderPath;
    var name42;
    serializationObject.textures = {};
    for (name42 in this._textures) {
      serializationObject.textures[name42] = this._textures[name42].serialize();
    }
    serializationObject.textureArrays = {};
    for (name42 in this._textureArrays) {
      serializationObject.textureArrays[name42] = [];
      var array = this._textureArrays[name42];
      for (var index = 0; index < array.length; index++) {
        serializationObject.textureArrays[name42].push(array[index].serialize());
      }
    }
    serializationObject.floats = {};
    for (name42 in this._floats) {
      serializationObject.floats[name42] = this._floats[name42];
    }
    serializationObject.FloatArrays = {};
    for (name42 in this._floatsArrays) {
      serializationObject.FloatArrays[name42] = this._floatsArrays[name42];
    }
    serializationObject.colors3 = {};
    for (name42 in this._colors3) {
      serializationObject.colors3[name42] = this._colors3[name42].asArray();
    }
    serializationObject.colors3Arrays = {};
    for (name42 in this._colors3Arrays) {
      serializationObject.colors3Arrays[name42] = this._colors3Arrays[name42];
    }
    serializationObject.colors4 = {};
    for (name42 in this._colors4) {
      serializationObject.colors4[name42] = this._colors4[name42].asArray();
    }
    serializationObject.colors4Arrays = {};
    for (name42 in this._colors4Arrays) {
      serializationObject.colors4Arrays[name42] = this._colors4Arrays[name42];
    }
    serializationObject.vectors2 = {};
    for (name42 in this._vectors2) {
      serializationObject.vectors2[name42] = this._vectors2[name42].asArray();
    }
    serializationObject.vectors3 = {};
    for (name42 in this._vectors3) {
      serializationObject.vectors3[name42] = this._vectors3[name42].asArray();
    }
    serializationObject.vectors4 = {};
    for (name42 in this._vectors4) {
      serializationObject.vectors4[name42] = this._vectors4[name42].asArray();
    }
    serializationObject.matrices = {};
    for (name42 in this._matrices) {
      serializationObject.matrices[name42] = this._matrices[name42].asArray();
    }
    serializationObject.matrixArray = {};
    for (name42 in this._matrixArrays) {
      serializationObject.matrixArray[name42] = this._matrixArrays[name42];
    }
    serializationObject.matrices3x3 = {};
    for (name42 in this._matrices3x3) {
      serializationObject.matrices3x3[name42] = this._matrices3x3[name42];
    }
    serializationObject.matrices2x2 = {};
    for (name42 in this._matrices2x2) {
      serializationObject.matrices2x2[name42] = this._matrices2x2[name42];
    }
    serializationObject.vectors2Arrays = {};
    for (name42 in this._vectors2Arrays) {
      serializationObject.vectors2Arrays[name42] = this._vectors2Arrays[name42];
    }
    serializationObject.vectors3Arrays = {};
    for (name42 in this._vectors3Arrays) {
      serializationObject.vectors3Arrays[name42] = this._vectors3Arrays[name42];
    }
    serializationObject.vectors4Arrays = {};
    for (name42 in this._vectors4Arrays) {
      serializationObject.vectors4Arrays[name42] = this._vectors4Arrays[name42];
    }
    return serializationObject;
  };
  ShaderMaterial2.Parse = function(source, scene, rootUrl) {
    var material = SerializationHelper.Parse(function() {
      return new ShaderMaterial2(source.name, scene, source.shaderPath, source.options);
    }, source, scene, rootUrl);
    var name42;
    for (name42 in source.textures) {
      material.setTexture(name42, Texture.Parse(source.textures[name42], scene, rootUrl));
    }
    for (name42 in source.textureArrays) {
      var array = source.textureArrays[name42];
      var textureArray = new Array();
      for (var index = 0; index < array.length; index++) {
        textureArray.push(Texture.Parse(array[index], scene, rootUrl));
      }
      material.setTextureArray(name42, textureArray);
    }
    for (name42 in source.floats) {
      material.setFloat(name42, source.floats[name42]);
    }
    for (name42 in source.floatsArrays) {
      material.setFloats(name42, source.floatsArrays[name42]);
    }
    for (name42 in source.colors3) {
      material.setColor3(name42, Color3.FromArray(source.colors3[name42]));
    }
    for (name42 in source.colors3Arrays) {
      var colors = source.colors3Arrays[name42].reduce(function(arr, num, i) {
        if (i % 3 === 0) {
          arr.push([num]);
        } else {
          arr[arr.length - 1].push(num);
        }
        return arr;
      }, []).map(function(color) {
        return Color3.FromArray(color);
      });
      material.setColor3Array(name42, colors);
    }
    for (name42 in source.colors4) {
      material.setColor4(name42, Color4.FromArray(source.colors4[name42]));
    }
    for (name42 in source.colors4Arrays) {
      var colors = source.colors4Arrays[name42].reduce(function(arr, num, i) {
        if (i % 4 === 0) {
          arr.push([num]);
        } else {
          arr[arr.length - 1].push(num);
        }
        return arr;
      }, []).map(function(color) {
        return Color4.FromArray(color);
      });
      material.setColor4Array(name42, colors);
    }
    for (name42 in source.vectors2) {
      material.setVector2(name42, Vector2.FromArray(source.vectors2[name42]));
    }
    for (name42 in source.vectors3) {
      material.setVector3(name42, Vector3.FromArray(source.vectors3[name42]));
    }
    for (name42 in source.vectors4) {
      material.setVector4(name42, Vector4.FromArray(source.vectors4[name42]));
    }
    for (name42 in source.matrices) {
      material.setMatrix(name42, Matrix.FromArray(source.matrices[name42]));
    }
    for (name42 in source.matrixArray) {
      material._matrixArrays[name42] = new Float32Array(source.matrixArray[name42]);
    }
    for (name42 in source.matrices3x3) {
      material.setMatrix3x3(name42, source.matrices3x3[name42]);
    }
    for (name42 in source.matrices2x2) {
      material.setMatrix2x2(name42, source.matrices2x2[name42]);
    }
    for (name42 in source.vectors2Arrays) {
      material.setArray2(name42, source.vectors2Arrays[name42]);
    }
    for (name42 in source.vectors3Arrays) {
      material.setArray3(name42, source.vectors3Arrays[name42]);
    }
    for (name42 in source.vectors4Arrays) {
      material.setArray4(name42, source.vectors4Arrays[name42]);
    }
    return material;
  };
  ShaderMaterial2.ParseFromFileAsync = function(name42, url, scene, rootUrl) {
    var _this = this;
    if (rootUrl === void 0) {
      rootUrl = "";
    }
    return new Promise(function(resolve, reject) {
      var request = new WebRequest();
      request.addEventListener("readystatechange", function() {
        if (request.readyState == 4) {
          if (request.status == 200) {
            var serializationObject = JSON.parse(request.responseText);
            var output = _this.Parse(serializationObject, scene || Engine.LastCreatedScene, rootUrl);
            if (name42) {
              output.name = name42;
            }
            resolve(output);
          } else {
            reject("Unable to load the ShaderMaterial");
          }
        }
      });
      request.open("GET", url);
      request.send();
    });
  };
  ShaderMaterial2.CreateFromSnippetAsync = function(snippetId, scene, rootUrl) {
    var _this = this;
    if (rootUrl === void 0) {
      rootUrl = "";
    }
    return new Promise(function(resolve, reject) {
      var request = new WebRequest();
      request.addEventListener("readystatechange", function() {
        if (request.readyState == 4) {
          if (request.status == 200) {
            var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
            var serializationObject = JSON.parse(snippet.shaderMaterial);
            var output = _this.Parse(serializationObject, scene || Engine.LastCreatedScene, rootUrl);
            output.snippetId = snippetId;
            resolve(output);
          } else {
            reject("Unable to load the snippet " + snippetId);
          }
        }
      });
      request.open("GET", _this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
      request.send();
    });
  };
  ShaderMaterial2.SnippetUrl = "https://snippet.babylonjs.com";
  return ShaderMaterial2;
}(Material);
_TypeStore.RegisteredTypes["BABYLON.ShaderMaterial"] = ShaderMaterial;

// node_modules/@babylonjs/core/Maths/sphericalPolynomial.js
var SH3ylmBasisConstants = [
  Math.sqrt(1 / (4 * Math.PI)),
  -Math.sqrt(3 / (4 * Math.PI)),
  Math.sqrt(3 / (4 * Math.PI)),
  -Math.sqrt(3 / (4 * Math.PI)),
  Math.sqrt(15 / (4 * Math.PI)),
  -Math.sqrt(15 / (4 * Math.PI)),
  Math.sqrt(5 / (16 * Math.PI)),
  -Math.sqrt(15 / (4 * Math.PI)),
  Math.sqrt(15 / (16 * Math.PI))
];
var SH3ylmBasisTrigonometricTerms = [
  function(direction) {
    return 1;
  },
  function(direction) {
    return direction.y;
  },
  function(direction) {
    return direction.z;
  },
  function(direction) {
    return direction.x;
  },
  function(direction) {
    return direction.x * direction.y;
  },
  function(direction) {
    return direction.y * direction.z;
  },
  function(direction) {
    return 3 * direction.z * direction.z - 1;
  },
  function(direction) {
    return direction.x * direction.z;
  },
  function(direction) {
    return direction.x * direction.x - direction.y * direction.y;
  }
];
var applySH3 = function(lm, direction) {
  return SH3ylmBasisConstants[lm] * SH3ylmBasisTrigonometricTerms[lm](direction);
};
var SHCosKernelConvolution = [
  Math.PI,
  2 * Math.PI / 3,
  2 * Math.PI / 3,
  2 * Math.PI / 3,
  Math.PI / 4,
  Math.PI / 4,
  Math.PI / 4,
  Math.PI / 4,
  Math.PI / 4
];
var SphericalHarmonics = function() {
  function SphericalHarmonics2() {
    this.preScaled = false;
    this.l00 = Vector3.Zero();
    this.l1_1 = Vector3.Zero();
    this.l10 = Vector3.Zero();
    this.l11 = Vector3.Zero();
    this.l2_2 = Vector3.Zero();
    this.l2_1 = Vector3.Zero();
    this.l20 = Vector3.Zero();
    this.l21 = Vector3.Zero();
    this.l22 = Vector3.Zero();
  }
  SphericalHarmonics2.prototype.addLight = function(direction, color, deltaSolidAngle) {
    var colorVector = new Vector3(color.r, color.g, color.b);
    var c = colorVector.scale(deltaSolidAngle);
    this.l00 = this.l00.add(c.scale(applySH3(0, direction)));
    this.l1_1 = this.l1_1.add(c.scale(applySH3(1, direction)));
    this.l10 = this.l10.add(c.scale(applySH3(2, direction)));
    this.l11 = this.l11.add(c.scale(applySH3(3, direction)));
    this.l2_2 = this.l2_2.add(c.scale(applySH3(4, direction)));
    this.l2_1 = this.l2_1.add(c.scale(applySH3(5, direction)));
    this.l20 = this.l20.add(c.scale(applySH3(6, direction)));
    this.l21 = this.l21.add(c.scale(applySH3(7, direction)));
    this.l22 = this.l22.add(c.scale(applySH3(8, direction)));
  };
  SphericalHarmonics2.prototype.scaleInPlace = function(scale) {
    this.l00.scaleInPlace(scale);
    this.l1_1.scaleInPlace(scale);
    this.l10.scaleInPlace(scale);
    this.l11.scaleInPlace(scale);
    this.l2_2.scaleInPlace(scale);
    this.l2_1.scaleInPlace(scale);
    this.l20.scaleInPlace(scale);
    this.l21.scaleInPlace(scale);
    this.l22.scaleInPlace(scale);
  };
  SphericalHarmonics2.prototype.convertIncidentRadianceToIrradiance = function() {
    this.l00.scaleInPlace(SHCosKernelConvolution[0]);
    this.l1_1.scaleInPlace(SHCosKernelConvolution[1]);
    this.l10.scaleInPlace(SHCosKernelConvolution[2]);
    this.l11.scaleInPlace(SHCosKernelConvolution[3]);
    this.l2_2.scaleInPlace(SHCosKernelConvolution[4]);
    this.l2_1.scaleInPlace(SHCosKernelConvolution[5]);
    this.l20.scaleInPlace(SHCosKernelConvolution[6]);
    this.l21.scaleInPlace(SHCosKernelConvolution[7]);
    this.l22.scaleInPlace(SHCosKernelConvolution[8]);
  };
  SphericalHarmonics2.prototype.convertIrradianceToLambertianRadiance = function() {
    this.scaleInPlace(1 / Math.PI);
  };
  SphericalHarmonics2.prototype.preScaleForRendering = function() {
    this.preScaled = true;
    this.l00.scaleInPlace(SH3ylmBasisConstants[0]);
    this.l1_1.scaleInPlace(SH3ylmBasisConstants[1]);
    this.l10.scaleInPlace(SH3ylmBasisConstants[2]);
    this.l11.scaleInPlace(SH3ylmBasisConstants[3]);
    this.l2_2.scaleInPlace(SH3ylmBasisConstants[4]);
    this.l2_1.scaleInPlace(SH3ylmBasisConstants[5]);
    this.l20.scaleInPlace(SH3ylmBasisConstants[6]);
    this.l21.scaleInPlace(SH3ylmBasisConstants[7]);
    this.l22.scaleInPlace(SH3ylmBasisConstants[8]);
  };
  SphericalHarmonics2.FromArray = function(data) {
    var sh = new SphericalHarmonics2();
    Vector3.FromArrayToRef(data[0], 0, sh.l00);
    Vector3.FromArrayToRef(data[1], 0, sh.l1_1);
    Vector3.FromArrayToRef(data[2], 0, sh.l10);
    Vector3.FromArrayToRef(data[3], 0, sh.l11);
    Vector3.FromArrayToRef(data[4], 0, sh.l2_2);
    Vector3.FromArrayToRef(data[5], 0, sh.l2_1);
    Vector3.FromArrayToRef(data[6], 0, sh.l20);
    Vector3.FromArrayToRef(data[7], 0, sh.l21);
    Vector3.FromArrayToRef(data[8], 0, sh.l22);
    return sh;
  };
  SphericalHarmonics2.FromPolynomial = function(polynomial) {
    var result = new SphericalHarmonics2();
    result.l00 = polynomial.xx.scale(0.376127).add(polynomial.yy.scale(0.376127)).add(polynomial.zz.scale(0.376126));
    result.l1_1 = polynomial.y.scale(0.977204);
    result.l10 = polynomial.z.scale(0.977204);
    result.l11 = polynomial.x.scale(0.977204);
    result.l2_2 = polynomial.xy.scale(1.16538);
    result.l2_1 = polynomial.yz.scale(1.16538);
    result.l20 = polynomial.zz.scale(1.34567).subtract(polynomial.xx.scale(0.672834)).subtract(polynomial.yy.scale(0.672834));
    result.l21 = polynomial.zx.scale(1.16538);
    result.l22 = polynomial.xx.scale(1.16538).subtract(polynomial.yy.scale(1.16538));
    result.l1_1.scaleInPlace(-1);
    result.l11.scaleInPlace(-1);
    result.l2_1.scaleInPlace(-1);
    result.l21.scaleInPlace(-1);
    result.scaleInPlace(Math.PI);
    return result;
  };
  return SphericalHarmonics2;
}();
var SphericalPolynomial = function() {
  function SphericalPolynomial2() {
    this.x = Vector3.Zero();
    this.y = Vector3.Zero();
    this.z = Vector3.Zero();
    this.xx = Vector3.Zero();
    this.yy = Vector3.Zero();
    this.zz = Vector3.Zero();
    this.xy = Vector3.Zero();
    this.yz = Vector3.Zero();
    this.zx = Vector3.Zero();
  }
  Object.defineProperty(SphericalPolynomial2.prototype, "preScaledHarmonics", {
    get: function() {
      if (!this._harmonics) {
        this._harmonics = SphericalHarmonics.FromPolynomial(this);
      }
      if (!this._harmonics.preScaled) {
        this._harmonics.preScaleForRendering();
      }
      return this._harmonics;
    },
    enumerable: false,
    configurable: true
  });
  SphericalPolynomial2.prototype.addAmbient = function(color) {
    var colorVector = new Vector3(color.r, color.g, color.b);
    this.xx = this.xx.add(colorVector);
    this.yy = this.yy.add(colorVector);
    this.zz = this.zz.add(colorVector);
  };
  SphericalPolynomial2.prototype.scaleInPlace = function(scale) {
    this.x.scaleInPlace(scale);
    this.y.scaleInPlace(scale);
    this.z.scaleInPlace(scale);
    this.xx.scaleInPlace(scale);
    this.yy.scaleInPlace(scale);
    this.zz.scaleInPlace(scale);
    this.yz.scaleInPlace(scale);
    this.zx.scaleInPlace(scale);
    this.xy.scaleInPlace(scale);
  };
  SphericalPolynomial2.FromHarmonics = function(harmonics) {
    var result = new SphericalPolynomial2();
    result._harmonics = harmonics;
    result.x = harmonics.l11.scale(1.02333).scale(-1);
    result.y = harmonics.l1_1.scale(1.02333).scale(-1);
    result.z = harmonics.l10.scale(1.02333);
    result.xx = harmonics.l00.scale(0.886277).subtract(harmonics.l20.scale(0.247708)).add(harmonics.l22.scale(0.429043));
    result.yy = harmonics.l00.scale(0.886277).subtract(harmonics.l20.scale(0.247708)).subtract(harmonics.l22.scale(0.429043));
    result.zz = harmonics.l00.scale(0.886277).add(harmonics.l20.scale(0.495417));
    result.yz = harmonics.l2_1.scale(0.858086).scale(-1);
    result.zx = harmonics.l21.scale(0.858086).scale(-1);
    result.xy = harmonics.l2_2.scale(0.858086);
    result.scaleInPlace(1 / Math.PI);
    return result;
  };
  SphericalPolynomial2.FromArray = function(data) {
    var sp = new SphericalPolynomial2();
    Vector3.FromArrayToRef(data[0], 0, sp.x);
    Vector3.FromArrayToRef(data[1], 0, sp.y);
    Vector3.FromArrayToRef(data[2], 0, sp.z);
    Vector3.FromArrayToRef(data[3], 0, sp.xx);
    Vector3.FromArrayToRef(data[4], 0, sp.yy);
    Vector3.FromArrayToRef(data[5], 0, sp.zz);
    Vector3.FromArrayToRef(data[6], 0, sp.yz);
    Vector3.FromArrayToRef(data[7], 0, sp.zx);
    Vector3.FromArrayToRef(data[8], 0, sp.xy);
    return sp;
  };
  return SphericalPolynomial2;
}();

// node_modules/@babylonjs/core/Misc/HighDynamicRange/cubemapToSphericalPolynomial.js
var FileFaceOrientation = function() {
  function FileFaceOrientation2(name42, worldAxisForNormal, worldAxisForFileX, worldAxisForFileY) {
    this.name = name42;
    this.worldAxisForNormal = worldAxisForNormal;
    this.worldAxisForFileX = worldAxisForFileX;
    this.worldAxisForFileY = worldAxisForFileY;
  }
  return FileFaceOrientation2;
}();
var CubeMapToSphericalPolynomialTools = function() {
  function CubeMapToSphericalPolynomialTools2() {
  }
  CubeMapToSphericalPolynomialTools2.ConvertCubeMapTextureToSphericalPolynomial = function(texture) {
    if (!texture.isCube) {
      return null;
    }
    var size = texture.getSize().width;
    var right = texture.readPixels(0);
    var left = texture.readPixels(1);
    var up;
    var down;
    if (texture.isRenderTarget) {
      up = texture.readPixels(3);
      down = texture.readPixels(2);
    } else {
      up = texture.readPixels(2);
      down = texture.readPixels(3);
    }
    var front = texture.readPixels(4);
    var back = texture.readPixels(5);
    var gammaSpace = texture.gammaSpace;
    var format = 5;
    var type = 0;
    if (texture.textureType == 1 || texture.textureType == 2) {
      type = 1;
    }
    var cubeInfo = {
      size,
      right,
      left,
      up,
      down,
      front,
      back,
      format,
      type,
      gammaSpace
    };
    return this.ConvertCubeMapToSphericalPolynomial(cubeInfo);
  };
  CubeMapToSphericalPolynomialTools2.ConvertCubeMapToSphericalPolynomial = function(cubeInfo) {
    var sphericalHarmonics = new SphericalHarmonics();
    var totalSolidAngle = 0;
    var du = 2 / cubeInfo.size;
    var dv = du;
    var minUV = du * 0.5 - 1;
    for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
      var fileFace = this.FileFaces[faceIndex];
      var dataArray = cubeInfo[fileFace.name];
      var v = minUV;
      var stride = cubeInfo.format === 5 ? 4 : 3;
      for (var y = 0; y < cubeInfo.size; y++) {
        var u = minUV;
        for (var x = 0; x < cubeInfo.size; x++) {
          var worldDirection = fileFace.worldAxisForFileX.scale(u).add(fileFace.worldAxisForFileY.scale(v)).add(fileFace.worldAxisForNormal);
          worldDirection.normalize();
          var deltaSolidAngle = Math.pow(1 + u * u + v * v, -3 / 2);
          var r = dataArray[y * cubeInfo.size * stride + x * stride + 0];
          var g = dataArray[y * cubeInfo.size * stride + x * stride + 1];
          var b = dataArray[y * cubeInfo.size * stride + x * stride + 2];
          if (isNaN(r)) {
            r = 0;
          }
          if (isNaN(g)) {
            g = 0;
          }
          if (isNaN(b)) {
            b = 0;
          }
          if (cubeInfo.type === 0) {
            r /= 255;
            g /= 255;
            b /= 255;
          }
          if (cubeInfo.gammaSpace) {
            r = Math.pow(Scalar.Clamp(r), ToLinearSpace);
            g = Math.pow(Scalar.Clamp(g), ToLinearSpace);
            b = Math.pow(Scalar.Clamp(b), ToLinearSpace);
          }
          var max = 4096;
          r = Scalar.Clamp(r, 0, max);
          g = Scalar.Clamp(g, 0, max);
          b = Scalar.Clamp(b, 0, max);
          var color = new Color3(r, g, b);
          sphericalHarmonics.addLight(worldDirection, color, deltaSolidAngle);
          totalSolidAngle += deltaSolidAngle;
          u += du;
        }
        v += dv;
      }
    }
    var sphereSolidAngle = 4 * Math.PI;
    var facesProcessed = 6;
    var expectedSolidAngle = sphereSolidAngle * facesProcessed / 6;
    var correctionFactor = expectedSolidAngle / totalSolidAngle;
    sphericalHarmonics.scaleInPlace(correctionFactor);
    sphericalHarmonics.convertIncidentRadianceToIrradiance();
    sphericalHarmonics.convertIrradianceToLambertianRadiance();
    return SphericalPolynomial.FromHarmonics(sphericalHarmonics);
  };
  CubeMapToSphericalPolynomialTools2.FileFaces = [
    new FileFaceOrientation("right", new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)),
    new FileFaceOrientation("left", new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, -1, 0)),
    new FileFaceOrientation("up", new Vector3(0, 1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)),
    new FileFaceOrientation("down", new Vector3(0, -1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, -1)),
    new FileFaceOrientation("front", new Vector3(0, 0, 1), new Vector3(1, 0, 0), new Vector3(0, -1, 0)),
    new FileFaceOrientation("back", new Vector3(0, 0, -1), new Vector3(-1, 0, 0), new Vector3(0, -1, 0))
  ];
  return CubeMapToSphericalPolynomialTools2;
}();

// node_modules/@babylonjs/core/Materials/Textures/baseTexture.polynomial.js
Object.defineProperty(BaseTexture.prototype, "sphericalPolynomial", {
  get: function() {
    if (this._texture) {
      if (this._texture._sphericalPolynomial) {
        return this._texture._sphericalPolynomial;
      }
      if (this._texture.isReady) {
        this._texture._sphericalPolynomial = CubeMapToSphericalPolynomialTools.ConvertCubeMapTextureToSphericalPolynomial(this);
        return this._texture._sphericalPolynomial;
      }
    }
    return null;
  },
  set: function(value) {
    if (this._texture) {
      this._texture._sphericalPolynomial = value;
    }
  },
  enumerable: true,
  configurable: true
});

// node_modules/@babylonjs/core/Shaders/rgbdEncode.fragment.js
var name2 = "rgbdEncodePixelShader";
var shader2 = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n#include<helperFunctions>\nvoid main(void)\n{\ngl_FragColor=toRGBD(texture2D(textureSampler,vUV).rgb);\n}";
Effect.ShadersStore[name2] = shader2;

// node_modules/@babylonjs/core/Shaders/rgbdDecode.fragment.js
var name3 = "rgbdDecodePixelShader";
var shader3 = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n#include<helperFunctions>\nvoid main(void)\n{\ngl_FragColor=vec4(fromRGBD(texture2D(textureSampler,vUV)),1.0);\n}";
Effect.ShadersStore[name3] = shader3;

// node_modules/@babylonjs/core/Misc/environmentTextureTools.js
var EnvironmentTextureTools = function() {
  function EnvironmentTextureTools2() {
  }
  EnvironmentTextureTools2.GetEnvInfo = function(data) {
    var dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
    var pos = 0;
    for (var i = 0; i < EnvironmentTextureTools2._MagicBytes.length; i++) {
      if (dataView.getUint8(pos++) !== EnvironmentTextureTools2._MagicBytes[i]) {
        Logger.Error("Not a babylon environment map");
        return null;
      }
    }
    var manifestString = "";
    var charCode = 0;
    while (charCode = dataView.getUint8(pos++)) {
      manifestString += String.fromCharCode(charCode);
    }
    var manifest = JSON.parse(manifestString);
    if (manifest.specular) {
      manifest.specular.specularDataPosition = pos;
      manifest.specular.lodGenerationScale = manifest.specular.lodGenerationScale || 0.8;
    }
    return manifest;
  };
  EnvironmentTextureTools2.CreateEnvTextureAsync = function(texture) {
    var _this = this;
    var internalTexture = texture.getInternalTexture();
    if (!internalTexture) {
      return Promise.reject("The cube texture is invalid.");
    }
    var engine = internalTexture.getEngine();
    if (engine && engine.premultipliedAlpha) {
      return Promise.reject("Env texture can only be created when the engine is created with the premultipliedAlpha option set to false.");
    }
    if (texture.textureType === 0) {
      return Promise.reject("The cube texture should allow HDR (Full Float or Half Float).");
    }
    var canvas = engine.getRenderingCanvas();
    if (!canvas) {
      return Promise.reject("Env texture can only be created when the engine is associated to a canvas.");
    }
    var textureType = 1;
    if (!engine.getCaps().textureFloatRender) {
      textureType = 2;
      if (!engine.getCaps().textureHalfFloatRender) {
        return Promise.reject("Env texture can only be created when the browser supports half float or full float rendering.");
      }
    }
    var cubeWidth = internalTexture.width;
    var hostingScene = new Scene(engine);
    var specularTextures = {};
    var promises = [];
    var mipmapsCount = Scalar.Log2(internalTexture.width);
    mipmapsCount = Math.round(mipmapsCount);
    var _loop_1 = function(i2) {
      var faceWidth = Math.pow(2, mipmapsCount - i2);
      var _loop_2 = function(face2) {
        var data = texture.readPixels(face2, i2);
        var tempTexture = engine.createRawTexture(data, faceWidth, faceWidth, 5, false, false, 1, null, textureType);
        var promise = new Promise(function(resolve, reject) {
          var rgbdPostProcess = new PostProcess("rgbdEncode", "rgbdEncode", null, null, 1, null, 1, engine, false, void 0, 0, void 0, null, false);
          rgbdPostProcess.getEffect().executeWhenCompiled(function() {
            rgbdPostProcess.onApply = function(effect) {
              effect._bindTexture("textureSampler", tempTexture);
            };
            var currentW = engine.getRenderWidth();
            var currentH = engine.getRenderHeight();
            engine.setSize(faceWidth, faceWidth);
            hostingScene.postProcessManager.directRender([rgbdPostProcess], null);
            Tools.ToBlob(canvas, function(blob) {
              var fileReader = new FileReader();
              fileReader.onload = function(event) {
                var arrayBuffer = event.target.result;
                specularTextures[i2 * 6 + face2] = arrayBuffer;
                resolve();
              };
              fileReader.readAsArrayBuffer(blob);
            });
            engine.setSize(currentW, currentH);
          });
        });
        promises.push(promise);
      };
      for (var face = 0; face < 6; face++) {
        _loop_2(face);
      }
    };
    for (var i = 0; i <= mipmapsCount; i++) {
      _loop_1(i);
    }
    return Promise.all(promises).then(function() {
      hostingScene.dispose();
      var info = {
        version: 1,
        width: cubeWidth,
        irradiance: _this._CreateEnvTextureIrradiance(texture),
        specular: {
          mipmaps: [],
          lodGenerationScale: texture.lodGenerationScale
        }
      };
      var position = 0;
      for (var i2 = 0; i2 <= mipmapsCount; i2++) {
        for (var face = 0; face < 6; face++) {
          var byteLength = specularTextures[i2 * 6 + face].byteLength;
          info.specular.mipmaps.push({
            length: byteLength,
            position
          });
          position += byteLength;
        }
      }
      var infoString = JSON.stringify(info);
      var infoBuffer = new ArrayBuffer(infoString.length + 1);
      var infoView = new Uint8Array(infoBuffer);
      for (var i2 = 0, strLen = infoString.length; i2 < strLen; i2++) {
        infoView[i2] = infoString.charCodeAt(i2);
      }
      infoView[infoString.length] = 0;
      var totalSize = EnvironmentTextureTools2._MagicBytes.length + position + infoBuffer.byteLength;
      var finalBuffer = new ArrayBuffer(totalSize);
      var finalBufferView = new Uint8Array(finalBuffer);
      var dataView = new DataView(finalBuffer);
      var pos = 0;
      for (var i2 = 0; i2 < EnvironmentTextureTools2._MagicBytes.length; i2++) {
        dataView.setUint8(pos++, EnvironmentTextureTools2._MagicBytes[i2]);
      }
      finalBufferView.set(new Uint8Array(infoBuffer), pos);
      pos += infoBuffer.byteLength;
      for (var i2 = 0; i2 <= mipmapsCount; i2++) {
        for (var face = 0; face < 6; face++) {
          var dataBuffer = specularTextures[i2 * 6 + face];
          finalBufferView.set(new Uint8Array(dataBuffer), pos);
          pos += dataBuffer.byteLength;
        }
      }
      return finalBuffer;
    });
  };
  EnvironmentTextureTools2._CreateEnvTextureIrradiance = function(texture) {
    var polynmials = texture.sphericalPolynomial;
    if (polynmials == null) {
      return null;
    }
    return {
      x: [polynmials.x.x, polynmials.x.y, polynmials.x.z],
      y: [polynmials.y.x, polynmials.y.y, polynmials.y.z],
      z: [polynmials.z.x, polynmials.z.y, polynmials.z.z],
      xx: [polynmials.xx.x, polynmials.xx.y, polynmials.xx.z],
      yy: [polynmials.yy.x, polynmials.yy.y, polynmials.yy.z],
      zz: [polynmials.zz.x, polynmials.zz.y, polynmials.zz.z],
      yz: [polynmials.yz.x, polynmials.yz.y, polynmials.yz.z],
      zx: [polynmials.zx.x, polynmials.zx.y, polynmials.zx.z],
      xy: [polynmials.xy.x, polynmials.xy.y, polynmials.xy.z]
    };
  };
  EnvironmentTextureTools2.CreateImageDataArrayBufferViews = function(data, info) {
    if (info.version !== 1) {
      throw new Error('Unsupported babylon environment map version "' + info.version + '"');
    }
    var specularInfo = info.specular;
    var mipmapsCount = Scalar.Log2(info.width);
    mipmapsCount = Math.round(mipmapsCount) + 1;
    if (specularInfo.mipmaps.length !== 6 * mipmapsCount) {
      throw new Error('Unsupported specular mipmaps number "' + specularInfo.mipmaps.length + '"');
    }
    var imageData = new Array(mipmapsCount);
    for (var i = 0; i < mipmapsCount; i++) {
      imageData[i] = new Array(6);
      for (var face = 0; face < 6; face++) {
        var imageInfo = specularInfo.mipmaps[i * 6 + face];
        imageData[i][face] = new Uint8Array(data.buffer, data.byteOffset + specularInfo.specularDataPosition + imageInfo.position, imageInfo.length);
      }
    }
    return imageData;
  };
  EnvironmentTextureTools2.UploadEnvLevelsAsync = function(texture, data, info) {
    if (info.version !== 1) {
      throw new Error('Unsupported babylon environment map version "' + info.version + '"');
    }
    var specularInfo = info.specular;
    if (!specularInfo) {
      return Promise.resolve();
    }
    texture._lodGenerationScale = specularInfo.lodGenerationScale;
    var imageData = EnvironmentTextureTools2.CreateImageDataArrayBufferViews(data, info);
    return EnvironmentTextureTools2.UploadLevelsAsync(texture, imageData);
  };
  EnvironmentTextureTools2._OnImageReadyAsync = function(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture) {
    return new Promise(function(resolve, reject) {
      if (expandTexture) {
        var tempTexture_1 = engine.createTexture(null, true, true, null, 1, null, function(message) {
          reject(message);
        }, image);
        rgbdPostProcess.getEffect().executeWhenCompiled(function() {
          rgbdPostProcess.onApply = function(effect) {
            effect._bindTexture("textureSampler", tempTexture_1);
            effect.setFloat2("scale", 1, 1);
          };
          engine.scenes[0].postProcessManager.directRender([rgbdPostProcess], cubeRtt, true, face, i);
          engine.restoreDefaultFramebuffer();
          tempTexture_1.dispose();
          URL.revokeObjectURL(url);
          resolve();
        });
      } else {
        engine._uploadImageToTexture(texture, image, face, i);
        if (generateNonLODTextures) {
          var lodTexture = lodTextures[i];
          if (lodTexture) {
            engine._uploadImageToTexture(lodTexture._texture, image, face, 0);
          }
        }
        resolve();
      }
    });
  };
  EnvironmentTextureTools2.UploadLevelsAsync = function(texture, imageData) {
    var _this = this;
    if (!Tools.IsExponentOfTwo(texture.width)) {
      throw new Error("Texture size must be a power of two");
    }
    var mipmapsCount = Math.round(Scalar.Log2(texture.width)) + 1;
    var engine = texture.getEngine();
    var expandTexture = false;
    var generateNonLODTextures = false;
    var rgbdPostProcess = null;
    var cubeRtt = null;
    var lodTextures = null;
    var caps = engine.getCaps();
    texture.format = 5;
    texture.type = 0;
    texture.generateMipMaps = true;
    texture._cachedAnisotropicFilteringLevel = null;
    engine.updateTextureSamplingMode(3, texture);
    if (!caps.textureLOD) {
      expandTexture = false;
      generateNonLODTextures = true;
      lodTextures = {};
    } else if (engine.webGLVersion < 2) {
      expandTexture = false;
    } else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
      expandTexture = true;
      texture.type = 2;
    } else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
      expandTexture = true;
      texture.type = 1;
    }
    if (expandTexture) {
      rgbdPostProcess = new PostProcess("rgbdDecode", "rgbdDecode", null, null, 1, null, 3, engine, false, void 0, texture.type, void 0, null, false);
      texture._isRGBD = false;
      texture.invertY = false;
      cubeRtt = engine.createRenderTargetCubeTexture(texture.width, {
        generateDepthBuffer: false,
        generateMipMaps: true,
        generateStencilBuffer: false,
        samplingMode: 3,
        type: texture.type,
        format: 5
      });
    } else {
      texture._isRGBD = true;
      texture.invertY = true;
      if (generateNonLODTextures) {
        var mipSlices = 3;
        var scale = texture._lodGenerationScale;
        var offset = texture._lodGenerationOffset;
        for (var i = 0; i < mipSlices; i++) {
          var smoothness = i / (mipSlices - 1);
          var roughness = 1 - smoothness;
          var minLODIndex = offset;
          var maxLODIndex = (mipmapsCount - 1) * scale + offset;
          var lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;
          var mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));
          var glTextureFromLod = new InternalTexture(engine, InternalTextureSource.Temp);
          glTextureFromLod.isCube = true;
          glTextureFromLod.invertY = true;
          glTextureFromLod.generateMipMaps = false;
          engine.updateTextureSamplingMode(2, glTextureFromLod);
          var lodTexture = new BaseTexture(null);
          lodTexture.isCube = true;
          lodTexture._texture = glTextureFromLod;
          lodTextures[mipmapIndex] = lodTexture;
          switch (i) {
            case 0:
              texture._lodTextureLow = lodTexture;
              break;
            case 1:
              texture._lodTextureMid = lodTexture;
              break;
            case 2:
              texture._lodTextureHigh = lodTexture;
              break;
          }
        }
      }
    }
    var promises = [];
    var _loop_3 = function(i2) {
      var _loop_4 = function(face3) {
        var bytes = imageData[i2][face3];
        var blob = new Blob([bytes], { type: "image/png" });
        var url = URL.createObjectURL(blob);
        var promise = void 0;
        if (typeof Image === "undefined") {
          promise = createImageBitmap(blob).then(function(img) {
            return _this._OnImageReadyAsync(img, engine, expandTexture, rgbdPostProcess, url, face3, i2, generateNonLODTextures, lodTextures, cubeRtt, texture);
          });
        } else {
          var image_1 = new Image();
          image_1.src = url;
          promise = new Promise(function(resolve, reject) {
            image_1.onload = function() {
              _this._OnImageReadyAsync(image_1, engine, expandTexture, rgbdPostProcess, url, face3, i2, generateNonLODTextures, lodTextures, cubeRtt, texture).then(function() {
                return resolve();
              }).catch(function(reason) {
                reject(reason);
              });
            };
            image_1.onerror = function(error) {
              reject(error);
            };
          });
        }
        promises.push(promise);
      };
      for (var face2 = 0; face2 < 6; face2++) {
        _loop_4(face2);
      }
    };
    for (var i = 0; i < imageData.length; i++) {
      _loop_3(i);
    }
    if (imageData.length < mipmapsCount) {
      var data = void 0;
      var size = Math.pow(2, mipmapsCount - 1 - imageData.length);
      var dataLength = size * size * 4;
      switch (texture.type) {
        case 0: {
          data = new Uint8Array(dataLength);
          break;
        }
        case 2: {
          data = new Uint16Array(dataLength);
          break;
        }
        case 1: {
          data = new Float32Array(dataLength);
          break;
        }
      }
      for (var i = imageData.length; i < mipmapsCount; i++) {
        for (var face = 0; face < 6; face++) {
          engine._uploadArrayBufferViewToTexture(texture, data, face, i);
        }
      }
    }
    return Promise.all(promises).then(function() {
      if (cubeRtt) {
        engine._releaseFramebufferObjects(cubeRtt);
        engine._releaseTexture(texture);
        cubeRtt._swapAndDie(texture);
      }
      if (rgbdPostProcess) {
        rgbdPostProcess.dispose();
      }
      if (generateNonLODTextures) {
        if (texture._lodTextureHigh && texture._lodTextureHigh._texture) {
          texture._lodTextureHigh._texture.isReady = true;
        }
        if (texture._lodTextureMid && texture._lodTextureMid._texture) {
          texture._lodTextureMid._texture.isReady = true;
        }
        if (texture._lodTextureLow && texture._lodTextureLow._texture) {
          texture._lodTextureLow._texture.isReady = true;
        }
      }
    });
  };
  EnvironmentTextureTools2.UploadEnvSpherical = function(texture, info) {
    if (info.version !== 1) {
      Logger.Warn('Unsupported babylon environment map version "' + info.version + '"');
    }
    var irradianceInfo = info.irradiance;
    if (!irradianceInfo) {
      return;
    }
    var sp = new SphericalPolynomial();
    Vector3.FromArrayToRef(irradianceInfo.x, 0, sp.x);
    Vector3.FromArrayToRef(irradianceInfo.y, 0, sp.y);
    Vector3.FromArrayToRef(irradianceInfo.z, 0, sp.z);
    Vector3.FromArrayToRef(irradianceInfo.xx, 0, sp.xx);
    Vector3.FromArrayToRef(irradianceInfo.yy, 0, sp.yy);
    Vector3.FromArrayToRef(irradianceInfo.zz, 0, sp.zz);
    Vector3.FromArrayToRef(irradianceInfo.yz, 0, sp.yz);
    Vector3.FromArrayToRef(irradianceInfo.zx, 0, sp.zx);
    Vector3.FromArrayToRef(irradianceInfo.xy, 0, sp.xy);
    texture._sphericalPolynomial = sp;
  };
  EnvironmentTextureTools2._UpdateRGBDAsync = function(internalTexture, data, sphericalPolynomial, lodScale, lodOffset) {
    internalTexture._source = InternalTextureSource.CubeRawRGBD;
    internalTexture._bufferViewArrayArray = data;
    internalTexture._lodGenerationScale = lodScale;
    internalTexture._lodGenerationOffset = lodOffset;
    internalTexture._sphericalPolynomial = sphericalPolynomial;
    return EnvironmentTextureTools2.UploadLevelsAsync(internalTexture, data).then(function() {
      internalTexture.isReady = true;
    });
  };
  EnvironmentTextureTools2._MagicBytes = [134, 22, 135, 150, 246, 214, 150, 54];
  return EnvironmentTextureTools2;
}();
InternalTexture._UpdateRGBDAsync = EnvironmentTextureTools._UpdateRGBDAsync;

// node_modules/@babylonjs/core/Loading/sceneLoader.js
var SceneLoaderAnimationGroupLoadingMode;
(function(SceneLoaderAnimationGroupLoadingMode2) {
  SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["Clean"] = 0] = "Clean";
  SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["Stop"] = 1] = "Stop";
  SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["Sync"] = 2] = "Sync";
  SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["NoSync"] = 3] = "NoSync";
})(SceneLoaderAnimationGroupLoadingMode || (SceneLoaderAnimationGroupLoadingMode = {}));
var SceneLoader = function() {
  function SceneLoader2() {
  }
  Object.defineProperty(SceneLoader2, "ForceFullSceneLoadingForIncremental", {
    get: function() {
      return SceneLoaderFlags.ForceFullSceneLoadingForIncremental;
    },
    set: function(value) {
      SceneLoaderFlags.ForceFullSceneLoadingForIncremental = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneLoader2, "ShowLoadingScreen", {
    get: function() {
      return SceneLoaderFlags.ShowLoadingScreen;
    },
    set: function(value) {
      SceneLoaderFlags.ShowLoadingScreen = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneLoader2, "loggingLevel", {
    get: function() {
      return SceneLoaderFlags.loggingLevel;
    },
    set: function(value) {
      SceneLoaderFlags.loggingLevel = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneLoader2, "CleanBoneMatrixWeights", {
    get: function() {
      return SceneLoaderFlags.CleanBoneMatrixWeights;
    },
    set: function(value) {
      SceneLoaderFlags.CleanBoneMatrixWeights = value;
    },
    enumerable: false,
    configurable: true
  });
  SceneLoader2.GetDefaultPlugin = function() {
    return SceneLoader2._registeredPlugins[".babylon"];
  };
  SceneLoader2._GetPluginForExtension = function(extension) {
    var registeredPlugin = SceneLoader2._registeredPlugins[extension];
    if (registeredPlugin) {
      return registeredPlugin;
    }
    Logger.Warn("Unable to find a plugin to load " + extension + " files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/how_to/load_from_any_file_type");
    return SceneLoader2.GetDefaultPlugin();
  };
  SceneLoader2._GetPluginForDirectLoad = function(data) {
    for (var extension in SceneLoader2._registeredPlugins) {
      var plugin = SceneLoader2._registeredPlugins[extension].plugin;
      if (plugin.canDirectLoad && plugin.canDirectLoad(data)) {
        return SceneLoader2._registeredPlugins[extension];
      }
    }
    return SceneLoader2.GetDefaultPlugin();
  };
  SceneLoader2._GetPluginForFilename = function(sceneFilename) {
    var queryStringPosition = sceneFilename.indexOf("?");
    if (queryStringPosition !== -1) {
      sceneFilename = sceneFilename.substring(0, queryStringPosition);
    }
    var dotPosition = sceneFilename.lastIndexOf(".");
    var extension = sceneFilename.substring(dotPosition, sceneFilename.length).toLowerCase();
    return SceneLoader2._GetPluginForExtension(extension);
  };
  SceneLoader2._GetDirectLoad = function(sceneFilename) {
    if (sceneFilename.substr(0, 5) === "data:") {
      return sceneFilename.substr(5);
    }
    return null;
  };
  SceneLoader2._LoadData = function(fileInfo, scene, onSuccess, onProgress, onError, onDispose, pluginExtension) {
    var directLoad = SceneLoader2._GetDirectLoad(fileInfo.name);
    var registeredPlugin = pluginExtension ? SceneLoader2._GetPluginForExtension(pluginExtension) : directLoad ? SceneLoader2._GetPluginForDirectLoad(fileInfo.name) : SceneLoader2._GetPluginForFilename(fileInfo.name);
    var plugin;
    if (registeredPlugin.plugin.createPlugin !== void 0) {
      plugin = registeredPlugin.plugin.createPlugin();
    } else {
      plugin = registeredPlugin.plugin;
    }
    if (!plugin) {
      throw "The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.";
    }
    SceneLoader2.OnPluginActivatedObservable.notifyObservers(plugin);
    if (directLoad) {
      if (plugin.directLoad) {
        var result = plugin.directLoad(scene, directLoad);
        if (result.then) {
          result.then(function(data) {
            onSuccess(plugin, data);
          }).catch(function(error) {
            onError("Error in directLoad of _loadData: " + error, error);
          });
        } else {
          onSuccess(plugin, result);
        }
      } else {
        onSuccess(plugin, directLoad);
      }
      return plugin;
    }
    var useArrayBuffer = registeredPlugin.isBinary;
    var dataCallback = function(data, responseURL) {
      if (scene.isDisposed) {
        onError("Scene has been disposed");
        return;
      }
      onSuccess(plugin, data, responseURL);
    };
    var request = null;
    var pluginDisposed = false;
    var onDisposeObservable = plugin.onDisposeObservable;
    if (onDisposeObservable) {
      onDisposeObservable.add(function() {
        pluginDisposed = true;
        if (request) {
          request.abort();
          request = null;
        }
        onDispose();
      });
    }
    var manifestChecked = function() {
      if (pluginDisposed) {
        return;
      }
      var successCallback = function(data, request2) {
        dataCallback(data, request2 ? request2.responseURL : void 0);
      };
      var errorCallback2 = function(error) {
        onError(error.message, error);
      };
      request = plugin.requestFile ? plugin.requestFile(scene, fileInfo.url, successCallback, onProgress, useArrayBuffer, errorCallback2) : scene._requestFile(fileInfo.url, successCallback, onProgress, true, useArrayBuffer, errorCallback2);
    };
    var file = fileInfo.file || FilesInputStore.FilesToLoad[fileInfo.name.toLowerCase()];
    if (fileInfo.rootUrl.indexOf("file:") === -1 || fileInfo.rootUrl.indexOf("file:") !== -1 && !file) {
      var engine = scene.getEngine();
      var canUseOfflineSupport = engine.enableOfflineSupport;
      if (canUseOfflineSupport) {
        var exceptionFound = false;
        for (var _i = 0, _a = scene.disableOfflineSupportExceptionRules; _i < _a.length; _i++) {
          var regex = _a[_i];
          if (regex.test(fileInfo.url)) {
            exceptionFound = true;
            break;
          }
        }
        canUseOfflineSupport = !exceptionFound;
      }
      if (canUseOfflineSupport && Engine.OfflineProviderFactory) {
        scene.offlineProvider = Engine.OfflineProviderFactory(fileInfo.url, manifestChecked, engine.disableManifestCheck);
      } else {
        manifestChecked();
      }
    } else {
      if (file) {
        var errorCallback = function(error) {
          onError(error.message, error);
        };
        request = plugin.readFile ? plugin.readFile(scene, file, dataCallback, onProgress, useArrayBuffer, errorCallback) : scene._readFile(file, dataCallback, onProgress, useArrayBuffer, errorCallback);
      } else {
        onError("Unable to find file named " + fileInfo.name);
      }
    }
    return plugin;
  };
  SceneLoader2._GetFileInfo = function(rootUrl, sceneFilename) {
    var url;
    var name42;
    var file = null;
    if (!sceneFilename) {
      url = rootUrl;
      name42 = Tools.GetFilename(rootUrl);
      rootUrl = Tools.GetFolderPath(rootUrl);
    } else if (sceneFilename.name) {
      var sceneFile = sceneFilename;
      url = rootUrl + sceneFile.name;
      name42 = sceneFile.name;
      file = sceneFile;
    } else {
      var filename = sceneFilename;
      if (filename.substr(0, 1) === "/") {
        Tools.Error("Wrong sceneFilename parameter");
        return null;
      }
      url = rootUrl + filename;
      name42 = filename;
    }
    return {
      url,
      rootUrl,
      name: name42,
      file
    };
  };
  SceneLoader2.GetPluginForExtension = function(extension) {
    return SceneLoader2._GetPluginForExtension(extension).plugin;
  };
  SceneLoader2.IsPluginForExtensionAvailable = function(extension) {
    return !!SceneLoader2._registeredPlugins[extension];
  };
  SceneLoader2.RegisterPlugin = function(plugin) {
    if (typeof plugin.extensions === "string") {
      var extension = plugin.extensions;
      SceneLoader2._registeredPlugins[extension.toLowerCase()] = {
        plugin,
        isBinary: false
      };
    } else {
      var extensions = plugin.extensions;
      Object.keys(extensions).forEach(function(extension2) {
        SceneLoader2._registeredPlugins[extension2.toLowerCase()] = {
          plugin,
          isBinary: extensions[extension2].isBinary
        };
      });
    }
  };
  SceneLoader2.ImportMesh = function(meshNames, rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension) {
    if (sceneFilename === void 0) {
      sceneFilename = "";
    }
    if (scene === void 0) {
      scene = EngineStore.LastCreatedScene;
    }
    if (onSuccess === void 0) {
      onSuccess = null;
    }
    if (onProgress === void 0) {
      onProgress = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (pluginExtension === void 0) {
      pluginExtension = null;
    }
    if (!scene) {
      Logger.Error("No scene available to import mesh to");
      return null;
    }
    var fileInfo = SceneLoader2._GetFileInfo(rootUrl, sceneFilename);
    if (!fileInfo) {
      return null;
    }
    var loadingToken = {};
    scene._addPendingData(loadingToken);
    var disposeHandler = function() {
      scene._removePendingData(loadingToken);
    };
    var errorHandler = function(message, exception) {
      var errorMessage = "Unable to import meshes from " + fileInfo.url + ": " + message;
      if (onError) {
        onError(scene, errorMessage, exception);
      } else {
        Logger.Error(errorMessage);
      }
      disposeHandler();
    };
    var progressHandler = onProgress ? function(event) {
      try {
        onProgress(event);
      } catch (e) {
        errorHandler("Error in onProgress callback: " + e, e);
      }
    } : void 0;
    var successHandler = function(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) {
      scene.importedMeshesFiles.push(fileInfo.url);
      if (onSuccess) {
        try {
          onSuccess(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights);
        } catch (e) {
          errorHandler("Error in onSuccess callback: " + e, e);
        }
      }
      scene._removePendingData(loadingToken);
    };
    return SceneLoader2._LoadData(fileInfo, scene, function(plugin, data, responseURL) {
      if (plugin.rewriteRootURL) {
        fileInfo.rootUrl = plugin.rewriteRootURL(fileInfo.rootUrl, responseURL);
      }
      if (plugin.importMesh) {
        var syncedPlugin = plugin;
        var meshes = new Array();
        var particleSystems = new Array();
        var skeletons = new Array();
        if (!syncedPlugin.importMesh(meshNames, scene, data, fileInfo.rootUrl, meshes, particleSystems, skeletons, errorHandler)) {
          return;
        }
        scene.loadingPluginName = plugin.name;
        successHandler(meshes, particleSystems, skeletons, [], [], [], []);
      } else {
        var asyncedPlugin = plugin;
        asyncedPlugin.importMeshAsync(meshNames, scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(function(result) {
          scene.loadingPluginName = plugin.name;
          successHandler(result.meshes, result.particleSystems, result.skeletons, result.animationGroups, result.transformNodes, result.geometries, result.lights);
        }).catch(function(error) {
          errorHandler(error.message, error);
        });
      }
    }, progressHandler, errorHandler, disposeHandler, pluginExtension);
  };
  SceneLoader2.ImportMeshAsync = function(meshNames, rootUrl, sceneFilename, scene, onProgress, pluginExtension) {
    if (sceneFilename === void 0) {
      sceneFilename = "";
    }
    if (scene === void 0) {
      scene = EngineStore.LastCreatedScene;
    }
    if (onProgress === void 0) {
      onProgress = null;
    }
    if (pluginExtension === void 0) {
      pluginExtension = null;
    }
    return new Promise(function(resolve, reject) {
      SceneLoader2.ImportMesh(meshNames, rootUrl, sceneFilename, scene, function(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) {
        resolve({
          meshes,
          particleSystems,
          skeletons,
          animationGroups,
          transformNodes,
          geometries,
          lights
        });
      }, onProgress, function(scene2, message, exception) {
        reject(exception || new Error(message));
      }, pluginExtension);
    });
  };
  SceneLoader2.Load = function(rootUrl, sceneFilename, engine, onSuccess, onProgress, onError, pluginExtension) {
    if (sceneFilename === void 0) {
      sceneFilename = "";
    }
    if (engine === void 0) {
      engine = EngineStore.LastCreatedEngine;
    }
    if (onSuccess === void 0) {
      onSuccess = null;
    }
    if (onProgress === void 0) {
      onProgress = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (pluginExtension === void 0) {
      pluginExtension = null;
    }
    if (!engine) {
      Tools.Error("No engine available");
      return null;
    }
    return SceneLoader2.Append(rootUrl, sceneFilename, new Scene(engine), onSuccess, onProgress, onError, pluginExtension);
  };
  SceneLoader2.LoadAsync = function(rootUrl, sceneFilename, engine, onProgress, pluginExtension) {
    if (sceneFilename === void 0) {
      sceneFilename = "";
    }
    if (engine === void 0) {
      engine = EngineStore.LastCreatedEngine;
    }
    if (onProgress === void 0) {
      onProgress = null;
    }
    if (pluginExtension === void 0) {
      pluginExtension = null;
    }
    return new Promise(function(resolve, reject) {
      SceneLoader2.Load(rootUrl, sceneFilename, engine, function(scene) {
        resolve(scene);
      }, onProgress, function(scene, message, exception) {
        reject(exception || new Error(message));
      }, pluginExtension);
    });
  };
  SceneLoader2.Append = function(rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension) {
    var _this = this;
    if (sceneFilename === void 0) {
      sceneFilename = "";
    }
    if (scene === void 0) {
      scene = EngineStore.LastCreatedScene;
    }
    if (onSuccess === void 0) {
      onSuccess = null;
    }
    if (onProgress === void 0) {
      onProgress = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (pluginExtension === void 0) {
      pluginExtension = null;
    }
    if (!scene) {
      Logger.Error("No scene available to append to");
      return null;
    }
    var fileInfo = SceneLoader2._GetFileInfo(rootUrl, sceneFilename);
    if (!fileInfo) {
      return null;
    }
    if (SceneLoader2.ShowLoadingScreen && !this._showingLoadingScreen) {
      this._showingLoadingScreen = true;
      scene.getEngine().displayLoadingUI();
      scene.executeWhenReady(function() {
        scene.getEngine().hideLoadingUI();
        _this._showingLoadingScreen = false;
      });
    }
    var loadingToken = {};
    scene._addPendingData(loadingToken);
    var disposeHandler = function() {
      scene._removePendingData(loadingToken);
    };
    var errorHandler = function(message, exception) {
      var errorMessage = "Unable to load from " + fileInfo.url + (message ? ": " + message : "");
      if (onError) {
        onError(scene, errorMessage, exception);
      } else {
        Logger.Error(errorMessage);
      }
      disposeHandler();
    };
    var progressHandler = onProgress ? function(event) {
      try {
        onProgress(event);
      } catch (e) {
        errorHandler("Error in onProgress callback", e);
      }
    } : void 0;
    var successHandler = function() {
      if (onSuccess) {
        try {
          onSuccess(scene);
        } catch (e) {
          errorHandler("Error in onSuccess callback", e);
        }
      }
      scene._removePendingData(loadingToken);
    };
    return SceneLoader2._LoadData(fileInfo, scene, function(plugin, data) {
      if (plugin.load) {
        var syncedPlugin = plugin;
        if (!syncedPlugin.load(scene, data, fileInfo.rootUrl, errorHandler)) {
          return;
        }
        scene.loadingPluginName = plugin.name;
        successHandler();
      } else {
        var asyncedPlugin = plugin;
        asyncedPlugin.loadAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(function() {
          scene.loadingPluginName = plugin.name;
          successHandler();
        }).catch(function(error) {
          errorHandler(error.message, error);
        });
      }
    }, progressHandler, errorHandler, disposeHandler, pluginExtension);
  };
  SceneLoader2.AppendAsync = function(rootUrl, sceneFilename, scene, onProgress, pluginExtension) {
    if (sceneFilename === void 0) {
      sceneFilename = "";
    }
    if (scene === void 0) {
      scene = EngineStore.LastCreatedScene;
    }
    if (onProgress === void 0) {
      onProgress = null;
    }
    if (pluginExtension === void 0) {
      pluginExtension = null;
    }
    return new Promise(function(resolve, reject) {
      SceneLoader2.Append(rootUrl, sceneFilename, scene, function(scene2) {
        resolve(scene2);
      }, onProgress, function(scene2, message, exception) {
        reject(exception || new Error(message));
      }, pluginExtension);
    });
  };
  SceneLoader2.LoadAssetContainer = function(rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension) {
    if (sceneFilename === void 0) {
      sceneFilename = "";
    }
    if (scene === void 0) {
      scene = EngineStore.LastCreatedScene;
    }
    if (onSuccess === void 0) {
      onSuccess = null;
    }
    if (onProgress === void 0) {
      onProgress = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (pluginExtension === void 0) {
      pluginExtension = null;
    }
    if (!scene) {
      Logger.Error("No scene available to load asset container to");
      return null;
    }
    var fileInfo = SceneLoader2._GetFileInfo(rootUrl, sceneFilename);
    if (!fileInfo) {
      return null;
    }
    var loadingToken = {};
    scene._addPendingData(loadingToken);
    var disposeHandler = function() {
      scene._removePendingData(loadingToken);
    };
    var errorHandler = function(message, exception) {
      var errorMessage = "Unable to load assets from " + fileInfo.url + (message ? ": " + message : "");
      if (exception && exception.message) {
        errorMessage += " (" + exception.message + ")";
      }
      if (onError) {
        onError(scene, errorMessage, exception);
      } else {
        Logger.Error(errorMessage);
      }
      disposeHandler();
    };
    var progressHandler = onProgress ? function(event) {
      try {
        onProgress(event);
      } catch (e) {
        errorHandler("Error in onProgress callback", e);
      }
    } : void 0;
    var successHandler = function(assets) {
      if (onSuccess) {
        try {
          onSuccess(assets);
        } catch (e) {
          errorHandler("Error in onSuccess callback", e);
        }
      }
      scene._removePendingData(loadingToken);
    };
    return SceneLoader2._LoadData(fileInfo, scene, function(plugin, data) {
      if (plugin.loadAssetContainer) {
        var syncedPlugin = plugin;
        var assetContainer = syncedPlugin.loadAssetContainer(scene, data, fileInfo.rootUrl, errorHandler);
        if (!assetContainer) {
          return;
        }
        scene.loadingPluginName = plugin.name;
        successHandler(assetContainer);
      } else if (plugin.loadAssetContainerAsync) {
        var asyncedPlugin = plugin;
        asyncedPlugin.loadAssetContainerAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(function(assetContainer2) {
          scene.loadingPluginName = plugin.name;
          successHandler(assetContainer2);
        }).catch(function(error) {
          errorHandler(error.message, error);
        });
      } else {
        errorHandler("LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.");
      }
    }, progressHandler, errorHandler, disposeHandler, pluginExtension);
  };
  SceneLoader2.LoadAssetContainerAsync = function(rootUrl, sceneFilename, scene, onProgress, pluginExtension) {
    if (sceneFilename === void 0) {
      sceneFilename = "";
    }
    if (scene === void 0) {
      scene = EngineStore.LastCreatedScene;
    }
    if (onProgress === void 0) {
      onProgress = null;
    }
    if (pluginExtension === void 0) {
      pluginExtension = null;
    }
    return new Promise(function(resolve, reject) {
      SceneLoader2.LoadAssetContainer(rootUrl, sceneFilename, scene, function(assetContainer) {
        resolve(assetContainer);
      }, onProgress, function(scene2, message, exception) {
        reject(exception || new Error(message));
      }, pluginExtension);
    });
  };
  SceneLoader2.ImportAnimations = function(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onSuccess, onProgress, onError, pluginExtension) {
    if (sceneFilename === void 0) {
      sceneFilename = "";
    }
    if (scene === void 0) {
      scene = EngineStore.LastCreatedScene;
    }
    if (overwriteAnimations === void 0) {
      overwriteAnimations = true;
    }
    if (animationGroupLoadingMode === void 0) {
      animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean;
    }
    if (targetConverter === void 0) {
      targetConverter = null;
    }
    if (onSuccess === void 0) {
      onSuccess = null;
    }
    if (onProgress === void 0) {
      onProgress = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (pluginExtension === void 0) {
      pluginExtension = null;
    }
    if (!scene) {
      Logger.Error("No scene available to load animations to");
      return;
    }
    if (overwriteAnimations) {
      for (var _i = 0, _a = scene.animatables; _i < _a.length; _i++) {
        var animatable = _a[_i];
        animatable.reset();
      }
      scene.stopAllAnimations();
      scene.animationGroups.slice().forEach(function(animationGroup) {
        animationGroup.dispose();
      });
      var nodes = scene.getNodes();
      nodes.forEach(function(node) {
        if (node.animations) {
          node.animations = [];
        }
      });
    } else {
      switch (animationGroupLoadingMode) {
        case SceneLoaderAnimationGroupLoadingMode.Clean:
          scene.animationGroups.slice().forEach(function(animationGroup) {
            animationGroup.dispose();
          });
          break;
        case SceneLoaderAnimationGroupLoadingMode.Stop:
          scene.animationGroups.forEach(function(animationGroup) {
            animationGroup.stop();
          });
          break;
        case SceneLoaderAnimationGroupLoadingMode.Sync:
          scene.animationGroups.forEach(function(animationGroup) {
            animationGroup.reset();
            animationGroup.restart();
          });
          break;
        case SceneLoaderAnimationGroupLoadingMode.NoSync:
          break;
        default:
          Logger.Error("Unknown animation group loading mode value '" + animationGroupLoadingMode + "'");
          return;
      }
    }
    var startingIndexForNewAnimatables = scene.animatables.length;
    var onAssetContainerLoaded = function(container) {
      container.mergeAnimationsTo(scene, scene.animatables.slice(startingIndexForNewAnimatables), targetConverter);
      container.dispose();
      scene.onAnimationFileImportedObservable.notifyObservers(scene);
      if (onSuccess) {
        onSuccess(scene);
      }
    };
    this.LoadAssetContainer(rootUrl, sceneFilename, scene, onAssetContainerLoaded, onProgress, onError, pluginExtension);
  };
  SceneLoader2.ImportAnimationsAsync = function(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onSuccess, onProgress, onError, pluginExtension) {
    if (sceneFilename === void 0) {
      sceneFilename = "";
    }
    if (scene === void 0) {
      scene = EngineStore.LastCreatedScene;
    }
    if (overwriteAnimations === void 0) {
      overwriteAnimations = true;
    }
    if (animationGroupLoadingMode === void 0) {
      animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean;
    }
    if (targetConverter === void 0) {
      targetConverter = null;
    }
    if (onSuccess === void 0) {
      onSuccess = null;
    }
    if (onProgress === void 0) {
      onProgress = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (pluginExtension === void 0) {
      pluginExtension = null;
    }
    return new Promise(function(resolve, reject) {
      SceneLoader2.ImportAnimations(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, function(_scene) {
        resolve(_scene);
      }, onProgress, function(_scene, message, exception) {
        reject(exception || new Error(message));
      }, pluginExtension);
    });
  };
  SceneLoader2.NO_LOGGING = 0;
  SceneLoader2.MINIMAL_LOGGING = 1;
  SceneLoader2.SUMMARY_LOGGING = 2;
  SceneLoader2.DETAILED_LOGGING = 3;
  SceneLoader2.OnPluginActivatedObservable = new Observable();
  SceneLoader2._registeredPlugins = {};
  SceneLoader2._showingLoadingScreen = false;
  return SceneLoader2;
}();

// node_modules/@babylonjs/core/Lights/shadowLight.js
var ShadowLight = function(_super) {
  __extends(ShadowLight2, _super);
  function ShadowLight2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._needProjectionMatrixCompute = true;
    return _this;
  }
  ShadowLight2.prototype._setPosition = function(value) {
    this._position = value;
  };
  Object.defineProperty(ShadowLight2.prototype, "position", {
    get: function() {
      return this._position;
    },
    set: function(value) {
      this._setPosition(value);
    },
    enumerable: false,
    configurable: true
  });
  ShadowLight2.prototype._setDirection = function(value) {
    this._direction = value;
  };
  Object.defineProperty(ShadowLight2.prototype, "direction", {
    get: function() {
      return this._direction;
    },
    set: function(value) {
      this._setDirection(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowLight2.prototype, "shadowMinZ", {
    get: function() {
      return this._shadowMinZ;
    },
    set: function(value) {
      this._shadowMinZ = value;
      this.forceProjectionMatrixCompute();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowLight2.prototype, "shadowMaxZ", {
    get: function() {
      return this._shadowMaxZ;
    },
    set: function(value) {
      this._shadowMaxZ = value;
      this.forceProjectionMatrixCompute();
    },
    enumerable: false,
    configurable: true
  });
  ShadowLight2.prototype.computeTransformedInformation = function() {
    if (this.parent && this.parent.getWorldMatrix) {
      if (!this.transformedPosition) {
        this.transformedPosition = Vector3.Zero();
      }
      Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this.transformedPosition);
      if (this.direction) {
        if (!this.transformedDirection) {
          this.transformedDirection = Vector3.Zero();
        }
        Vector3.TransformNormalToRef(this.direction, this.parent.getWorldMatrix(), this.transformedDirection);
      }
      return true;
    }
    return false;
  };
  ShadowLight2.prototype.getDepthScale = function() {
    return 50;
  };
  ShadowLight2.prototype.getShadowDirection = function(faceIndex) {
    return this.transformedDirection ? this.transformedDirection : this.direction;
  };
  ShadowLight2.prototype.getAbsolutePosition = function() {
    return this.transformedPosition ? this.transformedPosition : this.position;
  };
  ShadowLight2.prototype.setDirectionToTarget = function(target) {
    this.direction = Vector3.Normalize(target.subtract(this.position));
    return this.direction;
  };
  ShadowLight2.prototype.getRotation = function() {
    this.direction.normalize();
    var xaxis = Vector3.Cross(this.direction, Axis.Y);
    var yaxis = Vector3.Cross(xaxis, this.direction);
    return Vector3.RotationFromAxis(xaxis, yaxis, this.direction);
  };
  ShadowLight2.prototype.needCube = function() {
    return false;
  };
  ShadowLight2.prototype.needProjectionMatrixCompute = function() {
    return this._needProjectionMatrixCompute;
  };
  ShadowLight2.prototype.forceProjectionMatrixCompute = function() {
    this._needProjectionMatrixCompute = true;
  };
  ShadowLight2.prototype._initCache = function() {
    _super.prototype._initCache.call(this);
    this._cache.position = Vector3.Zero();
  };
  ShadowLight2.prototype._isSynchronized = function() {
    if (!this._cache.position.equals(this.position)) {
      return false;
    }
    return true;
  };
  ShadowLight2.prototype.computeWorldMatrix = function(force) {
    if (!force && this.isSynchronized()) {
      this._currentRenderId = this.getScene().getRenderId();
      return this._worldMatrix;
    }
    this._updateCache();
    this._cache.position.copyFrom(this.position);
    if (!this._worldMatrix) {
      this._worldMatrix = Matrix.Identity();
    }
    Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix);
    if (this.parent && this.parent.getWorldMatrix) {
      this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(), this._worldMatrix);
      this._markSyncedWithParent();
    }
    this._worldMatrixDeterminantIsDirty = true;
    return this._worldMatrix;
  };
  ShadowLight2.prototype.getDepthMinZ = function(activeCamera) {
    return this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ;
  };
  ShadowLight2.prototype.getDepthMaxZ = function(activeCamera) {
    return this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ;
  };
  ShadowLight2.prototype.setShadowProjectionMatrix = function(matrix, viewMatrix, renderList) {
    if (this.customProjectionMatrixBuilder) {
      this.customProjectionMatrixBuilder(viewMatrix, renderList, matrix);
    } else {
      this._setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList);
    }
    return this;
  };
  __decorate([
    serializeAsVector3()
  ], ShadowLight2.prototype, "position", null);
  __decorate([
    serializeAsVector3()
  ], ShadowLight2.prototype, "direction", null);
  __decorate([
    serialize()
  ], ShadowLight2.prototype, "shadowMinZ", null);
  __decorate([
    serialize()
  ], ShadowLight2.prototype, "shadowMaxZ", null);
  return ShadowLight2;
}(Light);

// node_modules/@babylonjs/core/Lights/directionalLight.js
Node.AddNodeConstructor("Light_Type_1", function(name42, scene) {
  return function() {
    return new DirectionalLight(name42, Vector3.Zero(), scene);
  };
});
var DirectionalLight = function(_super) {
  __extends(DirectionalLight2, _super);
  function DirectionalLight2(name42, direction, scene) {
    var _this = _super.call(this, name42, scene) || this;
    _this._shadowFrustumSize = 0;
    _this._shadowOrthoScale = 0.1;
    _this.autoUpdateExtends = true;
    _this.autoCalcShadowZBounds = false;
    _this._orthoLeft = Number.MAX_VALUE;
    _this._orthoRight = Number.MIN_VALUE;
    _this._orthoTop = Number.MIN_VALUE;
    _this._orthoBottom = Number.MAX_VALUE;
    _this.position = direction.scale(-1);
    _this.direction = direction;
    return _this;
  }
  Object.defineProperty(DirectionalLight2.prototype, "shadowFrustumSize", {
    get: function() {
      return this._shadowFrustumSize;
    },
    set: function(value) {
      this._shadowFrustumSize = value;
      this.forceProjectionMatrixCompute();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DirectionalLight2.prototype, "shadowOrthoScale", {
    get: function() {
      return this._shadowOrthoScale;
    },
    set: function(value) {
      this._shadowOrthoScale = value;
      this.forceProjectionMatrixCompute();
    },
    enumerable: false,
    configurable: true
  });
  DirectionalLight2.prototype.getClassName = function() {
    return "DirectionalLight";
  };
  DirectionalLight2.prototype.getTypeID = function() {
    return Light.LIGHTTYPEID_DIRECTIONALLIGHT;
  };
  DirectionalLight2.prototype._setDefaultShadowProjectionMatrix = function(matrix, viewMatrix, renderList) {
    if (this.shadowFrustumSize > 0) {
      this._setDefaultFixedFrustumShadowProjectionMatrix(matrix);
    } else {
      this._setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList);
    }
  };
  DirectionalLight2.prototype._setDefaultFixedFrustumShadowProjectionMatrix = function(matrix) {
    var activeCamera = this.getScene().activeCamera;
    if (!activeCamera) {
      return;
    }
    Matrix.OrthoLHToRef(this.shadowFrustumSize, this.shadowFrustumSize, this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ, this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ, matrix);
  };
  DirectionalLight2.prototype._setDefaultAutoExtendShadowProjectionMatrix = function(matrix, viewMatrix, renderList) {
    var activeCamera = this.getScene().activeCamera;
    if (!activeCamera) {
      return;
    }
    if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {
      var tempVector3 = Vector3.Zero();
      this._orthoLeft = Number.MAX_VALUE;
      this._orthoRight = Number.MIN_VALUE;
      this._orthoTop = Number.MIN_VALUE;
      this._orthoBottom = Number.MAX_VALUE;
      var shadowMinZ = Number.MAX_VALUE;
      var shadowMaxZ = Number.MIN_VALUE;
      for (var meshIndex = 0; meshIndex < renderList.length; meshIndex++) {
        var mesh = renderList[meshIndex];
        if (!mesh) {
          continue;
        }
        var boundingInfo = mesh.getBoundingInfo();
        var boundingBox = boundingInfo.boundingBox;
        for (var index = 0; index < boundingBox.vectorsWorld.length; index++) {
          Vector3.TransformCoordinatesToRef(boundingBox.vectorsWorld[index], viewMatrix, tempVector3);
          if (tempVector3.x < this._orthoLeft) {
            this._orthoLeft = tempVector3.x;
          }
          if (tempVector3.y < this._orthoBottom) {
            this._orthoBottom = tempVector3.y;
          }
          if (tempVector3.x > this._orthoRight) {
            this._orthoRight = tempVector3.x;
          }
          if (tempVector3.y > this._orthoTop) {
            this._orthoTop = tempVector3.y;
          }
          if (this.autoCalcShadowZBounds) {
            if (tempVector3.z < shadowMinZ) {
              shadowMinZ = tempVector3.z;
            }
            if (tempVector3.z > shadowMaxZ) {
              shadowMaxZ = tempVector3.z;
            }
          }
        }
      }
      if (this.autoCalcShadowZBounds) {
        this._shadowMinZ = shadowMinZ;
        this._shadowMaxZ = shadowMaxZ;
      }
    }
    var xOffset = this._orthoRight - this._orthoLeft;
    var yOffset = this._orthoTop - this._orthoBottom;
    Matrix.OrthoOffCenterLHToRef(this._orthoLeft - xOffset * this.shadowOrthoScale, this._orthoRight + xOffset * this.shadowOrthoScale, this._orthoBottom - yOffset * this.shadowOrthoScale, this._orthoTop + yOffset * this.shadowOrthoScale, this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ, this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ, matrix);
  };
  DirectionalLight2.prototype._buildUniformLayout = function() {
    this._uniformBuffer.addUniform("vLightData", 4);
    this._uniformBuffer.addUniform("vLightDiffuse", 4);
    this._uniformBuffer.addUniform("vLightSpecular", 4);
    this._uniformBuffer.addUniform("shadowsInfo", 3);
    this._uniformBuffer.addUniform("depthValues", 2);
    this._uniformBuffer.create();
  };
  DirectionalLight2.prototype.transferToEffect = function(effect, lightIndex) {
    if (this.computeTransformedInformation()) {
      this._uniformBuffer.updateFloat4("vLightData", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, lightIndex);
      return this;
    }
    this._uniformBuffer.updateFloat4("vLightData", this.direction.x, this.direction.y, this.direction.z, 1, lightIndex);
    return this;
  };
  DirectionalLight2.prototype.transferToNodeMaterialEffect = function(effect, lightDataUniformName) {
    if (this.computeTransformedInformation()) {
      effect.setFloat3(lightDataUniformName, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z);
      return this;
    }
    effect.setFloat3(lightDataUniformName, this.direction.x, this.direction.y, this.direction.z);
    return this;
  };
  DirectionalLight2.prototype.getDepthMinZ = function(activeCamera) {
    return 1;
  };
  DirectionalLight2.prototype.getDepthMaxZ = function(activeCamera) {
    return 1;
  };
  DirectionalLight2.prototype.prepareLightSpecificDefines = function(defines, lightIndex) {
    defines["DIRLIGHT" + lightIndex] = true;
  };
  __decorate([
    serialize()
  ], DirectionalLight2.prototype, "shadowFrustumSize", null);
  __decorate([
    serialize()
  ], DirectionalLight2.prototype, "shadowOrthoScale", null);
  __decorate([
    serialize()
  ], DirectionalLight2.prototype, "autoUpdateExtends", void 0);
  __decorate([
    serialize()
  ], DirectionalLight2.prototype, "autoCalcShadowZBounds", void 0);
  return DirectionalLight2;
}(ShadowLight);

// node_modules/@babylonjs/core/Lights/spotLight.js
Node.AddNodeConstructor("Light_Type_2", function(name42, scene) {
  return function() {
    return new SpotLight(name42, Vector3.Zero(), Vector3.Zero(), 0, 0, scene);
  };
});
var SpotLight = function(_super) {
  __extends(SpotLight2, _super);
  function SpotLight2(name42, position, direction, angle, exponent, scene) {
    var _this = _super.call(this, name42, scene) || this;
    _this._innerAngle = 0;
    _this._projectionTextureMatrix = Matrix.Zero();
    _this._projectionTextureLightNear = 1e-6;
    _this._projectionTextureLightFar = 1e3;
    _this._projectionTextureUpDirection = Vector3.Up();
    _this._projectionTextureViewLightDirty = true;
    _this._projectionTextureProjectionLightDirty = true;
    _this._projectionTextureDirty = true;
    _this._projectionTextureViewTargetVector = Vector3.Zero();
    _this._projectionTextureViewLightMatrix = Matrix.Zero();
    _this._projectionTextureProjectionLightMatrix = Matrix.Zero();
    _this._projectionTextureScalingMatrix = Matrix.FromValues(0.5, 0, 0, 0, 0, 0.5, 0, 0, 0, 0, 0.5, 0, 0.5, 0.5, 0.5, 1);
    _this.position = position;
    _this.direction = direction;
    _this.angle = angle;
    _this.exponent = exponent;
    return _this;
  }
  Object.defineProperty(SpotLight2.prototype, "angle", {
    get: function() {
      return this._angle;
    },
    set: function(value) {
      this._angle = value;
      this._cosHalfAngle = Math.cos(value * 0.5);
      this._projectionTextureProjectionLightDirty = true;
      this.forceProjectionMatrixCompute();
      this._computeAngleValues();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SpotLight2.prototype, "innerAngle", {
    get: function() {
      return this._innerAngle;
    },
    set: function(value) {
      this._innerAngle = value;
      this._computeAngleValues();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SpotLight2.prototype, "shadowAngleScale", {
    get: function() {
      return this._shadowAngleScale;
    },
    set: function(value) {
      this._shadowAngleScale = value;
      this.forceProjectionMatrixCompute();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SpotLight2.prototype, "projectionTextureMatrix", {
    get: function() {
      return this._projectionTextureMatrix;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SpotLight2.prototype, "projectionTextureLightNear", {
    get: function() {
      return this._projectionTextureLightNear;
    },
    set: function(value) {
      this._projectionTextureLightNear = value;
      this._projectionTextureProjectionLightDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SpotLight2.prototype, "projectionTextureLightFar", {
    get: function() {
      return this._projectionTextureLightFar;
    },
    set: function(value) {
      this._projectionTextureLightFar = value;
      this._projectionTextureProjectionLightDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SpotLight2.prototype, "projectionTextureUpDirection", {
    get: function() {
      return this._projectionTextureUpDirection;
    },
    set: function(value) {
      this._projectionTextureUpDirection = value;
      this._projectionTextureProjectionLightDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SpotLight2.prototype, "projectionTexture", {
    get: function() {
      return this._projectionTexture;
    },
    set: function(value) {
      var _this = this;
      if (this._projectionTexture === value) {
        return;
      }
      this._projectionTexture = value;
      this._projectionTextureDirty = true;
      if (this._projectionTexture && !this._projectionTexture.isReady()) {
        if (SpotLight2._IsProceduralTexture(this._projectionTexture)) {
          this._projectionTexture.getEffect().executeWhenCompiled(function() {
            _this._markMeshesAsLightDirty();
          });
        } else if (SpotLight2._IsTexture(this._projectionTexture)) {
          this._projectionTexture.onLoadObservable.addOnce(function() {
            _this._markMeshesAsLightDirty();
          });
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  SpotLight2._IsProceduralTexture = function(texture) {
    return texture.onGeneratedObservable !== void 0;
  };
  SpotLight2._IsTexture = function(texture) {
    return texture.onLoadObservable !== void 0;
  };
  SpotLight2.prototype.getClassName = function() {
    return "SpotLight";
  };
  SpotLight2.prototype.getTypeID = function() {
    return Light.LIGHTTYPEID_SPOTLIGHT;
  };
  SpotLight2.prototype._setDirection = function(value) {
    _super.prototype._setDirection.call(this, value);
    this._projectionTextureViewLightDirty = true;
  };
  SpotLight2.prototype._setPosition = function(value) {
    _super.prototype._setPosition.call(this, value);
    this._projectionTextureViewLightDirty = true;
  };
  SpotLight2.prototype._setDefaultShadowProjectionMatrix = function(matrix, viewMatrix, renderList) {
    var activeCamera = this.getScene().activeCamera;
    if (!activeCamera) {
      return;
    }
    this._shadowAngleScale = this._shadowAngleScale || 1;
    var angle = this._shadowAngleScale * this._angle;
    Matrix.PerspectiveFovLHToRef(angle, 1, this.getDepthMinZ(activeCamera), this.getDepthMaxZ(activeCamera), matrix);
  };
  SpotLight2.prototype._computeProjectionTextureViewLightMatrix = function() {
    this._projectionTextureViewLightDirty = false;
    this._projectionTextureDirty = true;
    this.position.addToRef(this.direction, this._projectionTextureViewTargetVector);
    Matrix.LookAtLHToRef(this.position, this._projectionTextureViewTargetVector, this._projectionTextureUpDirection, this._projectionTextureViewLightMatrix);
  };
  SpotLight2.prototype._computeProjectionTextureProjectionLightMatrix = function() {
    this._projectionTextureProjectionLightDirty = false;
    this._projectionTextureDirty = true;
    var light_far = this.projectionTextureLightFar;
    var light_near = this.projectionTextureLightNear;
    var P = light_far / (light_far - light_near);
    var Q = -P * light_near;
    var S = 1 / Math.tan(this._angle / 2);
    var A = 1;
    Matrix.FromValuesToRef(S / A, 0, 0, 0, 0, S, 0, 0, 0, 0, P, 1, 0, 0, Q, 0, this._projectionTextureProjectionLightMatrix);
  };
  SpotLight2.prototype._computeProjectionTextureMatrix = function() {
    this._projectionTextureDirty = false;
    this._projectionTextureViewLightMatrix.multiplyToRef(this._projectionTextureProjectionLightMatrix, this._projectionTextureMatrix);
    if (this._projectionTexture instanceof Texture) {
      var u = this._projectionTexture.uScale / 2;
      var v = this._projectionTexture.vScale / 2;
      Matrix.FromValuesToRef(u, 0, 0, 0, 0, v, 0, 0, 0, 0, 0.5, 0, 0.5, 0.5, 0.5, 1, this._projectionTextureScalingMatrix);
    }
    this._projectionTextureMatrix.multiplyToRef(this._projectionTextureScalingMatrix, this._projectionTextureMatrix);
  };
  SpotLight2.prototype._buildUniformLayout = function() {
    this._uniformBuffer.addUniform("vLightData", 4);
    this._uniformBuffer.addUniform("vLightDiffuse", 4);
    this._uniformBuffer.addUniform("vLightSpecular", 4);
    this._uniformBuffer.addUniform("vLightDirection", 3);
    this._uniformBuffer.addUniform("vLightFalloff", 4);
    this._uniformBuffer.addUniform("shadowsInfo", 3);
    this._uniformBuffer.addUniform("depthValues", 2);
    this._uniformBuffer.create();
  };
  SpotLight2.prototype._computeAngleValues = function() {
    this._lightAngleScale = 1 / Math.max(1e-3, Math.cos(this._innerAngle * 0.5) - this._cosHalfAngle);
    this._lightAngleOffset = -this._cosHalfAngle * this._lightAngleScale;
  };
  SpotLight2.prototype.transferTexturesToEffect = function(effect, lightIndex) {
    if (this.projectionTexture && this.projectionTexture.isReady()) {
      if (this._projectionTextureViewLightDirty) {
        this._computeProjectionTextureViewLightMatrix();
      }
      if (this._projectionTextureProjectionLightDirty) {
        this._computeProjectionTextureProjectionLightMatrix();
      }
      if (this._projectionTextureDirty) {
        this._computeProjectionTextureMatrix();
      }
      effect.setMatrix("textureProjectionMatrix" + lightIndex, this._projectionTextureMatrix);
      effect.setTexture("projectionLightSampler" + lightIndex, this.projectionTexture);
    }
    return this;
  };
  SpotLight2.prototype.transferToEffect = function(effect, lightIndex) {
    var normalizeDirection;
    if (this.computeTransformedInformation()) {
      this._uniformBuffer.updateFloat4("vLightData", this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z, this.exponent, lightIndex);
      normalizeDirection = Vector3.Normalize(this.transformedDirection);
    } else {
      this._uniformBuffer.updateFloat4("vLightData", this.position.x, this.position.y, this.position.z, this.exponent, lightIndex);
      normalizeDirection = Vector3.Normalize(this.direction);
    }
    this._uniformBuffer.updateFloat4("vLightDirection", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, this._cosHalfAngle, lightIndex);
    this._uniformBuffer.updateFloat4("vLightFalloff", this.range, this._inverseSquaredRange, this._lightAngleScale, this._lightAngleOffset, lightIndex);
    return this;
  };
  SpotLight2.prototype.transferToNodeMaterialEffect = function(effect, lightDataUniformName) {
    var normalizeDirection;
    if (this.computeTransformedInformation()) {
      normalizeDirection = Vector3.Normalize(this.transformedDirection);
    } else {
      normalizeDirection = Vector3.Normalize(this.direction);
    }
    if (this.getScene().useRightHandedSystem) {
      effect.setFloat3(lightDataUniformName, -normalizeDirection.x, -normalizeDirection.y, -normalizeDirection.z);
    } else {
      effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);
    }
    return this;
  };
  SpotLight2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    if (this._projectionTexture) {
      this._projectionTexture.dispose();
    }
  };
  SpotLight2.prototype.prepareLightSpecificDefines = function(defines, lightIndex) {
    defines["SPOTLIGHT" + lightIndex] = true;
    defines["PROJECTEDLIGHTTEXTURE" + lightIndex] = this.projectionTexture && this.projectionTexture.isReady() ? true : false;
  };
  __decorate([
    serialize()
  ], SpotLight2.prototype, "angle", null);
  __decorate([
    serialize()
  ], SpotLight2.prototype, "innerAngle", null);
  __decorate([
    serialize()
  ], SpotLight2.prototype, "shadowAngleScale", null);
  __decorate([
    serialize()
  ], SpotLight2.prototype, "exponent", void 0);
  __decorate([
    serialize()
  ], SpotLight2.prototype, "projectionTextureLightNear", null);
  __decorate([
    serialize()
  ], SpotLight2.prototype, "projectionTextureLightFar", null);
  __decorate([
    serialize()
  ], SpotLight2.prototype, "projectionTextureUpDirection", null);
  __decorate([
    serializeAsTexture("projectedLightTexture")
  ], SpotLight2.prototype, "_projectionTexture", void 0);
  return SpotLight2;
}(ShadowLight);

// node_modules/@babylonjs/core/Engines/Extensions/engine.cubeTexture.js
ThinEngine.prototype._createDepthStencilCubeTexture = function(size, options) {
  var internalTexture = new InternalTexture(this, InternalTextureSource.Unknown);
  internalTexture.isCube = true;
  if (this.webGLVersion === 1) {
    Logger.Error("Depth cube texture is not supported by WebGL 1.");
    return internalTexture;
  }
  var internalOptions = __assign({ bilinearFiltering: false, comparisonFunction: 0, generateStencil: false }, options);
  var gl = this._gl;
  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, internalTexture, true);
  this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.bilinearFiltering, internalOptions.comparisonFunction);
  for (var face = 0; face < 6; face++) {
    if (internalOptions.generateStencil) {
      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH24_STENCIL8, size, size, 0, gl.DEPTH_STENCIL, gl.UNSIGNED_INT_24_8, null);
    } else {
      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH_COMPONENT24, size, size, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);
    }
  }
  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
  return internalTexture;
};
ThinEngine.prototype._partialLoadFile = function(url, index, loadedFiles, onfinish, onErrorCallBack) {
  if (onErrorCallBack === void 0) {
    onErrorCallBack = null;
  }
  var onload = function(data) {
    loadedFiles[index] = data;
    loadedFiles._internalCount++;
    if (loadedFiles._internalCount === 6) {
      onfinish(loadedFiles);
    }
  };
  var onerror = function(request, exception) {
    if (onErrorCallBack && request) {
      onErrorCallBack(request.status + " " + request.statusText, exception);
    }
  };
  this._loadFile(url, onload, void 0, void 0, true, onerror);
};
ThinEngine.prototype._cascadeLoadFiles = function(scene, onfinish, files, onError) {
  if (onError === void 0) {
    onError = null;
  }
  var loadedFiles = [];
  loadedFiles._internalCount = 0;
  for (var index = 0; index < 6; index++) {
    this._partialLoadFile(files[index], index, loadedFiles, onfinish, onError);
  }
};
ThinEngine.prototype._cascadeLoadImgs = function(scene, onfinish, files, onError, mimeType) {
  if (onError === void 0) {
    onError = null;
  }
  var loadedImages = [];
  loadedImages._internalCount = 0;
  for (var index = 0; index < 6; index++) {
    this._partialLoadImg(files[index], index, loadedImages, scene, onfinish, onError, mimeType);
  }
};
ThinEngine.prototype._partialLoadImg = function(url, index, loadedImages, scene, onfinish, onErrorCallBack, mimeType) {
  if (onErrorCallBack === void 0) {
    onErrorCallBack = null;
  }
  var img;
  var onload = function() {
    if (img) {
      loadedImages[index] = img;
      loadedImages._internalCount++;
      if (scene) {
        scene._removePendingData(img);
      }
    }
    if (loadedImages._internalCount === 6) {
      onfinish(loadedImages);
    }
  };
  var onerror = function(message, exception) {
    if (scene) {
      scene._removePendingData(img);
    }
    if (onErrorCallBack) {
      onErrorCallBack(message, exception);
    }
  };
  img = FileTools.LoadImage(url, onload, onerror, scene ? scene.offlineProvider : null, mimeType);
  if (scene && img) {
    scene._addPendingData(img);
  }
};
ThinEngine.prototype._setCubeMapTextureParams = function(texture, loadMipmap) {
  var gl = this._gl;
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, loadMipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  texture.samplingMode = loadMipmap ? 3 : 2;
  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
};
ThinEngine.prototype.createCubeTexture = function(rootUrl, scene, files, noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, fallback, loaderOptions) {
  var _this = this;
  if (onLoad === void 0) {
    onLoad = null;
  }
  if (onError === void 0) {
    onError = null;
  }
  if (forcedExtension === void 0) {
    forcedExtension = null;
  }
  if (createPolynomials === void 0) {
    createPolynomials = false;
  }
  if (lodScale === void 0) {
    lodScale = 0;
  }
  if (lodOffset === void 0) {
    lodOffset = 0;
  }
  if (fallback === void 0) {
    fallback = null;
  }
  var gl = this._gl;
  var texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Cube);
  texture.isCube = true;
  texture.url = rootUrl;
  texture.generateMipMaps = !noMipmap;
  texture._lodGenerationScale = lodScale;
  texture._lodGenerationOffset = lodOffset;
  if (!this._doNotHandleContextLost) {
    texture._extension = forcedExtension;
    texture._files = files;
  }
  var originalRootUrl = rootUrl;
  if (this._transformTextureUrl && !fallback) {
    rootUrl = this._transformTextureUrl(rootUrl);
  }
  var lastDot = rootUrl.lastIndexOf(".");
  var extension = forcedExtension ? forcedExtension : lastDot > -1 ? rootUrl.substring(lastDot).toLowerCase() : "";
  var loader = null;
  for (var _i = 0, _a = ThinEngine._TextureLoaders; _i < _a.length; _i++) {
    var availableLoader = _a[_i];
    if (availableLoader.canLoad(extension)) {
      loader = availableLoader;
      break;
    }
  }
  var onInternalError = function(request, exception) {
    if (rootUrl === originalRootUrl) {
      if (onError && request) {
        onError(request.status + " " + request.statusText, exception);
      }
    } else {
      Logger.Warn("Failed to load " + rootUrl + ", falling back to the " + originalRootUrl);
      _this.createCubeTexture(originalRootUrl, scene, files, noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, texture, loaderOptions);
    }
  };
  if (loader) {
    var onloaddata_1 = function(data) {
      _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
      loader.loadCubeData(data, texture, createPolynomials, onLoad, onError);
    };
    if (files && files.length === 6) {
      if (loader.supportCascades) {
        this._cascadeLoadFiles(scene, function(images) {
          return onloaddata_1(images.map(function(image) {
            return new Uint8Array(image);
          }));
        }, files, onError);
      } else {
        if (onError) {
          onError("Textures type does not support cascades.");
        } else {
          Logger.Warn("Texture loader does not support cascades.");
        }
      }
    } else {
      this._loadFile(rootUrl, function(data) {
        return onloaddata_1(new Uint8Array(data));
      }, void 0, void 0, true, onInternalError);
    }
  } else {
    if (!files) {
      throw new Error("Cannot load cubemap because files were not defined");
    }
    this._cascadeLoadImgs(scene, function(imgs) {
      var width = _this.needPOTTextures ? ThinEngine.GetExponentOfTwo(imgs[0].width, _this._caps.maxCubemapTextureSize) : imgs[0].width;
      var height = width;
      var faces = [
        gl.TEXTURE_CUBE_MAP_POSITIVE_X,
        gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
        gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
        gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
        gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
        gl.TEXTURE_CUBE_MAP_NEGATIVE_Z
      ];
      _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
      _this._unpackFlipY(false);
      var internalFormat = format ? _this._getInternalFormat(format) : _this._gl.RGBA;
      for (var index = 0; index < faces.length; index++) {
        if (imgs[index].width !== width || imgs[index].height !== height) {
          _this._prepareWorkingCanvas();
          if (!_this._workingCanvas || !_this._workingContext) {
            Logger.Warn("Cannot create canvas to resize texture.");
            return;
          }
          _this._workingCanvas.width = width;
          _this._workingCanvas.height = height;
          _this._workingContext.drawImage(imgs[index], 0, 0, imgs[index].width, imgs[index].height, 0, 0, width, height);
          gl.texImage2D(faces[index], 0, internalFormat, internalFormat, gl.UNSIGNED_BYTE, _this._workingCanvas);
        } else {
          gl.texImage2D(faces[index], 0, internalFormat, internalFormat, gl.UNSIGNED_BYTE, imgs[index]);
        }
      }
      if (!noMipmap) {
        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
      }
      _this._setCubeMapTextureParams(texture, !noMipmap);
      texture.width = width;
      texture.height = height;
      texture.isReady = true;
      if (format) {
        texture.format = format;
      }
      texture.onLoadedObservable.notifyObservers(texture);
      texture.onLoadedObservable.clear();
      if (onLoad) {
        onLoad();
      }
    }, files, onError);
  }
  this._internalTexturesCache.push(texture);
  return texture;
};

// node_modules/@babylonjs/core/Materials/Textures/cubeTexture.js
var CubeTexture = function(_super) {
  __extends(CubeTexture2, _super);
  function CubeTexture2(rootUrl, sceneOrEngine, extensions, noMipmap, files, onLoad, onError, format, prefiltered, forcedExtension, createPolynomials, lodScale, lodOffset, loaderOptions) {
    if (extensions === void 0) {
      extensions = null;
    }
    if (noMipmap === void 0) {
      noMipmap = false;
    }
    if (files === void 0) {
      files = null;
    }
    if (onLoad === void 0) {
      onLoad = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (format === void 0) {
      format = 5;
    }
    if (prefiltered === void 0) {
      prefiltered = false;
    }
    if (forcedExtension === void 0) {
      forcedExtension = null;
    }
    if (createPolynomials === void 0) {
      createPolynomials = false;
    }
    if (lodScale === void 0) {
      lodScale = 0.8;
    }
    if (lodOffset === void 0) {
      lodOffset = 0;
    }
    var _a;
    var _this = _super.call(this, sceneOrEngine) || this;
    _this.onLoadObservable = new Observable();
    _this.boundingBoxPosition = Vector3.Zero();
    _this._rotationY = 0;
    _this._files = null;
    _this._forcedExtension = null;
    _this._extensions = null;
    _this.name = rootUrl;
    _this.url = rootUrl;
    _this._noMipmap = noMipmap;
    _this.hasAlpha = false;
    _this._format = format;
    _this.isCube = true;
    _this._textureMatrix = Matrix.Identity();
    _this._createPolynomials = createPolynomials;
    _this.coordinatesMode = Texture.CUBIC_MODE;
    _this._extensions = extensions;
    _this._files = files;
    _this._forcedExtension = forcedExtension;
    _this._loaderOptions = loaderOptions;
    if (!rootUrl && !files) {
      return _this;
    }
    var lastDot = rootUrl.lastIndexOf(".");
    var extension = forcedExtension ? forcedExtension : lastDot > -1 ? rootUrl.substring(lastDot).toLowerCase() : "";
    var isDDS = extension === ".dds";
    var isEnv = extension === ".env";
    if (isEnv) {
      _this.gammaSpace = false;
      _this._prefiltered = false;
      _this.anisotropicFilteringLevel = 1;
    } else {
      _this._prefiltered = prefiltered;
      if (prefiltered) {
        _this.gammaSpace = false;
        _this.anisotropicFilteringLevel = 1;
      }
    }
    _this._texture = _this._getFromCache(rootUrl, noMipmap);
    if (!files) {
      if (!isEnv && !isDDS && !extensions) {
        extensions = ["_px.jpg", "_py.jpg", "_pz.jpg", "_nx.jpg", "_ny.jpg", "_nz.jpg"];
      }
      files = [];
      if (extensions) {
        for (var index = 0; index < extensions.length; index++) {
          files.push(rootUrl + extensions[index]);
        }
      }
    }
    _this._files = files;
    var onLoadProcessing = function() {
      _this.onLoadObservable.notifyObservers(_this);
      if (onLoad) {
        onLoad();
      }
    };
    if (!_this._texture) {
      var scene = _this.getScene();
      if (!(scene === null || scene === void 0 ? void 0 : scene.useDelayedTextureLoading)) {
        if (prefiltered) {
          _this._texture = _this._getEngine().createPrefilteredCubeTexture(rootUrl, scene, lodScale, lodOffset, onLoad, onError, format, forcedExtension, _this._createPolynomials);
        } else {
          _this._texture = _this._getEngine().createCubeTexture(rootUrl, scene, files, noMipmap, onLoad, onError, _this._format, forcedExtension, false, lodScale, lodOffset, null, loaderOptions);
        }
        (_a = _this._texture) === null || _a === void 0 ? void 0 : _a.onLoadedObservable.add(function() {
          return _this.onLoadObservable.notifyObservers(_this);
        });
      } else {
        _this.delayLoadState = 4;
      }
    } else {
      if (_this._texture.isReady) {
        Tools.SetImmediate(function() {
          return onLoadProcessing();
        });
      } else {
        _this._texture.onLoadedObservable.add(function() {
          return onLoadProcessing();
        });
      }
    }
    return _this;
  }
  Object.defineProperty(CubeTexture2.prototype, "boundingBoxSize", {
    get: function() {
      return this._boundingBoxSize;
    },
    set: function(value) {
      if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {
        return;
      }
      this._boundingBoxSize = value;
      var scene = this.getScene();
      if (scene) {
        scene.markAllMaterialsAsDirty(1);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CubeTexture2.prototype, "rotationY", {
    get: function() {
      return this._rotationY;
    },
    set: function(value) {
      this._rotationY = value;
      this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CubeTexture2.prototype, "noMipmap", {
    get: function() {
      return this._noMipmap;
    },
    enumerable: false,
    configurable: true
  });
  CubeTexture2.CreateFromImages = function(files, scene, noMipmap) {
    var rootUrlKey = "";
    files.forEach(function(url) {
      return rootUrlKey += url;
    });
    return new CubeTexture2(rootUrlKey, scene, null, noMipmap, files);
  };
  CubeTexture2.CreateFromPrefilteredData = function(url, scene, forcedExtension, createPolynomials) {
    if (forcedExtension === void 0) {
      forcedExtension = null;
    }
    if (createPolynomials === void 0) {
      createPolynomials = true;
    }
    var oldValue = scene.useDelayedTextureLoading;
    scene.useDelayedTextureLoading = false;
    var result = new CubeTexture2(url, scene, null, false, null, null, null, void 0, true, forcedExtension, createPolynomials);
    scene.useDelayedTextureLoading = oldValue;
    return result;
  };
  CubeTexture2.prototype.getClassName = function() {
    return "CubeTexture";
  };
  CubeTexture2.prototype.updateURL = function(url, forcedExtension, onLoad, prefiltered) {
    var _a;
    if (prefiltered === void 0) {
      prefiltered = false;
    }
    if (this.url) {
      this.releaseInternalTexture();
      (_a = this.getScene()) === null || _a === void 0 ? void 0 : _a.markAllMaterialsAsDirty(1);
    }
    if (!this.name || StringTools.StartsWith(this.name, "data:")) {
      this.name = url;
    }
    this.url = url;
    this.delayLoadState = 4;
    this._prefiltered = prefiltered;
    if (this._prefiltered) {
      this.gammaSpace = false;
      this.anisotropicFilteringLevel = 1;
    }
    this._forcedExtension = forcedExtension || null;
    if (onLoad) {
      this._delayedOnLoad = onLoad;
    }
    this.delayLoad(forcedExtension);
  };
  CubeTexture2.prototype.delayLoad = function(forcedExtension) {
    var _this = this;
    var _a;
    if (this.delayLoadState !== 4) {
      return;
    }
    this.delayLoadState = 1;
    this._texture = this._getFromCache(this.url, this._noMipmap);
    if (!this._texture) {
      var scene = this.getScene();
      if (this._prefiltered) {
        this._texture = this._getEngine().createPrefilteredCubeTexture(this.url, scene, 0.8, 0, this._delayedOnLoad, void 0, this._format, forcedExtension, this._createPolynomials);
      } else {
        this._texture = this._getEngine().createCubeTexture(this.url, scene, this._files, this._noMipmap, this._delayedOnLoad, null, this._format, forcedExtension, false, 0, 0, null, this._loaderOptions);
      }
      (_a = this._texture) === null || _a === void 0 ? void 0 : _a.onLoadedObservable.add(function() {
        return _this.onLoadObservable.notifyObservers(_this);
      });
    }
  };
  CubeTexture2.prototype.getReflectionTextureMatrix = function() {
    return this._textureMatrix;
  };
  CubeTexture2.prototype.setReflectionTextureMatrix = function(value) {
    var _this = this;
    var _a;
    if (value.updateFlag === this._textureMatrix.updateFlag) {
      return;
    }
    if (value.isIdentity() !== this._textureMatrix.isIdentity()) {
      (_a = this.getScene()) === null || _a === void 0 ? void 0 : _a.markAllMaterialsAsDirty(1, function(mat) {
        return mat.getActiveTextures().indexOf(_this) !== -1;
      });
    }
    this._textureMatrix = value;
  };
  CubeTexture2.Parse = function(parsedTexture, scene, rootUrl) {
    var texture = SerializationHelper.Parse(function() {
      var prefiltered = false;
      if (parsedTexture.prefiltered) {
        prefiltered = parsedTexture.prefiltered;
      }
      return new CubeTexture2(rootUrl + parsedTexture.name, scene, parsedTexture.extensions, false, parsedTexture.files || null, null, null, void 0, prefiltered, parsedTexture.forcedExtension);
    }, parsedTexture, scene);
    if (parsedTexture.boundingBoxPosition) {
      texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);
    }
    if (parsedTexture.boundingBoxSize) {
      texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);
    }
    if (parsedTexture.animations) {
      for (var animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {
        var parsedAnimation = parsedTexture.animations[animationIndex];
        var internalClass = _TypeStore.GetClass("BABYLON.Animation");
        if (internalClass) {
          texture.animations.push(internalClass.Parse(parsedAnimation));
        }
      }
    }
    return texture;
  };
  CubeTexture2.prototype.clone = function() {
    var _this = this;
    var uniqueId = 0;
    var newCubeTexture = SerializationHelper.Clone(function() {
      var cubeTexture = new CubeTexture2(_this.url, _this.getScene() || _this._getEngine(), _this._extensions, _this._noMipmap, _this._files);
      uniqueId = cubeTexture.uniqueId;
      return cubeTexture;
    }, this);
    newCubeTexture.uniqueId = uniqueId;
    return newCubeTexture;
  };
  __decorate([
    serialize()
  ], CubeTexture2.prototype, "url", void 0);
  __decorate([
    serialize("rotationY")
  ], CubeTexture2.prototype, "rotationY", null);
  __decorate([
    serialize("files")
  ], CubeTexture2.prototype, "_files", void 0);
  __decorate([
    serialize("forcedExtension")
  ], CubeTexture2.prototype, "_forcedExtension", void 0);
  __decorate([
    serialize("extensions")
  ], CubeTexture2.prototype, "_extensions", void 0);
  __decorate([
    serializeAsMatrix("textureMatrix")
  ], CubeTexture2.prototype, "_textureMatrix", void 0);
  return CubeTexture2;
}(BaseTexture);
Texture._CubeTextureParser = CubeTexture.Parse;
_TypeStore.RegisteredTypes["BABYLON.CubeTexture"] = CubeTexture;

// node_modules/@babylonjs/core/Misc/rgbdTextureTools.js
var RGBDTextureTools = function() {
  function RGBDTextureTools2() {
  }
  RGBDTextureTools2.ExpandRGBDTexture = function(texture) {
    var internalTexture = texture._texture;
    if (!internalTexture || !texture.isRGBD) {
      return;
    }
    var engine = internalTexture.getEngine();
    var caps = engine.getCaps();
    var expandTexture = false;
    if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
      expandTexture = true;
      internalTexture.type = 2;
    } else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
      expandTexture = true;
      internalTexture.type = 1;
    }
    if (expandTexture) {
      internalTexture.isReady = false;
      internalTexture._isRGBD = false;
      internalTexture.invertY = false;
    }
    texture.onLoadObservable.addOnce(function() {
      if (expandTexture) {
        var rgbdPostProcess_1 = new PostProcess("rgbdDecode", "rgbdDecode", null, null, 1, null, 3, engine, false, void 0, internalTexture.type, void 0, null, false);
        var expandedTexture_1 = engine.createRenderTargetTexture(internalTexture.width, {
          generateDepthBuffer: false,
          generateMipMaps: false,
          generateStencilBuffer: false,
          samplingMode: internalTexture.samplingMode,
          type: internalTexture.type,
          format: 5
        });
        rgbdPostProcess_1.getEffect().executeWhenCompiled(function() {
          rgbdPostProcess_1.onApply = function(effect) {
            effect._bindTexture("textureSampler", internalTexture);
            effect.setFloat2("scale", 1, 1);
          };
          texture.getScene().postProcessManager.directRender([rgbdPostProcess_1], expandedTexture_1, true);
          engine.restoreDefaultFramebuffer();
          engine._releaseTexture(internalTexture);
          engine._releaseFramebufferObjects(expandedTexture_1);
          if (rgbdPostProcess_1) {
            rgbdPostProcess_1.dispose();
          }
          expandedTexture_1._swapAndDie(internalTexture);
          internalTexture.isReady = true;
        });
      }
    });
  };
  return RGBDTextureTools2;
}();

// node_modules/@babylonjs/core/Misc/brdfTextureTools.js
var BRDFTextureTools = function() {
  function BRDFTextureTools2() {
  }
  BRDFTextureTools2.GetEnvironmentBRDFTexture = function(scene) {
    if (!scene.environmentBRDFTexture) {
      var useDelayedTextureLoading = scene.useDelayedTextureLoading;
      scene.useDelayedTextureLoading = false;
      var previousState = scene._blockEntityCollection;
      scene._blockEntityCollection = false;
      var texture = Texture.CreateFromBase64String(this._environmentBRDFBase64Texture, "EnvironmentBRDFTexture" + this._instanceNumber++, scene, true, false, Texture.BILINEAR_SAMPLINGMODE);
      scene._blockEntityCollection = previousState;
      var texturesCache = scene.getEngine().getLoadedTexturesCache();
      var index = texturesCache.indexOf(texture.getInternalTexture());
      if (index !== -1) {
        texturesCache.splice(index, 1);
      }
      texture.isRGBD = true;
      texture.wrapU = Texture.CLAMP_ADDRESSMODE;
      texture.wrapV = Texture.CLAMP_ADDRESSMODE;
      scene.environmentBRDFTexture = texture;
      scene.useDelayedTextureLoading = useDelayedTextureLoading;
      RGBDTextureTools.ExpandRGBDTexture(texture);
    }
    return scene.environmentBRDFTexture;
  };
  BRDFTextureTools2._instanceNumber = 0;
  BRDFTextureTools2._environmentBRDFBase64Texture = "data:image/png;base64,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";
  return BRDFTextureTools2;
}();

// node_modules/@babylonjs/core/Materials/PBR/pbrClearCoatConfiguration.js
var PBRClearCoatConfiguration = function() {
  function PBRClearCoatConfiguration2(markAllSubMeshesAsTexturesDirty) {
    this._isEnabled = false;
    this.isEnabled = false;
    this.intensity = 1;
    this.roughness = 0;
    this._indexOfRefraction = PBRClearCoatConfiguration2._DefaultIndexOfRefraction;
    this.indexOfRefraction = PBRClearCoatConfiguration2._DefaultIndexOfRefraction;
    this._texture = null;
    this.texture = null;
    this._useRoughnessFromMainTexture = true;
    this.useRoughnessFromMainTexture = true;
    this._textureRoughness = null;
    this.textureRoughness = null;
    this._remapF0OnInterfaceChange = true;
    this.remapF0OnInterfaceChange = true;
    this._bumpTexture = null;
    this.bumpTexture = null;
    this._isTintEnabled = false;
    this.isTintEnabled = false;
    this.tintColor = Color3.White();
    this.tintColorAtDistance = 1;
    this.tintThickness = 1;
    this._tintTexture = null;
    this.tintTexture = null;
    this._internalMarkAllSubMeshesAsTexturesDirty = markAllSubMeshesAsTexturesDirty;
  }
  PBRClearCoatConfiguration2.prototype._markAllSubMeshesAsTexturesDirty = function() {
    this._internalMarkAllSubMeshesAsTexturesDirty();
  };
  PBRClearCoatConfiguration2.prototype.isReadyForSubMesh = function(defines, scene, engine, disableBumpMap) {
    if (defines._areTexturesDirty) {
      if (scene.texturesEnabled) {
        if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {
          if (!this._texture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._textureRoughness && MaterialFlags.ClearCoatTextureEnabled) {
          if (!this._textureRoughness.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.ClearCoatBumpTextureEnabled && !disableBumpMap) {
          if (!this._bumpTexture.isReady()) {
            return false;
          }
        }
        if (this._isTintEnabled && this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
          if (!this._tintTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
      }
    }
    return true;
  };
  PBRClearCoatConfiguration2.prototype.prepareDefines = function(defines, scene) {
    var _a;
    if (this._isEnabled) {
      defines.CLEARCOAT = true;
      defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;
      defines.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL = this._texture !== null && this._texture._texture === ((_a = this._textureRoughness) === null || _a === void 0 ? void 0 : _a._texture) && this._texture.checkTransformsAreIdentical(this._textureRoughness);
      defines.CLEARCOAT_REMAP_F0 = this._remapF0OnInterfaceChange;
      if (defines._areTexturesDirty) {
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {
            MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, "CLEARCOAT_TEXTURE");
          } else {
            defines.CLEARCOAT_TEXTURE = false;
          }
          if (this._textureRoughness && MaterialFlags.ClearCoatTextureEnabled) {
            MaterialHelper.PrepareDefinesForMergedUV(this._textureRoughness, defines, "CLEARCOAT_TEXTURE_ROUGHNESS");
          } else {
            defines.CLEARCOAT_TEXTURE_ROUGHNESS = false;
          }
          if (this._bumpTexture && MaterialFlags.ClearCoatBumpTextureEnabled) {
            MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture, defines, "CLEARCOAT_BUMP");
          } else {
            defines.CLEARCOAT_BUMP = false;
          }
          defines.CLEARCOAT_DEFAULTIOR = this._indexOfRefraction === PBRClearCoatConfiguration2._DefaultIndexOfRefraction;
          if (this._isTintEnabled) {
            defines.CLEARCOAT_TINT = true;
            if (this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
              MaterialHelper.PrepareDefinesForMergedUV(this._tintTexture, defines, "CLEARCOAT_TINT_TEXTURE");
            } else {
              defines.CLEARCOAT_TINT_TEXTURE = false;
            }
          } else {
            defines.CLEARCOAT_TINT = false;
            defines.CLEARCOAT_TINT_TEXTURE = false;
          }
        }
      }
    } else {
      defines.CLEARCOAT = false;
      defines.CLEARCOAT_TEXTURE = false;
      defines.CLEARCOAT_TEXTURE_ROUGHNESS = false;
      defines.CLEARCOAT_BUMP = false;
      defines.CLEARCOAT_TINT = false;
      defines.CLEARCOAT_TINT_TEXTURE = false;
      defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
      defines.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL = false;
    }
  };
  PBRClearCoatConfiguration2.prototype.bindForSubMesh = function(uniformBuffer, scene, engine, disableBumpMap, isFrozen, invertNormalMapX, invertNormalMapY, subMesh) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    var defines = subMesh._materialDefines;
    var identicalTextures = defines.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL;
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if (identicalTextures && MaterialFlags.ClearCoatTextureEnabled) {
        uniformBuffer.updateFloat4("vClearCoatInfos", this._texture.coordinatesIndex, this._texture.level, -1, -1);
        MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "clearCoat");
      } else if ((this._texture || this._textureRoughness) && MaterialFlags.ClearCoatTextureEnabled) {
        uniformBuffer.updateFloat4("vClearCoatInfos", (_b = (_a = this._texture) === null || _a === void 0 ? void 0 : _a.coordinatesIndex) !== null && _b !== void 0 ? _b : 0, (_d = (_c = this._texture) === null || _c === void 0 ? void 0 : _c.level) !== null && _d !== void 0 ? _d : 0, (_f = (_e = this._textureRoughness) === null || _e === void 0 ? void 0 : _e.coordinatesIndex) !== null && _f !== void 0 ? _f : 0, (_h = (_g = this._textureRoughness) === null || _g === void 0 ? void 0 : _g.level) !== null && _h !== void 0 ? _h : 0);
        if (this._texture) {
          MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "clearCoat");
        }
        if (this._textureRoughness && !identicalTextures && !defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE) {
          MaterialHelper.BindTextureMatrix(this._textureRoughness, uniformBuffer, "clearCoatRoughness");
        }
      }
      if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.ClearCoatTextureEnabled && !disableBumpMap) {
        uniformBuffer.updateFloat2("vClearCoatBumpInfos", this._bumpTexture.coordinatesIndex, this._bumpTexture.level);
        MaterialHelper.BindTextureMatrix(this._bumpTexture, uniformBuffer, "clearCoatBump");
        if (scene._mirroredCameraPosition) {
          uniformBuffer.updateFloat2("vClearCoatTangentSpaceParams", invertNormalMapX ? 1 : -1, invertNormalMapY ? 1 : -1);
        } else {
          uniformBuffer.updateFloat2("vClearCoatTangentSpaceParams", invertNormalMapX ? -1 : 1, invertNormalMapY ? -1 : 1);
        }
      }
      if (this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
        uniformBuffer.updateFloat2("vClearCoatTintInfos", this._tintTexture.coordinatesIndex, this._tintTexture.level);
        MaterialHelper.BindTextureMatrix(this._tintTexture, uniformBuffer, "clearCoatTint");
      }
      uniformBuffer.updateFloat2("vClearCoatParams", this.intensity, this.roughness);
      var a = 1 - this._indexOfRefraction;
      var b = 1 + this._indexOfRefraction;
      var f0 = Math.pow(-a / b, 2);
      var eta = 1 / this._indexOfRefraction;
      uniformBuffer.updateFloat4("vClearCoatRefractionParams", f0, eta, a, b);
      if (this._isTintEnabled) {
        uniformBuffer.updateFloat4("vClearCoatTintParams", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(1e-5, this.tintThickness));
        uniformBuffer.updateFloat("clearCoatColorAtDistance", Math.max(1e-5, this.tintColorAtDistance));
      }
    }
    if (scene.texturesEnabled) {
      if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {
        uniformBuffer.setTexture("clearCoatSampler", this._texture);
      }
      if (this._textureRoughness && !identicalTextures && !defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.ClearCoatTextureEnabled) {
        uniformBuffer.setTexture("clearCoatRoughnessSampler", this._textureRoughness);
      }
      if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.ClearCoatBumpTextureEnabled && !disableBumpMap) {
        uniformBuffer.setTexture("clearCoatBumpSampler", this._bumpTexture);
      }
      if (this._isTintEnabled && this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
        uniformBuffer.setTexture("clearCoatTintSampler", this._tintTexture);
      }
    }
  };
  PBRClearCoatConfiguration2.prototype.hasTexture = function(texture) {
    if (this._texture === texture) {
      return true;
    }
    if (this._textureRoughness === texture) {
      return true;
    }
    if (this._bumpTexture === texture) {
      return true;
    }
    if (this._tintTexture === texture) {
      return true;
    }
    return false;
  };
  PBRClearCoatConfiguration2.prototype.getActiveTextures = function(activeTextures) {
    if (this._texture) {
      activeTextures.push(this._texture);
    }
    if (this._textureRoughness) {
      activeTextures.push(this._textureRoughness);
    }
    if (this._bumpTexture) {
      activeTextures.push(this._bumpTexture);
    }
    if (this._tintTexture) {
      activeTextures.push(this._tintTexture);
    }
  };
  PBRClearCoatConfiguration2.prototype.getAnimatables = function(animatables) {
    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
      animatables.push(this._texture);
    }
    if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {
      animatables.push(this._textureRoughness);
    }
    if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {
      animatables.push(this._bumpTexture);
    }
    if (this._tintTexture && this._tintTexture.animations && this._tintTexture.animations.length > 0) {
      animatables.push(this._tintTexture);
    }
  };
  PBRClearCoatConfiguration2.prototype.dispose = function(forceDisposeTextures) {
    var _a, _b, _c, _d;
    if (forceDisposeTextures) {
      (_a = this._texture) === null || _a === void 0 ? void 0 : _a.dispose();
      (_b = this._textureRoughness) === null || _b === void 0 ? void 0 : _b.dispose();
      (_c = this._bumpTexture) === null || _c === void 0 ? void 0 : _c.dispose();
      (_d = this._tintTexture) === null || _d === void 0 ? void 0 : _d.dispose();
    }
  };
  PBRClearCoatConfiguration2.prototype.getClassName = function() {
    return "PBRClearCoatConfiguration";
  };
  PBRClearCoatConfiguration2.AddFallbacks = function(defines, fallbacks, currentRank) {
    if (defines.CLEARCOAT_BUMP) {
      fallbacks.addFallback(currentRank++, "CLEARCOAT_BUMP");
    }
    if (defines.CLEARCOAT_TINT) {
      fallbacks.addFallback(currentRank++, "CLEARCOAT_TINT");
    }
    if (defines.CLEARCOAT) {
      fallbacks.addFallback(currentRank++, "CLEARCOAT");
    }
    return currentRank;
  };
  PBRClearCoatConfiguration2.AddUniforms = function(uniforms) {
    uniforms.push("vClearCoatTangentSpaceParams", "vClearCoatParams", "vClearCoatRefractionParams", "vClearCoatTintParams", "clearCoatColorAtDistance", "clearCoatMatrix", "clearCoatRoughnessMatrix", "clearCoatBumpMatrix", "clearCoatTintMatrix", "vClearCoatInfos", "vClearCoatBumpInfos", "vClearCoatTintInfos");
  };
  PBRClearCoatConfiguration2.AddSamplers = function(samplers) {
    samplers.push("clearCoatSampler", "clearCoatRoughnessSampler", "clearCoatBumpSampler", "clearCoatTintSampler");
  };
  PBRClearCoatConfiguration2.PrepareUniformBuffer = function(uniformBuffer) {
    uniformBuffer.addUniform("vClearCoatParams", 2);
    uniformBuffer.addUniform("vClearCoatRefractionParams", 4);
    uniformBuffer.addUniform("vClearCoatInfos", 4);
    uniformBuffer.addUniform("clearCoatMatrix", 16);
    uniformBuffer.addUniform("clearCoatRoughnessMatrix", 16);
    uniformBuffer.addUniform("vClearCoatBumpInfos", 2);
    uniformBuffer.addUniform("vClearCoatTangentSpaceParams", 2);
    uniformBuffer.addUniform("clearCoatBumpMatrix", 16);
    uniformBuffer.addUniform("vClearCoatTintParams", 4);
    uniformBuffer.addUniform("clearCoatColorAtDistance", 1);
    uniformBuffer.addUniform("vClearCoatTintInfos", 2);
    uniformBuffer.addUniform("clearCoatTintMatrix", 16);
  };
  PBRClearCoatConfiguration2.prototype.copyTo = function(clearCoatConfiguration) {
    SerializationHelper.Clone(function() {
      return clearCoatConfiguration;
    }, this);
  };
  PBRClearCoatConfiguration2.prototype.serialize = function() {
    return SerializationHelper.Serialize(this);
  };
  PBRClearCoatConfiguration2.prototype.parse = function(source, scene, rootUrl) {
    var _this = this;
    SerializationHelper.Parse(function() {
      return _this;
    }, source, scene, rootUrl);
  };
  PBRClearCoatConfiguration2._DefaultIndexOfRefraction = 1.5;
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRClearCoatConfiguration2.prototype, "isEnabled", void 0);
  __decorate([
    serialize()
  ], PBRClearCoatConfiguration2.prototype, "intensity", void 0);
  __decorate([
    serialize()
  ], PBRClearCoatConfiguration2.prototype, "roughness", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRClearCoatConfiguration2.prototype, "indexOfRefraction", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRClearCoatConfiguration2.prototype, "texture", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRClearCoatConfiguration2.prototype, "useRoughnessFromMainTexture", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRClearCoatConfiguration2.prototype, "textureRoughness", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRClearCoatConfiguration2.prototype, "remapF0OnInterfaceChange", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRClearCoatConfiguration2.prototype, "bumpTexture", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRClearCoatConfiguration2.prototype, "isTintEnabled", void 0);
  __decorate([
    serializeAsColor3()
  ], PBRClearCoatConfiguration2.prototype, "tintColor", void 0);
  __decorate([
    serialize()
  ], PBRClearCoatConfiguration2.prototype, "tintColorAtDistance", void 0);
  __decorate([
    serialize()
  ], PBRClearCoatConfiguration2.prototype, "tintThickness", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRClearCoatConfiguration2.prototype, "tintTexture", void 0);
  return PBRClearCoatConfiguration2;
}();

// node_modules/@babylonjs/core/Materials/PBR/pbrAnisotropicConfiguration.js
var PBRAnisotropicConfiguration = function() {
  function PBRAnisotropicConfiguration2(markAllSubMeshesAsTexturesDirty) {
    this._isEnabled = false;
    this.isEnabled = false;
    this.intensity = 1;
    this.direction = new Vector2(1, 0);
    this._texture = null;
    this.texture = null;
    this._internalMarkAllSubMeshesAsTexturesDirty = markAllSubMeshesAsTexturesDirty;
  }
  PBRAnisotropicConfiguration2.prototype._markAllSubMeshesAsTexturesDirty = function() {
    this._internalMarkAllSubMeshesAsTexturesDirty();
  };
  PBRAnisotropicConfiguration2.prototype.isReadyForSubMesh = function(defines, scene) {
    if (defines._areTexturesDirty) {
      if (scene.texturesEnabled) {
        if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
          if (!this._texture.isReadyOrNotBlocking()) {
            return false;
          }
        }
      }
    }
    return true;
  };
  PBRAnisotropicConfiguration2.prototype.prepareDefines = function(defines, mesh, scene) {
    if (this._isEnabled) {
      defines.ANISOTROPIC = this._isEnabled;
      if (this._isEnabled && !mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {
        defines._needUVs = true;
        defines.MAINUV1 = true;
      }
      if (defines._areTexturesDirty) {
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
            MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, "ANISOTROPIC_TEXTURE");
          } else {
            defines.ANISOTROPIC_TEXTURE = false;
          }
        }
      }
    } else {
      defines.ANISOTROPIC = false;
      defines.ANISOTROPIC_TEXTURE = false;
    }
  };
  PBRAnisotropicConfiguration2.prototype.bindForSubMesh = function(uniformBuffer, scene, isFrozen) {
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
        uniformBuffer.updateFloat2("vAnisotropyInfos", this._texture.coordinatesIndex, this._texture.level);
        MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "anisotropy");
      }
      uniformBuffer.updateFloat3("vAnisotropy", this.direction.x, this.direction.y, this.intensity);
    }
    if (scene.texturesEnabled) {
      if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
        uniformBuffer.setTexture("anisotropySampler", this._texture);
      }
    }
  };
  PBRAnisotropicConfiguration2.prototype.hasTexture = function(texture) {
    if (this._texture === texture) {
      return true;
    }
    return false;
  };
  PBRAnisotropicConfiguration2.prototype.getActiveTextures = function(activeTextures) {
    if (this._texture) {
      activeTextures.push(this._texture);
    }
  };
  PBRAnisotropicConfiguration2.prototype.getAnimatables = function(animatables) {
    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
      animatables.push(this._texture);
    }
  };
  PBRAnisotropicConfiguration2.prototype.dispose = function(forceDisposeTextures) {
    if (forceDisposeTextures) {
      if (this._texture) {
        this._texture.dispose();
      }
    }
  };
  PBRAnisotropicConfiguration2.prototype.getClassName = function() {
    return "PBRAnisotropicConfiguration";
  };
  PBRAnisotropicConfiguration2.AddFallbacks = function(defines, fallbacks, currentRank) {
    if (defines.ANISOTROPIC) {
      fallbacks.addFallback(currentRank++, "ANISOTROPIC");
    }
    return currentRank;
  };
  PBRAnisotropicConfiguration2.AddUniforms = function(uniforms) {
    uniforms.push("vAnisotropy", "vAnisotropyInfos", "anisotropyMatrix");
  };
  PBRAnisotropicConfiguration2.PrepareUniformBuffer = function(uniformBuffer) {
    uniformBuffer.addUniform("vAnisotropy", 3);
    uniformBuffer.addUniform("vAnisotropyInfos", 2);
    uniformBuffer.addUniform("anisotropyMatrix", 16);
  };
  PBRAnisotropicConfiguration2.AddSamplers = function(samplers) {
    samplers.push("anisotropySampler");
  };
  PBRAnisotropicConfiguration2.prototype.copyTo = function(anisotropicConfiguration) {
    SerializationHelper.Clone(function() {
      return anisotropicConfiguration;
    }, this);
  };
  PBRAnisotropicConfiguration2.prototype.serialize = function() {
    return SerializationHelper.Serialize(this);
  };
  PBRAnisotropicConfiguration2.prototype.parse = function(source, scene, rootUrl) {
    var _this = this;
    SerializationHelper.Parse(function() {
      return _this;
    }, source, scene, rootUrl);
  };
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRAnisotropicConfiguration2.prototype, "isEnabled", void 0);
  __decorate([
    serialize()
  ], PBRAnisotropicConfiguration2.prototype, "intensity", void 0);
  __decorate([
    serializeAsVector2()
  ], PBRAnisotropicConfiguration2.prototype, "direction", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRAnisotropicConfiguration2.prototype, "texture", void 0);
  return PBRAnisotropicConfiguration2;
}();

// node_modules/@babylonjs/core/Materials/PBR/pbrBRDFConfiguration.js
var PBRBRDFConfiguration = function() {
  function PBRBRDFConfiguration2(markAllSubMeshesAsMiscDirty) {
    this._useEnergyConservation = PBRBRDFConfiguration2.DEFAULT_USE_ENERGY_CONSERVATION;
    this.useEnergyConservation = PBRBRDFConfiguration2.DEFAULT_USE_ENERGY_CONSERVATION;
    this._useSmithVisibilityHeightCorrelated = PBRBRDFConfiguration2.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;
    this.useSmithVisibilityHeightCorrelated = PBRBRDFConfiguration2.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;
    this._useSphericalHarmonics = PBRBRDFConfiguration2.DEFAULT_USE_SPHERICAL_HARMONICS;
    this.useSphericalHarmonics = PBRBRDFConfiguration2.DEFAULT_USE_SPHERICAL_HARMONICS;
    this._useSpecularGlossinessInputEnergyConservation = PBRBRDFConfiguration2.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;
    this.useSpecularGlossinessInputEnergyConservation = PBRBRDFConfiguration2.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;
    this._internalMarkAllSubMeshesAsMiscDirty = markAllSubMeshesAsMiscDirty;
  }
  PBRBRDFConfiguration2.prototype._markAllSubMeshesAsMiscDirty = function() {
    this._internalMarkAllSubMeshesAsMiscDirty();
  };
  PBRBRDFConfiguration2.prototype.prepareDefines = function(defines) {
    defines.BRDF_V_HEIGHT_CORRELATED = this._useSmithVisibilityHeightCorrelated;
    defines.MS_BRDF_ENERGY_CONSERVATION = this._useEnergyConservation && this._useSmithVisibilityHeightCorrelated;
    defines.SPHERICAL_HARMONICS = this._useSphericalHarmonics;
    defines.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = this._useSpecularGlossinessInputEnergyConservation;
  };
  PBRBRDFConfiguration2.prototype.getClassName = function() {
    return "PBRBRDFConfiguration";
  };
  PBRBRDFConfiguration2.prototype.copyTo = function(brdfConfiguration) {
    SerializationHelper.Clone(function() {
      return brdfConfiguration;
    }, this);
  };
  PBRBRDFConfiguration2.prototype.serialize = function() {
    return SerializationHelper.Serialize(this);
  };
  PBRBRDFConfiguration2.prototype.parse = function(source, scene, rootUrl) {
    var _this = this;
    SerializationHelper.Parse(function() {
      return _this;
    }, source, scene, rootUrl);
  };
  PBRBRDFConfiguration2.DEFAULT_USE_ENERGY_CONSERVATION = true;
  PBRBRDFConfiguration2.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED = true;
  PBRBRDFConfiguration2.DEFAULT_USE_SPHERICAL_HARMONICS = true;
  PBRBRDFConfiguration2.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION = true;
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsMiscDirty")
  ], PBRBRDFConfiguration2.prototype, "useEnergyConservation", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsMiscDirty")
  ], PBRBRDFConfiguration2.prototype, "useSmithVisibilityHeightCorrelated", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsMiscDirty")
  ], PBRBRDFConfiguration2.prototype, "useSphericalHarmonics", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsMiscDirty")
  ], PBRBRDFConfiguration2.prototype, "useSpecularGlossinessInputEnergyConservation", void 0);
  return PBRBRDFConfiguration2;
}();

// node_modules/@babylonjs/core/Materials/PBR/pbrSheenConfiguration.js
var PBRSheenConfiguration = function() {
  function PBRSheenConfiguration2(markAllSubMeshesAsTexturesDirty) {
    this._isEnabled = false;
    this.isEnabled = false;
    this._linkSheenWithAlbedo = false;
    this.linkSheenWithAlbedo = false;
    this.intensity = 1;
    this.color = Color3.White();
    this._texture = null;
    this.texture = null;
    this._useRoughnessFromMainTexture = true;
    this.useRoughnessFromMainTexture = true;
    this._roughness = null;
    this.roughness = null;
    this._textureRoughness = null;
    this.textureRoughness = null;
    this._albedoScaling = false;
    this.albedoScaling = false;
    this._internalMarkAllSubMeshesAsTexturesDirty = markAllSubMeshesAsTexturesDirty;
  }
  PBRSheenConfiguration2.prototype._markAllSubMeshesAsTexturesDirty = function() {
    this._internalMarkAllSubMeshesAsTexturesDirty();
  };
  PBRSheenConfiguration2.prototype.isReadyForSubMesh = function(defines, scene) {
    if (defines._areTexturesDirty) {
      if (scene.texturesEnabled) {
        if (this._texture && MaterialFlags.SheenTextureEnabled) {
          if (!this._texture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {
          if (!this._textureRoughness.isReadyOrNotBlocking()) {
            return false;
          }
        }
      }
    }
    return true;
  };
  PBRSheenConfiguration2.prototype.prepareDefines = function(defines, scene) {
    var _a;
    if (this._isEnabled) {
      defines.SHEEN = this._isEnabled;
      defines.SHEEN_LINKWITHALBEDO = this._linkSheenWithAlbedo;
      defines.SHEEN_ROUGHNESS = this._roughness !== null;
      defines.SHEEN_ALBEDOSCALING = this._albedoScaling;
      defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;
      defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL = this._texture !== null && this._texture._texture === ((_a = this._textureRoughness) === null || _a === void 0 ? void 0 : _a._texture) && this._texture.checkTransformsAreIdentical(this._textureRoughness);
      if (defines._areTexturesDirty) {
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.SheenTextureEnabled) {
            MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, "SHEEN_TEXTURE");
          } else {
            defines.SHEEN_TEXTURE = false;
          }
          if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {
            MaterialHelper.PrepareDefinesForMergedUV(this._textureRoughness, defines, "SHEEN_TEXTURE_ROUGHNESS");
          } else {
            defines.SHEEN_TEXTURE_ROUGHNESS = false;
          }
        }
      }
    } else {
      defines.SHEEN = false;
      defines.SHEEN_TEXTURE = false;
      defines.SHEEN_TEXTURE_ROUGHNESS = false;
      defines.SHEEN_LINKWITHALBEDO = false;
      defines.SHEEN_ROUGHNESS = false;
      defines.SHEEN_ALBEDOSCALING = false;
      defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
      defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL = false;
    }
  };
  PBRSheenConfiguration2.prototype.bindForSubMesh = function(uniformBuffer, scene, isFrozen, subMesh) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    var defines = subMesh._materialDefines;
    var identicalTextures = defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL;
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if (identicalTextures && MaterialFlags.SheenTextureEnabled) {
        uniformBuffer.updateFloat4("vSheenInfos", this._texture.coordinatesIndex, this._texture.level, -1, -1);
        MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "sheen");
      } else if ((this._texture || this._textureRoughness) && MaterialFlags.SheenTextureEnabled) {
        uniformBuffer.updateFloat4("vSheenInfos", (_b = (_a = this._texture) === null || _a === void 0 ? void 0 : _a.coordinatesIndex) !== null && _b !== void 0 ? _b : 0, (_d = (_c = this._texture) === null || _c === void 0 ? void 0 : _c.level) !== null && _d !== void 0 ? _d : 0, (_f = (_e = this._textureRoughness) === null || _e === void 0 ? void 0 : _e.coordinatesIndex) !== null && _f !== void 0 ? _f : 0, (_h = (_g = this._textureRoughness) === null || _g === void 0 ? void 0 : _g.level) !== null && _h !== void 0 ? _h : 0);
        if (this._texture) {
          MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "sheen");
        }
        if (this._textureRoughness && !identicalTextures && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE) {
          MaterialHelper.BindTextureMatrix(this._textureRoughness, uniformBuffer, "sheenRoughness");
        }
      }
      uniformBuffer.updateFloat4("vSheenColor", this.color.r, this.color.g, this.color.b, this.intensity);
      if (this._roughness !== null) {
        uniformBuffer.updateFloat("vSheenRoughness", this._roughness);
      }
    }
    if (scene.texturesEnabled) {
      if (this._texture && MaterialFlags.SheenTextureEnabled) {
        uniformBuffer.setTexture("sheenSampler", this._texture);
      }
      if (this._textureRoughness && !identicalTextures && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.SheenTextureEnabled) {
        uniformBuffer.setTexture("sheenRoughnessSampler", this._textureRoughness);
      }
    }
  };
  PBRSheenConfiguration2.prototype.hasTexture = function(texture) {
    if (this._texture === texture) {
      return true;
    }
    if (this._textureRoughness === texture) {
      return true;
    }
    return false;
  };
  PBRSheenConfiguration2.prototype.getActiveTextures = function(activeTextures) {
    if (this._texture) {
      activeTextures.push(this._texture);
    }
    if (this._textureRoughness) {
      activeTextures.push(this._textureRoughness);
    }
  };
  PBRSheenConfiguration2.prototype.getAnimatables = function(animatables) {
    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
      animatables.push(this._texture);
    }
    if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {
      animatables.push(this._textureRoughness);
    }
  };
  PBRSheenConfiguration2.prototype.dispose = function(forceDisposeTextures) {
    var _a, _b;
    if (forceDisposeTextures) {
      (_a = this._texture) === null || _a === void 0 ? void 0 : _a.dispose();
      (_b = this._textureRoughness) === null || _b === void 0 ? void 0 : _b.dispose();
    }
  };
  PBRSheenConfiguration2.prototype.getClassName = function() {
    return "PBRSheenConfiguration";
  };
  PBRSheenConfiguration2.AddFallbacks = function(defines, fallbacks, currentRank) {
    if (defines.SHEEN) {
      fallbacks.addFallback(currentRank++, "SHEEN");
    }
    return currentRank;
  };
  PBRSheenConfiguration2.AddUniforms = function(uniforms) {
    uniforms.push("vSheenColor", "vSheenRoughness", "vSheenInfos", "sheenMatrix", "sheenRoughnessMatrix");
  };
  PBRSheenConfiguration2.PrepareUniformBuffer = function(uniformBuffer) {
    uniformBuffer.addUniform("vSheenColor", 4);
    uniformBuffer.addUniform("vSheenRoughness", 1);
    uniformBuffer.addUniform("vSheenInfos", 4);
    uniformBuffer.addUniform("sheenMatrix", 16);
    uniformBuffer.addUniform("sheenRoughnessMatrix", 16);
  };
  PBRSheenConfiguration2.AddSamplers = function(samplers) {
    samplers.push("sheenSampler");
    samplers.push("sheenRoughnessSampler");
  };
  PBRSheenConfiguration2.prototype.copyTo = function(sheenConfiguration) {
    SerializationHelper.Clone(function() {
      return sheenConfiguration;
    }, this);
  };
  PBRSheenConfiguration2.prototype.serialize = function() {
    return SerializationHelper.Serialize(this);
  };
  PBRSheenConfiguration2.prototype.parse = function(source, scene, rootUrl) {
    var _this = this;
    SerializationHelper.Parse(function() {
      return _this;
    }, source, scene, rootUrl);
  };
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRSheenConfiguration2.prototype, "isEnabled", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRSheenConfiguration2.prototype, "linkSheenWithAlbedo", void 0);
  __decorate([
    serialize()
  ], PBRSheenConfiguration2.prototype, "intensity", void 0);
  __decorate([
    serializeAsColor3()
  ], PBRSheenConfiguration2.prototype, "color", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRSheenConfiguration2.prototype, "texture", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRSheenConfiguration2.prototype, "useRoughnessFromMainTexture", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRSheenConfiguration2.prototype, "roughness", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRSheenConfiguration2.prototype, "textureRoughness", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRSheenConfiguration2.prototype, "albedoScaling", void 0);
  return PBRSheenConfiguration2;
}();

// node_modules/@babylonjs/core/Materials/PBR/pbrSubSurfaceConfiguration.js
var PBRSubSurfaceConfiguration = function() {
  function PBRSubSurfaceConfiguration2(markAllSubMeshesAsTexturesDirty, markScenePrePassDirty, scene) {
    this._isRefractionEnabled = false;
    this.isRefractionEnabled = false;
    this._isTranslucencyEnabled = false;
    this.isTranslucencyEnabled = false;
    this._isScatteringEnabled = false;
    this.isScatteringEnabled = false;
    this._scatteringDiffusionProfileIndex = 0;
    this.refractionIntensity = 1;
    this.translucencyIntensity = 1;
    this.useAlbedoToTintRefraction = false;
    this._thicknessTexture = null;
    this.thicknessTexture = null;
    this._refractionTexture = null;
    this.refractionTexture = null;
    this._indexOfRefraction = 1.5;
    this.indexOfRefraction = 1.5;
    this._volumeIndexOfRefraction = -1;
    this._invertRefractionY = false;
    this.invertRefractionY = false;
    this._linkRefractionWithTransparency = false;
    this.linkRefractionWithTransparency = false;
    this.minimumThickness = 0;
    this.maximumThickness = 1;
    this.tintColor = Color3.White();
    this.tintColorAtDistance = 1;
    this.diffusionDistance = Color3.White();
    this._useMaskFromThicknessTexture = false;
    this.useMaskFromThicknessTexture = false;
    this._useMaskFromThicknessTextureGltf = false;
    this.useMaskFromThicknessTextureGltf = false;
    this._internalMarkAllSubMeshesAsTexturesDirty = markAllSubMeshesAsTexturesDirty;
    this._internalMarkScenePrePassDirty = markScenePrePassDirty;
    this._scene = scene;
  }
  Object.defineProperty(PBRSubSurfaceConfiguration2.prototype, "scatteringDiffusionProfile", {
    get: function() {
      if (!this._scene.subSurfaceConfiguration) {
        return null;
      }
      return this._scene.subSurfaceConfiguration.ssDiffusionProfileColors[this._scatteringDiffusionProfileIndex];
    },
    set: function(c) {
      if (!this._scene.enableSubSurfaceForPrePass()) {
        return;
      }
      if (c) {
        this._scatteringDiffusionProfileIndex = this._scene.subSurfaceConfiguration.addDiffusionProfile(c);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRSubSurfaceConfiguration2.prototype, "volumeIndexOfRefraction", {
    get: function() {
      if (this._volumeIndexOfRefraction >= 1) {
        return this._volumeIndexOfRefraction;
      }
      return this._indexOfRefraction;
    },
    set: function(value) {
      if (value >= 1) {
        this._volumeIndexOfRefraction = value;
      } else {
        this._volumeIndexOfRefraction = -1;
      }
    },
    enumerable: false,
    configurable: true
  });
  PBRSubSurfaceConfiguration2.prototype._markAllSubMeshesAsTexturesDirty = function() {
    this._internalMarkAllSubMeshesAsTexturesDirty();
  };
  PBRSubSurfaceConfiguration2.prototype._markScenePrePassDirty = function() {
    this._internalMarkAllSubMeshesAsTexturesDirty();
    this._internalMarkScenePrePassDirty();
  };
  PBRSubSurfaceConfiguration2.prototype.isReadyForSubMesh = function(defines, scene) {
    if (defines._areTexturesDirty) {
      if (scene.texturesEnabled) {
        if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
          if (!this._thicknessTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        var refractionTexture = this._getRefractionTexture(scene);
        if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
          if (!refractionTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
      }
    }
    return true;
  };
  PBRSubSurfaceConfiguration2.prototype.prepareDefines = function(defines, scene) {
    if (defines._areTexturesDirty) {
      defines.SUBSURFACE = false;
      defines.SS_TRANSLUCENCY = this._isTranslucencyEnabled;
      defines.SS_SCATTERING = this._isScatteringEnabled;
      defines.SS_THICKNESSANDMASK_TEXTURE = false;
      defines.SS_MASK_FROM_THICKNESS_TEXTURE = false;
      defines.SS_MASK_FROM_THICKNESS_TEXTURE_GLTF = false;
      defines.SS_REFRACTION = false;
      defines.SS_REFRACTIONMAP_3D = false;
      defines.SS_GAMMAREFRACTION = false;
      defines.SS_RGBDREFRACTION = false;
      defines.SS_LINEARSPECULARREFRACTION = false;
      defines.SS_REFRACTIONMAP_OPPOSITEZ = false;
      defines.SS_LODINREFRACTIONALPHA = false;
      defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;
      defines.SS_ALBEDOFORREFRACTIONTINT = false;
      if (this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled) {
        defines.SUBSURFACE = true;
        if (defines._areTexturesDirty) {
          if (scene.texturesEnabled) {
            if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
              MaterialHelper.PrepareDefinesForMergedUV(this._thicknessTexture, defines, "SS_THICKNESSANDMASK_TEXTURE");
            }
          }
        }
        defines.SS_MASK_FROM_THICKNESS_TEXTURE = this._useMaskFromThicknessTexture;
        defines.SS_MASK_FROM_THICKNESS_TEXTURE_GLTF = this._useMaskFromThicknessTextureGltf;
      }
      if (this._isRefractionEnabled) {
        if (scene.texturesEnabled) {
          var refractionTexture = this._getRefractionTexture(scene);
          if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
            defines.SS_REFRACTION = true;
            defines.SS_REFRACTIONMAP_3D = refractionTexture.isCube;
            defines.SS_GAMMAREFRACTION = refractionTexture.gammaSpace;
            defines.SS_RGBDREFRACTION = refractionTexture.isRGBD;
            defines.SS_LINEARSPECULARREFRACTION = refractionTexture.linearSpecularLOD;
            defines.SS_REFRACTIONMAP_OPPOSITEZ = refractionTexture.invertZ;
            defines.SS_LODINREFRACTIONALPHA = refractionTexture.lodLevelInAlpha;
            defines.SS_LINKREFRACTIONTOTRANSPARENCY = this._linkRefractionWithTransparency;
            defines.SS_ALBEDOFORREFRACTIONTINT = this.useAlbedoToTintRefraction;
          }
        }
      }
    }
  };
  PBRSubSurfaceConfiguration2.prototype.bindForSubMesh = function(uniformBuffer, scene, engine, isFrozen, lodBasedMicrosurface, realTimeFiltering) {
    var refractionTexture = this._getRefractionTexture(scene);
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
        uniformBuffer.updateFloat2("vThicknessInfos", this._thicknessTexture.coordinatesIndex, this._thicknessTexture.level);
        MaterialHelper.BindTextureMatrix(this._thicknessTexture, uniformBuffer, "thickness");
      }
      uniformBuffer.updateFloat2("vThicknessParam", this.minimumThickness, this.maximumThickness - this.minimumThickness);
      if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
        uniformBuffer.updateMatrix("refractionMatrix", refractionTexture.getReflectionTextureMatrix());
        var depth = 1;
        if (!refractionTexture.isCube) {
          if (refractionTexture.depth) {
            depth = refractionTexture.depth;
          }
        }
        var width = refractionTexture.getSize().width;
        var refractionIor = this.volumeIndexOfRefraction;
        uniformBuffer.updateFloat4("vRefractionInfos", refractionTexture.level, 1 / refractionIor, depth, this._invertRefractionY ? -1 : 1);
        uniformBuffer.updateFloat3("vRefractionMicrosurfaceInfos", width, refractionTexture.lodGenerationScale, refractionTexture.lodGenerationOffset);
        if (realTimeFiltering) {
          uniformBuffer.updateFloat2("vRefractionFilteringInfo", width, Scalar.Log2(width));
        }
      }
      if (this.isScatteringEnabled) {
        uniformBuffer.updateFloat("scatteringDiffusionProfile", this._scatteringDiffusionProfileIndex);
      }
      uniformBuffer.updateColor3("vDiffusionDistance", this.diffusionDistance);
      uniformBuffer.updateFloat4("vTintColor", this.tintColor.r, this.tintColor.g, this.tintColor.b, this.tintColorAtDistance);
      uniformBuffer.updateFloat3("vSubSurfaceIntensity", this.refractionIntensity, this.translucencyIntensity, 0);
    }
    if (scene.texturesEnabled) {
      if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
        uniformBuffer.setTexture("thicknessSampler", this._thicknessTexture);
      }
      if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
        if (lodBasedMicrosurface) {
          uniformBuffer.setTexture("refractionSampler", refractionTexture);
        } else {
          uniformBuffer.setTexture("refractionSampler", refractionTexture._lodTextureMid || refractionTexture);
          uniformBuffer.setTexture("refractionSamplerLow", refractionTexture._lodTextureLow || refractionTexture);
          uniformBuffer.setTexture("refractionSamplerHigh", refractionTexture._lodTextureHigh || refractionTexture);
        }
      }
    }
  };
  PBRSubSurfaceConfiguration2.prototype.unbind = function(activeEffect) {
    if (this._refractionTexture && this._refractionTexture.isRenderTarget) {
      activeEffect.setTexture("refractionSampler", null);
      return true;
    }
    return false;
  };
  PBRSubSurfaceConfiguration2.prototype._getRefractionTexture = function(scene) {
    if (this._refractionTexture) {
      return this._refractionTexture;
    }
    if (this._isRefractionEnabled) {
      return scene.environmentTexture;
    }
    return null;
  };
  Object.defineProperty(PBRSubSurfaceConfiguration2.prototype, "disableAlphaBlending", {
    get: function() {
      return this.isRefractionEnabled && this._linkRefractionWithTransparency;
    },
    enumerable: false,
    configurable: true
  });
  PBRSubSurfaceConfiguration2.prototype.fillRenderTargetTextures = function(renderTargets) {
    if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
      renderTargets.push(this._refractionTexture);
    }
  };
  PBRSubSurfaceConfiguration2.prototype.hasTexture = function(texture) {
    if (this._thicknessTexture === texture) {
      return true;
    }
    if (this._refractionTexture === texture) {
      return true;
    }
    return false;
  };
  PBRSubSurfaceConfiguration2.prototype.hasRenderTargetTextures = function() {
    if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
      return true;
    }
    return false;
  };
  PBRSubSurfaceConfiguration2.prototype.getActiveTextures = function(activeTextures) {
    if (this._thicknessTexture) {
      activeTextures.push(this._thicknessTexture);
    }
    if (this._refractionTexture) {
      activeTextures.push(this._refractionTexture);
    }
  };
  PBRSubSurfaceConfiguration2.prototype.getAnimatables = function(animatables) {
    if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {
      animatables.push(this._thicknessTexture);
    }
    if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {
      animatables.push(this._refractionTexture);
    }
  };
  PBRSubSurfaceConfiguration2.prototype.dispose = function(forceDisposeTextures) {
    if (forceDisposeTextures) {
      if (this._thicknessTexture) {
        this._thicknessTexture.dispose();
      }
      if (this._refractionTexture) {
        this._refractionTexture.dispose();
      }
    }
  };
  PBRSubSurfaceConfiguration2.prototype.getClassName = function() {
    return "PBRSubSurfaceConfiguration";
  };
  PBRSubSurfaceConfiguration2.AddFallbacks = function(defines, fallbacks, currentRank) {
    if (defines.SS_SCATTERING) {
      fallbacks.addFallback(currentRank++, "SS_SCATTERING");
    }
    if (defines.SS_TRANSLUCENCY) {
      fallbacks.addFallback(currentRank++, "SS_TRANSLUCENCY");
    }
    return currentRank;
  };
  PBRSubSurfaceConfiguration2.AddUniforms = function(uniforms) {
    uniforms.push("vDiffusionDistance", "vTintColor", "vSubSurfaceIntensity", "vRefractionMicrosurfaceInfos", "vRefractionFilteringInfo", "vRefractionInfos", "vThicknessInfos", "vThicknessParam", "refractionMatrix", "thicknessMatrix", "scatteringDiffusionProfile");
  };
  PBRSubSurfaceConfiguration2.AddSamplers = function(samplers) {
    samplers.push("thicknessSampler", "refractionSampler", "refractionSamplerLow", "refractionSamplerHigh");
  };
  PBRSubSurfaceConfiguration2.PrepareUniformBuffer = function(uniformBuffer) {
    uniformBuffer.addUniform("vRefractionMicrosurfaceInfos", 3);
    uniformBuffer.addUniform("vRefractionFilteringInfo", 2);
    uniformBuffer.addUniform("vRefractionInfos", 4);
    uniformBuffer.addUniform("refractionMatrix", 16);
    uniformBuffer.addUniform("vThicknessInfos", 2);
    uniformBuffer.addUniform("thicknessMatrix", 16);
    uniformBuffer.addUniform("vThicknessParam", 2);
    uniformBuffer.addUniform("vDiffusionDistance", 3);
    uniformBuffer.addUniform("vTintColor", 4);
    uniformBuffer.addUniform("vSubSurfaceIntensity", 3);
    uniformBuffer.addUniform("scatteringDiffusionProfile", 1);
  };
  PBRSubSurfaceConfiguration2.prototype.copyTo = function(configuration) {
    SerializationHelper.Clone(function() {
      return configuration;
    }, this);
  };
  PBRSubSurfaceConfiguration2.prototype.serialize = function() {
    return SerializationHelper.Serialize(this);
  };
  PBRSubSurfaceConfiguration2.prototype.parse = function(source, scene, rootUrl) {
    var _this = this;
    SerializationHelper.Parse(function() {
      return _this;
    }, source, scene, rootUrl);
  };
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRSubSurfaceConfiguration2.prototype, "isRefractionEnabled", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRSubSurfaceConfiguration2.prototype, "isTranslucencyEnabled", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markScenePrePassDirty")
  ], PBRSubSurfaceConfiguration2.prototype, "isScatteringEnabled", void 0);
  __decorate([
    serialize()
  ], PBRSubSurfaceConfiguration2.prototype, "_scatteringDiffusionProfileIndex", void 0);
  __decorate([
    serialize()
  ], PBRSubSurfaceConfiguration2.prototype, "refractionIntensity", void 0);
  __decorate([
    serialize()
  ], PBRSubSurfaceConfiguration2.prototype, "translucencyIntensity", void 0);
  __decorate([
    serialize()
  ], PBRSubSurfaceConfiguration2.prototype, "useAlbedoToTintRefraction", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRSubSurfaceConfiguration2.prototype, "thicknessTexture", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRSubSurfaceConfiguration2.prototype, "refractionTexture", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRSubSurfaceConfiguration2.prototype, "indexOfRefraction", void 0);
  __decorate([
    serialize()
  ], PBRSubSurfaceConfiguration2.prototype, "_volumeIndexOfRefraction", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRSubSurfaceConfiguration2.prototype, "volumeIndexOfRefraction", null);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRSubSurfaceConfiguration2.prototype, "invertRefractionY", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRSubSurfaceConfiguration2.prototype, "linkRefractionWithTransparency", void 0);
  __decorate([
    serialize()
  ], PBRSubSurfaceConfiguration2.prototype, "minimumThickness", void 0);
  __decorate([
    serialize()
  ], PBRSubSurfaceConfiguration2.prototype, "maximumThickness", void 0);
  __decorate([
    serializeAsColor3()
  ], PBRSubSurfaceConfiguration2.prototype, "tintColor", void 0);
  __decorate([
    serialize()
  ], PBRSubSurfaceConfiguration2.prototype, "tintColorAtDistance", void 0);
  __decorate([
    serializeAsColor3()
  ], PBRSubSurfaceConfiguration2.prototype, "diffusionDistance", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRSubSurfaceConfiguration2.prototype, "useMaskFromThicknessTexture", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRSubSurfaceConfiguration2.prototype, "useMaskFromThicknessTextureGltf", void 0);
  return PBRSubSurfaceConfiguration2;
}();

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentDeclaration.js
var name4 = "pbrFragmentDeclaration";
var shader4 = "uniform vec3 vReflectionColor;\nuniform vec4 vAlbedoColor;\n\nuniform vec4 vLightingIntensity;\nuniform vec4 vReflectivityColor;\nuniform vec4 vMetallicReflectanceFactors;\nuniform vec3 vEmissiveColor;\nuniform float visibility;\n\n#ifdef ALBEDO\nuniform vec2 vAlbedoInfos;\n#endif\n#ifdef AMBIENT\nuniform vec4 vAmbientInfos;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform vec2 vTangentSpaceParams;\n#endif\n#ifdef OPACITY\nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\n#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;\n#endif\n#ifdef REFLECTIVITY\nuniform vec3 vReflectivityInfos;\n#endif\n#ifdef MICROSURFACEMAP\nuniform vec2 vMicroSurfaceSamplerInfos;\n#endif\n\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(SS_REFRACTION)\nuniform mat4 view;\n#endif\n\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;\n#ifdef REALTIME_FILTERING\nuniform vec2 vReflectionFilteringInfo;\n#endif\nuniform mat4 reflectionMatrix;\nuniform vec3 vReflectionMicrosurfaceInfos;\n#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)\nuniform vec3 vReflectionPosition;\nuniform vec3 vReflectionSize;\n#endif\n#endif\n\n#ifdef CLEARCOAT\nuniform vec2 vClearCoatParams;\nuniform vec4 vClearCoatRefractionParams;\n#if defined(CLEARCOAT_TEXTURE) || defined(CLEARCOAT_TEXTURE_ROUGHNESS)\nuniform vec4 vClearCoatInfos;\n#endif\n#ifdef CLEARCOAT_TEXTURE\nuniform mat4 clearCoatMatrix;\n#endif\n#ifdef CLEARCOAT_TEXTURE_ROUGHNESS\nuniform mat4 clearCoatRoughnessMatrix;\n#endif\n#ifdef CLEARCOAT_BUMP\nuniform vec2 vClearCoatBumpInfos;\nuniform vec2 vClearCoatTangentSpaceParams;\nuniform mat4 clearCoatBumpMatrix;\n#endif\n#ifdef CLEARCOAT_TINT\nuniform vec4 vClearCoatTintParams;\nuniform float clearCoatColorAtDistance;\n#ifdef CLEARCOAT_TINT_TEXTURE\nuniform vec2 vClearCoatTintInfos;\nuniform mat4 clearCoatTintMatrix;\n#endif\n#endif\n#endif\n\n#ifdef ANISOTROPIC\nuniform vec3 vAnisotropy;\n#ifdef ANISOTROPIC_TEXTURE\nuniform vec2 vAnisotropyInfos;\nuniform mat4 anisotropyMatrix;\n#endif\n#endif\n\n#ifdef SHEEN\nuniform vec4 vSheenColor;\n#ifdef SHEEN_ROUGHNESS\nuniform float vSheenRoughness;\n#endif\n#if defined(SHEEN_TEXTURE) || defined(SHEEN_TEXTURE_ROUGHNESS)\nuniform vec4 vSheenInfos;\n#endif\n#ifdef SHEEN_TEXTURE\nuniform mat4 sheenMatrix;\n#endif\n#ifdef SHEEN_TEXTURE_ROUGHNESS\nuniform mat4 sheenRoughnessMatrix;\n#endif\n#endif\n\n#ifdef SUBSURFACE\n#ifdef SS_REFRACTION\nuniform vec3 vRefractionMicrosurfaceInfos;\nuniform vec4 vRefractionInfos;\nuniform mat4 refractionMatrix;\n#ifdef REALTIME_FILTERING\nuniform vec2 vRefractionFilteringInfo;\n#endif\n#endif\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nuniform vec2 vThicknessInfos;\nuniform mat4 thicknessMatrix;\n#endif\nuniform vec2 vThicknessParam;\nuniform vec3 vDiffusionDistance;\nuniform vec4 vTintColor;\nuniform vec3 vSubSurfaceIntensity;\n#endif\n#ifdef PREPASS\n#ifdef PREPASS_IRRADIANCE\nuniform float scatteringDiffusionProfile;\n#endif\n#endif";
Effect.IncludesShadersStore[name4] = shader4;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrUboDeclaration.js
var name5 = "pbrUboDeclaration";
var shader5 = "layout(std140,column_major) uniform;\nuniform Material\n{\nuniform vec2 vAlbedoInfos;\nuniform vec4 vAmbientInfos;\nuniform vec2 vOpacityInfos;\nuniform vec2 vEmissiveInfos;\nuniform vec2 vLightmapInfos;\nuniform vec3 vReflectivityInfos;\nuniform vec2 vMicroSurfaceSamplerInfos;\nuniform vec2 vReflectionInfos;\nuniform vec2 vReflectionFilteringInfo;\nuniform vec3 vReflectionPosition;\nuniform vec3 vReflectionSize;\nuniform vec3 vBumpInfos;\nuniform mat4 albedoMatrix;\nuniform mat4 ambientMatrix;\nuniform mat4 opacityMatrix;\nuniform mat4 emissiveMatrix;\nuniform mat4 lightmapMatrix;\nuniform mat4 reflectivityMatrix;\nuniform mat4 microSurfaceSamplerMatrix;\nuniform mat4 bumpMatrix;\nuniform vec2 vTangentSpaceParams;\nuniform mat4 reflectionMatrix;\nuniform vec3 vReflectionColor;\nuniform vec4 vAlbedoColor;\nuniform vec4 vLightingIntensity;\nuniform vec3 vReflectionMicrosurfaceInfos;\nuniform float pointSize;\nuniform vec4 vReflectivityColor;\nuniform vec3 vEmissiveColor;\nuniform float visibility;\nuniform vec4 vMetallicReflectanceFactors;\nuniform vec2 vMetallicReflectanceInfos;\nuniform mat4 metallicReflectanceMatrix;\nuniform vec2 vClearCoatParams;\nuniform vec4 vClearCoatRefractionParams;\nuniform vec4 vClearCoatInfos;\nuniform mat4 clearCoatMatrix;\nuniform mat4 clearCoatRoughnessMatrix;\nuniform vec2 vClearCoatBumpInfos;\nuniform vec2 vClearCoatTangentSpaceParams;\nuniform mat4 clearCoatBumpMatrix;\nuniform vec4 vClearCoatTintParams;\nuniform float clearCoatColorAtDistance;\nuniform vec2 vClearCoatTintInfos;\nuniform mat4 clearCoatTintMatrix;\nuniform vec3 vAnisotropy;\nuniform vec2 vAnisotropyInfos;\nuniform mat4 anisotropyMatrix;\nuniform vec4 vSheenColor;\nuniform float vSheenRoughness;\nuniform vec4 vSheenInfos;\nuniform mat4 sheenMatrix;\nuniform mat4 sheenRoughnessMatrix;\nuniform vec3 vRefractionMicrosurfaceInfos;\nuniform vec2 vRefractionFilteringInfo;\nuniform vec4 vRefractionInfos;\nuniform mat4 refractionMatrix;\nuniform vec2 vThicknessInfos;\nuniform mat4 thicknessMatrix;\nuniform vec2 vThicknessParam;\nuniform vec3 vDiffusionDistance;\nuniform vec4 vTintColor;\nuniform vec3 vSubSurfaceIntensity;\nuniform float scatteringDiffusionProfile;\nuniform vec4 vDetailInfos;\nuniform mat4 detailMatrix;\n};\nuniform Scene {\nmat4 viewProjection;\n#ifdef MULTIVIEW\nmat4 viewProjectionR;\n#endif\nmat4 view;\n};";
Effect.IncludesShadersStore[name5] = shader5;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentExtraDeclaration.js
var name6 = "pbrFragmentExtraDeclaration";
var shader6 = "uniform vec4 vEyePosition;\nuniform vec3 vAmbientColor;\nuniform vec4 vCameraInfos;\n\nvarying vec3 vPositionW;\n#if DEBUGMODE>0\nuniform vec2 vDebugMode;\nvarying vec4 vClipSpacePosition;\n#endif\n#ifdef MAINUV1\nvarying vec2 vMainUV1;\n#endif\n#ifdef MAINUV2\nvarying vec2 vMainUV2;\n#endif\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\nvarying vec3 vEnvironmentIrradiance;\n#endif\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif";
Effect.IncludesShadersStore[name6] = shader6;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentSamplersDeclaration.js
var name7 = "pbrFragmentSamplersDeclaration";
var shader7 = "#ifdef ALBEDO\n#if ALBEDODIRECTUV == 1\n#define vAlbedoUV vMainUV1\n#elif ALBEDODIRECTUV == 2\n#define vAlbedoUV vMainUV2\n#else\nvarying vec2 vAlbedoUV;\n#endif\nuniform sampler2D albedoSampler;\n#endif\n#ifdef AMBIENT\n#if AMBIENTDIRECTUV == 1\n#define vAmbientUV vMainUV1\n#elif AMBIENTDIRECTUV == 2\n#define vAmbientUV vMainUV2\n#else\nvarying vec2 vAmbientUV;\n#endif\nuniform sampler2D ambientSampler;\n#endif\n#ifdef OPACITY\n#if OPACITYDIRECTUV == 1\n#define vOpacityUV vMainUV1\n#elif OPACITYDIRECTUV == 2\n#define vOpacityUV vMainUV2\n#else\nvarying vec2 vOpacityUV;\n#endif\nuniform sampler2D opacitySampler;\n#endif\n#ifdef EMISSIVE\n#if EMISSIVEDIRECTUV == 1\n#define vEmissiveUV vMainUV1\n#elif EMISSIVEDIRECTUV == 2\n#define vEmissiveUV vMainUV2\n#else\nvarying vec2 vEmissiveUV;\n#endif\nuniform sampler2D emissiveSampler;\n#endif\n#ifdef LIGHTMAP\n#if LIGHTMAPDIRECTUV == 1\n#define vLightmapUV vMainUV1\n#elif LIGHTMAPDIRECTUV == 2\n#define vLightmapUV vMainUV2\n#else\nvarying vec2 vLightmapUV;\n#endif\nuniform sampler2D lightmapSampler;\n#endif\n#ifdef REFLECTIVITY\n#if REFLECTIVITYDIRECTUV == 1\n#define vReflectivityUV vMainUV1\n#elif REFLECTIVITYDIRECTUV == 2\n#define vReflectivityUV vMainUV2\n#else\nvarying vec2 vReflectivityUV;\n#endif\nuniform sampler2D reflectivitySampler;\n#endif\n#ifdef MICROSURFACEMAP\n#if MICROSURFACEMAPDIRECTUV == 1\n#define vMicroSurfaceSamplerUV vMainUV1\n#elif MICROSURFACEMAPDIRECTUV == 2\n#define vMicroSurfaceSamplerUV vMainUV2\n#else\nvarying vec2 vMicroSurfaceSamplerUV;\n#endif\nuniform sampler2D microSurfaceSampler;\n#endif\n#ifdef METALLIC_REFLECTANCE\n#if METALLIC_REFLECTANCEDIRECTUV == 1\n#define vMetallicReflectanceUV vMainUV1\n#elif METALLIC_REFLECTANCEDIRECTUV == 2\n#define vMetallicReflectanceUV vMainUV2\n#else\nvarying vec2 vMetallicReflectanceUV;\n#endif\nuniform sampler2D metallicReflectanceSampler;\n#endif\n#ifdef CLEARCOAT\n#if defined(CLEARCOAT_TEXTURE)\n#if CLEARCOAT_TEXTUREDIRECTUV == 1\n#define vClearCoatUV vMainUV1\n#elif CLEARCOAT_TEXTUREDIRECTUV == 2\n#define vClearCoatUV vMainUV2\n#else\nvarying vec2 vClearCoatUV;\n#endif\n#endif\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS)\n#if CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV == 1\n#define vClearCoatRoughnessUV vMainUV1\n#elif CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV == 2\n#define vClearCoatRoughnessUV vMainUV2\n#else\nvarying vec2 vClearCoatRoughnessUV;\n#endif\n#endif\n#ifdef CLEARCOAT_TEXTURE\nuniform sampler2D clearCoatSampler;\n#endif\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL)\nuniform sampler2D clearCoatRoughnessSampler;\n#endif\n#ifdef CLEARCOAT_BUMP\n#if CLEARCOAT_BUMPDIRECTUV == 1\n#define vClearCoatBumpUV vMainUV1\n#elif CLEARCOAT_BUMPDIRECTUV == 2\n#define vClearCoatBumpUV vMainUV2\n#else\nvarying vec2 vClearCoatBumpUV;\n#endif\nuniform sampler2D clearCoatBumpSampler;\n#endif\n#ifdef CLEARCOAT_TINT_TEXTURE\n#if CLEARCOAT_TINT_TEXTUREDIRECTUV == 1\n#define vClearCoatTintUV vMainUV1\n#elif CLEARCOAT_TINT_TEXTUREDIRECTUV == 2\n#define vClearCoatTintUV vMainUV2\n#else\nvarying vec2 vClearCoatTintUV;\n#endif\nuniform sampler2D clearCoatTintSampler;\n#endif\n#endif\n#ifdef SHEEN\n#ifdef SHEEN_TEXTURE\n#if SHEEN_TEXTUREDIRECTUV == 1\n#define vSheenUV vMainUV1\n#elif SHEEN_TEXTUREDIRECTUV == 2\n#define vSheenUV vMainUV2\n#else\nvarying vec2 vSheenUV;\n#endif\n#endif\n#ifdef SHEEN_TEXTURE_ROUGHNESS\n#if SHEEN_TEXTURE_ROUGHNESSDIRECTUV == 1\n#define vSheenRoughnessUV vMainUV1\n#elif SHEEN_TEXTURE_ROUGHNESSDIRECTUV == 2\n#define vSheenRoughnessUV vMainUV2\n#else\nvarying vec2 vSheenRoughnessUV;\n#endif\n#endif\n#ifdef SHEEN_TEXTURE\nuniform sampler2D sheenSampler;\n#endif\n#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL)\nuniform sampler2D sheenRoughnessSampler;\n#endif\n#endif\n#ifdef ANISOTROPIC\n#ifdef ANISOTROPIC_TEXTURE\n#if ANISOTROPIC_TEXTUREDIRECTUV == 1\n#define vAnisotropyUV vMainUV1\n#elif ANISOTROPIC_TEXTUREDIRECTUV == 2\n#define vAnisotropyUV vMainUV2\n#else\nvarying vec2 vAnisotropyUV;\n#endif\nuniform sampler2D anisotropySampler;\n#endif\n#endif\n\n#ifdef REFLECTION\n#ifdef REFLECTIONMAP_3D\n#define sampleReflection(s,c) textureCube(s,c)\nuniform samplerCube reflectionSampler;\n#ifdef LODBASEDMICROSFURACE\n#define sampleReflectionLod(s,c,l) textureCubeLodEXT(s,c,l)\n#else\nuniform samplerCube reflectionSamplerLow;\nuniform samplerCube reflectionSamplerHigh;\n#endif\n#ifdef USEIRRADIANCEMAP\nuniform samplerCube irradianceSampler;\n#endif\n#else\n#define sampleReflection(s,c) texture2D(s,c)\nuniform sampler2D reflectionSampler;\n#ifdef LODBASEDMICROSFURACE\n#define sampleReflectionLod(s,c,l) texture2DLodEXT(s,c,l)\n#else\nuniform sampler2D reflectionSamplerLow;\nuniform sampler2D reflectionSamplerHigh;\n#endif\n#ifdef USEIRRADIANCEMAP\nuniform sampler2D irradianceSampler;\n#endif\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#else\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#endif\n#endif\n#ifdef ENVIRONMENTBRDF\nuniform sampler2D environmentBrdfSampler;\n#endif\n\n#ifdef SUBSURFACE\n#ifdef SS_REFRACTION\n#ifdef SS_REFRACTIONMAP_3D\n#define sampleRefraction(s,c) textureCube(s,c)\nuniform samplerCube refractionSampler;\n#ifdef LODBASEDMICROSFURACE\n#define sampleRefractionLod(s,c,l) textureCubeLodEXT(s,c,l)\n#else\nuniform samplerCube refractionSamplerLow;\nuniform samplerCube refractionSamplerHigh;\n#endif\n#else\n#define sampleRefraction(s,c) texture2D(s,c)\nuniform sampler2D refractionSampler;\n#ifdef LODBASEDMICROSFURACE\n#define sampleRefractionLod(s,c,l) texture2DLodEXT(s,c,l)\n#else\nuniform sampler2D refractionSamplerLow;\nuniform sampler2D refractionSamplerHigh;\n#endif\n#endif\n#endif\n#ifdef SS_THICKNESSANDMASK_TEXTURE\n#if SS_THICKNESSANDMASK_TEXTUREDIRECTUV == 1\n#define vThicknessUV vMainUV1\n#elif SS_THICKNESSANDMASK_TEXTUREDIRECTUV == 2\n#define vThicknessUV vMainUV2\n#else\nvarying vec2 vThicknessUV;\n#endif\nuniform sampler2D thicknessSampler;\n#endif\n#endif";
Effect.IncludesShadersStore[name7] = shader7;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/subSurfaceScatteringFunctions.js
var name8 = "subSurfaceScatteringFunctions";
var shader8 = "bool testLightingForSSS(float diffusionProfile)\n{\nreturn diffusionProfile<1.;\n}";
Effect.IncludesShadersStore[name8] = shader8;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/importanceSampling.js
var name9 = "importanceSampling";
var shader9 = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvec3 hemisphereCosSample(vec2 u) {\n\nfloat phi=2.*PI*u.x;\nfloat cosTheta2=1.-u.y;\nfloat cosTheta=sqrt(cosTheta2);\nfloat sinTheta=sqrt(1.-cosTheta2);\nreturn vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvec3 hemisphereImportanceSampleDggx(vec2 u,float a) {\n\nfloat phi=2.*PI*u.x;\n\nfloat cosTheta2=(1.-u.y)/(1.+(a+1.)*((a-1.)*u.y));\nfloat cosTheta=sqrt(cosTheta2);\nfloat sinTheta=sqrt(1.-cosTheta2);\nreturn vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvec3 hemisphereImportanceSampleDCharlie(vec2 u,float a) {\n\nfloat phi=2.*PI*u.x;\nfloat sinTheta=pow(u.y,a/(2.*a+1.));\nfloat cosTheta=sqrt(1.-sinTheta*sinTheta);\nreturn vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);\n}";
Effect.IncludesShadersStore[name9] = shader9;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrHelperFunctions.js
var name10 = "pbrHelperFunctions";
var shader10 = "\n#define RECIPROCAL_PI2 0.15915494\n#define RECIPROCAL_PI 0.31830988618\n\n#define MINIMUMVARIANCE 0.0005\nfloat convertRoughnessToAverageSlope(float roughness)\n{\n\nreturn square(roughness)+MINIMUMVARIANCE;\n}\nfloat fresnelGrazingReflectance(float reflectance0) {\n\n\nfloat reflectance90=saturate(reflectance0*25.0);\nreturn reflectance90;\n}\nvec2 getAARoughnessFactors(vec3 normalVector) {\n#ifdef SPECULARAA\nvec3 nDfdx=dFdx(normalVector.xyz);\nvec3 nDfdy=dFdy(normalVector.xyz);\nfloat slopeSquare=max(dot(nDfdx,nDfdx),dot(nDfdy,nDfdy));\n\nfloat geometricRoughnessFactor=pow(saturate(slopeSquare),0.333);\n\nfloat geometricAlphaGFactor=sqrt(slopeSquare);\n\ngeometricAlphaGFactor*=0.75;\nreturn vec2(geometricRoughnessFactor,geometricAlphaGFactor);\n#else\nreturn vec2(0.);\n#endif\n}\n#ifdef ANISOTROPIC\n\n\nvec2 getAnisotropicRoughness(float alphaG,float anisotropy) {\nfloat alphaT=max(alphaG*(1.0+anisotropy),MINIMUMVARIANCE);\nfloat alphaB=max(alphaG*(1.0-anisotropy),MINIMUMVARIANCE);\nreturn vec2(alphaT,alphaB);\n}\n\n\nvec3 getAnisotropicBentNormals(const vec3 T,const vec3 B,const vec3 N,const vec3 V,float anisotropy) {\nvec3 anisotropicFrameDirection=anisotropy>=0.0 ? B : T;\nvec3 anisotropicFrameTangent=cross(normalize(anisotropicFrameDirection),V);\nvec3 anisotropicFrameNormal=cross(anisotropicFrameTangent,anisotropicFrameDirection);\nvec3 anisotropicNormal=normalize(mix(N,anisotropicFrameNormal,abs(anisotropy)));\nreturn anisotropicNormal;\n\n}\n#endif\n#if defined(CLEARCOAT) || defined(SS_REFRACTION)\n\n\n\nvec3 cocaLambert(vec3 alpha,float distance) {\nreturn exp(-alpha*distance);\n}\n\nvec3 cocaLambert(float NdotVRefract,float NdotLRefract,vec3 alpha,float thickness) {\nreturn cocaLambert(alpha,(thickness*((NdotLRefract+NdotVRefract)/(NdotLRefract*NdotVRefract))));\n}\n\nvec3 computeColorAtDistanceInMedia(vec3 color,float distance) {\nreturn -log(color)/distance;\n}\nvec3 computeClearCoatAbsorption(float NdotVRefract,float NdotLRefract,vec3 clearCoatColor,float clearCoatThickness,float clearCoatIntensity) {\nvec3 clearCoatAbsorption=mix(vec3(1.0),\ncocaLambert(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness),\nclearCoatIntensity);\nreturn clearCoatAbsorption;\n}\n#endif\n\n\n\n\n#ifdef MICROSURFACEAUTOMATIC\nfloat computeDefaultMicroSurface(float microSurface,vec3 reflectivityColor)\n{\nconst float kReflectivityNoAlphaWorkflow_SmoothnessMax=0.95;\nfloat reflectivityLuminance=getLuminance(reflectivityColor);\nfloat reflectivityLuma=sqrt(reflectivityLuminance);\nmicroSurface=reflectivityLuma*kReflectivityNoAlphaWorkflow_SmoothnessMax;\nreturn microSurface;\n}\n#endif";
Effect.IncludesShadersStore[name10] = shader10;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/harmonicsFunctions.js
var name11 = "harmonicsFunctions";
var shader11 = "#ifdef USESPHERICALFROMREFLECTIONMAP\n#ifdef SPHERICAL_HARMONICS\nuniform vec3 vSphericalL00;\nuniform vec3 vSphericalL1_1;\nuniform vec3 vSphericalL10;\nuniform vec3 vSphericalL11;\nuniform vec3 vSphericalL2_2;\nuniform vec3 vSphericalL2_1;\nuniform vec3 vSphericalL20;\nuniform vec3 vSphericalL21;\nuniform vec3 vSphericalL22;\n\n\n\n\n\n\n\nvec3 computeEnvironmentIrradiance(vec3 normal) {\nreturn vSphericalL00\n+vSphericalL1_1*(normal.y)\n+vSphericalL10*(normal.z)\n+vSphericalL11*(normal.x)\n+vSphericalL2_2*(normal.y*normal.x)\n+vSphericalL2_1*(normal.y*normal.z)\n+vSphericalL20*((3.0*normal.z*normal.z)-1.0)\n+vSphericalL21*(normal.z*normal.x)\n+vSphericalL22*(normal.x*normal.x-(normal.y*normal.y));\n}\n#else\nuniform vec3 vSphericalX;\nuniform vec3 vSphericalY;\nuniform vec3 vSphericalZ;\nuniform vec3 vSphericalXX_ZZ;\nuniform vec3 vSphericalYY_ZZ;\nuniform vec3 vSphericalZZ;\nuniform vec3 vSphericalXY;\nuniform vec3 vSphericalYZ;\nuniform vec3 vSphericalZX;\n\nvec3 computeEnvironmentIrradiance(vec3 normal) {\n\n\n\n\n\n\n\n\n\nfloat Nx=normal.x;\nfloat Ny=normal.y;\nfloat Nz=normal.z;\nvec3 C1=vSphericalZZ.rgb;\nvec3 Cx=vSphericalX.rgb;\nvec3 Cy=vSphericalY.rgb;\nvec3 Cz=vSphericalZ.rgb;\nvec3 Cxx_zz=vSphericalXX_ZZ.rgb;\nvec3 Cyy_zz=vSphericalYY_ZZ.rgb;\nvec3 Cxy=vSphericalXY.rgb;\nvec3 Cyz=vSphericalYZ.rgb;\nvec3 Czx=vSphericalZX.rgb;\nvec3 a1=Cyy_zz*Ny+Cy;\nvec3 a2=Cyz*Nz+a1;\nvec3 b1=Czx*Nz+Cx;\nvec3 b2=Cxy*Ny+b1;\nvec3 b3=Cxx_zz*Nx+b2;\nvec3 t1=Cz*Nz+C1;\nvec3 t2=a2*Ny+t1;\nvec3 t3=b3*Nx+t2;\nreturn t3;\n}\n#endif\n#endif";
Effect.IncludesShadersStore[name11] = shader11;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDirectLightingSetupFunctions.js
var name12 = "pbrDirectLightingSetupFunctions";
var shader12 = "\nstruct preLightingInfo\n{\n\nvec3 lightOffset;\nfloat lightDistanceSquared;\nfloat lightDistance;\n\nfloat attenuation;\n\nvec3 L;\nvec3 H;\nfloat NdotV;\nfloat NdotLUnclamped;\nfloat NdotL;\nfloat VdotH;\nfloat roughness;\n};\npreLightingInfo computePointAndSpotPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {\npreLightingInfo result;\n\nresult.lightOffset=lightData.xyz-vPositionW;\nresult.lightDistanceSquared=dot(result.lightOffset,result.lightOffset);\n\nresult.lightDistance=sqrt(result.lightDistanceSquared);\n\nresult.L=normalize(result.lightOffset);\nresult.H=normalize(V+result.L);\nresult.VdotH=saturate(dot(V,result.H));\nresult.NdotLUnclamped=dot(N,result.L);\nresult.NdotL=saturateEps(result.NdotLUnclamped);\nreturn result;\n}\npreLightingInfo computeDirectionalPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {\npreLightingInfo result;\n\nresult.lightDistance=length(-lightData.xyz);\n\nresult.L=normalize(-lightData.xyz);\nresult.H=normalize(V+result.L);\nresult.VdotH=saturate(dot(V,result.H));\nresult.NdotLUnclamped=dot(N,result.L);\nresult.NdotL=saturateEps(result.NdotLUnclamped);\nreturn result;\n}\npreLightingInfo computeHemisphericPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {\npreLightingInfo result;\n\n\nresult.NdotL=dot(N,lightData.xyz)*0.5+0.5;\nresult.NdotL=saturateEps(result.NdotL);\nresult.NdotLUnclamped=result.NdotL;\n#ifdef SPECULARTERM\nresult.L=normalize(lightData.xyz);\nresult.H=normalize(V+result.L);\nresult.VdotH=saturate(dot(V,result.H));\n#endif\nreturn result;\n}";
Effect.IncludesShadersStore[name12] = shader12;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDirectLightingFalloffFunctions.js
var name13 = "pbrDirectLightingFalloffFunctions";
var shader13 = "float computeDistanceLightFalloff_Standard(vec3 lightOffset,float range)\n{\nreturn max(0.,1.0-length(lightOffset)/range);\n}\nfloat computeDistanceLightFalloff_Physical(float lightDistanceSquared)\n{\nreturn 1.0/maxEps(lightDistanceSquared);\n}\nfloat computeDistanceLightFalloff_GLTF(float lightDistanceSquared,float inverseSquaredRange)\n{\nfloat lightDistanceFalloff=1.0/maxEps(lightDistanceSquared);\nfloat factor=lightDistanceSquared*inverseSquaredRange;\nfloat attenuation=saturate(1.0-factor*factor);\nattenuation*=attenuation;\n\nlightDistanceFalloff*=attenuation;\nreturn lightDistanceFalloff;\n}\nfloat computeDistanceLightFalloff(vec3 lightOffset,float lightDistanceSquared,float range,float inverseSquaredRange)\n{\n#ifdef USEPHYSICALLIGHTFALLOFF\nreturn computeDistanceLightFalloff_Physical(lightDistanceSquared);\n#elif defined(USEGLTFLIGHTFALLOFF)\nreturn computeDistanceLightFalloff_GLTF(lightDistanceSquared,inverseSquaredRange);\n#else\nreturn computeDistanceLightFalloff_Standard(lightOffset,range);\n#endif\n}\nfloat computeDirectionalLightFalloff_Standard(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle,float exponent)\n{\nfloat falloff=0.0;\nfloat cosAngle=maxEps(dot(-lightDirection,directionToLightCenterW));\nif (cosAngle>=cosHalfAngle)\n{\nfalloff=max(0.,pow(cosAngle,exponent));\n}\nreturn falloff;\n}\nfloat computeDirectionalLightFalloff_Physical(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle)\n{\nconst float kMinusLog2ConeAngleIntensityRatio=6.64385618977;\n\n\n\n\n\nfloat concentrationKappa=kMinusLog2ConeAngleIntensityRatio/(1.0-cosHalfAngle);\n\n\nvec4 lightDirectionSpreadSG=vec4(-lightDirection*concentrationKappa,-concentrationKappa);\nfloat falloff=exp2(dot(vec4(directionToLightCenterW,1.0),lightDirectionSpreadSG));\nreturn falloff;\n}\nfloat computeDirectionalLightFalloff_GLTF(vec3 lightDirection,vec3 directionToLightCenterW,float lightAngleScale,float lightAngleOffset)\n{\n\n\n\nfloat cd=dot(-lightDirection,directionToLightCenterW);\nfloat falloff=saturate(cd*lightAngleScale+lightAngleOffset);\n\nfalloff*=falloff;\nreturn falloff;\n}\nfloat computeDirectionalLightFalloff(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle,float exponent,float lightAngleScale,float lightAngleOffset)\n{\n#ifdef USEPHYSICALLIGHTFALLOFF\nreturn computeDirectionalLightFalloff_Physical(lightDirection,directionToLightCenterW,cosHalfAngle);\n#elif defined(USEGLTFLIGHTFALLOFF)\nreturn computeDirectionalLightFalloff_GLTF(lightDirection,directionToLightCenterW,lightAngleScale,lightAngleOffset);\n#else\nreturn computeDirectionalLightFalloff_Standard(lightDirection,directionToLightCenterW,cosHalfAngle,exponent);\n#endif\n}";
Effect.IncludesShadersStore[name13] = shader13;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBRDFFunctions.js
var name14 = "pbrBRDFFunctions";
var shader14 = "\n#define FRESNEL_MAXIMUM_ON_ROUGH 0.25\n\n\n\n\n#ifdef MS_BRDF_ENERGY_CONSERVATION\n\n\nvec3 getEnergyConservationFactor(const vec3 specularEnvironmentR0,const vec3 environmentBrdf) {\nreturn 1.0+specularEnvironmentR0*(1.0/environmentBrdf.y-1.0);\n}\n#endif\n#ifdef ENVIRONMENTBRDF\nvec3 getBRDFLookup(float NdotV,float perceptualRoughness) {\n\nvec2 UV=vec2(NdotV,perceptualRoughness);\n\nvec4 brdfLookup=texture2D(environmentBrdfSampler,UV);\n#ifdef ENVIRONMENTBRDF_RGBD\nbrdfLookup.rgb=fromRGBD(brdfLookup.rgba);\n#endif\nreturn brdfLookup.rgb;\n}\nvec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0,const vec3 specularEnvironmentR90,const vec3 environmentBrdf) {\n#ifdef BRDF_V_HEIGHT_CORRELATED\nvec3 reflectance=(specularEnvironmentR90-specularEnvironmentR0)*environmentBrdf.x+specularEnvironmentR0*environmentBrdf.y;\n\n#else\nvec3 reflectance=specularEnvironmentR0*environmentBrdf.x+specularEnvironmentR90*environmentBrdf.y;\n#endif\nreturn reflectance;\n}\nvec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0,const vec3 environmentBrdf) {\n#ifdef BRDF_V_HEIGHT_CORRELATED\nvec3 reflectance=mix(environmentBrdf.xxx,environmentBrdf.yyy,specularEnvironmentR0);\n#else\nvec3 reflectance=specularEnvironmentR0*environmentBrdf.x+environmentBrdf.y;\n#endif\nreturn reflectance;\n}\n#endif\n\n#if !defined(ENVIRONMENTBRDF) || defined(REFLECTIONMAP_SKYBOX) || defined(ALPHAFRESNEL)\nvec3 getReflectanceFromAnalyticalBRDFLookup_Jones(float VdotN,vec3 reflectance0,vec3 reflectance90,float smoothness)\n{\n\nfloat weight=mix(FRESNEL_MAXIMUM_ON_ROUGH,1.0,smoothness);\nreturn reflectance0+weight*(reflectance90-reflectance0)*pow5(saturate(1.0-VdotN));\n}\n#endif\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF)\n\nvec3 getSheenReflectanceFromBRDFLookup(const vec3 reflectance0,const vec3 environmentBrdf) {\nvec3 sheenEnvironmentReflectance=reflectance0*environmentBrdf.b;\nreturn sheenEnvironmentReflectance;\n}\n#endif\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvec3 fresnelSchlickGGX(float VdotH,vec3 reflectance0,vec3 reflectance90)\n{\nreturn reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);\n}\nfloat fresnelSchlickGGX(float VdotH,float reflectance0,float reflectance90)\n{\nreturn reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);\n}\n#ifdef CLEARCOAT\n\n\n\n\n\nvec3 getR0RemappedForClearCoat(vec3 f0) {\n#ifdef CLEARCOAT_DEFAULTIOR\n#ifdef MOBILE\nreturn saturate(f0*(f0*0.526868+0.529324)-0.0482256);\n#else\nreturn saturate(f0*(f0*(0.941892-0.263008*f0)+0.346479)-0.0285998);\n#endif\n#else\nvec3 s=sqrt(f0);\nvec3 t=(vClearCoatRefractionParams.z+vClearCoatRefractionParams.w*s)/(vClearCoatRefractionParams.w+vClearCoatRefractionParams.z*s);\nreturn t*t;\n#endif\n}\n#endif\n\n\n\n\n\n\nfloat normalDistributionFunction_TrowbridgeReitzGGX(float NdotH,float alphaG)\n{\n\n\n\nfloat a2=square(alphaG);\nfloat d=NdotH*NdotH*(a2-1.0)+1.0;\nreturn a2/(PI*d*d);\n}\n#ifdef SHEEN\n\n\nfloat normalDistributionFunction_CharlieSheen(float NdotH,float alphaG)\n{\nfloat invR=1./alphaG;\nfloat cos2h=NdotH*NdotH;\nfloat sin2h=1.-cos2h;\nreturn (2.+invR)*pow(sin2h,invR*.5)/(2.*PI);\n}\n#endif\n#ifdef ANISOTROPIC\n\n\nfloat normalDistributionFunction_BurleyGGX_Anisotropic(float NdotH,float TdotH,float BdotH,const vec2 alphaTB) {\nfloat a2=alphaTB.x*alphaTB.y;\nvec3 v=vec3(alphaTB.y*TdotH,alphaTB.x*BdotH,a2*NdotH);\nfloat v2=dot(v,v);\nfloat w2=a2/v2;\nreturn a2*w2*w2*RECIPROCAL_PI;\n}\n#endif\n\n\n\n\n#ifdef BRDF_V_HEIGHT_CORRELATED\n\n\n\nfloat smithVisibility_GGXCorrelated(float NdotL,float NdotV,float alphaG) {\n#ifdef MOBILE\n\nfloat GGXV=NdotL*(NdotV*(1.0-alphaG)+alphaG);\nfloat GGXL=NdotV*(NdotL*(1.0-alphaG)+alphaG);\nreturn 0.5/(GGXV+GGXL);\n#else\nfloat a2=alphaG*alphaG;\nfloat GGXV=NdotL*sqrt(NdotV*(NdotV-a2*NdotV)+a2);\nfloat GGXL=NdotV*sqrt(NdotL*(NdotL-a2*NdotL)+a2);\nreturn 0.5/(GGXV+GGXL);\n#endif\n}\n#else\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfloat smithVisibilityG1_TrowbridgeReitzGGXFast(float dot,float alphaG)\n{\n#ifdef MOBILE\n\nreturn 1.0/(dot+alphaG+(1.0-alphaG)*dot ));\n#else\nfloat alphaSquared=alphaG*alphaG;\nreturn 1.0/(dot+sqrt(alphaSquared+(1.0-alphaSquared)*dot*dot));\n#endif\n}\nfloat smithVisibility_TrowbridgeReitzGGXFast(float NdotL,float NdotV,float alphaG)\n{\nfloat visibility=smithVisibilityG1_TrowbridgeReitzGGXFast(NdotL,alphaG)*smithVisibilityG1_TrowbridgeReitzGGXFast(NdotV,alphaG);\n\nreturn visibility;\n}\n#endif\n#ifdef ANISOTROPIC\n\n\nfloat smithVisibility_GGXCorrelated_Anisotropic(float NdotL,float NdotV,float TdotV,float BdotV,float TdotL,float BdotL,const vec2 alphaTB) {\nfloat lambdaV=NdotL*length(vec3(alphaTB.x*TdotV,alphaTB.y*BdotV,NdotV));\nfloat lambdaL=NdotV*length(vec3(alphaTB.x*TdotL,alphaTB.y*BdotL,NdotL));\nfloat v=0.5/(lambdaV+lambdaL);\nreturn v;\n}\n#endif\n#ifdef CLEARCOAT\nfloat visibility_Kelemen(float VdotH) {\n\n\n\nreturn 0.25/(VdotH*VdotH);\n}\n#endif\n#ifdef SHEEN\n\n\n\nfloat visibility_Ashikhmin(float NdotL,float NdotV)\n{\nreturn 1./(4.*(NdotL+NdotV-NdotL*NdotV));\n}\n\n#endif\n\n\n\n\n\n\n\nfloat diffuseBRDF_Burley(float NdotL,float NdotV,float VdotH,float roughness) {\n\n\nfloat diffuseFresnelNV=pow5(saturateEps(1.0-NdotL));\nfloat diffuseFresnelNL=pow5(saturateEps(1.0-NdotV));\nfloat diffuseFresnel90=0.5+2.0*VdotH*VdotH*roughness;\nfloat fresnel =\n(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNL) *\n(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNV);\nreturn fresnel/PI;\n}\n#ifdef SS_TRANSLUCENCY\n\n\nvec3 transmittanceBRDF_Burley(const vec3 tintColor,const vec3 diffusionDistance,float thickness) {\nvec3 S=1./maxEps(diffusionDistance);\nvec3 temp=exp((-0.333333333*thickness)*S);\nreturn tintColor.rgb*0.25*(temp*temp*temp+3.0*temp);\n}\n\n\nfloat computeWrappedDiffuseNdotL(float NdotL,float w) {\nfloat t=1.0+w;\nfloat invt2=1.0/square(t);\nreturn saturate((NdotL+w)*invt2);\n}\n#endif\n";
Effect.IncludesShadersStore[name14] = shader14;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/hdrFilteringFunctions.js
var name15 = "hdrFilteringFunctions";
var shader15 = "#ifdef NUM_SAMPLES\n#if NUM_SAMPLES>0\n#ifdef WEBGL2\n\n\nfloat radicalInverse_VdC(uint bits)\n{\nbits=(bits << 16u) | (bits >> 16u);\nbits=((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\nbits=((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\nbits=((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\nbits=((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\nreturn float(bits)*2.3283064365386963e-10;\n}\nvec2 hammersley(uint i,uint N)\n{\nreturn vec2(float(i)/float(N),radicalInverse_VdC(i));\n}\n#else\nfloat vanDerCorpus(int n,int base)\n{\nfloat invBase=1.0/float(base);\nfloat denom=1.0;\nfloat result=0.0;\nfor(int i=0; i<32; ++i)\n{\nif(n>0)\n{\ndenom=mod(float(n),2.0);\nresult+=denom*invBase;\ninvBase=invBase/2.0;\nn=int(float(n)/2.0);\n}\n}\nreturn result;\n}\nvec2 hammersley(int i,int N)\n{\nreturn vec2(float(i)/float(N),vanDerCorpus(i,2));\n}\n#endif\nfloat log4(float x) {\nreturn log2(x)/2.;\n}\nconst float NUM_SAMPLES_FLOAT=float(NUM_SAMPLES);\nconst float NUM_SAMPLES_FLOAT_INVERSED=1./NUM_SAMPLES_FLOAT;\nconst float K=4.;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define inline\nvec3 irradiance(samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)\n{\nvec3 n=normalize(inputN);\nvec3 result=vec3(0.0);\nvec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);\ntangent=normalize(cross(tangent,n));\nvec3 bitangent=cross(n,tangent);\nmat3 tbn=mat3(tangent,bitangent,n);\nfloat maxLevel=filteringInfo.y;\nfloat dim0=filteringInfo.x;\nfloat omegaP=(4.*PI)/(6.*dim0*dim0);\n#ifdef WEBGL2\nfor(uint i=0u; i<NUM_SAMPLES; ++i)\n#else\nfor(int i=0; i<NUM_SAMPLES; ++i)\n#endif\n{\nvec2 Xi=hammersley(i,NUM_SAMPLES);\nvec3 Ls=hemisphereCosSample(Xi);\nLs=normalize(Ls);\nvec3 Ns=vec3(0.,0.,1.);\nfloat NoL=dot(Ns,Ls);\nif (NoL>0.) {\nfloat pdf_inversed=PI/NoL;\nfloat omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;\nfloat l=log4(omegaS)-log4(omegaP)+log4(K);\nfloat mipLevel=clamp(l,0.0,maxLevel);\nvec3 c=textureCubeLodEXT(inputTexture,tbn*Ls,mipLevel).rgb;\n#ifdef GAMMA_INPUT\nc=toLinearSpace(c);\n#endif\nresult+=c;\n}\n}\nresult=result*NUM_SAMPLES_FLOAT_INVERSED;\nreturn result;\n}\n#define inline\nvec3 radiance(float alphaG,samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)\n{\nvec3 n=normalize(inputN);\nif (alphaG == 0.) {\nvec3 c=textureCube(inputTexture,n).rgb;\n#ifdef GAMMA_INPUT\nc=toLinearSpace(c);\n#endif\nreturn c;\n}\nvec3 result=vec3(0.);\nvec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);\ntangent=normalize(cross(tangent,n));\nvec3 bitangent=cross(n,tangent);\nmat3 tbn=mat3(tangent,bitangent,n);\nfloat maxLevel=filteringInfo.y;\nfloat dim0=filteringInfo.x;\nfloat omegaP=(4.*PI)/(6.*dim0*dim0);\nfloat weight=0.;\n#ifdef WEBGL2\nfor(uint i=0u; i<NUM_SAMPLES; ++i)\n#else\nfor(int i=0; i<NUM_SAMPLES; ++i)\n#endif\n{\nvec2 Xi=hammersley(i,NUM_SAMPLES);\nvec3 H=hemisphereImportanceSampleDggx(Xi,alphaG);\nfloat NoV=1.;\nfloat NoH=H.z;\nfloat NoH2=H.z*H.z;\nfloat NoL=2.*NoH2-1.;\nvec3 L=vec3(2.*NoH*H.x,2.*NoH*H.y,NoL);\nL=normalize(L);\nif (NoL>0.) {\nfloat pdf_inversed=4./normalDistributionFunction_TrowbridgeReitzGGX(NoH,alphaG);\nfloat omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;\nfloat l=log4(omegaS)-log4(omegaP)+log4(K);\nfloat mipLevel=clamp(float(l),0.0,maxLevel);\nweight+=NoL;\nvec3 c=textureCubeLodEXT(inputTexture,tbn*L,mipLevel).rgb;\n#ifdef GAMMA_INPUT\nc=toLinearSpace(c);\n#endif\nresult+=c*NoL;\n}\n}\nresult=result/weight;\nreturn result;\n}\n#endif\n#endif";
Effect.IncludesShadersStore[name15] = shader15;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDirectLightingFunctions.js
var name16 = "pbrDirectLightingFunctions";
var shader16 = "#define CLEARCOATREFLECTANCE90 1.0\n\nstruct lightingInfo\n{\nvec3 diffuse;\n#ifdef SPECULARTERM\nvec3 specular;\n#endif\n#ifdef CLEARCOAT\n\n\nvec4 clearCoat;\n#endif\n#ifdef SHEEN\nvec3 sheen;\n#endif\n};\n\nfloat adjustRoughnessFromLightProperties(float roughness,float lightRadius,float lightDistance) {\n#if defined(USEPHYSICALLIGHTFALLOFF) || defined(USEGLTFLIGHTFALLOFF)\n\nfloat lightRoughness=lightRadius/lightDistance;\n\nfloat totalRoughness=saturate(lightRoughness+roughness);\nreturn totalRoughness;\n#else\nreturn roughness;\n#endif\n}\nvec3 computeHemisphericDiffuseLighting(preLightingInfo info,vec3 lightColor,vec3 groundColor) {\nreturn mix(groundColor,lightColor,info.NdotL);\n}\nvec3 computeDiffuseLighting(preLightingInfo info,vec3 lightColor) {\nfloat diffuseTerm=diffuseBRDF_Burley(info.NdotL,info.NdotV,info.VdotH,info.roughness);\nreturn diffuseTerm*info.attenuation*info.NdotL*lightColor;\n}\n#define inline\nvec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){\nvec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);\nstrq/=strq.w;\nvec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;\nreturn toLinearSpace(textureColor);\n}\n#ifdef SS_TRANSLUCENCY\nvec3 computeDiffuseAndTransmittedLighting(preLightingInfo info,vec3 lightColor,vec3 transmittance) {\nfloat NdotL=absEps(info.NdotLUnclamped);\n\nfloat wrapNdotL=computeWrappedDiffuseNdotL(NdotL,0.02);\n\nfloat trAdapt=step(0.,info.NdotLUnclamped);\nvec3 transmittanceNdotL=mix(transmittance*wrapNdotL,vec3(wrapNdotL),trAdapt);\nfloat diffuseTerm=diffuseBRDF_Burley(NdotL,info.NdotV,info.VdotH,info.roughness);\nreturn diffuseTerm*transmittanceNdotL*info.attenuation*lightColor;\n}\n#endif\n#ifdef SPECULARTERM\nvec3 computeSpecularLighting(preLightingInfo info,vec3 N,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {\nfloat NdotH=saturateEps(dot(N,info.H));\nfloat roughness=max(info.roughness,geometricRoughnessFactor);\nfloat alphaG=convertRoughnessToAverageSlope(roughness);\nvec3 fresnel=fresnelSchlickGGX(info.VdotH,reflectance0,reflectance90);\nfloat distribution=normalDistributionFunction_TrowbridgeReitzGGX(NdotH,alphaG);\n#ifdef BRDF_V_HEIGHT_CORRELATED\nfloat smithVisibility=smithVisibility_GGXCorrelated(info.NdotL,info.NdotV,alphaG);\n#else\nfloat smithVisibility=smithVisibility_TrowbridgeReitzGGXFast(info.NdotL,info.NdotV,alphaG);\n#endif\nvec3 specTerm=fresnel*distribution*smithVisibility;\nreturn specTerm*info.attenuation*info.NdotL*lightColor;\n}\n#endif\n#ifdef ANISOTROPIC\nvec3 computeAnisotropicSpecularLighting(preLightingInfo info,vec3 V,vec3 N,vec3 T,vec3 B,float anisotropy,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {\nfloat NdotH=saturateEps(dot(N,info.H));\nfloat TdotH=dot(T,info.H);\nfloat BdotH=dot(B,info.H);\nfloat TdotV=dot(T,V);\nfloat BdotV=dot(B,V);\nfloat TdotL=dot(T,info.L);\nfloat BdotL=dot(B,info.L);\nfloat alphaG=convertRoughnessToAverageSlope(info.roughness);\nvec2 alphaTB=getAnisotropicRoughness(alphaG,anisotropy);\nalphaTB=max(alphaTB,square(geometricRoughnessFactor));\nvec3 fresnel=fresnelSchlickGGX(info.VdotH,reflectance0,reflectance90);\nfloat distribution=normalDistributionFunction_BurleyGGX_Anisotropic(NdotH,TdotH,BdotH,alphaTB);\nfloat smithVisibility=smithVisibility_GGXCorrelated_Anisotropic(info.NdotL,info.NdotV,TdotV,BdotV,TdotL,BdotL,alphaTB);\nvec3 specTerm=fresnel*distribution*smithVisibility;\nreturn specTerm*info.attenuation*info.NdotL*lightColor;\n}\n#endif\n#ifdef CLEARCOAT\nvec4 computeClearCoatLighting(preLightingInfo info,vec3 Ncc,float geometricRoughnessFactor,float clearCoatIntensity,vec3 lightColor) {\nfloat NccdotL=saturateEps(dot(Ncc,info.L));\nfloat NccdotH=saturateEps(dot(Ncc,info.H));\nfloat clearCoatRoughness=max(info.roughness,geometricRoughnessFactor);\nfloat alphaG=convertRoughnessToAverageSlope(clearCoatRoughness);\nfloat fresnel=fresnelSchlickGGX(info.VdotH,vClearCoatRefractionParams.x,CLEARCOATREFLECTANCE90);\nfresnel*=clearCoatIntensity;\nfloat distribution=normalDistributionFunction_TrowbridgeReitzGGX(NccdotH,alphaG);\nfloat kelemenVisibility=visibility_Kelemen(info.VdotH);\nfloat clearCoatTerm=fresnel*distribution*kelemenVisibility;\nreturn vec4(\nclearCoatTerm*info.attenuation*NccdotL*lightColor,\n1.0-fresnel\n);\n}\nvec3 computeClearCoatLightingAbsorption(float NdotVRefract,vec3 L,vec3 Ncc,vec3 clearCoatColor,float clearCoatThickness,float clearCoatIntensity) {\nvec3 LRefract=-refract(L,Ncc,vClearCoatRefractionParams.y);\nfloat NdotLRefract=saturateEps(dot(Ncc,LRefract));\nvec3 absorption=computeClearCoatAbsorption(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness,clearCoatIntensity);\nreturn absorption;\n}\n#endif\n#ifdef SHEEN\nvec3 computeSheenLighting(preLightingInfo info,vec3 N,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {\nfloat NdotH=saturateEps(dot(N,info.H));\nfloat roughness=max(info.roughness,geometricRoughnessFactor);\nfloat alphaG=convertRoughnessToAverageSlope(roughness);\n\n\nfloat fresnel=1.;\nfloat distribution=normalDistributionFunction_CharlieSheen(NdotH,alphaG);\n\nfloat visibility=visibility_Ashikhmin(info.NdotL,info.NdotV);\n\nfloat sheenTerm=fresnel*distribution*visibility;\nreturn sheenTerm*info.attenuation*info.NdotL*lightColor;\n}\n#endif\n";
Effect.IncludesShadersStore[name16] = shader16;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrIBLFunctions.js
var name17 = "pbrIBLFunctions";
var shader17 = "#if defined(REFLECTION) || defined(SS_REFRACTION)\nfloat getLodFromAlphaG(float cubeMapDimensionPixels,float microsurfaceAverageSlope) {\nfloat microsurfaceAverageSlopeTexels=cubeMapDimensionPixels*microsurfaceAverageSlope;\nfloat lod=log2(microsurfaceAverageSlopeTexels);\nreturn lod;\n}\nfloat getLinearLodFromRoughness(float cubeMapDimensionPixels,float roughness) {\nfloat lod=log2(cubeMapDimensionPixels)*roughness;\nreturn lod;\n}\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(RADIANCEOCCLUSION)\nfloat environmentRadianceOcclusion(float ambientOcclusion,float NdotVUnclamped) {\n\n\nfloat temp=NdotVUnclamped+ambientOcclusion;\nreturn saturate(square(temp)-1.0+ambientOcclusion);\n}\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(HORIZONOCCLUSION)\nfloat environmentHorizonOcclusion(vec3 view,vec3 normal,vec3 geometricNormal) {\n\nvec3 reflection=reflect(view,normal);\nfloat temp=saturate(1.0+1.1*dot(reflection,geometricNormal));\nreturn square(temp);\n}\n#endif\n\n\n\n\n#if defined(LODINREFLECTIONALPHA) || defined(SS_LODINREFRACTIONALPHA)\n\n\n#define UNPACK_LOD(x) (1.0-x)*255.0\nfloat getLodFromAlphaG(float cubeMapDimensionPixels,float alphaG,float NdotV) {\nfloat microsurfaceAverageSlope=alphaG;\n\n\n\n\n\n\nmicrosurfaceAverageSlope*=sqrt(abs(NdotV));\nreturn getLodFromAlphaG(cubeMapDimensionPixels,microsurfaceAverageSlope);\n}\n#endif";
Effect.IncludesShadersStore[name17] = shader17;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAlbedoOpacity.js
var name18 = "pbrBlockAlbedoOpacity";
var shader18 = "struct albedoOpacityOutParams\n{\nvec3 surfaceAlbedo;\nfloat alpha;\n};\n#define pbr_inline\nvoid albedoOpacityBlock(\nconst in vec4 vAlbedoColor,\n#ifdef ALBEDO\nconst in vec4 albedoTexture,\nconst in vec2 albedoInfos,\n#endif\n#ifdef OPACITY\nconst in vec4 opacityMap,\nconst in vec2 vOpacityInfos,\n#endif\n#ifdef DETAIL\nconst in vec4 detailColor,\nconst in vec4 vDetailInfos,\n#endif\nout albedoOpacityOutParams outParams\n)\n{\n\nvec3 surfaceAlbedo=vAlbedoColor.rgb;\nfloat alpha=vAlbedoColor.a;\n#ifdef ALBEDO\n#if defined(ALPHAFROMALBEDO) || defined(ALPHATEST)\nalpha*=albedoTexture.a;\n#endif\n#ifdef GAMMAALBEDO\nsurfaceAlbedo*=toLinearSpace(albedoTexture.rgb);\n#else\nsurfaceAlbedo*=albedoTexture.rgb;\n#endif\nsurfaceAlbedo*=albedoInfos.y;\n#endif\n#ifdef VERTEXCOLOR\nsurfaceAlbedo*=vColor.rgb;\n#endif\n#ifdef DETAIL\nfloat detailAlbedo=2.0*mix(0.5,detailColor.r,vDetailInfos.y);\nsurfaceAlbedo.rgb=surfaceAlbedo.rgb*detailAlbedo*detailAlbedo;\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_ALBEDO\n\n#ifdef OPACITY\n#ifdef OPACITYRGB\nalpha=getLuminance(opacityMap.rgb);\n#else\nalpha*=opacityMap.a;\n#endif\nalpha*=vOpacityInfos.y;\n#endif\n#ifdef VERTEXALPHA\nalpha*=vColor.a;\n#endif\n#if !defined(SS_LINKREFRACTIONTOTRANSPARENCY) && !defined(ALPHAFRESNEL)\n#ifdef ALPHATEST\nif (alpha<ALPHATESTVALUE)\ndiscard;\n#ifndef ALPHABLEND\n\nalpha=1.0;\n#endif\n#endif\n#endif\noutParams.surfaceAlbedo=surfaceAlbedo;\noutParams.alpha=alpha;\n}\n";
Effect.IncludesShadersStore[name18] = shader18;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectivity.js
var name19 = "pbrBlockReflectivity";
var shader19 = "struct reflectivityOutParams\n{\nfloat microSurface;\nfloat roughness;\nvec3 surfaceReflectivityColor;\n#ifdef METALLICWORKFLOW\nvec3 surfaceAlbedo;\n#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\nvec3 ambientOcclusionColor;\n#endif\n#if DEBUGMODE>0\nvec4 surfaceMetallicColorMap;\nvec4 surfaceReflectivityColorMap;\nvec2 metallicRoughness;\nvec3 metallicF0;\n#endif\n};\n#define pbr_inline\nvoid reflectivityBlock(\nconst in vec4 vReflectivityColor,\n#ifdef METALLICWORKFLOW\nconst in vec3 surfaceAlbedo,\nconst in vec4 metallicReflectanceFactors,\n#endif\n#ifdef REFLECTIVITY\nconst in vec3 reflectivityInfos,\nconst in vec4 surfaceMetallicOrReflectivityColorMap,\n#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\nconst in vec3 ambientOcclusionColorIn,\n#endif\n#ifdef MICROSURFACEMAP\nconst in vec4 microSurfaceTexel,\n#endif\n#ifdef DETAIL\nconst in vec4 detailColor,\nconst in vec4 vDetailInfos,\n#endif\nout reflectivityOutParams outParams\n)\n{\nfloat microSurface=vReflectivityColor.a;\nvec3 surfaceReflectivityColor=vReflectivityColor.rgb;\n#ifdef METALLICWORKFLOW\nvec2 metallicRoughness=surfaceReflectivityColor.rg;\n#ifdef REFLECTIVITY\n#if DEBUGMODE>0\noutParams.surfaceMetallicColorMap=surfaceMetallicOrReflectivityColorMap;\n#endif\n#ifdef AOSTOREINMETALMAPRED\nvec3 aoStoreInMetalMap=vec3(surfaceMetallicOrReflectivityColorMap.r,surfaceMetallicOrReflectivityColorMap.r,surfaceMetallicOrReflectivityColorMap.r);\noutParams.ambientOcclusionColor=mix(ambientOcclusionColorIn,aoStoreInMetalMap,reflectivityInfos.z);\n#endif\n#ifdef METALLNESSSTOREINMETALMAPBLUE\nmetallicRoughness.r*=surfaceMetallicOrReflectivityColorMap.b;\n#else\nmetallicRoughness.r*=surfaceMetallicOrReflectivityColorMap.r;\n#endif\n#ifdef ROUGHNESSSTOREINMETALMAPALPHA\nmetallicRoughness.g*=surfaceMetallicOrReflectivityColorMap.a;\n#else\n#ifdef ROUGHNESSSTOREINMETALMAPGREEN\nmetallicRoughness.g*=surfaceMetallicOrReflectivityColorMap.g;\n#endif\n#endif\n#endif\n#ifdef DETAIL\nfloat detailRoughness=mix(0.5,detailColor.b,vDetailInfos.w);\nfloat loLerp=mix(0.,metallicRoughness.g,detailRoughness*2.);\nfloat hiLerp=mix(metallicRoughness.g,1.,(detailRoughness-0.5)*2.);\nmetallicRoughness.g=mix(loLerp,hiLerp,step(detailRoughness,0.5));\n#endif\n#ifdef MICROSURFACEMAP\nmetallicRoughness.g*=microSurfaceTexel.r;\n#endif\n#if DEBUGMODE>0\noutParams.metallicRoughness=metallicRoughness;\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_METALLICROUGHNESS\n\nmicroSurface=1.0-metallicRoughness.g;\n\nvec3 baseColor=surfaceAlbedo;\n#ifdef FROSTBITE_REFLECTANCE\n\n\n\n\n\n\noutParams.surfaceAlbedo=baseColor.rgb*(1.0-metallicRoughness.r);\n\nsurfaceReflectivityColor=mix(0.16*reflectance*reflectance,baseColor,metallicRoughness.r);\n#else\nvec3 metallicF0=metallicReflectanceFactors.rgb;\n#if DEBUGMODE>0\noutParams.metallicF0=metallicF0;\n#endif\n\noutParams.surfaceAlbedo=mix(baseColor.rgb*(1.0-metallicF0),vec3(0.,0.,0.),metallicRoughness.r);\n\nsurfaceReflectivityColor=mix(metallicF0,baseColor,metallicRoughness.r);\n#endif\n#else\n#ifdef REFLECTIVITY\nsurfaceReflectivityColor*=surfaceMetallicOrReflectivityColorMap.rgb;\n#if DEBUGMODE>0\noutParams.surfaceReflectivityColorMap=surfaceMetallicOrReflectivityColorMap;\n#endif\n#ifdef MICROSURFACEFROMREFLECTIVITYMAP\nmicroSurface*=surfaceMetallicOrReflectivityColorMap.a;\nmicroSurface*=reflectivityInfos.z;\n#else\n#ifdef MICROSURFACEAUTOMATIC\nmicroSurface*=computeDefaultMicroSurface(microSurface,surfaceReflectivityColor);\n#endif\n#ifdef MICROSURFACEMAP\nmicroSurface*=microSurfaceTexel.r;\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_MICROSURFACE\n#endif\n#endif\n#endif\n\nmicroSurface=saturate(microSurface);\n\nfloat roughness=1.-microSurface;\noutParams.microSurface=microSurface;\noutParams.roughness=roughness;\noutParams.surfaceReflectivityColor=surfaceReflectivityColor;\n}\n";
Effect.IncludesShadersStore[name19] = shader19;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAmbientOcclusion.js
var name20 = "pbrBlockAmbientOcclusion";
var shader20 = "struct ambientOcclusionOutParams\n{\nvec3 ambientOcclusionColor;\n#if DEBUGMODE>0\nvec3 ambientOcclusionColorMap;\n#endif\n};\n#define pbr_inline\nvoid ambientOcclusionBlock(\n#ifdef AMBIENT\nconst in vec3 ambientOcclusionColorMap_,\nconst in vec4 vAmbientInfos,\n#endif\nout ambientOcclusionOutParams outParams\n)\n{\nvec3 ambientOcclusionColor=vec3(1.,1.,1.);\n#ifdef AMBIENT\nvec3 ambientOcclusionColorMap=ambientOcclusionColorMap_*vAmbientInfos.y;\n#ifdef AMBIENTINGRAYSCALE\nambientOcclusionColorMap=vec3(ambientOcclusionColorMap.r,ambientOcclusionColorMap.r,ambientOcclusionColorMap.r);\n#endif\nambientOcclusionColor=mix(ambientOcclusionColor,ambientOcclusionColorMap,vAmbientInfos.z);\n#if DEBUGMODE>0\noutParams.ambientOcclusionColorMap=ambientOcclusionColorMap;\n#endif\n#endif\noutParams.ambientOcclusionColor=ambientOcclusionColor;\n}\n";
Effect.IncludesShadersStore[name20] = shader20;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAlphaFresnel.js
var name21 = "pbrBlockAlphaFresnel";
var shader21 = "#ifdef ALPHAFRESNEL\n#if defined(ALPHATEST) || defined(ALPHABLEND)\nstruct alphaFresnelOutParams\n{\nfloat alpha;\n};\n#define pbr_inline\nvoid alphaFresnelBlock(\nconst in vec3 normalW,\nconst in vec3 viewDirectionW,\nconst in float alpha,\nconst in float microSurface,\nout alphaFresnelOutParams outParams\n)\n{\n\n\n\nfloat opacityPerceptual=alpha;\n#ifdef LINEARALPHAFRESNEL\nfloat opacity0=opacityPerceptual;\n#else\nfloat opacity0=opacityPerceptual*opacityPerceptual;\n#endif\nfloat opacity90=fresnelGrazingReflectance(opacity0);\nvec3 normalForward=faceforward(normalW,-viewDirectionW,normalW);\n\noutParams.alpha=getReflectanceFromAnalyticalBRDFLookup_Jones(saturate(dot(viewDirectionW,normalForward)),vec3(opacity0),vec3(opacity90),sqrt(microSurface)).x;\n#ifdef ALPHATEST\nif (outParams.alpha<ALPHATESTVALUE)\ndiscard;\n#ifndef ALPHABLEND\n\noutParams.alpha=1.0;\n#endif\n#endif\n}\n#endif\n#endif\n";
Effect.IncludesShadersStore[name21] = shader21;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAnisotropic.js
var name22 = "pbrBlockAnisotropic";
var shader22 = "#ifdef ANISOTROPIC\nstruct anisotropicOutParams\n{\nfloat anisotropy;\nvec3 anisotropicTangent;\nvec3 anisotropicBitangent;\nvec3 anisotropicNormal;\n#if DEBUGMODE>0\nvec3 anisotropyMapData;\n#endif\n};\n#define pbr_inline\nvoid anisotropicBlock(\nconst in vec3 vAnisotropy,\n#ifdef ANISOTROPIC_TEXTURE\nconst in vec3 anisotropyMapData,\n#endif\nconst in mat3 TBN,\nconst in vec3 normalW,\nconst in vec3 viewDirectionW,\nout anisotropicOutParams outParams\n)\n{\nfloat anisotropy=vAnisotropy.b;\nvec3 anisotropyDirection=vec3(vAnisotropy.xy,0.);\n#ifdef ANISOTROPIC_TEXTURE\nanisotropy*=anisotropyMapData.b;\nanisotropyDirection.rg*=anisotropyMapData.rg*2.0-1.0;\n#if DEBUGMODE>0\noutParams.anisotropyMapData=anisotropyMapData;\n#endif\n#endif\nmat3 anisoTBN=mat3(normalize(TBN[0]),normalize(TBN[1]),normalize(TBN[2]));\nvec3 anisotropicTangent=normalize(anisoTBN*anisotropyDirection);\nvec3 anisotropicBitangent=normalize(cross(anisoTBN[2],anisotropicTangent));\noutParams.anisotropy=anisotropy;\noutParams.anisotropicTangent=anisotropicTangent;\noutParams.anisotropicBitangent=anisotropicBitangent;\noutParams.anisotropicNormal=getAnisotropicBentNormals(anisotropicTangent,anisotropicBitangent,normalW,viewDirectionW,anisotropy);\n}\n#endif\n";
Effect.IncludesShadersStore[name22] = shader22;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflection.js
var name23 = "pbrBlockReflection";
var shader23 = "#ifdef REFLECTION\nstruct reflectionOutParams\n{\nvec4 environmentRadiance;\nvec3 environmentIrradiance;\n#ifdef REFLECTIONMAP_3D\nvec3 reflectionCoords;\n#else\nvec2 reflectionCoords;\n#endif\n#ifdef SS_TRANSLUCENCY\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\nvec3 irradianceVector;\n#endif\n#endif\n#endif\n};\n#define pbr_inline\nvoid createReflectionCoords(\nconst in vec3 vPositionW,\nconst in vec3 normalW,\n#ifdef ANISOTROPIC\nconst in anisotropicOutParams anisotropicOut,\n#endif\n#ifdef REFLECTIONMAP_3D\nout vec3 reflectionCoords\n#else\nout vec2 reflectionCoords\n#endif\n)\n{\n#ifdef ANISOTROPIC\nvec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),anisotropicOut.anisotropicNormal);\n#else\nvec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\n#endif\n#ifdef REFLECTIONMAP_OPPOSITEZ\nreflectionVector.z*=-1.0;\n#endif\n\n#ifdef REFLECTIONMAP_3D\nreflectionCoords=reflectionVector;\n#else\nreflectionCoords=reflectionVector.xy;\n#ifdef REFLECTIONMAP_PROJECTION\nreflectionCoords/=reflectionVector.z;\n#endif\nreflectionCoords.y=1.0-reflectionCoords.y;\n#endif\n}\n#define pbr_inline\n#define inline\nvoid sampleReflectionTexture(\nconst in float alphaG,\nconst in vec3 vReflectionMicrosurfaceInfos,\nconst in vec2 vReflectionInfos,\nconst in vec3 vReflectionColor,\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nconst in float NdotVUnclamped,\n#endif\n#ifdef LINEARSPECULARREFLECTION\nconst in float roughness,\n#endif\n#ifdef REFLECTIONMAP_3D\nconst in samplerCube reflectionSampler,\nconst vec3 reflectionCoords,\n#else\nconst in sampler2D reflectionSampler,\nconst vec2 reflectionCoords,\n#endif\n#ifndef LODBASEDMICROSFURACE\n#ifdef REFLECTIONMAP_3D\nconst in samplerCube reflectionSamplerLow,\nconst in samplerCube reflectionSamplerHigh,\n#else\nconst in sampler2D reflectionSamplerLow,\nconst in sampler2D reflectionSamplerHigh,\n#endif\n#endif\n#ifdef REALTIME_FILTERING\nconst in vec2 vReflectionFilteringInfo,\n#endif\nout vec4 environmentRadiance\n)\n{\n\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nfloat reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG,NdotVUnclamped);\n#elif defined(LINEARSPECULARREFLECTION)\nfloat reflectionLOD=getLinearLodFromRoughness(vReflectionMicrosurfaceInfos.x,roughness);\n#else\nfloat reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG);\n#endif\n#ifdef LODBASEDMICROSFURACE\n\nreflectionLOD=reflectionLOD*vReflectionMicrosurfaceInfos.y+vReflectionMicrosurfaceInfos.z;\n#ifdef LODINREFLECTIONALPHA\n\n\n\n\n\n\n\n\n\nfloat automaticReflectionLOD=UNPACK_LOD(sampleReflection(reflectionSampler,reflectionCoords).a);\nfloat requestedReflectionLOD=max(automaticReflectionLOD,reflectionLOD);\n#else\nfloat requestedReflectionLOD=reflectionLOD;\n#endif\n#ifdef REALTIME_FILTERING\nenvironmentRadiance=vec4(radiance(alphaG,reflectionSampler,reflectionCoords,vReflectionFilteringInfo),1.0);\n#else\nenvironmentRadiance=sampleReflectionLod(reflectionSampler,reflectionCoords,reflectionLOD);\n#endif\n#else\nfloat lodReflectionNormalized=saturate(reflectionLOD/log2(vReflectionMicrosurfaceInfos.x));\nfloat lodReflectionNormalizedDoubled=lodReflectionNormalized*2.0;\nvec4 environmentMid=sampleReflection(reflectionSampler,reflectionCoords);\nif (lodReflectionNormalizedDoubled<1.0){\nenvironmentRadiance=mix(\nsampleReflection(reflectionSamplerHigh,reflectionCoords),\nenvironmentMid,\nlodReflectionNormalizedDoubled\n);\n} else {\nenvironmentRadiance=mix(\nenvironmentMid,\nsampleReflection(reflectionSamplerLow,reflectionCoords),\nlodReflectionNormalizedDoubled-1.0\n);\n}\n#endif\n#ifdef RGBDREFLECTION\nenvironmentRadiance.rgb=fromRGBD(environmentRadiance);\n#endif\n#ifdef GAMMAREFLECTION\nenvironmentRadiance.rgb=toLinearSpace(environmentRadiance.rgb);\n#endif\n\nenvironmentRadiance.rgb*=vReflectionInfos.x;\nenvironmentRadiance.rgb*=vReflectionColor.rgb;\n}\n#define pbr_inline\n#define inline\nvoid reflectionBlock(\nconst in vec3 vPositionW,\nconst in vec3 normalW,\nconst in float alphaG,\nconst in vec3 vReflectionMicrosurfaceInfos,\nconst in vec2 vReflectionInfos,\nconst in vec3 vReflectionColor,\n#ifdef ANISOTROPIC\nconst in anisotropicOutParams anisotropicOut,\n#endif\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nconst in float NdotVUnclamped,\n#endif\n#ifdef LINEARSPECULARREFLECTION\nconst in float roughness,\n#endif\n#ifdef REFLECTIONMAP_3D\nconst in samplerCube reflectionSampler,\n#else\nconst in sampler2D reflectionSampler,\n#endif\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX)\nconst in vec3 vEnvironmentIrradiance,\n#endif\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\nconst in mat4 reflectionMatrix,\n#endif\n#endif\n#ifdef USEIRRADIANCEMAP\n#ifdef REFLECTIONMAP_3D\nconst in samplerCube irradianceSampler,\n#else\nconst in sampler2D irradianceSampler,\n#endif\n#endif\n#ifndef LODBASEDMICROSFURACE\n#ifdef REFLECTIONMAP_3D\nconst in samplerCube reflectionSamplerLow,\nconst in samplerCube reflectionSamplerHigh,\n#else\nconst in sampler2D reflectionSamplerLow,\nconst in sampler2D reflectionSamplerHigh,\n#endif\n#endif\n#ifdef REALTIME_FILTERING\nconst in vec2 vReflectionFilteringInfo,\n#endif\nout reflectionOutParams outParams\n)\n{\n\nvec4 environmentRadiance=vec4(0.,0.,0.,0.);\n#ifdef REFLECTIONMAP_3D\nvec3 reflectionCoords=vec3(0.);\n#else\nvec2 reflectionCoords=vec2(0.);\n#endif\ncreateReflectionCoords(\nvPositionW,\nnormalW,\n#ifdef ANISOTROPIC\nanisotropicOut,\n#endif\nreflectionCoords\n);\nsampleReflectionTexture(\nalphaG,\nvReflectionMicrosurfaceInfos,\nvReflectionInfos,\nvReflectionColor,\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nNdotVUnclamped,\n#endif\n#ifdef LINEARSPECULARREFLECTION\nroughness,\n#endif\n#ifdef REFLECTIONMAP_3D\nreflectionSampler,\nreflectionCoords,\n#else\nreflectionSampler,\nreflectionCoords,\n#endif\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\nreflectionSamplerHigh,\n#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\n#endif\nenvironmentRadiance\n);\n\nvec3 environmentIrradiance=vec3(0.,0.,0.);\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX)\nenvironmentIrradiance=vEnvironmentIrradiance;\n#else\n#ifdef ANISOTROPIC\nvec3 irradianceVector=vec3(reflectionMatrix*vec4(anisotropicOut.anisotropicNormal,0)).xyz;\n#else\nvec3 irradianceVector=vec3(reflectionMatrix*vec4(normalW,0)).xyz;\n#endif\n#ifdef REFLECTIONMAP_OPPOSITEZ\nirradianceVector.z*=-1.0;\n#endif\n#ifdef INVERTCUBICMAP\nirradianceVector.y*=-1.0;\n#endif\n#if defined(REALTIME_FILTERING)\nenvironmentIrradiance=irradiance(reflectionSampler,irradianceVector,vReflectionFilteringInfo);\n#else\nenvironmentIrradiance=computeEnvironmentIrradiance(irradianceVector);\n#endif\n#ifdef SS_TRANSLUCENCY\noutParams.irradianceVector=irradianceVector;\n#endif\n#endif\n#elif defined(USEIRRADIANCEMAP)\nvec4 environmentIrradiance4=sampleReflection(irradianceSampler,reflectionCoords);\nenvironmentIrradiance=environmentIrradiance4.rgb;\n#ifdef RGBDREFLECTION\nenvironmentIrradiance.rgb=fromRGBD(environmentIrradiance4);\n#endif\n#ifdef GAMMAREFLECTION\nenvironmentIrradiance.rgb=toLinearSpace(environmentIrradiance.rgb);\n#endif\n#endif\nenvironmentIrradiance*=vReflectionColor.rgb;\noutParams.environmentRadiance=environmentRadiance;\noutParams.environmentIrradiance=environmentIrradiance;\noutParams.reflectionCoords=reflectionCoords;\n}\n#endif\n";
Effect.IncludesShadersStore[name23] = shader23;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockSheen.js
var name24 = "pbrBlockSheen";
var shader24 = "#ifdef SHEEN\nstruct sheenOutParams\n{\nfloat sheenIntensity;\nvec3 sheenColor;\nfloat sheenRoughness;\n#ifdef SHEEN_LINKWITHALBEDO\nvec3 surfaceAlbedo;\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\nfloat sheenAlbedoScaling;\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nvec3 finalSheenRadianceScaled;\n#endif\n#if DEBUGMODE>0\nvec4 sheenMapData;\nvec3 sheenEnvironmentReflectance;\n#endif\n};\n#define pbr_inline\n#define inline\nvoid sheenBlock(\nconst in vec4 vSheenColor,\n#ifdef SHEEN_ROUGHNESS\nconst in float vSheenRoughness,\n#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)\nconst in vec4 sheenMapRoughnessData,\n#endif\n#endif\nconst in float roughness,\n#ifdef SHEEN_TEXTURE\nconst in vec4 sheenMapData,\n#endif\nconst in float reflectance,\n#ifdef SHEEN_LINKWITHALBEDO\nconst in vec3 baseColor,\nconst in vec3 surfaceAlbedo,\n#endif\n#ifdef ENVIRONMENTBRDF\nconst in float NdotV,\nconst in vec3 environmentBrdf,\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nconst in vec2 AARoughnessFactors,\nconst in vec3 vReflectionMicrosurfaceInfos,\nconst in vec2 vReflectionInfos,\nconst in vec3 vReflectionColor,\nconst in vec4 vLightingIntensity,\n#ifdef REFLECTIONMAP_3D\nconst in samplerCube reflectionSampler,\nconst in vec3 reflectionCoords,\n#else\nconst in sampler2D reflectionSampler,\nconst in vec2 reflectionCoords,\n#endif\nconst in float NdotVUnclamped,\n#ifndef LODBASEDMICROSFURACE\n#ifdef REFLECTIONMAP_3D\nconst in samplerCube reflectionSamplerLow,\nconst in samplerCube reflectionSamplerHigh,\n#else\nconst in sampler2D reflectionSamplerLow,\nconst in sampler2D reflectionSamplerHigh,\n#endif\n#endif\n#ifdef REALTIME_FILTERING\nconst in vec2 vReflectionFilteringInfo,\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)\nconst in float seo,\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)\nconst in float eho,\n#endif\n#endif\nout sheenOutParams outParams\n)\n{\nfloat sheenIntensity=vSheenColor.a;\n#ifdef SHEEN_TEXTURE\n#if DEBUGMODE>0\noutParams.sheenMapData=sheenMapData;\n#endif\n#endif\n#ifdef SHEEN_LINKWITHALBEDO\nfloat sheenFactor=pow5(1.0-sheenIntensity);\nvec3 sheenColor=baseColor.rgb*(1.0-sheenFactor);\nfloat sheenRoughness=sheenIntensity;\noutParams.surfaceAlbedo=surfaceAlbedo*sheenFactor;\n#ifdef SHEEN_TEXTURE\nsheenIntensity*=sheenMapData.a;\n#endif\n#else\nvec3 sheenColor=vSheenColor.rgb;\n#ifdef SHEEN_TEXTURE\nsheenColor.rgb*=sheenMapData.rgb;\n#endif\n#ifdef SHEEN_ROUGHNESS\nfloat sheenRoughness=vSheenRoughness;\n#ifdef SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE\n#if defined(SHEEN_TEXTURE)\nsheenRoughness*=sheenMapData.a;\n#endif\n#elif defined(SHEEN_TEXTURE_ROUGHNESS)\n#ifdef SHEEN_TEXTURE_ROUGHNESS_IDENTICAL\nsheenRoughness*=sheenMapData.a;\n#else\nsheenRoughness*=sheenMapRoughnessData.a;\n#endif\n#endif\n#else\nfloat sheenRoughness=roughness;\n#ifdef SHEEN_TEXTURE\nsheenIntensity*=sheenMapData.a;\n#endif\n#endif\n\n#if !defined(SHEEN_ALBEDOSCALING)\nsheenIntensity*=(1.-reflectance);\n#endif\n\nsheenColor*=sheenIntensity;\n#endif\n\n#ifdef ENVIRONMENTBRDF\n\n#ifdef SHEEN_ROUGHNESS\nvec3 environmentSheenBrdf=getBRDFLookup(NdotV,sheenRoughness);\n#else\nvec3 environmentSheenBrdf=environmentBrdf;\n#endif\n\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nfloat sheenAlphaG=convertRoughnessToAverageSlope(sheenRoughness);\n#ifdef SPECULARAA\n\nsheenAlphaG+=AARoughnessFactors.y;\n#endif\nvec4 environmentSheenRadiance=vec4(0.,0.,0.,0.);\nsampleReflectionTexture(\nsheenAlphaG,\nvReflectionMicrosurfaceInfos,\nvReflectionInfos,\nvReflectionColor,\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nNdotVUnclamped,\n#endif\n#ifdef LINEARSPECULARREFLECTION\nsheenRoughness,\n#endif\nreflectionSampler,\nreflectionCoords,\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\nreflectionSamplerHigh,\n#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\n#endif\nenvironmentSheenRadiance\n);\nvec3 sheenEnvironmentReflectance=getSheenReflectanceFromBRDFLookup(sheenColor,environmentSheenBrdf);\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)\nsheenEnvironmentReflectance*=seo;\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)\nsheenEnvironmentReflectance*=eho;\n#endif\n#if DEBUGMODE>0\noutParams.sheenEnvironmentReflectance=sheenEnvironmentReflectance;\n#endif\noutParams.finalSheenRadianceScaled=\nenvironmentSheenRadiance.rgb *\nsheenEnvironmentReflectance *\nvLightingIntensity.z;\n\n\n\n\n\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\n\n\n\noutParams.sheenAlbedoScaling=1.0-sheenIntensity*max(max(sheenColor.r,sheenColor.g),sheenColor.b)*environmentSheenBrdf.b;\n#endif\n\noutParams.sheenIntensity=sheenIntensity;\noutParams.sheenColor=sheenColor;\noutParams.sheenRoughness=sheenRoughness;\n}\n#endif\n";
Effect.IncludesShadersStore[name24] = shader24;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockClearcoat.js
var name25 = "pbrBlockClearcoat";
var shader25 = "struct clearcoatOutParams\n{\nvec3 specularEnvironmentR0;\nfloat conservationFactor;\nvec3 clearCoatNormalW;\nvec2 clearCoatAARoughnessFactors;\nfloat clearCoatIntensity;\nfloat clearCoatRoughness;\n#ifdef REFLECTION\nvec3 finalClearCoatRadianceScaled;\n#endif\n#ifdef CLEARCOAT_TINT\nvec3 absorption;\nfloat clearCoatNdotVRefract;\nvec3 clearCoatColor;\nfloat clearCoatThickness;\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\nvec3 energyConservationFactorClearCoat;\n#endif\n#if DEBUGMODE>0\nmat3 TBNClearCoat;\nvec2 clearCoatMapData;\nvec4 clearCoatTintMapData;\nvec4 environmentClearCoatRadiance;\nfloat clearCoatNdotV;\nvec3 clearCoatEnvironmentReflectance;\n#endif\n};\n#ifdef CLEARCOAT\n#define pbr_inline\n#define inline\nvoid clearcoatBlock(\nconst in vec3 vPositionW,\nconst in vec3 geometricNormalW,\nconst in vec3 viewDirectionW,\nconst in vec2 vClearCoatParams,\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\nconst in vec4 clearCoatMapRoughnessData,\n#endif\nconst in vec3 specularEnvironmentR0,\n#ifdef CLEARCOAT_TEXTURE\nconst in vec2 clearCoatMapData,\n#endif\n#ifdef CLEARCOAT_TINT\nconst in vec4 vClearCoatTintParams,\nconst in float clearCoatColorAtDistance,\nconst in vec4 vClearCoatRefractionParams,\n#ifdef CLEARCOAT_TINT_TEXTURE\nconst in vec4 clearCoatTintMapData,\n#endif\n#endif\n#ifdef CLEARCOAT_BUMP\nconst in vec2 vClearCoatBumpInfos,\nconst in vec4 clearCoatBumpMapData,\nconst in vec2 vClearCoatBumpUV,\n#if defined(TANGENT) && defined(NORMAL)\nconst in mat3 vTBN,\n#else\nconst in vec2 vClearCoatTangentSpaceParams,\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nconst in mat4 normalMatrix,\n#endif\n#endif\n#if defined(FORCENORMALFORWARD) && defined(NORMAL)\nconst in vec3 faceNormal,\n#endif\n#ifdef REFLECTION\nconst in vec3 vReflectionMicrosurfaceInfos,\nconst in vec2 vReflectionInfos,\nconst in vec3 vReflectionColor,\nconst in vec4 vLightingIntensity,\n#ifdef REFLECTIONMAP_3D\nconst in samplerCube reflectionSampler,\n#else\nconst in sampler2D reflectionSampler,\n#endif\n#ifndef LODBASEDMICROSFURACE\n#ifdef REFLECTIONMAP_3D\nconst in samplerCube reflectionSamplerLow,\nconst in samplerCube reflectionSamplerHigh,\n#else\nconst in sampler2D reflectionSamplerLow,\nconst in sampler2D reflectionSamplerHigh,\n#endif\n#endif\n#ifdef REALTIME_FILTERING\nconst in vec2 vReflectionFilteringInfo,\n#endif\n#endif\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\n#ifdef RADIANCEOCCLUSION\nconst in float ambientMonochrome,\n#endif\n#endif\nout clearcoatOutParams outParams\n)\n{\n\nfloat clearCoatIntensity=vClearCoatParams.x;\nfloat clearCoatRoughness=vClearCoatParams.y;\n#ifdef CLEARCOAT_TEXTURE\nclearCoatIntensity*=clearCoatMapData.x;\n#ifdef CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE\nclearCoatRoughness*=clearCoatMapData.y;\n#endif\n#if DEBUGMODE>0\noutParams.clearCoatMapData=clearCoatMapData;\n#endif\n#endif\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\n#ifdef CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL\nclearCoatRoughness*=clearCoatMapData.y;\n#else\nclearCoatRoughness*=clearCoatMapRoughnessData.y;\n#endif\n#endif\noutParams.clearCoatIntensity=clearCoatIntensity;\noutParams.clearCoatRoughness=clearCoatRoughness;\n#ifdef CLEARCOAT_TINT\nvec3 clearCoatColor=vClearCoatTintParams.rgb;\nfloat clearCoatThickness=vClearCoatTintParams.a;\n#ifdef CLEARCOAT_TINT_TEXTURE\nclearCoatColor*=clearCoatTintMapData.rgb;\nclearCoatThickness*=clearCoatTintMapData.a;\n#if DEBUGMODE>0\noutParams.clearCoatTintMapData=clearCoatTintMapData;\n#endif\n#endif\noutParams.clearCoatColor=computeColorAtDistanceInMedia(clearCoatColor,clearCoatColorAtDistance);\noutParams.clearCoatThickness=clearCoatThickness;\n#endif\n\n\n\n\n#ifdef CLEARCOAT_REMAP_F0\nvec3 specularEnvironmentR0Updated=getR0RemappedForClearCoat(specularEnvironmentR0);\n#else\nvec3 specularEnvironmentR0Updated=specularEnvironmentR0;\n#endif\noutParams.specularEnvironmentR0=mix(specularEnvironmentR0,specularEnvironmentR0Updated,clearCoatIntensity);\n\nvec3 clearCoatNormalW=geometricNormalW;\n#ifdef CLEARCOAT_BUMP\n#ifdef NORMALXYSCALE\nfloat clearCoatNormalScale=1.0;\n#else\nfloat clearCoatNormalScale=vClearCoatBumpInfos.y;\n#endif\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBNClearCoat=vTBN;\n#else\nmat3 TBNClearCoat=cotangent_frame(clearCoatNormalW*clearCoatNormalScale,vPositionW,vClearCoatBumpUV,vClearCoatTangentSpaceParams);\n#endif\n#if DEBUGMODE>0\noutParams.TBNClearCoat=TBNClearCoat;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nclearCoatNormalW=normalize(clearCoatBumpMapData.xyz*2.0-1.0);\nclearCoatNormalW=normalize(mat3(normalMatrix)*clearCoatNormalW);\n#else\nclearCoatNormalW=perturbNormal(TBNClearCoat,clearCoatBumpMapData.xyz,vClearCoatBumpInfos.y);\n#endif\n#endif\n#if defined(FORCENORMALFORWARD) && defined(NORMAL)\nclearCoatNormalW*=sign(dot(clearCoatNormalW,faceNormal));\n#endif\n#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)\nclearCoatNormalW=gl_FrontFacing ? clearCoatNormalW : -clearCoatNormalW;\n#endif\noutParams.clearCoatNormalW=clearCoatNormalW;\n\noutParams.clearCoatAARoughnessFactors=getAARoughnessFactors(clearCoatNormalW.xyz);\n\nfloat clearCoatNdotVUnclamped=dot(clearCoatNormalW,viewDirectionW);\n\nfloat clearCoatNdotV=absEps(clearCoatNdotVUnclamped);\n#if DEBUGMODE>0\noutParams.clearCoatNdotV=clearCoatNdotV;\n#endif\n#ifdef CLEARCOAT_TINT\n\nvec3 clearCoatVRefract=-refract(vPositionW,clearCoatNormalW,vClearCoatRefractionParams.y);\n\noutParams.clearCoatNdotVRefract=absEps(dot(clearCoatNormalW,clearCoatVRefract));\n#endif\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\n\nvec3 environmentClearCoatBrdf=getBRDFLookup(clearCoatNdotV,clearCoatRoughness);\n#endif\n\n#if defined(REFLECTION)\nfloat clearCoatAlphaG=convertRoughnessToAverageSlope(clearCoatRoughness);\n#ifdef SPECULARAA\n\nclearCoatAlphaG+=outParams.clearCoatAARoughnessFactors.y;\n#endif\nvec4 environmentClearCoatRadiance=vec4(0.,0.,0.,0.);\nvec3 clearCoatReflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),clearCoatNormalW);\n#ifdef REFLECTIONMAP_OPPOSITEZ\nclearCoatReflectionVector.z*=-1.0;\n#endif\n\n#ifdef REFLECTIONMAP_3D\nvec3 clearCoatReflectionCoords=clearCoatReflectionVector;\n#else\nvec2 clearCoatReflectionCoords=clearCoatReflectionVector.xy;\n#ifdef REFLECTIONMAP_PROJECTION\nclearCoatReflectionCoords/=clearCoatReflectionVector.z;\n#endif\nclearCoatReflectionCoords.y=1.0-clearCoatReflectionCoords.y;\n#endif\nsampleReflectionTexture(\nclearCoatAlphaG,\nvReflectionMicrosurfaceInfos,\nvReflectionInfos,\nvReflectionColor,\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nclearCoatNdotVUnclamped,\n#endif\n#ifdef LINEARSPECULARREFLECTION\nclearCoatRoughness,\n#endif\nreflectionSampler,\nclearCoatReflectionCoords,\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\nreflectionSamplerHigh,\n#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\n#endif\nenvironmentClearCoatRadiance\n);\n#if DEBUGMODE>0\noutParams.environmentClearCoatRadiance=environmentClearCoatRadiance;\n#endif\n\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\nvec3 clearCoatEnvironmentReflectance=getReflectanceFromBRDFLookup(vec3(vClearCoatRefractionParams.x),environmentClearCoatBrdf);\n#ifdef RADIANCEOCCLUSION\nfloat clearCoatSeo=environmentRadianceOcclusion(ambientMonochrome,clearCoatNdotVUnclamped);\nclearCoatEnvironmentReflectance*=clearCoatSeo;\n#endif\n#ifdef HORIZONOCCLUSION\n#ifdef BUMP\n#ifdef REFLECTIONMAP_3D\nfloat clearCoatEho=environmentHorizonOcclusion(-viewDirectionW,clearCoatNormalW,geometricNormalW);\nclearCoatEnvironmentReflectance*=clearCoatEho;\n#endif\n#endif\n#endif\n#else\n\nvec3 clearCoatEnvironmentReflectance=getReflectanceFromAnalyticalBRDFLookup_Jones(clearCoatNdotV,vec3(1.),vec3(1.),sqrt(1.-clearCoatRoughness));\n#endif\nclearCoatEnvironmentReflectance*=clearCoatIntensity;\n#if DEBUGMODE>0\noutParams.clearCoatEnvironmentReflectance=clearCoatEnvironmentReflectance;\n#endif\noutParams.finalClearCoatRadianceScaled=\nenvironmentClearCoatRadiance.rgb *\nclearCoatEnvironmentReflectance *\nvLightingIntensity.z;\n#endif\n#if defined(CLEARCOAT_TINT)\n\noutParams.absorption=computeClearCoatAbsorption(outParams.clearCoatNdotVRefract,outParams.clearCoatNdotVRefract,outParams.clearCoatColor,clearCoatThickness,clearCoatIntensity);\n#endif\n\nfloat fresnelIBLClearCoat=fresnelSchlickGGX(clearCoatNdotV,vClearCoatRefractionParams.x,CLEARCOATREFLECTANCE90);\nfresnelIBLClearCoat*=clearCoatIntensity;\noutParams.conservationFactor=(1.-fresnelIBLClearCoat);\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\noutParams.energyConservationFactorClearCoat=getEnergyConservationFactor(outParams.specularEnvironmentR0,environmentClearCoatBrdf);\n#endif\n}\n#endif\n";
Effect.IncludesShadersStore[name25] = shader25;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockSubSurface.js
var name26 = "pbrBlockSubSurface";
var shader26 = "struct subSurfaceOutParams\n{\nvec3 specularEnvironmentReflectance;\n#ifdef SS_REFRACTION\nvec3 finalRefraction;\nvec3 surfaceAlbedo;\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nfloat alpha;\n#endif\n#ifdef REFLECTION\nfloat refractionFactorForIrradiance;\n#endif\n#endif\n#ifdef SS_TRANSLUCENCY\nvec3 transmittance;\nfloat translucencyIntensity;\n#ifdef REFLECTION\nvec3 refractionIrradiance;\n#endif\n#endif\n#if DEBUGMODE>0\nvec4 thicknessMap;\nvec4 environmentRefraction;\nvec3 refractionTransmittance;\n#endif\n};\n#ifdef SUBSURFACE\n#define pbr_inline\n#define inline\nvoid subSurfaceBlock(\nconst in vec3 vSubSurfaceIntensity,\nconst in vec2 vThicknessParam,\nconst in vec4 vTintColor,\nconst in vec3 normalW,\nconst in vec3 specularEnvironmentReflectance,\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nconst in vec4 thicknessMap,\n#endif\n#ifdef REFLECTION\n#ifdef SS_TRANSLUCENCY\nconst in mat4 reflectionMatrix,\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\nconst in vec3 irradianceVector_,\n#endif\n#if defined(REALTIME_FILTERING)\nconst in samplerCube reflectionSampler,\nconst in vec2 vReflectionFilteringInfo,\n#endif\n#endif\n#ifdef USEIRRADIANCEMAP\n#ifdef REFLECTIONMAP_3D\nconst in samplerCube irradianceSampler,\n#else\nconst in sampler2D irradianceSampler,\n#endif\n#endif\n#endif\n#endif\n#ifdef SS_REFRACTION\nconst in vec3 vPositionW,\nconst in vec3 viewDirectionW,\nconst in mat4 view,\nconst in vec3 surfaceAlbedo,\nconst in vec4 vRefractionInfos,\nconst in mat4 refractionMatrix,\nconst in vec3 vRefractionMicrosurfaceInfos,\nconst in vec4 vLightingIntensity,\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nconst in float alpha,\n#endif\n#ifdef SS_LODINREFRACTIONALPHA\nconst in float NdotVUnclamped,\n#endif\n#ifdef SS_LINEARSPECULARREFRACTION\nconst in float roughness,\n#else\nconst in float alphaG,\n#endif\n#ifdef SS_REFRACTIONMAP_3D\nconst in samplerCube refractionSampler,\n#ifndef LODBASEDMICROSFURACE\nconst in samplerCube refractionSamplerLow,\nconst in samplerCube refractionSamplerHigh,\n#endif\n#else\nconst in sampler2D refractionSampler,\n#ifndef LODBASEDMICROSFURACE\nconst in sampler2D refractionSamplerLow,\nconst in sampler2D refractionSamplerHigh,\n#endif\n#endif\n#ifdef ANISOTROPIC\nconst in anisotropicOutParams anisotropicOut,\n#endif\n#ifdef REALTIME_FILTERING\nconst in vec2 vRefractionFilteringInfo,\n#endif\n#endif\n#ifdef SS_TRANSLUCENCY\nconst in vec3 vDiffusionDistance,\n#endif\nout subSurfaceOutParams outParams\n)\n{\noutParams.specularEnvironmentReflectance=specularEnvironmentReflectance;\n\n\n\n#ifdef SS_REFRACTION\nfloat refractionIntensity=vSubSurfaceIntensity.x;\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nrefractionIntensity*=(1.0-alpha);\n\noutParams.alpha=1.0;\n#endif\n#endif\n#ifdef SS_TRANSLUCENCY\nfloat translucencyIntensity=vSubSurfaceIntensity.y;\n#endif\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nfloat thickness=thicknessMap.r*vThicknessParam.y+vThicknessParam.x;\n#if DEBUGMODE>0\noutParams.thicknessMap=thicknessMap;\n#endif\n#ifdef SS_MASK_FROM_THICKNESS_TEXTURE\n#ifdef SS_REFRACTION\nrefractionIntensity*=thicknessMap.g;\n#endif\n#ifdef SS_TRANSLUCENCY\ntranslucencyIntensity*=thicknessMap.b;\n#endif\n#elif defined(SS_MASK_FROM_THICKNESS_TEXTURE_GLTF)\n#ifdef SS_REFRACTION\nrefractionIntensity*=thicknessMap.r;\n#elif defined(SS_TRANSLUCENCY)\ntranslucencyIntensity*=thicknessMap.r;\n#endif\nthickness=thicknessMap.g*vThicknessParam.y+vThicknessParam.x;\n#endif\n#else\nfloat thickness=vThicknessParam.y;\n#endif\n\n\n\n#ifdef SS_TRANSLUCENCY\nthickness=maxEps(thickness);\nvec3 transmittance=transmittanceBRDF_Burley(vTintColor.rgb,vDiffusionDistance,thickness);\ntransmittance*=translucencyIntensity;\noutParams.transmittance=transmittance;\noutParams.translucencyIntensity=translucencyIntensity;\n#endif\n\n\n\n#ifdef SS_REFRACTION\nvec4 environmentRefraction=vec4(0.,0.,0.,0.);\n#ifdef ANISOTROPIC\nvec3 refractionVector=refract(-viewDirectionW,anisotropicOut.anisotropicNormal,vRefractionInfos.y);\n#else\nvec3 refractionVector=refract(-viewDirectionW,normalW,vRefractionInfos.y);\n#endif\n#ifdef SS_REFRACTIONMAP_OPPOSITEZ\nrefractionVector.z*=-1.0;\n#endif\n\n#ifdef SS_REFRACTIONMAP_3D\nrefractionVector.y=refractionVector.y*vRefractionInfos.w;\nvec3 refractionCoords=refractionVector;\nrefractionCoords=vec3(refractionMatrix*vec4(refractionCoords,0));\n#else\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));\nvec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;\nrefractionCoords.y=1.0-refractionCoords.y;\n#endif\n#ifdef SS_LODINREFRACTIONALPHA\nfloat refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,alphaG,NdotVUnclamped);\n#elif defined(SS_LINEARSPECULARREFRACTION)\nfloat refractionLOD=getLinearLodFromRoughness(vRefractionMicrosurfaceInfos.x,roughness);\n#else\nfloat refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,alphaG);\n#endif\n#ifdef LODBASEDMICROSFURACE\n\nrefractionLOD=refractionLOD*vRefractionMicrosurfaceInfos.y+vRefractionMicrosurfaceInfos.z;\n#ifdef SS_LODINREFRACTIONALPHA\n\n\n\n\n\n\n\n\n\nfloat automaticRefractionLOD=UNPACK_LOD(sampleRefraction(refractionSampler,refractionCoords).a);\nfloat requestedRefractionLOD=max(automaticRefractionLOD,refractionLOD);\n#else\nfloat requestedRefractionLOD=refractionLOD;\n#endif\n#ifdef REALTIME_FILTERING\nenvironmentRefraction=vec4(radiance(alphaG,refractionSampler,refractionCoords,vRefractionFilteringInfo),1.0);\n#else\nenvironmentRefraction=sampleRefractionLod(refractionSampler,refractionCoords,requestedRefractionLOD);\n#endif\n#else\nfloat lodRefractionNormalized=saturate(refractionLOD/log2(vRefractionMicrosurfaceInfos.x));\nfloat lodRefractionNormalizedDoubled=lodRefractionNormalized*2.0;\nvec4 environmentRefractionMid=sampleRefraction(refractionSampler,refractionCoords);\nif (lodRefractionNormalizedDoubled<1.0){\nenvironmentRefraction=mix(\nsampleRefraction(refractionSamplerHigh,refractionCoords),\nenvironmentRefractionMid,\nlodRefractionNormalizedDoubled\n);\n} else {\nenvironmentRefraction=mix(\nenvironmentRefractionMid,\nsampleRefraction(refractionSamplerLow,refractionCoords),\nlodRefractionNormalizedDoubled-1.0\n);\n}\n#endif\n#ifdef SS_RGBDREFRACTION\nenvironmentRefraction.rgb=fromRGBD(environmentRefraction);\n#endif\n#ifdef SS_GAMMAREFRACTION\nenvironmentRefraction.rgb=toLinearSpace(environmentRefraction.rgb);\n#endif\n\nenvironmentRefraction.rgb*=vRefractionInfos.x;\n#endif\n\n\n\n#ifdef SS_REFRACTION\nvec3 refractionTransmittance=vec3(refractionIntensity);\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nvec3 volumeAlbedo=computeColorAtDistanceInMedia(vTintColor.rgb,vTintColor.w);\n\n\n\n\n\nrefractionTransmittance*=cocaLambert(volumeAlbedo,thickness);\n#elif defined(SS_LINKREFRACTIONTOTRANSPARENCY)\n\nfloat maxChannel=max(max(surfaceAlbedo.r,surfaceAlbedo.g),surfaceAlbedo.b);\nvec3 volumeAlbedo=saturate(maxChannel*surfaceAlbedo);\n\nenvironmentRefraction.rgb*=volumeAlbedo;\n#else\n\nvec3 volumeAlbedo=computeColorAtDistanceInMedia(vTintColor.rgb,vTintColor.w);\nrefractionTransmittance*=cocaLambert(volumeAlbedo,vThicknessParam.y);\n#endif\n#ifdef SS_ALBEDOFORREFRACTIONTINT\n\nenvironmentRefraction.rgb*=surfaceAlbedo.rgb;\n#endif\n\noutParams.surfaceAlbedo=surfaceAlbedo*(1.-refractionIntensity);\n#ifdef REFLECTION\n\noutParams.refractionFactorForIrradiance=(1.-refractionIntensity);\n\n#endif\n\nvec3 bounceSpecularEnvironmentReflectance=(2.0*specularEnvironmentReflectance)/(1.0+specularEnvironmentReflectance);\noutParams.specularEnvironmentReflectance=mix(bounceSpecularEnvironmentReflectance,specularEnvironmentReflectance,refractionIntensity);\n\nrefractionTransmittance*=1.0-outParams.specularEnvironmentReflectance;\n#if DEBUGMODE>0\noutParams.refractionTransmittance=refractionTransmittance;\n#endif\noutParams.finalRefraction=environmentRefraction.rgb*refractionTransmittance*vLightingIntensity.z;\n#if DEBUGMODE>0\noutParams.environmentRefraction=environmentRefraction;\n#endif\n#endif\n\n\n\n#if defined(REFLECTION) && defined(SS_TRANSLUCENCY)\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX) || !defined(USESPHERICALFROMREFLECTIONMAP)\nvec3 irradianceVector=vec3(reflectionMatrix*vec4(normalW,0)).xyz;\n#ifdef REFLECTIONMAP_OPPOSITEZ\nirradianceVector.z*=-1.0;\n#endif\n#ifdef INVERTCUBICMAP\nirradianceVector.y*=-1.0;\n#endif\n#else\nvec3 irradianceVector=irradianceVector_;\n#endif\n#if defined(USESPHERICALFROMREFLECTIONMAP)\n#if defined(REALTIME_FILTERING)\nvec3 refractionIrradiance=irradiance(reflectionSampler,-irradianceVector,vReflectionFilteringInfo);\n#else\nvec3 refractionIrradiance=computeEnvironmentIrradiance(-irradianceVector);\n#endif\n#elif defined(USEIRRADIANCEMAP)\n#ifdef REFLECTIONMAP_3D\nvec3 irradianceCoords=irradianceVector;\n#else\nvec2 irradianceCoords=irradianceVector.xy;\n#ifdef REFLECTIONMAP_PROJECTION\nirradianceCoords/=irradianceVector.z;\n#endif\nirradianceCoords.y=1.0-irradianceCoords.y;\n#endif\nvec4 refractionIrradiance=sampleReflection(irradianceSampler,-irradianceCoords);\n#ifdef RGBDREFLECTION\nrefractionIrradiance.rgb=fromRGBD(refractionIrradiance);\n#endif\n#ifdef GAMMAREFLECTION\nrefractionIrradiance.rgb=toLinearSpace(refractionIrradiance.rgb);\n#endif\n#else\nvec4 refractionIrradiance=vec4(0.);\n#endif\nrefractionIrradiance.rgb*=transmittance;\noutParams.refractionIrradiance=refractionIrradiance.rgb;\n#endif\n}\n#endif\n";
Effect.IncludesShadersStore[name26] = shader26;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockNormalGeometric.js
var name27 = "pbrBlockNormalGeometric";
var shader27 = "vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=normalize(cross(dFdx(vPositionW),dFdy(vPositionW)))*vEyePosition.w;\n#endif\nvec3 geometricNormalW=normalW;\n#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)\ngeometricNormalW=gl_FrontFacing ? geometricNormalW : -geometricNormalW;\n#endif\n";
Effect.IncludesShadersStore[name27] = shader27;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockNormalFinal.js
var name28 = "pbrBlockNormalFinal";
var shader28 = "#if defined(FORCENORMALFORWARD) && defined(NORMAL)\nvec3 faceNormal=normalize(cross(dFdx(vPositionW),dFdy(vPositionW)))*vEyePosition.w;\n#if defined(TWOSIDEDLIGHTING)\nfaceNormal=gl_FrontFacing ? faceNormal : -faceNormal;\n#endif\nnormalW*=sign(dot(normalW,faceNormal));\n#endif\n#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)\nnormalW=gl_FrontFacing ? normalW : -normalW;\n#endif\n";
Effect.IncludesShadersStore[name28] = shader28;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockLightmapInit.js
var name29 = "pbrBlockLightmapInit";
var shader29 = "#ifdef LIGHTMAP\nvec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);\n#ifdef RGBDLIGHTMAP\nlightmapColor.rgb=fromRGBD(lightmapColor);\n#endif\n#ifdef GAMMALIGHTMAP\nlightmapColor.rgb=toLinearSpace(lightmapColor.rgb);\n#endif\nlightmapColor.rgb*=vLightmapInfos.y;\n#endif\n";
Effect.IncludesShadersStore[name29] = shader29;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockGeometryInfo.js
var name30 = "pbrBlockGeometryInfo";
var shader30 = "float NdotVUnclamped=dot(normalW,viewDirectionW);\n\nfloat NdotV=absEps(NdotVUnclamped);\nfloat alphaG=convertRoughnessToAverageSlope(roughness);\nvec2 AARoughnessFactors=getAARoughnessFactors(normalW.xyz);\n#ifdef SPECULARAA\n\nalphaG+=AARoughnessFactors.y;\n#endif\n#if defined(ENVIRONMENTBRDF)\n\nvec3 environmentBrdf=getBRDFLookup(NdotV,roughness);\n#endif\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\n#ifdef RADIANCEOCCLUSION\n#ifdef AMBIENTINGRAYSCALE\nfloat ambientMonochrome=aoOut.ambientOcclusionColor.r;\n#else\nfloat ambientMonochrome=getLuminance(aoOut.ambientOcclusionColor);\n#endif\nfloat seo=environmentRadianceOcclusion(ambientMonochrome,NdotVUnclamped);\n#endif\n#ifdef HORIZONOCCLUSION\n#ifdef BUMP\n#ifdef REFLECTIONMAP_3D\nfloat eho=environmentHorizonOcclusion(-viewDirectionW,normalW,geometricNormalW);\n#endif\n#endif\n#endif\n#endif\n";
Effect.IncludesShadersStore[name30] = shader30;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectance0.js
var name31 = "pbrBlockReflectance0";
var shader31 = "float reflectance=max(max(reflectivityOut.surfaceReflectivityColor.r,reflectivityOut.surfaceReflectivityColor.g),reflectivityOut.surfaceReflectivityColor.b);\nvec3 specularEnvironmentR0=reflectivityOut.surfaceReflectivityColor.rgb;\n#ifdef METALLICWORKFLOW\nvec3 specularEnvironmentR90=vec3(metallicReflectanceFactors.a);\n#else\nvec3 specularEnvironmentR90=vec3(1.0,1.0,1.0);\n#endif\n\n#ifdef ALPHAFRESNEL\nfloat reflectance90=fresnelGrazingReflectance(reflectance);\nspecularEnvironmentR90=specularEnvironmentR90*reflectance90;\n#endif\n";
Effect.IncludesShadersStore[name31] = shader31;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectance.js
var name32 = "pbrBlockReflectance";
var shader32 = "#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\nvec3 specularEnvironmentReflectance=getReflectanceFromBRDFLookup(clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,environmentBrdf);\n#ifdef RADIANCEOCCLUSION\nspecularEnvironmentReflectance*=seo;\n#endif\n#ifdef HORIZONOCCLUSION\n#ifdef BUMP\n#ifdef REFLECTIONMAP_3D\nspecularEnvironmentReflectance*=eho;\n#endif\n#endif\n#endif\n#else\n\nvec3 specularEnvironmentReflectance=getReflectanceFromAnalyticalBRDFLookup_Jones(NdotV,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,sqrt(microSurface));\n#endif\n#ifdef CLEARCOAT\nspecularEnvironmentReflectance*=clearcoatOut.conservationFactor;\n#if defined(CLEARCOAT_TINT)\nspecularEnvironmentReflectance*=clearcoatOut.absorption;\n#endif\n#endif\n";
Effect.IncludesShadersStore[name32] = shader32;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockDirectLighting.js
var name33 = "pbrBlockDirectLighting";
var shader33 = "vec3 diffuseBase=vec3(0.,0.,0.);\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif\n#ifdef CLEARCOAT\nvec3 clearCoatBase=vec3(0.,0.,0.);\n#endif\n#ifdef SHEEN\nvec3 sheenBase=vec3(0.,0.,0.);\n#endif\n\npreLightingInfo preInfo;\nlightingInfo info;\nfloat shadow=1.;\n#if defined(CLEARCOAT) && defined(CLEARCOAT_TINT)\nvec3 absorption=vec3(0.);\n#endif\n";
Effect.IncludesShadersStore[name33] = shader33;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockFinalLitComponents.js
var name34 = "pbrBlockFinalLitComponents";
var shader34 = "\n\n\n\n#if defined(ENVIRONMENTBRDF)\n#ifdef MS_BRDF_ENERGY_CONSERVATION\nvec3 energyConservationFactor=getEnergyConservationFactor(clearcoatOut.specularEnvironmentR0,environmentBrdf);\n#endif\n#endif\n#ifndef METALLICWORKFLOW\n#ifdef SPECULAR_GLOSSINESS_ENERGY_CONSERVATION\nsurfaceAlbedo.rgb=(1.-reflectance)*surfaceAlbedo.rgb;\n#endif\n#endif\n#if defined(SHEEN) && defined(SHEEN_ALBEDOSCALING) && defined(ENVIRONMENTBRDF)\nsurfaceAlbedo.rgb=sheenOut.sheenAlbedoScaling*surfaceAlbedo.rgb;\n#endif\n\n#ifdef REFLECTION\nvec3 finalIrradiance=reflectionOut.environmentIrradiance;\n#if defined(CLEARCOAT)\nfinalIrradiance*=clearcoatOut.conservationFactor;\n#if defined(CLEARCOAT_TINT)\nfinalIrradiance*=clearcoatOut.absorption;\n#endif\n#endif\n#if defined(SS_REFRACTION)\nfinalIrradiance*=subSurfaceOut.refractionFactorForIrradiance;\n#endif\n#if defined(SS_TRANSLUCENCY)\nfinalIrradiance*=(1.0-subSurfaceOut.translucencyIntensity);\nfinalIrradiance+=subSurfaceOut.refractionIrradiance;\n#endif\nfinalIrradiance*=surfaceAlbedo.rgb;\nfinalIrradiance*=vLightingIntensity.z;\nfinalIrradiance*=aoOut.ambientOcclusionColor;\n#endif\n\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase;\nfinalSpecular=max(finalSpecular,0.0);\nvec3 finalSpecularScaled=finalSpecular*vLightingIntensity.x*vLightingIntensity.w;\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\nfinalSpecularScaled*=energyConservationFactor;\n#endif\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\nfinalSpecularScaled*=sheenOut.sheenAlbedoScaling;\n#endif\n#endif\n\n#ifdef REFLECTION\nvec3 finalRadiance=reflectionOut.environmentRadiance.rgb;\nfinalRadiance*=subSurfaceOut.specularEnvironmentReflectance;\nvec3 finalRadianceScaled=finalRadiance*vLightingIntensity.z;\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\nfinalRadianceScaled*=energyConservationFactor;\n#endif\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\nfinalRadianceScaled*=sheenOut.sheenAlbedoScaling;\n#endif\n#endif\n\n#ifdef SHEEN\nvec3 finalSheen=sheenBase*sheenOut.sheenColor;\nfinalSheen=max(finalSheen,0.0);\nvec3 finalSheenScaled=finalSheen*vLightingIntensity.x*vLightingIntensity.w;\n#if defined(CLEARCOAT) && defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nsheenOut.finalSheenRadianceScaled*=clearcoatOut.conservationFactor;\n#if defined(CLEARCOAT_TINT)\nsheenOut.finalSheenRadianceScaled*=clearcoatOut.absorption;\n#endif\n#endif\n#endif\n\n#ifdef CLEARCOAT\nvec3 finalClearCoat=clearCoatBase;\nfinalClearCoat=max(finalClearCoat,0.0);\nvec3 finalClearCoatScaled=finalClearCoat*vLightingIntensity.x*vLightingIntensity.w;\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\nfinalClearCoatScaled*=clearcoatOut.energyConservationFactorClearCoat;\n#endif\n#ifdef SS_REFRACTION\nsubSurfaceOut.finalRefraction*=clearcoatOut.conservationFactor;\n#ifdef CLEARCOAT_TINT\nsubSurfaceOut.finalRefraction*=clearcoatOut.absorption;\n#endif\n#endif\n#endif\n\n#ifdef ALPHABLEND\nfloat luminanceOverAlpha=0.0;\n#if defined(REFLECTION) && defined(RADIANCEOVERALPHA)\nluminanceOverAlpha+=getLuminance(finalRadianceScaled);\n#if defined(CLEARCOAT)\nluminanceOverAlpha+=getLuminance(clearcoatOut.finalClearCoatRadianceScaled);\n#endif\n#endif\n#if defined(SPECULARTERM) && defined(SPECULAROVERALPHA)\nluminanceOverAlpha+=getLuminance(finalSpecularScaled);\n#endif\n#if defined(CLEARCOAT) && defined(CLEARCOATOVERALPHA)\nluminanceOverAlpha+=getLuminance(finalClearCoatScaled);\n#endif\n#if defined(RADIANCEOVERALPHA) || defined(SPECULAROVERALPHA) || defined(CLEARCOATOVERALPHA)\nalpha=saturate(alpha+luminanceOverAlpha*luminanceOverAlpha);\n#endif\n#endif\n";
Effect.IncludesShadersStore[name34] = shader34;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockFinalUnlitComponents.js
var name35 = "pbrBlockFinalUnlitComponents";
var shader35 = "\nvec3 finalDiffuse=diffuseBase;\nfinalDiffuse*=surfaceAlbedo.rgb;\nfinalDiffuse=max(finalDiffuse,0.0);\nfinalDiffuse*=vLightingIntensity.x;\n\nvec3 finalAmbient=vAmbientColor;\nfinalAmbient*=surfaceAlbedo.rgb;\n\nvec3 finalEmissive=vEmissiveColor;\n#ifdef EMISSIVE\nvec3 emissiveColorTex=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb;\nfinalEmissive*=toLinearSpace(emissiveColorTex.rgb);\nfinalEmissive*=vEmissiveInfos.y;\n#endif\nfinalEmissive*=vLightingIntensity.y;\n\n#ifdef AMBIENT\nvec3 ambientOcclusionForDirectDiffuse=mix(vec3(1.),aoOut.ambientOcclusionColor,vAmbientInfos.w);\n#else\nvec3 ambientOcclusionForDirectDiffuse=aoOut.ambientOcclusionColor;\n#endif\nfinalAmbient*=aoOut.ambientOcclusionColor;\nfinalDiffuse*=ambientOcclusionForDirectDiffuse;\n";
Effect.IncludesShadersStore[name35] = shader35;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockFinalColorComposition.js
var name36 = "pbrBlockFinalColorComposition";
var shader36 = "vec4 finalColor=vec4(\nfinalAmbient +\nfinalDiffuse +\n#ifndef UNLIT\n#ifdef REFLECTION\nfinalIrradiance +\n#endif\n#ifdef SPECULARTERM\nfinalSpecularScaled +\n#endif\n#ifdef SHEEN\nfinalSheenScaled +\n#endif\n#ifdef CLEARCOAT\nfinalClearCoatScaled +\n#endif\n#ifdef REFLECTION\nfinalRadianceScaled +\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF)\nsheenOut.finalSheenRadianceScaled +\n#endif\n#ifdef CLEARCOAT\nclearcoatOut.finalClearCoatRadianceScaled +\n#endif\n#endif\n#ifdef SS_REFRACTION\nsubSurfaceOut.finalRefraction +\n#endif\n#endif\nfinalEmissive,\nalpha);\n\n#ifdef LIGHTMAP\n#ifndef LIGHTMAPEXCLUDED\n#ifdef USELIGHTMAPASSHADOWMAP\nfinalColor.rgb*=lightmapColor.rgb;\n#else\nfinalColor.rgb+=lightmapColor.rgb;\n#endif\n#endif\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_FOG\n\nfinalColor=max(finalColor,0.0);\n";
Effect.IncludesShadersStore[name36] = shader36;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockImageProcessing.js
var name37 = "pbrBlockImageProcessing";
var shader37 = "#ifdef IMAGEPROCESSINGPOSTPROCESS\n\n\nfinalColor.rgb=clamp(finalColor.rgb,0.,30.0);\n#else\n\nfinalColor=applyImageProcessing(finalColor);\n#endif\nfinalColor.a*=visibility;\n#ifdef PREMULTIPLYALPHA\n\nfinalColor.rgb*=finalColor.a;\n#endif\n";
Effect.IncludesShadersStore[name37] = shader37;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDebug.js
var name38 = "pbrDebug";
var shader38 = "#if DEBUGMODE>0\nif (vClipSpacePosition.x/vClipSpacePosition.w>=vDebugMode.x) {\n\n#if DEBUGMODE == 1\ngl_FragColor.rgb=vPositionW.rgb;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE == 2 && defined(NORMAL)\ngl_FragColor.rgb=vNormalW.rgb;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE == 3 && defined(BUMP) || DEBUGMODE == 3 && defined(PARALLAX) || DEBUGMODE == 3 && defined(ANISOTROPIC)\n\ngl_FragColor.rgb=TBN[0];\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE == 4 && defined(BUMP) || DEBUGMODE == 4 && defined(PARALLAX) || DEBUGMODE == 4 && defined(ANISOTROPIC)\n\ngl_FragColor.rgb=TBN[1];\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE == 5\n\ngl_FragColor.rgb=normalW;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE == 6 && defined(MAINUV1)\ngl_FragColor.rgb=vec3(vMainUV1,0.0);\n#elif DEBUGMODE == 7 && defined(MAINUV2)\ngl_FragColor.rgb=vec3(vMainUV2,0.0);\n#elif DEBUGMODE == 8 && defined(CLEARCOAT) && defined(CLEARCOAT_BUMP)\n\ngl_FragColor.rgb=clearcoatOut.TBNClearCoat[0];\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE == 9 && defined(CLEARCOAT) && defined(CLEARCOAT_BUMP)\n\ngl_FragColor.rgb=clearcoatOut.TBNClearCoat[1];\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE == 10 && defined(CLEARCOAT)\n\ngl_FragColor.rgb=clearcoatOut.clearCoatNormalW;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE == 11 && defined(ANISOTROPIC)\ngl_FragColor.rgb=anisotropicOut.anisotropicNormal;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE == 12 && defined(ANISOTROPIC)\ngl_FragColor.rgb=anisotropicOut.anisotropicTangent;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE == 13 && defined(ANISOTROPIC)\ngl_FragColor.rgb=anisotropicOut.anisotropicBitangent;\n#define DEBUGMODE_NORMALIZE\n\n#elif DEBUGMODE == 20 && defined(ALBEDO)\ngl_FragColor.rgb=albedoTexture.rgb;\n#elif DEBUGMODE == 21 && defined(AMBIENT)\ngl_FragColor.rgb=aoOut.ambientOcclusionColorMap.rgb;\n#elif DEBUGMODE == 22 && defined(OPACITY)\ngl_FragColor.rgb=opacityMap.rgb;\n#elif DEBUGMODE == 23 && defined(EMISSIVE)\ngl_FragColor.rgb=emissiveColorTex.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE == 24 && defined(LIGHTMAP)\ngl_FragColor.rgb=lightmapColor.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE == 25 && defined(REFLECTIVITY) && defined(METALLICWORKFLOW)\ngl_FragColor.rgb=reflectivityOut.surfaceMetallicColorMap.rgb;\n#elif DEBUGMODE == 26 && defined(REFLECTIVITY) && !defined(METALLICWORKFLOW)\ngl_FragColor.rgb=reflectivityOut.surfaceReflectivityColorMap.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE == 27 && defined(CLEARCOAT) && defined(CLEARCOAT_TEXTURE)\ngl_FragColor.rgb=vec3(clearcoatOut.clearCoatMapData.rg,0.0);\n#elif DEBUGMODE == 28 && defined(CLEARCOAT) && defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)\ngl_FragColor.rgb=clearcoatOut.clearCoatTintMapData.rgb;\n#elif DEBUGMODE == 29 && defined(SHEEN) && defined(SHEEN_TEXTURE)\ngl_FragColor.rgb=sheenOut.sheenMapData.rgb;\n#elif DEBUGMODE == 30 && defined(ANISOTROPIC) && defined(ANISOTROPIC_TEXTURE)\ngl_FragColor.rgb=anisotropicOut.anisotropyMapData.rgb;\n#elif DEBUGMODE == 31 && defined(SUBSURFACE) && defined(SS_THICKNESSANDMASK_TEXTURE)\ngl_FragColor.rgb=subSurfaceOut.thicknessMap.rgb;\n\n#elif DEBUGMODE == 40 && defined(SS_REFRACTION)\n\ngl_FragColor.rgb=subSurfaceOut.environmentRefraction.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE == 41 && defined(REFLECTION)\ngl_FragColor.rgb=reflectionOut.environmentRadiance.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE == 42 && defined(CLEARCOAT) && defined(REFLECTION)\ngl_FragColor.rgb=clearcoatOut.environmentClearCoatRadiance.rgb;\n#define DEBUGMODE_GAMMA\n\n#elif DEBUGMODE == 50\ngl_FragColor.rgb=diffuseBase.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE == 51 && defined(SPECULARTERM)\ngl_FragColor.rgb=specularBase.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE == 52 && defined(CLEARCOAT)\ngl_FragColor.rgb=clearCoatBase.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE == 53 && defined(SHEEN)\ngl_FragColor.rgb=sheenBase.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE == 54 && defined(REFLECTION)\ngl_FragColor.rgb=reflectionOut.environmentIrradiance.rgb;\n#define DEBUGMODE_GAMMA\n\n#elif DEBUGMODE == 60\ngl_FragColor.rgb=surfaceAlbedo.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE == 61\ngl_FragColor.rgb=clearcoatOut.specularEnvironmentR0;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE == 62 && defined(METALLICWORKFLOW)\ngl_FragColor.rgb=vec3(reflectivityOut.metallicRoughness.r);\n#elif DEBUGMODE == 71 && defined(METALLICWORKFLOW)\ngl_FragColor.rgb=reflectivityOut.metallicF0;\n#elif DEBUGMODE == 63\ngl_FragColor.rgb=vec3(roughness);\n#elif DEBUGMODE == 64\ngl_FragColor.rgb=vec3(alphaG);\n#elif DEBUGMODE == 65\ngl_FragColor.rgb=vec3(NdotV);\n#elif DEBUGMODE == 66 && defined(CLEARCOAT) && defined(CLEARCOAT_TINT)\ngl_FragColor.rgb=clearcoatOut.clearCoatColor.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE == 67 && defined(CLEARCOAT)\ngl_FragColor.rgb=vec3(clearcoatOut.clearCoatRoughness);\n#elif DEBUGMODE == 68 && defined(CLEARCOAT)\ngl_FragColor.rgb=vec3(clearcoatOut.clearCoatNdotV);\n#elif DEBUGMODE == 69 && defined(SUBSURFACE) && defined(SS_TRANSLUCENCY)\ngl_FragColor.rgb=subSurfaceOut.transmittance;\n#elif DEBUGMODE == 70 && defined(SUBSURFACE) && defined(SS_REFRACTION)\ngl_FragColor.rgb=subSurfaceOut.refractionTransmittance;\n\n#elif DEBUGMODE == 80 && defined(RADIANCEOCCLUSION)\ngl_FragColor.rgb=vec3(seo);\n#elif DEBUGMODE == 81 && defined(HORIZONOCCLUSION)\ngl_FragColor.rgb=vec3(eho);\n#elif DEBUGMODE == 82 && defined(MS_BRDF_ENERGY_CONSERVATION)\ngl_FragColor.rgb=vec3(energyConservationFactor);\n#elif DEBUGMODE == 83 && defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\ngl_FragColor.rgb=specularEnvironmentReflectance;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE == 84 && defined(CLEARCOAT) && defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\ngl_FragColor.rgb=clearcoatOut.clearCoatEnvironmentReflectance;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE == 85 && defined(SHEEN) && defined(REFLECTION)\ngl_FragColor.rgb=sheenOut.sheenEnvironmentReflectance;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE == 86 && defined(ALPHABLEND)\ngl_FragColor.rgb=vec3(luminanceOverAlpha);\n#elif DEBUGMODE == 87\ngl_FragColor.rgb=vec3(alpha);\n#endif\ngl_FragColor.rgb*=vDebugMode.y;\n#ifdef DEBUGMODE_NORMALIZE\ngl_FragColor.rgb=normalize(gl_FragColor.rgb)*0.5+0.5;\n#endif\n#ifdef DEBUGMODE_GAMMA\ngl_FragColor.rgb=toGammaSpace(gl_FragColor.rgb);\n#endif\ngl_FragColor.a=1.0;\n#ifdef PREPASS\ngl_FragData[0]=toLinearSpace(gl_FragColor);\ngl_FragData[1]=vec4(0.,0.,0.,0.);\n#endif\nreturn;\n}\n#endif";
Effect.IncludesShadersStore[name38] = shader38;

// node_modules/@babylonjs/core/Shaders/pbr.fragment.js
var name39 = "pbrPixelShader";
var shader39 = "#if defined(BUMP) || !defined(NORMAL) || defined(FORCENORMALFORWARD) || defined(SPECULARAA) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\n#extension GL_OES_standard_derivatives : enable\n#endif\n#ifdef LODBASEDMICROSFURACE\n#extension GL_EXT_shader_texture_lod : enable\n#endif\n#define CUSTOM_FRAGMENT_BEGIN\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\nprecision highp float;\n\n#ifndef FROMLINEARSPACE\n#define FROMLINEARSPACE\n#endif\n\n#include<__decl__pbrFragment>\n#include<pbrFragmentExtraDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<pbrFragmentSamplersDeclaration>\n#include<imageProcessingDeclaration>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n\n#include<helperFunctions>\n#include<subSurfaceScatteringFunctions>\n#include<importanceSampling>\n#include<pbrHelperFunctions>\n#include<imageProcessingFunctions>\n#include<shadowsFragmentFunctions>\n#include<harmonicsFunctions>\n#include<pbrDirectLightingSetupFunctions>\n#include<pbrDirectLightingFalloffFunctions>\n#include<pbrBRDFFunctions>\n#include<hdrFilteringFunctions>\n#include<pbrDirectLightingFunctions>\n#include<pbrIBLFunctions>\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#ifdef REFLECTION\n#include<reflectionFunction>\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\n#include<pbrBlockAlbedoOpacity>\n#include<pbrBlockReflectivity>\n#include<pbrBlockAmbientOcclusion>\n#include<pbrBlockAlphaFresnel>\n#include<pbrBlockAnisotropic>\n#include<pbrBlockReflection>\n#include<pbrBlockSheen>\n#include<pbrBlockClearcoat>\n#include<pbrBlockSubSurface>\n\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\n\n#include<pbrBlockNormalGeometric>\n#include<bumpFragment>\n#include<pbrBlockNormalFinal>\n\nalbedoOpacityOutParams albedoOpacityOut;\n#ifdef ALBEDO\nvec4 albedoTexture=texture2D(albedoSampler,vAlbedoUV+uvOffset);\n#endif\n#ifdef OPACITY\nvec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);\n#endif\nalbedoOpacityBlock(\nvAlbedoColor,\n#ifdef ALBEDO\nalbedoTexture,\nvAlbedoInfos,\n#endif\n#ifdef OPACITY\nopacityMap,\nvOpacityInfos,\n#endif\n#ifdef DETAIL\ndetailColor,\nvDetailInfos,\n#endif\nalbedoOpacityOut\n);\nvec3 surfaceAlbedo=albedoOpacityOut.surfaceAlbedo;\nfloat alpha=albedoOpacityOut.alpha;\n#define CUSTOM_FRAGMENT_UPDATE_ALPHA\n#include<depthPrePass>\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\n\nambientOcclusionOutParams aoOut;\n#ifdef AMBIENT\nvec3 ambientOcclusionColorMap=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb;\n#endif\nambientOcclusionBlock(\n#ifdef AMBIENT\nambientOcclusionColorMap,\nvAmbientInfos,\n#endif\naoOut\n);\n#include<pbrBlockLightmapInit>\n#ifdef UNLIT\nvec3 diffuseBase=vec3(1.,1.,1.);\n#else\n\nvec3 baseColor=surfaceAlbedo;\nreflectivityOutParams reflectivityOut;\n#if defined(REFLECTIVITY)\nvec4 surfaceMetallicOrReflectivityColorMap=texture2D(reflectivitySampler,vReflectivityUV+uvOffset);\nvec4 baseReflectivity=surfaceMetallicOrReflectivityColorMap;\n#ifndef METALLICWORKFLOW\nsurfaceMetallicOrReflectivityColorMap=toLinearSpace(surfaceMetallicOrReflectivityColorMap);\nsurfaceMetallicOrReflectivityColorMap.rgb*=vReflectivityInfos.y;\n#endif\n#endif\n#if defined(MICROSURFACEMAP)\nvec4 microSurfaceTexel=texture2D(microSurfaceSampler,vMicroSurfaceSamplerUV+uvOffset)*vMicroSurfaceSamplerInfos.y;\n#endif\n#ifdef METALLICWORKFLOW\nvec4 metallicReflectanceFactors=vMetallicReflectanceFactors;\n#ifdef METALLIC_REFLECTANCE\nvec4 metallicReflectanceFactorsMap=texture2D(metallicReflectanceSampler,vMetallicReflectanceUV+uvOffset);\nmetallicReflectanceFactorsMap=toLinearSpace(metallicReflectanceFactorsMap);\nmetallicReflectanceFactors*=metallicReflectanceFactorsMap;\n#endif\n#endif\nreflectivityBlock(\nvReflectivityColor,\n#ifdef METALLICWORKFLOW\nsurfaceAlbedo,\nmetallicReflectanceFactors,\n#endif\n#ifdef REFLECTIVITY\nvReflectivityInfos,\nsurfaceMetallicOrReflectivityColorMap,\n#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\naoOut.ambientOcclusionColor,\n#endif\n#ifdef MICROSURFACEMAP\nmicroSurfaceTexel,\n#endif\n#ifdef DETAIL\ndetailColor,\nvDetailInfos,\n#endif\nreflectivityOut\n);\nfloat microSurface=reflectivityOut.microSurface;\nfloat roughness=reflectivityOut.roughness;\n#ifdef METALLICWORKFLOW\nsurfaceAlbedo=reflectivityOut.surfaceAlbedo;\n#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\naoOut.ambientOcclusionColor=reflectivityOut.ambientOcclusionColor;\n#endif\n\n#ifdef ALPHAFRESNEL\n#if defined(ALPHATEST) || defined(ALPHABLEND)\nalphaFresnelOutParams alphaFresnelOut;\nalphaFresnelBlock(\nnormalW,\nviewDirectionW,\nalpha,\nmicroSurface,\nalphaFresnelOut\n);\nalpha=alphaFresnelOut.alpha;\n#endif\n#endif\n\n#include<pbrBlockGeometryInfo>\n\n#ifdef ANISOTROPIC\nanisotropicOutParams anisotropicOut;\n#ifdef ANISOTROPIC_TEXTURE\nvec3 anisotropyMapData=texture2D(anisotropySampler,vAnisotropyUV+uvOffset).rgb*vAnisotropyInfos.y;\n#endif\nanisotropicBlock(\nvAnisotropy,\n#ifdef ANISOTROPIC_TEXTURE\nanisotropyMapData,\n#endif\nTBN,\nnormalW,\nviewDirectionW,\nanisotropicOut\n);\n#endif\n\n#ifdef REFLECTION\nreflectionOutParams reflectionOut;\nreflectionBlock(\nvPositionW,\nnormalW,\nalphaG,\nvReflectionMicrosurfaceInfos,\nvReflectionInfos,\nvReflectionColor,\n#ifdef ANISOTROPIC\nanisotropicOut,\n#endif\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nNdotVUnclamped,\n#endif\n#ifdef LINEARSPECULARREFLECTION\nroughness,\n#endif\nreflectionSampler,\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX)\nvEnvironmentIrradiance,\n#endif\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\nreflectionMatrix,\n#endif\n#endif\n#ifdef USEIRRADIANCEMAP\nirradianceSampler,\n#endif\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\nreflectionSamplerHigh,\n#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\n#endif\nreflectionOut\n);\n#endif\n\n#include<pbrBlockReflectance0>\n\n#ifdef SHEEN\nsheenOutParams sheenOut;\n#ifdef SHEEN_TEXTURE\nvec4 sheenMapData=toLinearSpace(texture2D(sheenSampler,vSheenUV+uvOffset))*vSheenInfos.y;\n#endif\n#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)\nvec4 sheenMapRoughnessData=texture2D(sheenRoughnessSampler,vSheenRoughnessUV+uvOffset)*vSheenInfos.w;\n#endif\nsheenBlock(\nvSheenColor,\n#ifdef SHEEN_ROUGHNESS\nvSheenRoughness,\n#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)\nsheenMapRoughnessData,\n#endif\n#endif\nroughness,\n#ifdef SHEEN_TEXTURE\nsheenMapData,\n#endif\nreflectance,\n#ifdef SHEEN_LINKWITHALBEDO\nbaseColor,\nsurfaceAlbedo,\n#endif\n#ifdef ENVIRONMENTBRDF\nNdotV,\nenvironmentBrdf,\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nAARoughnessFactors,\nvReflectionMicrosurfaceInfos,\nvReflectionInfos,\nvReflectionColor,\nvLightingIntensity,\nreflectionSampler,\nreflectionOut.reflectionCoords,\nNdotVUnclamped,\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\nreflectionSamplerHigh,\n#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)\nseo,\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)\neho,\n#endif\n#endif\nsheenOut\n);\n#ifdef SHEEN_LINKWITHALBEDO\nsurfaceAlbedo=sheenOut.surfaceAlbedo;\n#endif\n#endif\n\nclearcoatOutParams clearcoatOut;\n#ifdef CLEARCOAT\n#ifdef CLEARCOAT_TEXTURE\nvec2 clearCoatMapData=texture2D(clearCoatSampler,vClearCoatUV+uvOffset).rg*vClearCoatInfos.y;\n#endif\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\nvec4 clearCoatMapRoughnessData=texture2D(clearCoatRoughnessSampler,vClearCoatRoughnessUV+uvOffset)*vClearCoatInfos.w;\n#endif\n#if defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)\nvec4 clearCoatTintMapData=toLinearSpace(texture2D(clearCoatTintSampler,vClearCoatTintUV+uvOffset));\n#endif\n#ifdef CLEARCOAT_BUMP\nvec4 clearCoatBumpMapData=texture2D(clearCoatBumpSampler,vClearCoatBumpUV+uvOffset);\n#endif\nclearcoatBlock(\nvPositionW,\ngeometricNormalW,\nviewDirectionW,\nvClearCoatParams,\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\nclearCoatMapRoughnessData,\n#endif\nspecularEnvironmentR0,\n#ifdef CLEARCOAT_TEXTURE\nclearCoatMapData,\n#endif\n#ifdef CLEARCOAT_TINT\nvClearCoatTintParams,\nclearCoatColorAtDistance,\nvClearCoatRefractionParams,\n#ifdef CLEARCOAT_TINT_TEXTURE\nclearCoatTintMapData,\n#endif\n#endif\n#ifdef CLEARCOAT_BUMP\nvClearCoatBumpInfos,\nclearCoatBumpMapData,\nvClearCoatBumpUV,\n#if defined(TANGENT) && defined(NORMAL)\nvTBN,\n#else\nvClearCoatTangentSpaceParams,\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nnormalMatrix,\n#endif\n#endif\n#if defined(FORCENORMALFORWARD) && defined(NORMAL)\nfaceNormal,\n#endif\n#ifdef REFLECTION\nvReflectionMicrosurfaceInfos,\nvReflectionInfos,\nvReflectionColor,\nvLightingIntensity,\nreflectionSampler,\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\nreflectionSamplerHigh,\n#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\n#endif\n#endif\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\n#ifdef RADIANCEOCCLUSION\nambientMonochrome,\n#endif\n#endif\nclearcoatOut\n);\n#else\nclearcoatOut.specularEnvironmentR0=specularEnvironmentR0;\n#endif\n\n#include<pbrBlockReflectance>\n\nsubSurfaceOutParams subSurfaceOut;\n#ifdef SUBSURFACE\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nvec4 thicknessMap=texture2D(thicknessSampler,vThicknessUV+uvOffset);\n#endif\nsubSurfaceBlock(\nvSubSurfaceIntensity,\nvThicknessParam,\nvTintColor,\nnormalW,\nspecularEnvironmentReflectance,\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nthicknessMap,\n#endif\n#ifdef REFLECTION\n#ifdef SS_TRANSLUCENCY\nreflectionMatrix,\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\nreflectionOut.irradianceVector,\n#endif\n#if defined(REALTIME_FILTERING)\nreflectionSampler,\nvReflectionFilteringInfo,\n#endif\n#endif\n#ifdef USEIRRADIANCEMAP\nirradianceSampler,\n#endif\n#endif\n#endif\n#ifdef SS_REFRACTION\nvPositionW,\nviewDirectionW,\nview,\nsurfaceAlbedo,\nvRefractionInfos,\nrefractionMatrix,\nvRefractionMicrosurfaceInfos,\nvLightingIntensity,\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nalpha,\n#endif\n#ifdef SS_LODINREFRACTIONALPHA\nNdotVUnclamped,\n#endif\n#ifdef SS_LINEARSPECULARREFRACTION\nroughness,\n#else\nalphaG,\n#endif\nrefractionSampler,\n#ifndef LODBASEDMICROSFURACE\nrefractionSamplerLow,\nrefractionSamplerHigh,\n#endif\n#ifdef ANISOTROPIC\nanisotropicOut,\n#endif\n#ifdef REALTIME_FILTERING\nvRefractionFilteringInfo,\n#endif\n#endif\n#ifdef SS_TRANSLUCENCY\nvDiffusionDistance,\n#endif\nsubSurfaceOut\n);\n#ifdef SS_REFRACTION\nsurfaceAlbedo=subSurfaceOut.surfaceAlbedo;\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nalpha=subSurfaceOut.alpha;\n#endif\n#endif\n#else\nsubSurfaceOut.specularEnvironmentReflectance=specularEnvironmentReflectance;\n#endif\n\n#include<pbrBlockDirectLighting>\n#include<lightFragment>[0..maxSimultaneousLights]\n\n#include<pbrBlockFinalLitComponents>\n#endif\n#include<pbrBlockFinalUnlitComponents>\n#include<pbrBlockFinalColorComposition>\n#include<logDepthFragment>\n#include<fogFragment>(color,finalColor)\n#include<pbrBlockImageProcessing>\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\n#ifdef PREPASS\n#ifdef PREPASS_POSITION\ngl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,1.0);\n#endif\n#ifdef PREPASS_VELOCITY\nvec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;\nvec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;\nvec2 velocity=abs(a-b);\nvelocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;\ngl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,1.0);\n#endif\n#ifdef PREPASS_IRRADIANCE\nvec3 irradiance=finalDiffuse;\n#ifndef UNLIT\n#ifdef REFLECTION\nirradiance+=finalIrradiance;\n#endif\n#endif\nvec3 sqAlbedo=sqrt(surfaceAlbedo);\n#ifdef SS_SCATTERING\ngl_FragData[0]=vec4(finalColor.rgb-irradiance,finalColor.a);\nirradiance/=sqAlbedo;\n#else\ngl_FragData[0]=finalColor;\nfloat scatteringDiffusionProfile=255.;\n#endif\ngl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(irradiance,scatteringDiffusionProfile/255.);\n#else\ngl_FragData[0]=vec4(finalColor.rgb,finalColor.a);\n#endif\n#ifdef PREPASS_DEPTHNORMAL\ngl_FragData[PREPASS_DEPTHNORMAL_INDEX]=vec4(vViewPos.z,(view*vec4(normalW,0.0)).rgb);\n#endif\n#ifdef PREPASS_ALBEDO\ngl_FragData[PREPASS_ALBEDO_INDEX]=vec4(sqAlbedo,1.0);\n#endif\n#ifdef PREPASS_REFLECTIVITY\n#if defined(REFLECTIVITY)\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(baseReflectivity.rgb,1.0);\n#else\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(0.0,0.0,0.0,1.0);\n#endif\n#endif\n#endif\n#if !defined(PREPASS) || defined(WEBGL2)\ngl_FragColor=finalColor;\n#endif\n#include<pbrDebug>\n}\n";
Effect.ShadersStore[name39] = shader39;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrVertexDeclaration.js
var name40 = "pbrVertexDeclaration";
var shader40 = "uniform mat4 view;\nuniform mat4 viewProjection;\n#ifdef ALBEDO\nuniform mat4 albedoMatrix;\nuniform vec2 vAlbedoInfos;\n#endif\n#ifdef AMBIENT\nuniform mat4 ambientMatrix;\nuniform vec4 vAmbientInfos;\n#endif\n#ifdef OPACITY\nuniform mat4 opacityMatrix;\nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\nuniform mat4 emissiveMatrix;\n#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;\nuniform mat4 lightmapMatrix;\n#endif\n#ifdef REFLECTIVITY\nuniform vec3 vReflectivityInfos;\nuniform mat4 reflectivityMatrix;\n#endif\n#ifdef METALLIC_REFLECTANCE\nuniform vec2 vMetallicReflectanceInfos;\nuniform mat4 metallicReflectanceMatrix;\n#endif\n#ifdef MICROSURFACEMAP\nuniform vec2 vMicroSurfaceSamplerInfos;\nuniform mat4 microSurfaceSamplerMatrix;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform mat4 bumpMatrix;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;\nuniform mat4 reflectionMatrix;\n#endif\n\n#ifdef CLEARCOAT\n#if defined(CLEARCOAT_TEXTURE) || defined(CLEARCOAT_TEXTURE_ROUGHNESS)\nuniform vec4 vClearCoatInfos;\n#endif\n#ifdef CLEARCOAT_TEXTURE\nuniform mat4 clearCoatMatrix;\n#endif\n#ifdef CLEARCOAT_TEXTURE_ROUGHNESS\nuniform mat4 clearCoatRoughnessMatrix;\n#endif\n#ifdef CLEARCOAT_BUMP\nuniform vec2 vClearCoatBumpInfos;\nuniform mat4 clearCoatBumpMatrix;\n#endif\n#ifdef CLEARCOAT_TINT_TEXTURE\nuniform vec2 vClearCoatTintInfos;\nuniform mat4 clearCoatTintMatrix;\n#endif\n#endif\n\n#ifdef ANISOTROPIC\n#ifdef ANISOTROPIC_TEXTURE\nuniform vec2 vAnisotropyInfos;\nuniform mat4 anisotropyMatrix;\n#endif\n#endif\n\n#ifdef SHEEN\n#if defined(SHEEN_TEXTURE) || defined(SHEEN_TEXTURE_ROUGHNESS)\nuniform vec4 vSheenInfos;\n#endif\n#ifdef SHEEN_TEXTURE\nuniform mat4 sheenMatrix;\n#endif\n#ifdef SHEEN_TEXTURE_ROUGHNESS\nuniform mat4 sheenRoughnessMatrix;\n#endif\n#endif\n\n#ifdef SUBSURFACE\n#ifdef SS_REFRACTION\nuniform vec4 vRefractionInfos;\nuniform mat4 refractionMatrix;\n#endif\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nuniform vec2 vThicknessInfos;\nuniform mat4 thicknessMatrix;\n#endif\n#endif\n";
Effect.IncludesShadersStore[name40] = shader40;

// node_modules/@babylonjs/core/Shaders/pbr.vertex.js
var name41 = "pbrVertexShader";
var shader41 = "precision highp float;\n#include<__decl__pbrVertex>\n#define CUSTOM_VERTEX_BEGIN\n\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef TANGENT\nattribute vec4 tangent;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef MAINUV1\nvarying vec2 vMainUV1;\n#endif\n#ifdef MAINUV2\nvarying vec2 vMainUV2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<helperFunctions>\n#include<bonesDeclaration>\n\n#include<instancesDeclaration>\n#include<prePassVertexDeclaration>\n#if defined(ALBEDO) && ALBEDODIRECTUV == 0\nvarying vec2 vAlbedoUV;\n#endif\n#if defined(DETAIL) && DETAILDIRECTUV == 0\nvarying vec2 vDetailUV;\n#endif\n#if defined(AMBIENT) && AMBIENTDIRECTUV == 0\nvarying vec2 vAmbientUV;\n#endif\n#if defined(OPACITY) && OPACITYDIRECTUV == 0\nvarying vec2 vOpacityUV;\n#endif\n#if defined(EMISSIVE) && EMISSIVEDIRECTUV == 0\nvarying vec2 vEmissiveUV;\n#endif\n#if defined(LIGHTMAP) && LIGHTMAPDIRECTUV == 0\nvarying vec2 vLightmapUV;\n#endif\n#if defined(REFLECTIVITY) && REFLECTIVITYDIRECTUV == 0\nvarying vec2 vReflectivityUV;\n#endif\n#if defined(MICROSURFACEMAP) && MICROSURFACEMAPDIRECTUV == 0\nvarying vec2 vMicroSurfaceSamplerUV;\n#endif\n#if defined(METALLIC_REFLECTANCE) && METALLIC_REFLECTANCEDIRECTUV == 0\nvarying vec2 vMetallicReflectanceUV;\n#endif\n#if defined(BUMP) && BUMPDIRECTUV == 0\nvarying vec2 vBumpUV;\n#endif\n#ifdef CLEARCOAT\n#if defined(CLEARCOAT_TEXTURE) && CLEARCOAT_TEXTUREDIRECTUV == 0\nvarying vec2 vClearCoatUV;\n#endif\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV == 0\nvarying vec2 vClearCoatRoughnessUV;\n#endif\n#if defined(CLEARCOAT_BUMP) && CLEARCOAT_BUMPDIRECTUV == 0\nvarying vec2 vClearCoatBumpUV;\n#endif\n#if defined(CLEARCOAT_TINT_TEXTURE) && CLEARCOAT_TINT_TEXTUREDIRECTUV == 0\nvarying vec2 vClearCoatTintUV;\n#endif\n#endif\n#ifdef SHEEN\n#if defined(SHEEN_TEXTURE) && SHEEN_TEXTUREDIRECTUV == 0\nvarying vec2 vSheenUV;\n#endif\n#if defined(SHEEN_TEXTURE_ROUGHNESS) && SHEEN_TEXTURE_ROUGHNESSDIRECTUV == 0\nvarying vec2 vSheenRoughnessUV;\n#endif\n#endif\n#ifdef ANISOTROPIC\n#if defined(ANISOTROPIC_TEXTURE) && ANISOTROPIC_TEXTUREDIRECTUV == 0\nvarying vec2 vAnisotropyUV;\n#endif\n#endif\n#ifdef SUBSURFACE\n#if defined(SS_THICKNESSANDMASK_TEXTURE) && SS_THICKNESSANDMASK_TEXTUREDIRECTUV == 0\nvarying vec2 vThicknessUV;\n#endif\n#endif\n\nvarying vec3 vPositionW;\n#if DEBUGMODE>0\nvarying vec4 vClipSpacePosition;\n#endif\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\nvarying vec3 vEnvironmentIrradiance;\n#include<harmonicsFunctions>\n#endif\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<bumpVertexDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvec3 positionUpdated=position;\n#ifdef NORMAL\nvec3 normalUpdated=normal;\n#endif\n#ifdef TANGENT\nvec4 tangentUpdated=tangent;\n#endif\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvPositionUVW=positionUpdated;\n#endif\n#define CUSTOM_VERTEX_UPDATE_POSITION\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n#include<instancesVertex>\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\n\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);\nvPreviousPosition=previousViewProjection*previousWorld*vec4(positionUpdated,1.0);\n#endif\n#include<bonesVertex>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\nvPositionW=vec3(worldPos);\n#include<prePassVertex>\n#ifdef NORMAL\nmat3 normalWorld=mat3(finalWorld);\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));\nvNormalW=normalize(normalWorld*vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\n#endif\nvNormalW=normalize(normalWorld*normalUpdated);\n#endif\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\nvec3 reflectionVector=vec3(reflectionMatrix*vec4(vNormalW,0)).xyz;\n#ifdef REFLECTIONMAP_OPPOSITEZ\nreflectionVector.z*=-1.0;\n#endif\nvEnvironmentIrradiance=computeEnvironmentIrradiance(reflectionVector);\n#endif\n#endif\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR == 0u) {\ngl_Position=viewProjection*worldPos;\n} else {\ngl_Position=viewProjectionR*worldPos;\n}\n#else\ngl_Position=viewProjection*worldPos;\n#endif\n#if DEBUGMODE>0\nvClipSpacePosition=gl_Position;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));\n#endif\n\n#ifndef UV1\nvec2 uvUpdated=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef MAINUV1\nvMainUV1=uvUpdated;\n#endif\n#ifdef MAINUV2\nvMainUV2=uv2;\n#endif\n#if defined(ALBEDO) && ALBEDODIRECTUV == 0\nif (vAlbedoInfos.x == 0.)\n{\nvAlbedoUV=vec2(albedoMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvAlbedoUV=vec2(albedoMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(DETAIL) && DETAILDIRECTUV == 0\nif (vDetailInfos.x == 0.)\n{\nvDetailUV=vec2(detailMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvDetailUV=vec2(detailMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(AMBIENT) && AMBIENTDIRECTUV == 0\nif (vAmbientInfos.x == 0.)\n{\nvAmbientUV=vec2(ambientMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvAmbientUV=vec2(ambientMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(OPACITY) && OPACITYDIRECTUV == 0\nif (vOpacityInfos.x == 0.)\n{\nvOpacityUV=vec2(opacityMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvOpacityUV=vec2(opacityMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(EMISSIVE) && EMISSIVEDIRECTUV == 0\nif (vEmissiveInfos.x == 0.)\n{\nvEmissiveUV=vec2(emissiveMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvEmissiveUV=vec2(emissiveMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(LIGHTMAP) && LIGHTMAPDIRECTUV == 0\nif (vLightmapInfos.x == 0.)\n{\nvLightmapUV=vec2(lightmapMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvLightmapUV=vec2(lightmapMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(REFLECTIVITY) && REFLECTIVITYDIRECTUV == 0\nif (vReflectivityInfos.x == 0.)\n{\nvReflectivityUV=vec2(reflectivityMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvReflectivityUV=vec2(reflectivityMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(MICROSURFACEMAP) && MICROSURFACEMAPDIRECTUV == 0\nif (vMicroSurfaceSamplerInfos.x == 0.)\n{\nvMicroSurfaceSamplerUV=vec2(microSurfaceSamplerMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvMicroSurfaceSamplerUV=vec2(microSurfaceSamplerMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(METALLIC_REFLECTANCE) && METALLIC_REFLECTANCEDIRECTUV == 0\nif (vMetallicReflectanceInfos.x == 0.)\n{\nvMetallicReflectanceUV=vec2(metallicReflectanceMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvMetallicReflectanceUV=vec2(metallicReflectanceMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(BUMP) && BUMPDIRECTUV == 0\nif (vBumpInfos.x == 0.)\n{\nvBumpUV=vec2(bumpMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvBumpUV=vec2(bumpMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#ifdef CLEARCOAT\n#if defined(CLEARCOAT_TEXTURE) && CLEARCOAT_TEXTUREDIRECTUV == 0\nif (vClearCoatInfos.x == 0.)\n{\nvClearCoatUV=vec2(clearCoatMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvClearCoatUV=vec2(clearCoatMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV == 0\nif (vClearCoatInfos.z == 0.)\n{\nvClearCoatRoughnessUV=vec2(clearCoatRoughnessMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvClearCoatRoughnessUV=vec2(clearCoatRoughnessMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(CLEARCOAT_BUMP) && CLEARCOAT_BUMPDIRECTUV == 0\nif (vClearCoatBumpInfos.x == 0.)\n{\nvClearCoatBumpUV=vec2(clearCoatBumpMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvClearCoatBumpUV=vec2(clearCoatBumpMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(CLEARCOAT_TINT_TEXTURE) && CLEARCOAT_TINT_TEXTUREDIRECTUV == 0\nif (vClearCoatTintInfos.x == 0.)\n{\nvClearCoatTintUV=vec2(clearCoatTintMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvClearCoatTintUV=vec2(clearCoatTintMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#endif\n#ifdef SHEEN\n#if defined(SHEEN_TEXTURE) && SHEEN_TEXTUREDIRECTUV == 0\nif (vSheenInfos.x == 0.)\n{\nvSheenUV=vec2(sheenMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvSheenUV=vec2(sheenMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(SHEEN_TEXTURE_ROUGHNESS) && SHEEN_TEXTURE_ROUGHNESSDIRECTUV == 0\nif (vSheenInfos.z == 0.)\n{\nvSheenRoughnessUV=vec2(sheenRoughnessMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvSheenRoughnessUV=vec2(sheenRoughnessMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#endif\n#ifdef ANISOTROPIC\n#if defined(ANISOTROPIC_TEXTURE) && ANISOTROPIC_TEXTUREDIRECTUV == 0\nif (vAnisotropyInfos.x == 0.)\n{\nvAnisotropyUV=vec2(anisotropyMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvAnisotropyUV=vec2(anisotropyMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#endif\n#ifdef SUBSURFACE\n#if defined(SS_THICKNESSANDMASK_TEXTURE) && SS_THICKNESSANDMASK_TEXTUREDIRECTUV == 0\nif (vThicknessInfos.x == 0.)\n{\nvThicknessUV=vec2(thicknessMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvThicknessUV=vec2(thicknessMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#endif\n\n#include<bumpVertex>\n\n#include<clipPlaneVertex>\n\n#include<fogVertex>\n\n#include<shadowsVertex>[0..maxSimultaneousLights]\n\n#ifdef VERTEXCOLOR\nvColor=color;\n#endif\n\n#ifdef POINTSIZE\ngl_PointSize=pointSize;\n#endif\n\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}";
Effect.ShadersStore[name41] = shader41;

// node_modules/@babylonjs/core/Materials/PBR/pbrBaseMaterial.js
var onCreatedEffectParameters2 = { effect: null, subMesh: null };
var PBRMaterialDefines = function(_super) {
  __extends(PBRMaterialDefines2, _super);
  function PBRMaterialDefines2() {
    var _this = _super.call(this) || this;
    _this.PBR = true;
    _this.NUM_SAMPLES = "0";
    _this.REALTIME_FILTERING = false;
    _this.MAINUV1 = false;
    _this.MAINUV2 = false;
    _this.UV1 = false;
    _this.UV2 = false;
    _this.ALBEDO = false;
    _this.GAMMAALBEDO = false;
    _this.ALBEDODIRECTUV = 0;
    _this.VERTEXCOLOR = false;
    _this.DETAIL = false;
    _this.DETAILDIRECTUV = 0;
    _this.DETAIL_NORMALBLENDMETHOD = 0;
    _this.AMBIENT = false;
    _this.AMBIENTDIRECTUV = 0;
    _this.AMBIENTINGRAYSCALE = false;
    _this.OPACITY = false;
    _this.VERTEXALPHA = false;
    _this.OPACITYDIRECTUV = 0;
    _this.OPACITYRGB = false;
    _this.ALPHATEST = false;
    _this.DEPTHPREPASS = false;
    _this.ALPHABLEND = false;
    _this.ALPHAFROMALBEDO = false;
    _this.ALPHATESTVALUE = "0.5";
    _this.SPECULAROVERALPHA = false;
    _this.RADIANCEOVERALPHA = false;
    _this.ALPHAFRESNEL = false;
    _this.LINEARALPHAFRESNEL = false;
    _this.PREMULTIPLYALPHA = false;
    _this.EMISSIVE = false;
    _this.EMISSIVEDIRECTUV = 0;
    _this.REFLECTIVITY = false;
    _this.REFLECTIVITYDIRECTUV = 0;
    _this.SPECULARTERM = false;
    _this.MICROSURFACEFROMREFLECTIVITYMAP = false;
    _this.MICROSURFACEAUTOMATIC = false;
    _this.LODBASEDMICROSFURACE = false;
    _this.MICROSURFACEMAP = false;
    _this.MICROSURFACEMAPDIRECTUV = 0;
    _this.METALLICWORKFLOW = false;
    _this.ROUGHNESSSTOREINMETALMAPALPHA = false;
    _this.ROUGHNESSSTOREINMETALMAPGREEN = false;
    _this.METALLNESSSTOREINMETALMAPBLUE = false;
    _this.AOSTOREINMETALMAPRED = false;
    _this.METALLIC_REFLECTANCE = false;
    _this.METALLIC_REFLECTANCEDIRECTUV = 0;
    _this.ENVIRONMENTBRDF = false;
    _this.ENVIRONMENTBRDF_RGBD = false;
    _this.NORMAL = false;
    _this.TANGENT = false;
    _this.BUMP = false;
    _this.BUMPDIRECTUV = 0;
    _this.OBJECTSPACE_NORMALMAP = false;
    _this.PARALLAX = false;
    _this.PARALLAXOCCLUSION = false;
    _this.NORMALXYSCALE = true;
    _this.LIGHTMAP = false;
    _this.LIGHTMAPDIRECTUV = 0;
    _this.USELIGHTMAPASSHADOWMAP = false;
    _this.GAMMALIGHTMAP = false;
    _this.RGBDLIGHTMAP = false;
    _this.REFLECTION = false;
    _this.REFLECTIONMAP_3D = false;
    _this.REFLECTIONMAP_SPHERICAL = false;
    _this.REFLECTIONMAP_PLANAR = false;
    _this.REFLECTIONMAP_CUBIC = false;
    _this.USE_LOCAL_REFLECTIONMAP_CUBIC = false;
    _this.REFLECTIONMAP_PROJECTION = false;
    _this.REFLECTIONMAP_SKYBOX = false;
    _this.REFLECTIONMAP_EXPLICIT = false;
    _this.REFLECTIONMAP_EQUIRECTANGULAR = false;
    _this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
    _this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
    _this.INVERTCUBICMAP = false;
    _this.USESPHERICALFROMREFLECTIONMAP = false;
    _this.USEIRRADIANCEMAP = false;
    _this.SPHERICAL_HARMONICS = false;
    _this.USESPHERICALINVERTEX = false;
    _this.REFLECTIONMAP_OPPOSITEZ = false;
    _this.LODINREFLECTIONALPHA = false;
    _this.GAMMAREFLECTION = false;
    _this.RGBDREFLECTION = false;
    _this.LINEARSPECULARREFLECTION = false;
    _this.RADIANCEOCCLUSION = false;
    _this.HORIZONOCCLUSION = false;
    _this.INSTANCES = false;
    _this.THIN_INSTANCES = false;
    _this.PREPASS = false;
    _this.PREPASS_IRRADIANCE = false;
    _this.PREPASS_IRRADIANCE_INDEX = -1;
    _this.PREPASS_ALBEDO = false;
    _this.PREPASS_ALBEDO_INDEX = -1;
    _this.PREPASS_DEPTHNORMAL = false;
    _this.PREPASS_DEPTHNORMAL_INDEX = -1;
    _this.PREPASS_POSITION = false;
    _this.PREPASS_POSITION_INDEX = -1;
    _this.PREPASS_VELOCITY = false;
    _this.PREPASS_VELOCITY_INDEX = -1;
    _this.PREPASS_REFLECTIVITY = false;
    _this.PREPASS_REFLECTIVITY_INDEX = -1;
    _this.SCENE_MRT_COUNT = 0;
    _this.NUM_BONE_INFLUENCERS = 0;
    _this.BonesPerMesh = 0;
    _this.BONETEXTURE = false;
    _this.BONES_VELOCITY_ENABLED = false;
    _this.NONUNIFORMSCALING = false;
    _this.MORPHTARGETS = false;
    _this.MORPHTARGETS_NORMAL = false;
    _this.MORPHTARGETS_TANGENT = false;
    _this.MORPHTARGETS_UV = false;
    _this.NUM_MORPH_INFLUENCERS = 0;
    _this.IMAGEPROCESSING = false;
    _this.VIGNETTE = false;
    _this.VIGNETTEBLENDMODEMULTIPLY = false;
    _this.VIGNETTEBLENDMODEOPAQUE = false;
    _this.TONEMAPPING = false;
    _this.TONEMAPPING_ACES = false;
    _this.CONTRAST = false;
    _this.COLORCURVES = false;
    _this.COLORGRADING = false;
    _this.COLORGRADING3D = false;
    _this.SAMPLER3DGREENDEPTH = false;
    _this.SAMPLER3DBGRMAP = false;
    _this.IMAGEPROCESSINGPOSTPROCESS = false;
    _this.EXPOSURE = false;
    _this.MULTIVIEW = false;
    _this.USEPHYSICALLIGHTFALLOFF = false;
    _this.USEGLTFLIGHTFALLOFF = false;
    _this.TWOSIDEDLIGHTING = false;
    _this.SHADOWFLOAT = false;
    _this.CLIPPLANE = false;
    _this.CLIPPLANE2 = false;
    _this.CLIPPLANE3 = false;
    _this.CLIPPLANE4 = false;
    _this.CLIPPLANE5 = false;
    _this.CLIPPLANE6 = false;
    _this.POINTSIZE = false;
    _this.FOG = false;
    _this.LOGARITHMICDEPTH = false;
    _this.FORCENORMALFORWARD = false;
    _this.SPECULARAA = false;
    _this.CLEARCOAT = false;
    _this.CLEARCOAT_DEFAULTIOR = false;
    _this.CLEARCOAT_TEXTURE = false;
    _this.CLEARCOAT_TEXTURE_ROUGHNESS = false;
    _this.CLEARCOAT_TEXTUREDIRECTUV = 0;
    _this.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV = 0;
    _this.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
    _this.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL = false;
    _this.CLEARCOAT_BUMP = false;
    _this.CLEARCOAT_BUMPDIRECTUV = 0;
    _this.CLEARCOAT_REMAP_F0 = true;
    _this.CLEARCOAT_TINT = false;
    _this.CLEARCOAT_TINT_TEXTURE = false;
    _this.CLEARCOAT_TINT_TEXTUREDIRECTUV = 0;
    _this.ANISOTROPIC = false;
    _this.ANISOTROPIC_TEXTURE = false;
    _this.ANISOTROPIC_TEXTUREDIRECTUV = 0;
    _this.BRDF_V_HEIGHT_CORRELATED = false;
    _this.MS_BRDF_ENERGY_CONSERVATION = false;
    _this.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = false;
    _this.SHEEN = false;
    _this.SHEEN_TEXTURE = false;
    _this.SHEEN_TEXTURE_ROUGHNESS = false;
    _this.SHEEN_TEXTUREDIRECTUV = 0;
    _this.SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0;
    _this.SHEEN_LINKWITHALBEDO = false;
    _this.SHEEN_ROUGHNESS = false;
    _this.SHEEN_ALBEDOSCALING = false;
    _this.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
    _this.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL = false;
    _this.SUBSURFACE = false;
    _this.SS_REFRACTION = false;
    _this.SS_TRANSLUCENCY = false;
    _this.SS_SCATTERING = false;
    _this.SS_THICKNESSANDMASK_TEXTURE = false;
    _this.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;
    _this.SS_REFRACTIONMAP_3D = false;
    _this.SS_REFRACTIONMAP_OPPOSITEZ = false;
    _this.SS_LODINREFRACTIONALPHA = false;
    _this.SS_GAMMAREFRACTION = false;
    _this.SS_RGBDREFRACTION = false;
    _this.SS_LINEARSPECULARREFRACTION = false;
    _this.SS_LINKREFRACTIONTOTRANSPARENCY = false;
    _this.SS_ALBEDOFORREFRACTIONTINT = false;
    _this.SS_MASK_FROM_THICKNESS_TEXTURE = false;
    _this.SS_MASK_FROM_THICKNESS_TEXTURE_GLTF = false;
    _this.UNLIT = false;
    _this.DEBUGMODE = 0;
    _this.rebuild();
    return _this;
  }
  PBRMaterialDefines2.prototype.reset = function() {
    _super.prototype.reset.call(this);
    this.ALPHATESTVALUE = "0.5";
    this.PBR = true;
  };
  return PBRMaterialDefines2;
}(MaterialDefines);
var PBRBaseMaterial = function(_super) {
  __extends(PBRBaseMaterial2, _super);
  function PBRBaseMaterial2(name42, scene) {
    var _this = _super.call(this, name42, scene) || this;
    _this._directIntensity = 1;
    _this._emissiveIntensity = 1;
    _this._environmentIntensity = 1;
    _this._specularIntensity = 1;
    _this._lightingInfos = new Vector4(_this._directIntensity, _this._emissiveIntensity, _this._environmentIntensity, _this._specularIntensity);
    _this._disableBumpMap = false;
    _this._albedoTexture = null;
    _this._ambientTexture = null;
    _this._ambientTextureStrength = 1;
    _this._ambientTextureImpactOnAnalyticalLights = PBRBaseMaterial2.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;
    _this._opacityTexture = null;
    _this._reflectionTexture = null;
    _this._emissiveTexture = null;
    _this._reflectivityTexture = null;
    _this._metallicTexture = null;
    _this._metallic = null;
    _this._roughness = null;
    _this._metallicF0Factor = 1;
    _this._metallicReflectanceColor = Color3.White();
    _this._metallicReflectanceTexture = null;
    _this._microSurfaceTexture = null;
    _this._bumpTexture = null;
    _this._lightmapTexture = null;
    _this._ambientColor = new Color3(0, 0, 0);
    _this._albedoColor = new Color3(1, 1, 1);
    _this._reflectivityColor = new Color3(1, 1, 1);
    _this._reflectionColor = new Color3(1, 1, 1);
    _this._emissiveColor = new Color3(0, 0, 0);
    _this._microSurface = 0.9;
    _this._useLightmapAsShadowmap = false;
    _this._useHorizonOcclusion = true;
    _this._useRadianceOcclusion = true;
    _this._useAlphaFromAlbedoTexture = false;
    _this._useSpecularOverAlpha = true;
    _this._useMicroSurfaceFromReflectivityMapAlpha = false;
    _this._useRoughnessFromMetallicTextureAlpha = true;
    _this._useRoughnessFromMetallicTextureGreen = false;
    _this._useMetallnessFromMetallicTextureBlue = false;
    _this._useAmbientOcclusionFromMetallicTextureRed = false;
    _this._useAmbientInGrayScale = false;
    _this._useAutoMicroSurfaceFromReflectivityMap = false;
    _this._lightFalloff = PBRBaseMaterial2.LIGHTFALLOFF_PHYSICAL;
    _this._useRadianceOverAlpha = true;
    _this._useObjectSpaceNormalMap = false;
    _this._useParallax = false;
    _this._useParallaxOcclusion = false;
    _this._parallaxScaleBias = 0.05;
    _this._disableLighting = false;
    _this._maxSimultaneousLights = 4;
    _this._invertNormalMapX = false;
    _this._invertNormalMapY = false;
    _this._twoSidedLighting = false;
    _this._alphaCutOff = 0.4;
    _this._forceAlphaTest = false;
    _this._useAlphaFresnel = false;
    _this._useLinearAlphaFresnel = false;
    _this._environmentBRDFTexture = null;
    _this._forceIrradianceInFragment = false;
    _this._realTimeFiltering = false;
    _this._realTimeFilteringQuality = 8;
    _this._forceNormalForward = false;
    _this._enableSpecularAntiAliasing = false;
    _this._imageProcessingObserver = null;
    _this._renderTargets = new SmartArray(16);
    _this._globalAmbientColor = new Color3(0, 0, 0);
    _this._useLogarithmicDepth = false;
    _this._unlit = false;
    _this._debugMode = 0;
    _this.debugMode = 0;
    _this.debugLimit = -1;
    _this.debugFactor = 1;
    _this.clearCoat = new PBRClearCoatConfiguration(_this._markAllSubMeshesAsTexturesDirty.bind(_this));
    _this.anisotropy = new PBRAnisotropicConfiguration(_this._markAllSubMeshesAsTexturesDirty.bind(_this));
    _this.brdf = new PBRBRDFConfiguration(_this._markAllSubMeshesAsMiscDirty.bind(_this));
    _this.sheen = new PBRSheenConfiguration(_this._markAllSubMeshesAsTexturesDirty.bind(_this));
    _this.detailMap = new DetailMapConfiguration(_this._markAllSubMeshesAsTexturesDirty.bind(_this));
    _this._rebuildInParallel = false;
    _this._attachImageProcessingConfiguration(null);
    _this.getRenderTargetTextures = function() {
      _this._renderTargets.reset();
      if (MaterialFlags.ReflectionTextureEnabled && _this._reflectionTexture && _this._reflectionTexture.isRenderTarget) {
        _this._renderTargets.push(_this._reflectionTexture);
      }
      _this.subSurface.fillRenderTargetTextures(_this._renderTargets);
      return _this._renderTargets;
    };
    _this._environmentBRDFTexture = BRDFTextureTools.GetEnvironmentBRDFTexture(scene);
    _this.subSurface = new PBRSubSurfaceConfiguration(_this._markAllSubMeshesAsTexturesDirty.bind(_this), _this._markScenePrePassDirty.bind(_this), scene);
    _this.prePassConfiguration = new PrePassConfiguration();
    return _this;
  }
  Object.defineProperty(PBRBaseMaterial2.prototype, "realTimeFiltering", {
    get: function() {
      return this._realTimeFiltering;
    },
    set: function(b) {
      this._realTimeFiltering = b;
      this.markAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRBaseMaterial2.prototype, "realTimeFilteringQuality", {
    get: function() {
      return this._realTimeFilteringQuality;
    },
    set: function(n) {
      this._realTimeFilteringQuality = n;
      this.markAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRBaseMaterial2.prototype, "canRenderToMRT", {
    get: function() {
      return true;
    },
    enumerable: false,
    configurable: true
  });
  PBRBaseMaterial2.prototype._attachImageProcessingConfiguration = function(configuration) {
    var _this = this;
    if (configuration === this._imageProcessingConfiguration) {
      return;
    }
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    if (!configuration) {
      this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;
    } else {
      this._imageProcessingConfiguration = configuration;
    }
    if (this._imageProcessingConfiguration) {
      this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(function() {
        _this._markAllSubMeshesAsImageProcessingDirty();
      });
    }
  };
  Object.defineProperty(PBRBaseMaterial2.prototype, "hasRenderTargetTextures", {
    get: function() {
      if (MaterialFlags.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
        return true;
      }
      return this.subSurface.hasRenderTargetTextures();
    },
    enumerable: false,
    configurable: true
  });
  PBRBaseMaterial2.prototype.getClassName = function() {
    return "PBRBaseMaterial";
  };
  Object.defineProperty(PBRBaseMaterial2.prototype, "useLogarithmicDepth", {
    get: function() {
      return this._useLogarithmicDepth;
    },
    set: function(value) {
      this._useLogarithmicDepth = value && this.getScene().getEngine().getCaps().fragmentDepthSupported;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRBaseMaterial2.prototype, "_disableAlphaBlending", {
    get: function() {
      return this.subSurface.disableAlphaBlending || this._transparencyMode === PBRBaseMaterial2.PBRMATERIAL_OPAQUE || this._transparencyMode === PBRBaseMaterial2.PBRMATERIAL_ALPHATEST;
    },
    enumerable: false,
    configurable: true
  });
  PBRBaseMaterial2.prototype.needAlphaBlending = function() {
    if (this._disableAlphaBlending) {
      return false;
    }
    return this.alpha < 1 || this._opacityTexture != null || this._shouldUseAlphaFromAlbedoTexture();
  };
  PBRBaseMaterial2.prototype.needAlphaTesting = function() {
    if (this._forceAlphaTest) {
      return true;
    }
    if (this.subSurface.disableAlphaBlending) {
      return false;
    }
    return this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === PBRBaseMaterial2.PBRMATERIAL_ALPHATEST);
  };
  PBRBaseMaterial2.prototype._shouldUseAlphaFromAlbedoTexture = function() {
    return this._albedoTexture != null && this._albedoTexture.hasAlpha && this._useAlphaFromAlbedoTexture && this._transparencyMode !== PBRBaseMaterial2.PBRMATERIAL_OPAQUE;
  };
  PBRBaseMaterial2.prototype._hasAlphaChannel = function() {
    return this._albedoTexture != null && this._albedoTexture.hasAlpha || this._opacityTexture != null;
  };
  PBRBaseMaterial2.prototype.getAlphaTestTexture = function() {
    return this._albedoTexture;
  };
  PBRBaseMaterial2.prototype.isReadyForSubMesh = function(mesh, subMesh, useInstances) {
    if (subMesh.effect && this.isFrozen) {
      if (subMesh.effect._wasPreviouslyReady) {
        return true;
      }
    }
    if (!subMesh._materialDefines) {
      subMesh._materialDefines = new PBRMaterialDefines();
    }
    var defines = subMesh._materialDefines;
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    var scene = this.getScene();
    var engine = scene.getEngine();
    if (defines._areTexturesDirty) {
      if (scene.texturesEnabled) {
        if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
          if (!this._albedoTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
          if (!this._ambientTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
          if (!this._opacityTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        var reflectionTexture = this._getReflectionTexture();
        if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
          if (!reflectionTexture.isReadyOrNotBlocking()) {
            return false;
          }
          if (reflectionTexture.irradianceTexture && !reflectionTexture.irradianceTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
          if (!this._lightmapTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
          if (!this._emissiveTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (MaterialFlags.SpecularTextureEnabled) {
          if (this._metallicTexture) {
            if (!this._metallicTexture.isReadyOrNotBlocking()) {
              return false;
            }
          } else if (this._reflectivityTexture) {
            if (!this._reflectivityTexture.isReadyOrNotBlocking()) {
              return false;
            }
          }
          if (this._metallicReflectanceTexture) {
            if (!this._metallicReflectanceTexture.isReadyOrNotBlocking()) {
              return false;
            }
          }
          if (this._microSurfaceTexture) {
            if (!this._microSurfaceTexture.isReadyOrNotBlocking()) {
              return false;
            }
          }
        }
        if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
          if (!this._bumpTexture.isReady()) {
            return false;
          }
        }
        if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {
          if (!this._environmentBRDFTexture.isReady()) {
            return false;
          }
        }
      }
    }
    if (!this.subSurface.isReadyForSubMesh(defines, scene) || !this.clearCoat.isReadyForSubMesh(defines, scene, engine, this._disableBumpMap) || !this.sheen.isReadyForSubMesh(defines, scene) || !this.anisotropy.isReadyForSubMesh(defines, scene) || !this.detailMap.isReadyForSubMesh(defines, scene)) {
      return false;
    }
    if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
      if (!this._imageProcessingConfiguration.isReady()) {
        return false;
      }
    }
    if (!engine.getCaps().standardDerivatives && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      mesh.createNormals(true);
      Logger.Warn("PBRMaterial: Normals have been created for the mesh: " + mesh.name);
    }
    var previousEffect = subMesh.effect;
    var lightDisposed = defines._areLightsDisposed;
    var effect = this._prepareEffect(mesh, defines, this.onCompiled, this.onError, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);
    if (effect) {
      if (this._onEffectCreatedObservable) {
        onCreatedEffectParameters2.effect = effect;
        onCreatedEffectParameters2.subMesh = subMesh;
        this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters2);
      }
      if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {
        effect = previousEffect;
        this._rebuildInParallel = true;
        defines.markAsUnprocessed();
        if (lightDisposed) {
          defines._areLightsDisposed = true;
          return false;
        }
      } else {
        this._rebuildInParallel = false;
        scene.resetCachedMaterial();
        subMesh.setEffect(effect, defines);
        this.buildUniformLayout();
      }
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    subMesh.effect._wasPreviouslyReady = true;
    return true;
  };
  PBRBaseMaterial2.prototype.isMetallicWorkflow = function() {
    if (this._metallic != null || this._roughness != null || this._metallicTexture) {
      return true;
    }
    return false;
  };
  PBRBaseMaterial2.prototype._prepareEffect = function(mesh, defines, onCompiled, onError, useInstances, useClipPlane, useThinInstances) {
    if (onCompiled === void 0) {
      onCompiled = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (useInstances === void 0) {
      useInstances = null;
    }
    if (useClipPlane === void 0) {
      useClipPlane = null;
    }
    this._prepareDefines(mesh, defines, useInstances, useClipPlane, useThinInstances);
    if (!defines.isDirty) {
      return null;
    }
    defines.markAsProcessed();
    var scene = this.getScene();
    var engine = scene.getEngine();
    var fallbacks = new EffectFallbacks();
    var fallbackRank = 0;
    if (defines.USESPHERICALINVERTEX) {
      fallbacks.addFallback(fallbackRank++, "USESPHERICALINVERTEX");
    }
    if (defines.FOG) {
      fallbacks.addFallback(fallbackRank, "FOG");
    }
    if (defines.SPECULARAA) {
      fallbacks.addFallback(fallbackRank, "SPECULARAA");
    }
    if (defines.POINTSIZE) {
      fallbacks.addFallback(fallbackRank, "POINTSIZE");
    }
    if (defines.LOGARITHMICDEPTH) {
      fallbacks.addFallback(fallbackRank, "LOGARITHMICDEPTH");
    }
    if (defines.PARALLAX) {
      fallbacks.addFallback(fallbackRank, "PARALLAX");
    }
    if (defines.PARALLAXOCCLUSION) {
      fallbacks.addFallback(fallbackRank++, "PARALLAXOCCLUSION");
    }
    fallbackRank = PBRAnisotropicConfiguration.AddFallbacks(defines, fallbacks, fallbackRank);
    fallbackRank = PBRAnisotropicConfiguration.AddFallbacks(defines, fallbacks, fallbackRank);
    fallbackRank = PBRSubSurfaceConfiguration.AddFallbacks(defines, fallbacks, fallbackRank);
    fallbackRank = PBRSheenConfiguration.AddFallbacks(defines, fallbacks, fallbackRank);
    if (defines.ENVIRONMENTBRDF) {
      fallbacks.addFallback(fallbackRank++, "ENVIRONMENTBRDF");
    }
    if (defines.TANGENT) {
      fallbacks.addFallback(fallbackRank++, "TANGENT");
    }
    if (defines.BUMP) {
      fallbacks.addFallback(fallbackRank++, "BUMP");
    }
    fallbackRank = MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights, fallbackRank++);
    if (defines.SPECULARTERM) {
      fallbacks.addFallback(fallbackRank++, "SPECULARTERM");
    }
    if (defines.USESPHERICALFROMREFLECTIONMAP) {
      fallbacks.addFallback(fallbackRank++, "USESPHERICALFROMREFLECTIONMAP");
    }
    if (defines.USEIRRADIANCEMAP) {
      fallbacks.addFallback(fallbackRank++, "USEIRRADIANCEMAP");
    }
    if (defines.LIGHTMAP) {
      fallbacks.addFallback(fallbackRank++, "LIGHTMAP");
    }
    if (defines.NORMAL) {
      fallbacks.addFallback(fallbackRank++, "NORMAL");
    }
    if (defines.AMBIENT) {
      fallbacks.addFallback(fallbackRank++, "AMBIENT");
    }
    if (defines.EMISSIVE) {
      fallbacks.addFallback(fallbackRank++, "EMISSIVE");
    }
    if (defines.VERTEXCOLOR) {
      fallbacks.addFallback(fallbackRank++, "VERTEXCOLOR");
    }
    if (defines.MORPHTARGETS) {
      fallbacks.addFallback(fallbackRank++, "MORPHTARGETS");
    }
    if (defines.MULTIVIEW) {
      fallbacks.addFallback(0, "MULTIVIEW");
    }
    var attribs = [VertexBuffer.PositionKind];
    if (defines.NORMAL) {
      attribs.push(VertexBuffer.NormalKind);
    }
    if (defines.TANGENT) {
      attribs.push(VertexBuffer.TangentKind);
    }
    if (defines.UV1) {
      attribs.push(VertexBuffer.UVKind);
    }
    if (defines.UV2) {
      attribs.push(VertexBuffer.UV2Kind);
    }
    if (defines.VERTEXCOLOR) {
      attribs.push(VertexBuffer.ColorKind);
    }
    MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
    MaterialHelper.PrepareAttributesForInstances(attribs, defines);
    MaterialHelper.PrepareAttributesForMorphTargets(attribs, mesh, defines);
    var shaderName = "pbr";
    var uniforms = [
      "world",
      "view",
      "viewProjection",
      "vEyePosition",
      "vLightsType",
      "vAmbientColor",
      "vAlbedoColor",
      "vReflectivityColor",
      "vMetallicReflectanceFactors",
      "vEmissiveColor",
      "visibility",
      "vReflectionColor",
      "vFogInfos",
      "vFogColor",
      "pointSize",
      "vAlbedoInfos",
      "vAmbientInfos",
      "vOpacityInfos",
      "vReflectionInfos",
      "vReflectionPosition",
      "vReflectionSize",
      "vEmissiveInfos",
      "vReflectivityInfos",
      "vReflectionFilteringInfo",
      "vMetallicReflectanceInfos",
      "vMicroSurfaceSamplerInfos",
      "vBumpInfos",
      "vLightmapInfos",
      "mBones",
      "vClipPlane",
      "vClipPlane2",
      "vClipPlane3",
      "vClipPlane4",
      "vClipPlane5",
      "vClipPlane6",
      "albedoMatrix",
      "ambientMatrix",
      "opacityMatrix",
      "reflectionMatrix",
      "emissiveMatrix",
      "reflectivityMatrix",
      "normalMatrix",
      "microSurfaceSamplerMatrix",
      "bumpMatrix",
      "lightmapMatrix",
      "metallicReflectanceMatrix",
      "vLightingIntensity",
      "logarithmicDepthConstant",
      "vSphericalX",
      "vSphericalY",
      "vSphericalZ",
      "vSphericalXX_ZZ",
      "vSphericalYY_ZZ",
      "vSphericalZZ",
      "vSphericalXY",
      "vSphericalYZ",
      "vSphericalZX",
      "vSphericalL00",
      "vSphericalL1_1",
      "vSphericalL10",
      "vSphericalL11",
      "vSphericalL2_2",
      "vSphericalL2_1",
      "vSphericalL20",
      "vSphericalL21",
      "vSphericalL22",
      "vReflectionMicrosurfaceInfos",
      "vTangentSpaceParams",
      "boneTextureWidth",
      "vDebugMode"
    ];
    var samplers = [
      "albedoSampler",
      "reflectivitySampler",
      "ambientSampler",
      "emissiveSampler",
      "bumpSampler",
      "lightmapSampler",
      "opacitySampler",
      "reflectionSampler",
      "reflectionSamplerLow",
      "reflectionSamplerHigh",
      "irradianceSampler",
      "microSurfaceSampler",
      "environmentBrdfSampler",
      "boneSampler",
      "metallicReflectanceSampler"
    ];
    var uniformBuffers = ["Material", "Scene"];
    DetailMapConfiguration.AddUniforms(uniforms);
    DetailMapConfiguration.AddSamplers(samplers);
    PBRSubSurfaceConfiguration.AddUniforms(uniforms);
    PBRSubSurfaceConfiguration.AddSamplers(samplers);
    PBRClearCoatConfiguration.AddUniforms(uniforms);
    PBRClearCoatConfiguration.AddSamplers(samplers);
    PBRAnisotropicConfiguration.AddUniforms(uniforms);
    PBRAnisotropicConfiguration.AddSamplers(samplers);
    PBRSheenConfiguration.AddUniforms(uniforms);
    PBRSheenConfiguration.AddSamplers(samplers);
    PrePassConfiguration.AddUniforms(uniforms);
    PrePassConfiguration.AddSamplers(uniforms);
    if (ImageProcessingConfiguration) {
      ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);
      ImageProcessingConfiguration.PrepareSamplers(samplers, defines);
    }
    MaterialHelper.PrepareUniformsAndSamplersList({
      uniformsNames: uniforms,
      uniformBuffersNames: uniformBuffers,
      samplers,
      defines,
      maxSimultaneousLights: this._maxSimultaneousLights
    });
    var csnrOptions = {};
    if (this.customShaderNameResolve) {
      shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);
    }
    var join = defines.toString();
    return engine.createEffect(shaderName, {
      attributes: attribs,
      uniformsNames: uniforms,
      uniformBuffersNames: uniformBuffers,
      samplers,
      defines: join,
      fallbacks,
      onCompiled,
      onError,
      indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS },
      processFinalCode: csnrOptions.processFinalCode,
      multiTarget: defines.PREPASS
    }, engine);
  };
  PBRBaseMaterial2.prototype._prepareDefines = function(mesh, defines, useInstances, useClipPlane, useThinInstances) {
    if (useInstances === void 0) {
      useInstances = null;
    }
    if (useClipPlane === void 0) {
      useClipPlane = null;
    }
    if (useThinInstances === void 0) {
      useThinInstances = false;
    }
    var scene = this.getScene();
    var engine = scene.getEngine();
    MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);
    defines._needNormals = true;
    MaterialHelper.PrepareDefinesForMultiview(scene, defines);
    MaterialHelper.PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT);
    defines.METALLICWORKFLOW = this.isMetallicWorkflow();
    if (defines._areTexturesDirty) {
      defines._needUVs = false;
      if (scene.texturesEnabled) {
        if (scene.getEngine().getCaps().textureLOD) {
          defines.LODBASEDMICROSFURACE = true;
        }
        if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
          MaterialHelper.PrepareDefinesForMergedUV(this._albedoTexture, defines, "ALBEDO");
          defines.GAMMAALBEDO = this._albedoTexture.gammaSpace;
        } else {
          defines.ALBEDO = false;
        }
        if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
          MaterialHelper.PrepareDefinesForMergedUV(this._ambientTexture, defines, "AMBIENT");
          defines.AMBIENTINGRAYSCALE = this._useAmbientInGrayScale;
        } else {
          defines.AMBIENT = false;
        }
        if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
          MaterialHelper.PrepareDefinesForMergedUV(this._opacityTexture, defines, "OPACITY");
          defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;
        } else {
          defines.OPACITY = false;
        }
        var reflectionTexture = this._getReflectionTexture();
        if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
          defines.REFLECTION = true;
          defines.GAMMAREFLECTION = reflectionTexture.gammaSpace;
          defines.RGBDREFLECTION = reflectionTexture.isRGBD;
          defines.REFLECTIONMAP_OPPOSITEZ = this.getScene().useRightHandedSystem ? !reflectionTexture.invertZ : reflectionTexture.invertZ;
          defines.LODINREFLECTIONALPHA = reflectionTexture.lodLevelInAlpha;
          defines.LINEARSPECULARREFLECTION = reflectionTexture.linearSpecularLOD;
          if (this.realTimeFiltering && this.realTimeFilteringQuality > 0) {
            defines.NUM_SAMPLES = "" + this.realTimeFilteringQuality;
            if (engine.webGLVersion > 1) {
              defines.NUM_SAMPLES = defines.NUM_SAMPLES + "u";
            }
            defines.REALTIME_FILTERING = true;
          } else {
            defines.REALTIME_FILTERING = false;
          }
          if (reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE) {
            defines.INVERTCUBICMAP = true;
          }
          defines.REFLECTIONMAP_3D = reflectionTexture.isCube;
          defines.REFLECTIONMAP_CUBIC = false;
          defines.REFLECTIONMAP_EXPLICIT = false;
          defines.REFLECTIONMAP_PLANAR = false;
          defines.REFLECTIONMAP_PROJECTION = false;
          defines.REFLECTIONMAP_SKYBOX = false;
          defines.REFLECTIONMAP_SPHERICAL = false;
          defines.REFLECTIONMAP_EQUIRECTANGULAR = false;
          defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
          defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
          switch (reflectionTexture.coordinatesMode) {
            case Texture.EXPLICIT_MODE:
              defines.REFLECTIONMAP_EXPLICIT = true;
              break;
            case Texture.PLANAR_MODE:
              defines.REFLECTIONMAP_PLANAR = true;
              break;
            case Texture.PROJECTION_MODE:
              defines.REFLECTIONMAP_PROJECTION = true;
              break;
            case Texture.SKYBOX_MODE:
              defines.REFLECTIONMAP_SKYBOX = true;
              break;
            case Texture.SPHERICAL_MODE:
              defines.REFLECTIONMAP_SPHERICAL = true;
              break;
            case Texture.EQUIRECTANGULAR_MODE:
              defines.REFLECTIONMAP_EQUIRECTANGULAR = true;
              break;
            case Texture.FIXED_EQUIRECTANGULAR_MODE:
              defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = true;
              break;
            case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:
              defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = true;
              break;
            case Texture.CUBIC_MODE:
            case Texture.INVCUBIC_MODE:
            default:
              defines.REFLECTIONMAP_CUBIC = true;
              defines.USE_LOCAL_REFLECTIONMAP_CUBIC = reflectionTexture.boundingBoxSize ? true : false;
              break;
          }
          if (reflectionTexture.coordinatesMode !== Texture.SKYBOX_MODE) {
            if (reflectionTexture.irradianceTexture) {
              defines.USEIRRADIANCEMAP = true;
              defines.USESPHERICALFROMREFLECTIONMAP = false;
            } else if (reflectionTexture.isCube) {
              defines.USESPHERICALFROMREFLECTIONMAP = true;
              defines.USEIRRADIANCEMAP = false;
              if (this._forceIrradianceInFragment || this.realTimeFiltering || scene.getEngine().getCaps().maxVaryingVectors <= 8) {
                defines.USESPHERICALINVERTEX = false;
              } else {
                defines.USESPHERICALINVERTEX = true;
              }
            }
          }
        } else {
          defines.REFLECTION = false;
          defines.REFLECTIONMAP_3D = false;
          defines.REFLECTIONMAP_SPHERICAL = false;
          defines.REFLECTIONMAP_PLANAR = false;
          defines.REFLECTIONMAP_CUBIC = false;
          defines.USE_LOCAL_REFLECTIONMAP_CUBIC = false;
          defines.REFLECTIONMAP_PROJECTION = false;
          defines.REFLECTIONMAP_SKYBOX = false;
          defines.REFLECTIONMAP_EXPLICIT = false;
          defines.REFLECTIONMAP_EQUIRECTANGULAR = false;
          defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
          defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
          defines.INVERTCUBICMAP = false;
          defines.USESPHERICALFROMREFLECTIONMAP = false;
          defines.USEIRRADIANCEMAP = false;
          defines.USESPHERICALINVERTEX = false;
          defines.REFLECTIONMAP_OPPOSITEZ = false;
          defines.LODINREFLECTIONALPHA = false;
          defines.GAMMAREFLECTION = false;
          defines.RGBDREFLECTION = false;
          defines.LINEARSPECULARREFLECTION = false;
        }
        if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
          MaterialHelper.PrepareDefinesForMergedUV(this._lightmapTexture, defines, "LIGHTMAP");
          defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;
          defines.GAMMALIGHTMAP = this._lightmapTexture.gammaSpace;
          defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;
        } else {
          defines.LIGHTMAP = false;
        }
        if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
          MaterialHelper.PrepareDefinesForMergedUV(this._emissiveTexture, defines, "EMISSIVE");
        } else {
          defines.EMISSIVE = false;
        }
        if (MaterialFlags.SpecularTextureEnabled) {
          if (this._metallicTexture) {
            MaterialHelper.PrepareDefinesForMergedUV(this._metallicTexture, defines, "REFLECTIVITY");
            defines.ROUGHNESSSTOREINMETALMAPALPHA = this._useRoughnessFromMetallicTextureAlpha;
            defines.ROUGHNESSSTOREINMETALMAPGREEN = !this._useRoughnessFromMetallicTextureAlpha && this._useRoughnessFromMetallicTextureGreen;
            defines.METALLNESSSTOREINMETALMAPBLUE = this._useMetallnessFromMetallicTextureBlue;
            defines.AOSTOREINMETALMAPRED = this._useAmbientOcclusionFromMetallicTextureRed;
          } else if (this._reflectivityTexture) {
            MaterialHelper.PrepareDefinesForMergedUV(this._reflectivityTexture, defines, "REFLECTIVITY");
            defines.MICROSURFACEFROMREFLECTIVITYMAP = this._useMicroSurfaceFromReflectivityMapAlpha;
            defines.MICROSURFACEAUTOMATIC = this._useAutoMicroSurfaceFromReflectivityMap;
          } else {
            defines.REFLECTIVITY = false;
          }
          if (this._metallicReflectanceTexture) {
            MaterialHelper.PrepareDefinesForMergedUV(this._metallicReflectanceTexture, defines, "METALLIC_REFLECTANCE");
          } else {
            defines.METALLIC_REFLECTANCE = false;
          }
          if (this._microSurfaceTexture) {
            MaterialHelper.PrepareDefinesForMergedUV(this._microSurfaceTexture, defines, "MICROSURFACEMAP");
          } else {
            defines.MICROSURFACEMAP = false;
          }
        } else {
          defines.REFLECTIVITY = false;
          defines.MICROSURFACEMAP = false;
        }
        if (scene.getEngine().getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
          MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture, defines, "BUMP");
          if (this._useParallax && this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
            defines.PARALLAX = true;
            defines.PARALLAXOCCLUSION = !!this._useParallaxOcclusion;
          } else {
            defines.PARALLAX = false;
          }
          defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;
        } else {
          defines.BUMP = false;
        }
        if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {
          defines.ENVIRONMENTBRDF = true;
          defines.ENVIRONMENTBRDF_RGBD = this._environmentBRDFTexture.isRGBD;
        } else {
          defines.ENVIRONMENTBRDF = false;
          defines.ENVIRONMENTBRDF_RGBD = false;
        }
        if (this._shouldUseAlphaFromAlbedoTexture()) {
          defines.ALPHAFROMALBEDO = true;
        } else {
          defines.ALPHAFROMALBEDO = false;
        }
      }
      defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;
      if (this._lightFalloff === PBRBaseMaterial2.LIGHTFALLOFF_STANDARD) {
        defines.USEPHYSICALLIGHTFALLOFF = false;
        defines.USEGLTFLIGHTFALLOFF = false;
      } else if (this._lightFalloff === PBRBaseMaterial2.LIGHTFALLOFF_GLTF) {
        defines.USEPHYSICALLIGHTFALLOFF = false;
        defines.USEGLTFLIGHTFALLOFF = true;
      } else {
        defines.USEPHYSICALLIGHTFALLOFF = true;
        defines.USEGLTFLIGHTFALLOFF = false;
      }
      defines.RADIANCEOVERALPHA = this._useRadianceOverAlpha;
      if (!this.backFaceCulling && this._twoSidedLighting) {
        defines.TWOSIDEDLIGHTING = true;
      } else {
        defines.TWOSIDEDLIGHTING = false;
      }
      defines.SPECULARAA = scene.getEngine().getCaps().standardDerivatives && this._enableSpecularAntiAliasing;
    }
    if (defines._areTexturesDirty || defines._areMiscDirty) {
      defines.ALPHATESTVALUE = "" + this._alphaCutOff + (this._alphaCutOff % 1 === 0 ? "." : "");
      defines.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8;
      defines.ALPHABLEND = this.needAlphaBlendingForMesh(mesh);
      defines.ALPHAFRESNEL = this._useAlphaFresnel || this._useLinearAlphaFresnel;
      defines.LINEARALPHAFRESNEL = this._useLinearAlphaFresnel;
    }
    if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
      this._imageProcessingConfiguration.prepareDefines(defines);
    }
    defines.FORCENORMALFORWARD = this._forceNormalForward;
    defines.RADIANCEOCCLUSION = this._useRadianceOcclusion;
    defines.HORIZONOCCLUSION = this._useHorizonOcclusion;
    if (defines._areMiscDirty) {
      MaterialHelper.PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh) || this._forceAlphaTest, defines);
      defines.UNLIT = this._unlit || (this.pointsCloud || this.wireframe) && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind);
      defines.DEBUGMODE = this._debugMode;
    }
    this.detailMap.prepareDefines(defines, scene);
    this.subSurface.prepareDefines(defines, scene);
    this.clearCoat.prepareDefines(defines, scene);
    this.anisotropy.prepareDefines(defines, mesh, scene);
    this.brdf.prepareDefines(defines);
    this.sheen.prepareDefines(defines, scene);
    MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, defines, useInstances ? true : false, useClipPlane, useThinInstances);
    MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true, true, this._transparencyMode !== PBRBaseMaterial2.PBRMATERIAL_OPAQUE);
  };
  PBRBaseMaterial2.prototype.forceCompilation = function(mesh, onCompiled, options) {
    var _this = this;
    var localOptions = __assign({ clipPlane: false, useInstances: false }, options);
    var defines = new PBRMaterialDefines();
    var effect = this._prepareEffect(mesh, defines, void 0, void 0, localOptions.useInstances, localOptions.clipPlane, mesh.hasThinInstances);
    if (this._onEffectCreatedObservable) {
      onCreatedEffectParameters2.effect = effect;
      onCreatedEffectParameters2.subMesh = null;
      this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters2);
    }
    if (effect.isReady()) {
      if (onCompiled) {
        onCompiled(this);
      }
    } else {
      effect.onCompileObservable.add(function() {
        if (onCompiled) {
          onCompiled(_this);
        }
      });
    }
  };
  PBRBaseMaterial2.prototype.buildUniformLayout = function() {
    var ubo = this._uniformBuffer;
    ubo.addUniform("vAlbedoInfos", 2);
    ubo.addUniform("vAmbientInfos", 4);
    ubo.addUniform("vOpacityInfos", 2);
    ubo.addUniform("vEmissiveInfos", 2);
    ubo.addUniform("vLightmapInfos", 2);
    ubo.addUniform("vReflectivityInfos", 3);
    ubo.addUniform("vMicroSurfaceSamplerInfos", 2);
    ubo.addUniform("vReflectionInfos", 2);
    ubo.addUniform("vReflectionFilteringInfo", 2);
    ubo.addUniform("vReflectionPosition", 3);
    ubo.addUniform("vReflectionSize", 3);
    ubo.addUniform("vBumpInfos", 3);
    ubo.addUniform("albedoMatrix", 16);
    ubo.addUniform("ambientMatrix", 16);
    ubo.addUniform("opacityMatrix", 16);
    ubo.addUniform("emissiveMatrix", 16);
    ubo.addUniform("lightmapMatrix", 16);
    ubo.addUniform("reflectivityMatrix", 16);
    ubo.addUniform("microSurfaceSamplerMatrix", 16);
    ubo.addUniform("bumpMatrix", 16);
    ubo.addUniform("vTangentSpaceParams", 2);
    ubo.addUniform("reflectionMatrix", 16);
    ubo.addUniform("vReflectionColor", 3);
    ubo.addUniform("vAlbedoColor", 4);
    ubo.addUniform("vLightingIntensity", 4);
    ubo.addUniform("vReflectionMicrosurfaceInfos", 3);
    ubo.addUniform("pointSize", 1);
    ubo.addUniform("vReflectivityColor", 4);
    ubo.addUniform("vEmissiveColor", 3);
    ubo.addUniform("visibility", 1);
    ubo.addUniform("vMetallicReflectanceFactors", 4);
    ubo.addUniform("vMetallicReflectanceInfos", 2);
    ubo.addUniform("metallicReflectanceMatrix", 16);
    PBRClearCoatConfiguration.PrepareUniformBuffer(ubo);
    PBRAnisotropicConfiguration.PrepareUniformBuffer(ubo);
    PBRSheenConfiguration.PrepareUniformBuffer(ubo);
    PBRSubSurfaceConfiguration.PrepareUniformBuffer(ubo);
    DetailMapConfiguration.PrepareUniformBuffer(ubo);
    ubo.create();
  };
  PBRBaseMaterial2.prototype.unbind = function() {
    if (this._activeEffect) {
      var needFlag = false;
      if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
        this._activeEffect.setTexture("reflection2DSampler", null);
        needFlag = true;
      }
      if (this.subSurface.unbind(this._activeEffect)) {
        needFlag = true;
      }
      if (needFlag) {
        this._markAllSubMeshesAsTexturesDirty();
      }
    }
    _super.prototype.unbind.call(this);
  };
  PBRBaseMaterial2.prototype.bindForSubMesh = function(world, mesh, subMesh) {
    var scene = this.getScene();
    var defines = subMesh._materialDefines;
    if (!defines) {
      return;
    }
    var effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    if (!defines.INSTANCES || defines.THIN_INSTANCES) {
      this.bindOnlyWorldMatrix(world);
    }
    this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);
    if (defines.OBJECTSPACE_NORMALMAP) {
      world.toNormalMatrix(this._normalMatrix);
      this.bindOnlyNormalMatrix(this._normalMatrix);
    }
    var mustRebind = this._mustRebind(scene, effect, mesh.visibility);
    MaterialHelper.BindBonesParameters(mesh, this._activeEffect, this.prePassConfiguration);
    var reflectionTexture = null;
    var ubo = this._uniformBuffer;
    if (mustRebind) {
      var engine = scene.getEngine();
      ubo.bindToEffect(effect, "Material");
      this.bindViewProjection(effect);
      reflectionTexture = this._getReflectionTexture();
      if (!ubo.useUbo || !this.isFrozen || !ubo.isSync) {
        if (scene.texturesEnabled) {
          if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
            ubo.updateFloat2("vAlbedoInfos", this._albedoTexture.coordinatesIndex, this._albedoTexture.level);
            MaterialHelper.BindTextureMatrix(this._albedoTexture, ubo, "albedo");
          }
          if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
            ubo.updateFloat4("vAmbientInfos", this._ambientTexture.coordinatesIndex, this._ambientTexture.level, this._ambientTextureStrength, this._ambientTextureImpactOnAnalyticalLights);
            MaterialHelper.BindTextureMatrix(this._ambientTexture, ubo, "ambient");
          }
          if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
            ubo.updateFloat2("vOpacityInfos", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);
            MaterialHelper.BindTextureMatrix(this._opacityTexture, ubo, "opacity");
          }
          if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
            ubo.updateMatrix("reflectionMatrix", reflectionTexture.getReflectionTextureMatrix());
            ubo.updateFloat2("vReflectionInfos", reflectionTexture.level, 0);
            if (reflectionTexture.boundingBoxSize) {
              var cubeTexture = reflectionTexture;
              ubo.updateVector3("vReflectionPosition", cubeTexture.boundingBoxPosition);
              ubo.updateVector3("vReflectionSize", cubeTexture.boundingBoxSize);
            }
            if (this.realTimeFiltering) {
              var width = reflectionTexture.getSize().width;
              ubo.updateFloat2("vReflectionFilteringInfo", width, Scalar.Log2(width));
            }
            if (!defines.USEIRRADIANCEMAP) {
              var polynomials = reflectionTexture.sphericalPolynomial;
              if (defines.USESPHERICALFROMREFLECTIONMAP && polynomials) {
                if (defines.SPHERICAL_HARMONICS) {
                  var preScaledHarmonics = polynomials.preScaledHarmonics;
                  this._activeEffect.setVector3("vSphericalL00", preScaledHarmonics.l00);
                  this._activeEffect.setVector3("vSphericalL1_1", preScaledHarmonics.l1_1);
                  this._activeEffect.setVector3("vSphericalL10", preScaledHarmonics.l10);
                  this._activeEffect.setVector3("vSphericalL11", preScaledHarmonics.l11);
                  this._activeEffect.setVector3("vSphericalL2_2", preScaledHarmonics.l2_2);
                  this._activeEffect.setVector3("vSphericalL2_1", preScaledHarmonics.l2_1);
                  this._activeEffect.setVector3("vSphericalL20", preScaledHarmonics.l20);
                  this._activeEffect.setVector3("vSphericalL21", preScaledHarmonics.l21);
                  this._activeEffect.setVector3("vSphericalL22", preScaledHarmonics.l22);
                } else {
                  this._activeEffect.setFloat3("vSphericalX", polynomials.x.x, polynomials.x.y, polynomials.x.z);
                  this._activeEffect.setFloat3("vSphericalY", polynomials.y.x, polynomials.y.y, polynomials.y.z);
                  this._activeEffect.setFloat3("vSphericalZ", polynomials.z.x, polynomials.z.y, polynomials.z.z);
                  this._activeEffect.setFloat3("vSphericalXX_ZZ", polynomials.xx.x - polynomials.zz.x, polynomials.xx.y - polynomials.zz.y, polynomials.xx.z - polynomials.zz.z);
                  this._activeEffect.setFloat3("vSphericalYY_ZZ", polynomials.yy.x - polynomials.zz.x, polynomials.yy.y - polynomials.zz.y, polynomials.yy.z - polynomials.zz.z);
                  this._activeEffect.setFloat3("vSphericalZZ", polynomials.zz.x, polynomials.zz.y, polynomials.zz.z);
                  this._activeEffect.setFloat3("vSphericalXY", polynomials.xy.x, polynomials.xy.y, polynomials.xy.z);
                  this._activeEffect.setFloat3("vSphericalYZ", polynomials.yz.x, polynomials.yz.y, polynomials.yz.z);
                  this._activeEffect.setFloat3("vSphericalZX", polynomials.zx.x, polynomials.zx.y, polynomials.zx.z);
                }
              }
            }
            ubo.updateFloat3("vReflectionMicrosurfaceInfos", reflectionTexture.getSize().width, reflectionTexture.lodGenerationScale, reflectionTexture.lodGenerationOffset);
          }
          if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
            ubo.updateFloat2("vEmissiveInfos", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);
            MaterialHelper.BindTextureMatrix(this._emissiveTexture, ubo, "emissive");
          }
          if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
            ubo.updateFloat2("vLightmapInfos", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);
            MaterialHelper.BindTextureMatrix(this._lightmapTexture, ubo, "lightmap");
          }
          if (MaterialFlags.SpecularTextureEnabled) {
            if (this._metallicTexture) {
              ubo.updateFloat3("vReflectivityInfos", this._metallicTexture.coordinatesIndex, this._metallicTexture.level, this._ambientTextureStrength);
              MaterialHelper.BindTextureMatrix(this._metallicTexture, ubo, "reflectivity");
            } else if (this._reflectivityTexture) {
              ubo.updateFloat3("vReflectivityInfos", this._reflectivityTexture.coordinatesIndex, this._reflectivityTexture.level, 1);
              MaterialHelper.BindTextureMatrix(this._reflectivityTexture, ubo, "reflectivity");
            }
            if (this._metallicReflectanceTexture) {
              ubo.updateFloat2("vMetallicReflectanceInfos", this._metallicReflectanceTexture.coordinatesIndex, this._metallicReflectanceTexture.level);
              MaterialHelper.BindTextureMatrix(this._metallicReflectanceTexture, ubo, "metallicReflectance");
            }
            if (this._microSurfaceTexture) {
              ubo.updateFloat2("vMicroSurfaceSamplerInfos", this._microSurfaceTexture.coordinatesIndex, this._microSurfaceTexture.level);
              MaterialHelper.BindTextureMatrix(this._microSurfaceTexture, ubo, "microSurfaceSampler");
            }
          }
          if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
            ubo.updateFloat3("vBumpInfos", this._bumpTexture.coordinatesIndex, this._bumpTexture.level, this._parallaxScaleBias);
            MaterialHelper.BindTextureMatrix(this._bumpTexture, ubo, "bump");
            if (scene._mirroredCameraPosition) {
              ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? 1 : -1, this._invertNormalMapY ? 1 : -1);
            } else {
              ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? -1 : 1, this._invertNormalMapY ? -1 : 1);
            }
          }
        }
        if (this.pointsCloud) {
          ubo.updateFloat("pointSize", this.pointSize);
        }
        if (defines.METALLICWORKFLOW) {
          TmpColors.Color3[0].r = this._metallic === void 0 || this._metallic === null ? 1 : this._metallic;
          TmpColors.Color3[0].g = this._roughness === void 0 || this._roughness === null ? 1 : this._roughness;
          ubo.updateColor4("vReflectivityColor", TmpColors.Color3[0], 1);
          var ior = this.subSurface.indexOfRefraction;
          var outside_ior = 1;
          var f0 = Math.pow((ior - outside_ior) / (ior + outside_ior), 2);
          this._metallicReflectanceColor.scaleToRef(f0 * this._metallicF0Factor, TmpColors.Color3[0]);
          var metallicF90 = this._metallicF0Factor;
          ubo.updateColor4("vMetallicReflectanceFactors", TmpColors.Color3[0], metallicF90);
        } else {
          ubo.updateColor4("vReflectivityColor", this._reflectivityColor, this._microSurface);
        }
        ubo.updateColor3("vEmissiveColor", MaterialFlags.EmissiveTextureEnabled ? this._emissiveColor : Color3.BlackReadOnly);
        ubo.updateColor3("vReflectionColor", this._reflectionColor);
        if (!defines.SS_REFRACTION && this.subSurface.linkRefractionWithTransparency) {
          ubo.updateColor4("vAlbedoColor", this._albedoColor, 1);
        } else {
          ubo.updateColor4("vAlbedoColor", this._albedoColor, this.alpha);
        }
        this._lightingInfos.x = this._directIntensity;
        this._lightingInfos.y = this._emissiveIntensity;
        this._lightingInfos.z = this._environmentIntensity * scene.environmentIntensity;
        this._lightingInfos.w = this._specularIntensity;
        ubo.updateVector4("vLightingIntensity", this._lightingInfos);
      }
      ubo.updateFloat("visibility", mesh.visibility);
      if (scene.texturesEnabled) {
        if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
          ubo.setTexture("albedoSampler", this._albedoTexture);
        }
        if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
          ubo.setTexture("ambientSampler", this._ambientTexture);
        }
        if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
          ubo.setTexture("opacitySampler", this._opacityTexture);
        }
        if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
          if (defines.LODBASEDMICROSFURACE) {
            ubo.setTexture("reflectionSampler", reflectionTexture);
          } else {
            ubo.setTexture("reflectionSampler", reflectionTexture._lodTextureMid || reflectionTexture);
            ubo.setTexture("reflectionSamplerLow", reflectionTexture._lodTextureLow || reflectionTexture);
            ubo.setTexture("reflectionSamplerHigh", reflectionTexture._lodTextureHigh || reflectionTexture);
          }
          if (defines.USEIRRADIANCEMAP) {
            ubo.setTexture("irradianceSampler", reflectionTexture.irradianceTexture);
          }
        }
        if (defines.ENVIRONMENTBRDF) {
          ubo.setTexture("environmentBrdfSampler", this._environmentBRDFTexture);
        }
        if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
          ubo.setTexture("emissiveSampler", this._emissiveTexture);
        }
        if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
          ubo.setTexture("lightmapSampler", this._lightmapTexture);
        }
        if (MaterialFlags.SpecularTextureEnabled) {
          if (this._metallicTexture) {
            ubo.setTexture("reflectivitySampler", this._metallicTexture);
          } else if (this._reflectivityTexture) {
            ubo.setTexture("reflectivitySampler", this._reflectivityTexture);
          }
          if (this._metallicReflectanceTexture) {
            ubo.setTexture("metallicReflectanceSampler", this._metallicReflectanceTexture);
          }
          if (this._microSurfaceTexture) {
            ubo.setTexture("microSurfaceSampler", this._microSurfaceTexture);
          }
        }
        if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
          ubo.setTexture("bumpSampler", this._bumpTexture);
        }
      }
      this.detailMap.bindForSubMesh(ubo, scene, this.isFrozen);
      this.subSurface.bindForSubMesh(ubo, scene, engine, this.isFrozen, defines.LODBASEDMICROSFURACE, this.realTimeFiltering);
      this.clearCoat.bindForSubMesh(ubo, scene, engine, this._disableBumpMap, this.isFrozen, this._invertNormalMapX, this._invertNormalMapY, subMesh);
      this.anisotropy.bindForSubMesh(ubo, scene, this.isFrozen);
      this.sheen.bindForSubMesh(ubo, scene, this.isFrozen, subMesh);
      MaterialHelper.BindClipPlane(this._activeEffect, scene);
      scene.ambientColor.multiplyToRef(this._ambientColor, this._globalAmbientColor);
      var eyePosition = scene._forcedViewPosition ? scene._forcedViewPosition : scene._mirroredCameraPosition ? scene._mirroredCameraPosition : scene.activeCamera.globalPosition;
      var invertNormal = scene.useRightHandedSystem === (scene._mirroredCameraPosition != null);
      effect.setFloat4("vEyePosition", eyePosition.x, eyePosition.y, eyePosition.z, invertNormal ? -1 : 1);
      effect.setColor3("vAmbientColor", this._globalAmbientColor);
      effect.setFloat2("vDebugMode", this.debugLimit, this.debugFactor);
    }
    if (mustRebind || !this.isFrozen) {
      if (scene.lightsEnabled && !this._disableLighting) {
        MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights, this._rebuildInParallel);
      }
      if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE || reflectionTexture) {
        this.bindView(effect);
      }
      MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect, true);
      if (defines.NUM_MORPH_INFLUENCERS) {
        MaterialHelper.BindMorphTargetParameters(mesh, this._activeEffect);
      }
      this._imageProcessingConfiguration.bind(this._activeEffect);
      MaterialHelper.BindLogDepth(defines, this._activeEffect, scene);
    }
    ubo.update();
    this._afterBind(mesh, this._activeEffect);
  };
  PBRBaseMaterial2.prototype.getAnimatables = function() {
    var results = [];
    if (this._albedoTexture && this._albedoTexture.animations && this._albedoTexture.animations.length > 0) {
      results.push(this._albedoTexture);
    }
    if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {
      results.push(this._ambientTexture);
    }
    if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {
      results.push(this._opacityTexture);
    }
    if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {
      results.push(this._reflectionTexture);
    }
    if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {
      results.push(this._emissiveTexture);
    }
    if (this._metallicTexture && this._metallicTexture.animations && this._metallicTexture.animations.length > 0) {
      results.push(this._metallicTexture);
    } else if (this._reflectivityTexture && this._reflectivityTexture.animations && this._reflectivityTexture.animations.length > 0) {
      results.push(this._reflectivityTexture);
    }
    if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {
      results.push(this._bumpTexture);
    }
    if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {
      results.push(this._lightmapTexture);
    }
    this.detailMap.getAnimatables(results);
    this.subSurface.getAnimatables(results);
    this.clearCoat.getAnimatables(results);
    this.sheen.getAnimatables(results);
    this.anisotropy.getAnimatables(results);
    return results;
  };
  PBRBaseMaterial2.prototype._getReflectionTexture = function() {
    if (this._reflectionTexture) {
      return this._reflectionTexture;
    }
    return this.getScene().environmentTexture;
  };
  PBRBaseMaterial2.prototype.getActiveTextures = function() {
    var activeTextures = _super.prototype.getActiveTextures.call(this);
    if (this._albedoTexture) {
      activeTextures.push(this._albedoTexture);
    }
    if (this._ambientTexture) {
      activeTextures.push(this._ambientTexture);
    }
    if (this._opacityTexture) {
      activeTextures.push(this._opacityTexture);
    }
    if (this._reflectionTexture) {
      activeTextures.push(this._reflectionTexture);
    }
    if (this._emissiveTexture) {
      activeTextures.push(this._emissiveTexture);
    }
    if (this._reflectivityTexture) {
      activeTextures.push(this._reflectivityTexture);
    }
    if (this._metallicTexture) {
      activeTextures.push(this._metallicTexture);
    }
    if (this._metallicReflectanceTexture) {
      activeTextures.push(this._metallicReflectanceTexture);
    }
    if (this._microSurfaceTexture) {
      activeTextures.push(this._microSurfaceTexture);
    }
    if (this._bumpTexture) {
      activeTextures.push(this._bumpTexture);
    }
    if (this._lightmapTexture) {
      activeTextures.push(this._lightmapTexture);
    }
    this.detailMap.getActiveTextures(activeTextures);
    this.subSurface.getActiveTextures(activeTextures);
    this.clearCoat.getActiveTextures(activeTextures);
    this.sheen.getActiveTextures(activeTextures);
    this.anisotropy.getActiveTextures(activeTextures);
    return activeTextures;
  };
  PBRBaseMaterial2.prototype.hasTexture = function(texture) {
    if (_super.prototype.hasTexture.call(this, texture)) {
      return true;
    }
    if (this._albedoTexture === texture) {
      return true;
    }
    if (this._ambientTexture === texture) {
      return true;
    }
    if (this._opacityTexture === texture) {
      return true;
    }
    if (this._reflectionTexture === texture) {
      return true;
    }
    if (this._reflectivityTexture === texture) {
      return true;
    }
    if (this._metallicTexture === texture) {
      return true;
    }
    if (this._metallicReflectanceTexture === texture) {
      return true;
    }
    if (this._microSurfaceTexture === texture) {
      return true;
    }
    if (this._bumpTexture === texture) {
      return true;
    }
    if (this._lightmapTexture === texture) {
      return true;
    }
    return this.detailMap.hasTexture(texture) || this.subSurface.hasTexture(texture) || this.clearCoat.hasTexture(texture) || this.sheen.hasTexture(texture) || this.anisotropy.hasTexture(texture);
  };
  PBRBaseMaterial2.prototype.setPrePassRenderer = function(prePassRenderer) {
    if (this.subSurface.isScatteringEnabled) {
      var subSurfaceConfiguration = this.getScene().enableSubSurfaceForPrePass();
      if (subSurfaceConfiguration) {
        subSurfaceConfiguration.enabled = true;
      }
      return true;
    }
    return false;
  };
  PBRBaseMaterial2.prototype.dispose = function(forceDisposeEffect, forceDisposeTextures) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    if (forceDisposeTextures) {
      if (this._environmentBRDFTexture && this.getScene().environmentBRDFTexture !== this._environmentBRDFTexture) {
        this._environmentBRDFTexture.dispose();
      }
      (_a = this._albedoTexture) === null || _a === void 0 ? void 0 : _a.dispose();
      (_b = this._ambientTexture) === null || _b === void 0 ? void 0 : _b.dispose();
      (_c = this._opacityTexture) === null || _c === void 0 ? void 0 : _c.dispose();
      (_d = this._reflectionTexture) === null || _d === void 0 ? void 0 : _d.dispose();
      (_e = this._emissiveTexture) === null || _e === void 0 ? void 0 : _e.dispose();
      (_f = this._metallicTexture) === null || _f === void 0 ? void 0 : _f.dispose();
      (_g = this._reflectivityTexture) === null || _g === void 0 ? void 0 : _g.dispose();
      (_h = this._bumpTexture) === null || _h === void 0 ? void 0 : _h.dispose();
      (_j = this._lightmapTexture) === null || _j === void 0 ? void 0 : _j.dispose();
      (_k = this._metallicReflectanceTexture) === null || _k === void 0 ? void 0 : _k.dispose();
      (_l = this._microSurfaceTexture) === null || _l === void 0 ? void 0 : _l.dispose();
    }
    this.detailMap.dispose(forceDisposeTextures);
    this.subSurface.dispose(forceDisposeTextures);
    this.clearCoat.dispose(forceDisposeTextures);
    this.sheen.dispose(forceDisposeTextures);
    this.anisotropy.dispose(forceDisposeTextures);
    this._renderTargets.dispose();
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures);
  };
  PBRBaseMaterial2.PBRMATERIAL_OPAQUE = Material.MATERIAL_OPAQUE;
  PBRBaseMaterial2.PBRMATERIAL_ALPHATEST = Material.MATERIAL_ALPHATEST;
  PBRBaseMaterial2.PBRMATERIAL_ALPHABLEND = Material.MATERIAL_ALPHABLEND;
  PBRBaseMaterial2.PBRMATERIAL_ALPHATESTANDBLEND = Material.MATERIAL_ALPHATESTANDBLEND;
  PBRBaseMaterial2.DEFAULT_AO_ON_ANALYTICAL_LIGHTS = 0;
  PBRBaseMaterial2.LIGHTFALLOFF_PHYSICAL = 0;
  PBRBaseMaterial2.LIGHTFALLOFF_GLTF = 1;
  PBRBaseMaterial2.LIGHTFALLOFF_STANDARD = 2;
  __decorate([
    serializeAsImageProcessingConfiguration()
  ], PBRBaseMaterial2.prototype, "_imageProcessingConfiguration", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsMiscDirty")
  ], PBRBaseMaterial2.prototype, "debugMode", void 0);
  __decorate([
    serialize()
  ], PBRBaseMaterial2.prototype, "useLogarithmicDepth", null);
  return PBRBaseMaterial2;
}(PushMaterial);

// node_modules/@babylonjs/core/Materials/PBR/pbrMaterial.js
var PBRMaterial = function(_super) {
  __extends(PBRMaterial2, _super);
  function PBRMaterial2(name42, scene) {
    var _this = _super.call(this, name42, scene) || this;
    _this.directIntensity = 1;
    _this.emissiveIntensity = 1;
    _this.environmentIntensity = 1;
    _this.specularIntensity = 1;
    _this.disableBumpMap = false;
    _this.ambientTextureStrength = 1;
    _this.ambientTextureImpactOnAnalyticalLights = PBRMaterial2.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;
    _this.metallicF0Factor = 1;
    _this.metallicReflectanceColor = Color3.White();
    _this.ambientColor = new Color3(0, 0, 0);
    _this.albedoColor = new Color3(1, 1, 1);
    _this.reflectivityColor = new Color3(1, 1, 1);
    _this.reflectionColor = new Color3(1, 1, 1);
    _this.emissiveColor = new Color3(0, 0, 0);
    _this.microSurface = 1;
    _this.useLightmapAsShadowmap = false;
    _this.useAlphaFromAlbedoTexture = false;
    _this.forceAlphaTest = false;
    _this.alphaCutOff = 0.4;
    _this.useSpecularOverAlpha = true;
    _this.useMicroSurfaceFromReflectivityMapAlpha = false;
    _this.useRoughnessFromMetallicTextureAlpha = true;
    _this.useRoughnessFromMetallicTextureGreen = false;
    _this.useMetallnessFromMetallicTextureBlue = false;
    _this.useAmbientOcclusionFromMetallicTextureRed = false;
    _this.useAmbientInGrayScale = false;
    _this.useAutoMicroSurfaceFromReflectivityMap = false;
    _this.useRadianceOverAlpha = true;
    _this.useObjectSpaceNormalMap = false;
    _this.useParallax = false;
    _this.useParallaxOcclusion = false;
    _this.parallaxScaleBias = 0.05;
    _this.disableLighting = false;
    _this.forceIrradianceInFragment = false;
    _this.maxSimultaneousLights = 4;
    _this.invertNormalMapX = false;
    _this.invertNormalMapY = false;
    _this.twoSidedLighting = false;
    _this.useAlphaFresnel = false;
    _this.useLinearAlphaFresnel = false;
    _this.environmentBRDFTexture = null;
    _this.forceNormalForward = false;
    _this.enableSpecularAntiAliasing = false;
    _this.useHorizonOcclusion = true;
    _this.useRadianceOcclusion = true;
    _this.unlit = false;
    _this._environmentBRDFTexture = BRDFTextureTools.GetEnvironmentBRDFTexture(scene);
    return _this;
  }
  Object.defineProperty(PBRMaterial2.prototype, "refractionTexture", {
    get: function() {
      return this.subSurface.refractionTexture;
    },
    set: function(value) {
      this.subSurface.refractionTexture = value;
      if (value) {
        this.subSurface.isRefractionEnabled = true;
      } else if (!this.subSurface.linkRefractionWithTransparency) {
        this.subSurface.isRefractionEnabled = false;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMaterial2.prototype, "indexOfRefraction", {
    get: function() {
      return this.subSurface.indexOfRefraction;
    },
    set: function(value) {
      this.subSurface.indexOfRefraction = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMaterial2.prototype, "invertRefractionY", {
    get: function() {
      return this.subSurface.invertRefractionY;
    },
    set: function(value) {
      this.subSurface.invertRefractionY = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMaterial2.prototype, "linkRefractionWithTransparency", {
    get: function() {
      return this.subSurface.linkRefractionWithTransparency;
    },
    set: function(value) {
      this.subSurface.linkRefractionWithTransparency = value;
      if (value) {
        this.subSurface.isRefractionEnabled = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMaterial2.prototype, "usePhysicalLightFalloff", {
    get: function() {
      return this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;
    },
    set: function(value) {
      if (value !== this.usePhysicalLightFalloff) {
        this._markAllSubMeshesAsTexturesDirty();
        if (value) {
          this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;
        } else {
          this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_STANDARD;
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMaterial2.prototype, "useGLTFLightFalloff", {
    get: function() {
      return this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_GLTF;
    },
    set: function(value) {
      if (value !== this.useGLTFLightFalloff) {
        this._markAllSubMeshesAsTexturesDirty();
        if (value) {
          this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_GLTF;
        } else {
          this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_STANDARD;
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMaterial2.prototype, "imageProcessingConfiguration", {
    get: function() {
      return this._imageProcessingConfiguration;
    },
    set: function(value) {
      this._attachImageProcessingConfiguration(value);
      this._markAllSubMeshesAsTexturesDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMaterial2.prototype, "cameraColorCurvesEnabled", {
    get: function() {
      return this.imageProcessingConfiguration.colorCurvesEnabled;
    },
    set: function(value) {
      this.imageProcessingConfiguration.colorCurvesEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMaterial2.prototype, "cameraColorGradingEnabled", {
    get: function() {
      return this.imageProcessingConfiguration.colorGradingEnabled;
    },
    set: function(value) {
      this.imageProcessingConfiguration.colorGradingEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMaterial2.prototype, "cameraToneMappingEnabled", {
    get: function() {
      return this._imageProcessingConfiguration.toneMappingEnabled;
    },
    set: function(value) {
      this._imageProcessingConfiguration.toneMappingEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMaterial2.prototype, "cameraExposure", {
    get: function() {
      return this._imageProcessingConfiguration.exposure;
    },
    set: function(value) {
      this._imageProcessingConfiguration.exposure = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMaterial2.prototype, "cameraContrast", {
    get: function() {
      return this._imageProcessingConfiguration.contrast;
    },
    set: function(value) {
      this._imageProcessingConfiguration.contrast = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMaterial2.prototype, "cameraColorGradingTexture", {
    get: function() {
      return this._imageProcessingConfiguration.colorGradingTexture;
    },
    set: function(value) {
      this._imageProcessingConfiguration.colorGradingTexture = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PBRMaterial2.prototype, "cameraColorCurves", {
    get: function() {
      return this._imageProcessingConfiguration.colorCurves;
    },
    set: function(value) {
      this._imageProcessingConfiguration.colorCurves = value;
    },
    enumerable: false,
    configurable: true
  });
  PBRMaterial2.prototype.getClassName = function() {
    return "PBRMaterial";
  };
  PBRMaterial2.prototype.clone = function(name42) {
    var _this = this;
    var clone = SerializationHelper.Clone(function() {
      return new PBRMaterial2(name42, _this.getScene());
    }, this);
    clone.id = name42;
    clone.name = name42;
    this.clearCoat.copyTo(clone.clearCoat);
    this.anisotropy.copyTo(clone.anisotropy);
    this.brdf.copyTo(clone.brdf);
    this.sheen.copyTo(clone.sheen);
    this.subSurface.copyTo(clone.subSurface);
    return clone;
  };
  PBRMaterial2.prototype.serialize = function() {
    var serializationObject = SerializationHelper.Serialize(this);
    serializationObject.customType = "BABYLON.PBRMaterial";
    serializationObject.clearCoat = this.clearCoat.serialize();
    serializationObject.anisotropy = this.anisotropy.serialize();
    serializationObject.brdf = this.brdf.serialize();
    serializationObject.sheen = this.sheen.serialize();
    serializationObject.subSurface = this.subSurface.serialize();
    return serializationObject;
  };
  PBRMaterial2.Parse = function(source, scene, rootUrl) {
    var material = SerializationHelper.Parse(function() {
      return new PBRMaterial2(source.name, scene);
    }, source, scene, rootUrl);
    if (source.clearCoat) {
      material.clearCoat.parse(source.clearCoat, scene, rootUrl);
    }
    if (source.anisotropy) {
      material.anisotropy.parse(source.anisotropy, scene, rootUrl);
    }
    if (source.brdf) {
      material.brdf.parse(source.brdf, scene, rootUrl);
    }
    if (source.sheen) {
      material.sheen.parse(source.sheen, scene, rootUrl);
    }
    if (source.subSurface) {
      material.subSurface.parse(source.subSurface, scene, rootUrl);
    }
    return material;
  };
  PBRMaterial2.PBRMATERIAL_OPAQUE = PBRBaseMaterial.PBRMATERIAL_OPAQUE;
  PBRMaterial2.PBRMATERIAL_ALPHATEST = PBRBaseMaterial.PBRMATERIAL_ALPHATEST;
  PBRMaterial2.PBRMATERIAL_ALPHABLEND = PBRBaseMaterial.PBRMATERIAL_ALPHABLEND;
  PBRMaterial2.PBRMATERIAL_ALPHATESTANDBLEND = PBRBaseMaterial.PBRMATERIAL_ALPHATESTANDBLEND;
  PBRMaterial2.DEFAULT_AO_ON_ANALYTICAL_LIGHTS = PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "directIntensity", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "emissiveIntensity", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "environmentIntensity", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "specularIntensity", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "disableBumpMap", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "albedoTexture", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "ambientTexture", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "ambientTextureStrength", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "ambientTextureImpactOnAnalyticalLights", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
  ], PBRMaterial2.prototype, "opacityTexture", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "reflectionTexture", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "emissiveTexture", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "reflectivityTexture", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "metallicTexture", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "metallic", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "roughness", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "metallicF0Factor", void 0);
  __decorate([
    serializeAsColor3(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "metallicReflectanceColor", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "metallicReflectanceTexture", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "microSurfaceTexture", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "bumpTexture", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty", null)
  ], PBRMaterial2.prototype, "lightmapTexture", void 0);
  __decorate([
    serializeAsColor3("ambient"),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "ambientColor", void 0);
  __decorate([
    serializeAsColor3("albedo"),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "albedoColor", void 0);
  __decorate([
    serializeAsColor3("reflectivity"),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "reflectivityColor", void 0);
  __decorate([
    serializeAsColor3("reflection"),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "reflectionColor", void 0);
  __decorate([
    serializeAsColor3("emissive"),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "emissiveColor", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "microSurface", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "useLightmapAsShadowmap", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
  ], PBRMaterial2.prototype, "useAlphaFromAlbedoTexture", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
  ], PBRMaterial2.prototype, "forceAlphaTest", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
  ], PBRMaterial2.prototype, "alphaCutOff", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "useSpecularOverAlpha", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "useMicroSurfaceFromReflectivityMapAlpha", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "useRoughnessFromMetallicTextureAlpha", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "useRoughnessFromMetallicTextureGreen", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "useMetallnessFromMetallicTextureBlue", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "useAmbientOcclusionFromMetallicTextureRed", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "useAmbientInGrayScale", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "useAutoMicroSurfaceFromReflectivityMap", void 0);
  __decorate([
    serialize()
  ], PBRMaterial2.prototype, "usePhysicalLightFalloff", null);
  __decorate([
    serialize()
  ], PBRMaterial2.prototype, "useGLTFLightFalloff", null);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "useRadianceOverAlpha", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "useObjectSpaceNormalMap", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "useParallax", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "useParallaxOcclusion", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "parallaxScaleBias", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsLightsDirty")
  ], PBRMaterial2.prototype, "disableLighting", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "forceIrradianceInFragment", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsLightsDirty")
  ], PBRMaterial2.prototype, "maxSimultaneousLights", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "invertNormalMapX", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "invertNormalMapY", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "twoSidedLighting", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "useAlphaFresnel", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "useLinearAlphaFresnel", void 0);
  __decorate([
    serializeAsTexture(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "environmentBRDFTexture", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "forceNormalForward", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "enableSpecularAntiAliasing", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "useHorizonOcclusion", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], PBRMaterial2.prototype, "useRadianceOcclusion", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsMiscDirty")
  ], PBRMaterial2.prototype, "unlit", void 0);
  return PBRMaterial2;
}(PBRBaseMaterial);
_TypeStore.RegisteredTypes["BABYLON.PBRMaterial"] = PBRMaterial;

// node_modules/@babylonjs/core/Misc/workerPool.js
var WorkerPool = function() {
  function WorkerPool2(workers) {
    this._pendingActions = new Array();
    this._workerInfos = workers.map(function(worker2) {
      return {
        worker: worker2,
        active: false
      };
    });
  }
  WorkerPool2.prototype.dispose = function() {
    for (var _i = 0, _a = this._workerInfos; _i < _a.length; _i++) {
      var workerInfo = _a[_i];
      workerInfo.worker.terminate();
    }
    this._workerInfos = [];
    this._pendingActions = [];
  };
  WorkerPool2.prototype.push = function(action) {
    for (var _i = 0, _a = this._workerInfos; _i < _a.length; _i++) {
      var workerInfo = _a[_i];
      if (!workerInfo.active) {
        this._execute(workerInfo, action);
        return;
      }
    }
    this._pendingActions.push(action);
  };
  WorkerPool2.prototype._execute = function(workerInfo, action) {
    var _this = this;
    workerInfo.active = true;
    action(workerInfo.worker, function() {
      workerInfo.active = false;
      var nextAction = _this._pendingActions.shift();
      if (nextAction) {
        _this._execute(workerInfo, nextAction);
      }
    });
  };
  return WorkerPool2;
}();

// node_modules/@babylonjs/core/Lights/pointLight.js
Node.AddNodeConstructor("Light_Type_0", function(name42, scene) {
  return function() {
    return new PointLight(name42, Vector3.Zero(), scene);
  };
});
var PointLight = function(_super) {
  __extends(PointLight2, _super);
  function PointLight2(name42, position, scene) {
    var _this = _super.call(this, name42, scene) || this;
    _this._shadowAngle = Math.PI / 2;
    _this.position = position;
    return _this;
  }
  Object.defineProperty(PointLight2.prototype, "shadowAngle", {
    get: function() {
      return this._shadowAngle;
    },
    set: function(value) {
      this._shadowAngle = value;
      this.forceProjectionMatrixCompute();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PointLight2.prototype, "direction", {
    get: function() {
      return this._direction;
    },
    set: function(value) {
      var previousNeedCube = this.needCube();
      this._direction = value;
      if (this.needCube() !== previousNeedCube && this._shadowGenerator) {
        this._shadowGenerator.recreateShadowMap();
      }
    },
    enumerable: false,
    configurable: true
  });
  PointLight2.prototype.getClassName = function() {
    return "PointLight";
  };
  PointLight2.prototype.getTypeID = function() {
    return Light.LIGHTTYPEID_POINTLIGHT;
  };
  PointLight2.prototype.needCube = function() {
    return !this.direction;
  };
  PointLight2.prototype.getShadowDirection = function(faceIndex) {
    if (this.direction) {
      return _super.prototype.getShadowDirection.call(this, faceIndex);
    } else {
      switch (faceIndex) {
        case 0:
          return new Vector3(1, 0, 0);
        case 1:
          return new Vector3(-1, 0, 0);
        case 2:
          return new Vector3(0, -1, 0);
        case 3:
          return new Vector3(0, 1, 0);
        case 4:
          return new Vector3(0, 0, 1);
        case 5:
          return new Vector3(0, 0, -1);
      }
    }
    return Vector3.Zero();
  };
  PointLight2.prototype._setDefaultShadowProjectionMatrix = function(matrix, viewMatrix, renderList) {
    var activeCamera = this.getScene().activeCamera;
    if (!activeCamera) {
      return;
    }
    Matrix.PerspectiveFovLHToRef(this.shadowAngle, 1, this.getDepthMinZ(activeCamera), this.getDepthMaxZ(activeCamera), matrix);
  };
  PointLight2.prototype._buildUniformLayout = function() {
    this._uniformBuffer.addUniform("vLightData", 4);
    this._uniformBuffer.addUniform("vLightDiffuse", 4);
    this._uniformBuffer.addUniform("vLightSpecular", 4);
    this._uniformBuffer.addUniform("vLightFalloff", 4);
    this._uniformBuffer.addUniform("shadowsInfo", 3);
    this._uniformBuffer.addUniform("depthValues", 2);
    this._uniformBuffer.create();
  };
  PointLight2.prototype.transferToEffect = function(effect, lightIndex) {
    if (this.computeTransformedInformation()) {
      this._uniformBuffer.updateFloat4("vLightData", this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z, 0, lightIndex);
    } else {
      this._uniformBuffer.updateFloat4("vLightData", this.position.x, this.position.y, this.position.z, 0, lightIndex);
    }
    this._uniformBuffer.updateFloat4("vLightFalloff", this.range, this._inverseSquaredRange, 0, 0, lightIndex);
    return this;
  };
  PointLight2.prototype.transferToNodeMaterialEffect = function(effect, lightDataUniformName) {
    if (this.computeTransformedInformation()) {
      effect.setFloat3(lightDataUniformName, this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z);
    } else {
      effect.setFloat3(lightDataUniformName, this.position.x, this.position.y, this.position.z);
    }
    return this;
  };
  PointLight2.prototype.prepareLightSpecificDefines = function(defines, lightIndex) {
    defines["POINTLIGHT" + lightIndex] = true;
  };
  __decorate([
    serialize()
  ], PointLight2.prototype, "shadowAngle", null);
  return PointLight2;
}(ShadowLight);

// node_modules/@babylonjs/core/Morph/morphTarget.js
var MorphTarget = function() {
  function MorphTarget2(name42, influence, scene) {
    if (influence === void 0) {
      influence = 0;
    }
    if (scene === void 0) {
      scene = null;
    }
    this.name = name42;
    this.animations = new Array();
    this._positions = null;
    this._normals = null;
    this._tangents = null;
    this._uvs = null;
    this._uniqueId = 0;
    this.onInfluenceChanged = new Observable();
    this._onDataLayoutChanged = new Observable();
    this._animationPropertiesOverride = null;
    this._scene = scene || EngineStore.LastCreatedScene;
    this.influence = influence;
    if (this._scene) {
      this._uniqueId = this._scene.getUniqueId();
    }
  }
  Object.defineProperty(MorphTarget2.prototype, "influence", {
    get: function() {
      return this._influence;
    },
    set: function(influence) {
      if (this._influence === influence) {
        return;
      }
      var previous = this._influence;
      this._influence = influence;
      if (this.onInfluenceChanged.hasObservers()) {
        this.onInfluenceChanged.notifyObservers(previous === 0 || influence === 0);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MorphTarget2.prototype, "animationPropertiesOverride", {
    get: function() {
      if (!this._animationPropertiesOverride && this._scene) {
        return this._scene.animationPropertiesOverride;
      }
      return this._animationPropertiesOverride;
    },
    set: function(value) {
      this._animationPropertiesOverride = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MorphTarget2.prototype, "uniqueId", {
    get: function() {
      return this._uniqueId;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MorphTarget2.prototype, "hasPositions", {
    get: function() {
      return !!this._positions;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MorphTarget2.prototype, "hasNormals", {
    get: function() {
      return !!this._normals;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MorphTarget2.prototype, "hasTangents", {
    get: function() {
      return !!this._tangents;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MorphTarget2.prototype, "hasUVs", {
    get: function() {
      return !!this._uvs;
    },
    enumerable: false,
    configurable: true
  });
  MorphTarget2.prototype.setPositions = function(data) {
    var hadPositions = this.hasPositions;
    this._positions = data;
    if (hadPositions !== this.hasPositions) {
      this._onDataLayoutChanged.notifyObservers(void 0);
    }
  };
  MorphTarget2.prototype.getPositions = function() {
    return this._positions;
  };
  MorphTarget2.prototype.setNormals = function(data) {
    var hadNormals = this.hasNormals;
    this._normals = data;
    if (hadNormals !== this.hasNormals) {
      this._onDataLayoutChanged.notifyObservers(void 0);
    }
  };
  MorphTarget2.prototype.getNormals = function() {
    return this._normals;
  };
  MorphTarget2.prototype.setTangents = function(data) {
    var hadTangents = this.hasTangents;
    this._tangents = data;
    if (hadTangents !== this.hasTangents) {
      this._onDataLayoutChanged.notifyObservers(void 0);
    }
  };
  MorphTarget2.prototype.getTangents = function() {
    return this._tangents;
  };
  MorphTarget2.prototype.setUVs = function(data) {
    var hadUVs = this.hasUVs;
    this._uvs = data;
    if (hadUVs !== this.hasUVs) {
      this._onDataLayoutChanged.notifyObservers(void 0);
    }
  };
  MorphTarget2.prototype.getUVs = function() {
    return this._uvs;
  };
  MorphTarget2.prototype.clone = function() {
    var _this = this;
    var newOne = SerializationHelper.Clone(function() {
      return new MorphTarget2(_this.name, _this.influence, _this._scene);
    }, this);
    newOne._positions = this._positions;
    newOne._normals = this._normals;
    newOne._tangents = this._tangents;
    newOne._uvs = this._uvs;
    return newOne;
  };
  MorphTarget2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.name = this.name;
    serializationObject.influence = this.influence;
    serializationObject.positions = Array.prototype.slice.call(this.getPositions());
    if (this.id != null) {
      serializationObject.id = this.id;
    }
    if (this.hasNormals) {
      serializationObject.normals = Array.prototype.slice.call(this.getNormals());
    }
    if (this.hasTangents) {
      serializationObject.tangents = Array.prototype.slice.call(this.getTangents());
    }
    if (this.hasUVs) {
      serializationObject.uvs = Array.prototype.slice.call(this.getUVs());
    }
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    return serializationObject;
  };
  MorphTarget2.prototype.getClassName = function() {
    return "MorphTarget";
  };
  MorphTarget2.Parse = function(serializationObject) {
    var result = new MorphTarget2(serializationObject.name, serializationObject.influence);
    result.setPositions(serializationObject.positions);
    if (serializationObject.id != null) {
      result.id = serializationObject.id;
    }
    if (serializationObject.normals) {
      result.setNormals(serializationObject.normals);
    }
    if (serializationObject.tangents) {
      result.setTangents(serializationObject.tangents);
    }
    if (serializationObject.uvs) {
      result.setUVs(serializationObject.uvs);
    }
    if (serializationObject.animations) {
      for (var animationIndex = 0; animationIndex < serializationObject.animations.length; animationIndex++) {
        var parsedAnimation = serializationObject.animations[animationIndex];
        var internalClass = _TypeStore.GetClass("BABYLON.Animation");
        if (internalClass) {
          result.animations.push(internalClass.Parse(parsedAnimation));
        }
      }
    }
    return result;
  };
  MorphTarget2.FromMesh = function(mesh, name42, influence) {
    if (!name42) {
      name42 = mesh.name;
    }
    var result = new MorphTarget2(name42, influence, mesh.getScene());
    result.setPositions(mesh.getVerticesData(VertexBuffer.PositionKind));
    if (mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      result.setNormals(mesh.getVerticesData(VertexBuffer.NormalKind));
    }
    if (mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {
      result.setTangents(mesh.getVerticesData(VertexBuffer.TangentKind));
    }
    if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
      result.setUVs(mesh.getVerticesData(VertexBuffer.UVKind));
    }
    return result;
  };
  __decorate([
    serialize()
  ], MorphTarget2.prototype, "id", void 0);
  return MorphTarget2;
}();

// node_modules/@babylonjs/core/Morph/morphTargetManager.js
var MorphTargetManager = function() {
  function MorphTargetManager2(scene) {
    if (scene === void 0) {
      scene = null;
    }
    this._targets = new Array();
    this._targetInfluenceChangedObservers = new Array();
    this._targetDataLayoutChangedObservers = new Array();
    this._activeTargets = new SmartArray(16);
    this._supportsNormals = false;
    this._supportsTangents = false;
    this._supportsUVs = false;
    this._vertexCount = 0;
    this._uniqueId = 0;
    this._tempInfluences = new Array();
    this.enableNormalMorphing = true;
    this.enableTangentMorphing = true;
    this.enableUVMorphing = true;
    if (!scene) {
      scene = EngineStore.LastCreatedScene;
    }
    this._scene = scene;
    if (this._scene) {
      this._scene.morphTargetManagers.push(this);
      this._uniqueId = this._scene.getUniqueId();
    }
  }
  Object.defineProperty(MorphTargetManager2.prototype, "uniqueId", {
    get: function() {
      return this._uniqueId;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MorphTargetManager2.prototype, "vertexCount", {
    get: function() {
      return this._vertexCount;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MorphTargetManager2.prototype, "supportsNormals", {
    get: function() {
      return this._supportsNormals && this.enableNormalMorphing;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MorphTargetManager2.prototype, "supportsTangents", {
    get: function() {
      return this._supportsTangents && this.enableTangentMorphing;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MorphTargetManager2.prototype, "supportsUVs", {
    get: function() {
      return this._supportsUVs && this.enableUVMorphing;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MorphTargetManager2.prototype, "numTargets", {
    get: function() {
      return this._targets.length;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MorphTargetManager2.prototype, "numInfluencers", {
    get: function() {
      return this._activeTargets.length;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MorphTargetManager2.prototype, "influences", {
    get: function() {
      return this._influences;
    },
    enumerable: false,
    configurable: true
  });
  MorphTargetManager2.prototype.getActiveTarget = function(index) {
    return this._activeTargets.data[index];
  };
  MorphTargetManager2.prototype.getTarget = function(index) {
    return this._targets[index];
  };
  MorphTargetManager2.prototype.addTarget = function(target) {
    var _this = this;
    this._targets.push(target);
    this._targetInfluenceChangedObservers.push(target.onInfluenceChanged.add(function(needUpdate) {
      _this._syncActiveTargets(needUpdate);
    }));
    this._targetDataLayoutChangedObservers.push(target._onDataLayoutChanged.add(function() {
      _this._syncActiveTargets(true);
    }));
    this._syncActiveTargets(true);
  };
  MorphTargetManager2.prototype.removeTarget = function(target) {
    var index = this._targets.indexOf(target);
    if (index >= 0) {
      this._targets.splice(index, 1);
      target.onInfluenceChanged.remove(this._targetInfluenceChangedObservers.splice(index, 1)[0]);
      target._onDataLayoutChanged.remove(this._targetDataLayoutChangedObservers.splice(index, 1)[0]);
      this._syncActiveTargets(true);
    }
  };
  MorphTargetManager2.prototype.clone = function() {
    var copy = new MorphTargetManager2(this._scene);
    for (var _i = 0, _a = this._targets; _i < _a.length; _i++) {
      var target = _a[_i];
      copy.addTarget(target.clone());
    }
    copy.enableNormalMorphing = this.enableNormalMorphing;
    copy.enableTangentMorphing = this.enableTangentMorphing;
    copy.enableUVMorphing = this.enableUVMorphing;
    return copy;
  };
  MorphTargetManager2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.id = this.uniqueId;
    serializationObject.targets = [];
    for (var _i = 0, _a = this._targets; _i < _a.length; _i++) {
      var target = _a[_i];
      serializationObject.targets.push(target.serialize());
    }
    return serializationObject;
  };
  MorphTargetManager2.prototype._syncActiveTargets = function(needUpdate) {
    var influenceCount = 0;
    this._activeTargets.reset();
    this._supportsNormals = true;
    this._supportsTangents = true;
    this._supportsUVs = true;
    this._vertexCount = 0;
    for (var _i = 0, _a = this._targets; _i < _a.length; _i++) {
      var target = _a[_i];
      if (target.influence === 0) {
        continue;
      }
      this._activeTargets.push(target);
      this._tempInfluences[influenceCount++] = target.influence;
      this._supportsNormals = this._supportsNormals && target.hasNormals;
      this._supportsTangents = this._supportsTangents && target.hasTangents;
      this._supportsUVs = this._supportsUVs && target.hasUVs;
      var positions = target.getPositions();
      if (positions) {
        var vertexCount = positions.length / 3;
        if (this._vertexCount === 0) {
          this._vertexCount = vertexCount;
        } else if (this._vertexCount !== vertexCount) {
          Logger.Error("Incompatible target. Targets must all have the same vertices count.");
          return;
        }
      }
    }
    if (!this._influences || this._influences.length !== influenceCount) {
      this._influences = new Float32Array(influenceCount);
    }
    for (var index = 0; index < influenceCount; index++) {
      this._influences[index] = this._tempInfluences[index];
    }
    if (needUpdate) {
      this.synchronize();
    }
  };
  MorphTargetManager2.prototype.synchronize = function() {
    if (!this._scene) {
      return;
    }
    for (var _i = 0, _a = this._scene.meshes; _i < _a.length; _i++) {
      var mesh = _a[_i];
      if (mesh.morphTargetManager === this) {
        mesh._syncGeometryWithMorphTargetManager();
      }
    }
  };
  MorphTargetManager2.Parse = function(serializationObject, scene) {
    var result = new MorphTargetManager2(scene);
    result._uniqueId = serializationObject.id;
    for (var _i = 0, _a = serializationObject.targets; _i < _a.length; _i++) {
      var targetData = _a[_i];
      result.addTarget(MorphTarget.Parse(targetData));
    }
    return result;
  };
  return MorphTargetManager2;
}();

// node_modules/@babylonjs/core/Materials/Textures/rawCubeTexture.js
var RawCubeTexture = function(_super) {
  __extends(RawCubeTexture2, _super);
  function RawCubeTexture2(scene, data, size, format, type, generateMipMaps, invertY, samplingMode, compression) {
    if (format === void 0) {
      format = 5;
    }
    if (type === void 0) {
      type = 0;
    }
    if (generateMipMaps === void 0) {
      generateMipMaps = false;
    }
    if (invertY === void 0) {
      invertY = false;
    }
    if (samplingMode === void 0) {
      samplingMode = 3;
    }
    if (compression === void 0) {
      compression = null;
    }
    var _this = _super.call(this, "", scene) || this;
    _this._texture = scene.getEngine().createRawCubeTexture(data, size, format, type, generateMipMaps, invertY, samplingMode, compression);
    return _this;
  }
  RawCubeTexture2.prototype.update = function(data, format, type, invertY, compression) {
    if (compression === void 0) {
      compression = null;
    }
    this._texture.getEngine().updateRawCubeTexture(this._texture, data, format, type, invertY, compression);
  };
  RawCubeTexture2.prototype.updateRGBDAsync = function(data, sphericalPolynomial, lodScale, lodOffset) {
    if (sphericalPolynomial === void 0) {
      sphericalPolynomial = null;
    }
    if (lodScale === void 0) {
      lodScale = 0.8;
    }
    if (lodOffset === void 0) {
      lodOffset = 0;
    }
    return RawCubeTexture2._UpdateRGBDAsync(this._texture, data, sphericalPolynomial, lodScale, lodOffset);
  };
  RawCubeTexture2.prototype.clone = function() {
    var _this = this;
    return SerializationHelper.Clone(function() {
      var scene = _this.getScene();
      var internalTexture = _this._texture;
      var texture = new RawCubeTexture2(scene, internalTexture._bufferViewArray, internalTexture.width, internalTexture.format, internalTexture.type, internalTexture.generateMipMaps, internalTexture.invertY, internalTexture.samplingMode, internalTexture._compression);
      if (internalTexture.source === InternalTextureSource.CubeRawRGBD) {
        texture.updateRGBDAsync(internalTexture._bufferViewArrayArray, internalTexture._sphericalPolynomial, internalTexture._lodGenerationScale, internalTexture._lodGenerationOffset);
      }
      return texture;
    }, this);
  };
  RawCubeTexture2._UpdateRGBDAsync = function(internalTexture, data, sphericalPolynomial, lodScale, lodOffset) {
    internalTexture._source = InternalTextureSource.CubeRawRGBD;
    internalTexture._bufferViewArrayArray = data;
    internalTexture._lodGenerationScale = lodScale;
    internalTexture._lodGenerationOffset = lodOffset;
    internalTexture._sphericalPolynomial = sphericalPolynomial;
    return EnvironmentTextureTools.UploadLevelsAsync(internalTexture, data).then(function() {
      internalTexture.isReady = true;
    });
  };
  return RawCubeTexture2;
}(CubeTexture);

// node_modules/@babylonjs/core/Meshes/Compression/dracoCompression.js
function createDecoderAsync(wasmBinary) {
  return new Promise(function(resolve) {
    DracoDecoderModule({ wasmBinary }).then(function(module) {
      resolve({ module });
    });
  });
}
function decodeMesh(decoderModule, dataView, attributes, onIndicesData, onAttributeData) {
  var buffer = new decoderModule.DecoderBuffer();
  buffer.Init(dataView, dataView.byteLength);
  var decoder = new decoderModule.Decoder();
  var geometry;
  var status;
  try {
    var type = decoder.GetEncodedGeometryType(buffer);
    switch (type) {
      case decoderModule.TRIANGULAR_MESH:
        geometry = new decoderModule.Mesh();
        status = decoder.DecodeBufferToMesh(buffer, geometry);
        break;
      case decoderModule.POINT_CLOUD:
        geometry = new decoderModule.PointCloud();
        status = decoder.DecodeBufferToPointCloud(buffer, geometry);
        break;
      default:
        throw new Error("Invalid geometry type " + type);
    }
    if (!status.ok() || !geometry.ptr) {
      throw new Error(status.error_msg());
    }
    if (type === decoderModule.TRIANGULAR_MESH) {
      var numFaces = geometry.num_faces();
      var numIndices = numFaces * 3;
      var byteLength = numIndices * 4;
      var ptr = decoderModule._malloc(byteLength);
      try {
        decoder.GetTrianglesUInt32Array(geometry, byteLength, ptr);
        var indices = new Uint32Array(numIndices);
        indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));
        onIndicesData(indices);
      } finally {
        decoderModule._free(ptr);
      }
    }
    var processAttribute = function(kind2, attribute2) {
      var numComponents = attribute2.num_components();
      var numPoints = geometry.num_points();
      var numValues = numPoints * numComponents;
      var byteLength2 = numValues * Float32Array.BYTES_PER_ELEMENT;
      var ptr2 = decoderModule._malloc(byteLength2);
      try {
        decoder.GetAttributeDataArrayForAllPoints(geometry, attribute2, decoderModule.DT_FLOAT32, byteLength2, ptr2);
        var values = new Float32Array(decoderModule.HEAPF32.buffer, ptr2, numValues);
        if (kind2 === "color" && numComponents === 3) {
          var babylonData = new Float32Array(numPoints * 4);
          for (var i = 0, j = 0; i < babylonData.length; i += 4, j += numComponents) {
            babylonData[i + 0] = values[j + 0];
            babylonData[i + 1] = values[j + 1];
            babylonData[i + 2] = values[j + 2];
            babylonData[i + 3] = 1;
          }
          onAttributeData(kind2, babylonData);
        } else {
          var babylonData = new Float32Array(numValues);
          babylonData.set(new Float32Array(decoderModule.HEAPF32.buffer, ptr2, numValues));
          onAttributeData(kind2, babylonData);
        }
      } finally {
        decoderModule._free(ptr2);
      }
    };
    if (attributes) {
      for (var kind in attributes) {
        var id = attributes[kind];
        var attribute = decoder.GetAttributeByUniqueId(geometry, id);
        processAttribute(kind, attribute);
      }
    } else {
      var nativeAttributeTypes = {
        "position": "POSITION",
        "normal": "NORMAL",
        "color": "COLOR",
        "uv": "TEX_COORD"
      };
      for (var kind in nativeAttributeTypes) {
        var id = decoder.GetAttributeId(geometry, decoderModule[nativeAttributeTypes[kind]]);
        if (id !== -1) {
          var attribute = decoder.GetAttribute(geometry, id);
          processAttribute(kind, attribute);
        }
      }
    }
  } finally {
    if (geometry) {
      decoderModule.destroy(geometry);
    }
    decoderModule.destroy(decoder);
    decoderModule.destroy(buffer);
  }
}
function worker() {
  var decoderPromise;
  onmessage = function(event) {
    var data = event.data;
    switch (data.id) {
      case "init": {
        var decoder = data.decoder;
        if (decoder.url) {
          importScripts(decoder.url);
          decoderPromise = DracoDecoderModule({ wasmBinary: decoder.wasmBinary });
        }
        postMessage("done");
        break;
      }
      case "decodeMesh": {
        if (!decoderPromise) {
          throw new Error("Draco decoder module is not available");
        }
        decoderPromise.then(function(decoder2) {
          decodeMesh(decoder2, data.dataView, data.attributes, function(indices) {
            postMessage({ id: "indices", value: indices }, [indices.buffer]);
          }, function(kind, data2) {
            postMessage({ id: kind, value: data2 }, [data2.buffer]);
          });
          postMessage("done");
        });
        break;
      }
    }
  };
}
function getAbsoluteUrl(url) {
  if (typeof document !== "object" || typeof url !== "string") {
    return url;
  }
  return Tools.GetAbsoluteUrl(url);
}
var DracoCompression = function() {
  function DracoCompression2(numWorkers) {
    if (numWorkers === void 0) {
      numWorkers = DracoCompression2.DefaultNumWorkers;
    }
    var decoder = DracoCompression2.Configuration.decoder;
    var decoderInfo = decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === "object" ? {
      url: decoder.wasmUrl,
      wasmBinaryPromise: Tools.LoadFileAsync(getAbsoluteUrl(decoder.wasmBinaryUrl))
    } : {
      url: decoder.fallbackUrl,
      wasmBinaryPromise: Promise.resolve(void 0)
    };
    if (numWorkers && typeof Worker === "function") {
      this._workerPoolPromise = decoderInfo.wasmBinaryPromise.then(function(decoderWasmBinary) {
        var workerContent = decodeMesh + "(" + worker + ")()";
        var workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: "application/javascript" }));
        var workerPromises = new Array(numWorkers);
        for (var i = 0; i < workerPromises.length; i++) {
          workerPromises[i] = new Promise(function(resolve, reject) {
            var worker2 = new Worker(workerBlobUrl);
            var onError = function(error) {
              worker2.removeEventListener("error", onError);
              worker2.removeEventListener("message", onMessage);
              reject(error);
            };
            var onMessage = function(message) {
              if (message.data === "done") {
                worker2.removeEventListener("error", onError);
                worker2.removeEventListener("message", onMessage);
                resolve(worker2);
              }
            };
            worker2.addEventListener("error", onError);
            worker2.addEventListener("message", onMessage);
            worker2.postMessage({
              id: "init",
              decoder: {
                url: getAbsoluteUrl(decoderInfo.url),
                wasmBinary: decoderWasmBinary
              }
            });
          });
        }
        return Promise.all(workerPromises).then(function(workers) {
          return new WorkerPool(workers);
        });
      });
    } else {
      this._decoderModulePromise = decoderInfo.wasmBinaryPromise.then(function(decoderWasmBinary) {
        if (!decoderInfo.url) {
          throw new Error("Draco decoder module is not available");
        }
        return Tools.LoadScriptAsync(decoderInfo.url).then(function() {
          return createDecoderAsync(decoderWasmBinary);
        });
      });
    }
  }
  Object.defineProperty(DracoCompression2, "DecoderAvailable", {
    get: function() {
      var decoder = DracoCompression2.Configuration.decoder;
      return !!(decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === "object" || decoder.fallbackUrl);
    },
    enumerable: false,
    configurable: true
  });
  DracoCompression2.GetDefaultNumWorkers = function() {
    if (typeof navigator !== "object" || !navigator.hardwareConcurrency) {
      return 1;
    }
    return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);
  };
  Object.defineProperty(DracoCompression2, "Default", {
    get: function() {
      if (!DracoCompression2._Default) {
        DracoCompression2._Default = new DracoCompression2();
      }
      return DracoCompression2._Default;
    },
    enumerable: false,
    configurable: true
  });
  DracoCompression2.prototype.dispose = function() {
    if (this._workerPoolPromise) {
      this._workerPoolPromise.then(function(workerPool) {
        workerPool.dispose();
      });
    }
    delete this._workerPoolPromise;
    delete this._decoderModulePromise;
  };
  DracoCompression2.prototype.whenReadyAsync = function() {
    if (this._workerPoolPromise) {
      return this._workerPoolPromise.then(function() {
      });
    }
    if (this._decoderModulePromise) {
      return this._decoderModulePromise.then(function() {
      });
    }
    return Promise.resolve();
  };
  DracoCompression2.prototype.decodeMeshAsync = function(data, attributes) {
    var dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;
    if (this._workerPoolPromise) {
      return this._workerPoolPromise.then(function(workerPool) {
        return new Promise(function(resolve, reject) {
          workerPool.push(function(worker2, onComplete) {
            var vertexData = new VertexData();
            var onError = function(error) {
              worker2.removeEventListener("error", onError);
              worker2.removeEventListener("message", onMessage);
              reject(error);
              onComplete();
            };
            var onMessage = function(message) {
              if (message.data === "done") {
                worker2.removeEventListener("error", onError);
                worker2.removeEventListener("message", onMessage);
                resolve(vertexData);
                onComplete();
              } else if (message.data.id === "indices") {
                vertexData.indices = message.data.value;
              } else {
                vertexData.set(message.data.value, message.data.id);
              }
            };
            worker2.addEventListener("error", onError);
            worker2.addEventListener("message", onMessage);
            var dataViewCopy = new Uint8Array(dataView.byteLength);
            dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));
            worker2.postMessage({ id: "decodeMesh", dataView: dataViewCopy, attributes }, [dataViewCopy.buffer]);
          });
        });
      });
    }
    if (this._decoderModulePromise) {
      return this._decoderModulePromise.then(function(decoder) {
        var vertexData = new VertexData();
        decodeMesh(decoder.module, dataView, attributes, function(indices) {
          vertexData.indices = indices;
        }, function(kind, data2) {
          vertexData.set(data2, kind);
        });
        return vertexData;
      });
    }
    throw new Error("Draco decoder module is not available");
  };
  DracoCompression2.Configuration = {
    decoder: {
      wasmUrl: "https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js",
      wasmBinaryUrl: "https://preview.babylonjs.com/draco_decoder_gltf.wasm",
      fallbackUrl: "https://preview.babylonjs.com/draco_decoder_gltf.js"
    }
  };
  DracoCompression2.DefaultNumWorkers = DracoCompression2.GetDefaultNumWorkers();
  DracoCompression2._Default = null;
  return DracoCompression2;
}();

// node_modules/@babylonjs/core/Misc/deferred.js
var Deferred = function() {
  function Deferred2() {
    var _this = this;
    this.promise = new Promise(function(resolve, reject) {
      _this._resolve = resolve;
      _this._reject = reject;
    });
  }
  Object.defineProperty(Deferred2.prototype, "resolve", {
    get: function() {
      return this._resolve;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Deferred2.prototype, "reject", {
    get: function() {
      return this._reject;
    },
    enumerable: false,
    configurable: true
  });
  return Deferred2;
}();

// node_modules/@babylonjs/core/Misc/dataReader.js
var DataReader = function() {
  function DataReader2(buffer) {
    this.byteOffset = 0;
    this.buffer = buffer;
  }
  DataReader2.prototype.loadAsync = function(byteLength) {
    var _this = this;
    return this.buffer.readAsync(this.byteOffset, byteLength).then(function(data) {
      _this._dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
      _this._dataByteOffset = 0;
    });
  };
  DataReader2.prototype.readUint32 = function() {
    var value = this._dataView.getUint32(this._dataByteOffset, true);
    this._dataByteOffset += 4;
    this.byteOffset += 4;
    return value;
  };
  DataReader2.prototype.readUint8Array = function(byteLength) {
    var value = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._dataByteOffset, byteLength);
    this._dataByteOffset += byteLength;
    this.byteOffset += byteLength;
    return value;
  };
  DataReader2.prototype.readString = function(byteLength) {
    return StringTools.Decode(this.readUint8Array(byteLength));
  };
  DataReader2.prototype.skipBytes = function(byteLength) {
    this._dataByteOffset += byteLength;
    this.byteOffset += byteLength;
  };
  return DataReader2;
}();

export {
  AnimationKeyInterpolation,
  AnimationRange,
  _IAnimationState,
  Animation,
  RuntimeAnimation,
  Bone,
  Animatable,
  TargetedAnimation,
  AnimationGroup,
  AnimationEvent,
  KeepAssets,
  InstantiatedEntries,
  AssetContainer,
  Sound,
  WeightedSound,
  RawTexture,
  Skeleton,
  CameraInputTypes,
  CameraInputsManager,
  FreeCameraKeyboardMoveInput,
  FreeCameraMouseInput,
  FreeCameraMouseWheelInput,
  FreeCameraTouchInput,
  FreeCameraInputsManager,
  TargetCamera,
  FreeCamera,
  PostProcess,
  RenderTargetTexture,
  ShaderMaterial,
  SphericalHarmonics,
  SphericalPolynomial,
  CubeMapToSphericalPolynomialTools,
  EnvironmentTextureTools,
  SceneLoaderAnimationGroupLoadingMode,
  SceneLoader,
  ShadowLight,
  DirectionalLight,
  SpotLight,
  CubeTexture,
  RGBDTextureTools,
  BRDFTextureTools,
  PBRClearCoatConfiguration,
  PBRMaterialDefines,
  PBRBaseMaterial,
  PBRMaterial,
  WorkerPool,
  PointLight,
  MorphTarget,
  MorphTargetManager,
  RawCubeTexture,
  DracoCompression,
  Deferred,
  DataReader
};
//# sourceMappingURL=chunk-KAF3XFTO.js.map
